[
    {
        "content": "<p>I would like to have a go at proving Montel's theorem, which in my head is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">montel</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hU</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hF1</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">differentiable_on</span> <span class=\"n\">‚ÑÇ</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hF2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">is_compact</span> <span class=\"n\">K</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">z</span> <span class=\"bp\">‚àà</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"bp\">‚Äñ</span><span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">z</span><span class=\"bp\">‚Äñ</span> <span class=\"bp\">‚â§</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span>\n  <span class=\"bp\">‚àÉ</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">),</span> <span class=\"n\">tendsto</span> <span class=\"n\">œÜ</span> <span class=\"n\">at_top</span> <span class=\"n\">at_top</span> <span class=\"bp\">‚àß</span>\n    <span class=\"n\">tendsto_locally_uniformly_on</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">f</span> <span class=\"n\">at_top</span> <span class=\"n\">U</span>\n</code></pre></div>\n<p>On paper I would say something along the lines of \"up to a diagonal extraction it is enough to work on a fixed compact set, and on a compact set this is just a simple application of Arzela-Ascoli with a bound on the modulus of continuity obtained by Cauchy's integral formula for the derivative\". But that is not very formal... so I need some advice.</p>\n<ul>\n<li>probably the right mathlib-ish statement at the right level of generality would be stated in terms of various filters rather than on sequences, but my experience in this domain is not good enough to figure it out exactly. What would the appropriate statement be? [As far as I am concerned, the sequential statement is enough for what I want to do with it.]</li>\n<li>it feels natural to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function.arzela_ascoli\">docs#bounded_continuous_function.arzela_ascoli</a> but this is written in terms of <code>bounded_continuous_function</code> while all of the complex analysis in mathlib is written in terms of <code>differentiable_on</code> for <code>f : \\C \\to \\C</code> and going back and forth between them is a bit painful.</li>\n</ul>\n<p>So in fact I am tempted to write the more general version of Arzela-Ascoli directly under locally uniform assumptions on an open set and derive <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function.arzela_ascoli\">docs#bounded_continuous_function.arzela_ascoli</a> from it, rather than the other way. Does that sound like a reasonable plan, or would it be better to go the other way?</p>",
        "id": 314199514,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1670319658
    },
    {
        "content": "<p>Not really answering your question, but <a href=\"https://github.com/leanprover-community/mathlib/pull/16467\">#16467</a> looks relevant.</p>",
        "id": 314202255,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1670320772
    },
    {
        "content": "<p>I think it would definitely make sense to have versions of Arzela-Ascoli for the topology of uniform convergence on some subset (this topology is defined in the file <code>topology/uniform_space/uniform_convergence_topology</code>), and also for the topology of locally uniform convergence on a family of subsets (but I don't think we have this one, although <code>tendsto_locally_uniformly</code> is defined). The current Arzela-Ascoli predates all these, so it is certainly improvable!</p>\n<p>I agree with you that proving a general statement for uniform convergence or locally uniform convergence and then deducing the current Arzela-Ascoli version from it is probably the right thing to do, because the other direction feels less natural.</p>",
        "id": 314204142,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1670321416
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> would probably have good ideas on what would be the best path here.</p>",
        "id": 314204265,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1670321460
    },
    {
        "content": "<p>In fact we also have the topology of uniform convergence on a family of subsets, on the type denoted with <code>Œ± ‚Üí·µ§[ùîñ] Œ≤</code>(where <code>ùîñ</code> is the set of sets where one requires uniform convergence), so the most general version of Arzela-Ascoli should probably be formulated for this one.</p>",
        "id": 314205591,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1670321978
    },
    {
        "content": "<p>Thanks for the pointers! In fact it might be a fair guess that <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> is actually working on that, because the whole <code>Œ± ‚Üí·µ§[ùîñ] Œ≤</code> type alias construction is following quite closely chapter X of Bourbaki TG and Ascoli is just a few pages further. IIUC the statements from there could be stated something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"n\">Œπ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí·µ§</span><span class=\"o\">[</span><span class=\"bp\">ùîñ</span><span class=\"o\">]</span> <span class=\"n\">Œ≤</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ascoli</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"bp\">ùîñ</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">is_compact</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">equicontinuous</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">set.restrict</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">totally_bounded</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n  <span class=\"n\">totally_bounded</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ascoli'</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"bp\">ùîñ</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">totally_bounded</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">uniform_equicontinuous</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">set.restrict</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">totally_bounded</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n  <span class=\"n\">totally_bounded</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>although a potentially useful generalization would assume something like along some filter on the index type, on any <code>A</code> the functions are eventually equicontinuous (but then I'm not sure what the conclusion should be).</p>",
        "id": 314424270,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1670409364
    },
    {
        "content": "<p>Anatole has his end of term exams next week so you cannot expect answers soon. But I'm sure he will easily handle all that later.</p>",
        "id": 314440145,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1670414946
    },
    {
        "content": "<p>Ah OK. I could give it a try myself but it's probably more natural if he does it...</p>",
        "id": 314441037,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1670415247
    },
    {
        "content": "<p>As a former student, isn't that the time of year when you're most easily distracted by non-exam things? But maybe Anatole is a better student than I was <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 314441118,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1670415287
    },
    {
        "content": "<p>I'm half expecting 500 lines of code from him at 2AM with a comment like \"now I have to study for my exams\" <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 314441535,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1670415432
    },
    {
        "content": "<p>I am in charge of the program where Anatole is studying...</p>",
        "id": 314455092,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1670419614
    },
    {
        "content": "<p>Sorry for the delay! I am indeed studying for my exams, so as Patrick said I am not going to have much time to devote to Lean until the end of the week, and much of this time is dedicated to keeping my PRs kind-of up-to-date, but the good news is that I won't have anything to do during the holidays, so I'll have plenty of Lean time then. But I wanted to give some answers already.<br>\nSo indeed, since <a href=\"https://github.com/leanprover-community/mathlib/pull/16467\">#16467</a> is merged, we now have equicontinuity, as well as the topologies of uniform convergence on the whole set and on some families of subsets. When I made the equicontinuity PR I decided not to completely refactor the current Arzela Ascoli (although I did some low-hanging steps, like equicontinuity being preserved by closure), because my main target was (and still is) the general Banach Steinhaus theorem, but I definitely wanted to go back to it if no one had done it earlier. So if you're okay to wait a bit and don't want to do it yourself, I would be happy to work on that in priority during the holidays!<br>\nAnother thing that has been in my mind is to adapt the uniform convergence topologies to our new <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tendsto_uniformly_on_filter\">docs#tendsto_uniformly_on_filter</a>. This would allow to truly have the topology of local uniform convergence without any trick like \"let's just say we mean uniform convergence on compact sets because we are working on a locally compact space\". I don't think this is in Bourbaki, but AFAIK this should be pretty straightforward.</p>",
        "id": 315104958,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1670691586
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/116395-maths/topic/Montel's.20theorem/near/314441118\">said</a>:</p>\n<blockquote>\n<p>As a former student, isn't that the time of year when you're most easily distracted by non-exam things? But maybe Anatole is a better student than I was <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n</blockquote>\n<p>Actually I used to do that a lot too, but for some reason I'm not falling into that this year. I guess one reason is that basically all of my courses are things I really like now, so when I'm bored of one subject, switching to anothere is just as tempting as a distraction as opening Lean or other things like that.</p>",
        "id": 315106011,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1670692171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/Montel's.20theorem/near/315106011\">said</a>:</p>\n<blockquote>\n<p>when I'm bored of one subject, switching to another is just as tempting as a distraction as opening Lean or other things like that.</p>\n</blockquote>\n<p>The Ya√´l is willing but the mind is weak <span aria-label=\"speechless\" class=\"emoji emoji-1f636\" role=\"img\" title=\"speechless\">:speechless:</span></p>",
        "id": 315115796,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1670698030
    },
    {
        "content": "<p>Hi, so I had a look at the type aliases for convergences, and got a bit lost. In particular, I didn't find a satisfactory way of stating that \"this and that uniform space structures induce the same uniformity on this particular set of functions\" (Lean kept reading what I wrote as a <code>rfl</code> in disguise because it saw a bit too much through type aliases.)</p>\n<p>OTOH I am now more motivated to try, because Montel's theorem is the last step missing for the Riemann mapping theorem: with it, the proof is complete in the sense that for every connected strict open set in the complex plane on which  every holomorphic function has a primitive, there is a bi-holomorphic bijection with the unit disk. A lot of the proof will likely have to be rewritten once contour integrals (and meromorphic functions) are in mathlib ... and given the state of the code, all that will likely have to happen after the flood</p>",
        "id": 315379802,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1670855099
    },
    {
        "content": "<p>Sorry for the delay, now I should be able to answer much more quickly <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> </p>\n<p>So indeed one downside of switching to type aliases is that you have to be careful about when to abuse defeq and when not. Note however that you can still refer to the uniform structure itself as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/uniform_fun.uniform_space\">docs#uniform_fun.uniform_space</a>, so the first \"solution\" is to embrace the <code>@</code>s and do everything by hand. <br>\nIf we want to keep the type aliases, we have to go to the other extreme and write <a href=\"https://leanprover-community.github.io/mathlib_docs/find/uniform_equiv\">docs#uniform_equiv</a> instead of equalities of uniform structure. But here I would need more information about your specific use case (in particular, when you say \"a set of functions\" do you mean some type or really some subset of <code>X -&gt; Y</code>?)</p>",
        "id": 316324017,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671212694
    },
    {
        "content": "<p>Okay so I started looking into Bourbaki's proof and I see where you have to do this kind of painful things. I think here there is no way to avoid a bunch of <code>@</code>s, but it shouldn't leak out too much so that should be fine <span aria-label=\"fingers crossed\" class=\"emoji emoji-1f91e\" role=\"img\" title=\"fingers crossed\">:fingers_crossed:</span></p>",
        "id": 316485734,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671296145
    },
    {
        "content": "<p>Here is a first sorry-free version!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.uniform_space.equicontinuity</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">filter</span> <span class=\"n\">uniform_space</span> <span class=\"n\">function</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">filter</span> <span class=\"n\">topological_space</span> <span class=\"n\">uniform_convergence</span> <span class=\"n\">uniformity</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cauchy_of_ne_bot</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">l.ne_bot</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">cauchy</span> <span class=\"n\">l</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">l</span> <span class=\"bp\">√ó·∂†</span> <span class=\"n\">l</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">ùì§</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">cauchy</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cauchy_pi</span> <span class=\"o\">{</span><span class=\"n\">Œπ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Œ†</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">uniform_space</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n  <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">Œ†</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Œ±</span> <span class=\"n\">i</span><span class=\"o\">)}</span> <span class=\"o\">[</span><span class=\"n\">l.ne_bot</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">cauchy</span> <span class=\"n\">l</span> <span class=\"bp\">‚Üî</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">cauchy_of_ne_bot</span><span class=\"o\">,</span> <span class=\"n\">prod_map_map_eq</span><span class=\"o\">,</span> <span class=\"n\">map_le_iff_le_comap</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformity</span><span class=\"o\">,</span> <span class=\"n\">le_infi_iff</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Œπ</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">theorem1</span> <span class=\"o\">[</span><span class=\"n\">compact_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">equicontinuous</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">uniform_fun.uniform_space</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniform_space</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">uniform_space.comap_mono</span> <span class=\"bp\">$</span> <span class=\"n\">le_iff_uniform_continuous_id.mpr</span> <span class=\"bp\">$</span>\n    <span class=\"n\">uniform_fun.uniform_continuous_to_fun</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">comap</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">ùì§</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">‚â§</span> <span class=\"n\">comap</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">ùì§</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformity</span><span class=\"o\">,</span> <span class=\"n\">filter.comap_infi</span><span class=\"o\">,</span> <span class=\"n\">filter.comap_comap</span><span class=\"o\">,</span> <span class=\"n\">function.comp</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"o\">((</span><span class=\"n\">uniform_fun.has_basis_uniformity</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">prod.map</span> <span class=\"n\">F</span> <span class=\"n\">F</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">ge_iff.mpr</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">U</span> <span class=\"n\">hU</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">comp_comp_symm_mem_uniformity_sets</span> <span class=\"n\">hU</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hV</span><span class=\"o\">,</span> <span class=\"n\">Vsymm</span><span class=\"o\">,</span> <span class=\"n\">hVU</span><span class=\"o\">‚ü©,</span>\n  <span class=\"k\">let</span> <span class=\"bp\">Œ©</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">‚àà</span> <span class=\"n\">V</span><span class=\"o\">},</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">compact_space.elim_nhds_subcover</span> <span class=\"bp\">Œ©</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hF</span> <span class=\"n\">x</span> <span class=\"n\">V</span> <span class=\"n\">hV</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">Scover</span><span class=\"o\">‚ü©,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">‚ãÇ</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">ij</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">√ó</span> <span class=\"n\">Œπ</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">ij.1</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">ij.2</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">‚àà</span> <span class=\"n\">V</span><span class=\"o\">})</span> <span class=\"bp\">‚äÜ</span>\n    <span class=\"o\">(</span><span class=\"n\">prod.map</span> <span class=\"n\">F</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">uniform_fun.gen</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">‚ü®</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">‚ü©</span> <span class=\"n\">hij</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mem_Inter‚ÇÇ</span> <span class=\"n\">at</span> <span class=\"n\">hij</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">mem_Union‚ÇÇ.mp</span> <span class=\"o\">(</span><span class=\"n\">Scover.symm.subset</span> <span class=\"bp\">$</span> <span class=\"n\">mem_univ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">hsx</span><span class=\"o\">‚ü©,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hVU</span> <span class=\"o\">(</span><span class=\"n\">prod_mk_mem_comp_rel</span> <span class=\"o\">(</span><span class=\"n\">prod_mk_mem_comp_rel</span>\n      <span class=\"o\">(</span><span class=\"n\">Vsymm.mk_mem_comm.mp</span> <span class=\"o\">(</span><span class=\"n\">hsx</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hsx</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mem_of_superset</span>\n    <span class=\"o\">(</span><span class=\"n\">S.Inter_mem_sets.mpr</span> <span class=\"bp\">$</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">hxS</span><span class=\"o\">,</span> <span class=\"n\">mem_infi_of_mem</span> <span class=\"n\">x</span> <span class=\"bp\">$</span> <span class=\"n\">preimage_mem_comap</span> <span class=\"n\">hV</span><span class=\"o\">)</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- TODO: this is too long</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">theorem1'</span> <span class=\"o\">{</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"bp\">ùîñ</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">is_compact</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">equicontinuous</span> <span class=\"o\">((</span><span class=\"n\">K.restrict</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">uniform_on_fun.uniform_space</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span> <span class=\"bp\">ùîñ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniform_space</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">uniform_space.comap_mono</span> <span class=\"bp\">$</span> <span class=\"n\">le_iff_uniform_continuous_id.mpr</span> <span class=\"bp\">$</span>\n    <span class=\"n\">uniform_on_fun.uniform_continuous_to_fun</span> <span class=\"n\">h1</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">uniform_on_fun.uniform_space</span><span class=\"o\">],</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">uniform_space.comap_infi</span><span class=\"o\">,</span> <span class=\"n\">le_infi‚ÇÇ_iff</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">uniform_space.comap_comap</span><span class=\"o\">],</span>\n  <span class=\"n\">intros</span> <span class=\"n\">K</span> <span class=\"n\">hK</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">compact_space</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"n\">is_compact_iff_compact_space.mp</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"n\">K</span> <span class=\"n\">hK</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">theorem1</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"n\">K</span> <span class=\"n\">hK</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">uniform_space.comap_comap</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">F</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"n\">uniform_space.comap_mono</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">uniform_continuous_iff</span><span class=\"o\">,</span> <span class=\"n\">uniform_continuous_pi</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">Œª</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniform_continuous_proj</span> <span class=\"n\">_</span> <span class=\"n\">i</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ascoli‚ÇÄ</span> <span class=\"o\">{</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí·µ§</span><span class=\"o\">[</span><span class=\"bp\">ùîñ</span><span class=\"o\">]</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œπ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">l.ne_bot</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"bp\">ùîñ</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">is_compact</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">equicontinuous</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">set.restrict</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">F</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">change</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">F</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"n\">at</span> <span class=\"n\">h4</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">cauchy_pi</span> <span class=\"n\">at</span> <span class=\"n\">h4</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cauchy_of_ne_bot</span><span class=\"o\">,</span> <span class=\"n\">prod_map_map_eq</span><span class=\"o\">,</span> <span class=\"n\">map_le_iff_le_comap</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">h4</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h4.trans</span> <span class=\"o\">(</span><span class=\"n\">theorem1'</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ge</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ascoli</span> <span class=\"o\">{</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí·µ§</span><span class=\"o\">[</span><span class=\"bp\">ùîñ</span><span class=\"o\">]</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"bp\">ùîñ</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">is_compact</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">equicontinuous</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">set.restrict</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">totally_bounded</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n  <span class=\"n\">totally_bounded</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">totally_bounded_iff_ultrafilter</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">h4</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">''</span> <span class=\"n\">univ</span> <span class=\"bp\">‚àà</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">image_univ</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">ultrafilter.mem_coe</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">le_principal_iff</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">ultrafilter.of_comap_inf_principal_eq_of_map</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">ultrafilter.of_comap_inf_principal</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">ascoli‚ÇÄ</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h4</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">g.map</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"bp\">$</span> <span class=\"n\">le_principal_iff.mpr</span> <span class=\"bp\">$</span> <span class=\"n\">range_mem_map</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 316512691,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671312712
    },
    {
        "content": "<p>Nice!</p>",
        "id": 316513108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671312995
    },
    {
        "content": "<p>In particular I'm quite happy with the intermediate <code>ascoli‚ÇÄ</code> in the above, because I can think of a lot of cases where being able to work directly with indexed sequences/families would be nice while having to deal with <code>totally_bounded (range ...)</code> (or even <code>is_compact (range ...)</code>) would be annoying.</p>",
        "id": 316513155,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671313063
    },
    {
        "content": "<p>And this also suggests a way to make an <code>eventually</code> statement: the natural thing to try would be replacing <code>h3</code> by <code>‚àÄ A ‚àà ùîñ, ‚àÄ·∂† (B : set Œπ) in l.small_sets, equicontinuous (Œª i : B, set.restrict A (F i))</code> (or <code>‚àÄ·∂† (B : set Œπ) in l.small_sets, ‚àÄ A ‚àà ùîñ, equicontinuous (Œª i : B, set.restrict A (F i))</code>) in <code>ascoli‚ÇÄ</code></p>",
        "id": 316513519,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671313315
    },
    {
        "content": "<p>That's really nice! (And I was far from knowing the current API to be able to reach such a proof in finite time.)</p>\n<p>Actually, do we really need assumption <code>h1</code>? (I mean, if then <code>h4</code> says <code>‚àÄ x ‚àà ‚ãÉ‚ÇÄ ùîñ</code>.) Removing it would help in applications where assumptions are in terms of <code>continuous_on</code>. E.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí·µ§</span><span class=\"o\">[{</span><span class=\"bp\">‚àÖ</span><span class=\"o\">}]</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Œπ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">l.ne_bot</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">F</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">uniform_on_fun.has_basis_uniformity</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span> <span class=\"o\">{</span><span class=\"bp\">‚àÖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">this.cauchy_iff.2</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">filter.map_ne_bot</span><span class=\"o\">],</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">rfl</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">‚ü®</span><span class=\"n\">univ</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">uniform_on_fun.gen</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 316569870,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1671361547
    },
    {
        "content": "<blockquote>\n<p>Actually, do we really need assumption h1? (I mean, if then h4 says <code>‚àÄ x ‚àà ‚ãÉ‚ÇÄ ùîñ</code>)</p>\n</blockquote>\n<p>That should definitely be doable, but the biggest question is (as usual) what's easier between doing the general version first or deducing it from the particular one. I'll give it a try.</p>\n<blockquote>\n<p>Removing it would help in applications where assumptions are in terms of <code>continuous_on</code></p>\n</blockquote>\n<p>That makes me realize that maybe we want <code>equicontinuous_on</code> already. I discussed that with S√©bastien on the equicontinuity PR and decided that we would add it when needed. You probably have way more uses of Ascoli in mind than I do, what do you think about this?</p>\n<blockquote>\n<p>And I was far from knowing the current API to be able to reach such a proof in finite time.</p>\n</blockquote>\n<p>To be honest the <code>uniform_space</code> API is really tricky to get right imo. The two main reasons I see are:</p>\n<ul>\n<li>unintuitive lemma names (e.g I never remember the name of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/comp_comp_symm_mem_uniformity_sets\">docs#comp_comp_symm_mem_uniformity_sets</a>) </li>\n<li>having to switch all the time between <code>uniformity</code>, <code>uniform_space.core.uniformity</code> and the raw <code>uniform_space</code>, because each of them have associated lemmas (see e.g the difference between the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/uniform_continuous\">docs#uniform_continuous</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/uniform_continuous_iff\">docs#uniform_continuous_iff</a>)</li>\n</ul>",
        "id": 316596063,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671373676
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>Actually, do we really need assumption h1? (I mean, if then h4 says <code>‚àÄ x ‚àà ‚ãÉ‚ÇÄ ùîñ</code>)</p>\n</blockquote>\n<p>That should definitely be doable, but the biggest question is (as usual) what's easier between doing the general version first or deducing it from the particular one. I'll give it a try.</p>\n</blockquote>\n<p>In fact tracing the API around it, there are many places where <code>ùîñ</code> being nonempty is assumed, where as far as I understood it it should work without the assumption (though admittedly the empty case is a bit boring). It would be optimal to have neither the nonempty nor the covering assumption.</p>\n<blockquote>\n<blockquote>\n<p>Removing it would help in applications where assumptions are in terms of <code>continuous_on</code></p>\n</blockquote>\n<p>That makes me realize that maybe we want <code>equicontinuous_on</code> already. I discussed that with S√©bastien on the equicontinuity PR and decided that we would add it when needed. You probably have way more uses of Ascoli in mind than I do, what do you think about this?</p>\n</blockquote>\n<p>The main use case that I have for the moment is Montel, so uniformly bounded families of holomorphic functions on a domain of the complex plane. So I care more about <code>ùîñ = {K \\ss U | is_compact K}</code> than about an additional definition.</p>",
        "id": 316597944,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1671374293
    },
    {
        "content": "<p>So actually removing <code>h1</code> is not hard at all, but making <code>h4</code> only require Cauchyness for elements of <code>‚ãÉ‚ÇÄ ùîñ</code> is much more annoying...</p>",
        "id": 316602653,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671376371
    },
    {
        "content": "<blockquote>\n<p>In fact tracing the API around it, there are many places where ùîñ being nonempty is assumed, where as far as I understood it it should work without the assumption (though admittedly the empty case is a bit boring). It would be optimal to have neither the nonempty nor the covering assumption.</p>\n</blockquote>\n<p>If you're talking about the <code>uniform_on_fun</code> API, the thing is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/uniform_on_fun.has_basis_uniformity_of_basis\">docs#uniform_on_fun.has_basis_uniformity_of_basis</a> <em>does</em> require nonemptyness and directedness (otherwise it isn't a filter basis to begin with!). The point where we get too strong assumptions is when I want to use this lemma to prove facts that don't depend directly on <code>ùîñ</code>. The reason is that I could replace <code>ùîñ</code> by its generated <strong>noncovering</strong> bornology, which is automatically nonempty and directed, without changing the topology. The reason we don't have that yet is that we don't have noncovering bornologies (because of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bornology.le_cofinite\">docs#bornology.le_cofinite</a>) so this is really annoying to even state.<br>\nThat said, I'm not sure this is too relevant here, because the covering condition is needed anyway if we want to compare uniform convergence and pointwise convergence: if the sets on which you have uniform convergence do not cover the space, you can't hope to have pointwise convergence</p>",
        "id": 316603738,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671376873
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 316609332,
        "sender_full_name": "Dean Young",
        "timestamp": 1671379675
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 316609409,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671379711
    },
    {
        "content": "<p>What do you think is the most useful as an hypothesis, <code>‚àÄ x ‚àà ‚ãÉ‚ÇÄ ùîñ, cauchy (map (eval x ‚àò F) l)</code> or <code>‚àÄ K ‚àà ùîñ, ‚àÄ x ‚àà K, cauchy (map (eval x ‚àò F) l)</code>?</p>",
        "id": 316611331,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671380849
    },
    {
        "content": "<p>My guess is the second one?</p>",
        "id": 316611735,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1671381093
    },
    {
        "content": "<p>I just pushed a fully relative version at <a href=\"https://github.com/leanprover-community/mathlib/pull/17975\">#17975</a>. It was a bit annoying because I can no longer say that <code>‚àÄ x ‚àà ‚ãÉ‚ÇÄ ùîñ, cauchy (map (eval x ‚àò F) l)</code> means being Cauchy for the product, so I have to go back to bare infimums and pullbacks, but the end result is clearly better</p>",
        "id": 316611840,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671381149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Montel's.20theorem/near/316611735\">said</a>:</p>\n<blockquote>\n<p>My guess is the second one?</p>\n</blockquote>\n<p>I would say the same, but since Vincent has a concrete application in mind I'd like to make sure everything works in his case</p>",
        "id": 316611985,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671381223
    },
    {
        "content": "<p>I will also add </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">forall_sUnion</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">‚Üî</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">infi_Prop_eq</span><span class=\"o\">,</span> <span class=\"n\">infi_sUnion</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>anyway</p>",
        "id": 316612096,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671381256
    },
    {
        "content": "<p>They feel the same to me - perhaps option 2 does indeed make things a bit more modular</p>",
        "id": 316612119,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1671381277
    },
    {
        "content": "<p>Noncovering bornologies are exactly filters, right? Or is there a difference?</p>",
        "id": 316626827,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1671390327
    },
    {
        "content": "<p>Yes but that should be an implementation detail hidden from the user, because having complements everywhere is super annoying</p>",
        "id": 316632747,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671394028
    },
    {
        "content": "<p>OK so with the relative version I can now prove this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">compacts</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"bp\">|</span> <span class=\"n\">K</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">U</span> <span class=\"bp\">‚àß</span> <span class=\"n\">is_compact</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Œπ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí·µ§</span><span class=\"o\">[</span><span class=\"n\">compacts</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">uniformly_bounded_on</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"n\">compacts</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">M</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">z</span> <span class=\"bp\">‚àà</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">function.eval</span> <span class=\"n\">z</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">closed_ball</span> <span class=\"mi\">0</span> <span class=\"n\">M</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">montel</span> <span class=\"o\">(</span><span class=\"n\">hU</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">uniformly_bounded_on</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">differentiable_on</span> <span class=\"n\">‚ÑÇ</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">totally_bounded</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(the definition of <code>uniformly_bounded_on</code> is not spelt the right way, it just minimized the local pain at some point in the proof ...)</p>",
        "id": 316636647,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1671396826
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/Montel's.20theorem/near/316632747\">said</a>:</p>\n<blockquote>\n<p>Yes but that should be an implementation detail hidden from the user, because having complements everywhere is super annoying</p>\n</blockquote>\n<p>Do you mean you need <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order.ideal\">docs#order.ideal</a>?</p>",
        "id": 316637910,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1671397669
    },
    {
        "content": "<p>In that case let me tell you that the API is a bit bad, but that I have a refactor on a branch that improves it greatly</p>",
        "id": 316637996,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1671397710
    },
    {
        "content": "<p>Then the refactor would redefine <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter\">docs#filter</a> in terms of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pfilter\">docs#pfilter</a> so that we can start porting <code>filter</code> lemmas to <code>pfilter</code> and dualise them to <code>ideal</code>.</p>",
        "id": 316638147,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1671397846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Montel's.20theorem/near/316638147\">said</a>:</p>\n<blockquote>\n<p>Then the refactor would redefine <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter\">docs#filter</a> in terms of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pfilter\">docs#pfilter</a> so that we can start porting <code>filter</code> lemmas to <code>pfilter</code> and dualise them to <code>ideal</code>.</p>\n</blockquote>\n<p>Hasn't this been dicussed a few times before, with the conclusion that we would lose a lot of nice definitional equalities in the case of filters on sets?</p>",
        "id": 316638253,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671397925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Montel's.20theorem/near/316637910\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/Montel's.20theorem/near/316632747\">said</a>:</p>\n<blockquote>\n<p>Yes but that should be an implementation detail hidden from the user, because having complements everywhere is super annoying</p>\n</blockquote>\n<p>Do you mean you need <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order.ideal\">docs#order.ideal</a>?</p>\n</blockquote>\n<p>Essentially yes, in my mind <code>bornology</code> would have been to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order.ideal\">docs#order.ideal</a> what <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter\">docs#filter</a> is to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pfilter\">docs#pfilter</a></p>",
        "id": 316638333,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671398008
    },
    {
        "content": "<p>To be honest I still don't see any reason to have the current restriction in the definition of bornology, and not just have it as a typeclass, apart from being slightly more consistent with the current litterature. In the context of topological vector spaces, this basically corresponds to restricting to T2 spaces!</p>",
        "id": 316638555,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671398192
    },
    {
        "content": "<p>But there are other changes I want to discuss about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bornology\">docs#bornology</a>, and we should wait for Lean4 before changing things here, especially since it appears quite low in the import tree (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/metric_space\">docs#metric_space</a> depends on it!)</p>",
        "id": 316638710,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671398321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/116395-maths/topic/Montel's.20theorem/near/316636647\">said</a>:</p>\n<blockquote>\n<p>OK so with the relative version I can now prove this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">compacts</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"bp\">|</span> <span class=\"n\">K</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">U</span> <span class=\"bp\">‚àß</span> <span class=\"n\">is_compact</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Œπ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí·µ§</span><span class=\"o\">[</span><span class=\"n\">compacts</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">uniformly_bounded_on</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"n\">compacts</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">M</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">z</span> <span class=\"bp\">‚àà</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">function.eval</span> <span class=\"n\">z</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">closed_ball</span> <span class=\"mi\">0</span> <span class=\"n\">M</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">montel</span> <span class=\"o\">(</span><span class=\"n\">hU</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">uniformly_bounded_on</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">differentiable_on</span> <span class=\"n\">‚ÑÇ</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">totally_bounded</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(the definition of <code>uniformly_bounded_on</code> is not spelt the right way, it just minimized the local pain at some point in the proof ...)</p>\n</blockquote>\n<p>This is nice! Just out of curiosity, did you try getting your original statement (with the subsequence) directy from the <code>cauchy</code> statement? I'm not sure this is the optimal road at all, but I feel like this is something that <em>should</em> be easy but isn't due to lack of API (I can't even find any links between <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cluster_pt\">docs#cluster_pt</a> and actual subsequences!), so it would be nice to at least make sure we can make it work</p>",
        "id": 316639267,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671398830
    },
    {
        "content": "<p>Side note: in an ideal world, we would have a nice way to show that your <code>uniformly_bounded_on</code> def is just <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bornology.is_bounded\">docs#bornology.is_bounded</a> for the Von Neuman bornology on <code>‚ÑÇ ‚Üí·µ§[compacts U] ‚ÑÇ</code>!</p>",
        "id": 316639647,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671399157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/Montel's.20theorem/near/316611331\">said</a>:</p>\n<blockquote>\n<p>What do you think is the most useful as an hypothesis, <code>‚àÄ x ‚àà ‚ãÉ‚ÇÄ ùîñ, cauchy (map (eval x ‚àò F) l)</code> or <code>‚àÄ K ‚àà ùîñ, ‚àÄ x ‚àà K, cauchy (map (eval x ‚àò F) l)</code>?</p>\n</blockquote>\n<p>Shouldn't there be a lemma that passes from one to another, possibly for other properties than <code>cauchy _</code> ?</p>",
        "id": 316641875,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1671400974
    },
    {
        "content": "<p>I will add this indeed: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">forall_sUnion</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">Œ±</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">‚Üî</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">infi_Prop_eq</span><span class=\"o\">,</span> <span class=\"n\">infi_sUnion</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>But there is still a point to be made that one is more natural to use because it doesn't involve any existential, so if everyone ends up rewriting to one form let's just use it directly.</p>",
        "id": 316642110,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671401168
    },
    {
        "content": "<p>(<code>infi_sUnion</code> doesn't exist yet either outside of the draft <a href=\"https://github.com/leanprover-community/mathlib/pull/17975\">#17975</a>)</p>",
        "id": 316642141,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671401227
    },
    {
        "content": "<blockquote>\n<p>Just out of curiosity, did you try getting your original statement (with the subsequence) directy from the cauchy statement? I'm not sure this is the optimal road at all, but I feel like this is something that should be easy but isn't due to lack of API (I can't even find any links between <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cluster_pt\">docs#cluster_pt</a> and actual subsequences!), so it would be nice to at least make sure we can make it work</p>\n</blockquote>\n<p>I spent a bit of time trying to do that and I came to the conclusion that 1) my explanation wasn't clear and 2) what I had in mind cannot work. Basically, I was trying to say \"instead of assuming total boundedness (which means that any ultrafilter is cauchy), why not just assume that <code>F</code> has pointwise cluster points, and then we should be able to deduce a cluster point for the whole sequence of functions in the same way that we prove that pointwise totally-bounded implies uniformly-totally-bounded\". But that cannot work, essentially because \"I have a converging subsequence\" and \"all my subsequences have a converging subsequence\" are not the same thing</p>",
        "id": 316645040,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671403664
    },
    {
        "content": "<p>So I guess now I have to prove that <code>X ‚Üí·µ§[ùîñ] Œ±</code> is complete when <code>Œ±</code> is and then Vincent will be able to get what he wants, modulo some API about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/totally_bounded\">docs#totally_bounded</a></p>",
        "id": 316645600,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671404120
    },
    {
        "content": "<blockquote>\n<p>I have to prove that <code>X ‚Üí·µ§[ùîñ]</code> Œ± is complete when <code>Œ±</code> is</p>\n</blockquote>\n<p>Actually we already have that for the ad-hoc <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tendsto_uniformly_on\">docs#tendsto_uniformly_on</a>. We really need to make more bridges between these, and in particular I have to backport our new <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tendsto_uniformly_on_filter\">docs#tendsto_uniformly_on_filter</a>. Presumably one <em>could</em> get rid of the predicates and use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/uniform_fun\">docs#uniform_fun</a> and variants of it, but I'm not sure about that.</p>",
        "id": 316646748,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671405085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/Montel's.20theorem/near/316638253\">said</a>:</p>\n<blockquote>\n<p>Hasn't this been dicussed a few times before, with the conclusion that we would lose a lot of nice definitional equalities in the case of filters on sets?</p>\n</blockquote>\n<p>We can keep any <code>filter</code> definition and show its equivalence with a <code>pfilter</code> one if we really care about defeq.</p>",
        "id": 316687883,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1671438432
    },
    {
        "content": "<p>I don't think using a sequence is the mathlib-appropriate way to do it, I was just following the proof I have on paper and found <a href=\"https://leanprover-community.github.io/mathlib_docs/find/exists_seq_tendsto_Sup\">docs#exists_seq_tendsto_Sup</a> and went with it. I would expect a smoother way to replace maximizing sequences would be to state <code>(nhds_within (supr f) (range f)).ne_bot</code> and use <code>comap</code> but I found nothing to do that in mathlib</p>",
        "id": 316697049,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1671441613
    },
    {
        "content": "<p>Ah, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_lub.nhds_within_ne_bot\">docs#is_lub.nhds_within_ne_bot</a></p>",
        "id": 316698673,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1671442238
    },
    {
        "content": "<blockquote>\n<p>I don't think using a sequence is the mathlib-appropriate way to do it</p>\n</blockquote>\n<p>Oh indeed I talked about sequences because the problem is easier to see, but of course I tried it with filters from the beginning. You can replace \"sequence\" by \"fillter and \"subsequence\" by \"finer ultrafilter\" in what I said</p>",
        "id": 316741671,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671456151
    },
    {
        "content": "<p>Sorry, I don't understand how order gets involved into any of that <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 316742586,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671456441
    },
    {
        "content": "<p>The way I thought you wanted to do it is getting relative compactness of the range (from a variant of Ascoli) and then use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_compact.tendsto_subseq\">docs#is_compact.tendsto_subseq</a></p>",
        "id": 316744027,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671456870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/Montel's.20theorem/near/316645600\">said</a>:</p>\n<blockquote>\n<p>So I guess now I have to prove that <code>X ‚Üí·µ§[ùîñ] Œ±</code> is complete when <code>Œ±</code> is and then Vincent will be able to get what he wants, modulo some API about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/totally_bounded\">docs#totally_bounded</a></p>\n</blockquote>\n<p>Actually I should have read Bourbaki better, I don't even need it to get relative compactness from total boundedness here, because we know that in our setup we might as well work with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Pi.uniform_space\">docs#Pi.uniform_space</a> (and we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Pi.complete_space\">docs#Pi.complete_space</a>)</p>",
        "id": 316744362,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1671456963
    },
    {
        "content": "<p>Quick update: if you can show <code>complete_space (‚ÑÇ ‚Üí·µ§[compacts U] ‚ÑÇ)</code>, or if you can show compactness given total boundedness and closedness in <code>‚ÑÇ ‚Üí·µ§[compacts U] ‚ÑÇ</code>, then I can now complete the proof of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">has_primitives</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">‚àÄ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">,</span> <span class=\"n\">differentiable_on</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">f</span> <span class=\"n\">U</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">,</span> <span class=\"n\">differentiable_on</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">g</span> <span class=\"n\">U</span> <span class=\"bp\">‚àß</span> <span class=\"n\">eq_on</span> <span class=\"o\">(</span><span class=\"n\">deriv</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">U</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">RMT</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">is_connected</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">‚â†</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"n\">has_primitives</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">‚àÉ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">differentiable_on</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">f</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">‚àß</span> <span class=\"o\">(</span><span class=\"n\">inj_on</span> <span class=\"n\">f</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">‚àß</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">U</span> <span class=\"bp\">=</span> <span class=\"n\">ball</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 317987752,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1672076641
    },
    {
        "content": "<p>This is absolutely great! I hope the Riemann Mapping Theorem makes it to mathlib soon. <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 317993919,
        "sender_full_name": "Kalle Kyt√∂l√§",
        "timestamp": 1672080712
    },
    {
        "content": "<p>(For anyone wondering, I am working on the missing bit)</p>",
        "id": 317995729,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1672082041
    },
    {
        "content": "<p>And here it is: <a href=\"https://github.com/leanprover-community/mathlib/pull/18017\">#18017</a></p>",
        "id": 318016468,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1672098277
    },
    {
        "content": "<p>This is still a mess (especially, the last few proofs, I just wanted to have them done for now!), and in particular I have to think of how to better integrate this with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/uniform_cauchy_seq_on_filter.tendsto_uniformly_on_filter_of_tendsto\">docs#uniform_cauchy_seq_on_filter.tendsto_uniformly_on_filter_of_tendsto</a><br>\nI'm pretty sure I can't use this last one directly because an infimum of complete spaces has no good reason to be complete, but it's essentially the same argument over and over again of going back to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Pi.complete_space\">docs#Pi.complete_space</a>. So I implemented Bourbaki's machinery to deal with this, which is <a href=\"https://github.com/leanprover-community/mathlib/blob/e56649fb7512ec1311642eaaf838bfde01b11be5/src/topology/uniform_space/cauchy.lean#L182\">this lemma</a></p>",
        "id": 318016818,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1672098663
    },
    {
        "content": "<p>At the moment it really looks like a more direct proof would have been shorter, but this should allow me to minimize some assumptions on Ascoli too (there is one version which gives compactness without assuming completeness of the codomain)</p>",
        "id": 318016949,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1672098800
    }
]
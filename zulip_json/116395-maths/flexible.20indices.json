[
    {
        "content": "<p>I'm fooling around with sequences of groups. Here is an extract of some code:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">subgroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">instances</span><span class=\"bp\">.</span><span class=\"n\">groups</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">functor_category</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">function</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">v</span> <span class=\"n\">v‚ÇÅ</span> <span class=\"n\">v‚ÇÇ</span> <span class=\"n\">v‚ÇÉ</span> <span class=\"n\">u</span> <span class=\"n\">u‚ÇÅ</span> <span class=\"n\">u‚ÇÇ</span> <span class=\"n\">u‚ÇÉ</span> <span class=\"c1\">-- declare the `v`&#39;s first; see `category_theory.category` for an explanation</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">instances</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u‚ÇÅ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"err\">ùíû</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v‚ÇÅ</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"n\">include</span> <span class=\"err\">ùíû</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sequence</span> <span class=\"o\">:=</span> <span class=\"bp\">‚Ñ§</span> <span class=\"err\">‚•§</span> <span class=\"n\">C</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">sequence</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"o\">(</span><span class=\"n\">sequence</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">category</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">sequence</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">delta</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñ§</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">i</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"err\">$</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">auto_param_eq</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">tidy</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 158961615,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550655938
    },
    {
        "content": "<p>What I am after is a nice definition of <code>delta</code></p>",
        "id": 158961623,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550655956
    },
    {
        "content": "<p>It is the map <code>X.obj i \\hom X.obj (i+1)</code> but I want to use unification to replace <code>i</code> with <code>(i-1+1)</code> when necessary.</p>",
        "id": 158961714,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550656069
    },
    {
        "content": "<p>Currently this fails:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variable</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñ§</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">delta</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"err\">‚â´</span> <span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">delta</span> <span class=\"n\">i</span>\n</pre></div>",
        "id": 158961922,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550656274
    },
    {
        "content": "<p>Because the second <code>X.delta</code> should be <code>X.delta (i-1+1)</code>, which is ugly.</p>",
        "id": 158961939,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550656298
    },
    {
        "content": "<p>My goal is to make things like this typecheck:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">sequence</span> <span class=\"n\">Group</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_complex</span> <span class=\"o\">:=</span>\n<span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñ§</span><span class=\"o\">),</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">delta</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">delta</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 158962397,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550656745
    },
    {
        "content": "<p>(never mind)</p>",
        "id": 158962468,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550656813
    },
    {
        "content": "<p>also your code doesn't work because <code>category_theory.instances.groups</code> doesn't exist</p>",
        "id": 158962609,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550656988
    },
    {
        "content": "<p>Yes, I know. It exists on my machine. It's a pity it doesn't yet exist in mathlib.</p>",
        "id": 158964464,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550659135
    },
    {
        "content": "<p>Here is <code>category_theory/instances/groups.lean</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\"> Copyright (c) 2018 Johan Commelin. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Johan Commelin</span>\n\n<span class=\"cm\">Introduce Group -- the category of groups.</span>\n\n<span class=\"cm\">Currently only the basic setup.</span>\n<span class=\"cm\">Copied from monoids.lean.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">concrete_category</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">fully_faithful</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">adjunction</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finsupp</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">instances</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- The category of groups and group morphisms. -/</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">Group</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bundled</span> <span class=\"n\">group</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Group</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">str</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">concrete_is_group_hom</span> <span class=\"o\">:</span>\n  <span class=\"n\">concrete_category</span> <span class=\"bp\">@</span><span class=\"n\">is_group_hom</span> <span class=\"o\">:=</span>\n<span class=\"bp\">‚ü®</span><span class=\"k\">by</span> <span class=\"n\">introsI</span> <span class=\"n\">Œ±</span> <span class=\"n\">ia</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"k\">by</span> <span class=\"n\">introsI</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"n\">Œ≥</span> <span class=\"n\">ia</span> <span class=\"n\">ib</span> <span class=\"n\">ic</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Group_hom_is_group_hom</span> <span class=\"o\">{</span><span class=\"n\">G‚ÇÅ</span> <span class=\"n\">G‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">Group</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G‚ÇÅ</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">G‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_group_hom</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G‚ÇÅ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">G‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span> <span class=\"bp\">‚ü®</span><span class=\"o\">{</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"n\">punit</span><span class=\"o\">,</span> <span class=\"n\">str</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">tidy</span> <span class=\"o\">}</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- The category of commutative groups and group morphisms. -/</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">CommGroup</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bundled</span> <span class=\"n\">comm_group</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">CommGroup</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">comm_group</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">str</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">is_comm_group_hom</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_group_hom</span> <span class=\"n\">f</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">concrete_is_comm_group_hom</span> <span class=\"o\">:</span> <span class=\"n\">concrete_category</span> <span class=\"bp\">@</span><span class=\"n\">is_comm_group_hom</span> <span class=\"o\">:=</span>\n<span class=\"bp\">‚ü®</span><span class=\"k\">by</span> <span class=\"n\">introsI</span> <span class=\"n\">Œ±</span> <span class=\"n\">ia</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"k\">by</span> <span class=\"n\">introsI</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"n\">Œ≥</span> <span class=\"n\">ia</span> <span class=\"n\">ib</span> <span class=\"n\">ic</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">CommGroup_hom_is_comm_group_hom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">CommGroup</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_comm_group_hom</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CommGroup</span>\n<span class=\"c\">/-</span><span class=\"cm\">- The forgetful functor from commutative groups to groups. -/</span>\n<span class=\"n\">def</span> <span class=\"n\">forget_to_Group</span> <span class=\"o\">:</span> <span class=\"n\">CommGroup</span> <span class=\"err\">‚•§</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span>\n<span class=\"n\">concrete_functor</span>\n  <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">intros</span> <span class=\"bp\">_</span> <span class=\"n\">c</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"n\">c</span> <span class=\"o\">})</span>\n  <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">introsI</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"bp\">;</span>  <span class=\"n\">exact</span> <span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"n\">i</span> <span class=\"o\">})</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">faithful</span> <span class=\"o\">(</span><span class=\"n\">forget_to_Group</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"n\">CommGroup</span> <span class=\"o\">:=</span> <span class=\"bp\">‚ü®</span><span class=\"o\">{</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"n\">punit</span><span class=\"o\">,</span> <span class=\"n\">str</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">tidy</span> <span class=\"o\">}</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">CommGroup</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">instances</span>\n</pre></div>",
        "id": 158965848,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550660657
    },
    {
        "content": "<p>What's the story as to why it's not in mathlib? My MSc student was going to use categories for doing schemes but we decided it wasn't a good idea because categories seemed to be happening too slowly</p>",
        "id": 158969754,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550665405
    },
    {
        "content": "<p>The story is that nobody copied the file about the category of monoids and did a search-replace <code>s/monoid/group/</code>. That's all.</p>",
        "id": 158981420,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550674298
    },
    {
        "content": "<blockquote>\n<p>My goal is to make things like this typecheck:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">sequence</span> <span class=\"n\">Group</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_complex</span> <span class=\"o\">:=</span>\n<span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñ§</span><span class=\"o\">),</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">delta</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">delta</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</pre></div>\n\n\n</blockquote>\n<p>Does anyone have an idea how to make this work?<br>\nI think writing <code>A.delta (i-1+1)</code> is very very ugly.</p>",
        "id": 159419211,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551183210
    },
    {
        "content": "<p>Why not use +1 instead of -1?</p>",
        "id": 159419271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551183254
    },
    {
        "content": "<p>it's over all integers</p>",
        "id": 159419274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551183263
    },
    {
        "content": "<p>Another way to flexify the indices for dependent types is to have an equality argument <code>i+1 = j</code> and have <code>i</code> on the left and <code>j</code> on the right</p>",
        "id": 159419303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551183309
    },
    {
        "content": "<p>But can we make it transparent?</p>",
        "id": 159419310,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551183325
    },
    {
        "content": "<p>don't know what you intend to do with this</p>",
        "id": 159419322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551183356
    },
    {
        "content": "<blockquote>\n<p>Why not use +1 instead of -1?</p>\n</blockquote>\n<p>I could do that here. But I think this issue will show up elsewhere as soon as we start looking in a broader range of indices.</p>",
        "id": 159419372,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551183386
    },
    {
        "content": "<blockquote>\n<p>don't know what you intend to do with this<br>\nFor starters we could try to prove the snake lemma (-;</p>\n</blockquote>",
        "id": 159419382,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551183414
    },
    {
        "content": "<p>More generally, you want an inductive family describing the allowable index combinations</p>",
        "id": 159419406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551183432
    },
    {
        "content": "<p>In this case it is just <code>inductive next : nat -&gt; nat -&gt; Prop | mk (i) : next i (i+1)</code></p>",
        "id": 159419419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551183460
    },
    {
        "content": "<p>Hmm, how do I use <code>next</code>?</p>",
        "id": 159419477,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551183492
    },
    {
        "content": "<p>Should I put that in my definition of <code>delta</code>?</p>",
        "id": 159419493,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551183509
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">is_complex</span> <span class=\"o\">:=</span>\n<span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñ§</span><span class=\"o\">),</span> <span class=\"n\">next</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">delta</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">delta</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 159419498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551183524
    },
    {
        "content": "<p>or are you looking somewhere else?</p>",
        "id": 159419514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551183544
    },
    {
        "content": "<p>Aah, ok</p>",
        "id": 159419714,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551183768
    },
    {
        "content": "<p>But that means I have 3 explicit arguments. So I can't just write <code>A.delta i</code></p>",
        "id": 159419729,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551183798
    },
    {
        "content": "<p>I would like to tell Lean: \"If unification knows what <code>j</code> should be, use that. Otherwise, default to <code>(i+1)</code>.\"</p>",
        "id": 159419801,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551183863
    },
    {
        "content": "<p>Yeah, I think so... it's just like with categories, you want the objects to be there before the morphisms, rather than extracting objects as the dom/cod of morphisms</p>",
        "id": 159419810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551183893
    },
    {
        "content": "<p>And after that I say to Lean: \"Hey, 95% of the time you can prove <code>next i j</code> by <code>mk i</code>. Otherwise, simplify the expression for <code>j</code> before doing that.\"</p>",
        "id": 159419828,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551183914
    },
    {
        "content": "<p>And so in 99% of the cases I can get away with just writing <code>A.delta i</code>. And in 1% of the cases I might to actually work on the proof obligation...</p>",
        "id": 159419841,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551183959
    },
    {
        "content": "<p>If something like that can work, that would be cool.</p>",
        "id": 159419885,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551183971
    },
    {
        "content": "<p>So <code>is_complex</code> is actually talking about three objects....</p>",
        "id": 159419903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184003
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">is_complex</span> <span class=\"o\">:=</span>\n<span class=\"bp\">‚àÄ</span> <span class=\"o\">{{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñ§</span><span class=\"o\">}}</span> <span class=\"o\">(</span><span class=\"n\">n1</span><span class=\"o\">:</span> <span class=\"n\">next</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n2</span> <span class=\"o\">:</span> <span class=\"n\">next</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">),</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">delta</span> <span class=\"n\">n1</span><span class=\"o\">)</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">delta</span> <span class=\"n\">n2</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 159419940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184051
    },
    {
        "content": "<p>what is {{}}?</p>",
        "id": 159419955,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551184072
    },
    {
        "content": "<p>half implicit, too lazy to unicode</p>",
        "id": 159419998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184091
    },
    {
        "content": "<p>I think it is working ascii notation though</p>",
        "id": 159420001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184102
    },
    {
        "content": "<p>what is half implicit?</p>",
        "id": 159420002,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551184103
    },
    {
        "content": "<p>not applied unless you apply an argument after them</p>",
        "id": 159420015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184139
    },
    {
        "content": "<p>like in the definition of subset</p>",
        "id": 159420024,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184150
    },
    {
        "content": "<p>:o</p>",
        "id": 159420029,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551184156
    },
    {
        "content": "<p>Hmm, but I think you are working on the wrong part. The definition of <code>delta</code> has to change.</p>",
        "id": 159420237,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551184362
    },
    {
        "content": "<p><code>is_complex</code> is just an example of something that doesn't typecheck with the current definition of <code>delta</code>.</p>",
        "id": 159420250,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551184383
    },
    {
        "content": "<p>I did that... <code>A.delta {i j} n1</code></p>",
        "id": 159420257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184392
    },
    {
        "content": "<p>Ooh, right. Ok.</p>",
        "id": 159420270,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551184412
    },
    {
        "content": "<p>But that means I can't write <code>A.delta i</code>, can I?</p>",
        "id": 159420279,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551184426
    },
    {
        "content": "<p>although possibly <code>i</code> and <code>j</code> shouldn't be implicit - this will print a bit weird if <code>n1</code> is not a simple term</p>",
        "id": 159420284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184435
    },
    {
        "content": "<p>No, I'm claiming that's a bad idea</p>",
        "id": 159420331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184452
    },
    {
        "content": "<p>If you don't have the objects lying around already, you can use +1 and -1 to access next elements, but if you ever want to link two of them together you need a variable for the common object</p>",
        "id": 159420377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184503
    },
    {
        "content": "<p><code>is_complex</code> is a good example of this - <code>j</code> is mediating the connection between <code>i</code> and <code>k</code></p>",
        "id": 159420393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184533
    },
    {
        "content": "<p>I know this looks silly but it's a DTT thing</p>",
        "id": 159420406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184557
    },
    {
        "content": "<p>This will be hard to explain to mathematicians...</p>",
        "id": 159420514,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551184651
    },
    {
        "content": "<p>Why can't automation help us here?</p>",
        "id": 159420518,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551184661
    },
    {
        "content": "<p>because DTT doesn't like it when you try to prove defeqs</p>",
        "id": 159420577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184685
    },
    {
        "content": "<p>If Lean figures out <code>j</code> by unification, that's cool. If it didn't: use <code>i+1</code>.</p>",
        "id": 159420593,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551184706
    },
    {
        "content": "<p>You want all rewriting and stuff to happen in prop land</p>",
        "id": 159420605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184719
    },
    {
        "content": "<p>but <code>delta</code> is data, so it needs a general type</p>",
        "id": 159420616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184734
    },
    {
        "content": "<p>it's not a question of figuring out the expressions, it's about making <code>i+1-1</code> defeq to <code>i</code></p>",
        "id": 159420639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551184785
    },
    {
        "content": "<p>Hmmm, I think that I wouldn't mind if automation could also help us with providing data, and not only proofs.</p>",
        "id": 159420910,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551185077
    },
    {
        "content": "<p>I don't know if automation is the right word here, but it's pretty clear that proof assistants that require using this <code>next</code> trick are not ready for use by mathematicians</p>",
        "id": 159420997,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1551185183
    },
    {
        "content": "<p>It's about wrangling DTT issues</p>",
        "id": 159421008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551185217
    },
    {
        "content": "<p>You are causing equality of integers to propagate to equality of types, which is bad</p>",
        "id": 159421021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551185251
    },
    {
        "content": "<p>I understand. It means we need either better wrangling tools or a better foundational framework. I'm not saying this is an easy question</p>",
        "id": 159421023,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1551185255
    },
    {
        "content": "<p>I am in favor of both of those</p>",
        "id": 159421032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551185279
    },
    {
        "content": "<p>What a nice thesis topic!</p>",
        "id": 159421079,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1551185295
    },
    {
        "content": "<p>Mario, I agree with Patrick. I understand the issues. But the issues are non-mathematical, so they should be hidden. Somehow...</p>",
        "id": 159421127,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551185376
    },
    {
        "content": "<p>In the end, DTT should be our assembly language. We want a Python on top of that.</p>",
        "id": 159421196,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551185417
    },
    {
        "content": "<p>You already have it: the tactic language</p>",
        "id": 159421204,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1551185437
    },
    {
        "content": "<p>DTT is a horrible assembly language</p>",
        "id": 159421207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551185444
    },
    {
        "content": "<p>it's like javascript - high level ish but used for low level things</p>",
        "id": 159421226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551185471
    },
    {
        "content": "<p>I know a much better proof assembly language, and it starts with M</p>",
        "id": 159421252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551185518
    },
    {
        "content": "<p>Sure, but is there a Python on top of your M?</p>",
        "id": 159421299,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551185537
    },
    {
        "content": "<p>One that will let me define functors on objects and morphisms, and check that they are lawful in a completely transparent way?</p>",
        "id": 159421315,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551185574
    },
    {
        "content": "<p>Proof automation is hard, and no one has a perfect solution. Lean could have the stuff you are talking about if it didn't have to fight its own foundation</p>",
        "id": 159421629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551185926
    },
    {
        "content": "<p>What do you mean with that last sentence?</p>",
        "id": 159421718,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551186018
    },
    {
        "content": "<p>You could just rewrite <code>i+1-1 = i</code> with the simplifier and we would all be happy</p>",
        "id": 159421860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551186128
    },
    {
        "content": "<p>Sure, that's exactly what I would want. But what do you mean with:</p>\n<blockquote>\n<p>Lean could have the stuff you are talking about if it didn't have to fight its own foundation<br>\nIs that an issue that can be solved, or is this fight some intrinsic DTT issue?</p>\n</blockquote>",
        "id": 159423093,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551187352
    },
    {
        "content": "<p>it's an intrinsic DTT issue</p>",
        "id": 159426569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551190474
    },
    {
        "content": "<p>defeq matters, and tactics can't change that</p>",
        "id": 159426583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551190485
    },
    {
        "content": "<p>Aah, so Lean will always be fighting its foundations.</p>",
        "id": 159426590,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551190496
    },
    {
        "content": "<p>So, why don't we write a Python-like on top of your assembly M? Do you think we would get further into state-of-the-art research level maths with a Python-like on top of M? Or is Lean just the best there is, and are we stuck with a system that fights its own foundations?</p>",
        "id": 159426749,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551190620
    },
    {
        "content": "<p>You are hitting surprisingly close to my current research areas</p>",
        "id": 159426793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551190677
    },
    {
        "content": "<p>That only means that I've been paying attention to what you've been saying on Zulip over the last couple of months (-;</p>",
        "id": 159426868,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551190720
    },
    {
        "content": "<p>I think that the killer combo is untyped foundations (ZFC like) + good tactic language + metaprogramming</p>",
        "id": 159426922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551190797
    },
    {
        "content": "<p>as you can see lean has 2 out of 3</p>",
        "id": 159426998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551190820
    },
    {
        "content": "<p>Isabelle gets pretty close, but it's not quite untyped foundations and as a result they are stuck with some things</p>",
        "id": 159427047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551190892
    },
    {
        "content": "<p>Hmmm, so why again did you give my colleagues that nlab blogpost on why type theory p0wns set theory?</p>",
        "id": 159427056,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551190908
    },
    {
        "content": "<p>I didn't write it, and I don't really endorse most of nLab philosophy</p>",
        "id": 159427119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551190943
    },
    {
        "content": "<p>but it's a good place to find the philosophy when you want it</p>",
        "id": 159427136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551190958
    },
    {
        "content": "<blockquote>\n<p>Why not use +1 instead of -1?</p>\n</blockquote>\n<p>So, for <code>is_complex</code> I could do this. But for <code>is_exact_at (i : int)</code> you need to reference <code>A.obj (i-1)</code> at some point. You can't avoid the subtraction. (Unless you want to break with the indexing conventions, but that will just move the pain to the next page, where it will hit you twice as hard.)</p>",
        "id": 159443240,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551203777
    },
    {
        "content": "<p>with the <code>next</code> thing, you can say <code>\\ex j, next i j /\\ ...</code></p>",
        "id": 159443585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551204115
    },
    {
        "content": "<p>but depending on what you want to say just plain <code>A.obj (i-1)</code> might be best</p>",
        "id": 159443669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551204178
    },
    {
        "content": "<p>So what is actually the benefit of <code>next</code>? Why can't I just write a condition <code>(h : j = i+1)</code> in the definition of <code>delta</code>?</p>",
        "id": 159443832,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551204325
    },
    {
        "content": "<p>you can</p>",
        "id": 159443845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551204338
    },
    {
        "content": "<p>but it generalizes to more complicated index structures</p>",
        "id": 159443860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551204357
    },
    {
        "content": "<p>I see...</p>",
        "id": 159444088,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551204552
    },
    {
        "content": "<p>I'm not saying you should necessarily use it here</p>",
        "id": 159444105,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551204576
    },
    {
        "content": "<p>Another example of this index business is (commutative / graded commutative) graded algebras</p>",
        "id": 159444253,
        "sender_full_name": "Reid Barton",
        "timestamp": 1551204701
    },
    {
        "content": "<p>where multiplication is a family of operations <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mo>:</mo><msub><mi>A</mi><mi>i</mi></msub><mo>√ó</mo><msub><mi>A</mi><mi>j</mi></msub><mo>‚Üí</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">m : A_i \\times A_j \\to A_{i+j}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord mathit\">m</span><span class=\"mrel\">:</span><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mbin\">√ó</span><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span><span class=\"mrel\">‚Üí</span><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">m</span></span></span></span> is supposed to be, say, associative, but stating that depends on the associativity of addition of indices</p>",
        "id": 159444327,
        "sender_full_name": "Reid Barton",
        "timestamp": 1551204759
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Do you know how mathematicians write the predicate <code>is_complex</code>?<br>\nThey just write <code>A.delta \\circ A.delta = 0</code><br>\nNow, I thought I should write <code>\\forall i, A.delta i \\circ A.delta (i-1) = 0</code>. But you are telling me I need 3 explicit arguments... it will probably take my psyche some time to adjust.</p>",
        "id": 159444385,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551204839
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Yeah, I was thinking about those a bit. (Because you can of course also do sequences as graded modules with a differential of degree 1.) I really don't know if the <code>A_i</code> should be an indexed family of types or an indexed family of subsets... We will probably need both...</p>",
        "id": 159444505,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551204938
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> Do you know how mathematicians write the predicate <code>is_complex</code>?<br>\nThey just write <code>A.delta \\circ A.delta = 0</code></p>\n</blockquote>\n<p>You can also write it in this way in Lean if you think of the total space of your complex as a group/module/whatever (with an additional filtered structure), and <code>A.delta</code>as a group/module/whatever morphism that, incidentally, happens to respect the filtration.</p>",
        "id": 159449374,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1551208520
    },
    {
        "content": "<p>Yes, but I fear that will make talking about homogeneous elements a lot more awkward...</p>",
        "id": 159449990,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551209036
    }
]
[
    {
        "content": "<p>The first step would be to change the statement to be in terms of the coefficients, which are equal to a sum of coefficients.<br>\nThe next step would be to use modular arithmetic to show that the sum of ite simplifies to a single ite.<br>\nHere is my MWE (minimal working example):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.analytic.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.complex.basic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">formal_multilinear_series</span> <span class=\"n\">finset</span> <span class=\"n\">filter</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">nnreal</span> <span class=\"n\">ennreal</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nontrivially_normed_field</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_add_comm_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">complete_space</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">formal_multilinear_series</span> <span class=\"bp\">𝕜</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">𝕜</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"bp\">𝕜</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ennreal</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">plain_old_series</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">nontrivially_normed_field</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>  <span class=\"o\">[</span><span class=\"n\">normed_add_comm_group</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formal_multilinear_series</span> <span class=\"bp\">𝕜</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">continuous_multilinear_map.mk_pi_field</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"c1\">------------------------</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rues_coeff</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">%</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">k.factorial</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rues_series</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">plain_old_series</span> <span class=\"n\">ℂ</span> <span class=\"o\">(</span><span class=\"n\">rues_coeff</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ruesDiff</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">rues_series</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ruesDiffTsumForm</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">:</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ruesDiff</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">tsum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">+</span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">%</span><span class=\"n\">n</span><span class=\"bp\">=</span><span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">z</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">/</span> <span class=\"n\">k.factorial</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">--already proved, but here for reference</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ruesDiffSumOfRuesDiff</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"bp\">&lt;</span><span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">:</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ruesDiff</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k₀</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">ruesDiff</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">*</span><span class=\"n\">k₀</span><span class=\"bp\">+</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">z</span><span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">--what I need help proving</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 301892656,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1664686890
    },
    {
        "content": "<p>If anyone does not see motivation to proving this result, perhaps skimming <a href=\"https://github.com/Nazgand/nazgandMathBook/blob/master/RootOfUnityExponentialSumFunction.pdf\">https://github.com/Nazgand/nazgandMathBook/blob/master/RootOfUnityExponentialSumFunction.pdf</a> and noting the lemma is a generalization of (5.3) would nerd-snipe someone into helping.</p>",
        "id": 301898950,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1664693665
    },
    {
        "content": "<p>It seems to me that the easiest way to prove the sum of ite is an ite is to use the Type <code>set Prop</code>.<br>\nI have a rough draft of what this should look like. Please help. I don't even know how to define <code>andSet</code>, let alone how to properly define the output Type of <code>iteSumOfIte</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">all</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"c1\">-- andSet claims that every Prop in props is true</span>\n<span class=\"kd\">def</span> <span class=\"n\">andSet</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">andSetElem</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">p</span><span class=\"bp\">∈</span><span class=\"n\">props</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">andSet</span> <span class=\"n\">props</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">andSetAndAndSet</span> <span class=\"o\">(</span><span class=\"n\">props₀</span> <span class=\"n\">props₁</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">andSet</span> <span class=\"n\">props₀</span> <span class=\"bp\">∧</span> <span class=\"n\">andSet</span> <span class=\"n\">props₁</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">andSet</span> <span class=\"o\">(</span><span class=\"n\">props₀</span> <span class=\"bp\">∪</span> <span class=\"n\">props₁</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- orSet claims that at least 1 Prop in props is true</span>\n<span class=\"kd\">def</span> <span class=\"n\">orSet</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">orSetElem</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">p</span><span class=\"bp\">∈</span><span class=\"n\">props</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">orSet</span> <span class=\"n\">props</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- mututallyExcusive claims that at most 1 Prop in props is true</span>\n<span class=\"kd\">def</span> <span class=\"n\">mutuallyExcusive</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">--  andSet {¬(h₀ ∧ h₁) | {h₀,h₁} ⊆ props ∧ h₀≠h₁} -- something like this but with init.data.set.set_of</span>\n\n<span class=\"c1\">-- exactly1True claims that exactly 1 Prop in props is true</span>\n<span class=\"kd\">def</span> <span class=\"n\">exactly1True</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">orSet</span> <span class=\"n\">props</span> <span class=\"bp\">∧</span> <span class=\"n\">mutuallyExcusive</span> <span class=\"n\">props</span>\n\n<span class=\"c1\">-- decidableSet claims every Prop in props is decidable</span>\n<span class=\"kd\">def</span> <span class=\"n\">decidableSet</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- andSet {decidable p | p ∈ props} -- something like this but with init.data.set.set_of</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">decidableSetElem</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">p</span><span class=\"bp\">∈</span><span class=\"n\">props</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidableSet</span> <span class=\"n\">props</span> <span class=\"bp\">→</span> <span class=\"n\">decidable</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">decidableSetSubset</span> <span class=\"o\">(</span><span class=\"n\">props₀</span> <span class=\"n\">props₁</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">props₀</span> <span class=\"bp\">⊆</span> <span class=\"n\">props₁</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidableSet</span> <span class=\"n\">props₁</span> <span class=\"bp\">→</span> <span class=\"n\">decidableSet</span> <span class=\"n\">props₀</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">decidableSetAndSet</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidableSet</span> <span class=\"n\">props</span> <span class=\"bp\">→</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">andSet</span> <span class=\"n\">props</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">decidableSetOrSet</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidableSet</span> <span class=\"n\">props</span> <span class=\"bp\">→</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">orSet</span> <span class=\"n\">props</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- having difficulty defining this lemma because of decidability</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">iteSumOfIte</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">finset</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₀</span><span class=\"o\">:</span><span class=\"n\">exactly1True</span> <span class=\"n\">props</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"o\">:</span><span class=\"n\">decidableSet</span> <span class=\"n\">props</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">orSet</span> <span class=\"n\">props</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">props</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"n\">p</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- this is the needed proof</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302076111,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1664807658
    },
    {
        "content": "<p>Your <code>andSetAndAndSet</code> looks suspiciously like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Inf_union\">docs#Inf_union</a> :-) have a look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inf_Prop_eq\">docs#inf_Prop_eq</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Inf_Prop_eq\">docs#Inf_Prop_eq</a></p>",
        "id": 302077903,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1664808214
    },
    {
        "content": "<p>Any idea why iteSumOfIte is not accepted by the interpreter? It shows an error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">props</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n<span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"n\">mutuallyExcusive</span> <span class=\"bp\">↑</span><span class=\"n\">props</span><span class=\"o\">,</span>\n<span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">decidableSet</span> <span class=\"bp\">↑</span><span class=\"n\">props</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">orSet</span> <span class=\"bp\">↑</span><span class=\"n\">props</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 302085539,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1664810393
    },
    {
        "content": "<p>it's trying to show that this is <code>decidable</code>, but can't find the type class instance (probably because it doesn't exist). Without really looking at any of this, but knowing that you have been working on things related to power series, my bet would be that you should just <code>open classical</code> at the top of the file, because I doubt you care about actual computability here. This will make everything decidable for you.</p>",
        "id": 302086913,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1664810812
    },
    {
        "content": "<p>Thanks. I'll need to remember that. Edited. Next, <code>mutuallyExcusive</code> needs to be defined.</p>",
        "id": 302092804,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1664812636
    },
    {
        "content": "<p>how about:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mutuallyExcusive</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">props</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span>\n</code></pre></div>\n<p>Note: I have <em>not</em> tried to understand why you are doing any of these <code>set Prop</code> manipulations, I'm just answering your questions briefly because I don't have much time. I suspect that for whatever you are trying to do, there is likely a much nicer way.</p>",
        "id": 302096641,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1664813704
    },
    {
        "content": "<p><code>mutuallyExclusive</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.pairwise_disjoint\">docs#set.pairwise_disjoint</a></p>",
        "id": 302097036,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664813845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  Sorry, how is that exactly? What is the <code>inf</code> of two propositions?</p>",
        "id": 302098926,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1664814414
    },
    {
        "content": "<p>I suppose it should be conjunction, but does Lean know that?</p>",
        "id": 302099150,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1664814481
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/Prop.distrib_lattice/src\">src#Prop.distrib_lattice</a></p>",
        "id": 302099256,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1664814510
    },
    {
        "content": "<p>And <code>orSet</code> is of course just <code>Sup</code>.</p>",
        "id": 302099914,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664814678
    },
    {
        "content": "<p>I think once you replace your adhoc constructions with the mathlib ones and generalize the <code>1</code> to anything, it's a fine lemma to have, if not a bit constricted.</p>",
        "id": 302100202,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664814760
    },
    {
        "content": "<p>You can also prove the \"dual\" with <code>Inf</code> and <code>prod</code>, and write the multiplicative version.</p>",
        "id": 302101554,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664815173
    },
    {
        "content": "<p>I don't see any other way to prove the original problem without the lemma <code>iteSumOfIte</code>.<br>\n<code>set.pairwise_disjoint</code> asks for a function, though. Does the identity function work?<br>\nIs this right, <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>? I am not sure what you meant.<br>\nAlso, I have been wondering how to prove <code>iteSumOfIte</code>. Induction on the set size seems like it might work, but I am unsure.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.complete_lattice</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.pairwise</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n\n<span class=\"c1\">-- mututallyExclusive claims that at most 1 Prop in props is true</span>\n<span class=\"kd\">def</span> <span class=\"n\">mutuallyExclusive</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">set.pairwise_disjoint</span> <span class=\"n\">props</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">iteSumOfIte</span> <span class=\"o\">(</span><span class=\"n\">props</span><span class=\"o\">:</span><span class=\"n\">finset</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₀</span><span class=\"o\">:</span><span class=\"n\">mutuallyExclusive</span> <span class=\"n\">props</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">Sup</span> <span class=\"n\">props</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">p</span> <span class=\"k\">in</span> <span class=\"n\">props</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"n\">p</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- this is the needed proof</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302102913,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1664815566
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"385848\">@Mark Andrew Gerads</span>, I'd strongly recommend dropping your <code>camelCase</code> naming convention and using the <code>snake_case</code> one prescribed by <a href=\"https://leanprover-community.github.io/contribute/naming.html\">#naming</a>. A powerful tool for working with mathlib is working out what the name of the result you want would be, and finding out if that name or similar already exists.</p>",
        "id": 302105602,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1664816326
    },
    {
        "content": "<p>If you use your own naming scheme, you will never be told by Lean that the thing you're proving already exists!</p>",
        "id": 302105709,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1664816368
    },
    {
        "content": "<p>For the \"at most one is true\" you could build a function that counts how many of the props are true, using <code>sum</code>, so going from <code>set Prop</code> to nat (or enat if your sets can be infinite) and then state that this number is at most one.</p>",
        "id": 302105844,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1664816404
    },
    {
        "content": "<p>Although I agree that this feels quite contrived for what you want to do - but I am not completely sure that I understand what you want to do</p>",
        "id": 302106247,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1664816513
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> my main goal in this thread is to prove <code>ruesDiffSumOfRuesDiff</code> in the first post of this thread. Because the coefficients use an <code>ite</code>, this ultimately seems to require <code>iteSumOfIte</code> in my last post.</p>",
        "id": 302107240,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1664816786
    },
    {
        "content": "<p>Ah ok. There might be some case of <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> here but I think I see what you are looking for.</p>",
        "id": 302107954,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1664817012
    },
    {
        "content": "<p>The lemma that has to be in mathlib is that the sum of a non empty collection of nonnegative terms is at least equal to the largest term, and if you phrase \"at least one\" in terms of the sum on your this, which feels reasonable to me, then I would look in this direction</p>",
        "id": 302108542,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1664817223
    },
    {
        "content": "<p>Maybe something similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.supr_le_sum\">docs#cardinal.supr_le_sum</a> ?</p>",
        "id": 302108730,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1664817286
    },
    {
        "content": "<p>For your initial question, can you perhaps use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tsum_sum\">docs#tsum_sum</a> ?</p>",
        "id": 302110474,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1664817844
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"385848\">@Mark Andrew Gerads</span>, yes <code>set.pairwise_disjoint</code> takes in an indexed family. In fact you could generalize your lemma to indexed families as well.</p>",
        "id": 302129418,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664823870
    },
    {
        "content": "<p>Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">\\</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pairwise_disjoint</span> <span class=\"n\">f</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"bp\">\\</span><span class=\"n\">supr</span> <span class=\"n\">i</span> <span class=\"bp\">\\</span><span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"bp\">\\</span><span class=\"n\">sum</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>This allows you to apply it when you have several times <code>false</code> in the sum.</p>",
        "id": 302129775,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664823997
    },
    {
        "content": "<p>I just noticed a problem. Because sets can only contain 1 element once, and every Prop is either <code>true</code> or <code>false</code>, this means that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>s</mi><mo>⊆</mo><mo stretchy=\"false\">{</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator=\"true\">,</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">props \\subseteq \\{true,false\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">e</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">se</span><span class=\"mclose\">}</span></span></span></span>. props having at most 1 true statement  is tautological.<br>\nI think I need props to be a list of Prop instead, so I need to read about lists in mathlib.</p>",
        "id": 302413158,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1664959784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function/near/302129775\">said</a>:</p>\n<blockquote>\n<p>This allows you to apply it when you have several times <code>false</code> in the sum.</p>\n</blockquote>\n<p><span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span></p>",
        "id": 302413285,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664959842
    },
    {
        "content": "<p>To be explicit, you don't need lists, you need <em>indexed families</em>, which are a function <code>ι → α</code> along with a range of values you're interested in <code>finset ι</code>.</p>",
        "id": 302414020,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1664960162
    },
    {
        "content": "<p>Okay, now I think I am asking for the right lemma. <code>library_search</code> failed. I have been thinking that if this is proved for n=2, that can be used for an inductive step. (<code>n&gt;0</code> and <code>mutually_exclusive (range n:set ℕ) p</code>) implies <code>mutually_exclusive (range (n-1):set ℕ) p</code>.<br>\nAlso, <code>∃ k ∈ range n, p k</code>=<code>(p (n-1) or ∃ k ∈ range (n-1), p k)</code>, which is why I believe induction could work. I will think more about it later.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n\n<span class=\"c1\">-- mutually_exclusive claims that at most 1 Prop is true in the indexed family I,p</span>\n<span class=\"kd\">def</span> <span class=\"n\">mutually_exclusive</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">i₀</span> <span class=\"n\">i₁</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">i₀</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"n\">i₁</span> <span class=\"bp\">→</span> <span class=\"n\">i₀</span> <span class=\"bp\">=</span> <span class=\"n\">i₁</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ite_sum_of_ite</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₀</span><span class=\"o\">:</span><span class=\"n\">mutually_exclusive</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">k</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- this is the needed proof</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302440882,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1664971187
    },
    {
        "content": "<p>Read <a href=\"#narrow/stream/116395-maths/topic/A.20function.20that.20is.20a.20sum.20of.20said.20function/near/302129775\">my messages</a> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 302549449,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665005887
    },
    {
        "content": "<p>The reason<code>library_search</code> failed is that you didn't teach it enough. Firstly, it doesn't know <em>anything</em> about <code>mutually_exclusive</code> so you can't expect it to do anything with that. Second it would only find exact matches, which we ruled out as the lemma doesn't exist in the library.</p>",
        "id": 302549763,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665006008
    },
    {
        "content": "<p>Anyway, here is your lemma <a href=\"https://github.com/leanprover-community/mathlib/pull/16825\">#16825</a></p>",
        "id": 302549778,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665006014
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/16825\">#16825</a>?</p>",
        "id": 302552733,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665007372
    },
    {
        "content": "<p>Yep, sorry. Keyboard should go to bed.</p>",
        "id": 302552845,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665007424
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Thank you very much for the lemma. It is quite helpful.</p>",
        "id": 302563960,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1665014460
    },
    {
        "content": "<p>I'm not sure the lemma is actually that useful; you can immediately simplify the RHS with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.prod_filter\">docs#finset.prod_filter</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.prod_const\">docs#finset.prod_const</a></p>",
        "id": 302566153,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665015593
    },
    {
        "content": "<p>Then we find that the actual lemma that is missing is that <code>s.filter f = {a}</code> when <code>a ∈ s</code> and <code>pairwise s f</code></p>",
        "id": 302566272,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665015687
    },
    {
        "content": "<p>I don't care about the finer details too much; my main goal right now is ruesDiffSumOfRuesDiff.<br>\nI am waiting on the PR now though, so please decide whatever needs to be decided to pull the PR. If the suggested filter version is pulled, I'll just need to learn to use filters.</p>",
        "id": 302876590,
        "sender_full_name": "Mark Andrew Gerads",
        "timestamp": 1665156124
    },
    {
        "content": "<p>Note that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.filter\">docs#finset.filter</a> is not related to \"filters\" (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter\">docs#filter</a>)</p>",
        "id": 303044851,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665249819
    }
]
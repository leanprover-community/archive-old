[
    {
        "content": "<p>Hello,</p>\n<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> be a real Hilbert space and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> a bilinear map on it. Then we can define a continuous map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V \\to V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> as follows:<br>\nfor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">v \\in V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>, map it to the unique vector <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">f \\in V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>w</mi><mo>∈</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo separator=\"true\">,</mo><mi>w</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">⟨</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>w</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\forall w \\in V, B(v,w) = \\langle f, w\\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">⟩</span></span></span></span>, which exists because of the Riesz representation theorem. How do we want to call this map? So far I've called it \"Lax-Milgram map\" because that's where I'm using it (the Lax-Milgram theorem can be stated as saying that this can be made a continuous equivalence under certain conditions), but <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> suggested we put it directly in <code>analysis.inner_product_space.dual</code> and give it a more descriptive name. She gave <code>sharp B</code>, <code>end_of_bilin B</code> and <code>clm_of_bilin B</code> as ideas. What do you think?</p>",
        "id": 268876680,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1642786910
    },
    {
        "content": "<p>I hope we can get some ideas here since I am not thrilled about the ones I suggested :). <span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> what do you think?</p>",
        "id": 268913111,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1642804805
    },
    {
        "content": "<p><code>sharp</code> is from the <a href=\"https://en.wikipedia.org/wiki/Musical_isomorphism\">musical isomorphism</a></p>",
        "id": 268913349,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1642804972
    },
    {
        "content": "<p>In differential geometry this operation would be raising an index, so what about \"raise\"?</p>",
        "id": 268914410,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1642805637
    },
    {
        "content": "<p>Alternatively, we are basically converting a bilinear form to an endomorphism, so it could be to_map or to_endo</p>",
        "id": 268914521,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1642805720
    },
    {
        "content": "<p>For these latter ideas, this is indeed where I was going with the <code>end_of_bilin</code> and <code>clm_of_bilin</code> (<code>clm</code> for \"continuous linear map\"), but I think the <code>of_bilin</code> is necessary because it won't literally be in the <code>bilin_form</code> namespace.</p>",
        "id": 268914686,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1642805828
    },
    {
        "content": "<p>Yes, that sounds reasonable</p>",
        "id": 268914808,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1642805885
    },
    {
        "content": "<p>I quite like <code>raise</code>, though.  And remarkably the word is not yet used in mathlib for anything else!</p>",
        "id": 268914815,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1642805887
    },
    {
        "content": "<p>By the way, another application of this construction will be when we prove the version of the spectral theorem which says that two symmetric bilinear forms are simultaneously diagonalizable.  It would be deduced from the current version for endomorphisms, by converting the second form <code>B</code> to an endomorphism using <code>raise</code> with the first form as the inner product.</p>",
        "id": 268915641,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1642806436
    },
    {
        "content": "<p>Ah, perhaps <span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> would have an opinion here, too.</p>",
        "id": 268917068,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1642807325
    },
    {
        "content": "<p>I would vote for <code>clm_of_bilin</code> personally, it's completely descriptive and easy to guess if you're looking for it. (Never in a million years would I guess <code>raise</code> :-) )</p>",
        "id": 268918632,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1642808297
    },
    {
        "content": "<p>maybe <code>cont_linear_map_of_bilin</code> or is that too long? I think <code>clm</code> is not really understandable</p>",
        "id": 268919711,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1642809032
    },
    {
        "content": "<p>We could call it <code>continuous_linear_map_of_bilin</code> and have local notation <code>raise</code> for <code>continuous_linear_map_of_bilin</code>, so that it isn't too much a pain to write code about.</p>",
        "id": 268921865,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1642810544
    },
    {
        "content": "<p>Or actually (keeping the name as <code>continuous_linear_map_of_bilin</code>), even notation <code>♯</code> (for sharp):  I think having a series of lemmas about <code>B♯</code> would look quite pretty and efficient, and it has more outside-mathlib precedent than some of our crazy notation.</p>",
        "id": 268926746,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1642814664
    },
    {
        "content": "<p>I kind of agree with the others that <code>raise</code> would not be immediately understandable: having the name <code>continuous_linear_map_of_bilin</code> and having <code>#</code> as local notation could be the best of both worlds.</p>",
        "id": 268947180,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1642842336
    },
    {
        "content": "<p>We also should define the inverse map, which works in arbitrary inner product spaces: it could be <code>bilin_of_continuous_linear_map</code> and have the notation <code>♭</code></p>",
        "id": 268947282,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1642842475
    },
    {
        "content": "<p>I like the idea of having a long name and a notation. We already do this, especially in projects depending on mathlib. One catch is that the doc website will show the long version.</p>",
        "id": 268948467,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1642844114
    },
    {
        "content": "<p>I  think that the correct way to think about the map is that there is a (continuous) map <code>(V →L[ℝ] V) →L[ℝ]  (V →L[ℝ] V →L[ℝ] V)</code>, which is an equivalence if <code>V</code> is a Hilbert space (and the analogous statement for the complex numbers using is_R_or_C, of course). Then the Lax-Milgram theorem can be stated as saying that bijective continuous linear maps are mapped bijectively to coercive bilinear forms. This does complicate things though...</p>",
        "id": 268948476,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1642844155
    },
    {
        "content": "<p>We could also decide that we really need a shorter long version of continuous_linear_map. clm is indeed already used in a couple of places, but very few.</p>",
        "id": 268948519,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1642844167
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I think showing the explicit version in the docs instead of the obscure notation is a feature, not a bug.</p>",
        "id": 268948532,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1642844211
    },
    {
        "content": "<p>The ideal situation would be to show the notation with something like a tooltip telling what it means. But clearly this is low priority until Lean 4.</p>",
        "id": 268948564,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1642844267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465995\">Daniel Roca González</span> <a href=\"#narrow/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces/near/268947180\">said</a>:</p>\n<blockquote>\n<p>having <code>#</code> as local notation</p>\n</blockquote>\n<p>Note that I am proposing notation <code>♯</code>, not <code>#</code> :)</p>",
        "id": 268959004,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1642859794
    },
    {
        "content": "<p>how does it work when someone else wants to use <code>♯</code> for something else? can they simply define the notation in their own namespace and that's it, or would it be necessary to define a class like <code>has_sharp</code> in the vein of <code>has_add</code>, <code>has_mem</code>...</p>",
        "id": 268967097,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1642871071
    },
    {
        "content": "<p>You can wrap notation in locales using <code>localized \"the_code_that_you_want_to_be_localized\" in name_of_the_locale</code></p>",
        "id": 268967130,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1642871150
    },
    {
        "content": "<p>Look for <code>localized</code> and you'll find a ton of examples in mathlib.</p>",
        "id": 268967179,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1642871172
    },
    {
        "content": "<p>In this case, I think it would be fine not to implement either of these methods (<code>localized</code> notation or a <code>has_sharp</code> class), they can wait until someone else actually has a use case for the same notation.</p>",
        "id": 268977273,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1642883566
    },
    {
        "content": "<p>So if nobody complains I would go for <code>continuous_linear_map_of_bilin</code> with the musical notation.</p>",
        "id": 269144166,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1643047153
    },
    {
        "content": "<p>Is there an explanation of what locales are and how they work anywhere? I'm looking at examples but I don't really understand them vs. namespaces. I didn't find anything in TOPL.</p>",
        "id": 269151582,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1643050117
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/commands.html#localized%20notation\">https://leanprover-community.github.io/mathlib_docs/commands.html#localized%20notation</a></p>",
        "id": 269151972,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643050259
    },
    {
        "content": "<p>Okay so now my problem is as follows: I defined <code>continuous_linear_map_of_bilin</code> in the general <code>is_R_or_C</code> case, with the notation, but if I try <code>B♯</code> it doesn't work because Lean can't infer the field, so I have to do <code>(B♯ : V →L[ℝ] V)</code> which is worse. Is there anything I could do to fix this?</p>",
        "id": 269306804,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1643137435
    },
    {
        "content": "<p>Make the field part of the notation?</p>",
        "id": 269310131,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643138841
    },
    {
        "content": "<p>This likely means that we have to give up on <code>localized</code> notation, and use something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kd\">postfix</span> <span class=\"bp\">`♯`</span> <span class=\"o\">:=</span> <span class=\"n\">continuous_linear_map_of_bilin</span> <span class=\"bp\">𝕜</span>\n</code></pre></div>\n<p>after having defined <code>𝕜</code>.</p>",
        "id": 269313046,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1643140063
    },
    {
        "content": "<p>In fact, we have the same problem for the inner product itself.  Practically every file on Hilbert spaces starts with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`⟪`</span><span class=\"n\">x</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">y</span><span class=\"bp\">`⟫`</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">inner</span> <span class=\"bp\">𝕜</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>because it is more ergonomic to do this (even at the cost of the duplication and the making <code>⟪v, w⟫</code> a local notation which doesn't show up in the docs) than to have an ugly notation like <code>𝕜⟪v, w⟫</code> or something which explicitly mentions the <code>𝕜</code>.</p>",
        "id": 269319847,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1643142803
    },
    {
        "content": "<p>lol, <a href=\"https://github.com/leanprover-community/mathlib/tree/inner_product_spaces\">branch#inner_product_spaces</a></p>",
        "id": 269320041,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643142913
    },
    {
        "content": "<p>Oh whoops sorry I deleted it. But this branch was using <code>𝕜⟪v | w⟫</code> all over the place.</p>",
        "id": 269320112,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643142952
    },
    {
        "content": "<p>In the case of <code>continuous_linear_map_of_bilin</code>, doesn't it take as an argument a bilinear map over some field, and then why isn't it possible for Lean to get the field by unification?</p>",
        "id": 269321250,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1643143530
    },
    {
        "content": "<p>If I remove the type ascriptions at line 74 in <code>src/analysis/inner_product_space/lax_milgram.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">bounded_below</span> <span class=\"o\">(</span><span class=\"n\">coercive</span> <span class=\"o\">:</span> <span class=\"n\">is_coercive</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">C</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">v</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"bp\">♯</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">v</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">coercive</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">C_ge_0</span><span class=\"o\">,</span> <span class=\"n\">coercivity</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">C_ge_0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∥</span><span class=\"n\">v</span><span class=\"bp\">∥</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">mul_le_mul_right</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"k\">calc</span> <span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">v</span><span class=\"bp\">∥</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">v</span><span class=\"bp\">∥</span>\n               <span class=\"bp\">≤</span> <span class=\"n\">B</span> <span class=\"n\">v</span> <span class=\"n\">v</span>                         <span class=\"o\">:</span> <span class=\"n\">coercivity</span> <span class=\"n\">v</span>\n    <span class=\"bp\">...</span>        <span class=\"bp\">=</span> <span class=\"n\">inner</span> <span class=\"o\">(</span><span class=\"n\">B</span><span class=\"bp\">♯</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">...</span>        <span class=\"bp\">≤</span> <span class=\"bp\">∥</span><span class=\"n\">B</span><span class=\"bp\">♯</span> <span class=\"n\">v</span><span class=\"bp\">∥</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">v</span><span class=\"bp\">∥</span>     <span class=\"o\">:</span> <span class=\"n\">real_inner_le_norm</span> <span class=\"o\">(</span><span class=\"n\">B</span><span class=\"bp\">♯</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The error is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">B</span><span class=\"bp\">♯</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">B</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">V</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_3</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"bp\">⋆</span><span class=\"o\">[</span><span class=\"bp\">?</span><span class=\"n\">m_1</span><span class=\"o\">]</span> <span class=\"bp\">?</span><span class=\"n\">m_3</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">?</span><span class=\"n\">m_1</span><span class=\"o\">]</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"bp\">?</span> <span class=\"bp\">?</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 269373749,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1643183792
    },
    {
        "content": "<p>I suspect the <code>→L[?m_1]</code> versus <code>→L⋆[?m_1]</code> has something to do with this...</p>",
        "id": 269373767,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1643183816
    },
    {
        "content": "<p>Right, <code>star_ring_end ℝ</code> is defeq to <code>ring_hom.id ℝ</code>, but <code>star_ring_end ?m_1</code> is not. So with the type ascription, the elaborator figures out <code>?m_1 = ℝ</code>, it can unfold <code>star_ring_end ℝ</code> and we're in business. And without the type ascription, it apparently doesn't realize that <code>→L[ℝ] =?= →L⋆[?m_1]</code> implies <code>?m_1 = ℝ</code>.</p>",
        "id": 269374884,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1643184738
    },
    {
        "content": "<p>I don't know why the elaborator skips unifying the type-level arguments here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">complete_space</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">section</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.type_context.is_def_eq</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.type_context.is_def_eq_detail</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.notation</span> <span class=\"n\">false</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">B₂</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">B₂</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"bp\">⋆</span><span class=\"o\">[</span><span class=\"n\">_</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">type_context.is_def_eq</span><span class=\"o\">]</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">=?=</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span> <span class=\"bp\">...</span> <span class=\"n\">success</span>  <span class=\"o\">(</span><span class=\"n\">approximate</span> <span class=\"n\">mode</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">type_context.is_def_eq_detail</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]:</span> <span class=\"n\">continuous_linear_map</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"n\">V</span> <span class=\"bp\">=?=</span> <span class=\"n\">continuous_linear_map</span> <span class=\"o\">(</span><span class=\"n\">star_ring_end</span> <span class=\"bp\">?</span><span class=\"n\">m_5</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"n\">V</span>\n<span class=\"o\">[</span><span class=\"n\">type_context.is_def_eq_detail</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]:</span> <span class=\"n\">continuous_linear_map</span> <span class=\"bp\">=?=</span> <span class=\"n\">continuous_linear_map</span>\n<span class=\"o\">[</span><span class=\"n\">type_context.is_def_eq_detail</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]:</span> <span class=\"n\">ring_hom.id</span> <span class=\"n\">real</span> <span class=\"bp\">=?=</span> <span class=\"n\">star_ring_end</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span>\n<span class=\"o\">[</span><span class=\"n\">type_context.is_def_eq_detail</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">]:</span> <span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span> <span class=\"n\">real</span><span class=\"o\">,</span> <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"bp\">=?=</span> <span class=\"n\">coe</span> <span class=\"n\">star_ring_aut</span>\n<span class=\"o\">[</span><span class=\"n\">type_context.is_def_eq_detail</span><span class=\"o\">]</span> <span class=\"n\">unfold</span> <span class=\"n\">right</span><span class=\"o\">:</span> <span class=\"n\">coe</span>\n<span class=\"o\">[</span><span class=\"n\">type_context.is_def_eq_detail</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">]:</span> <span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span> <span class=\"n\">real</span><span class=\"o\">,</span> <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"bp\">=?=</span> <span class=\"n\">lift_t</span> <span class=\"n\">star_ring_aut</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 269375591,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1643185258
    },
    {
        "content": "<p>Aha, <code>type_context_old::is_def_eq_args</code> unifies explicit arguments or implicit arguments of the form <code>t =?= ?m</code> first, before doing implicits. But the problem <code> @continuous_linear_map real real real.semiring real.semiring … =?= @continuous_linear_map ?m_1 …</code> looks like its first argument should be of that form <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 269376429,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1643185834
    },
    {
        "content": "<p>Ok, I don't feel like stepping through this whole thing in a debugger, and I don't know if it's worth the effort to investigate this if Lean 4 might change this part of the elaborator radically anyway, so I'll leave it here for someone with more elaborator knowledge to investigate.</p>",
        "id": 269377863,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1643186702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Name.20for.20certain.20map.20in.20Hilbert.20spaces/near/269319847\">said</a>:</p>\n<blockquote>\n<p>In fact, we have the same problem for the inner product itself.  Practically every file on Hilbert spaces starts with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`⟪`</span><span class=\"n\">x</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">y</span><span class=\"bp\">`⟫`</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">inner</span> <span class=\"bp\">𝕜</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>because it is more ergonomic to do this (even at the cost of the duplication and the making <code>⟪v, w⟫</code> a local notation which doesn't show up in the docs) than to have an ugly notation like <code>𝕜⟪v, w⟫</code> or something which explicitly mentions the <code>𝕜</code>.</p>\n</blockquote>\n<p>I has hoping this was not necessary, but if we're using it for the inner product too it makes sense to do it like this here.</p>",
        "id": 269379855,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1643187803
    }
]
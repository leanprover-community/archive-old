[
    {
        "content": "<p>Do the axioms of a Heyting algebra imply the existence of a bot? The definition I have over at <a href=\"https://github.com/leanprover-community/mathlib/tree/heyting_algebra\">branch#heyting_algebra</a> doesn't seem to imply it...</p>",
        "id": 269928139,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643542705
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>, this means I have to integrate <code>order_top</code> within <code>heyting_algebra</code>, but not <code>order_bot</code>. That's a funny situation but I think it's okay?</p>",
        "id": 269928229,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643542804
    },
    {
        "content": "<p>Ah, for people who talk about Heyting algebras, \"lattice\" means something with all finite meets and joins, including the empty ones. So yes, a Heyting algebra has a bottom (and top) element by definition.</p>",
        "id": 269928334,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643542975
    },
    {
        "content": "<p>Do you know that <code>compl_sup_eq_himp</code> only holds in Boolean algebras, not in general Heyting algebras? One always has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>p</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi mathvariant=\"normal\">⊤</mi></mrow><annotation encoding=\"application/x-tex\">(p \\implies p) = \\top</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">⊤</span></span></span></span>, but  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mo>⊔</mo><mi mathvariant=\"normal\">¬</mi><mi>p</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi mathvariant=\"normal\">⊤</mi></mrow><annotation encoding=\"application/x-tex\">(p \\sqcup \\neg p) = \\top</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊔</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">⊤</span></span></span></span> means that your Heyting algebra is Boolean. The definition of Heyting algebra should be \"finite meets and joins and an implication operator satisfying <code>le_himp_iff_inf_le</code>\" (from this you can deduce distributivity and define pseudocomplements as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>p</mi><mo><mi mathvariant=\"normal\">≔</mi></mo><mo stretchy=\"false\">(</mo><mi>p</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi mathvariant=\"normal\">⊥</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\neg p \\coloneqq (p \\implies \\bot)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mop\" style=\"position:relative;top:-0.0347em;\">:</span></span><span class=\"mrel\"><span class=\"mspace\" style=\"margin-right:-0.0667em;\"></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">⊥</span><span class=\"mclose\">)</span></span></span></span>).</p>",
        "id": 269930267,
        "sender_full_name": "David Wärn",
        "timestamp": 1643545477
    },
    {
        "content": "<p>By the way, Flypitch has a nice tactic framework for reasoning internally to Boolean algebras, which can easily be adapted to Heyting algebras. I wrote a <a href=\"https://gist.github.com/dwarn/fc60c7687551552bb0af6281d0625ed3\">version</a> for Cartesian closed categories a while ago. At the bottom of the gist is an example proof of the double-negated law of excluded middle, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo>∨</mo><mi mathvariant=\"normal\">¬</mi><mi>p</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\neg \\neg (p \\vee \\neg p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">¬¬</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∨</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span></span></span></span>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">Γ</span> <span class=\"bp\">⟶</span> <span class=\"o\">((</span><span class=\"n\">X</span> <span class=\"bp\">⨿</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟹</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"bp\">⟹</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">⟹</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">c_intro</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">hn</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">≫</span> <span class=\"n\">coprod.inr</span><span class=\"o\">),</span>\n  <span class=\"n\">c_intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hn</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"bp\">≫</span> <span class=\"n\">coprod.inl</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Here <code>c_intro</code> is a custom tactic for introducing a function / Heyting implication, analogous to <code>intro</code>, and <code>hn _</code> only makes sense because of a coercion from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>≤</mo><mo stretchy=\"false\">(</mo><mi>q</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>r</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p \\le (q \\implies r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mo>≤</mo><mi>q</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mo stretchy=\"false\">(</mo><mi>p</mi><mo>≤</mo><mi>r</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(p \\le q) \\to (p \\le r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span>. There's also a custom tactic for eliminating from a coproduct / disjunction (using distributivity). What's nice about these tactics is that the user experience is the same as when reasoning about <code>Prop</code>s in tactic mode.</p>",
        "id": 269934100,
        "sender_full_name": "David Wärn",
        "timestamp": 1643550531
    },
    {
        "content": "<p>I've got a puzzle about Heyting algebras <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/269941042\">in another thread</a>; if anyone is interested they can start reading from <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268472332\">here</a>.</p>\n<p>There are also some intuitionistic implications in <a href=\"https://gist.github.com/alreadydone/7474d5000c912194d794d06192e84f1e#file-choice_and_excluded_middle-lean-L512\">this gist</a> that could get you more familiar with intuitionistic logic.</p>",
        "id": 269941262,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643559337
    },
    {
        "content": "<p>Oh, me dumb. I knew that something was not quite right!</p>",
        "id": 269946868,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643566041
    }
]
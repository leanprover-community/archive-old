[
    {
        "content": "<p>Hello, I am a beginner and I am trying to define a path (in particular a path from <code>x</code> to <code>y</code> on a topological space).<br>\nI am sorry for the (temporary) maths notation of topological spaces and definitions.<br>\nNot knowing the syntax/ best way to impose the conditions  for the continuous function (f : I = [0,1] --&gt; X)  to be a path I thought of having a product <code>lean X  × (I → X) ×  Prop </code> as output. </p>\n<p>This is my code: </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">continuity</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">topological_space</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">infinite_sum</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">topological_structures</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">uniform_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">filter</span> <span class=\"n\">lattice</span> <span class=\"n\">classical</span>\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"c1\">-- ambient space</span>\n<span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">X</span>\n<span class=\"c1\">------ variable x : X</span>\n\n<span class=\"c1\">-- topological space (X, T)</span>\n<span class=\"kn\">variable</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">X</span>\n\n<span class=\"c1\">-- Interval [0, 1]</span>\n<span class=\"kn\">definition</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">I</span>\n\n<span class=\"kn\">variable</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">ℝ</span>\n\n<span class=\"c1\">-- Define inclusion map</span>\n<span class=\"kn\">definition</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>  <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"c1\">-- Define subspace topology [for Euclidean subspace topology?]</span>\n<span class=\"n\">def</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">I</span> <span class=\"o\">:=</span>\n<span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">induced</span>  <span class=\"n\">i</span> <span class=\"n\">E</span>\n\n<span class=\"c1\">-- PATH</span>\n<span class=\"kn\">variable</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n\n<span class=\"n\">def</span> <span class=\"n\">path_topological2</span>  <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span>  <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">×</span>  <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"o\">(</span> <span class=\"n\">f</span> <span class=\"n\">t</span> <span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">f</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">continuous</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">   type mismatch at application</span>\n<span class=\"cm\">  prod (f t)</span>\n<span class=\"cm\">term</span>\n<span class=\"cm\">  f t</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  X : Type u_1</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Type ? : Type (?+1)  -/</span>\n</pre></div>",
        "id": 129159440,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1530819308
    },
    {
        "content": "<p>What would be the best way to define a path? Also avoiding the <strong> type mismatch </strong> that arises in the definition?</p>",
        "id": 129159458,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1530819335
    },
    {
        "content": "<p>I don't understand what you are trying to do. But you could have a look at <code>data/sets/intervals</code> in mathlib</p>",
        "id": 129160116,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530820143
    },
    {
        "content": "<p>But actually it may be better to have path as a structure bundling a map from reals to X and the condition that it is continuous on [0, 1].</p>",
        "id": 129160140,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530820183
    },
    {
        "content": "<blockquote>\n<p>But actually it may be better to have path as a structure bundling a map from reals to X and the condition that it is continuous on [0, 1].</p>\n</blockquote>\n<p>I was not too sure whether use create as a structure or create a definition (later I would like define homotopy;  so I was thinking that (ideally) my definition of path would allow me to retrieve starting/ending points and the actual path (function f : I --&gt; X): this for possible re-parameterisations ( I --&gt; I ) )</p>\n<p>I know very little about structure, but I may try to look into your suggestion. Many Thanks!</p>",
        "id": 129161964,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1530822036
    },
    {
        "content": "<blockquote>\n<p>I don't understand what you are trying to do. But you could have a look at <code>data/sets/intervals</code> in mathlib</p>\n</blockquote>\n<p>PS: Are you referring to the part before the definition or the definition itself? <br>\nI included the code before definition  just to provide more information on the interval I (and the induced  subspace topology - which is meant to be induced from Euclidean topology on R ) and the topological space X of interest.</p>",
        "id": 129162181,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1530822260
    },
    {
        "content": "<p>A path is just a continuous function <code>I \\to X</code>, right? Or do you want a Type for paths from <code>x</code> to <code>y</code>?</p>",
        "id": 129185328,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530859438
    },
    {
        "content": "<p>It looks like he wants the end points to be parameters of the type</p>",
        "id": 129186563,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530861491
    },
    {
        "content": "<p>Hey Luca. So just to comment that <code>set ℝ</code> is a type so <code>I</code> is \"only\" a term. So when you make <code>topological_space I</code> something magic is happening: the term is being somehow promoted to a type. What's happening is that the term <code>  {x : ℝ | x ≤ 1 ∧ x ≥ 0}</code>(which is really a function) is being interpreted as the type <code>{x : ℝ // x ≤ 1 ∧ x ≥ 0}</code> implicitly (and this is a so-called subtype).  So when you write <code>t : I</code> then <code>t</code> might not be what you think it is -- it's a term of the subtype, so it has a value <code>t.val</code> which is the real number, and then a proof too, called <code>t.property</code>.</p>\n<p>The type mismatch is because <code>\\times</code>, the little cross, is for making types, not terms; a term of type <code>α × β</code> looks like <code>(a,b)</code>, like in maths.</p>",
        "id": 129187672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530863227
    },
    {
        "content": "<blockquote>\n<p>A path is just a continuous function <code>I \\to X</code>, right? Or do you want a Type for paths from <code>x</code> to <code>y</code>?</p>\n</blockquote>\n<p>Indeed, I would like the second one (a Type for paths from <code>x</code> to <code>y</code>) :)</p>",
        "id": 129187690,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1530863273
    },
    {
        "content": "<p>So you could build the type using a structure. You would have to decide whether to put things like <code>X</code> and <code>x</code> and <code>y</code> inside the structure or outside; this is the sort of question that I am terrible at.</p>",
        "id": 129187750,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530863374
    },
    {
        "content": "<p>So it could look like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">paths</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"err\">\\</span><span class=\"n\">to</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">...</span>\n</pre></div>\n\n\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">paths</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">start_point</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">end_point</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"err\">\\</span><span class=\"n\">to</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">...</span>\n</pre></div>\n\n\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">paths</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">HX</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">start_point</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"bp\">...</span>\n</pre></div>",
        "id": 129187876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530863525
    },
    {
        "content": "<p>In this case you definitely want <code>x</code> and <code>y</code> outside the structure</p>",
        "id": 129187887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530863551
    },
    {
        "content": "<p>Why?</p>",
        "id": 129187895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530863565
    },
    {
        "content": "<blockquote>\n<p>a Type for paths from <code>x</code> to <code>y</code></p>\n</blockquote>",
        "id": 129187906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530863580
    },
    {
        "content": "<p>:-)</p>",
        "id": 129187913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530863588
    },
    {
        "content": "<blockquote>\n<p>Hey Luca. So just to comment that <code>set ℝ</code> is a type so <code>I</code> is \"only\" a term. So when you make <code>topological_space I</code> something magic is happening: the term is being somehow promoted to a type. What's happening is that the term <code>  {x : ℝ | x ≤ 1 ∧ x ≥ 0}</code>(which is really a function) is being interpreted as the type <code>{x : ℝ // x ≤ 1 ∧ x ≥ 0}</code> implicitly (and this is a so-called subtype).  So when you write <code>t : I</code> then <code>t</code> might not be what you think it is -- it's a term of the subtype, so it has a value <code>t.val</code> which is the real number, and then a proof too, called <code>t.property</code>.</p>\n<p>The type mismatch is because <code>\\times</code>, the little cross, is for making types, not terms; a term of type <code>α × β</code> looks like <code>(a,b)</code>, like in maths.</p>\n</blockquote>\n<p>Thank you! I am in the process of digesting this...  I will try with the structure :)</p>",
        "id": 129187916,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1530863594
    },
    {
        "content": "<p>and Mario is saying that you want the first of my three options above.</p>",
        "id": 129187924,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530863613
    },
    {
        "content": "<p>I suspect that you might want to make <code>I</code>, the unit interval, into a subtype. If you don't then you'll have coercions everywhere. You'd perhaps be better off having the coercion from <code>I</code> to the reals.</p>",
        "id": 129187976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530863666
    },
    {
        "content": "<p>There is also the option of having the path \"defined\" on R but only use its values and continuity on I</p>",
        "id": 129188095,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530863851
    },
    {
        "content": "<p>Minimal version would be:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">real</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">path</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">start_pt</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">end_pt</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">cont</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">t</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">tendsto</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">t</span><span class=\"o\">)))</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">path</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">end_pt</span>\n</pre></div>",
        "id": 129188102,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530863869
    },
    {
        "content": "<p>Here's my suggestion:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">I01</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">//</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">I01</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">I01</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"n\">I01</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">zero_le_one</span><span class=\"bp\">⟩⟩</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"n\">I01</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">zero_le_one</span><span class=\"o\">,</span> <span class=\"n\">le_refl</span> <span class=\"bp\">_⟩⟩</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">path</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">I01</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">at_zero</span> <span class=\"o\">:</span> <span class=\"n\">to_fun</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">at_one</span> <span class=\"o\">:</span> <span class=\"n\">to_fun</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">cont</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">path</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">path</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 129188404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530864245
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120726\">@Luca Gerolla</span> Patrick's suggestion is an interesting one. It's a very \"non-maths\" way to think about things, but sometimes in computer science this seems to be the way it's done. Note that <code>cont</code> is an explicit proof that the map is continuous (using things called filters, which is a trick to enable you to talk about things tending to other things even when there's no metric). Note also that there's a trick with variables here -- this really says <code>structure path {X : Type} [topological_space X] (x y : X) :=...</code> Note also that there is a problem with equality here -- you can have two different terms of type <code>path x y</code> which are not literally equal but which are \"the same path\" because the maps are different but agree on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">[0,1]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">[</span><span class=\"mord mathrm\">0</span><span class=\"mpunct\">,</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">]</span></span></span></span>.</p>",
        "id": 129188438,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530864307
    },
    {
        "content": "<p>I think that in this case it is best to build up the theory of the interval as a type in its own right rather than totalizing a la isabelle</p>",
        "id": 129188441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530864317
    },
    {
        "content": "<p>Note again that mathlib does have a rudimentary theory of intervals (in totally ordered types).</p>",
        "id": 129188490,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530864368
    },
    {
        "content": "<p>Indeed you can prove that <code>I01</code> is compact in one line</p>",
        "id": 129188497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530864397
    },
    {
        "content": "<p>I'm not saying my way is best, I only wanted to point it out because, as pointed out by Kevin, it's very unlikely a mathematician or math student beginning Lean would think of it</p>",
        "id": 129188505,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530864427
    },
    {
        "content": "<p>Mario's version makes the interval a subtype, not a subset (so <code>I01</code> is a type), and the tricks beforehand with the instances make it a topological space and make it so you can talk about 0 and 1. His equality is equality of paths, however you are, I assume, not going to be interested in equality anyway, but homotopy equivalence, so you'll end up putting an equivalence relation on this structure anyway.</p>",
        "id": 129188506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530864434
    },
    {
        "content": "<p>The downside of Mario's version is it will be annoying to refer to any point in the interval, as seen in his definition of 0 and 1</p>",
        "id": 129188516,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530864478
    },
    {
        "content": "<p>The solution to this is to define appropriate functions on <code>I01</code> so that you abstract away the proof stuff</p>",
        "id": 129188567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530864531
    },
    {
        "content": "<p>For example you can probably get away with just a <code>has_mul</code> instance (the usual one) and a <code>has_neg</code> instance (the 1-x function)</p>",
        "id": 129188573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530864583
    },
    {
        "content": "<p>If you are going for homotopy theory, there is a clear test case: prove that concatenation of homotopy classes of path is associative, using various modelisation choices.</p>",
        "id": 129188574,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530864584
    },
    {
        "content": "<p>Also 1/2 should be a point in [0,1]</p>",
        "id": 129188622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530864615
    },
    {
        "content": "<p>exactly</p>",
        "id": 129188624,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530864623
    },
    {
        "content": "<p>from those I think you have enough to define everything else in homotopy theory</p>",
        "id": 129188629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530864649
    },
    {
        "content": "<p>Luca -- as far as I know nobody has done this sort of stuff in Lean, however it definitely looks possible to me and hopefully not too hard. I have to do admin today so I won't be hanging around in the computer room, but I will be in the department and will pop in occasionally. I think trying to define homotopy classes of paths etc would be a fabulous exercise for you or you/Rohan.</p>",
        "id": 129188696,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530864777
    },
    {
        "content": "<p>It's not quite true: Johan tried it</p>",
        "id": 129188705,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530864806
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/mathlib/pull/144\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/pull/144\">https://github.com/leanprover/mathlib/pull/144</a></p>",
        "id": 129188736,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530864843
    },
    {
        "content": "<p>this has some intersection with what Luca wants to try</p>",
        "id": 129188748,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530864858
    },
    {
        "content": "<p>Oh! Luca -- this is Johan Commelin. You might want to look at what he did (or you might want to figure it out yourself)</p>",
        "id": 129188750,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530864863
    },
    {
        "content": "<p>Thanks Patrick.</p>",
        "id": 129188752,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530864877
    },
    {
        "content": "<p>but it's geared towards homology, and biased towards abstraction (simplicial sets everywhere)</p>",
        "id": 129188758,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530864897
    },
    {
        "content": "<p>This is all very interesting, thank you very much everyone! :-)</p>",
        "id": 129188888,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1530865103
    },
    {
        "content": "<p>Hello, I am trying to define a function (<code> f </code> : X --&gt; Y , where X and Y are topological spaces)  in terms of its restrictions; to then exploit the fact  later that if the restrictions of <code> f </code>  (in this case fa : A --&gt; Y, fb : B ---&gt; Y - where A, B are closed ,  and they cover X) are continuous then the overall  function <code> f </code>is continuous (theorem already proved by <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  ). <br>\nUnfortunately I am struggling with set.inter and the coercions that \"naturally\" arise; in particular when I try to give a definition for the restrictions to match <code> fun_match </code> (i.e. fa = fb on <code> A \\and B  </code>) and to define f as fa on A and fb on B  <code>fun_pasting_closed </code>.</p>",
        "id": 130051069,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532173312
    },
    {
        "content": "<p>This is my code: </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">--- Attempt to define function (f : α → β ) in terms of its restriction</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">ga</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">gb</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">restriction</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">fun_match</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span> <span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">fb</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n<span class=\"c1\">--∀ x ∈  set.inter A B, fa x = fb x</span>\n<span class=\"c1\">--∀ x ∈ set.inter A B, fa x.val = fb x.val</span>\n<span class=\"c1\">--restriction fa ( set.inter A B) == restriction fb ( set.inter A B)</span>\n<span class=\"c1\">-- ∀ x, (restriction fa ( set.inter A B) ) x = (restriction fb ( set.inter A B) ) x</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">fun_match2</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">fb</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span>\n<span class=\"o\">(</span> <span class=\"n\">Ha</span> <span class=\"o\">:</span> <span class=\"n\">fa</span> <span class=\"bp\">=</span> <span class=\"n\">restriction</span> <span class=\"n\">f</span> <span class=\"n\">A</span> <span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">Hb</span> <span class=\"o\">:</span> <span class=\"n\">fb</span> <span class=\"bp\">=</span> <span class=\"n\">restriction</span> <span class=\"n\">f</span> <span class=\"n\">B</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"n\">def</span> <span class=\"n\">fun_pasting_closed</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span> <span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">fb</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"n\">HAcont</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">fa</span><span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">HBcont</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">fb</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">Hunion</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">HAclosed</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">HBclosed</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"n\">B</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">Hmatch</span> <span class=\"o\">:</span> <span class=\"n\">fun_match</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"c1\">--- λ t : X, if H : t ∈ A  then fa t else fb t</span>\n</pre></div>",
        "id": 130051111,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532173336
    },
    {
        "content": "<p>there are way too many topological space arguments in <code>fun_match</code></p>",
        "id": 130051195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532173514
    },
    {
        "content": "<p>Any help would be greatly appreciated</p>",
        "id": 130051196,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532173516
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def fun_match {X Y} {A B : set X} (fa : A → Y) (fb : B → Y) : Prop :=\n∀ x h₁ h₂, fa ⟨x, h₁⟩ = fb ⟨x, h₂⟩\n</pre></div>",
        "id": 130051245,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532173575
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>local attribute [instance] classical.prop_decidable\n\nnoncomputable def paste {X Y} {A B : set X} (Hunion : A ∪ B = set.univ) (fa : A → Y) (fb : B → Y) (t : X) : Y :=\nif h₁ : t ∈ A then fa ⟨t, h₁⟩ else\nhave t ∈ A ∪ B, from set.eq_univ_iff_forall.1 Hunion t,\nhave h₂ : t ∈ B, from this.resolve_left h₁,\nfb ⟨t, h₂⟩\n</pre></div>",
        "id": 130051367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532173862
    },
    {
        "content": "<p>we don't really need topology to define these functions; it only comes in for the continuity proof</p>",
        "id": 130051387,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532173917
    },
    {
        "content": "<p>Here's how you can prove it has the right values:</p>\n<div class=\"codehilite\"><pre><span></span>theorem paste_left {X Y} {A B : set X} (Hunion : A ∪ B = set.univ)\n  (fa : A → Y) (fb : B → Y) (t : X) (h : t ∈ A) :\n  paste Hunion fa fb t = fa ⟨t, h⟩ :=\ndif_pos _\n\ntheorem paste_right {X Y} {A B : set X} (Hunion : A ∪ B = set.univ)\n  (fa : A → Y) (fb : B → Y) (H : fun_match fa fb)\n  (t : X) (h : t ∈ B) :\n  paste Hunion fa fb t = fb ⟨t, h⟩ :=\nby by_cases h&#39; : t ∈ A; simp [paste, h&#39;]; apply H\n</pre></div>",
        "id": 130051589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532174186
    },
    {
        "content": "<p>do we really want to use the name <code>fun_match</code>? It is really similar to the internally generated variable <code>_fun_match</code></p>",
        "id": 130051606,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1532174218
    },
    {
        "content": "<p>that's fair</p>",
        "id": 130051616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532174226
    },
    {
        "content": "<p>mathlib uses <code>eq_on</code> for something very similar</p>",
        "id": 130051623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532174243
    },
    {
        "content": "<p>Thank you very much <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <br>\nFor the time being I renamed <code> fun_match </code> to <code> match_of_fun </code>. <br>\nWith your code the theorem <code> cont_of_paste </code> followed easily using (part of ) the pasting lemma; however, since this was done in terms of <code> restriction _ _ </code>, do you see an easy way to prove that the pasted <code> fa </code>, <code>fb </code> are indeed <code> restriction f A </code>, <code> restriction f B</code> respectively?  </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">rest_of_paste</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Hunion</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fb</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">}</span> <span class=\"o\">(</span> <span class=\"n\">Hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">paste</span> <span class=\"n\">Hunion</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span> <span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">fa</span> <span class=\"bp\">=</span> <span class=\"n\">restriction</span> <span class=\"n\">f</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">fb</span> <span class=\"bp\">=</span> <span class=\"n\">restriction</span> <span class=\"n\">f</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n\n<span class=\"n\">sorry</span><span class=\"o\">,</span>\n\n<span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- prove continuity when pasted continuous restrictions on closed sets</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">cont_of_paste</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n<span class=\"o\">{</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">Hunion</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">fb</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">HAclosed</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">HBclosed</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"n\">B</span><span class=\"o\">}</span>  <span class=\"o\">{</span> <span class=\"n\">Hmatch</span> <span class=\"o\">:</span> <span class=\"n\">match_of_fun</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span> <span class=\"o\">}</span>\n<span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">}</span> <span class=\"o\">(</span> <span class=\"n\">Hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">paste</span> <span class=\"n\">Hunion</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span> <span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">continuous</span> <span class=\"n\">fa</span> <span class=\"bp\">→</span> <span class=\"n\">continuous</span> <span class=\"n\">fb</span> <span class=\"bp\">→</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intros</span> <span class=\"n\">Ca</span> <span class=\"n\">Cb</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">ResA</span> <span class=\"o\">:</span> <span class=\"n\">fa</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">restriction</span> <span class=\"n\">f</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">rest_of_paste</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span> <span class=\"n\">Hf</span> <span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">ResB</span> <span class=\"o\">:</span> <span class=\"n\">fb</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">restriction</span> <span class=\"n\">f</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">rest_of_paste</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span> <span class=\"n\">Hf</span> <span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">ResA</span> <span class=\"n\">at</span> <span class=\"n\">Ca</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">ResB</span> <span class=\"n\">at</span> <span class=\"n\">Cb</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">continuous_closed_union</span> <span class=\"n\">f</span> <span class=\"n\">Hunion</span> <span class=\"n\">HAclosed</span> <span class=\"n\">HBclosed</span> <span class=\"n\">Ca</span> <span class=\"n\">Cb</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 130141208,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532342549
    },
    {
        "content": "<p>PS:  has <code> cont_of_paste </code> the right arguments?  Is  </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">}</span> <span class=\"o\">(</span> <span class=\"n\">Hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">paste</span> <span class=\"n\">Hunion</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span> <span class=\"o\">)</span>\n</pre></div>\n\n\n<p>the best way to specify <code> f </code> as a paste? Asking this because I have employed a similiar method to specify arguments which were functions of certain properties/definitions, and don't know if this makes things unnecessarily more convoluted.</p>",
        "id": 130141517,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532343026
    },
    {
        "content": "<p>If you want to prove two functions are equal, the <code>funext</code> tactic reduces you to checking their values are equal on every input. This might be what you need?</p>",
        "id": 130170170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532375616
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120726\">@Luca Gerolla</span> what about removing those two arguments and substituting <code>f</code> in directly? so your result would be <code>continuous (paste Hunion fa fb)</code></p>",
        "id": 130182032,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1532392375
    },
    {
        "content": "<blockquote>\n<p>If you want to prove two functions are equal, the <code>funext</code> tactic reduces you to checking their values are equal on every input. This might be what you need?</p>\n</blockquote>\n<p><code> funext </code> does help, together with <code>rw </code> and <code> unfold </code> leads to much more progress. Here is my \"nearly completed\" proof: </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">rest_of_paste</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Hunion</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fb</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">}</span> <span class=\"o\">(</span> <span class=\"n\">Hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">paste</span> <span class=\"n\">Hunion</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span> <span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">fa</span> <span class=\"bp\">=</span> <span class=\"n\">restriction</span> <span class=\"n\">f</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">fb</span> <span class=\"bp\">=</span> <span class=\"n\">restriction</span> <span class=\"n\">f</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">funext</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">restriction</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">Hf</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">paste</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">dif_pos</span><span class=\"o\">,</span> <span class=\"c1\">-- exact subtype.rec fa, exact subtype.rec_on,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span>  <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">⟨</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"bp\">_</span> <span class=\"bp\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">,</span>  <span class=\"n\">trivial</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"bp\">_</span> <span class=\"bp\">⟩</span><span class=\"o\">,</span>  <span class=\"n\">exact</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"o\">(</span> <span class=\"n\">H</span> <span class=\"o\">),</span> <span class=\"n\">exact</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"c1\">--rw H1,</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>  <span class=\"n\">exact</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n<span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>Is there a way to prove <code> fa x = fa ⟨x.val, ?m_1⟩ </code>?  (I thought the <code>have</code>s should do the job but then <code>rw H1</code> fails )</p>",
        "id": 130200013,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532423348
    },
    {
        "content": "<p>have you tried <code>simp</code> or <code>rw subtype.eta x.1 x.2</code></p>",
        "id": 130200168,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1532423587
    },
    {
        "content": "<p><code>cases x</code> will make this a lot easier</p>",
        "id": 130200179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532423631
    },
    {
        "content": "<p>Yes, simp does work! Thank you Chris, very silly of me not trying it.. sorry!</p>",
        "id": 130200222,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532423672
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">rest_of_paste</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Hunion</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fb</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">match_of_fun</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span><span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">Hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">paste</span> <span class=\"n\">Hunion</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span> <span class=\"o\">)</span>  <span class=\"o\">:</span>\n<span class=\"n\">fa</span> <span class=\"bp\">=</span> <span class=\"n\">restriction</span> <span class=\"n\">f</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">fb</span> <span class=\"bp\">=</span> <span class=\"n\">restriction</span> <span class=\"n\">f</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">funext</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">restriction</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">Hf</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">paste_left</span> <span class=\"n\">Hunion</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">],</span>\n  <span class=\"n\">funext</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">restriction</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">Hf</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">paste_right</span> <span class=\"n\">Hunion</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span> <span class=\"n\">H</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>Needed also the H hypotheses to complete the proof for <code>fb</code> , then <code>paste_**</code> simplified the proof further  :)</p>",
        "id": 130201370,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532425346
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111651\">@Nicholas Scheel</span> do you mean to  rewrite the statement as </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">cont_of_paste</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n<span class=\"o\">{</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">Hunion</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">fb</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">HAclosed</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">HBclosed</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"n\">B</span><span class=\"o\">}</span>  <span class=\"o\">{</span> <span class=\"n\">Hmatch</span> <span class=\"o\">:</span> <span class=\"n\">match_of_fun</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span> <span class=\"o\">}</span>\n<span class=\"o\">(</span> <span class=\"n\">CA</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">fa</span> <span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">CB</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">fb</span><span class=\"o\">)</span>  <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"n\">paste</span> <span class=\"n\">Hunion</span> <span class=\"n\">fa</span> <span class=\"n\">fb</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</pre></div>\n\n\n<p>?</p>",
        "id": 130201385,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532425388
    },
    {
        "content": "<blockquote>\n<p>Is there a way to prove <code> fa x = fa ⟨x.val, ?m_1⟩ </code>?  (I thought the <code>have</code>s should do the job but then <code>rw H1</code> fails )</p>\n</blockquote>\n<p>Luca I mentioned this in my talk yesterday. The problem here is that x is <code>\\&lt;x.val,x.property\\&gt;</code> but you're trying to compare <code>x</code> with <code>\\&lt;x.val,h\\&gt;</code> for <code>h</code> some (un-named, that's why it says ?m_1) other proof of the thing that <code>x.property</code> is a proof of. Because these are both proofs of the same thing, they're definitionally equal by definition, so actually <code>x = ⟨x.val, ?m_1⟩</code> . Take a look at theorems like <code>subtype.eq</code> and <code>subtype.eta</code> to see the various tricks that can be used, but remember  that <code>simp</code> will know all the important ones.</p>",
        "id": 130204505,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532430442
    },
    {
        "content": "<p>the easy proof is <code>cases x, refl</code></p>",
        "id": 130204515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532430477
    },
    {
        "content": "<p>I usually do cases on a variable like this before proofs, because everything becomes definitionally true that way</p>",
        "id": 130204566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532430523
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120726\">@Luca Gerolla</span> yes that’s what I meant, but it‘s not a big deal either way – looks like you’re making progress on it already :)</p>",
        "id": 130220203,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1532448446
    },
    {
        "content": "<p>So I am a bit confused as to why typeclass inference doesn't put a topology on the subtype of a topological space. Here's some non-pasteable code:</p>",
        "id": 130245778,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532476808
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">is_continuous</span> <span class=\"c1\">-- Spv.is_continuous : Spv ?M_1 → Prop</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Cont</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">vs</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span> <span class=\"bp\">//</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">is_continuous</span> <span class=\"n\">vs</span><span class=\"o\">}</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- works</span>\n\n<span class=\"c1\">--example (R : Type) [comm_ring R] [topological_space R] [topological_ring R] :</span>\n<span class=\"c1\">--topological_space (Cont R) := by apply_instance -- fails</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">Cont</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">topological_space</span>\n</pre></div>",
        "id": 130245786,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532476812
    },
    {
        "content": "<p><code>Spv R</code> is a topological space, and type class inference knows this. I then make a subtype, and even though <code>subtype.topological_space</code> is marked as an instance, type class inference doesn't seem to work. Is this to do with <code>topological_space</code> being a structure with the class attribute rather than a class?</p>",
        "id": 130245821,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532476879
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">topological_space</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">topological_space</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>",
        "id": 130245882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532476978
    },
    {
        "content": "<p>My MWE works :-/</p>",
        "id": 130245885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532476984
    },
    {
        "content": "<p>It can infer a topological space structure on <code>{vs : Spv R // Spv.is_continuous vs}</code> but not if you give it a different names.</p>",
        "id": 130246071,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1532477293
    },
    {
        "content": "<p>because type class inference looks at the <code>expr</code></p>",
        "id": 130246074,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1532477323
    },
    {
        "content": "<p>So am I OK to make the instance like I did?</p>",
        "id": 130246087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532477350
    },
    {
        "content": "<p>I don't want to make diamonds</p>",
        "id": 130246091,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532477362
    },
    {
        "content": "<p>Don't see why not. It's a defeq diamond, and it's not even a diamond really because there's only one path it will choose.</p>",
        "id": 130246138,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1532477414
    },
    {
        "content": "<p>Thanks Chris.</p>",
        "id": 130246147,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532477465
    },
    {
        "content": "<p>You will notice the pattern <code>by unfold foo; apply_instance</code> used for this sort of situation (although an alternative is to do the first step of instance work yourself, as you did)</p>",
        "id": 130259969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532503996
    },
    {
        "content": "<p>I think I prefer your solution -- it sounds safer. I hadn't really internalised this type class inference fact though -- so it's picky about defeq like <code>rw</code>?</p>",
        "id": 130262773,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532508166
    },
    {
        "content": "<p>yes, it only unfolds <code>reducible</code> definitions</p>",
        "id": 130262843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532508262
    },
    {
        "content": "<p>This is a good thing, because it means you can attach different typeclasses to defeq things, like <code>with_top A = with_bot A</code></p>",
        "id": 130262867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532508310
    },
    {
        "content": "<p>So naming a def is a way of controlling what typeclasses you want to inherit</p>",
        "id": 130262892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532508360
    },
    {
        "content": "<p>I guess it sometimes makes sense to make definitions reducible. What do you think about <code>Cont</code>? Might that be a case where <code>reducible</code> makes sense?</p>",
        "id": 130262934,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1532508374
    },
    {
        "content": "<p>I find that it is almost never a good idea to mark a definition <code>reducible</code></p>",
        "id": 130262943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532508405
    },
    {
        "content": "<p>You make it reducible and any goal with <code>Cont</code> in just gets unfolded and looks more unreadable. I think.</p>",
        "id": 130263136,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532508649
    },
    {
        "content": "<p>Yes, so let's not do that. After all, <code>unfold</code>ing isn't very hard to do, if we need it.</p>",
        "id": 130263163,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1532508715
    },
    {
        "content": "<p>Hello, has it been proved anywhere that a closed interval  [r, s]  is indeed closed?<br>\n I am stuck proving that a subset  <code> T r s Hrs </code>( closed subinterval [r,s] ) of  <code> I01 </code> ( unit interval [0, 1] ) is closed </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- May be needed / useful for Guillermo - Heine-Borel Thm</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">is_closed_int</span> <span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">}</span> <span class=\"o\">(</span> <span class=\"n\">Hrs</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"o\">(</span><span class=\"n\">int_clos</span> <span class=\"n\">Hrs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span> <span class=\"n\">sorry</span> <span class=\"kn\">end</span>\n\n\n<span class=\"kn\">lemma</span> <span class=\"n\">T_is_closed</span>  <span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">}</span> <span class=\"o\">(</span> <span class=\"n\">Hrs</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s</span> <span class=\"o\">):</span> <span class=\"n\">is_closed</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">Hrs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span> <span class=\"n\">unfold</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">is_closed_iff_nhds</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n        <span class=\"o\">(</span><span class=\"k\">begin</span> <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">H</span> <span class=\"o\">,</span> <span class=\"c1\">--by_contradiction,</span>\n\n        <span class=\"n\">sorry</span> <span class=\"o\">,</span>\n    <span class=\"kn\">end</span><span class=\"o\">),</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">T_is_closed2</span>  <span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">}</span> <span class=\"o\">(</span> <span class=\"n\">Hrs</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s</span> <span class=\"o\">):</span> <span class=\"n\">is_closed</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">Hrs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span> <span class=\"n\">unfold</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n<span class=\"c1\">-- Write in terms of intersection with I01 (i.e. T r s Hrs =  I01 ∧  closed_int Hrs), resolving subset nesting problem</span>\n    <span class=\"c1\">-- Prove auxilliary lemma that (closed_int Hrs) is indeed closed</span>\n        <span class=\"c1\">-- Use is_closed_inter to prove this lemma</span>\n<span class=\"c1\">--have Int : {x : ↥I01 | r ≤ x.val ∧ x.val ≤ s} = set.inter univ  (closed_int Hrs) ,</span>\n<span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>With the underlying definitions </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">I01</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">T</span> <span class=\"o\">(</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">Hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">I01</span> <span class=\"o\">:=</span>  <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">I01</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">int_clos</span> <span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">}</span> <span class=\"o\">(</span> <span class=\"n\">Hrs</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>  <span class=\"bp\">|</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 130413232,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532701209
    },
    {
        "content": "<p>it's even compact</p>",
        "id": 130413243,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1532701218
    },
    {
        "content": "<blockquote>\n<p>it's even compact</p>\n</blockquote>\n<p>Indeed! :)</p>",
        "id": 130413266,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532701253
    },
    {
        "content": "<p>what I mean is it's even proved that it is compact</p>",
        "id": 130413279,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1532701265
    },
    {
        "content": "<p>Check out the stuff around <code>ordered_topology</code> in <code>analysis.topology.topological_structures</code>, such as <code>is_closed_le</code></p>",
        "id": 130413304,
        "sender_full_name": "Reid Barton",
        "timestamp": 1532701298
    },
    {
        "content": "<p>Oh, haven't thought to approach it from compactness..</p>",
        "id": 130413315,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532701307
    },
    {
        "content": "<p>that isn't what I mean either, what I mean is that we even proved that it is compact, so I would expect it to be proved that it is closed</p>",
        "id": 130413384,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1532701330
    },
    {
        "content": "<p>Luca -- what Kenny means is \"the answer to your first question is almost certainly yes\". Here are some things which should be in mathlib <em>somewhere</em> : (1) interval [r,s] as a subspace of [0,1] with subspace topology will be closed in [0,1] if it is closed in R (2) interval [r,s] is closed in R. Reid is suggesting some places in mathlib where you might well find the theorems you want.</p>\n<p>As a rule of thumb, when you are working on \"high level\" stuff like this, your first instinct should be to look in the library to see what is there. I know it sometimes feels a bit daunting but you could do worse than looking at a whole bunch of those topology files and looking through them. They are often long and complex, and written by experts so the proofs are often incomprehensible. But the trick is to find such a file, then to scan over it once and try and find the <em>definitions</em>, and see if you can figure out what they are supposed to be (because they are kind of like notation -- they are the language the file is written in, in some sense) and then scan over it again and try and find the <em>statements of the main theorems</em>.  Some clues as to whether a theorem is a \"main theorem\" -- it might be called \"theorem\" rather than \"lemma\", it might have a docstring (a comment starting with <code>/-- ... -/</code> -- note two dashes not one), or it might have a long proof. <em>DO NOT TRY TO READ ANY LONG PROOFS!</em>. You will get depressed and it will all seem much harder. If you find that you simply cannot understand a file because e.g. the definitions are constantly using things you've not heard of, then perhaps you started too late; look at the files which are imported at the very top and try reading one of those instead. Remember also that if a file compiles perfectly then you should be able to hover over anything and see its definition, or right click on it and see it in context. </p>\n<p>I remember finding the files where rationals and reals were defined very intimidating to read, but that was before I started picking up some of the tricks I mention above.</p>",
        "id": 130414100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532702063
    },
    {
        "content": "<p><code>is_closed_Icc</code><br>\n<a href=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_structures.lean#L282-L283\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_structures.lean#L282-L283\">https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_structures.lean#L282-L283</a></p>",
        "id": 130415106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532703125
    },
    {
        "content": "<p>mathlib doesn't really use <code>theorem</code> vs <code>lemma</code> distinction (or at least I don't like to make this distinction)</p>",
        "id": 130415280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532703335
    },
    {
        "content": "<p>I'm not sure it's worth focusing on \"important theorems\" either when reading mathlib files - you will usually be interested in easy theorems anyway. <code>is_closed_Icc</code> is an easy theorem</p>",
        "id": 130415388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532703434
    },
    {
        "content": "<blockquote>\n<p>Check out the stuff around <code>ordered_topology</code> in <code>analysis.topology.topological_structures</code>, such as <code>is_closed_le</code></p>\n</blockquote>\n<p>Thank you very much, <code>is_closed_le' </code> and  `is_closed_ge'  allowed me to prove [r, s] is closed without getting to use nhds and filters!</p>",
        "id": 130415529,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532703602
    },
    {
        "content": "<p><code>is_closed_Icc </code> would have made it even quicker! (should have updated my mathlib to notice it!)  :)</p>",
        "id": 130415717,
        "sender_full_name": "Luca Gerolla",
        "timestamp": 1532703744
    }
]
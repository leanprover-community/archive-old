[
    {
        "content": "<p>I'm picking back up some work I was doing with <a href=\"https://leanprover-community.github.io/mathlib_docs/linear_algebra/lagrange.html\">https://leanprover-community.github.io/mathlib_docs/linear_algebra/lagrange.html</a>.</p>\n<p>One issue I have here is that, quite commonly, one wants to talk of a (finite) set of interpolation points, and the values they take at those points.</p>\n<p>Naively, I would think to represent this as an (injective) map from a fintype to my field, and then a separate map from my fintype to the field, representing the point and their values.</p>\n<p>The difficulty with this is that it's difficult to then take \"the product over the fintype for all j \\= to some (fixed) i\", which is relevant in the interpolation. And indeed, in the above, we define the interpolation for a finset in particular. The difficulty then is that my finset, as well as being a set of points in my field, also ends up indexing, say, the values a polynomial takes on them.</p>\n<p>This also has the effect of impose a decidable_eq constraint on the field which I'm not sure is warranted: I think this comes from the use of \"finset.erase\", but really what is necessary is that you have decidable equality on your <em>indexing</em> finset/fintype.</p>\n<p>Do you see my issue? What do you think the best way to solve this would be? Is it worth re-factoring <a href=\"https://leanprover-community.github.io/mathlib_docs/linear_algebra/lagrange.html\">https://leanprover-community.github.io/mathlib_docs/linear_algebra/lagrange.html</a> in order to remove this decidable_eq constraint on the field (which as I say I am not sure is necessary)?</p>",
        "id": 287693862,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656410174
    },
    {
        "content": "<p>You can get rid of decidable_eq by going back to the underlying list of the finset, and if you define <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lagrange.basis\">docs#lagrange.basis</a> using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.prod\">docs#list.prod</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lagrange.interpolate\">docs#lagrange.interpolate</a> using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.sum\">docs#list.sum</a> you don't need decidable_eq, as you can remove the nth element from a list without decidable_eq. If you then show the resulting Lagrange polnomial is independent of the list (a chosen ordering) then it descends to a function on <code>finset F</code>.<br>\nI'm not sure you should worry too much about dicidable_eq though. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.X\">docs#polynomial.X</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.C\">docs#polynomial.C</a> are already <code>noncomputable</code> (boils down to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.single\">docs#finsupp.single</a> being noncomputable), but I'd expect the above definition should unfold/reduce/eval(?) more nicely than the current one; if you have a computable finset I think it can be definitionally reduce to an expression involving X and C without decidable_eq.</p>",
        "id": 287739472,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1656432888
    },
    {
        "content": "<p>I've been playing around with something which I'm more or less ready to share. How do I create PRs which depend on one another?</p>",
        "id": 287756544,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656440765
    },
    {
        "content": "<p>(tl;dr doing everything on fintypes seems very viable, matches with mv_polynomial in some nice ways, and gives shorter proofs most of the time)</p>",
        "id": 287756618,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656440809
    },
    {
        "content": "<p>Actually, you know what, if I factor this in the right way, it won't matter.</p>",
        "id": 287756894,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656440946
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/15036\">https://github.com/leanprover-community/mathlib/pull/15036</a></p>",
        "id": 287758243,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656441566
    },
    {
        "content": "<p>Here - I decided it would just be easier to do the refactor and then people could comment on it.</p>\n<p>The issue, by the way, isn't the decidable equality of the finset in the way I think you are describing, <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>. The previous formulation needed decidable equality <em>of the whole field</em>: that's extremely strong compared to, say, decidable equality of <code>fin n</code>.</p>",
        "id": 287758446,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656441664
    },
    {
        "content": "<p>If you index things injectively by a decidably equal fintype, then you don't care about equality on the field.</p>",
        "id": 287758577,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656441725
    },
    {
        "content": "<p>Well an injective function from <code>fin n</code> is equivalent to an ordering on the <code>finset</code>, namely a <code>list</code>. However it's indeed weird that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lagrange.interpolate\">docs#lagrange.interpolate</a> takes a function from F to F, and your PR would allow a function from the finset/fintype to F, which seems better. And I agree that using an indexing type might be more convenient in some cases.</p>",
        "id": 287759465,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1656442181
    },
    {
        "content": "<p>Indeed, but I have injective functions from arbitrary fintypes (fin n is just the obvious special case).</p>",
        "id": 287764096,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656444276
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/116395-maths/topic/Lagrange.20interpolants/near/287756544\">said</a>:</p>\n<blockquote>\n<p>How do I create PRs which depend on one another?</p>\n</blockquote>\n<p>One way to do this (perhaps not simplest or most efficient, idk) is to create the first PR (e.g. in branch <code>my_branch_one</code>) then open a new branch for the dependent PR and do <code>git merge my_branch_one</code>.  Then when you create a PR from the second branch, add a line in the comments indicating the dependency, e.g. <code>- [ ] depends on: #54321 [Using stuff from my first branch]</code>.</p>",
        "id": 287764543,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1656444526
    },
    {
        "content": "<p>Thanks for the review <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span></p>",
        "id": 287764795,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656444656
    },
    {
        "content": "<p>as you noticed I had throughly de-simped it, so thanks for the skutwork.</p>",
        "id": 287764832,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656444677
    },
    {
        "content": "<p><code>interpolate_eq_interpolate_erase_add</code> has proved challenging to translate into this refactor. I am inclined to ditch it - there are I think other things one might want to prove about the Lagrange interpolants (for instance, other ways of constructing them) but my suspicion is that there will be better routes to this.</p>",
        "id": 287785093,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656455527
    },
    {
        "content": "<p>I'm not sure how we handle operating over a subtype of a fintype acting as an index, in general.</p>",
        "id": 287785236,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656455621
    },
    {
        "content": "<p>I would strongly advise you to not use an indexing fintype, but instead a finset inside an indexing type.</p>",
        "id": 287785852,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656456021
    },
    {
        "content": "<p>This makes adding/removing  elements less awkward and lets you take finsets in the field by considering the field itself as the indexing type.</p>",
        "id": 287785914,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656456075
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span>; these Zulip discussions are great, but can you make sure to link the PR from the Zulip thread (<a href=\"https://github.com/leanprover-community/mathlib/pull/15036\">#15036</a>?) and vice versa in future? It makes it easier to track what's going on!</p>",
        "id": 287787893,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656457365
    },
    {
        "content": "<p>Ah, so the link here is fine, but I need to link it back the other way?</p>",
        "id": 287789452,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656458477
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> that's a nice idea, I see the logic of it. How do you pair up nodes and values using that approach?</p>",
        "id": 287789558,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656458545
    },
    {
        "content": "<p>It would be more readable if you were writing <a href=\"https://github.com/leanprover-community/mathlib/pull/15036\">#15036</a> instead of <a href=\"https://github.com/leanprover-community/mathlib/pull/15036\">https://github.com/leanprover-community/mathlib/pull/15036</a></p>",
        "id": 287789567,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656458554
    },
    {
        "content": "<p>Right - and what about the link back?</p>",
        "id": 287789596,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656458581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/116395-maths/topic/Lagrange.20interpolants/near/287789558\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> that's a nice idea, I see the logic of it. How do you pair up nodes and values using that approach?</p>\n</blockquote>\n<p>Have them both be indexed families indexed by the same finset?</p>",
        "id": 287789617,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656458598
    },
    {
        "content": "<p>Write something like <a href=\"#narrow/stream/116395-maths/topic/Lagrange.20interpolants\">Zulip</a></p>",
        "id": 287789638,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656458620
    },
    {
        "content": "<p>Hmm - the thing is that sometimes it is really natural to consider these things as fin n -&gt; tuples, rather than, say, going from finset.range (which I think is what you would do with that approach).</p>",
        "id": 287789740,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656458695
    },
    {
        "content": "<p>You can always index them by <code>univ : finset (fin n)</code>.</p>",
        "id": 287789782,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656458728
    },
    {
        "content": "<p>The question I suppose is how this stuff is to be used - it isn't currently and I can only testify from my use-case.</p>",
        "id": 287789792,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656458735
    },
    {
        "content": "<p>(in which there's little need for adding/removing points)</p>",
        "id": 287789818,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656458759
    },
    {
        "content": "<p>Please please please give it a try. I've add extensive experience with similar things and finset-indexed families are by far the least painful.</p>",
        "id": 287789901,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656458800
    },
    {
        "content": "<p>I'll certainly have a go - do you have a link to something that uses a similar approach so I have something to model off?</p>",
        "id": 287789939,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656458832
    },
    {
        "content": "<p>I've seen plenty of fintype-indexed stuff but much less finset-indexed stuff.</p>",
        "id": 287789955,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656458851
    },
    {
        "content": "<p><del>docs#finpartition comes to mind</del> oh, that's not indexed</p>",
        "id": 287789980,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656458867
    },
    {
        "content": "<p>Apologies, I totally missed that you had already linked to the PR above!</p>",
        "id": 287790061,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656458908
    },
    {
        "content": "<p>No worries - it would be a bit odd of me if I hadn't for sure.</p>",
        "id": 287790119,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656458974
    },
    {
        "content": "<p>Typically, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum\">docs#finset.sum</a></p>",
        "id": 287790127,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656458980
    },
    {
        "content": "<p>Also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sup\">docs#finset.sup</a></p>",
        "id": 287790197,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656459007
    },
    {
        "content": "<p>This case is a bit unusual though because the map has to be injective, so the only motivation for this refactor seems to be one of computability?</p>",
        "id": 287790300,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656459078
    },
    {
        "content": "<p>No</p>",
        "id": 287790314,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459088
    },
    {
        "content": "<p>It's also because the current version interpolates over a whole function F -&gt; F. But this is an unusual place to start.</p>",
        "id": 287790341,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459120
    },
    {
        "content": "<p>Doesn't it let you specify an arbitrary finset of F?</p>",
        "id": 287790431,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656459166
    },
    {
        "content": "<p>As the nodal points.</p>",
        "id": 287790442,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459178
    },
    {
        "content": "<p>What's more usual is the following: you have some nodal points, which I'll index in the obvious way but we understand that it could be more general: x_1, x_2, ..., x_n. You have some values, r_1, ..., r_n. You construct a polynomial p of minimal degree such that p(x_i) = r_i.</p>",
        "id": 287790510,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459240
    },
    {
        "content": "<p>Ah. I missed that you needed to match up elements of two finsets</p>",
        "id": 287790612,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656459304
    },
    {
        "content": "<p>The current formulation is the following: given some finset s, and some function f : F -&gt; F, construct a polynomial p of minimal degree such that p(x) = f(x) for all x in s</p>",
        "id": 287790613,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459304
    },
    {
        "content": "<p>Yes - it's the matching up which is the tricky part, and why I've reformulated in the way that I did, after thinking about it and trying a few things. It ran through very smooth this way.</p>",
        "id": 287790654,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459348
    },
    {
        "content": "<p>I think what Yaël is proposing is roughly <code>(s : finset ι) (x : ι ↪ F) (r : ι → F)</code>?</p>",
        "id": 287790738,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656459402
    },
    {
        "content": "<p>And actually btw - the second lot isn't a finset necessarily: they don't have to be distinct.</p>",
        "id": 287790752,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459418
    },
    {
        "content": "<p>or <code>(s : finset F) (r : F → F)</code></p>",
        "id": 287790765,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656459435
    },
    {
        "content": "<p>That's what we have today</p>",
        "id": 287790776,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656459446
    },
    {
        "content": "<p>Yes: I don't want r: F -&gt; F. That's just what we already have, and it isn't useful in my actual context to do the actual maths you want to do with this</p>",
        "id": 287790795,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459469
    },
    {
        "content": "<p>What you describe there is nearly what I have, Eric - though I'm not sure how the finset gets folded in.</p>",
        "id": 287790880,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459516
    },
    {
        "content": "<p>It's the union of what you have and what we had before</p>",
        "id": 287790896,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656459535
    },
    {
        "content": "<p>Yes. I mean I'm perfectly happy to find something that works for everyone - but I have found my formulation very straightforward to work with and it works for my context. I do agree that erasing or adding nodes is hard though - it could be nice to fix that.</p>",
        "id": 287790961,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459594
    },
    {
        "content": "<p>One other thing to consider; <code>(s : finset F) (r : F → F)</code> in this case can be represented neatly as <code>r' : F →₀ F</code></p>",
        "id": 287791056,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656459677
    },
    {
        "content": "<p>Yes, I had actually wondered about the use of finsupps somehow.</p>",
        "id": 287791074,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459705
    },
    {
        "content": "<p>And then my spelling above amounts to having <code>r' = r.map_domain f</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.map_domain\">docs#finsupp.map_domain</a>)</p>",
        "id": 287791180,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656459783
    },
    {
        "content": "<p>A key test I would like to try is if my definition of the interpolant is compatible with, say, the construction of the interpolant using the derivative (I already have some work doing this, using current-mathlib).</p>",
        "id": 287791184,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459793
    },
    {
        "content": "<p>This sort of thing does often leave you wanting to erase stuff from sums.</p>",
        "id": 287791213,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459821
    },
    {
        "content": "<p>How does finsupp work? If you use finsupp you can't specify any element to be mapped to 0.</p>",
        "id": 287791269,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1656459849
    },
    {
        "content": "<p>Yeah I mean that is the issue - you want to lead values outside the nodal values unspecified.</p>",
        "id": 287791330,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459912
    },
    {
        "content": "<p>That's why I am suspicious of anything that starts with F -&gt; F: clearly that's a thing you want to be able to work with, that's why I define <code>interpolate_at</code>.</p>",
        "id": 287791389,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459962
    },
    {
        "content": "<p>But I'm not sure it should be the core definition.</p>",
        "id": 287791426,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656459973
    },
    {
        "content": "<p>Whoops. Clutching at straws, <code>F →₀ with_zero F</code> ought to be a faithful representation, but I doubt it's useful</p>",
        "id": 287791480,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656460024
    },
    {
        "content": "<p>Yes that sounds highly suspect. Again, in the context I am working in - I'm not going to fully explain it but, it's Goppa codes, it's always Goppa codes, I hate it, free me from this <em>ahem</em> - you really do have like, a fixed number of points that you care about, and those points are fixed.</p>",
        "id": 287791579,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460104
    },
    {
        "content": "<p>That's why - look you can say \"ho ho ho I'm very good at Lean and this works better\" all you like but I did do it this way for a reason - just picking some fintype or finset or whatever, fixing that, and using that to index is very natural.</p>",
        "id": 287791622,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460162
    },
    {
        "content": "<p>Ultimately if you pick a finset I think you're going to want to be thinking about functions from it anyway and then you're just promoting it to a type.</p>",
        "id": 287791647,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460192
    },
    {
        "content": "<p>I don't disagree, I just wonder if we're missing some primitive collection type</p>",
        "id": 287791701,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656460212
    },
    {
        "content": "<p>Cotton?</p>",
        "id": 287791707,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460219
    },
    {
        "content": "<p>Oh I see. I mean I suppose, technically, all I need is some labels for my nodes and they don't have to be homogeneous? So maybe there's some absolutely demented ways of labelling them with heterogeneous types.</p>",
        "id": 287791758,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460286
    },
    {
        "content": "<p>But uh - I don't want to. &lt;_&lt;</p>",
        "id": 287791771,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460303
    },
    {
        "content": "<p>I will say that I did first of all try indexing the values with the node finset. It just ended up a lot messier and I kept fighting against myself.</p>",
        "id": 287791873,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460381
    },
    {
        "content": "<p>What I'm curious about is whether something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">indexed_dict</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">keys</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">↪</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">values</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">indexed_dict.get</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- computable by enumeration</span>\n</code></pre></div>\n<p>is a useful abstraction for this kind of problem</p>",
        "id": 287791929,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656460439
    },
    {
        "content": "<p>I'm not sure I understand the role that s has here.</p>",
        "id": 287791986,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460464
    },
    {
        "content": "<p>(Incidentally, this is a side point, I think one reason it is nice to get more computability here even though at the current time it doesn't matter, is that in some future Lean 4 world where we're actually doing computation, somebody is going to want to write a numerical methods library and at that time they'll thank us if the interpolant works nicely.)</p>",
        "id": 287792073,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460560
    },
    {
        "content": "<p>(they'll be very annoyed that polynomial is noncomputable first though)</p>",
        "id": 287792135,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656460592
    },
    {
        "content": "<p>yes in this perfect world I'm imagining we've fixed that perverse state of affairs</p>",
        "id": 287792150,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460622
    },
    {
        "content": "<p>I mean it's like that for very good reasons but it's also a funny joke</p>",
        "id": 287792159,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460635
    },
    {
        "content": "<p>I imagine in practice we might have \"computable polynomials\" and \"theorem polynomials\" and some translation between them, a la how we have array I think because it's fast even though we don't really do, say, linear algebra proofs with it.</p>",
        "id": 287792257,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460716
    },
    {
        "content": "<p>Incidentally my framework also fits well into the lemmas at the top (reworked versions of existing ones) which link to the vandermonde. If you look at how the matrix.vandermonde lemmas work, it's all about doing this kind of thing with indexes.</p>",
        "id": 287792306,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460787
    },
    {
        "content": "<p>In the case of the vandermonde you have to do stuff with fin n but you can fix that (noncomputably, but that's fine enough for government work).</p>",
        "id": 287792372,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460821
    },
    {
        "content": "<p>I'm really very, very happy with how easy those proofs were (with only a little bit of massaging). The vandermonde is the key link between Lagrange interpolation and linear algebra (and thus the particular link between polynomials and linear algebra which is key for This Sort Of Thing).</p>",
        "id": 287792507,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460929
    },
    {
        "content": "<p>It's basically the best gadget.</p>",
        "id": 287792528,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656460965
    },
    {
        "content": "<blockquote>\n<p>I imagine in practice we might have \"computable polynomials\" and \"theorem polynomials\" and some translation between them, a la how we have array I think because it's fast even though we don't really do, say, linear algebra proofs with it.</p>\n</blockquote>\n<p>Some discussions in this twitter thread last November:<br>\n<a href=\"https://twitter.com/XenaProject/status/1462788134584954881\">https://twitter.com/XenaProject/status/1462788134584954881</a><br>\n<a href=\"https://twitter.com/XenaProject/status/1462475753556221953\">https://twitter.com/XenaProject/status/1462475753556221953</a><br>\n<a href=\"https://twitter.com/XenaProject/status/1462800104541376524\">https://twitter.com/XenaProject/status/1462800104541376524</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/XenaProject/status/1462788134584954881\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/9686557e167ea0d81d62930b9cefbd210a469b3c/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313236333831303239373536303733353734342f674d69616e515f565f6e6f726d616c2e6a7067\"></a><p><a href=\"https://twitter.com/EscardoMartin\">@EscardoMartin</a> <a href=\"https://twitter.com/jjcarett2\">@jjcarett2</a> Well this is an interesting idea. I remember when Lean switched from constructive to nonconstructive polynomials (and I remember why too -- we were having problems proving theorems about constructive polys). But wouldn't having both `poly` and `constructive_poly` be a minefield?</p><span>- Kevin Buzzard (@XenaProject)</span></div></div><div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/XenaProject/status/1462475753556221953\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/9686557e167ea0d81d62930b9cefbd210a469b3c/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313236333831303239373536303733353734342f674d69616e515f565f6e6f726d616c2e6a7067\"></a><p><a href=\"https://twitter.com/jjcarett2\">@jjcarett2</a> <a href=\"https://twitter.com/EscardoMartin\">@EscardoMartin</a> In Lean we rejected constructive polynomials because they were simply too tedious to work with; constructivism caused pain, and the only gain was constructive polynomial addition. Instead we have a *tactic* for doing polynomial addition, and this will do for us.</p><span>- Kevin Buzzard (@XenaProject)</span></div></div><div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/XenaProject/status/1462800104541376524\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/9686557e167ea0d81d62930b9cefbd210a469b3c/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313236333831303239373536303733353734342f674d69616e515f565f6e6f726d616c2e6a7067\"></a><p><a href=\"https://twitter.com/jonmsterling\">@jonmsterling</a> <a href=\"https://twitter.com/EscardoMartin\">@EscardoMartin</a> <a href=\"https://twitter.com/jjcarett2\">@jjcarett2</a> You say \"coefficients are 0 except for degrees in this explicit finset\" where a finset is a constructive finite subset of the naturals, so now you can't add them because you can't tell whether the coefficient of x^3 is zero because you can't decide a+b=0 in the reals.</p><span>- Kevin Buzzard (@XenaProject)</span></div></div>",
        "id": 287792680,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1656461116
    },
    {
        "content": "<p>Interesting! I leave that stuff to cleverer minds than I.</p>",
        "id": 287793024,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656461487
    },
    {
        "content": "<p>I am simply small brain cavewoman and want to know that x + x + x^2 + x = x^2 + 3*x.</p>",
        "id": 287793105,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656461551
    },
    {
        "content": "<p>(Which I assume is ultimately how you do it in the simple case, use some sparkly ubertactic to put polynomials in some normal form.)</p>",
        "id": 287793133,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656461596
    },
    {
        "content": "<p>The noncomputability of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.single\">docs#finsupp.single</a> comes from the need to distinguish between zero and nonzero, hence the need of decidable_eq, supplied by the classical instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">finsupp.single</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">support</span> <span class=\"o\">:=</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">∅</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">},</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">mem_support_to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>A more computable implementation of <code>finsupp</code> would be the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span>\n  <span class=\"n\">data.finset.basic</span>\n  <span class=\"n\">data.setoid.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">finsupp_aux</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">support</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mem_support_to_fun</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">support</span><span class=\"o\">)</span> <span class=\"c1\">-- notice this is no longer iff</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finsupp</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">setoid.comap</span> <span class=\"n\">finsupp_aux.to_fun</span> <span class=\"bp\">⊥</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">finsupp_aux</span> <span class=\"n\">α</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n<span class=\"c1\">-- `f g : finsupp_aux α M` are equivalent iff `f.to_fun = g.to_fun`.</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finsupp.single</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finsupp</span> <span class=\"n\">α</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">quotient.mk</span><span class=\"o\">,</span> <span class=\"n\">exact</span>\n<span class=\"o\">{</span> <span class=\"n\">support</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">},</span>\n  <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">a'</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"k\">then</span> <span class=\"n\">m</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">mem_support_to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a'</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">by_contra</span> <span class=\"n\">hne</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">if_neg</span> <span class=\"n\">hne</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>However, if you have a list of terms in <code>α × M</code> and want to computably construct a term in <code>finsupp α M</code>, you still need <code>decidable_eq α</code> to define <code>to_fun</code> field and to define polynomial multiplication, but that's satisfied when <code>α</code> is <code>ℕ</code> or <code>ℤ</code> (for polynomials) and many other cases. A maximally computable definition would be the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finsupp'</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">setoid.comap</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">multiset.map</span> <span class=\"n\">prod.snd</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">classical</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">s.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p.fst</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"o\">)</span> <span class=\"bp\">⊥</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"bp\">$</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finsupp'.single</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finsupp'</span> <span class=\"n\">α</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">quotient.mk</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">{(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">m</span><span class=\"o\">)}</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>This definition would allow you to define polynomial addition and multiplication computably without <code>decidable_eq α</code>. But it requires an add_comm_monoid, and evaluation won't be able to automatically combine like terms. So it feels the first definition would be most useful.<br>\nA third definition only requires has_zero, but doesn't support computable addition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">finsupp''_aux</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">monomials</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">nodup</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">monomials.map</span> <span class=\"n\">prod.fst</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodup</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finsupp''</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">setoid.comap</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">M</span><span class=\"o\">],</span> <span class=\"kd\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">f.monomials.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p.snd</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"bp\">⊥</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">finsupp''_aux</span> <span class=\"n\">α</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finsupp''.single</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finsupp''</span> <span class=\"n\">α</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">quotient.mk</span><span class=\"o\">,</span> <span class=\"n\">exact</span>\n<span class=\"o\">{</span> <span class=\"n\">monomials</span> <span class=\"o\">:=</span> <span class=\"o\">{(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">m</span><span class=\"o\">)},</span>\n  <span class=\"n\">nodup</span> <span class=\"o\">:=</span> <span class=\"n\">multiset.nodup_singleton</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Have people explored these ideas before?</p>",
        "id": 287806674,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1656477543
    },
    {
        "content": "<p>Wow, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/dfinsupp.pre\">docs#dfinsupp.pre</a> uses exactly my first strategy! I found it in <a href=\"#narrow/stream/113489-new-members/topic/.60ite.60.20with.20multiple.20decidable.20instances/near/272320459\">this thread</a>.</p>\n<p>Maybe I am not thinking about the right question, as per what Reid Barton said:</p>\n<blockquote>\n<p>\"making finsupp computable\" is not the right kind of goal, the correct goal should be \"add data structure X which supports operations Y in time complexity Z, for use in algorithm W\"</p>\n</blockquote>",
        "id": 287810159,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1656481937
    },
    {
        "content": "<p>Since the lagrange stuff is being refactored, what do people think about allowing the values to live in some algebra R over F instead of F itself? If R is a domain you also get uniqueness.</p>",
        "id": 287812071,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1656484009
    },
    {
        "content": "<p>I wouldn't take anything I say about constructivism on Twitter seriously, not least because I don't know anything about it</p>",
        "id": 287815516,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656487076
    },
    {
        "content": "<p>I'm fine for it to not be over a field - just let me know the more general setting.</p>",
        "id": 287831564,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656497287
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I understand why you've made the suggestion re:  not using<code>∏ j, ite (i = j) 1</code> that you have - but I have certainly found that form a <em>lot</em> easier to work with in proofs.</p>",
        "id": 287831631,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656497331
    },
    {
        "content": "<p>Like switching to the <code>erase</code> formulation makes all my proofs break and it isn't necessarily clear how to fix them without making them all longer.</p>",
        "id": 287831702,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656497380
    },
    {
        "content": "<p>I'm quite surprised by that; we have plenty of lemmas about the product of <code>finset.erase</code></p>",
        "id": 287835441,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656499972
    },
    {
        "content": "<p>It's also worth noting that the existing proofs already used <code>finset.erase</code></p>",
        "id": 287835672,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656500142
    },
    {
        "content": "<p>With <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>' suggested approach <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lagrange.basis\">docs#lagrange.basis</a> would just become</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">basis</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">↪</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∏</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"n\">s.erase</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"n\">v</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">j</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>or  the equivalent</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">basis</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">↪</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∏</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">s.erase</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 287835950,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656500329
    },
    {
        "content": "<p>Oh, I'm sure if I find the right lemmas it'll be fine; it's worth saying that the existing proofs got quite long and involved (my current proofs I think generally are shorter) but I'm sure there are short ways.</p>",
        "id": 287836522,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656500729
    },
    {
        "content": "<p>I just don't much like that definition, though.</p>",
        "id": 287836546,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656500749
    },
    {
        "content": "<p>(Also the <code>basis_divisor v i j</code> abstraction is very nice to work with so it would be good to keep that.)</p>",
        "id": 287836695,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656500831
    },
    {
        "content": "<p>I don't see why you would define some indexed embedding but then only work with a finset of it, as opposed to simply working with a finite type. Indexing by types is what we do in the case of, say, !docs#matrix, it works well there.</p>",
        "id": 287836913,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656500967
    },
    {
        "content": "<p>(I could see, btw <code>(v : s ↪ F)</code> working... but at that stage you're just using s as a fintype!)</p>",
        "id": 287837979,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656501698
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>good news - managed to fix my proofs. thank goodness the effect wasn't too large.</p>",
        "id": 287841910,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656504056
    },
    {
        "content": "<p>ultimately I can see the value of the above approach when we're dealing with a flexible indexing set. it's just not clear to me that is what you want here.</p>",
        "id": 287842423,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656504329
    },
    {
        "content": "<p>Also - what do you do in the case where you want to add a node to <code>v : ι ↪ F</code> that wasn't originally specified - that is, extend <code>ι</code>? That to me feels at least as likely as wanting to shrink it.</p>",
        "id": 287842823,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656504559
    },
    {
        "content": "<p>It occurs that you could define <code>def basis_divisor (x y : F) : F[X] := C (x - y)⁻¹ * (X - C (y))</code>, closer to how it originally works (though I do think abstracting that out is useful, it has nice properties in and of itself).</p>",
        "id": 287842986,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656504662
    },
    {
        "content": "<p>But then you get close to re-introducing this decidable_eq condition on the field, which is unnatural.</p>",
        "id": 287843119,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656504759
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/data/setoid/partition.html#indexed_partition\">https://leanprover-community.github.io/mathlib_docs/data/setoid/partition.html#indexed_partition</a></p>",
        "id": 287849243,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656507780
    },
    {
        "content": "<p>This seems to be an example where, again, we index by type.</p>",
        "id": 287849278,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656507793
    },
    {
        "content": "<p>I'm not sure if it's what you're explicitly describing above, but I think I see the problem; <code>(s : finset ι) (i : ι) (v : ι ↪ F)</code> puts too strong a condition on <code>v</code>, as it only need to be injective on <code>s</code>.</p>",
        "id": 287854460,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656509961
    },
    {
        "content": "<p>Can't you drop all the injectivity assumptions in the definition of <code>basis</code>, and prove results assuming <code>inj_on v s</code>?</p>",
        "id": 287855659,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1656510400
    },
    {
        "content": "<p>Yes; what isn't clear to me is what advantage that gets you.</p>",
        "id": 287860443,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656512317
    },
    {
        "content": "<p>Like - at that stage, why not just define <code>v : s ↪ F</code>?</p>",
        "id": 287860749,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656512424
    },
    {
        "content": "<p>because then how do you add an element? This sounds like pain.</p>",
        "id": 287860879,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656512475
    },
    {
        "content": "<p>Right - what I'm saying is I'm not sure that you need to.</p>",
        "id": 287860915,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656512487
    },
    {
        "content": "<p>Certainly I'm proving everything I want to be proving without doing this.</p>",
        "id": 287860964,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656512503
    },
    {
        "content": "<p>It's like saying, for, say, <code>matrix</code>, \"how do you add a column to the column indexing type\"? You don't, really.</p>",
        "id": 287861073,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656512541
    },
    {
        "content": "<p>Also: if I define <code>v : ι -&gt; F</code>, then what happens when I want to add a node to <code>s</code> that isn't indexed by any <code>i : ι</code>? You end up with the same problem anyway.</p>",
        "id": 287861292,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656512629
    },
    {
        "content": "<p>Just pushed a new set of commits to <a href=\"https://github.com/leanprover-community/mathlib/pull/15036\">#15036</a>.</p>",
        "id": 287872280,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656516565
    },
    {
        "content": "<p>Importantly we now have <code>eq_interpolate_iff</code>, which we implicitly previously had but I think is good to have explicitly: this is the characteristic property of the interpolation to a set of node-value pairs.</p>",
        "id": 287872443,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656516611
    },
    {
        "content": "<p>(This also perhaps makes a little clearer why I am happy with the current formulation: an interpolation is arguably defined /according to a particular choice of nodes/, and adding or removing a node simply gives a different interpolation, although there clearly is a relationship here.)</p>",
        "id": 287872614,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656516687
    },
    {
        "content": "<p>We also need a better location for the <code>non_lagrange</code> lemmas than this file: happy to take suggestions.</p>",
        "id": 287872667,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656516714
    },
    {
        "content": "<p>The only requirement is that wherever they go, this file will want to import it.</p>",
        "id": 287872766,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656516737
    },
    {
        "content": "<p>The finset approach does have things to commend it, I think, if we wanted to have other forms of the interpolant especially.<br>\nSo what is needed is:</p>\n<ul>\n<li>Have some type of indexes <code>ι</code>, which will probably have decidable equality.</li>\n<li>Have some <code>s : finset ι</code>, which represents \"currently used indexes\".</li>\n<li>For each <code>i</code> in <code>s</code>, we have some <code>v_i</code> in <code>F</code>, and these <code>v_i</code> are unique. They're the nodes.</li>\n<li>For each <code>i</code> in <code>s</code>,  we have some <code>r_i</code> in F. They don't have to be unique.</li>\n</ul>\n<p>That's almost the setup above, but, crucially, there's no need to define <code>v_i</code> and <code>r_i</code> across the entire <code>ι</code>.</p>",
        "id": 287878042,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656518659
    },
    {
        "content": "<p>But as I've said, I'm not necessarily sure that's better if you're not adding/removing nodes.</p>",
        "id": 287878162,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656518702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/116395-maths/topic/Lagrange.20interpolants/near/287878042\">said</a>:</p>\n<blockquote>\n<p>That's almost the setup above, but, crucially, there's no need to define <code>v_i</code> and <code>r_i</code> across the entire <code>ι</code>.</p>\n</blockquote>\n<p>This doesn't really matter though, as you know these types are inhabited so you can always output zero.</p>",
        "id": 287879192,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656519056
    },
    {
        "content": "<p>yes, but I am... not convinced by that perspective.</p>",
        "id": 287879966,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656519370
    },
    {
        "content": "<p>Is there a way to (noncomputably) turn a <code>s : finset F</code> into an injective function <code>v : fin (card s) -&gt; F</code></p>",
        "id": 287885352,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656521856
    },
    {
        "content": "<p>Having tried to implement the above, that's really the sticking point, because I want to be able to use <code>det_vandermonde_ne_zero_iff</code>.</p>",
        "id": 287885468,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656521888
    },
    {
        "content": "<p><code>fintype.equiv_fin</code> does this for fintypes.</p>",
        "id": 287885633,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656521989
    },
    {
        "content": "<p>I guess you could claim that we should have <code>vandermonde : matrix ι (fin n) R</code>, although that doesn't help when you get to taking the determinant</p>",
        "id": 287886417,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656522325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/116395-maths/topic/Lagrange.20interpolants/near/287885633\">said</a>:</p>\n<blockquote>\n<p><code>fintype.equiv_fin</code> does this for fintypes.</p>\n</blockquote>\n<p>That should be all you need, <code>↥s</code> is a fintype</p>",
        "id": 287886533,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656522367
    },
    {
        "content": "<p>I don't really claim that - I just want to use the nice vandermonde polynomial lemmas.</p>",
        "id": 287890654,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656524231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Lagrange.20interpolants/near/287886533\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/116395-maths/topic/Lagrange.20interpolants/near/287885633\">said</a>:</p>\n<blockquote>\n<p><code>fintype.equiv_fin</code> does this for fintypes.</p>\n</blockquote>\n<p>That should be all you need, <code>↥s</code> is a fintype</p>\n</blockquote>\n<p>Right, that's what I thought. I'll try it again. Where's the instance for that?</p>",
        "id": 287890704,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656524258
    },
    {
        "content": "<p>I need <code>↥s ↪ F</code>; what gives that?</p>",
        "id": 287890945,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656524357
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.embedding.subtype\">docs#function.embedding.subtype</a></p>",
        "id": 287891152,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656524468
    },
    {
        "content": "<p>ta</p>",
        "id": 287891714,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656524761
    },
    {
        "content": "<p>well, that does it. it's not... pretty...</p>",
        "id": 287891770,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656524772
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">eq_zero_of_eval_eq_zero</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]}</span>\n  <span class=\"o\">(</span><span class=\"n\">degree_f_lt</span> <span class=\"o\">:</span> <span class=\"n\">f.degree</span> <span class=\"bp\">&lt;</span> <span class=\"n\">card</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eval_f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f.eval</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mem_degree_lt</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">fintype.card_coe</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">degree_f_lt</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">vandermonde_invert</span> <span class=\"o\">(</span><span class=\"n\">function.embedding.trans</span> <span class=\"o\">(</span><span class=\"n\">fintype.equiv_fin</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.to_embedding</span> <span class=\"o\">(</span><span class=\"n\">function.embedding.subtype</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"n\">degree_f_lt</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">function.embedding.trans_apply</span><span class=\"o\">,</span> <span class=\"n\">function.embedding.coe_subtype</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">eval_f</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">coe_mem</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 287891848,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656524807
    },
    {
        "content": "<p>Compared with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">eq_zero_of_eval_eq_zero</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">↪</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]}</span>\n  <span class=\"o\">(</span><span class=\"n\">degree_f_lt</span> <span class=\"o\">:</span> <span class=\"n\">f.degree</span> <span class=\"bp\">&lt;</span> <span class=\"n\">fintype.card</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eval_f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f.eval</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">mem_degree_lt</span> <span class=\"n\">at</span> <span class=\"n\">degree_f_lt</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">vandermonde_invert</span>  <span class=\"o\">(</span><span class=\"n\">function.embedding.trans</span><span class=\"o\">(</span><span class=\"n\">fintype.equiv_fin</span> <span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.to_embedding</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n                            <span class=\"n\">degree_f_lt</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">eval_f</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 287891866,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656524816
    },
    {
        "content": "<p>For reference <code>vandermonde_invert</code> is essentially \"that, but indexed with fin n\".</p>",
        "id": 287892178,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656524964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Lagrange.20interpolants/near/287879192\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/116395-maths/topic/Lagrange.20interpolants/near/287878042\">said</a>:</p>\n<blockquote>\n<p>That's almost the setup above, but, crucially, there's no need to define <code>v_i</code> and <code>r_i</code> across the entire <code>ι</code>.</p>\n</blockquote>\n<p>This doesn't really matter though, as you know these types are inhabited so you can always output zero.</p>\n</blockquote>\n<p>It's a shame there's no \"finsupp but for junk values instead of zero\".</p>",
        "id": 287893643,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656525636
    },
    {
        "content": "<p>Because that's kinda what this approach would need.</p>",
        "id": 287893664,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656525646
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Good news! After substantial effort, I've refactored my refactor so that it's indexed-by-finsets, per the suggestions above.</p>",
        "id": 288100654,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656631156
    },
    {
        "content": "<p>We're now in the sort of halfway house between the two worlds.</p>",
        "id": 288100664,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656631167
    },
    {
        "content": "<p>I've also left out all the <code>interpolate_at</code> stuff, which is about interpolating a particular function <code>F -&gt; F</code>: it was ending up with a lot of definition replication where the proofs were just yards of def eq, for no clear benefit.</p>",
        "id": 288100742,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656631212
    },
    {
        "content": "<p><code>interpolate_eq_interpolate_erase_add</code> now has a nice proof (I changed the statement slightly but it says the same thing). I think this is probably generalisable, incidentally, to any subset of the finset.</p>\n<p>Also, the proof of <code>basis_divisor_add_symm</code> is a little indulgent (you <em>can</em> do it quicker using \"brute force rewrites, though it's horrible), but I think it nicely shows the utility of using the earlier lemmas.</p>",
        "id": 288101068,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656631506
    },
    {
        "content": "<p>It might be nice to have the barycentric form of the interpolant, but that does run into issues with the fact you have to work over the fraction field.</p>",
        "id": 288102136,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656632388
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/LOdZgtqRyRAuuAoluIol7g2k/682c36ab-c98e-4b4b-b99b-e5387a300bb6.jpg\">682c36ab-c98e-4b4b-b99b-e5387a300bb6.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/LOdZgtqRyRAuuAoluIol7g2k/682c36ab-c98e-4b4b-b99b-e5387a300bb6.jpg\" title=\"682c36ab-c98e-4b4b-b99b-e5387a300bb6.jpg\"><img src=\"/user_uploads/3121/LOdZgtqRyRAuuAoluIol7g2k/682c36ab-c98e-4b4b-b99b-e5387a300bb6.jpg\"></a></div>",
        "id": 288102568,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656632689
    },
    {
        "content": "<p>For reference</p>",
        "id": 288102578,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656632696
    },
    {
        "content": "<p>By the way, do we really not have zero_lt_two for with_bot?</p>",
        "id": 288105317,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656635194
    },
    {
        "content": "<p>Oh if only someone had proposed a refactor to provide those lemmas in much more general circumstances</p>",
        "id": 288117063,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656647872
    },
    {
        "content": "<p>Hahaha I did think of you</p>",
        "id": 288126852,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656657095
    },
    {
        "content": "<p>I hate working with with_bot so much. Everything is so much harder than it needs to be.</p>",
        "id": 288126866,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656657121
    },
    {
        "content": "<p>And then occasionally mathlib can't find the covariant class instances and complains.</p>",
        "id": 288126922,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656657146
    },
    {
        "content": "<p>I was dreaming about finsets last night -_-</p>",
        "id": 288126951,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656657184
    },
    {
        "content": "<p>My worry is that it might be annoying to use some of this stuff in practice, and also that maybe I should make a fintype definition as well, using the now finset-indexed version. But then it's like - do you replicate all the theorems? Is it better to just have the one most general version of interpolate and let people just use it in different ways in context, or is there value to providing specific versions?</p>",
        "id": 288127189,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656657390
    },
    {
        "content": "<p>Interested in thoughts.</p>",
        "id": 288127193,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656657398
    },
    {
        "content": "<p>Also someone mentioned it might be possible to generalise it somewhat more</p>",
        "id": 288127374,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656657559
    },
    {
        "content": "<p>This is what I mean by other spellings (fragment):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">other_spellings</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">interpolate_on</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">interpolate</span> <span class=\"n\">s</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">interpolate_fintype</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">↪</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">interpolate</span> <span class=\"n\">univ</span> <span class=\"n\">v</span> <span class=\"n\">r</span>\n<span class=\"kd\">def</span> <span class=\"n\">interpolate_fintype_on</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">↪</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">interpolate</span> <span class=\"n\">univ</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inj_on_finset_univ</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">↪</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set.inj_on</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">set.inj_on_of_injective</span> <span class=\"n\">v.inj'</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">other_spellings</span>\n</code></pre></div>",
        "id": 288135841,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656663199
    },
    {
        "content": "<p>So, like, in theory you could replicate some of the theorems for some of these? But I'm not sure there's much use.</p>",
        "id": 288135950,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656663275
    },
    {
        "content": "<p>The only thing would be avoiding having to type out that proof for <code>inj_on_finset_univ</code> every time.</p>",
        "id": 288136674,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656663706
    },
    {
        "content": "<p>We now have the following extension of the existing <code>interpolate_eq_interpolate_erase_add</code>, which is now a special case:</p>\n<p><code>theorem interpolate_eq_sum_interpolate_insert_sdiff (hvt : set.inj_on v t) (hs : s.nonempty)\n  (hst : s ⊆ t) : interpolate t v r =\n  ∑ i in s, (interpolate (insert i (t \\ s)) v r) * basis s v i := sorry</code></p>",
        "id": 288163369,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656679268
    },
    {
        "content": "<p>Ultimately the finset approach was the right one because this was, mostly, a dream.</p>",
        "id": 288163408,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656679286
    },
    {
        "content": "<p>This is going to need some extensive review (even though I think it is near a \"done\" point). In particular, I think a lot of my proofs today can probably be golfed, but I didn't have it in me to tighten them all.</p>",
        "id": 288163656,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656679440
    },
    {
        "content": "<p>But I do feel confident in the work - things, mostly, feel \"neat\".</p>",
        "id": 288163745,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656679467
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">interpolate_on</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">interpolate</span> <span class=\"n\">s</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">interpolate_fintype</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">↪</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">interpolate</span> <span class=\"n\">univ</span> <span class=\"n\">v</span> <span class=\"n\">r</span>\n<span class=\"kd\">def</span> <span class=\"n\">interpolate_fintype_on</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">↪</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">interpolate</span> <span class=\"n\">univ</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">interpolate_fintype_using</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">interpolate</span> <span class=\"n\">s</span> <span class=\"n\">id</span> <span class=\"n\">f</span>\n<span class=\"kd\">def</span> <span class=\"n\">interpolate_finfield</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">interpolate</span> <span class=\"n\">univ</span> <span class=\"n\">id</span> <span class=\"n\">f</span>\n</code></pre></div>\n<p>These are all the sensible variants I can think of. It could be useful to have other versions of my theorems for them - the alternative I think would be making more of the parameters in the theorems explicit.</p>",
        "id": 288179709,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656687052
    },
    {
        "content": "<p>What I hadn't realised was true until I wrote that last one down, but which is obvious now that I think about it, is that all maps F -&gt; F on a finite field F can be described as polynomials.</p>",
        "id": 288179950,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656687166
    },
    {
        "content": "<p>Just a bump to ask what people think is still required here, and if I should put in any of the different spellings/special cases I made above?</p>",
        "id": 288379495,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922556
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/15036\">#15036</a> is the PR in question, as a reminder.</p>",
        "id": 288379565,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922582
    },
    {
        "content": "<p>You could post in <a class=\"stream\" data-stream-id=\"144837\" href=\"/#narrow/stream/144837-PR-reviews\">#PR reviews</a></p>",
        "id": 288407291,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656939869
    },
    {
        "content": "<p>Ah - thanks, I wasn't subbed to that/</p>",
        "id": 288408416,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656940525
    }
]
[
    {
        "content": "<p>I have a 20 line proof of the following example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.ultrafilter</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.stone_cech</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"n\">ultrafilter.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n<p>Is there a simpler proof for this? e.g. using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/continuous_ultrafilter_extend\">docs#continuous_ultrafilter_extend</a> ? I'm not as familiar with the topology parts of mathlib as I should be...</p>",
        "id": 211197248,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600986534
    },
    {
        "content": "<p>I was under the impression that I built the adjunction involving the Stone-Cech compactification at some point... but where...</p>",
        "id": 211197922,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600987065
    },
    {
        "content": "<p>lol</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- TODO: These proofs seem too long!</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">hom_iso</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">free_obj</span> <span class=\"n\">S</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">ultrafilter.pure</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">ultrafilter.extend</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">continuous_ultrafilter_extend</span> <span class=\"n\">f</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">subtype.eq</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">dense_inducing_pure.dense.equalizer</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">continuous_ultrafilter_extend</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">g.2</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">ultrafilter_extend_extends</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">ultrafilter.pure</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">ultrafilter_extend_extends</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 211198136,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600987190
    },
    {
        "content": "<p>Nice. I didn't know the adjunction existed in mathlib</p>",
        "id": 211198232,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600987250
    },
    {
        "content": "<p>Maybe this will help (mathlib commit d12db89ac21bdcf5d33fd1dc7262ebbd3a7dcf54)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.monad.adjunction</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.category.Top.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.stone_cech</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">CompHaus</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_Top</span> <span class=\"o\">:</span> <span class=\"n\">Top.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n<span class=\"o\">[</span><span class=\"n\">is_compact</span> <span class=\"o\">:</span> <span class=\"n\">compact_space</span> <span class=\"n\">to_Top</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">is_hausdorff</span> <span class=\"o\">:</span> <span class=\"n\">t2_space</span> <span class=\"n\">to_Top</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CompHaus</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">Top.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">X.1</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- TODO: Fix this mess</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span> <span class=\"o\">:</span> <span class=\"n\">compact_space</span> <span class=\"n\">X.to_Top</span> <span class=\"o\">:=</span> <span class=\"n\">X.is_compact</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span> <span class=\"o\">:</span> <span class=\"n\">t2_space</span> <span class=\"n\">X.to_Top</span> <span class=\"o\">:=</span> <span class=\"n\">X.is_hausdorff</span>\n<span class=\"kd\">instance</span> <span class=\"n\">i</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span> <span class=\"o\">:</span> <span class=\"n\">compact_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">X.is_compact</span>\n<span class=\"kd\">instance</span> <span class=\"n\">ij</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span> <span class=\"o\">:</span> <span class=\"n\">t2_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">X.is_hausdorff</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">compact_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨⟨</span><span class=\"n\">X</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">category</span> <span class=\"o\">:</span> <span class=\"n\">large_category</span> <span class=\"n\">CompHaus</span> <span class=\"o\">:=</span>\n<span class=\"n\">induced_category.category</span> <span class=\"n\">to_Top</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">concrete_category</span> <span class=\"o\">:</span> <span class=\"n\">concrete_category</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">induced_category.concrete_category</span> <span class=\"n\">to_Top</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">has_forget_to_CompHaus</span> <span class=\"o\">:</span> <span class=\"n\">has_forget₂</span> <span class=\"n\">CompHaus</span> <span class=\"n\">Top</span> <span class=\"o\">:=</span>\n<span class=\"n\">induced_category.has_forget₂</span> <span class=\"n\">to_Top</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">adj</span>\n<span class=\"c\">/-</span><span class=\"cm\"> The space of ultrafilters β : Set → CompHaus</span>\n<span class=\"cm\">is left adjoint to the forgetful functor CompHaus → Set. -/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">free_obj</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">ultrafilter</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- TODO: These proofs seem too long!</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">hom_iso</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">free_obj</span> <span class=\"n\">S</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">ultrafilter.pure</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">ultrafilter.extend</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">continuous_ultrafilter_extend</span> <span class=\"n\">f</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">subtype.eq</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">dense_inducing_pure.dense.equalizer</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">continuous_ultrafilter_extend</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">g.2</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">ultrafilter_extend_extends</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">ultrafilter.pure</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">ultrafilter_extend_extends</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">is_right_adjoint</span> <span class=\"o\">(</span><span class=\"n\">forget</span> <span class=\"n\">CompHaus.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">adjunction.adjunction_of_equiv_left</span> <span class=\"n\">hom_iso</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">})</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">adj</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CompHaus</span>\n</code></pre></div>",
        "id": 211198235,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600987254
    },
    {
        "content": "<p>I mean, your statement definitely follows somehow from this but it might be longer than your proof.</p>",
        "id": 211198376,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600987353
    },
    {
        "content": "<p>Is this in mathlib? API search came up empty with CompHaus</p>",
        "id": 211198407,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600987385
    },
    {
        "content": "<p>No just a file I had lying around</p>",
        "id": 211198451,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600987419
    },
    {
        "content": "<p>Ah ok. Thanks.</p>",
        "id": 211198689,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600987504
    },
    {
        "content": "<p>I was hoping to be able to just quote a lemma from mathlib <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 211198835,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600987565
    },
    {
        "content": "<p>I agree it seems to be missing</p>",
        "id": 211199044,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600987706
    },
    {
        "content": "<p>There must be a way to do it with ultrafilter.extend, but I couldn't come up with a nice proof.</p>",
        "id": 211199118,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600987775
    },
    {
        "content": "<p>Here's my original proof FWIW</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.ultrafilter</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.stone_cech</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"n\">ultrafilter.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">U</span> <span class=\"n\">hU</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">hU</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">hU_H</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">is_open_of_is_topological_basis</span> <span class=\"n\">ultrafilter_basis_is_basis</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">is_open_of_is_topological_basis</span> <span class=\"n\">ultrafilter_basis_is_basis</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">set.univ</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">cond</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">univ_sets</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">is_open_inter</span><span class=\"o\">,</span>\n    <span class=\"n\">assumption'</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">set.preimage_sUnion</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">is_open_sUnion</span><span class=\"o\">,</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">T</span> <span class=\"o\">⟨</span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">is_open_sUnion</span><span class=\"o\">,</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">S</span> <span class=\"o\">⟨</span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hU_ih</span><span class=\"o\">,</span>\n    <span class=\"n\">assumption</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211199391,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600987942
    },
    {
        "content": "<p>Now I'm not even sure you can do it easily with <code>ultrafilter.extend</code>. Because you need to somehow identify the extension with <code>ultrafilter.map</code>, and the obvious way to do that (it's the unique continuous map that fits in a square) presupposes that you already know <code>ultrafilter.map</code> is continuous.</p>",
        "id": 211200199,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600988474
    },
    {
        "content": "<p>Right. I was also hoping mathlib had some lemma saying that ultrafilter.extend agrees with pure composed with the map f.</p>",
        "id": 211200735,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600988832
    },
    {
        "content": "<p>I guess it's not there <span aria-label=\"oh no\" class=\"emoji emoji-1f615\" role=\"img\" title=\"oh no\">:oh_no:</span></p>",
        "id": 211200762,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600988851
    },
    {
        "content": "<p>This seems to be frustratingly close</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">continuous_ultrafilter.map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"n\">ultrafilter.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">continuous_iff_ultrafilter</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">u</span> <span class=\"n\">g</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"o\">(</span><span class=\"n\">ultrafilter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">change</span> <span class=\"n\">G.val</span> <span class=\"bp\">≤</span> <span class=\"bp\">𝓝</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">G.map</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">≤</span> <span class=\"bp\">𝓝</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ultrafilter_converges_iff</span><span class=\"o\">,</span> <span class=\"n\">ultrafilter_converges_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- ⊢ ultrafilter.map f (mjoin G) = mjoin (ultrafilter.map (ultrafilter.map f) G)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211201449,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600989371
    },
    {
        "content": "<p>Does this last goal follow from the monad laws?</p>",
        "id": 211201659,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600989563
    },
    {
        "content": "<p>(I'm away from my computer right now.)</p>",
        "id": 211201677,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600989578
    },
    {
        "content": "<p>Kind of... it works when <code>α</code> and <code>β</code> are in the same universe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">continuous_ultrafilter.map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"n\">ultrafilter.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">continuous_iff_ultrafilter</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">u</span> <span class=\"n\">g</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"o\">(</span><span class=\"n\">ultrafilter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">change</span> <span class=\"n\">G.val</span> <span class=\"bp\">≤</span> <span class=\"bp\">𝓝</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">G.map</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">≤</span> <span class=\"bp\">𝓝</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ultrafilter_converges_iff</span><span class=\"o\">,</span> <span class=\"n\">ultrafilter_converges_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">mjoin_map_map</span> <span class=\"n\">f</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211201887,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600989735
    },
    {
        "content": "<p>Oh right .... That's because of mjoin</p>",
        "id": 211201908,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600989758
    },
    {
        "content": "<p>how frustrating</p>",
        "id": 211201975,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600989814
    },
    {
        "content": "<p>OK sometimes the simple way is best</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">continuous_ultrafilter.map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"n\">ultrafilter.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">continuous_generated_from</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ultrafilter_is_open_basic</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211202332,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600990143
    },
    {
        "content": "<p>Cool. I guess continuous_generated_from is the boilerplate version of the induction in my original proof. Good to know!</p>",
        "id": 211202491,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600990301
    }
]
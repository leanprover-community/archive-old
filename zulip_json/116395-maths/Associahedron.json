[
    {
        "content": "<p>I was talking with somene about the dreaded infinity categories and how we couldn't even define the association rules. So we started talking about <a href=\"https://en.wikipedia.org/wiki/Associahedron\">associahedrons</a>. Does anybody know a way to characterize the faces (of all dimensions!) of the n-th associahedron? We thought hard about it and I came up with the idea that each face was corresponding to an invariant part of the binary trees/parenthezations, and then came across <a href=\"https://en.wikipedia.org/wiki/Associahedron#/media/File:Associahedron_K5_faces,_ovals.svg\">this image on Wikipedia</a>.<br>\nFor now, I figured out it would be quite a good exercise to even define <a href=\"https://en.wikipedia.org/wiki/Tamari_lattice\">the Tamari lattice</a>.</p>",
        "id": 258786891,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634943938
    },
    {
        "content": "<p>I think the simplest characterisation of the faces of the n-th associahedron is as rooted \"planar\" trees with n leaves (not necessarily binary). The dimension of the face is the N-#vertices for some straightforward N(n). Containment of faces is given by the (transitive closure) of contraction of internal edges.</p>",
        "id": 258788953,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634945525
    },
    {
        "content": "<p>e.g. (ignore the text labels)<br>\n<a href=\"/user_uploads/3121/0_ARYfcinI_aVfp1ZBmMMhg_/A4-faces.png\">A4-faces.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/0_ARYfcinI_aVfp1ZBmMMhg_/A4-faces.png\" title=\"A4-faces.png\"><img src=\"/user_uploads/3121/0_ARYfcinI_aVfp1ZBmMMhg_/A4-faces.png\"></a></div>",
        "id": 258789218,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634945738
    },
    {
        "content": "<p>(The labels are showing you the terms appearing in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><msub><mi>m</mi><mn>4</mn></msub></mrow><annotation encoding=\"application/x-tex\">d m_4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">4</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> in an A_infty algebra.)</p>",
        "id": 258789353,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634945840
    },
    {
        "content": "<p>Ohohoh! Very interesting! So you're saying the faces are identifiable with rooted trees? What do you mean by planar here?</p>",
        "id": 258789512,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634945977
    },
    {
        "content": "<p>I remember some talk a while back about formalizing operads. Did anything happen with that?</p>",
        "id": 258789533,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1634945994
    },
    {
        "content": "<p>Just look at the picture. There's a linear order on the children of each vertex.</p>",
        "id": 258789743,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634946152
    },
    {
        "content": "<p>And I guess you need to say every non-leaf vertex has at least 2 children.</p>",
        "id": 258789758,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634946175
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 258789759,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1634946176
    },
    {
        "content": "<p>Does</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">face</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">face</span>\n<span class=\"bp\">|</span> <span class=\"n\">fork</span> <span class=\"o\">:</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">face</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">face</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">face</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">face</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">fork</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">children</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">face</span>\n</code></pre></div>\n<p>Do it?</p>",
        "id": 258790079,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634946444
    },
    {
        "content": "<p><code>fork</code> is for a 2-child vertex, then you use <code>cons</code> to add more children?</p>",
        "id": 258790101,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634946462
    },
    {
        "content": "<p>Okay, I see.</p>",
        "id": 258790331,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634946637
    },
    {
        "content": "<p>And contraction is replacing <code>fork</code> by <code>cons</code>, right?</p>",
        "id": 258790355,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634946668
    },
    {
        "content": "<p>No, it's more complicated, you need to do something with <code>cons</code>s as well.</p>",
        "id": 258790385,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634946707
    },
    {
        "content": "<p>It might be easier to define <code>boundary</code> rather than <code>coboundary</code>.</p>",
        "id": 258790437,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634946731
    },
    {
        "content": "<p>i.e. all the ways to uncontract an edge</p>",
        "id": 258790463,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634946757
    },
    {
        "content": "<p>but I guess we want both anyway</p>",
        "id": 258790478,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634946772
    },
    {
        "content": "<p>Okay okay</p>",
        "id": 258790501,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634946798
    },
    {
        "content": "<p>Is there a moduli space of metric planar rooted trees, where each edge has an associated positive length? It seems like you can set it up so that edge contraction is a limit of shrinking an edge's length.  Can this (or rather some subspace) map cleanly onto the associahedron as a geometric object?  I'd expect the subspace where the edges incident to the leaves are all unit length would work, but it seems like it gives a dual cell structure.  (A tree with n internal vertices is contained in a cell of dimension n.)</p>",
        "id": 258791498,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1634947536
    },
    {
        "content": "<p>The following code is possibly correct. At least it seems to get the number and sizes of faces correct:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.pnat.basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">splits</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">[([],</span> <span class=\"o\">[])]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">splits</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">p.1</span><span class=\"o\">,</span> <span class=\"n\">p.2</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- Give all ways of decomposing a list into a prefix, a singleton, and a suffix. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">prefix_singleton_suffix</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"o\">[([],</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">[])]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">prefix_singleton_suffix</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">p.1</span><span class=\"o\">,</span> <span class=\"n\">p.2</span><span class=\"o\">))</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">face</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">face</span>\n<span class=\"bp\">|</span> <span class=\"n\">fork</span> <span class=\"o\">:</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">face</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">face</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">face</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">face</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">leaf</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"o\">[])</span>  <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"o\">[])</span> <span class=\"o\">:=</span> <span class=\"n\">fork</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">L</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">face</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">fork</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">children</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">children_of</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">face</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">L.length</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">children</span> <span class=\"bp\">=</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">top</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">face</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">leaf</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">fork</span> <span class=\"n\">leaf</span> <span class=\"n\">leaf</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">cons</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">top</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">leaves</span> <span class=\"o\">:</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">fork</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">leaves</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">leaves</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">leaves</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">leaves</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">depth</span> <span class=\"o\">:</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">fork</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">depth</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">depth</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">depth</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">depth</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- For a face with n children, choose between 2 and n-1 contiguous children,</span>\n<span class=\"sd\">and combine those as a single child. -/</span>\n<span class=\"c1\">-- TODO define this on the constructors?</span>\n<span class=\"kd\">def</span> <span class=\"n\">uncontract</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">face</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">face</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">QR</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">f.children.splits</span><span class=\"o\">,</span>\n   <span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">QR.splits</span><span class=\"o\">,</span>\n   <span class=\"n\">guard</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">Q.length</span> <span class=\"bp\">∧</span> <span class=\"n\">Q.length</span> <span class=\"bp\">&lt;</span> <span class=\"n\">f.children.length</span><span class=\"o\">),</span>\n   <span class=\"n\">return</span> <span class=\"bp\">$</span> <span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">of</span> <span class=\"n\">Q</span><span class=\"o\">]</span> <span class=\"bp\">++</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">face</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">face</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">face</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">face</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">f.children.prefix_singleton_suffix</span><span class=\"o\">,</span>\n   <span class=\"n\">q</span> <span class=\"bp\">←</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n   <span class=\"n\">return</span> <span class=\"bp\">$</span> <span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"bp\">++</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">boundary</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">face</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">face</span> <span class=\"o\">:=</span>\n<span class=\"n\">uncontract</span> <span class=\"n\">f</span> <span class=\"bp\">++</span> <span class=\"n\">f.map</span> <span class=\"n\">uncontract</span>\n\n<span class=\"c1\">-- The n=5 associahedron has 9 faces:</span>\n<span class=\"k\">#eval</span> <span class=\"o\">((</span><span class=\"n\">top</span> <span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">boundary</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"c1\">-- Of those faces, 3 are squares and 6 are pentagons:</span>\n<span class=\"k\">#eval</span> <span class=\"o\">((</span><span class=\"n\">top</span> <span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">boundary</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">face</span><span class=\"o\">,</span> <span class=\"n\">f.boundary.length</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- The n=6 associahedron has 14 faces:</span>\n<span class=\"k\">#eval</span> <span class=\"o\">((</span><span class=\"n\">top</span> <span class=\"mi\">6</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">boundary</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"c1\">-- Those faces themselves have either 7 or 9 faces:</span>\n<span class=\"c1\">-- https://www.shapeways.com/product/YAHGXP2QS/associahedron-k-6</span>\n<span class=\"k\">#eval</span> <span class=\"o\">((</span><span class=\"n\">top</span> <span class=\"mi\">6</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">boundary</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">face</span><span class=\"o\">,</span> <span class=\"n\">f.boundary.length</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">face</span>\n</code></pre></div>\n<p>It is a bit hacky.</p>",
        "id": 258794048,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634950325
    },
    {
        "content": "<p>Dual to the tree characterization for faces is a characterization in terms of arcs in a disk between labeled points:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">arc</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- whether the interiors of the arcs must intersect --/</span>\n<span class=\"kd\">def</span> <span class=\"n\">arc.interlaces</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">arc</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">p.a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">q.a</span> <span class=\"bp\">∧</span> <span class=\"n\">p.b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">q.b</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q.a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p.a</span> <span class=\"bp\">∧</span> <span class=\"n\">q.b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p.b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">face</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">arcs</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">arc</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">disj</span> <span class=\"o\">:</span> <span class=\"n\">arcs.val.pairwise</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">arc</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"bp\">¬</span> <span class=\"n\">p.interlaces</span> <span class=\"n\">q</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>This illustrates the correspondence between a tree and this <code>face</code> structure for a four-leafed tree:</p>\n<p><a href=\"/user_uploads/3121/5LJH3T-iLTnTS2UY65GdLRBP/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/5LJH3T-iLTnTS2UY65GdLRBP/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/5LJH3T-iLTnTS2UY65GdLRBP/image.png\"></a></div><p>Edge contraction corresponds to deleting an arc from the <code>arcs</code> set.</p>\n<p>(Edit: That (0,5) edge seems unnecessary -- it probably should be excluded in the definition.)</p>",
        "id": 258794163,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1634950509
    },
    {
        "content": "<p>In what form should the associahedron first enter mathlib.</p>\n<ol>\n<li>just as a combinatorial object (a simplicial complex?)</li>\n<li>the definition of an A_infty algebra?</li>\n</ol>",
        "id": 258794167,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634950517
    },
    {
        "content": "<p>Oh wow! I tried but failed to have working code.</p>",
        "id": 258813596,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634981300
    },
    {
        "content": "<p>I was wondering if it makes sense to provide the definition of an abstract polytope, and then the associahedra as examples.</p>",
        "id": 258813619,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634981386
    },
    {
        "content": "<p>I don't know what a A_infty algebra is, so I was envisioning defining it as an abstract polytopial complex. Certainly not as a simplicial complex in the way I'm defining them in <a href=\"https://github.com/leanprover-community/mathlib/issues/9762\">#9762</a> because that assumes a geometrical embedding.</p>",
        "id": 258813664,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634981420
    },
    {
        "content": "<p>What's your definition of an abstract polytope?</p>",
        "id": 258813684,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634981513
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Abstract_polytope\">https://en.wikipedia.org/wiki/Abstract_polytope</a> seems good. :-) There's some basic order theory about chains and flags that I suspect we don't quite have.</p>",
        "id": 258813723,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634981547
    },
    {
        "content": "<p>We would need <code>flag</code> in an arbitrary partial_order, defined as a maximal chain.</p>",
        "id": 258813815,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634981661
    },
    {
        "content": "<p>And <code>rank x</code> as the length of the longest chain ending at <code>x</code>.</p>",
        "id": 258813823,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634981688
    },
    {
        "content": "<p>What about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zorn.is_max_chain\">docs#zorn.is_max_chain</a> ?</p>",
        "id": 258813847,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634981728
    },
    {
        "content": "<p>Btw I'm all for splitting the chain stuff from <code>order.zorn</code></p>",
        "id": 258813852,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634981755
    },
    {
        "content": "<p>Yes, that should be factored out a bit.</p>",
        "id": 258813896,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634981778
    },
    {
        "content": "<p>I guess we also need <code>incident</code> as the relation <code>x \\le y \\or y \\le x</code>, and <code>connected</code> as the transitive closure of <code>incident</code>.</p>",
        "id": 258813915,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634981830
    },
    {
        "content": "<p>That doesn't work. Everything is connected through <code>bot</code>.</p>",
        "id": 258813928,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634981858
    },
    {
        "content": "<p>Oops!</p>",
        "id": 258813973,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634981898
    },
    {
        "content": "<p>hmm, I guess you restrict <code>incident</code> to the \"proper\" (i.e. neither top nor bot) elements and take transitive closure there</p>",
        "id": 258813977,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634981927
    },
    {
        "content": "<p>Yeah, that's what wikipedia does. A bit hacky, isn't it?</p>",
        "id": 258813992,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634981954
    },
    {
        "content": "<p>None of this is particularly important, but I do love associahedra. :-)</p>",
        "id": 258813994,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634981961
    },
    {
        "content": "<p>I too <span aria-label=\"heart eyes\" class=\"emoji emoji-1f60d\" role=\"img\" title=\"heart eyes\">:heart_eyes:</span></p>",
        "id": 258813999,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634981973
    },
    {
        "content": "<p>I have to head off now, but I'll think about it some more at some point!</p>",
        "id": 258814001,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634981975
    },
    {
        "content": "<p>Okay! I can try working on the definition of an abstract polytope.</p>",
        "id": 258814004,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1634981993
    },
    {
        "content": "<p>combinatorics ppl like me would says that associahedrons are just secondary polytopes of convex n-gons. So, everything is convex, unlike for abstract polytopes, which need not be realizible as convex polytopes.</p>",
        "id": 258815691,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1634984389
    },
    {
        "content": "<p>While \"concrete\"/\"geometric\" polytopes are \"better\", and in the end we want them, I suspect it's going to be easier to start with something that involves no geometry. The secondary polytope construction immediately requires us to think about volumes, doesn't it?</p>",
        "id": 258817000,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1634986273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Associahedron/near/258794167\">said</a>:</p>\n<blockquote>\n<p>In what form should the associahedron first enter mathlib.</p>\n<ol>\n<li>just as a combinatorial object (a simplicial complex?)</li>\n<li>the definition of an A_infty algebra?</li>\n</ol>\n</blockquote>\n<p>I would understand an A_infty algebra to be an algebra over an operad (that is a cofibrant replacement of the Assoc operad), so 1 and 2 are kind of the same thing</p>",
        "id": 258833550,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635009334
    },
    {
        "content": "<p>If only Lean felt that way. :-)</p>",
        "id": 258846322,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635028793
    },
    {
        "content": "<p>Right, a better thing to say would be I think it makes sense for it to start out as some combinatorial structure/polytope, then the plan is to realize it as a space/chain complex, and at some point along the way it will gain an operad structure</p>",
        "id": 258848508,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635032442
    },
    {
        "content": "<p>Yes, one would need convex polytopes, their triangulations, and volumes (of simplices, to begin with - but well, it's just a determinant ;-)). This would be a very useful project, IMHO, I don't know how hard.</p>",
        "id": 258925367,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1635147443
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib/tree/sperner-again\">branch#sperner-again</a> for a start <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 258925401,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635147469
    },
    {
        "content": "<p>Does <a href=\"https://github.com/leanprover-community/mathlib/tree/sperner-again\">https://github.com/leanprover-community/mathlib/tree/sperner-again</a> let one talk about convex hulls of finitely many points? How about facets (and, maybe dual polytopes)?</p>",
        "id": 258954299,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1635166527
    },
    {
        "content": "<p>You can already talk about convex hulls of finitely many points. Do you mean bundled as polytopes? If so, yes, although the API is currently quite dry: <a href=\"https://github.com/leanprover-community/mathlib/blob/sperner-again/src/combinatorics/simplicial_complex/polyhedron.lean#L375\">https://github.com/leanprover-community/mathlib/blob/sperner-again/src/combinatorics/simplicial_complex/polyhedron.lean#L375</a></p>",
        "id": 258954680,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635166710
    },
    {
        "content": "<p>I mean an alternative definition of polytope, as a bounded set defined by finitely many linear inequalities.</p>",
        "id": 258962193,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1635170088
    },
    {
        "content": "<p>among such systems of inequalies there is (essentially) one canonical, with as few inequalities as possible.</p>",
        "id": 258962466,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1635170202
    },
    {
        "content": "<p>a.k.a. \"dual polytope\"</p>",
        "id": 258962536,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1635170234
    },
    {
        "content": "<p>That's what I'm trying to do at this line: <a href=\"https://github.com/leanprover-community/mathlib/blob/sperner-again/src/combinatorics/simplicial_complex/polyhedron.lean#L466\">https://github.com/leanprover-community/mathlib/blob/sperner-again/src/combinatorics/simplicial_complex/polyhedron.lean#L466</a></p>",
        "id": 258962675,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635170294
    },
    {
        "content": "<p>Well, not for the \"bounded\" part.</p>",
        "id": 258962746,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635170329
    },
    {
        "content": "<p>unbounded convex polyhedra are a bit too general - anyhow, to have a decomposition theorem for these (any such polyhedron is Minkowski sum of a polytope, a cone, and an affine subspace) you need bounded ones, and cones.</p>",
        "id": 258989296,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1635181450
    },
    {
        "content": "<p>We already have cones in mathlib!</p>",
        "id": 258989386,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635181478
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/convex_cone\">docs#convex_cone</a></p>",
        "id": 258989692,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635181606
    },
    {
        "content": "<p>If you have some idea of what to do and in what order, I'm very happy to hear it. I'm pretty interested in convexity.</p>",
        "id": 258989779,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635181646
    },
    {
        "content": "<p>how hard is to prove in Lean that a finitely generated (pointed) cone has finitely generated dual?</p>",
        "id": 259304282,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1635367798
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>, what do you think? <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 259306167,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635368633
    },
    {
        "content": "<p>to this end, I can only think of proving this by showing correctness of an algorithmic procedure which computes the facets.</p>",
        "id": 259310951,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1635370960
    },
    {
        "content": "<p>Bhavik has proved Gordan's lemma, if that's related.</p>",
        "id": 259311054,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635371011
    },
    {
        "content": "<p>Is any of this related to the simplex algorithm? I proved correctness of that back in 2019 <a href=\"https://github.com/ChrisHughes24/LP/blob/master/src/simplex.lean\">https://github.com/ChrisHughes24/LP/blob/master/src/simplex.lean</a> It never went into mathlib.</p>",
        "id": 259313464,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1635372445
    },
    {
        "content": "<p>Gordan's lemma seems related to me.</p>",
        "id": 259313483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635372462
    },
    {
        "content": "<p>well, there is \"reverse search\", one of procedures to enumerate facets, whch is sort of running simplex method backwards: <br>\n<a href=\"https://www.sciencedirect.com/science/article/pii/0166218X9500026N\">https://www.sciencedirect.com/science/article/pii/0166218X9500026N</a></p>",
        "id": 259314215,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1635372917
    },
    {
        "content": "<p>the simplest \"paper\"  proof I know is in K. Fukuda's lecture notes <a href=\"https://inf.ethz.ch/personal/fukudak/lect/pclect/notes2015/PolyComp2015.pdf\">https://inf.ethz.ch/personal/fukudak/lect/pclect/notes2015/PolyComp2015.pdf</a> - which uses an easy algorithm to eliminate variables in systems of linear inequalities (Fourier-Motzkin elimination).</p>",
        "id": 259358453,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1635411456
    },
    {
        "content": "<p>Ahah! <code>linarith</code> is an implementation of Fourier-Motzkin, but we have no formalization per say.</p>",
        "id": 259363082,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635414039
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"316505\">Dima Pasechnik</span> <a href=\"#narrow/stream/116395-maths/topic/Associahedron/near/259358453\">said</a>:</p>\n<blockquote>\n<p>the simplest \"paper\"  proof I know is in K. Fukuda's lecture notes (Theorem 3.10) <a href=\"https://inf.ethz.ch/personal/fukudak/lect/pclect/notes2015/PolyComp2015.pdf\">https://inf.ethz.ch/personal/fukudak/lect/pclect/notes2015/PolyComp2015.pdf</a> - which uses an easy algorithm to eliminate variables in systems of linear inequalities (Fourier-Motzkin elimination).</p>\n</blockquote>\n<p>tl; dr: if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mi>R</mi><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">x=R\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\">λ</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\lambda\\geq 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> is representing all the vectors in the cone generated by the columns of the matrix <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, then eliminating <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span>'s will leave us with a finite system of linear inequalities on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>.</p>",
        "id": 259366228,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1635415986
    },
    {
        "content": "<p>I have a formalization of what is basically Fourier-Motzkin elimination in <a href=\"https://github.com/rwbarton/lean-omin/blob/master/src/o_minimal/examples/isolating.lean\">https://github.com/rwbarton/lean-omin/blob/master/src/o_minimal/examples/isolating.lean</a> though it's probably not quite close enough to be useful here without extra work--in any case, it's not very difficult</p>",
        "id": 259391688,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635429405
    }
]
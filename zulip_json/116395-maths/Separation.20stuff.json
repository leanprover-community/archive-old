[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> I'm working on uniform spaces again, and I have a couple of question. </p>\n<ul>\n<li>First, at <a href=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_space.lean#L638-L640\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_space.lean#L638-L640\">https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_space.lean#L638-L640</a> the comment mentions two possible definitions of T1 spaces. Am I right to think the equivalence of those definitions is not in mathlib?</li>\n<li>Bourbaki defines separated uniform spaces as uniform spaces whose underlying topology is T2. You define them in terms of the separation relation, and prove the underlying topological space is T2. But you don't prove the converse implication, do you?</li>\n<li>When trying to prove the converse implication on paper, I get that T1 underlying topology is enough. Is this fishy? Or is it only that topologies coming from uniform structures are special and T1 implies T2 (and regular)?</li>\n</ul>",
        "id": 134237694,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537369150
    },
    {
        "content": "<p>T1 implies T2 for uniform spaces should be the same epsilon/2 as shows metric spaces are T2</p>",
        "id": 134239354,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537370610
    },
    {
        "content": "<p>Uh, on my phone and apparently can't form complete sentences but I guess you understand what I mean.</p>",
        "id": 134239449,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537370700
    },
    {
        "content": "<p>Indeed it looks very plausible, but I wanted to check with our local expert before starting to Lean it</p>",
        "id": 134239563,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537370784
    },
    {
        "content": "<p>I now have a really detailed paper proof of the fact that the group uniform structure on the completion of a group is the same as the completion of the group uniform structure. I have about 15 lemmas to state and prove in Lean. I'm really afraid because lots of them involve different uniform structures on the same type, and I don't know how to fight the type class resolution system here.</p>",
        "id": 134240553,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537371783
    },
    {
        "content": "<p>Ok, I decided to start with a lemma which is independent of all the group theory stuff and openly involves different uniform structures on the same type. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">uniform_space</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_id_of_emb</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">u&#39;</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">top</span> <span class=\"o\">:</span> <span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span> <span class=\"bp\">=</span> <span class=\"n\">u&#39;</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ue</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">uniform_embedding</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">u</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dense</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">uniform_continuous</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">u</span> <span class=\"bp\">≤</span> <span class=\"n\">u&#39;</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₀</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ue</span><span class=\"bp\">.</span><span class=\"n\">dense_embedding</span> <span class=\"n\">dense</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">extend</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>As expected, lots of @/_ flying around. First surprise: how does Lean accepts the <code>dense</code> hypothesis? Where does it get a topology on beta? I was expecting to need to need @ here, pick at random from <code>u</code> to <code>u'</code> and then use the <code>topo</code> hypothesis in the proof. And then Lean complains when I define <code>e₀</code>: <code>synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized u' inferred u</code>. Here I want to use uniform structure <code>u</code>. How can I proceed?</p>",
        "id": 134253310,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537375053
    },
    {
        "content": "<p>Any hint about this?</p>",
        "id": 134259187,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537381045
    },
    {
        "content": "<p>first observation: in <code>dense</code>, the type class instances find somehow <code>u'</code></p>",
        "id": 134259425,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537381229
    },
    {
        "content": "<p>For some reasons it also uses non-type class parameters...</p>",
        "id": 134259461,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537381283
    },
    {
        "content": "<p>Yes, this is what confuses me</p>",
        "id": 134259548,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537381331
    },
    {
        "content": "<p>the type class inference will use <code>u</code> if you swap <code>u'</code> and <code>u</code>. then <code>u</code> will be used in <code>dense</code>, and <code>e₀</code> works</p>",
        "id": 134259575,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537381357
    },
    {
        "content": "<p>but this is surely not reliable.</p>",
        "id": 134259585,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537381364
    },
    {
        "content": "<p>Of course square brackets are meant to indicate how these arguments will be supplied when applying the lemma. But somehow I thought they also indicated what to put in the type class system for immediate use in following arguments</p>",
        "id": 134259601,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537381380
    },
    {
        "content": "<p>I thought about swapping, but I wanted a robust solution</p>",
        "id": 134259626,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537381407
    },
    {
        "content": "<p>And , while you're here, this thread starts with three questions for you...</p>",
        "id": 134259705,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537381447
    },
    {
        "content": "<p>to have it robust you need to use the <code>@...</code> notation</p>",
        "id": 134259709,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537381451
    },
    {
        "content": "<p>My son requires me, you have some extra thinking time <span class=\"emoji emoji-263a\" title=\"smile\">:smile:</span></p>",
        "id": 134259913,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537381617
    },
    {
        "content": "<p>1) heh, the comment is the wrong way around. All we have specifically for T1 is the three theorem below the <code>class</code>.  So AFAIR: no this equivalence is not in mathlib.</p>",
        "id": 134259939,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537381641
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">uniform_space</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"c1\">--set_option trace.class_instances true</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_id_of_emb</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">u&#39;</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"c1\">-- works??</span>\n<span class=\"c1\">--  have : u = u&#39; := rfl, -- fails??</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 134259948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537381644
    },
    {
        "content": "<p>this is horrible</p>",
        "id": 134259975,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537381665
    },
    {
        "content": "<p>2) no the converse is not proved</p>",
        "id": 134260041,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537381699
    },
    {
        "content": "<p>3) Reid's comment makes sense to me.</p>",
        "id": 134260187,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537381835
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> you used have instead of let.</p>",
        "id": 134260195,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1537381849
    },
    {
        "content": "<p>thank goodness for that</p>",
        "id": 134260216,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537381875
    },
    {
        "content": "<p>and not for the first time</p>",
        "id": 134260225,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537381886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  do you work with: <strong>I. M. James: Topologies and Uniformities</strong>? This is what I used to formalize most of uniform spaces.</p>",
        "id": 134260341,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537382015
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">uniform_space</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_id_of_emb</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">u&#39;</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">βtop</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"c1\">-- ??</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">βtop</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span> <span class=\"n\">β</span> <span class=\"n\">u&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 134260347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537382027
    },
    {
        "content": "<p>So as Johannes says, type class inference picks up <code>u'</code> and it's not clear why</p>",
        "id": 134260400,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537382057
    },
    {
        "content": "<blockquote>\n<p>How can I proceed?</p>\n</blockquote>\n<p>Well we now see the problem; type class inference succeeds when it shouldn't, so...</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">uniform_space</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_id_of_emb</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">u&#39;</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">top</span> <span class=\"o\">:</span> <span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span> <span class=\"bp\">=</span> <span class=\"n\">u&#39;</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ue</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">uniform_embedding</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">u</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dense</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"bp\">@</span><span class=\"n\">closure</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">uniform_continuous</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">u</span> <span class=\"bp\">≤</span> <span class=\"n\">u&#39;</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₀</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">dense_embedding</span><span class=\"bp\">.</span><span class=\"n\">extend</span> <span class=\"bp\">_</span> <span class=\"n\">β</span> <span class=\"n\">β</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"o\">)</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">u&#39;</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_embedding</span><span class=\"bp\">.</span><span class=\"n\">dense_embedding</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">u</span> <span class=\"bp\">_</span> <span class=\"n\">ue</span> <span class=\"n\">dense</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I don't know what you're complaining about :-)</p>",
        "id": 134260910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537382601
    },
    {
        "content": "<p>Did you steel Scott's monitor?</p>",
        "id": 134260981,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537382657
    },
    {
        "content": "<p>Those lines are way too long. <span class=\"emoji emoji-1f923\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 134260988,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537382667
    },
    {
        "content": "<p>Here is a possible workaround: use beta and gamma with an equiv, let u be the uniform structure on beta and u' on gamma</p>",
        "id": 134260990,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537382670
    },
    {
        "content": "<blockquote>\n<p>Those lines are way too long. <span class=\"emoji emoji-1f923\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>\n</blockquote>\n<p>I even halved the longest one!</p>",
        "id": 134261001,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537382686
    },
    {
        "content": "<p>and then you won't get the problems</p>",
        "id": 134261022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537382725
    },
    {
        "content": "<p>and you can just push forward and pull back the uniformities.</p>",
        "id": 134261028,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537382734
    },
    {
        "content": "<p>This might actually work. But of course the question still remains as to how type class inference is stealing your uniformities. This is very funny. It's <em>exactly</em> the opposite of the complaint most of my student have -- \"I can see it in the local context, how come Lean doesn't know why R is a ring?\"</p>",
        "id": 134261100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537382805
    },
    {
        "content": "<p>ah yes, when you move the parameters <code>u</code> and <code>u'</code> to the right side of <code>:</code>, then it doesn't work anymore:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_id_of_emb</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">u&#39;</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">top</span> <span class=\"o\">:</span> <span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span> <span class=\"bp\">=</span> <span class=\"n\">u&#39;</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ue</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">uniform_embedding</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">u</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">dense</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"c1\">-- fails here</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">uniform_continuous</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e</span><span class=\"o\">),</span> <span class=\"n\">u</span> <span class=\"bp\">≤</span> <span class=\"n\">u&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</pre></div>",
        "id": 134261241,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537382956
    },
    {
        "content": "<p>So when Leo said only stuff to the left of the colon could be used for type class inference, I didn't realise he meant that even stuff which we didn't want to use would get used...</p>",
        "id": 134261338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383017
    },
    {
        "content": "<p>Is this just for uniform spaces or does everything do this?</p>",
        "id": 134261347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383027
    },
    {
        "content": "<p>I guess everything?!</p>",
        "id": 134261357,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537383044
    },
    {
        "content": "<p>maybe only things which are marked as <code>@[class]</code>?</p>",
        "id": 134261372,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537383065
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- who knew that this worked??</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 134261392,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383088
    },
    {
        "content": "<p>Is this a bug??</p>",
        "id": 134261407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383100
    },
    {
        "content": "<p>I'm confused, why is this a surprise</p>",
        "id": 134261471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537383134
    },
    {
        "content": "<p>you asked for an instance, it found one</p>",
        "id": 134261498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537383163
    },
    {
        "content": "<p>Patrick, even though Johannes has pointed out a fix, the more I think about the gamma trick the more I think you should consider it seriously. Then you can just use type class inference for beta with u and gamma with u', and deduce the actual thing you want afterwards with a minimal amount of <code>@</code></p>",
        "id": 134261505,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383170
    },
    {
        "content": "<p>I just had absolutely no idea that it would look there</p>",
        "id": 134261512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383179
    },
    {
        "content": "<p>isn't that where it normally looks?</p>",
        "id": 134261523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537383194
    },
    {
        "content": "<p>I thought there was the square bracket stuff and the round bracket stuff</p>",
        "id": 134261535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383210
    },
    {
        "content": "<p>and it only looked in the square bracket stuff</p>",
        "id": 134261541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383216
    },
    {
        "content": "<p>Ah, I see. The square bracket only affects users of the theorem, it doesn't matter what you mark it when it's in the context</p>",
        "id": 134261591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537383244
    },
    {
        "content": "<p>the only thing that matters inside the theorem is whether the head constant is a <code>@[class]</code></p>",
        "id": 134261614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537383275
    },
    {
        "content": "<p>I see!</p>",
        "id": 134261627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383288
    },
    {
        "content": "<p>Hm, this is also news to me!</p>",
        "id": 134261666,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537383355
    },
    {
        "content": "<p>In which case Patrick I think this is an even bigger indication that you should just work with two different types and maps between them, and in the application make the types the same</p>",
        "id": 134261709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383368
    },
    {
        "content": "<p>Hopefully this solves some blockages higher up the chain of problems as well. I didn't know things worked like this, and presumably Patrick didn't either -- but I do remember him saying that he could not actually solve some problems with type classes because he could not direct his instances in the right direction. This will hopefully clear a lot of stuff up.</p>",
        "id": 134261780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383468
    },
    {
        "content": "<p>I also think it is a good idea to use two types and a uniform equivalence between them. The annoying this is: this may force you to prove for a lot of constants, that they are invariant under equivalences</p>",
        "id": 134261857,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537383525
    },
    {
        "content": "<p>I guess the reason many users didn't notice this is simply because it is very rare to actually have two terms of type <code>foo X</code> with <code>foo</code> a class, which you actually want to be distinct; usually users are wrestling to prove that they are the equal, not the other way around.</p>",
        "id": 134261869,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383545
    },
    {
        "content": "<p>yes, type classes work so well, exactly for this reason: if you assume two different structures, you usually have two different types</p>",
        "id": 134261902,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537383595
    },
    {
        "content": "<blockquote>\n<p>I also think it is a good idea to use two types and a uniform equivalence between them. The annoying this is: this may force you to prove for a lot of constants, that they are invariant under equivalences</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> This is back to transport de structure. Deligne emphasized this concept in his IAS lecture last week.</p>",
        "id": 134261948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383605
    },
    {
        "content": "<p>Patrick is about to need the fact that if he has <code>h : equiv X Y</code> and a topological space structure on X, then all topology-like theorems he proves for X should have an analogue for Y obtained by mapping and co-mapping along h.</p>",
        "id": 134262036,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537383674
    },
    {
        "content": "<p>we need to extensions of <code>equiv</code>: <code>continuous_equiv</code> and <code>uniform_equiv</code>. We also assume a topological structure on <code>Y</code> (it may be the one induced by <code>h</code>, but this shouldn't be necessary def-equal)</p>",
        "id": 134262303,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537383936
    },
    {
        "content": "<p>isn't <code>continuous_equiv</code> just <code>homeo</code>?</p>",
        "id": 134262810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537384447
    },
    {
        "content": "<p>yes</p>",
        "id": 134262868,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537384537
    },
    {
        "content": "<p>I feel like we have taken a big step forward here though. My solution with long lines would have been hell and Patrick was complaining some time ago that he could not control his instances. I realised the other reason that this phenomenon was not well known -- if you have a term whose type is a class, 99% of the time you put it in square brackets in the statement of a theorem or definition</p>",
        "id": 134263238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537384953
    },
    {
        "content": "<p>I'm back. Thanks everybody for your work on this.</p>",
        "id": 134263651,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537385421
    },
    {
        "content": "<p>I'm not sure I'm buying the two types solutions. The problem is that I'm not intersted in this lemma in isolation, it's a tiny step in a much bigger proof</p>",
        "id": 134263681,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537385465
    },
    {
        "content": "<p>So I'll actually need to apply this lemma</p>",
        "id": 134263692,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537385476
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>: <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> keeps pointing out that <code>transport</code> overlaps with his <code>transfer</code> machinery. I think it would be worth checking if <code>transfer</code> solves your problems right out of the box.</p>",
        "id": 134264311,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537386307
    },
    {
        "content": "<p>it doesn't solve them right out of the box. It still requires quite some infrastructure. But I think it is less work to extend <code>transfer</code> than to implement a <code>transport</code></p>",
        "id": 134264380,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537386391
    },
    {
        "content": "<p>I would like to hear much more about what is going on here. I don't know what either of these words are. Are they tactics? I remember having a lot of fun working towards <code>transport</code>. Maybe we have an actual use case here. Presumably Johannes in his message above has pinpointed exactly what we need in this situation</p>",
        "id": 134265117,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537387260
    },
    {
        "content": "<p>Patrick if you try and prove the lemma using just one beta then you have an @ nightmare. If you prove it using beta and gamma then you have a different problem which might be easily solvable and furthermore your lemma will be a more general result. You can get the lemma you want by applying the more general one in the case beta = gamma and then you are only in @ hell for a few lines</p>",
        "id": 134265223,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537387408
    },
    {
        "content": "<p>I think this is a very important topic, so I'll probably try a couple of solutions</p>",
        "id": 134265278,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537387449
    },
    {
        "content": "<p>I still need to know how I can use my \"same topology hypothesis\" to deduce that the range of e is dense for for topologies</p>",
        "id": 134265294,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537387491
    },
    {
        "content": "<p>This is very much like how transport de structure works in Galois theory. You first do it with an isomorphism X = Y and then apply it with X=Y but the isomorphism not equal to the identity and you deduce something which might look like a nontrivial computation with no work</p>",
        "id": 134265322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537387540
    },
    {
        "content": "<p><code>transfer</code> is a tactic, used in core lean to prove various properties of integers</p>",
        "id": 134265376,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1537387576
    },
    {
        "content": "<p>Kevin, you heard about it in Orsay</p>",
        "id": 134265497,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537387726
    },
    {
        "content": "<p>Oh I remember! I hadn't put two and two together.</p>",
        "id": 134265731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537387931
    },
    {
        "content": "<p>This fight against @ is epic. Did I tell you I forgot to assume both uniformities on β are complete and separated?</p>",
        "id": 134266139,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537388367
    },
    {
        "content": "<p>I tried to cut my proof into so many tiny lemmas that I forgot to copy-paste a couple of assumptions</p>",
        "id": 134266198,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537388404
    },
    {
        "content": "<p><code>set_option pp.all true</code> is my only ally</p>",
        "id": 134266574,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537388773
    },
    {
        "content": "<p><code>rewrite tactic failed, motive is not type correct nested exception message: check failed, application type mismatch (use 'set_option trace.check true' for additional details)</code> is my enemy</p>",
        "id": 134266643,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537388871
    },
    {
        "content": "<p>Now I am confused about why something which transfers proofs from N x N to Z can help. I think I need to think about how transfer actually works. But with the beta gamma approach there are no @s at all and you can just use type class inference as usual.</p>",
        "id": 134266705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537388920
    },
    {
        "content": "<p>In fact I would be tempted to see how much you can do with beta not assumed equal to gamma and not ever prove anything with beta = gamma unless you absolutely have to.</p>",
        "id": 134266720,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537388946
    },
    {
        "content": "<p>You can try to prove the lemma if you want (without forgetting to assume both structures on target are complete and separated)</p>",
        "id": 134266778,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537389005
    },
    {
        "content": "<p><code>transfer</code> doesn't require an equivalence, just a relation and proofs about terms related terms. That's how proofs about <code>Z</code> can be reduced to proofs about <code>N x N</code></p>",
        "id": 134266850,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537389096
    },
    {
        "content": "<p>I guess I would need to know the maths statement and proof...</p>",
        "id": 134267045,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537389265
    },
    {
        "content": "<p>Here is the real world story (using A and B instead of greek letters for typing convenience). We have A with a fixed uniform structure, and B with two complete separated uniform structure u and u', which induce the same topology on B. We have e : A to B which is a uniform embedding into (B, u) with dense image. We assume e is uniformly continuous from A to (B, u'). Hence it can be extended by continuity to some uniformly continuous e0 from (B, u) to (B, u'). Since e0 \\circ e = e, we learn the e0 is the identity on the image of e. But the later is dense, so by continuity, e0 = Id. So we learned that Id is uniformly continuous from (B, u) to (B, u'), QED.</p>",
        "id": 134267138,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537389366
    },
    {
        "content": "<p>As is often the case, the paper I have in front of me contains only an annotated commutative diagram.</p>",
        "id": 134267191,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537389453
    },
    {
        "content": "<p>Can we work on this together at cocalc (possibly at different times)?</p>",
        "id": 134267273,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537389514
    },
    {
        "content": "<p>or is it easier just to spam the chat with gists?</p>",
        "id": 134267286,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537389541
    },
    {
        "content": "<p>Here my full Lean so far:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">uniform_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">unif_emb</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">u_α</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u_β</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">uniform_embedding</span> <span class=\"n\">f</span>\n\n<span class=\"n\">def</span> <span class=\"n\">unif_cont</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">u_α</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u_β</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">uniform_continuous</span> <span class=\"n\">f</span>\n\n<span class=\"n\">def</span> <span class=\"n\">top</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">):=</span> <span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span>\n\n<span class=\"n\">def</span> <span class=\"n\">complete</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">complete_space</span> <span class=\"n\">α</span>\n\n<span class=\"n\">def</span> <span class=\"n\">hausdorff</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">separated</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"n\">true</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_id_of_emb</span> <span class=\"o\">[</span><span class=\"n\">uα</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u&#39;</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">cu</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">u</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">hausdorff</span> <span class=\"n\">u</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">cu&#39;</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">u&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hu&#39;</span> <span class=\"o\">:</span> <span class=\"n\">hausdorff</span> <span class=\"n\">u&#39;</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">htop</span> <span class=\"o\">:</span> <span class=\"n\">top</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">top</span> <span class=\"n\">u&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ue</span> <span class=\"o\">:</span> <span class=\"n\">unif_emb</span> <span class=\"n\">uα</span> <span class=\"n\">u</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dense</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">unif_cont</span> <span class=\"n\">uα</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">u</span> <span class=\"bp\">≤</span> <span class=\"n\">u&#39;</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₀</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ue</span><span class=\"bp\">.</span><span class=\"n\">dense_embedding</span> <span class=\"n\">dense</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">extend</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">separated</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">hu</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">unif_cont</span> <span class=\"n\">u</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e₀</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">unif_cont</span><span class=\"o\">,</span> <span class=\"n\">e₀</span><span class=\"o\">],</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">uniform_continuous_uniformly_extend</span> <span class=\"n\">β</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">u</span> <span class=\"n\">uα</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e</span> <span class=\"n\">ue</span> <span class=\"n\">dense</span> <span class=\"n\">e</span> <span class=\"n\">h</span> <span class=\"n\">cu&#39;</span> <span class=\"n\">hu&#39;</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">top</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">htop</span><span class=\"o\">,</span>\n\n    <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 134267302,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537389565
    },
    {
        "content": "<p>I am trying to help my daughter with biology homework, clean the kitchen, eat some dinner and prove a lemma</p>",
        "id": 134267307,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537389571
    },
    {
        "content": "<p>A CoCalc effort would probably be fun</p>",
        "id": 134267315,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537389583
    },
    {
        "content": "<p>As you can see, I tried to hide a bunch of @ in new definitions which simply change binders</p>",
        "id": 134267377,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537389621
    },
    {
        "content": "<p>The bad side is we need <code>dsimp</code> then</p>",
        "id": 134267413,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537389682
    },
    {
        "content": "<p>That real world proof looks applicable where the types are different. The only tricky bit is \"generating the same topology\", but I think this just means that the equiv is a quotient map (in the topological sense)</p>",
        "id": 134267624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537389900
    },
    {
        "content": "<p>The relevant part of state is then</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">this</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">uniform_continuous</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_2</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"n\">β</span> <span class=\"n\">u</span> <span class=\"n\">u&#39;</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">dense_embedding</span><span class=\"bp\">.</span><span class=\"n\">extend</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span> <span class=\"n\">u_2</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">α</span> <span class=\"n\">uα</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n       <span class=\"n\">e</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"n\">u&#39;</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_embedding</span><span class=\"bp\">.</span><span class=\"n\">dense_embedding</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">uα</span> <span class=\"n\">u</span> <span class=\"n\">e</span> <span class=\"n\">ue</span> <span class=\"n\">dense</span><span class=\"o\">)</span>\n       <span class=\"n\">e</span><span class=\"o\">),</span>\n<span class=\"n\">htop</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"n\">u&#39;</span><span class=\"o\">)</span>\n<span class=\"err\">⊢</span> <span class=\"bp\">@</span><span class=\"n\">uniform_continuous</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_2</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"n\">β</span> <span class=\"n\">u</span> <span class=\"n\">u&#39;</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">dense_embedding</span><span class=\"bp\">.</span><span class=\"n\">extend</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span> <span class=\"n\">u_2</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">α</span> <span class=\"n\">uα</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n       <span class=\"n\">e</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">β</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_embedding</span><span class=\"bp\">.</span><span class=\"n\">dense_embedding</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">uα</span> <span class=\"n\">u</span> <span class=\"n\">e</span> <span class=\"n\">ue</span> <span class=\"n\">dense</span><span class=\"o\">)</span>\n       <span class=\"n\">e</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>So it looks like <code>rwa htop at this</code> should close the goal, but I get a that nasty error instead</p>",
        "id": 134267625,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537389902
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 134267727,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537390000
    },
    {
        "content": "<p>Here is the version which is written in what I believe is the correct generality (using A and B and C instead of greek letters for typing convenience). We have A, B, C uniform spaces, with B and C uniform and complete, and a homeo j : B -&gt; C.  We have e : A to B which is a uniform embedding into B with dense image. We assume j circ e is uniformly continuous from A to C. Hence it can be extended by continuity to some uniformly continuous j' from B to C. Since j = j' on e(A), j = j' and hence j is uniformly continuous from B to C, QED <em>without a single @</em></p>",
        "id": 134267732,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537390007
    },
    {
        "content": "<p>I'll try to prove that tomorrow, but I fear this is only pushing the pain to the moment I will need to apply the lemma</p>",
        "id": 134267846,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537390116
    },
    {
        "content": "<p>we need the theorem that <code>id</code> is uniformly continuous from <code>u</code> to <code>u'</code> iff <code>u &lt;= u'</code></p>",
        "id": 134267863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537390141
    },
    {
        "content": "<p>that is the only part that really needs <code>@</code> work, and the proof is trivial using <code>map_id</code> on filters</p>",
        "id": 134267879,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537390171
    },
    {
        "content": "<p>Sure, we need this id stuff.</p>",
        "id": 134267939,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537390215
    },
    {
        "content": "<p>But I don't understand the next sentence</p>",
        "id": 134267956,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537390226
    },
    {
        "content": "<p>And I don't understand why rewrite doesn't work in my attempt.</p>",
        "id": 134268016,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537390307
    },
    {
        "content": "<p>uniform continuity works on pairs of function, i.e. you need to prove <code>(λx:α×α, (x.1, x.2)) = id</code></p>",
        "id": 134268122,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537390418
    },
    {
        "content": "<p>and then unfold <code>uniform_continuity</code> and rewrite with this equality</p>",
        "id": 134268196,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537390479
    },
    {
        "content": "<p>Sure, but this is completely orthogonal to my problem, right?</p>",
        "id": 134268304,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537390574
    },
    {
        "content": "<p>I'm far away from having that id is uniformly continuous here</p>",
        "id": 134268321,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537390598
    },
    {
        "content": "<p>Do we have homeomorphisms in the strong sense of a continuous equiv with a continuous inverse?</p>",
        "id": 134268507,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537390779
    },
    {
        "content": "<p>no :(</p>",
        "id": 134268530,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537390801
    },
    {
        "content": "<p><a href=\"https://github.com/PatrickMassot/lean-differential-topology/blob/master/src/homeos.lean\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-differential-topology/blob/master/src/homeos.lean\">https://github.com/PatrickMassot/lean-differential-topology/blob/master/src/homeos.lean</a></p>",
        "id": 134268631,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537390887
    },
    {
        "content": "<p>Would you like to get this in mathlib?</p>",
        "id": 134268639,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537390902
    },
    {
        "content": "<p>I need to go sleeping, but don't hesitate to unblock this. I hope I could then imitate the solution in many other such lemmas</p>",
        "id": 134268698,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537390940
    },
    {
        "content": "<p>Patrick here is the statement with beta ne gamma:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_id_of_emb&#39;</span> <span class=\"o\">[</span><span class=\"n\">uα</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">complete_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">separated</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">complete_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">separated</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- need cts</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ue</span> <span class=\"o\">:</span> <span class=\"n\">uniform_embedding</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dense</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">uniform_continuous</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"err\">∘</span> <span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"o\">:</span>  <span class=\"n\">uniform_continuous</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>I had to use none of your five binder-changing defs</p>",
        "id": 134268794,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537391060
    },
    {
        "content": "<p>Weird! My rewrite now works</p>",
        "id": 134269048,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537391374
    },
    {
        "content": "<p>I wanted to try one more time. I have no idea what changed</p>",
        "id": 134269054,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537391390
    },
    {
        "content": "<p>Thanks Kevin. I'll definitely try this road tomorrow</p>",
        "id": 134269137,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537391466
    },
    {
        "content": "<p>But, as I wrote earlier, I think it's important enough that I try several things</p>",
        "id": 134269145,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537391480
    },
    {
        "content": "<p>wait, does the statement hold at all?</p>",
        "id": 134269235,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537391593
    },
    {
        "content": "<p>How do you want to prove it? (ah, reading your previous description)</p>",
        "id": 134269249,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537391628
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">unif_cont</span> <span class=\"n\">u</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e₀</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">unif_cont</span><span class=\"o\">,</span> <span class=\"n\">e₀</span><span class=\"o\">],</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">uniform_continuous_uniformly_extend</span> <span class=\"n\">β</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">u</span> <span class=\"n\">uα</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e</span> <span class=\"n\">ue</span> <span class=\"n\">dense</span> <span class=\"n\">e</span> <span class=\"n\">h</span> <span class=\"n\">cu&#39;</span> <span class=\"n\">hu&#39;</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">top</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">htop</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">htop</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">occs</span> <span class=\"o\">:=</span> <span class=\"n\">occurrences</span><span class=\"bp\">.</span><span class=\"n\">pos</span> <span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]}</span> <span class=\"o\">},</span>\n</pre></div>\n\n\n<p>the have can be proved fixing the occurence. I guess the <code>e₀ = id</code> proof doesn't mention any uniformities?</p>",
        "id": 134269434,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537391872
    },
    {
        "content": "<p>Oh -- I should add that my formalisation is not quite correct because the <code>equiv</code> should be a <code>homeo</code></p>",
        "id": 134269643,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537392166
    },
    {
        "content": "<p>Hmm, we seem to need the theorem that <code>id</code> is uniformly continuous from <code>u</code> to <code>u'</code> iff <code>u &lt;= u'</code>. But I would rather prove a statement that an equiv is uniformly continuous iff some pushforward of a uniformity is <code>&lt;=</code> the other one. Is this already in Lean?</p>",
        "id": 134269735,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537392327
    },
    {
        "content": "<p>this holds by definitional equality. EDIT: no, it doesn't</p>",
        "id": 134269997,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537392630
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">unif_cont</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">u_α</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u_β</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">uniform_continuous</span> <span class=\"n\">f</span>\n</pre></div>\n\n\n<p>Is this OK if alpha = beta? I'm not so sure. I think type class inference chooses the same uniform structure twice. <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I think there's a bug here. Thoughts anyone?</p>",
        "id": 134270448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537393237
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">uα</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uβ</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):</span>\n  <span class=\"n\">uniform_continuous</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">uβ</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">uα</span> <span class=\"o\">:=</span>\n<span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">map_le_iff_le_comap</span>\n</pre></div>",
        "id": 134270861,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537393663
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> the content of <code>unif_cont</code> is fully elaborated. The elaborator doesn't do a type class search when it is used in <code>uniform_continuous_id_of_emb</code></p>",
        "id": 134271113,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537393790
    },
    {
        "content": "<p>Oh I see. So it's Ok.</p>",
        "id": 134271209,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537393827
    },
    {
        "content": "<p>As you can see, I am still coming to terms with my new knowledge about how typeclass inference works. Patrick -- sorry -- it's Ok.</p>",
        "id": 134271228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537393852
    },
    {
        "content": "<p>Patrick's version --</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_id_of_emb</span> <span class=\"o\">[</span><span class=\"n\">uα</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u&#39;</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">cu</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">u</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">hausdorff</span> <span class=\"n\">u</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">cu&#39;</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">u&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hu&#39;</span> <span class=\"o\">:</span> <span class=\"n\">hausdorff</span> <span class=\"n\">u&#39;</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">htop</span> <span class=\"o\">:</span> <span class=\"n\">top</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">top</span> <span class=\"n\">u&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ue</span> <span class=\"o\">:</span> <span class=\"n\">unif_emb</span> <span class=\"n\">uα</span> <span class=\"n\">u</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dense</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">unif_cont</span> <span class=\"n\">uα</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">u</span> <span class=\"bp\">≤</span> <span class=\"n\">u&#39;</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>Should the conclusion be <code>u' &lt;= u</code>? I'm not an expert in uniform spaces.</p>",
        "id": 134271543,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537394174
    },
    {
        "content": "<p>I ask because Patrick seemed to be saying that the conclusion was that id was continuous from u to u', and Johannes seems to want to conclude from this that <code>u' &lt;= u</code>. But this could easily be some situation where <code>&lt;=</code> is defined as <code>&gt;=</code> for some people (as far as I know)</p>",
        "id": 134271658,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537394324
    },
    {
        "content": "<p>There is no <code>uniform_space.comap_id</code> :-(</p>",
        "id": 134272056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537394821
    },
    {
        "content": "<p>gaargh there seems to be no <code>ext</code></p>",
        "id": 134274017,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537397829
    },
    {
        "content": "<p><code>⊢ u' = uniform_space.comap id u'</code></p>",
        "id": 134274344,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537398266
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">unif_cont</span> <span class=\"n\">u</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e₀</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">unif_cont</span><span class=\"o\">,</span> <span class=\"n\">e₀</span><span class=\"o\">],</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">uniform_continuous_uniformly_extend</span> <span class=\"n\">β</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">u</span> <span class=\"n\">uα</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e</span> <span class=\"n\">ue</span> <span class=\"n\">dense</span> <span class=\"n\">e</span> <span class=\"n\">h</span> <span class=\"n\">cu&#39;</span> <span class=\"n\">hu&#39;</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">top</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">htop</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">htop</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">occs</span> <span class=\"o\">:=</span> <span class=\"n\">occurrences</span><span class=\"bp\">.</span><span class=\"n\">pos</span> <span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]}</span> <span class=\"o\">},</span>\n</pre></div>\n\n\n</blockquote>\n<p>With the gamma version it's just</p>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"k\">let</span> <span class=\"n\">e₀</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ue</span><span class=\"bp\">.</span><span class=\"n\">dense_embedding</span> <span class=\"n\">dense</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">extend</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"err\">∘</span> <span class=\"n\">e</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">uniform_continuous</span> <span class=\"n\">e₀</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">unif_cont</span><span class=\"o\">,</span> <span class=\"n\">e₀</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">uniform_continuous_uniformly_extend</span> <span class=\"n\">ue</span> <span class=\"n\">dense</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n</pre></div>",
        "id": 134275140,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537399411
    },
    {
        "content": "<p>Everything is easier this way, switching to gamma is a no-brainer</p>",
        "id": 134275198,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537399459
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">uniform_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_id_of_emb&#39;</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">complete_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">separated</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">complete_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">separated</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- need continuity assumption</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ue</span> <span class=\"o\">:</span> <span class=\"n\">uniform_embedding</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dense</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">uniform_continuous</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"err\">∘</span> <span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">uniform_continuous</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₀</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ue</span><span class=\"bp\">.</span><span class=\"n\">dense_embedding</span> <span class=\"n\">dense</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">extend</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"err\">∘</span> <span class=\"n\">e</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">uniform_continuous</span> <span class=\"n\">e₀</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">e₀</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">uniform_continuous_uniformly_extend</span> <span class=\"n\">ue</span> <span class=\"n\">dense</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">sorry</span> <span class=\"c1\">-- I need that j is a homeo and this isn&#39;t in the assumptions</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>but it's bedtime now</p>",
        "id": 134275275,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537399566
    },
    {
        "content": "<p>and we need to say that <code>j</code> is a homeo not just an equiv.</p>",
        "id": 134275281,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537399592
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">uα</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uβ</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):</span>\n  <span class=\"n\">uniform_continuous</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">uβ</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">uα</span> <span class=\"o\">:=</span>\n<span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">map_le_iff_le_comap</span>\n\n<span class=\"n\">def</span> <span class=\"n\">unif_emb</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">u_α</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u_β</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">uniform_embedding</span> <span class=\"n\">f</span>\n\n<span class=\"n\">def</span> <span class=\"n\">unif_cont</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">u_α</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u_β</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">uniform_continuous</span> <span class=\"n\">f</span>\n\n<span class=\"n\">def</span> <span class=\"n\">top</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">):=</span> <span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span>\n\n<span class=\"n\">def</span> <span class=\"n\">complete</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">complete_space</span> <span class=\"n\">α</span>\n\n<span class=\"n\">def</span> <span class=\"n\">hausdorff</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">separated</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_id_of_emb</span> <span class=\"o\">[</span><span class=\"n\">uα</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u&#39;</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">cu</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">u</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">hausdorff</span> <span class=\"n\">u</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">cu&#39;</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">u&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hu&#39;</span> <span class=\"o\">:</span> <span class=\"n\">hausdorff</span> <span class=\"n\">u&#39;</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">htop</span> <span class=\"o\">:</span> <span class=\"n\">top</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">top</span> <span class=\"n\">u&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ue</span> <span class=\"o\">:</span> <span class=\"n\">unif_emb</span> <span class=\"n\">uα</span> <span class=\"n\">u</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dense</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">unif_cont</span> <span class=\"n\">uα</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">u&#39;</span> <span class=\"bp\">≤</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">unif_cont</span> <span class=\"n\">u</span> <span class=\"n\">u&#39;</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">uniform_continuous_id_of_emb&#39;</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">β</span> <span class=\"n\">uα</span> <span class=\"n\">u</span> <span class=\"n\">u&#39;</span> <span class=\"n\">cu</span> <span class=\"n\">hu</span> <span class=\"n\">cu&#39;</span> <span class=\"n\">hu&#39;</span> <span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">e</span> <span class=\"n\">ue</span> <span class=\"n\">dense</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">unif_cont</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">uniform_continuous_iff</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- ⊢ u&#39; = uniform_space.comap id u&#39;</span>\n  <span class=\"c1\">-- should be trivial?</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 134275359,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537399731
    },
    {
        "content": "<p><code>  have : uniform_continuous e₀ :=\n    uniform_continuous_uniformly_extend ue dense h,</code></p>",
        "id": 134275590,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537400116
    },
    {
        "content": "<p>Indeed it seems the following is missing:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">id_prod</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">ext</span> <span class=\"bp\">;</span> <span class=\"n\">simp</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">extensionality</span><span class=\"o\">]</span> <span class=\"n\">uniform_space_eq</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">uniform_space_comap_id</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">id_prod</span><span class=\"o\">,</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">comap_id</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>The first one is strange, but I couldn't find it <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> any thought?</p>",
        "id": 134291887,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537428114
    },
    {
        "content": "<p>Should we add this to mathlib? make the first one a simp lemma?</p>",
        "id": 134291938,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537428137
    },
    {
        "content": "<p>you mean <code>id_prod</code>? I don't think we have it yet</p>",
        "id": 134291941,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537428141
    },
    {
        "content": "<p>Yes, id_prod</p>",
        "id": 134291947,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537428150
    },
    {
        "content": "<p>I feel like a child collecting football cards again</p>",
        "id": 134291951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537428157
    },
    {
        "content": "<p>great excitement when we discover a new basic lemma we don't have</p>",
        "id": 134291955,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537428168
    },
    {
        "content": "<p>simp or not simp?</p>",
        "id": 134291967,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537428186
    },
    {
        "content": "<p>I guess we will never run out of basic lemmas</p>",
        "id": 134291968,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537428188
    },
    {
        "content": "<p>currently I'm in favor of not simp</p>",
        "id": 134291971,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537428198
    },
    {
        "content": "<p>I ran out of football cards once; I remember the joy of getting the last one. Bryan Flynn, Leeds United.</p>",
        "id": 134291975,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537428227
    },
    {
        "content": "<p>I don't think we have a lot of eta-rule like these in the simp-set. And it might get confusing. But then this rule is quiet nice...</p>",
        "id": 134291976,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537428241
    },
    {
        "content": "<p>But I thought we would ultimately find that every basic lemma is either easy or has a tactic-free and simple proof</p>",
        "id": 134292015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537428265
    },
    {
        "content": "<p>What about tagging uniform_space_eq?</p>",
        "id": 134292016,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537428266
    },
    {
        "content": "<p>yes, <code>uniform_space_eq</code> should be tagged with <code>@[extensionality]</code>.</p>",
        "id": 134292107,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537428476
    },
    {
        "content": "<p>Ok, I first PR'ed id_prod, then I'll do the other two</p>",
        "id": 134292424,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537428968
    },
    {
        "content": "<p>just waiting for Travis</p>",
        "id": 134292533,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537429140
    },
    {
        "content": "<p>Quick update on this topic: mathlib got <a href=\"https://github.com/leanprover/mathlib/commit/d0f1b21a9df64f48a8d28203bf292eb80e05a6da\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/commit/d0f1b21a9df64f48a8d28203bf292eb80e05a6da\">https://github.com/leanprover/mathlib/commit/d0f1b21a9df64f48a8d28203bf292eb80e05a6da</a> and <a href=\"https://github.com/leanprover/mathlib/commit/1da8cc51854c2e75f456878b195b162dc8dbb130\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/commit/1da8cc51854c2e75f456878b195b162dc8dbb130\">https://github.com/leanprover/mathlib/commit/1da8cc51854c2e75f456878b195b162dc8dbb130</a> then I added <a href=\"https://github.com/PatrickMassot/lean-differential-topology/blob/master/src/homeos.lean\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-differential-topology/blob/master/src/homeos.lean\">https://github.com/PatrickMassot/lean-differential-topology/blob/master/src/homeos.lean</a> to the perfectoid project (I think I still don't whether mathlib wants it). We can then write the two versions of the lemma (following my real life sketch and Kevin's Lean  start) as:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_id_of_emb&#39;</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">complete_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">separated</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">complete_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">separated</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">homeo</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ue</span> <span class=\"o\">:</span> <span class=\"n\">uniform_embedding</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dense</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">uniform_continuous</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"err\">∘</span> <span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">uniform_continuous</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">e₀</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ue</span><span class=\"bp\">.</span><span class=\"n\">dense_embedding</span> <span class=\"n\">dense</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">extend</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"err\">∘</span> <span class=\"n\">e</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">uc_e₀</span> <span class=\"o\">:</span> <span class=\"n\">uniform_continuous</span> <span class=\"n\">e₀</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">e₀</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">uniform_continuous_uniformly_extend</span> <span class=\"n\">ue</span> <span class=\"n\">dense</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"n\">convert</span> <span class=\"n\">uc_e₀</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">closed</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"n\">j</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">e₀</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">is_closed_eq</span> <span class=\"n\">j</span><span class=\"bp\">.</span><span class=\"n\">fun_con</span> <span class=\"n\">uc_e₀</span><span class=\"bp\">.</span><span class=\"n\">continuous</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">dense&#39;</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rwa</span> <span class=\"n\">eq_univ_iff_forall</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">is_closed_property</span> <span class=\"n\">dense&#39;</span> <span class=\"n\">closed</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"err\">$</span> <span class=\"n\">uniformly_extend_of_emb</span> <span class=\"n\">ue</span> <span class=\"n\">dense</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">unif_emb</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">u_α</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u_β</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">uniform_embedding</span> <span class=\"n\">f</span>\n\n<span class=\"n\">def</span> <span class=\"n\">unif_cont</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">u_α</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u_β</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">uniform_continuous</span> <span class=\"n\">f</span>\n\n<span class=\"n\">def</span> <span class=\"n\">top</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">):=</span> <span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span>\n\n<span class=\"n\">def</span> <span class=\"n\">complete</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">complete_space</span> <span class=\"n\">α</span>\n\n<span class=\"n\">def</span> <span class=\"n\">hausdorff</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">separated</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_id_of_emb</span> <span class=\"o\">[</span><span class=\"n\">uα</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u&#39;</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">cu</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">u</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">hausdorff</span> <span class=\"n\">u</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">cu&#39;</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">u&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hu&#39;</span> <span class=\"o\">:</span> <span class=\"n\">hausdorff</span> <span class=\"n\">u&#39;</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">htop</span> <span class=\"o\">:</span> <span class=\"n\">top</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">top</span> <span class=\"n\">u&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ue</span> <span class=\"o\">:</span> <span class=\"n\">unif_emb</span> <span class=\"n\">uα</span> <span class=\"n\">u</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dense</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">unif_cont</span> <span class=\"n\">uα</span> <span class=\"n\">u&#39;</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">u&#39;</span> <span class=\"bp\">≤</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">iduu&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">homeo</span> <span class=\"n\">β</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">top</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">top</span> <span class=\"n\">u&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n    <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n    <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">fun_con</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">htop</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">continuous_id</span><span class=\"o\">,</span>\n    <span class=\"n\">inv_con</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">htop</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">continuous_id</span> <span class=\"o\">},</span>\n\n  <span class=\"n\">rw</span> <span class=\"k\">show</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">iduu&#39;</span> <span class=\"err\">∘</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">refl</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">uniform_continuous_id_of_emb&#39;</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">β</span> <span class=\"n\">uα</span> <span class=\"n\">u</span> <span class=\"n\">u&#39;</span> <span class=\"n\">cu</span> <span class=\"n\">hu</span> <span class=\"n\">cu&#39;</span> <span class=\"n\">hu&#39;</span> <span class=\"n\">iduu&#39;</span> <span class=\"n\">e</span> <span class=\"n\">ue</span> <span class=\"n\">dense</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n\n  <span class=\"n\">rw</span> <span class=\"n\">uniform_continuous_iff</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">iduu&#39;</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">uniform_space_comap_id</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 134316246,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537456985
    },
    {
        "content": "<p>Of course the first proof has no @, we are not fighting mathlib here. The second one is not too bad in my opinion. The statement is clean, because of the \"rebinded\" definitions, which cost nothing in the proof.</p>",
        "id": 134316471,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537457171
    },
    {
        "content": "<p>The main @ thing is the definition of the identity seen as a homeo between different topologies, which costs two slightly awkwards <code>rw show ..., by refl</code>.</p>",
        "id": 134316535,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537457259
    },
    {
        "content": "<p>What do you guys think about all this?</p>",
        "id": 134316601,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537457290
    },
    {
        "content": "<p>I think the identity homeo should be a theorem</p>",
        "id": 134316684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537457390
    },
    {
        "content": "<p>Stating what?</p>",
        "id": 134316753,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537457415
    },
    {
        "content": "<p>just like the theorem that identity is continuous iff the topologies are le, the identity is a homeo iff the topologies are eq</p>",
        "id": 134316771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537457431
    },
    {
        "content": "<p>This bundled definition of a homeo doesn't seem so nice when it comes to stating that some map is a homeo</p>",
        "id": 134316811,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537457486
    },
    {
        "content": "<p>this is true. Maybe settle for one direction, the one you proved</p>",
        "id": 134316836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537457512
    },
    {
        "content": "<p>The reverse direction says that if <code>f : homeo A A T1 T2</code> and <code>f x = x</code> for all <code>x</code>, then <code>T1 = T2</code></p>",
        "id": 134316920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537457589
    },
    {
        "content": "<p>So it would be a <code>def</code>, not a <code>lemma</code>, right?</p>",
        "id": 134316930,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537457604
    },
    {
        "content": "<p>yes</p>",
        "id": 134316939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537457611
    },
    {
        "content": "<p>After all this refactoring, I would ask whether you really need <code>uniform_continuous_id_of_emb</code> though</p>",
        "id": 134317018,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537457701
    },
    {
        "content": "<p>we treated it as the endgame but maybe you can avoid le on uniformities to begin with</p>",
        "id": 134317045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537457750
    },
    {
        "content": "<p>I was wondering the same</p>",
        "id": 134317110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537457804
    },
    {
        "content": "<p>Of course this is also a legitimate question. But this thread is also used as an exercise in type class hell survival.</p>",
        "id": 134317111,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537457805
    },
    {
        "content": "<p>Patrick's original question was whether the completion of a top group \"equalled\" (in a mathematician-like way) the completion of the underlying uniform space. But these two completions are just two different types so you could instead ask if they are uniform-equiv, not that this exists.</p>",
        "id": 134317153,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537457869
    },
    {
        "content": "<p>On the other hand Johannes, if I recall correctly, put a bunch of stuff in <code>topological_space.lean</code> about different topologies on the same space...</p>",
        "id": 134317201,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537457904
    },
    {
        "content": "<p>What do you mean \"different types\"?</p>",
        "id": 134317202,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537457905
    },
    {
        "content": "<p>Isn't there one \"complete-a-group\" function which completes a group and spits out one type, and one \"complete-a-uniform-space\" function which completes a uniform space and spits out a second type? And we think of them as \"equal\" but they're two different types. That's all I mean, and you know all this already.</p>",
        "id": 134317249,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537457973
    },
    {
        "content": "<p>I was wondering if you ever needed to compare two uniformities on the same type, but I don't know the full story</p>",
        "id": 134317315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458009
    },
    {
        "content": "<p>No, there is a complete a uniform space structure, an instance saying that the result has a uniform structure, and there are instances saying that abelian top groups are uniform spaces, and that the completion of a group is a top group</p>",
        "id": 134317340,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458051
    },
    {
        "content": "<p>The full story is still at <a href=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L124\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L124\">https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L124</a></p>",
        "id": 134317355,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458067
    },
    {
        "content": "<p>and <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/group_completion.lean#L118\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/group_completion.lean#L118\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/group_completion.lean#L118</a> of course (maybe with tiny differences)</p>",
        "id": 134317382,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458101
    },
    {
        "content": "<p>So we really have two uniform space structures on the same type. But of course I wonder whether I could cook up more functions to hide things to the type class system</p>",
        "id": 134317454,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458145
    },
    {
        "content": "<p>So should that line 124 even make sense?</p>",
        "id": 134317655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458384
    },
    {
        "content": "<p>That's what I'm thinking</p>",
        "id": 134317662,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458390
    },
    {
        "content": "<p>Given some top group H</p>",
        "id": 134317668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458412
    },
    {
        "content": "<p>there is an associated uniform space which is also H</p>",
        "id": 134317670,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458420
    },
    {
        "content": "<p>but then isn't there <code>topological_add_group.completion H</code> (one type) and <code>uniform_space.completion H</code> (a different type)?</p>",
        "id": 134317685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458446
    },
    {
        "content": "<p>And then maybe you prove a theorem saying that two uniform structures are the same</p>",
        "id": 134317756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458520
    },
    {
        "content": "<p>I guess there is a single (uniform) completion operation which additionally has the property that it lifts topological group structure</p>",
        "id": 134317768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537458545
    },
    {
        "content": "<p>right, but should it be like that?</p>",
        "id": 134317774,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458559
    },
    {
        "content": "<p>should the theorem be that there's a uniform space equiv?</p>",
        "id": 134317777,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458576
    },
    {
        "content": "<p>Obviously <code>topological_group</code> should have a uniform component so that this can be by defeq</p>",
        "id": 134317778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537458577
    },
    {
        "content": "<blockquote>\n<p>Obviously <code>topological_group</code> should have a uniform component</p>\n</blockquote>\n<p>This is when it gets silly.</p>",
        "id": 134317847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458611
    },
    {
        "content": "<p>The theorem that is sorried there has mathematical content, it won't become trivial</p>",
        "id": 134317853,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458627
    },
    {
        "content": "<p>right</p>",
        "id": 134317857,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458634
    },
    {
        "content": "<p>So I don't know what Mario wants to see defeq</p>",
        "id": 134317866,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458649
    },
    {
        "content": "<p>of course, the content is shifted to the definition of the topological group</p>",
        "id": 134317867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537458649
    },
    {
        "content": "<p>Is there no way of making all this sensible?</p>",
        "id": 134317879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458676
    },
    {
        "content": "<p>There are zero cases where you want a topological group with a uniform structure that doesn't agree with it</p>",
        "id": 134317884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537458686
    },
    {
        "content": "<p>It's like the product of metric spaces example, but it's even better, because we don't even have to take a product.</p>",
        "id": 134317890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458700
    },
    {
        "content": "<p>Except for non-commutative groups where there are two choices</p>",
        "id": 134317894,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458709
    },
    {
        "content": "<p>rofl</p>",
        "id": 134317895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458713
    },
    {
        "content": "<p>Left uniformity and right uniformity</p>",
        "id": 134317944,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458732
    },
    {
        "content": "<p>two different uniformities giving the same topology, right?</p>",
        "id": 134317945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458733
    },
    {
        "content": "<p>sure</p>",
        "id": 134317950,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458738
    },
    {
        "content": "<p>Let's cross that bridge when we come to it</p>",
        "id": 134317959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458757
    },
    {
        "content": "<p>I assumed everything was commutative because I aimed for addition in rings</p>",
        "id": 134317960,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458761
    },
    {
        "content": "<p>and it was complicated enough</p>",
        "id": 134317964,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458770
    },
    {
        "content": "<p>I want to end up in a situation where there are no diamonds. Is this possible?</p>",
        "id": 134317967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458780
    },
    {
        "content": "<p>yes</p>",
        "id": 134317977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537458790
    },
    {
        "content": "<p>Given a uniform space I want to be able to complete it</p>",
        "id": 134317978,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458792
    },
    {
        "content": "<p>I don't mind seeing the uniform structure as part of the abelian top group</p>",
        "id": 134317982,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458799
    },
    {
        "content": "<p>I assume you mean the diamonds commute by defeq</p>",
        "id": 134317985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537458801
    },
    {
        "content": "<p>yes</p>",
        "id": 134317987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458806
    },
    {
        "content": "<p>What I was thinking is that the group completion should have a different name.</p>",
        "id": 134318005,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458834
    },
    {
        "content": "<p>But I don't see how this will help when proving the actual theorem, even if this proof is now part of the construction of the top group instance</p>",
        "id": 134318006,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458838
    },
    {
        "content": "<p>this is not supposed to help proving the theorem</p>",
        "id": 134318053,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458850
    },
    {
        "content": "<p>yes I was just wondering about how to make the theorem part of the infrastructure. Is this just clear to both of you?</p>",
        "id": 134318059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458868
    },
    {
        "content": "<p>I mean help in the Lean sense, not maths sense</p>",
        "id": 134318060,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458869
    },
    {
        "content": "<p>Nothing is clear to me here (except the proof I see on paper in front of me)</p>",
        "id": 134318076,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537458886
    },
    {
        "content": "<p>I want to give the top group completion a different name, make it a different type to the uniform space completion</p>",
        "id": 134318084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458898
    },
    {
        "content": "<p>hmm but it still has to be a top group</p>",
        "id": 134318110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458926
    },
    {
        "content": "<p>It will make that <code>same_uniformity</code> theorem true by defeq, so you won't have to muck about with rewriting instance arguments</p>",
        "id": 134318113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537458931
    },
    {
        "content": "<p>But it's true that the theorem still has to be proved, and it is an equality of uniformities</p>",
        "id": 134318165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537458969
    },
    {
        "content": "<p>top groups and uniform spaces -- they are going to be classes, right? Let's make that assumption</p>",
        "id": 134318169,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458972
    },
    {
        "content": "<p>yes, are they not already?</p>",
        "id": 134318172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537458986
    },
    {
        "content": "<p>And there's always going to be an instance from top group to uniform space, right?</p>",
        "id": 134318173,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537458990
    },
    {
        "content": "<p>right</p>",
        "id": 134318174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537458993
    },
    {
        "content": "<p>but it may be generated by <code>extends</code></p>",
        "id": 134318184,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537459009
    },
    {
        "content": "<p>?</p>",
        "id": 134318198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537459025
    },
    {
        "content": "<p>and will a top group definitely have a uniformity component?</p>",
        "id": 134318208,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459030
    },
    {
        "content": "<p>so the instance is a forgetful functor?</p>",
        "id": 134318215,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459042
    },
    {
        "content": "<p>If <code>class top_group extends uniform_space</code></p>",
        "id": 134318219,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537459044
    },
    {
        "content": "<p>right</p>",
        "id": 134318222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537459050
    },
    {
        "content": "<p>But with the completion construction</p>",
        "id": 134318225,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459056
    },
    {
        "content": "<p>you can insert the theorem into the construction, can you not?</p>",
        "id": 134318230,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459067
    },
    {
        "content": "<p>yes, that's the idea</p>",
        "id": 134318236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537459074
    },
    {
        "content": "<p>right</p>",
        "id": 134318239,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459077
    },
    {
        "content": "<p>so the top group completion <em>must</em> have the \"uniform space generated by the top group structure\" uniform space</p>",
        "id": 134318313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459143
    },
    {
        "content": "<p>So the gain would be when I wanted to use the <code>same_uniformity</code> theorem, in <a href=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L161\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L161\">https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L161</a> not when I want to prove it</p>",
        "id": 134318321,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537459149
    },
    {
        "content": "<p>yes</p>",
        "id": 134318401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537459224
    },
    {
        "content": "<p>sounds very good</p>",
        "id": 134318406,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537459236
    },
    {
        "content": "<p>I think I'm there</p>",
        "id": 134318411,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459244
    },
    {
        "content": "<p>Kevin, do you want to know why we need this theorem? It's easy to explain</p>",
        "id": 134318434,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537459268
    },
    {
        "content": "<p>Mario, the trouble is I tried to do this \"top_group extends uniform space\" trick after the Orsay meeting but couldn't handle everything that broke when I started</p>",
        "id": 134318451,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537459310
    },
    {
        "content": "<p>I can see for maths reasons why we want to prove the two uniformities are equal.</p>",
        "id": 134318512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459382
    },
    {
        "content": "<p>What I was thinking about was how all this could play well with the type class system.</p>",
        "id": 134318529,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459406
    },
    {
        "content": "<p>That is exactly why I changed your beta,beta to beta,gamma, because then the theorem you were struggling on suddenly seemed much easier</p>",
        "id": 134318544,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459435
    },
    {
        "content": "<p>ok, we're on the same page</p>",
        "id": 134318545,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537459438
    },
    {
        "content": "<p>but if topological_group extends uniform_space (I don't know if it does or if it should) then we have to be careful, but it sounds like it's OK. I guess it doesn't matter whether it extends or not -- you probably still want an instance. Eew. Is top group -&gt; uniform space -&gt; top space defeq to top group -&gt; top space?</p>",
        "id": 134318717,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459564
    },
    {
        "content": "<p>Yes, I made sure this is true back in June</p>",
        "id": 134318744,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537459601
    },
    {
        "content": "<p>It's ridiculous that this sort of thing is important. I think the system is not quite fit for purpose.</p>",
        "id": 134318765,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459623
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/topological_structures.lean#L353\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/topological_structures.lean#L353\">https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/topological_structures.lean#L353</a></p>",
        "id": 134318790,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537459644
    },
    {
        "content": "<p>I'm with Chris. He had trouble with two instances which were provably equivalent but not defeq. There should be a way to make this work by brandishing a theorem at the type class inference system and saying \"use this if stuck\"</p>",
        "id": 134318805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459674
    },
    {
        "content": "<blockquote>\n<p>just like the theorem that identity is continuous iff the topologies are le</p>\n</blockquote>\n<p>Do we actually have this theorem in mathlib? I can't find it</p>",
        "id": 134318890,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537459746
    },
    {
        "content": "<p>It would be wonderful if the default setting was \"if it's a class, then you will have one instance and that's the end of it. If there are two instances, then you had better supply the proof that they're the same\"</p>",
        "id": 134318891,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459747
    },
    {
        "content": "<p>and you had to explicitly switch this off.</p>",
        "id": 134318900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537459766
    },
    {
        "content": "<p>Let's try to use the existing Lean. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what do you suggest I should do? Should I try to refactor everything about commutative additive top groups? Should I start with <code>class topological_abelian_group (α : Type u) extends uniform_space α, add_comm_group α</code>?</p>",
        "id": 134319419,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537460284
    },
    {
        "content": "<p>and then prove an instance converting this to the existing topological group classes?</p>",
        "id": 134319450,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537460332
    },
    {
        "content": "<p>he'll make you call it <code>topological_add_comm_group</code></p>",
        "id": 134320701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537461594
    },
    {
        "content": "<p>I'm okay with saying <code>top</code> instead of <code>topological</code></p>",
        "id": 134321783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537462664
    },
    {
        "content": "<p>exactly because you want to stack adjectives like this</p>",
        "id": 134321834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537462687
    },
    {
        "content": "<p>What about my question?</p>",
        "id": 134324250,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537465147
    },
    {
        "content": "<p>I hate to answer a question like that with yes, but yes</p>",
        "id": 134325399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537466200
    },
    {
        "content": "<p>then again, I think <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> had a part in the original formulation so maybe he should say something here</p>",
        "id": 134325445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537466243
    },
    {
        "content": "<blockquote>\n<p>I hate to answer a question like that with yes, but yes</p>\n</blockquote>\n<p>What would you prefer?</p>",
        "id": 134325826,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537466555
    },
    {
        "content": "<p>what you said: a class <code>top_add_comm_group</code> that extends <code>uniform_space</code> and <code>add_comm_group</code></p>",
        "id": 134326342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537467083
    },
    {
        "content": "<p>I tried various things today, but clearly I'm not doing it right. Recall I defined the Hausdorff completion functor in <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/master/src/for_mathlib/completion.lean\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/master/src/for_mathlib/completion.lean\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/master/src/for_mathlib/completion.lean</a> I also defined a uniform structure on commutative topological groups in <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/master/src/for_mathlib/topological_structures.lean#L109\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/master/src/for_mathlib/topological_structures.lean#L109\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/master/src/for_mathlib/topological_structures.lean#L109</a>, and wanted to get a group completion functor. For this it seems we need closer integration of topological groups and uniform structures. I made a first attempt at <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/e44b49e7bd9f77f59246f725cc38bf879c2af50f/src/for_mathlib/top_groups.lean\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/e44b49e7bd9f77f59246f725cc38bf879c2af50f/src/for_mathlib/top_groups.lean\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/e44b49e7bd9f77f59246f725cc38bf879c2af50f/src/for_mathlib/top_groups.lean</a> There I have an axiom relating a uniform structure and a group structure, but the uniform structure is a parameter. There are only two sorries in that file, and the completion stuff is available right from the beginning, seemingly without diamond issue. However I'd like a way to produce a <code>top_add_comm_group</code> from a topological space structure and a group structure, building the uniform space structure automatically using a version of my previous unbundled work. I don't see how to do that. Then I tried <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/master/src/for_mathlib/top_groups.lean\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/master/src/for_mathlib/top_groups.lean\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/master/src/for_mathlib/top_groups.lean</a> where the only parameter of <code>top_add_comm_group</code> is the carrier type. But then I had to setup much more wrapping around my completion stuff, and <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/master/src/for_mathlib/top_groups.lean#L45\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/master/src/for_mathlib/top_groups.lean#L45\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/master/src/for_mathlib/top_groups.lean#L45</a> completely fails. I really need help from <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span>  or <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> in order to now which attempt (if any) goes in the right direction.</p>",
        "id": 134377971,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537536728
    },
    {
        "content": "<p>I'm taking a look at it</p>",
        "id": 134391084,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537549986
    },
    {
        "content": "<p>Do you need <code>topological_add_group</code> in your definition of <code>top_add_comm_group</code>? Shouldn't <code>topological_add_group</code> be derived from <code>unif_group</code>?</p>",
        "id": 134432236,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537613280
    },
    {
        "content": "<p>You're probably right</p>",
        "id": 134434646,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537616642
    },
    {
        "content": "<p>I forked your repo: <a href=\"https://github.com/johoelzl/lean-perfectoid-spaces\" target=\"_blank\" title=\"https://github.com/johoelzl/lean-perfectoid-spaces\">https://github.com/johoelzl/lean-perfectoid-spaces</a></p>",
        "id": 134434933,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537617210
    },
    {
        "content": "<p>So in <code>top_groups</code> you need to prove that the group is a group, and then that the uniformity fits</p>",
        "id": 134434980,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537617253
    },
    {
        "content": "<p>first we need to show that <code>-</code> and <code>+</code> are (uniform) continuous, and reduce to <code>-</code>, <code>+</code> on <code>G</code> under <code>to_completion</code>. Then we can proof the group properties by the embedding along <code>to_completion</code>.</p>",
        "id": 134435010,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537617345
    },
    {
        "content": "<p>is this what you expected or do you want something different?</p>",
        "id": 134435042,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537617363
    },
    {
        "content": "<p>I want to be able to manipulate topological groups and their completions. The mathematical story is extremely clear, and I already formalized large parts of it, but they don't want to fit together. Have you seen my two recent attempts? There are successive commits. The older attempts are in neighboring files. Would you like me to LaTeX the math story?</p>",
        "id": 134435676,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537618782
    },
    {
        "content": "<p>I think LaTeX is not yet necessary. But what kind of manipulations do you want to make?</p>",
        "id": 134435734,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537618887
    },
    {
        "content": "<p>The same thing we want from the beginning: a completion functor, left adjoint to the inclusion of complete hausdorff group into all topological groups. That's all!</p>",
        "id": 134435834,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537619094
    },
    {
        "content": "<p>We do have it for uniform space, in my <code>completion.lean</code></p>",
        "id": 134435843,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537619109
    },
    {
        "content": "<p>hm, this is a little bit too far for me. but you are currently stuck in proving that the completion of a topological group (with the induced uniformity) is again a group. This is what I see in <code>top_groups</code>. is this correct?</p>",
        "id": 134435897,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537619168
    },
    {
        "content": "<p>or did you just <code>sorry</code> this part, because you wanted to see how this way works for later proofs?</p>",
        "id": 134435910,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537619224
    },
    {
        "content": "<p>The key fact is we start with a completion which is a universal solution to the problem of factoring maps into complete hausdorff spaces:</p>\n<ul>\n<li><a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L51\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L51\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L51</a></li>\n<li><a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L132\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L132\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L132</a></li>\n<li><a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L157\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L157\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L157</a></li>\n<li><a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L171\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L171\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L171</a><br>\nThen the action of the completion functor on maps comes for free: <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L144\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L144\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L144</a></li>\n</ul>\n<p>When moving to topological groups, we want all those maps to be group morphisms. It looks like extending operation by continuity and running the same abstract non-sense will do it without any work. But when you think about how to prove that <code>completion.map f</code> is a group morphisms you see you need commutation of the two constructions (from top group to uniform space and from uniform space to completion)</p>",
        "id": 134436031,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537619414
    },
    {
        "content": "<p>so what I propose is:</p>\n<ul>\n<li>we get obviously that <code>group_completion G</code> is a complete, separated uniformity (and everything we know about them). This is a couple of instances.</li>\n<li>then we proof that it is a <code>group</code>. This requires some work, we need to lift the group operations and show that they are uniform and invariant under coerion</li>\n</ul>",
        "id": 134436032,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537619418
    },
    {
        "content": "<p>I did all that in my first attempt in <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean</a></p>",
        "id": 134436086,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537619530
    },
    {
        "content": "<p>But then the last instance fail completely because of the diamond issue, and even sorrying an equality of uniform structures didn't help because I couldn't manage rewriting instances</p>",
        "id": 134436096,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537619606
    },
    {
        "content": "<p>I'm sorry I need to take care of my family. But in any case I don't think this problem can be solved without investing some time into reading my various attempts</p>",
        "id": 134436140,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537619672
    },
    {
        "content": "<p>Thank you very much for trying to help me</p>",
        "id": 134436141,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537619690
    },
    {
        "content": "<p>I am of course actively interested in making all this work so let me know if I can help somehow.</p>",
        "id": 134436154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537619745
    },
    {
        "content": "<p>So it turns out that <code>top_add_comm_group</code> is equivalent to <code>uniform_add_group</code>. From <code>uniform_add_group</code> we can derive <code>uniformity = comap (λx:α×α, x.2 - x.1) (nhds (0:α))</code>.</p>\n<p>so the only complicated lift is the group structure itself</p>",
        "id": 134446757,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537639668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> I see you made some progress in your fork. Are you still working on this? Or do you think I should try to copy your work and try to proceed?</p>",
        "id": 134515389,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537781275
    },
    {
        "content": "<p>I didn't continue on this yet. But I want to continue today</p>",
        "id": 134515432,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537781304
    },
    {
        "content": "<p>In particular, does it mean you think that the definition of <code>top_add_comm_group</code> is the correct starting point, and wrapping the completion stuff in <code>group_completion</code> is the right thing to do?</p>",
        "id": 134515457,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537781374
    },
    {
        "content": "<p>Ok, great. I'll wait and see then</p>",
        "id": 134515513,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537781423
    },
    {
        "content": "<p>But I think I will take a look again at your <code>completion</code> branch in <code>leanprover-community</code>.</p>",
        "id": 134515522,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537781453
    },
    {
        "content": "<p>I think <code>top_add_comm_group</code> is not necessary. I think <code>uniform_add_group</code> can also be used instead of it.</p>",
        "id": 134515619,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537781587
    },
    {
        "content": "<p>But if you want you can finish the proofs in <code>top_groups.lean</code>. In the meantime I look at your <code>completion</code> branch and try to bring it up to current <code>mathlib</code> and see how I want to merge it. What do you think about this?</p>",
        "id": 134515669,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537781643
    },
    {
        "content": "<p>I still don't understand what is <code>uniform_add_group</code> This notion doesn't exist in real world maths, and it seems equivalent to topological groups, at least in the communtative case. What's the point?</p>",
        "id": 134515861,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537781907
    },
    {
        "content": "<p>The difference is just that <code>topological_add_group</code> doesn't know about its uniformity. So I called the type class which requires the uniformity <code>uniform_add_group</code>. We can change <code>topological_add_group</code> to require an uniform space, and change the axiom to assume that <code>-</code> is uniformly continuous.</p>",
        "id": 134516035,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537782225
    },
    {
        "content": "<p>The difference to <code>top_add_comm_group</code> will be that <code>topological_add_group</code> is still unbundled.</p>",
        "id": 134516077,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537782253
    },
    {
        "content": "<p>I don't understand. What is unbundled?</p>",
        "id": 134516170,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537782409
    },
    {
        "content": "<p>Okay, <strong>bundled</strong> is not the right word in this context. What I mean is that <code>topological_add_group</code> has the topology and the group structure as <strong>parameter</strong>. <code>top_add_group</code> has it as the uniformity and its group as fields in its structure.</p>",
        "id": 134516284,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537782553
    },
    {
        "content": "<p>I'm sorry this conversation is not smoother, but my youngest daughter is sick, and I have to take care of her</p>",
        "id": 134516888,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537783409
    },
    {
        "content": "<p>The point of the \"bundled\" version was to try to make sure the work of proving the uniform structure compatibility in group completions would be hidden in the instance building, and would never be an issue afterwards</p>",
        "id": 134516966,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537783523
    },
    {
        "content": "<p>But of course this version needs a constructor which only takes group law axioms, a topology and a bunch of continuity proofs, in the same way as a metric space can be constructed from a distance without providing a uniformity</p>",
        "id": 134517026,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537783584
    },
    {
        "content": "<p>I will see how much of the actual construction can be hidden. Also, note that I will rebase your <code>completions</code> branch in <code>leanprover-community</code> after lunch. I hope you don't have any local changes</p>",
        "id": 134517460,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537784105
    },
    {
        "content": "<p>It's a bit of a mess that this work is somewhat split between this mathlib branch and the prefectoid repository, but I think the only substantial difference is the new <code>top_groups.lean</code> in the perfectoid repository, so you can work on the community mathlib branch</p>",
        "id": 134517551,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537784215
    },
    {
        "content": "<p>I worked a bit, see <a href=\"https://github.com/johoelzl/lean-perfectoid-spaces/compare/master...PatrickMassot:master\" target=\"_blank\" title=\"https://github.com/johoelzl/lean-perfectoid-spaces/compare/master...PatrickMassot:master\">https://github.com/johoelzl/lean-perfectoid-spaces/compare/master...PatrickMassot:master</a> I unsorried the <code>add_comm_group</code> structure by porting my previous work. Hopefully this could save you some time. This required adding a couple of lemmas first. I tried to follow the mathlib convention in naming <code>group_completion.continuous_add</code> and <code>group_completion.continuous_add'</code> but I noticed you didn't. Also, I shortened the name since it's all in the <code>group_completion</code> namespace, but since the purely topological <code>continuous_add</code> is in root namespace, it's a but of a mess. Hopefully all this will be much simpler in the end</p>",
        "id": 134522077,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537790889
    },
    {
        "content": "<p>Thanks! I'm currently reorganizing <code>uniform_space.lean</code> and move the separated quotient type and <code>Cauchy</code> to <code>completions.lean</code>.</p>",
        "id": 134522483,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537791515
    },
    {
        "content": "<p>Great!</p>",
        "id": 134522579,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537791663
    },
    {
        "content": "<p>I'm very excited and grateful to get some help here</p>",
        "id": 134522595,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537791702
    },
    {
        "content": "<p>Also note that the proofs in <a href=\"https://github.com/johoelzl/lean-perfectoid-spaces/blob/fa721c6aa863c79b22ce463358c2b616c413e38c/src/for_mathlib/top_groups.lean#L194\" target=\"_blank\" title=\"https://github.com/johoelzl/lean-perfectoid-spaces/blob/fa721c6aa863c79b22ce463358c2b616c413e38c/src/for_mathlib/top_groups.lean#L194\">https://github.com/johoelzl/lean-perfectoid-spaces/blob/fa721c6aa863c79b22ce463358c2b616c413e38c/src/for_mathlib/top_groups.lean#L194</a> are not as abstract as we'd like them to be. Ideally they would all follow from things like <a href=\"https://github.com/leanprover-community/mathlib/blob/a5da4d5acccc9910d921cfadb2c8e4cce59e1d80/analysis/topology/completion.lean#L726\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/a5da4d5acccc9910d921cfadb2c8e4cce59e1d80/analysis/topology/completion.lean#L726\">https://github.com/leanprover-community/mathlib/blob/a5da4d5acccc9910d921cfadb2c8e4cce59e1d80/analysis/topology/completion.lean#L726</a>. So all topological argument would ultimately be in <a href=\"https://github.com/leanprover-community/mathlib/blob/a5da4d5acccc9910d921cfadb2c8e4cce59e1d80/analysis/topology/completion.lean#L552\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/a5da4d5acccc9910d921cfadb2c8e4cce59e1d80/analysis/topology/completion.lean#L552\">https://github.com/leanprover-community/mathlib/blob/a5da4d5acccc9910d921cfadb2c8e4cce59e1d80/analysis/topology/completion.lean#L552</a>, as they should be. But the trouble is that group axioms in mathlib are stated as equalities between elements, instead of functions. So a lot of packing and unpacking would be required. I hesitated to setup all this, with a new group structure constructor inspired by <a href=\"https://en.wikipedia.org/wiki/Universal_algebra\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Universal_algebra\">universal algebra</a> but I preferred to move on.</p>",
        "id": 134524646,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537794172
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I moved now most of the completion stiff to its own lean theory <code>analysis.topology.completion</code>. I added the group completion instances to the <code>completion</code> type itself. I guess this makes sense.<br>\nthe only thing missing is a nice setup for topological groups, where one only needs to define the zero nighbourhood and get a topological group, or where one proofs that we have a topological group and get the uniformity. This is currently in <code>analysis/topology/topological_groups</code> but needs to be restructured.</p>",
        "id": 134615079,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537898016
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> It all looks nice, except that I still don't know what we are talking about. What is this theory of <code>uniform_add_group</code>? Is this meant to be only an intermediate definition? Is the missing piece the piece were you make connection with topological groups as they are defined in math books?</p>",
        "id": 134619925,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537902313
    },
    {
        "content": "<p>Also, I'm confused about when the diamond problem will return to hit us. The fact that the group uniform structure on the completion of a group is the completion of the group uniform structure is a non-empty mathematical content. In my approach it seemed necessary in order to get a functorial group completion. Where will this be needed in your way of building the theory?</p>",
        "id": 134620301,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537902630
    },
    {
        "content": "<p><code>uniform_add_group</code> is a technical device. I don't want to force each appearance of a topological group to be a uniform space. That's why it is split into a <code>topological_add_group</code> (topology + group) and <code>uniform_add_group</code> (uniformity + group). We know also that we can derive a canonical uniform space for a topological group, but this is not setup as a type class instance.</p>",
        "id": 134620397,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537902725
    },
    {
        "content": "<p>What is exactly the diamond? We have <code>add_group (completion A)</code> and <code>uniform_space (completion A)</code>. Both have currently only one way to construct them. What are the alternatives?</p>",
        "id": 134620466,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537902808
    },
    {
        "content": "<p><code>topological_add_group.to_uniform_space (completion A) = completion (topological_add_group.to_uniform_space A)</code></p>",
        "id": 134620573,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537902871
    },
    {
        "content": "<p>That's a non-empty mathematical result</p>",
        "id": 134620584,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537902891
    },
    {
        "content": "<p>but <code>topological_add_group.to_uniform_space</code> is currently not in our type class hierarchy</p>",
        "id": 134620608,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537902915
    },
    {
        "content": "<p>I don't understand why this theorem can be avoided while constructing the completion functor for commutative topological groups</p>",
        "id": 134620712,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537902975
    },
    {
        "content": "<p>It's independent of the discussion of have instances or def</p>",
        "id": 134620730,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537902993
    },
    {
        "content": "<p>With <code>uniformity_eq_comap_nhds_zero</code> (<a href=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/topological_structures.lean#L276\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/topological_structures.lean#L276\">https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/topological_structures.lean#L276</a>) it should be easy to prove this. In the one direction this is how we define the uniformity, in the other direction we have a <code>uniform_add_group</code> and can use <code>uniformity_eq_comap_nhds_zero</code>.</p>\n<p>But maybe I misunderstand the problem. I will try to prove this diamond tomorrow.</p>",
        "id": 134621075,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537903282
    },
    {
        "content": "<p>Ok, thank you very much. I would really love to see the finished thing (including the link with topological groups). I hope I'll be able to learn something from this, since I spend quite a lot of time thinking about more naive (ie. straight from maths books) approaches</p>",
        "id": 134621323,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537903510
    },
    {
        "content": "<p>Indeed <code>uniformity_eq_comap_nhds_zero</code> looks like a characterization of the uniform structure that could be very important. The first step of the proof looks like it has nothing to do with groups:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">johannes_lemma</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"bp\">×</span><span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">},</span>\n  <span class=\"n\">uniform_continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"bp\">×</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniformity</span> <span class=\"n\">α</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sets</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">u</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniformity</span> <span class=\"n\">α</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"o\">,</span> <span class=\"bp\">∀</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">uniform_continuous</span><span class=\"o\">,</span> <span class=\"n\">uniformity_prod_eq_prod</span><span class=\"o\">,</span> <span class=\"n\">tendsto_map&#39;_iff</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"err\">∘</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">mem_map_sets_iff</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">hs</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">clear</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">mem_prod_iff</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">ht</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">huvt</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">clear</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">hts</span> <span class=\"err\">$</span> <span class=\"o\">(</span><span class=\"n\">mem_image</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">⟨⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"bp\">⟩⟩</span><span class=\"o\">,</span> <span class=\"n\">huvt</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"bp\">_⟩⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">refl_mem_uniformity</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I don't know what would be a better mathlib name.</p>",
        "id": 134625736,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537907090
    },
    {
        "content": "<p>Better statement:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">johannes_lemma</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">},</span>\n  <span class=\"n\">uniform_continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniformity</span> <span class=\"n\">β</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sets</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">u</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniformity</span> <span class=\"n\">α</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"o\">,</span> <span class=\"bp\">∀</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 134625920,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537907310
    },
    {
        "content": "<p>And I don't change any character from the proof! I love that. Usually when we wrote in real world math: \"the same proof shows that...\" it's a polite lie</p>",
        "id": 134625951,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537907354
    },
    {
        "content": "<p>Of course we can also write this as:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">johannes_lemma</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n<span class=\"o\">:</span> <span class=\"n\">uniform_continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)},</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniformity</span> <span class=\"n\">β</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sets</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">u</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniformity</span> <span class=\"n\">α</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"o\">,</span> <span class=\"bp\">∀</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">s</span>\n</pre></div>\n\n\n<p>Isn't it an <code>iff</code> then?</p>",
        "id": 134626147,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537907574
    },
    {
        "content": "<p>I'm trying to process the \"better statement\". Is it essentially saying that if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>×</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f : A \\times A \\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mrel\">:</span><span class=\"mord mathit\">A</span><span class=\"mbin\">×</span><span class=\"mord mathit\">A</span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is uniformly continuous, then so is <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>c</mi><mo>)</mo><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f(-, c) : A \\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">c</span><span class=\"mclose\">)</span><span class=\"mrel\">:</span><span class=\"mord mathit\">A</span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> for any <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">c \\in A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"base\"><span class=\"mord mathit\">c</span><span class=\"mrel\">∈</span><span class=\"mord mathit\">A</span></span></span></span>?</p>",
        "id": 134626187,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537907638
    },
    {
        "content": "<p>I'm also trying to process it</p>",
        "id": 134626239,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537907663
    },
    {
        "content": "<p>But I don't think it means what you wrote</p>",
        "id": 134626262,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537907684
    },
    {
        "content": "<p>but you may be right</p>",
        "id": 134626280,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537907701
    },
    {
        "content": "<p>Oh no I am not right.</p>",
        "id": 134626303,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537907731
    },
    {
        "content": "<p>I see. I had the quantifier involving <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">c</span></span></span></span> in the wrong place.</p>",
        "id": 134626314,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537907748
    },
    {
        "content": "<p>Yeah, it's a tricky statement</p>",
        "id": 134626333,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537907764
    },
    {
        "content": "<p>Still there is an asymmetry between the two A factors, so it's probably not an iff</p>",
        "id": 134626410,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537907829
    },
    {
        "content": "<p>Anyway, this lemma, in its latest version allows to reduce the crucial proof to:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">uniformity_eq_comap_nhds_zero</span> <span class=\"o\">:</span> <span class=\"n\">uniformity</span> <span class=\"bp\">=</span> <span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"bp\">×</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nhds_eq_comap_uniformity</span><span class=\"o\">,</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">comap_comap_comp</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">map_le_iff_le_comap</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">;</span> <span class=\"n\">intros</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">johannes_lemma</span> <span class=\"n\">uniform_continuous_sub&#39;</span> <span class=\"n\">hs</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">mem_map</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">mem_sets_of_superset</span> <span class=\"n\">ht</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">rintros</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">subset_def</span><span class=\"o\">]</span> <span class=\"kn\">using</span> <span class=\"n\">hts</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">johannes_lemma</span> <span class=\"n\">uniform_continuous_add&#39;</span> <span class=\"n\">hs</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">rintros</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">subset_def</span><span class=\"o\">]</span> <span class=\"kn\">using</span> <span class=\"n\">hts</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 134627274,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537908629
    },
    {
        "content": "<p>And I still don't understand the magic trick that seems to have removed the diamond issue (I mean removed from the maths discussion, I'm not even talking about Lean). I guess I'll see it when everything will be in place.</p>",
        "id": 134627304,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537908689
    },
    {
        "content": "<p>I also don't understand at all <a href=\"https://github.com/leanprover-community/mathlib/commit/85b19e23d45f14a210d0b7491c66477d0c560c9a\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/commit/85b19e23d45f14a210d0b7491c66477d0c560c9a\">https://github.com/leanprover-community/mathlib/commit/85b19e23d45f14a210d0b7491c66477d0c560c9a</a> Why did you remove all this? It contains a lot of maths that don't appear anywhere else</p>",
        "id": 134627409,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537908808
    },
    {
        "content": "<p>Urgs, I removed the wrong file.</p>",
        "id": 134652519,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537947660
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> Did you try to go from <code>topological_add_group</code> to the completion and still get everything?</p>",
        "id": 134697940,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537990749
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 134698069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537990899
    },
    {
        "content": "<p>Mario did you just respond to a question asked on the wrong topic with an answer posted on the wrong stream</p>",
        "id": 134698176,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537991009
    },
    {
        "content": "<p>yes. yes I did.</p>",
        "id": 134698232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537991045
    },
    {
        "content": "<p>This topic was only distantly related to separation stuff anyway</p>",
        "id": 134698240,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537991055
    },
    {
        "content": "<p>Somehow, deep down, I guess we miss Gitter's mess</p>",
        "id": 134698271,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537991098
    },
    {
        "content": "<p>The stuff about group topologies generated from a neighborhood filter around zero will probably be very convenient for the perfectoid project, which  uses adic topology</p>",
        "id": 134698719,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537991530
    },
    {
        "content": "<p>I didn't work yet on the diamond, I got side tracked by the topological space construction</p>",
        "id": 134699310,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537992056
    },
    {
        "content": "<p>Ok, I understand.</p>",
        "id": 134699347,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537992101
    },
    {
        "content": "<p>I added now <code>topological_add_comm_group.to_uniform_space_eq</code>. It doesn't look to be directly a diamond. The reason is the following:<br>\nFor <code>completion α</code> to be a group, we already need to know that <code>α</code> has a uniform space, and that the group structure is compatible with this uniformity (i.e. <code>uniform_add_group</code>).</p>\n<p>A diamond would mean we have <code>group_to_uniform ∘ completion = completion ∘group_to_uniform</code>. But <code>completion</code> doesn't work on groups without the uniformity. So we actually have <code>group_to_uniform ∘ completion ∘group_to_uniform = completion ∘group_to_uniform</code>. Now it is enough to prove <code>group_to_uniform ∘ G = G</code>, where <code>G</code> is already a group with compatible uniformity.</p>",
        "id": 134731658,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538038735
    }
]
[
    {
        "content": "<p>Here's a message I just posted to the <a href=\"https://groups.google.com/forum/#!forum/homotopytypetheory\" target=\"_blank\" title=\"https://groups.google.com/forum/#!forum/homotopytypetheory\">homotopy type theory google group forum</a>:</p>\n<blockquote>\n<p>Hi from a Lean user.</p>\n<p>As many people here will know, Tom Hales' formal abstracts project <a href=\"https://formalabstracts.github.io/\" target=\"_blank\" title=\"https://formalabstracts.github.io/\">https://formalabstracts.github.io/</a> wants to formalise many of the statements of modern pure mathematics in Lean. One could ask more generally about a project of formalising many of the statements of modern pure mathematics in an arbitrary system, such as HoTT. I know enough about the formalisation process to know that whatever system one chooses, there will be pain points, because some mathematical ideas fit more readily into some foundational systems than others.</p>\n<p>I have seen enough of Lean to become convinced that the pain points would be surmountable in Lean. I have seen enough of Isabelle/HOL to become skeptical about the idea that it would be suitable for all of modern pure mathematics, although it is clearly suitable for some of it; however it seems that simple type theory struggles to handle things like tensor products of sheaves of modules on a scheme, because sheaves are dependent types and it seems that one cannot use Isabelle's typeclass system to handle the rings showing up in a sheaf of rings.</p>\n<p>I have very little experience with HoTT. I have heard that the fact that \"all constructions must be isomorphism-invariant\" is both a blessing and a curse. However I would like to know more details. I am speaking at the Big Proof conference in Edinburgh this coming Wednesday on the pain points involved with formalising mathematical objects in dependent type theory and during the preparation of my talk I began to wonder what the analogous picture was with HoTT.</p>\n<p>Everyone will have a different interpretation of \"modern pure mathematics\" so to fix our ideas, let me say that for the purposes of this discussion, \"modern pure mathematics\" means the statements of the theorems publishsed by the Annals of Mathematics over the last few years, so for example I am talking about formalising statements of theorems involving L-functions of abelian varieties over number fields, Hodge theory, cohomology of algebraic varieties, Hecke algebras of symmetric groups, Ricci flow and the like; one can see titles and more at <a href=\"http://annals.math.princeton.edu/2019/189-3\" target=\"_blank\" title=\"http://annals.math.princeton.edu/2019/189-3\">http://annals.math.princeton.edu/2019/189-3</a> . Classical logic and the axiom of choice are absolutely essential -- I am only interested in the hard-core \"classical mathematician\" stance of the way mathematics works, and what it is.</p>\n<p>If this is not the right forum for this question, I would be happily directed to somewhere more suitable. After spending 10 minutes failing to get onto ##hott on freenode (\"you need to be identified with services\") I decided it was easier just to ask here. If people want to chat directly I am usually around at <a href=\"\" target=\"_blank\" title=\"\">https://leanprover.zulipchat.com/</a> (registration required, full names are usually used, I'll start a HoTT thread in #mathematics).</p>\n<p>Kevin Buzzard</p>\n</blockquote>\n<p>Does anyone here have enough experience with HoTT to say anything? I've asked here questions like \"what would the pain points be if one tried to formalise a scheme in HoTT?\" and have got answers of the form \"if you want to find out, you should go ahead and try\". I'm not sure I have time to learn another system though. I have even dumber questions -- how would one define the trace of a linear map from a finite-dimensional vector space to itself? A mathematician would pick a basis, compute the trace of the corresponding matrix, and then note that it was independent of the choice. Is this problematic in HoTT?</p>",
        "id": 166520970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558779439
    },
    {
        "content": "<p>I suppose it will depend on exactly how you define \"finite-dimensional vector space\". If it's defined as a vector space together with <code>trunc</code> of a basis, then the procedure for defining the trace of a map goes exactly how you describe.</p>",
        "id": 166521201,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558779906
    },
    {
        "content": "<p><code>trunc</code> is called the \"propositional truncation\" in HoTT although \"proposition\" there more closely corresponds to what Lean calls <code>subsingleton</code></p>",
        "id": 166521275,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558780075
    },
    {
        "content": "<p>In particular, this definition is constructive. However you would probably need the axiom of choice to prove that a quotient of a finite dimensional vector space is again finite dimensional.</p>",
        "id": 166521523,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558780510
    },
    {
        "content": "<p>Or maybe LEM is enough, but that's still an uncomputable axiom</p>",
        "id": 166521718,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558780887
    },
    {
        "content": "<p>I haven't actually used a HoTT-based theorem prover yet, only read the book. I do find it difficult to get a sense of how HoTT+choice would work in practice. I think this is a cultural phenomenon: there tends to be overlap between people interested in HoTT and people interested in constructive logic. (Consider that the same could be said about Coq, yet Lean is based on essentially the same underlying type theory and look where we are now.)</p>",
        "id": 166522080,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558781540
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Does the construction of the Serre SS use any axioms?</p>",
        "id": 166522337,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558782078
    },
    {
        "content": "<p>Kevin, I wouldn't be surprised if in fact nobody has done anything resembling what you're asking about.</p>",
        "id": 166522344,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558782119
    },
    {
        "content": "<p>In the areas that require classical logic/choice, I mean.</p>",
        "id": 166522401,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558782208
    },
    {
        "content": "<p>I think UniMath is trying to build a general mathematical library on a HoTT foundation</p>",
        "id": 166522651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558782655
    },
    {
        "content": "<p>I think it slowed down when Voevodsky died though</p>",
        "id": 166522664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558782685
    },
    {
        "content": "<p>What am I asking about? Doing fabstracts in hott or making schemes in hott? I am currently thinking about undergraduate maths. Say V and W are finite dimensional vector spaces over an arbitrary field, defined however you like, and we have a linear map from V to W. Say X is the kernel. Say I have a linear map from X to X. Can I define its trace in HoTT?</p>",
        "id": 166522666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558782691
    },
    {
        "content": "<p>So unimath is to mathlib as hott is to lean?</p>",
        "id": 166522670,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558782717
    },
    {
        "content": "<p>I think so, I'm no expert though</p>",
        "id": 166522716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558782744
    },
    {
        "content": "<p>Then where is the analogue of me who tried to do completely dumb simple maths things in HoTT?</p>",
        "id": 166522739,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558782820
    },
    {
        "content": "<p>I certainly wouldn't be able to answer that</p>",
        "id": 166522797,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558782857
    },
    {
        "content": "<p>I'm sure there are such people in the community but I'm not enough a part of it to say</p>",
        "id": 166522799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558782873
    },
    {
        "content": "<p>Can it be done and how far did they get? Where are the pain points? Who should I ask?</p>",
        "id": 166522801,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558782878
    },
    {
        "content": "<p>I guess the UniMath foundation?</p>",
        "id": 166522805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558782901
    },
    {
        "content": "<p>Hopefully someone will respond to my post on the mailing list</p>",
        "id": 166522814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558782906
    },
    {
        "content": "<p>Thanks, I'll try them</p>",
        "id": 166522819,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558782916
    },
    {
        "content": "<p>Part of the problem is that the HoTT world is very fragmented, so no individual project has very many people working on it</p>",
        "id": 166522873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558782971
    },
    {
        "content": "<p>which I might argue is one of the downsides of DTT, strangely enough</p>",
        "id": 166522878,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558783006
    },
    {
        "content": "<p>The HoTT people really embrace the D in DTT, and when you work like that the exact details of definitional equality matter a lot; but there is not a uniform conception of what it should be, so you end up with a bunch of incompatible axiomatizations</p>",
        "id": 166522897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558783070
    },
    {
        "content": "<p>Does unimath work only with constructive maths??</p>",
        "id": 166522948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558783115
    },
    {
        "content": "<p>No such system will ever catch on with mathematicians</p>",
        "id": 166522952,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558783128
    },
    {
        "content": "<blockquote>\n<p>The axioms accepted are: the univalence axiom, the law of excluded middle, the axiom of choice, and a few new variants of the axiom of choice, validated by the semantic model.</p>\n</blockquote>",
        "id": 166522972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558783188
    },
    {
        "content": "<p>I am continually weirded out by the fact that Leo simultaneously seems completely uninterested in mathematics and yet seems to have made the system which is most suitable for general pure mathematicians</p>",
        "id": 166522973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558783194
    },
    {
        "content": "<p>Ok great I'll ask the univalent people if they can define the trace of a linear map and a scheme</p>",
        "id": 166523021,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558783240
    },
    {
        "content": "<p>I heard about it from Daniel Grayson, who is the lead developer; you could ask him for a summary</p>",
        "id": 166523036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558783297
    },
    {
        "content": "<p>Oh I know Dan from my sci.math.research days</p>",
        "id": 166523044,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558783321
    },
    {
        "content": "<p>the readme at <a href=\"https://github.com/UniMath/UniMath/tree/master/UniMath\" target=\"_blank\" title=\"https://github.com/UniMath/UniMath/tree/master/UniMath\">https://github.com/UniMath/UniMath/tree/master/UniMath</a> has a bunch of useful general info</p>",
        "id": 166523091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558783334
    },
    {
        "content": "<blockquote>\n<p>What am I asking about? Doing fabstracts in hott or making schemes in hott? I am currently thinking about undergraduate maths. Say V and W are finite dimensional vector spaces over an arbitrary field, defined however you like, and we have a linear map from V to W. Say X is the kernel. Say I have a linear map from X to X. Can I define its trace in HoTT?</p>\n</blockquote>\n<p>I mean formalizing even relatively basic constructions like this one that (apparently) require choice.<br>\nI'm pretty sure that this is possible in HoTT (plus choice). In either HoTT or Lean you must first prove that X is finite dimensional (has a finite basis); that part will go the same way. In HoTT you will also need to prove that the trace is independent of the choice of basis, which is not a bad thing.</p>",
        "id": 166523260,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558783628
    },
    {
        "content": "<p>In HoTT if I define what it means for a ring to be local, would I have to prove that a ring isomorphic to a local ring is local before I can even make the definition?</p>",
        "id": 166524854,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558786539
    },
    {
        "content": "<p>No, you'd define it the same way as in Lean</p>",
        "id": 166525101,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558786940
    },
    {
        "content": "<p>I think even stupid thing like this are isomorphism invariant in HoTT.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">=</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">h</span> <span class=\"mi\">37</span>\n</pre></div>",
        "id": 166525291,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1558787323
    },
    {
        "content": "<p>I think a first approximation to how choice works in HoTT, expressed in the language of Lean, is that one can no longer have <code>choice : nonempty X -&gt; X</code>, but one still has</p>\n<ul>\n<li><code>unique_choice : nonempty X -&gt; trunc X</code>, which means that you can extract a witness for an existential to construct something provided you can prove the result doesn't depend on the choice of witness, and</li>\n<li><code>axiom_of_choice : (∀ x, ∃ y, r x y) -&gt; ∃ f, ∀ x, r x (f x)</code></li>\n</ul>",
        "id": 166525302,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558787388
    },
    {
        "content": "<p>What's the difference between <code>nonempty</code> and <code>trunc</code> in HoTT?</p>",
        "id": 166525353,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1558787427
    },
    {
        "content": "<p>There isn't one (at least in book HoTT) because HoTT has no notion of judgmentally being a proposition.</p>",
        "id": 166525366,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558787466
    },
    {
        "content": "<p>So unique choice is <code>id</code>?</p>",
        "id": 166525373,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1558787503
    },
    {
        "content": "<p>So the result is that places where we would use an ∃ in Lean correspond to <code>|| ∃ ... ||</code> in HoTT</p>",
        "id": 166525374,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558787514
    },
    {
        "content": "<p>or let's say <code>|| Σ ... ||</code> to be more clear</p>",
        "id": 166525419,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558787557
    },
    {
        "content": "<p>where <code>|| ... ||</code> is the propositional truncation (Lean <code>trunc</code>)</p>",
        "id": 166525435,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558787589
    },
    {
        "content": "<p>Right, so unique choice doesn't really correspond to anything in HoTT but I tried to give a translation into a Lean worldview.</p>",
        "id": 166525484,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558787658
    },
    {
        "content": "<p>Actually the HoTT book does have something it calls \"unique choice\", which is the statement that if P is a Prop (Lean: <code>subsingleton P</code>) then P is equivalent to ||P||.</p>",
        "id": 166525501,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558787722
    },
    {
        "content": "<p>But it's a theorem</p>",
        "id": 166525503,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558787729
    },
    {
        "content": "<p>Is UniMath written in book HoTT?</p>",
        "id": 166526168,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558788805
    },
    {
        "content": "<p>\"Close enough\"</p>",
        "id": 166526726,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558789694
    },
    {
        "content": "<p>It seems to be book HoTT minus some features like inductive types</p>",
        "id": 166526753,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558789785
    },
    {
        "content": "<p>So given a tool like Coq or Lean, you can either use it as God intended, as it were, or you can start adding additional rules of the form \"you can use this axiom\" and \"you can't use this command\"</p>",
        "id": 166526835,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558789893
    },
    {
        "content": "<p>This then surely makes for a more inefficient system, as the way it is designed is somehow slightly in conflict with the way it is being used.</p>",
        "id": 166526884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558789928
    },
    {
        "content": "<p>Here's my two cents:<br>\nThe main advantage univalence gives us from a formalization perspective is that it allows for implementation irrelevance. I can build an entire library of the p-adics using the algebraic definition, and if someone in the future needs to use the analytic definition, she can simply transport the statements (and proofs!) proven using the first definitions onto the second.</p>",
        "id": 166527727,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1558791385
    },
    {
        "content": "<p>However, this requires computable univalence, which is an open problem in book HoTT.</p>",
        "id": 166527791,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1558791519
    },
    {
        "content": "<p>If we do \"fabstracts in HoTT\", then it would mean that we could formalize a single definition for each mathematical statement and that would, by univalence, be akin to formalizing a whole equivalence class of such definitions. (<em>upto homotopy</em>)</p>",
        "id": 166528012,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1558791932
    },
    {
        "content": "<p>Sadly this would require changes to the underlying type theory to one where univalence actually computes, such as cubical type theory.</p>",
        "id": 166528065,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1558792015
    },
    {
        "content": "<blockquote>\n<p>Here's my two cents:<br>\nThe main advantage univalence gives us from a formalization perspective is that it allows for implementation irrelevance. I can build an entire library of the p-adics using the algebraic definition, and if someone in the future needs to use the analytic definition, she can simply transport the statements (and proofs!) proven using the first definitions onto the second.</p>\n</blockquote>\n<p>I don't see any reason why we can't do this in Lean, once those computer scientists have written the <code>transport </code> tactic for us.</p>",
        "id": 166528125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558792138
    },
    {
        "content": "<p>I haven't used <code>transport</code> so I don't know how it works. But I would conjecture that it isn't as powerful as full univalence. (In what sense exactly, I don't know)<br>\nBut people <em>have</em> tried to get Univalent parametricity without changing the type theory: <a href=\"https://hal.inria.fr/hal-01559073\" target=\"_blank\" title=\"https://hal.inria.fr/hal-01559073\">https://hal.inria.fr/hal-01559073</a></p>",
        "id": 166528326,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1558792508
    },
    {
        "content": "<p>I think that untyped set theory is <em>much</em> better at \"implementation invariance\" than dependent type theory, in general</p>",
        "id": 166529423,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558794273
    },
    {
        "content": "<p>In DTT all your definitions can potentially be \"unfolded\" and this might matter for making some terms type correct, if they appear as dependencies in a type</p>",
        "id": 166529448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558794329
    },
    {
        "content": "<p>so you basically can't really hide anything, at least in principle</p>",
        "id": 166529452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558794347
    },
    {
        "content": "<p>Whether <code>transport</code> is as powerful as full univalence is actually an open research question. It's related to whether univalence computes \"propositionally\" in book HoTT</p>",
        "id": 166529518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558794425
    },
    {
        "content": "<p>I still don't really understand how Strickland's idea managed to get the schemes project out of the hole I'd dug it into.</p>",
        "id": 166529972,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558795197
    },
    {
        "content": "<p>I'm late to the party, but here are some of my responses.</p>\n<blockquote>\n<p>Does the construction of the Serre SS use any axioms?</p>\n</blockquote>\n<p>No, only univalence and higher inductive types. In HoTT there is a very strong sense of \"trying to avoid the axiom of choice\". And if you care about that (which mathematicians of course don't), there are some nice new things you can do with HoTT to avoid axioms:</p>\n<ul>\n<li>You can elimination from the propositional truncation (which is like <code>nonempty</code>) to any subsingleton type without using an axiom. In Lean you would use <code>choice</code> for this.</li>\n<li>Normally, if you define the real numbers as Cauchy sequences, you need the (countable) axiom of choice to prove completeness of the real numbers. In HoTT there is a definition of the Cauchy real numbers as a higher inductive type where you can prove completeness without the axiom of choice (you still need choice to prove that it is equivalent to the Dedekind real numbers).</li>\n</ul>\n<p>This is not to say you cannot add the axiom of choice to HoTT and work classically. This is very much possible. However, as Reid mentions you cannot add <code>classical.choice</code> (that is inconsistent with univalence), you need the weaker set-theoretic formulation of choice (e.g. every surjection has a section).</p>",
        "id": 166651904,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1558976833
    },
    {
        "content": "<blockquote>\n<p>what would the pain points be if one tried to formalise a scheme in HoTT?</p>\n</blockquote>\n<p>I think the pain points much more depend on which proof assistant you use, and more importantly: which tactics and automation is available. One example of a pain point when doing HoTT in Lean 2 which are specific to HoTT, is that - for example - I had to prove that the ordering on the natural numbers is a proposition (subsingleton): <a href=\"https://github.com/leanprover/lean2/blob/master/hott/types/nat/hott.hlean#L14\" target=\"_blank\" title=\"https://github.com/leanprover/lean2/blob/master/hott/types/nat/hott.hlean#L14\">https://github.com/leanprover/lean2/blob/master/hott/types/nat/hott.hlean#L14</a></p>\n<div class=\"codehilite\"><pre><span></span>definition is_prop_le [instance] (n m : ℕ) : is_prop (n ≤ m)\n</pre></div>\n\n\n<p>A much bigger pain point is that univalence doesn't compute in Lean 2, so if you want a function you define to compute definitionally (and in Lean 2 we wanted that, partially because of the lack of a good <code>simp</code>), then you want to avoid using univalence. This made me define many many concepts explicitly which I could have defined using univalence.</p>",
        "id": 166652260,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1558977279
    },
    {
        "content": "<p>One mentality problem in HoTT is that everything - even proofs of propositions - are definitions and it sometimes matters how you define/prove them, especially if you use dependent types heavily. For example, if you have a sequence of maps <code>X 0 -&gt; X 1 -&gt; X 2 -&gt; ...</code> then you can define a function <code>n &lt;= m -&gt; X n -&gt; X m</code>. In HoTT you can define this function by recursion on the proof that <code>n &lt;= m</code>, and so how that function computes depends on how you have proven that <code>n &lt;= m</code> (for numerals <code>n</code> and <code>m</code> there is only 1 way to do this, but for variables there could be different ways, of course). At one point, I reproved some inequalities of natural numbers to make this function compute better (and it was important that it computed better because I was using dependent types).</p>",
        "id": 166652496,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1558977600
    },
    {
        "content": "<p>Out of curiosity, does anyone know about how usable cubical type theory is?</p>",
        "id": 166665147,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1558992539
    },
    {
        "content": "<p>What do you mean by usable?</p>\n<ul>\n<li>Usable for doing HoTT? Yes, although most proof assistants implementing univalence are pretty experimental and lack high-level features.</li>\n<li>Usable for computation of univalence? Yes, it can compute univalence. Although with complicated proofs, the computation is inefficient, so you will have to optimize your proof for efficient computation.</li>\n<li>Usable for doing ordinary mathematics? Probably not really.</li>\n</ul>",
        "id": 166666107,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1558993952
    },
    {
        "content": "<p>You mean for the cubing a cube question? ;-)</p>",
        "id": 166670185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558998121
    },
    {
        "content": "<p><a href=\"https://groups.google.com/forum/#!topic/homotopytypetheory/NhIhMd7SM_4\" target=\"_blank\" title=\"https://groups.google.com/forum/#!topic/homotopytypetheory/NhIhMd7SM_4\">https://groups.google.com/forum/#!topic/homotopytypetheory/NhIhMd7SM_4</a></p>\n<p>The discussion on the HoTT mailing list says a bunch of things which many people here knew already; I guess they are slowly but surely dawning on me.</p>",
        "id": 167131772,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559498399
    },
    {
        "content": "<p>It seems that HoTT and UniMath find it very important that everything is constructive and computable. Are their p-adics computable?</p>",
        "id": 167274706,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559640867
    },
    {
        "content": "<p>The p-adics are uncountable so it's not even clear, I think, what this question can mean.</p>",
        "id": 167285889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559650328
    },
    {
        "content": "<p>Their paper says their p-adics are constructive. One way to interpret the computability question is to ask if they can define computable functions on the p-adics. For example, given a closed term of Z_p you might want to compute its norm. As far as I could tell, they don't define any functions beyond the arithmetic ones, computably or noncomputably. And univalence doesn't compute in UniMath. That may or may not show up to block things here, I don't know.</p>",
        "id": 167286716,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1559651082
    },
    {
        "content": "<p>A quote from (page 1 of) <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> 's <a href=\"https://florisvandoorn.com/papers/dissertation.pdf\" target=\"_blank\" title=\"https://florisvandoorn.com/papers/dissertation.pdf\">thesis</a>:</p>\n<blockquote>\n<p>The fact that all constructions are homotopy invariant also leads to some challenges.<br>\nIt is not always clear whether we can define a concept of homotopy theory in homotopy<br>\ntype theory. For example, singular homology is a homotopy invariant notion, but in the<br>\nconstruction we use the set of all simplices in a space, which is not a homotopy invariant<br>\nnotion. In this case, we can define homology in a different way (see Section 5.5).<br>\nHowever, for other definitions, such as the Grassmannian manifolds, it is an open<br>\nproblem whether they can be constructed in homotopy type theory.</p>\n</blockquote>\n<p>Wait--what? Are we just talking about the standard smooth projective varieties of e.g. subspaces of a f.d. vector space? What is the trouble with making them in HoTT?</p>",
        "id": 167670100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560031594
    },
    {
        "content": "<p>The problem is to construct HoTT types whose \"internal homotopy type\" is the homotopy type of a real or complex Grassmannian.<br>\nHere \"internal homotopy type of X\" means, for example, use the interpretation of HoTT in simplicial sets and take the homotopy type of the simplicial set corresponding to X.</p>",
        "id": 167670378,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560032127
    },
    {
        "content": "<p>Of course you can also reinvent the real numbers, classical topology, linear algebra, etc. in HoTT just the same way you would do in Lean and define Grassmannians that way, but there's no known way in book HoTT to relate this classical homotopy theory to the internal homotopy theory.</p>",
        "id": 167670689,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560032690
    },
    {
        "content": "<p>I think there was a discussion about this here before but I can't find it now</p>",
        "id": 167670754,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560032793
    },
    {
        "content": "<p>The penny is slowly dropping. Last summer <span class=\"user-mention\" data-user-id=\"120256\">@Ali Sever</span> developed synthetic 2-dimensional geometry in Lean (following Tarski), where \"point\" and \"line\" are just abstract types and there are relations between them. This is different to \"analytic 2-dimensional geometry\" where you define <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span></span></span></span> and then points are points in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span></span></span></span> and lines are lines in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span></span></span></span>. </p>\n<p>This HoTT is just the same sort of thing isn't it. You're saying we can do it the \"analytic\" way, but this basic interpretation of types as spaces-up-to-homotopy is like the synthetic way of doing it.</p>",
        "id": 167670816,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560032888
    },
    {
        "content": "<p>This is basically explained on p4 of the thesis. \"Synthetic geometry limits the things one can state or prove, but these proofs are applicable in every model of the axioms\". That's all well and good, but what about if you only care about one model?</p>",
        "id": 167670834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560032987
    },
    {
        "content": "<p>So there might be more models of HoTT other than spaces-up-to-homotopy?</p>",
        "id": 167670886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560033021
    },
    {
        "content": "<p>There are definitely multiple models (I know it's not in English, but see the bottom of page 2)</p>",
        "id": 167670894,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560033055
    },
    {
        "content": "<p>Hmm, yeah that doesn't really help :-/</p>",
        "id": 167670910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560033117
    },
    {
        "content": "<p>So is \"spaces up to homotopy\" a \"model\" for HoTT?</p>",
        "id": 167670956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560033138
    },
    {
        "content": "<p>Is \"the simplicial set model\" something like \"simplicial sets up to some sort of simplicial homotopy relation\"?</p>",
        "id": 167670972,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560033191
    },
    {
        "content": "<p>Where can I read about Grothendieck infinity,1 toposes? Assume I know what a Grothendieck topos is.</p>",
        "id": 167670977,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560033239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  this is what people usually refer to when they talk about the \"simplicial set model\" - <a href=\"https://arxiv.org/abs/1211.2851\" target=\"_blank\" title=\"https://arxiv.org/abs/1211.2851\">https://arxiv.org/abs/1211.2851</a></p>",
        "id": 167671150,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1560033506
    },
    {
        "content": "<blockquote>\n<p>Where can I read about Grothendieck infinity,1 toposes? Assume I know what a Grothendieck topos is.</p>\n</blockquote>\n<p>Instead of sheaves of sets on a site, take sheaves of spaces on a site.</p>",
        "id": 167671706,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560034545
    },
    {
        "content": "<p>An (infinity,1)-topos is a particular kind of (infinity,1)-category, which you could model using any choice of models for (infinity,1)-categories, for example, quasicategories as in Jacob's book.</p>",
        "id": 167671759,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560034598
    },
    {
        "content": "<p>Incidentally Lean minus all the axioms can also be interpreted in any Grothendieck topos, so this question about multiple models is sort of orthogonal to the question about HoTT or not.</p>",
        "id": 167671828,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560034685
    },
    {
        "content": "<p>You have to do a pretty large amount of work to get from an (infinity,1)-topos to an interpretation of HoTT though</p>",
        "id": 167671852,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560034798
    },
    {
        "content": "<p>Maybe this is the best thing to say about the spaces model:</p>",
        "id": 167671905,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560034814
    },
    {
        "content": "<p>I only know one Grothendieck topos really, and that's the category of sets :-)</p>",
        "id": 167671908,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560034820
    },
    {
        "content": "<p>We're going to interpret a type as a simplicial set (or more accurately, a Kan complex)</p>",
        "id": 167671912,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560034854
    },
    {
        "content": "<blockquote>\n<p>Instead of sheaves of sets on a site, take sheaves of spaces on a site.</p>\n</blockquote>\n<p>Do I have to invert homotopy equivalences though?</p>",
        "id": 167671925,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560034885
    },
    {
        "content": "<p>and if the interpretation of <code>T</code> is a simplicial set <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, then the interpretation of <code>@eq T a b</code> is the simplicial set of maps <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"normal\">Δ</mi><mn>1</mn></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta^1 \\to X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathrm\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> sending <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.64444em;\"></span><span class=\"strut bottom\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathrm\">0</span></span></span></span> to <code>a</code> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.64444em;\"></span><span class=\"strut bottom\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathrm\">1</span></span></span></span> to <code>b</code></p>",
        "id": 167671972,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560034943
    },
    {
        "content": "<p>Right.</p>",
        "id": 167671974,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560034969
    },
    {
        "content": "<p>Not invert exactly but keep track of them in the higher morphisms, yes.</p>",
        "id": 167671977,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560034979
    },
    {
        "content": "<p>A simplicial version of everything.</p>",
        "id": 167671983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560034983
    },
    {
        "content": "<blockquote>\n<p>Not invert exactly but keep track of them in the higher morphisms, yes.</p>\n</blockquote>\n<p>Aah!</p>",
        "id": 167671989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560034998
    },
    {
        "content": "<p>Is that an \"Aaa\" or an \"Ahh\"</p>",
        "id": 167671991,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035023
    },
    {
        "content": "<p>Oh I see, I am conflating two uses of \"=\".</p>",
        "id": 167671993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035032
    },
    {
        "content": "<p>I shouldn't be thinking of \"X=Y\" as meaning \"X looks exactly the same as Y\"</p>",
        "id": 167672040,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035065
    },
    {
        "content": "<p>Of course I should also tell you how to define the rest of the connectives but some of them are easy, for example <code>prod</code> becomes the product and <code>-&gt;</code> becomes the mapping space (let's ignore Pi types for now)</p>",
        "id": 167672043,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035077
    },
    {
        "content": "<p>Pi types are just some fibration or something</p>",
        "id": 167672056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035108
    },
    {
        "content": "<p>oh, in the simplicial world you have to make them</p>",
        "id": 167672059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035146
    },
    {
        "content": "<p>So if I have <code>f, g : X -&gt; Y</code> then a term <code>t : f = g</code> is a map <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"normal\">Δ</mi><mn>1</mn></msup><mo>→</mo><msup><mi>Y</mi><mi>X</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\Delta^1 \\to Y^X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8413309999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathrm\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span><span class=\"mrel\">→</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span></span></span></span></span></span></span></span>--which I can also treat as <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi><mo>×</mo><msup><mi mathvariant=\"normal\">Δ</mi><mn>1</mn></msup><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X \\times \\Delta^1 \\to Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mbin\">×</span><span class=\"mord\"><span class=\"mord mathrm\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, i.e., a simplicial homotopy (since I assumed my spaces were Kan complexes, I can represent every homotopy which should exist this way)</p>",
        "id": 167672061,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035153
    },
    {
        "content": "<p>How do I know that this simplicial model is definitely different to the topological spaces model?</p>",
        "id": 167672111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035212
    },
    {
        "content": "<p>I think there can't really be a topological spaces model for technical reasons but if there was one it should not be different in any meaningful way</p>",
        "id": 167672124,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035264
    },
    {
        "content": "<p>So what did you mean by \"sheaves of spaces\" [on a point]?</p>",
        "id": 167672170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035292
    },
    {
        "content": "<p>so you can just imagine topological spaces instead of simplicial sets, if you prefer</p>",
        "id": 167672171,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035295
    },
    {
        "content": "<p>\"Space\" is a free-for-all word that means simplicial set or topological space or whatever you like that models the homotopy theory of spaces</p>",
        "id": 167672173,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035318
    },
    {
        "content": "<p>clever!</p>",
        "id": 167672175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035327
    },
    {
        "content": "<p>It's sort of analogous to how we don't care what model you pick for a <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>K</mi><mo>(</mo><mi>G</mi><mo separator=\"true\">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">K(G,1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">(</span><span class=\"mord mathit\">G</span><span class=\"mpunct\">,</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span></span></span></span> or whatever, but one level higher</p>",
        "id": 167672237,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035405
    },
    {
        "content": "<p>So HoTT is a way of making the \"basic objects\" Kan complexes. And it feels to me that Lean is a way of making the basic objects into non-intersecting sets. So if you want to do some parts of homotopy theory then HoTT is a really good way to do it because the basic objects are so close to the objects you want to model. But it sounds like a less good way of doing all mathematics, because Lean's types seem to me to be closer to the kind of objects that mathematicians use. Are there people out there who would argue that I am wrong here and I should be thinking of Z/6Z or the p-adic numbers as some sort of space?</p>",
        "id": 167672262,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035478
    },
    {
        "content": "<p>Z/6Z no; of course you already think of the p-adic numbers as some kind of space--it's not the kind of space that HoTT helps you with, but another flavor of type theory might</p>",
        "id": 167672332,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035586
    },
    {
        "content": "<p>or rather than changing your type theory, you could change your model (condensed sets?)</p>",
        "id": 167672340,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035633
    },
    {
        "content": "<p>I definitely don't think of the p-adic numbers as only being defined up to homotopy!</p>",
        "id": 167672382,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035644
    },
    {
        "content": "<blockquote>\n<p>or rather than changing your type theory, you could change your model (condensed sets?)</p>\n</blockquote>\n<p>Do they have anything to do with all this nonsense?</p>",
        "id": 167672388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035672
    },
    {
        "content": "<p>Anyways in HoTT you can always impose a condition that makes a type X into a genuine set: namely <code>isSet X := \\Pi (a b : X) (e f : a = b), e = f</code></p>",
        "id": 167672391,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035676
    },
    {
        "content": "<p>Right. And then I can perhaps prove that some things are sets.</p>",
        "id": 167672395,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035700
    },
    {
        "content": "<p>It seems to me that I have lost the ability to rewrite, and this extra condition is some attempt to put it back again. Hmm. Maybe what I'm saying is that I have lost <code>Prop</code>, and one can attempt to make it again, but I bet in practice it's not as good as my beloved Lean <code>Prop</code>.</p>",
        "id": 167672457,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035769
    },
    {
        "content": "<p>and then manually use <code>isSet</code> where you would in Lean rely on proof irrelevance--and then you get only a propositional equality and not a definitional one. It doesn't seem very ergonomic to me, but I've never tried to use it myself.</p>",
        "id": 167672458,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035793
    },
    {
        "content": "<p>Basically what you just wrote</p>",
        "id": 167672459,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035802
    },
    {
        "content": "<p>My attempt over the last couple of weeks to understand HoTT has taken some of the gloss off it. I think I'd rather have a <code>transfer</code> tactic than lose all this other stuff. The <code>transfer</code> tactic seems accessible to me.</p>",
        "id": 167672470,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035871
    },
    {
        "content": "<p>Now you could probably design a system with both HoTT-style types and sets, or more generally track the \"h-level\" of a type (= how truncated it is) the same way Lean tracks universe levels, it just doesn't exist yet as far as I know</p>",
        "id": 167672515,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560035912
    },
    {
        "content": "<p>I see. So one could imagine some future version of Leo coming along with a new model, a slightly different kind of type theory which was perhaps some way between Lean and HoTT, which worked even better for mathematics, and then we'd all have to start again?</p>",
        "id": 167672557,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560035979
    },
    {
        "content": "<p>Or possibly we figure out how to extend/embed these systems in a way that doesn't require starting over</p>",
        "id": 167672736,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560036267
    },
    {
        "content": "<p>The question you started with about building types in HoTT that correspond to things we classically build using geometric constructions is a big deal if you want to go far into homotopy theory, too.</p>",
        "id": 167672870,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560036555
    },
    {
        "content": "<p>It seems to me that for \"normal mathematicians\" (i.e. mathematicians who don't know anything about type theory or set theory or category theory), vanilla Lean 3 is currently the best option for formalising \"all normal maths\" on a computer. HOL has no dependent types so just isn't flexible enough for algebra (although it's very good at analysis) and HoTT is great at homotopy theory but lacks a decent implementation in a computer system. Mizar seems to be dead, for some reason, so that leaves Coq, Lean and Agda, and Lean is somehow better than the other two because it was written later on so has learnt from the mistakes of the earlier systems (quotients, term mode and tactic mode, ...)</p>",
        "id": 167672875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560036573
    },
    {
        "content": "<blockquote>\n<p>The question you started with about building types in HoTT that correspond to things we classically build using geometric constructions is a big deal if you want to go far into homotopy theory, too.</p>\n</blockquote>\n<p>Why? If you want to reason about complicated objects which have an analytic construction but not a synthetic one then you should figure out what extra properties you need from the analytic construction which don't \"come for free\" via some formal synthetic argument, right?</p>",
        "id": 167672937,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560036630
    },
    {
        "content": "<p>Well, and then what? Add them as constants/axioms?</p>",
        "id": 167672948,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560036671
    },
    {
        "content": "<p>If you're willing to extend the theory then you have options</p>",
        "id": 167672950,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560036688
    },
    {
        "content": "<p>Oh we're slightly at cross purposes. I was imagining building them analytically. Sure you're in trouble if you want to do everything synthetically.</p>",
        "id": 167672957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560036720
    },
    {
        "content": "<p>sounds to me like you can't even do Grassmannians if you stick to the synthetic approach.</p>",
        "id": 167673001,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560036745
    },
    {
        "content": "<p>Right and that means no K-theory, or complex cobordism which is at the heart of chromatic homotopy theory, etc</p>",
        "id": 167673003,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560036768
    },
    {
        "content": "<p>So one thing I would like to attempt some day is to turn the Kapulkin-Lumsdaine paper that <span class=\"user-mention\" data-user-id=\"116448\">@Koundinya Vajjha</span> linked earlier into Lean so that you can do the synthetic homotopy theory parts in an embedded HoTT language and the analytic parts with whatever means are necessary.</p>",
        "id": 167673017,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560036823
    },
    {
        "content": "<p>though I have very little idea how well the \"embedded HoTT language\" part would work in practice</p>",
        "id": 167673065,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560036889
    },
    {
        "content": "<p>I just can't get away from the fact that HoTT is making a tool which makes some parts of homotopy theory very nice. What about the rest of maths? It's like Isabelle/HOL with its real analysis.</p>",
        "id": 167673134,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560036971
    },
    {
        "content": "<p>These tools are very suitable for parts of maths, but a lot less suitable for other parts.</p>",
        "id": 167673159,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560036998
    },
    {
        "content": "<p>I mean, it does also solve your \"if R is local and S is isomorphic to R then S is local\" problem.</p>",
        "id": 167673193,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560037053
    },
    {
        "content": "<p>I think the area where HoTT is strongest is actually category theory (and maybe n-categories for very small values of n like 2) and maybe this is why UniMath has so much of it.</p>",
        "id": 167673245,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560037090
    },
    {
        "content": "<blockquote>\n<p>I mean, it does also solve your \"if R is local and S is isomorphic to R then S is local\" problem.</p>\n</blockquote>\n<p>It does, but it sounds to me like Lean might be able to make a better solution.</p>",
        "id": 167673408,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560037373
    },
    {
        "content": "<p>because Lean's solution will have computational content.</p>",
        "id": 167673417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560037386
    },
    {
        "content": "<p>If we make some computable definition that depends on R, and then port it over to S, it should remain computable.</p>",
        "id": 167673423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560037427
    },
    {
        "content": "<p>Oh, I don't know whether this helps, but regarding the term \"sheaf of spaces\" which I never really defined, if you require the spaces to only have <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\pi_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\pi_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span>, then it's the same thing as a stack.</p>",
        "id": 167673609,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560037760
    },
    {
        "content": "<p>Because a space with only <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\pi_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\pi_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> is the same thing as a groupoid</p>",
        "id": 167673614,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560037782
    },
    {
        "content": "<p><a href=\"https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/\" target=\"_blank\" title=\"https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/\">https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/</a></p>\n<blockquote>\n<p>cubicaltt is based on a novel type theory called Cubical Type Theory that provides new ways to reason about equality. Most notably it makes various extensionality principles, like function extensionality and Voevodsky’s univalence axiom, into theorems instead of axioms. This is done such that these principles have computational content and in particular that we can transport structures between equivalent types and that these transports compute. This is different from when one postulates the univalence axiom in a proof assistant like Coq or Agda. If one just adds an axiom there is no way for Coq or Agda to know how it should compute and one looses the good computational properties of type theory. In particular canonicity no longer holds and one can produce terms that are stuck (e.g. booleans that are neither true nor false but don’t reduce further). In other words this is like having a programming language in which one doesn’t know how to run the programs. So cubicaltt provides an operational semantics for Homotopy Type Theory and Univalent Foundations by giving a computational justification for the univalence axiom and (some) higher inductive types.</p>\n</blockquote>",
        "id": 167673874,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560038184
    },
    {
        "content": "<p>So how's its maths library?</p>",
        "id": 167673884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560038225
    },
    {
        "content": "<p>I think this is currently even more impractical to actually use though.</p>",
        "id": 167673887,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560038228
    },
    {
        "content": "<blockquote>\n<p>For those who cannot live without implicit arguments and other features of modern proof assistants there is now an experimental cubical mode shipped with the master branch of Agda.</p>\n</blockquote>",
        "id": 167673888,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560038234
    },
    {
        "content": "<p>and presumably, like Coq or Lean, if you try it in Agda then you have to promise not to use some of Agda's functionality?</p>",
        "id": 167673941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560038335
    },
    {
        "content": "<p>What's the easiest way of proving <code>false</code> using the Lean 3 HoTT package?</p>",
        "id": 167673956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560038380
    },
    {
        "content": "<p>Is <code>bool = fin 2 -&gt; false</code> provable in Lean?</p>",
        "id": 167674024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560038438
    },
    {
        "content": "<p>It looks like the Agda cubical thing is a mode that Agda is aware of, so it probably automatically prevents you from breaking the rules (assuming there aren't bugs), like Lean 2's HoTT mode</p>",
        "id": 167674083,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560038546
    },
    {
        "content": "<p>Maybe it's easier to write down two equivalences bool -&gt; bool</p>",
        "id": 167674090,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560038569
    },
    {
        "content": "<blockquote>\n<p>Is <code>bool = fin 2 -&gt; false</code> provable in Lean?</p>\n</blockquote>\n<p>no</p>",
        "id": 167674091,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560038579
    },
    {
        "content": "<blockquote>\n<p>What's the easiest way of proving <code>false</code> using the Lean 3 HoTT package?</p>\n</blockquote>\n<p>Use univalence to construct <code>e : bool = bool</code> such that <code>eq.rec</code> on <code>e</code> swaps the values, and then use proof irrelevance to get <code>e = rfl</code></p>",
        "id": 167674145,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560038683
    },
    {
        "content": "<p>right.</p>",
        "id": 167674158,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560038712
    },
    {
        "content": "<p>Is <code>tt == ff</code> in HoTT</p>",
        "id": 167674162,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560038751
    },
    {
        "content": "<blockquote>\n<p>Use univalence to construct <code>e : bool = bool</code> such that <code>eq.rec</code> on <code>e</code> swaps the values, and then use proof irrelevance to get <code>e = rfl</code></p>\n</blockquote>\n<p>dammit <code>e</code> has type Type 1 instead of <code>Prop</code></p>",
        "id": 167674217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560038852
    },
    {
        "content": "<p><code>=</code> has been redefined to mean <code>hott.eq</code></p>",
        "id": 167674219,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560038865
    },
    {
        "content": "<p>Are you in HoTT Lean?</p>",
        "id": 167674265,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560038893
    },
    {
        "content": "<p>rofl <code>=</code> is overloaded</p>",
        "id": 167674266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560038899
    },
    {
        "content": "<p>I'm just goofing around in <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> 's hott3 repo</p>",
        "id": 167674268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560038916
    },
    {
        "content": "<p><code>=</code> is overloaded! It's just like normal maths!</p>",
        "id": 167674270,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560038930
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">hott_theory_cmd</span> <span class=\"s2\">&quot;local infix ` = ` := hott.eq&quot;</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">hott</span><span class=\"o\">,</span> <span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">rfl</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">a</span>\n</pre></div>\n\n\n<p>You've got to be pretty darn careful in this repo!</p>",
        "id": 167674331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560039026
    },
    {
        "content": "<p>Oh I was afraid of that, but I only skimmed the source on github, I didn't actually build it.</p>",
        "id": 167674335,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560039048
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">eq</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">eq</span> <span class=\"n\">a</span>\n</pre></div>",
        "id": 167674349,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560039082
    },
    {
        "content": "<p>Okay so it's the same as the normal <code>eq</code>, just not a Prop.</p>",
        "id": 167674350,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560039087
    },
    {
        "content": "<p>right</p>",
        "id": 167674352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560039092
    },
    {
        "content": "<p>You can still prove that any two terms of type <code>hott.eq a b</code> are equal but it's more complicated than you might expect under the hood.</p>",
        "id": 167674469,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560039353
    },
    {
        "content": "<p>Perhaps I'm not supposed to be proving that sort of thing.</p>",
        "id": 167674514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560039386
    },
    {
        "content": "<p>Well that's how you finish the proof of <code>false</code>--it replaces the proof irrelevance step</p>",
        "id": 167674520,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560039423
    },
    {
        "content": "<p>So yes you're not supposed to prove it</p>",
        "id": 167674532,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560039438
    },
    {
        "content": "<p>This always seemed to me to be something that felt accidentally consistent. You have a recursor that says every proof is <code>refl</code>, but somehow you can't prove everything's a set. A lot of the proofs in the HoTT book informally prove equalities by saying \"assume everything's refl\". Is there some intuition behind when this is valid? Very imprecise question, I know.</p>",
        "id": 167674818,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560039902
    },
    {
        "content": "<blockquote>\n<p>So one thing I would like to attempt some day is to turn the Kapulkin-Lumsdaine paper that <span class=\"user-mention silent\" data-user-id=\"116448\">Koundinya Vajjha</span> linked earlier into Lean so that you can do the synthetic homotopy theory parts in an embedded HoTT language and the analytic parts with whatever means are necessary.</p>\n</blockquote>\n<p>AFAIK, synthetic homotopy theory uses Higher Inductive types and the Kapulkin-Lumsdaine paper avoids HITs altogether. As of last year, I think HITs have a semantics in the simplicial model, although I'm not totally sure.</p>",
        "id": 167674829,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1560039913
    },
    {
        "content": "<p>It avoids them in the sense that it does not handle them, yeah.</p>",
        "id": 167674876,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560039977
    },
    {
        "content": "<p>The definition of the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>S</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">S^1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span></span></span> type (the circle) seems to have one point <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">x</span></span></span></span> and one proof <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x=x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">x</span><span class=\"mrel\">=</span><span class=\"mord mathit\">x</span></span></span></span> and you can compose this proof with itself lots of times and get lots of proofs of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x=x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">x</span><span class=\"mrel\">=</span><span class=\"mord mathit\">x</span></span></span></span> and only one of them will be <code>refl</code></p>",
        "id": 167674878,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560039997
    },
    {
        "content": "<p>This proof of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x=x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">x</span><span class=\"mrel\">=</span><span class=\"mord mathit\">x</span></span></span></span> is made as an explicit constructor in the definition of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>S</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">S^1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span></span></span> so is really not proved by <code>refl</code></p>",
        "id": 167674896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560040044
    },
    {
        "content": "<p>I don't even know if I'm supposed to be calling it a \"proof\".</p>",
        "id": 167674899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560040076
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> It's not exactly about \"assume everything's refl\", but it's hard not to read it that way because that's what the J rule (aka <code>eq.drec</code>) says</p>",
        "id": 167675138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560040472
    },
    {
        "content": "<blockquote>\n<p>This always seemed to me to be something that felt accidentally consistent. You have a recursor that says every proof is <code>refl</code>, but somehow you can't prove everything's a set. A lot of the proofs in the HoTT book informally prove equalities by saying \"assume everything's refl\". Is there some intuition behind when this is valid? Very imprecise question, I know.</p>\n</blockquote>\n<p>At least one endpoint of the equality has to be a variable; then you can replace it and the equality proof by the other endpoint and <code>refl</code>. The intuition is that if you have a path in a space, if you're allowed to move one endpoint, then you can collapse the path down to a constant path, but if you're not allowed to then you can't. (Well that is kind of obvious, but the point is that even if the two endpoints are the same then the path might not be equal to the constant path.)</p>",
        "id": 167675148,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560040504
    },
    {
        "content": "<p>Some comments:</p>\n<blockquote>\n<p>Kevin Buzzard: So how's its [cubicaltt's] maths library?</p>\n</blockquote>\n<p>There is none, up to a rounding error. I doubt that the rational numbers are defined. Note that cubicaltt does not support implicit arguments, and yes, that is every bit as inconvenient as you think it is.</p>\n<blockquote>\n<p>What's the easiest way of proving false using the Lean 3 HoTT package?</p>\n</blockquote>\n<p>The claim of consistency of the Lean 3 HoTT library is that you cannot prove <code>false</code> in a declaration with the <code>@[hott]</code> attribute without generating a warning/error message. Without this attribute you can do it, as stated above (you have to prove that <code>hott.eq</code> and <code>eq</code> are equivalent).</p>\n<blockquote>\n<p>Is <code>tt == ff</code> in HoTT</p>\n</blockquote>\n<p>If <code>==</code> is the <code>heq</code> analogue for HoTT, then yes. However, this is not in contradiction, since you cannot prove that if <code>x == y</code> and <code>x : A</code> and <code>y : A</code> then <code>x = y</code>. What this shows is that <code>heq</code> is not a useful notion in HoTT. Instead, we use pathovers: <a href=\"https://github.com/gebner/hott3/blob/master/src/hott/init/pathover.lean\" target=\"_blank\" title=\"https://github.com/gebner/hott3/blob/master/src/hott/init/pathover.lean\">https://github.com/gebner/hott3/blob/master/src/hott/init/pathover.lean</a></p>\n<blockquote>\n<p><code>=</code> is overloaded! It's just like normal maths!</p>\n</blockquote>\n<p>If I recall correctly, local notation doesn't overload global notation, but replaces it. But now that I test it, that doesn't seem to be true. I'm quite sure it was never a problem (presumably because <code>hott.eq</code> always applies when <code>eq</code> does [for the use cases of HoTT].</p>",
        "id": 167694290,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1560076910
    },
    {
        "content": "<p>Is HoTT is consistent with proof irrelevance without large elimination?</p>",
        "id": 167698093,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560083499
    },
    {
        "content": "<p>With \"large elimination\" do you mean \"singleton elimination\" (the reason that <code>eq</code>, <code>acc</code>, <code>true</code> and similar inductive propositions/predicates can eliminate to <code>Type*</code> instead of just <code>Prop</code>)? Assuming you also remove choice and quotients, then I strongly suspect it is consistent, since in that case there is probably no way to go from <code>Prop</code> to <code>Type*</code>. In other words, if you can construct an element of a type, then I suspect you can construct that element without proving any proposition.</p>",
        "id": 167728363,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1560134130
    },
    {
        "content": "<p>This took me forever. HoTT is weird.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">hott</span><span class=\"o\">]</span> <span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">unit</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"n\">punit</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">eq</span> <span class=\"n\">h</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"err\">$</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">unit</span> <span class=\"o\">()</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">punit</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">())</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">()</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 167842318,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560253886
    },
    {
        "content": "<p>are there no tactics in hott?</p>",
        "id": 167842429,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560253989
    },
    {
        "content": "<p>I haven't found any. <code>cases</code> gives the the error <code>not hott: uses large eliminator eq.rec</code></p>",
        "id": 167842530,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560254069
    },
    {
        "content": "<p><code>not hott</code> rhymes</p>",
        "id": 167842539,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560254078
    },
    {
        "content": "<p>Also the elaborator can never compute the motive for these funny ones.</p>",
        "id": 167842570,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560254101
    },
    {
        "content": "<p>Some tactics are available.  For example, <code>cases</code> (and the equations compiler) works as long as the type you match on is not dependent (i.e., unit, prod, list are fine.  sigma, eq is bad).  Floris wrote an <code>hinduction</code> tactic that does induction on equalities.  There is also an <code>hsimp</code> tactic that adapts the simplifier to work on <code>hott.eq</code>.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">hott</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">ex2</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">unit</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hinduction</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">unit</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">⟨⟩</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>(My HoTT is really rusty now.)  BTW, <code>@[hott]</code> doesn't work on examples.</p>",
        "id": 167845678,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1560256785
    },
    {
        "content": "<p>How do I prove <code>0 \\ne nat.succ n</code> in HoTT</p>",
        "id": 167846809,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560257700
    },
    {
        "content": "<p>can't you do it the same way as usual?</p>",
        "id": 167847047,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560257868
    },
    {
        "content": "<p>spoilers: there's a proof in <code>hott.nat.basic</code></p>",
        "id": 167847199,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560257985
    },
    {
        "content": "<p>spoilers<br>\n.<br>\n.<br>\n.<br>\n.<br>\n.<br>\n.<br>\n.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">.</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">hott</span><span class=\"o\">,</span> <span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">code</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>        <span class=\"mi\">0</span>        <span class=\"o\">:=</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>        <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">empty</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"mi\">0</span>        <span class=\"o\">:=</span> <span class=\"n\">empty</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">code</span> <span class=\"n\">n</span> <span class=\"n\">m</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">hott</span><span class=\"o\">]</span> <span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">code</span> <span class=\"n\">n</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>        <span class=\"o\">:=</span> <span class=\"n\">star</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">refl</span> <span class=\"n\">n</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">hott</span><span class=\"o\">]</span> <span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">encode</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">code</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">p</span> <span class=\"bp\">▸</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">n</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">hott</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">succ_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">encode</span>\n</pre></div>",
        "id": 167847422,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560258127
    },
    {
        "content": "<p><code>nat.no_confusion</code> will prove it for normal <code>eq</code> not HoTT <code>eq</code>. I guess I could define <code>nat.hno_confusion</code> again.</p>",
        "id": 167847432,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560258138
    },
    {
        "content": "<p>The <code>nat.code</code>/<code>encode</code>/<code>decode</code> are very similar to <code>nat.no_confusion_type</code>. They are a bit stronger, they also allow you to prove that <code>n = m</code> is equivalent (as a type) to <code>code n m</code>, which allows you to prove that <code>n = m</code> is a proposition (subsingleton), and hence that <code>nat</code> is a set.</p>",
        "id": 167907694,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1560304696
    },
    {
        "content": "<p>There are tactic proofs in HoTT3, but there are also a bunch of illegal tactics that use proof irrelevance (<code>cases</code>/<code>rw</code>/<code>simp</code>/...). Instead of <code>cases</code> you can do <code>induction</code> (which is less sophisticated) and Gabriel wrote HoTT-compatible versions of <code>rw</code> and <code>simp</code> called <code>rwr</code> and <code>hsimp</code>.</p>",
        "id": 167907731,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1560304788
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> That proof is indeed counter-intuitive. Here is the version in the HoTT library:<br>\n<a href=\"https://github.com/gebner/hott3/blob/64a297c4c1effa4886abcdc08dd88824a7b27455/src/hott/init/trunc.lean#L156-L161\" target=\"_blank\" title=\"https://github.com/gebner/hott3/blob/64a297c4c1effa4886abcdc08dd88824a7b27455/src/hott/init/trunc.lean#L156-L161\">https://github.com/gebner/hott3/blob/64a297c4c1effa4886abcdc08dd88824a7b27455/src/hott/init/trunc.lean#L156-L161</a></p>\n<p>The idea behind the proof is that you first want to define a \"canonical\" proof that any two elements in your type are equal (which is equal to refl when the two terms are definitionally equal), and then (using path/eq induction) proof that an arbitrary path/eq is equal to the canonical one.</p>\n<p>You can also look in chapter 3 of the HoTT book (I think section 3.1) for a proof in words.</p>",
        "id": 167908008,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1560305114
    },
    {
        "content": "<p>There are plenty of tactic proofs in the HoTT library: <a href=\"https://github.com/gebner/hott3/search?q=begin&amp;unscoped_q=begin\" target=\"_blank\" title=\"https://github.com/gebner/hott3/search?q=begin&amp;unscoped_q=begin\">https://github.com/gebner/hott3/search?q=begin&amp;unscoped_q=begin</a></p>",
        "id": 167908109,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1560305271
    },
    {
        "content": "<p>Here is one question that I've been wondering about:<br>\nsuppose that I formalise groups in HoTT. It would be something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"o\">:</span> <span class=\"n\">is_a_set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">axioms</span> <span class=\"o\">:</span> <span class=\"n\">blah</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>The difference is of course the addition of the <code>is_a_set</code> condition.</p>\n<p>Now I formalise <code>Group</code> as bundled groups, and endow this with the obvious category structure. I then have isomorphisms in the category <code>Group</code>, but HoTT also gives me transport along paths. These two notions are mathematically the same. How hard is it to derive this in HoTT?</p>",
        "id": 167960482,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560354617
    },
    {
        "content": "<p>I'm pretty sure the chapter on categories in the hott book discusses this exact issue</p>",
        "id": 167961567,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560355255
    },
    {
        "content": "<p>This condition that the groupoid of isomorphisms agrees with the homotopy type of the space of objects is something you can write down internally</p>",
        "id": 167961811,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560355419
    },
    {
        "content": "<p>For Set it is the univalence axiom (for sets)</p>",
        "id": 167962029,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560355442
    },
    {
        "content": "<p>I forget what the hott book calls it, but it's essentially the \"complete\" condition of complete Segal spaces</p>",
        "id": 167962192,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560355541
    },
    {
        "content": "<p>I'm pretty sure the book explains why it is also automatically satisfied for algebraic structures like groups</p>",
        "id": 167962311,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560355608
    },
    {
        "content": "<p>Ok, thanks. I should have a look at the HoTT book again.<br>\nWith \"automatically satisfied\" you mean that it is <em>true</em>, not that you get the result for free, I guess.</p>",
        "id": 167965828,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560358093
    },
    {
        "content": "<p>right</p>",
        "id": 167966427,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560358571
    },
    {
        "content": "<p>but I don't think it should be very hard, and it should be mechanical</p>",
        "id": 167966437,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560358586
    },
    {
        "content": "<p>You know that the cool kids these days define a group as a tuple:<br>\n<code>(G : Type) (BG : Type) (h : G = \\Omega BG)</code> ...</p>",
        "id": 167992116,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1560376536
    },
    {
        "content": "<p>(i.e. it's some type which is the loop space of some other type)</p>",
        "id": 167992138,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1560376558
    },
    {
        "content": "<p>Hi. I have a few layman's Lean history or mathematics questions after reading the README of Gabriel's <a href=\"https://github.com/gebner/hott3\">HoTT repo</a> (my goal is just to make sure I know enough to competently write something in <a href=\"https://github.com/leanprover-community/leanprover-community.github.io/pull/249\">this PR</a>, but I'd love to understand more than I do now regardless):</p>\n<blockquote>\n<p>the equality type eq which is defined to be in Prop can eliminate to Type, which is inconsistent with univalence</p>\n</blockquote>\n<ul>\n<li>Is there an easy way to understand what makes this inconsistent with univalence?</li>\n<li>What was the historical reason to introduce this change (singleton elimination) to Lean 3?</li>\n<li>Is this the only thing inconsistent with univalence? It seems the answer is \"yes\", given that the external repo was able to re-add a HoTT-based library with just some avoidance of that, but just want to make sure I didn't miss something</li>\n<li>What is a higher inductive type? Is it equiimportant with the univalence axiom in understanding HoTT and how it differs from Lean / CoC?</li>\n<li>Can a layman understand \"Dan Licata's trick\"? What's the \"problem\" that needs a trick?</li>\n</ul>\n<p>And finally:</p>\n<blockquote>\n<p>Without singleton elimination the system is conjectured to be consistent</p>\n</blockquote>\n<p>Is this still the best that can be said there?</p>",
        "id": 269903162,
        "sender_full_name": "Julian Berman",
        "timestamp": 1643508455
    },
    {
        "content": "<p>My two cents: if X and Y are types with two terms like <code>bool</code> then we can construct two provably distinct terms <code>f g : X ≃ Y</code>  but there's at most one term <code>h : X = Y</code> in lean because <code>X = Y</code> is a Prop. So <code>X ≃ Y</code> and <code>X = Y</code> provably don't biject with each other.</p>\n<p>My personal understanding of why Leo dropped univalence was that he basically felt that it made the system complex and unintuitive to use and maintain.</p>",
        "id": 269923296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1643536312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/116395-maths/topic/HoTT/near/269903162\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Is this the only thing inconsistent with univalence? It seems the answer is \"yes\", given that the external repo was able to re-add a HoTT-based library with just some avoidance of that, but just want to make sure I didn't miss something</li>\n</ul>\n</blockquote>\n<p>The axiom of choice is the other big thing that's inconsistent with univalence depending on how it's stated. Lean's statement would be inconsistent but wrapping it in <code>nonempty</code> would make it consistent, so you can have <code>Pi {A : Type}, nonempty (nonempty A -&gt; A)</code></p>",
        "id": 269924597,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1643538059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/116395-maths/topic/HoTT/near/269903162\">said</a>:</p>\n<blockquote>\n<ul>\n<li>What is a higher inductive type? Is it equiimportant with the univalence axiom in understanding HoTT and how it differs from Lean / CoC?</li>\n</ul>\n</blockquote>\n<p>A higher inductive type is like an inductive type but you can also add paths (equalities) between elements in your type. This is one way of doing quotient types, but it also lets you define things like the space <code>S^1</code>which is defined as follows.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">data</span> <span class=\"n\">S</span><span class=\"bp\">¹</span> <span class=\"o\">:</span> <span class=\"n\">Type₀</span> <span class=\"n\">where</span>\n  <span class=\"n\">base</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"bp\">¹</span>\n  <span class=\"n\">loop</span> <span class=\"o\">:</span> <span class=\"n\">base</span> <span class=\"bp\">≡</span> <span class=\"n\">base</span>\n</code></pre></div>\n<p>You can add an extra path between <code>base</code> and <code>base</code> which is not equal to <code>refl</code>. The space of paths <code>base ≡ base</code> can be proved to be isomorphic to <code>int</code> and you can do this in the <a href=\"https://thehottgameguide.readthedocs.io/en/latest/index.html\">HoTT game</a>.</p>",
        "id": 269924887,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1643538446
    },
    {
        "content": "<p>It looks like those people forget to write where they got their inspiration.</p>",
        "id": 269925250,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1643538956
    },
    {
        "content": "<p>The <a href=\"https://github.com/thehottgame/TheHoTTGame/commit/51f084b5b6a221296fb1b1c273452019050fe7b3\">very first commit</a> in July 2021 contained a text file explicitly referring to the Natural Number Game, but somehow that information got lost...</p>",
        "id": 269925348,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1643539058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/116395-maths/topic/HoTT/near/269924887\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/116395-maths/topic/HoTT/near/269903162\">said</a>:</p>\n<blockquote>\n<ul>\n<li>What is a higher inductive type? Is it equiimportant with the univalence axiom in understanding HoTT and how it differs from Lean / CoC?</li>\n</ul>\n</blockquote>\n<p>A higher inductive type is like an inductive type but you can also add paths (equalities) between elements in your type.</p>\n</blockquote>\n<p>And \"Dan Licata's trick\" is a way to simulate HITs in a system that was not designed to support them.<br>\nThe idea is to represent a HIT by an ordinary inductive that only has the value constructors (like <code>base</code> but not <code>loop</code>). Then add the path constructors as axioms. This usually makes the system inconsistent, because we could prove (using the original induction principle for the underlying inductive type) that these axioms are false. So, we do this inside a private scope from which we don't export the original induction principle, but instead export our own induction principle with the correct type for the HIT (with an extra argument corresponding to the path constructor).</p>",
        "id": 269926539,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643540663
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/HoTT/near/269923296\">said</a>:</p>\n<blockquote>\n<p>My personal understanding of why Leo dropped univalence was that he basically felt that it made the system complex and unintuitive to use and maintain.</p>\n</blockquote>\n<p>It seems to be very hard to support multiple foundational systems well at the same time. The issue is not so much in the kernel/prover itself but in the surrounding libraries--if the systems are different in useful ways then you will want to express things differently in them, and then the libraries diverge. In the case of two mutually incompatible systems (e.g. univalence vs large elimination for eq/<code>choice</code> constant) you actually have three systems, the third being the \"neutral\" system containing whatever is valid in both of them.</p>\n<p>We already have something similar regarding decidability--parts of the library that are totally nonconstructive still have to deal with <code>decidable</code> and <code>fintype</code> instances and potential diamonds and stating lemmas \"correctly\" and so on.</p>",
        "id": 269927612,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643542021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/116395-maths/topic/HoTT/near/269903162\">said</a>:</p>\n<blockquote>\n<ul>\n<li>What was the historical reason to introduce this change (singleton elimination) to Lean 3?</li>\n</ul>\n</blockquote>\n<p>This is a slight simplification but: In practice, the choice is between having definitional proof irrelevance for <code>x = y</code> and having univalence for <code>=</code> between types. You can't have both because there are generally multiple distinct equivalences between two types.<br>\nDefinitional proof irrelevance for <code>x = y</code> is nice because it means that you can be reasonably confident that changing the proof of an equality won't break downstream proofs, and so you can freely use tactics/automation without worrying that a change to the tactic will make it produce the \"wrong\" proof.</p>",
        "id": 269927897,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643542365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/116395-maths/topic/HoTT/near/269925250\">said</a>:</p>\n<blockquote>\n<p>It looks like those people forget to write where they got their inspiration.</p>\n</blockquote>\n<p>Thanks for pointing this out. I added some info on the website <a href=\"https://thehottgameguide.readthedocs.io/en/latest/getting-started/about-hott-game.html\">https://thehottgameguide.readthedocs.io/en/latest/getting-started/about-hott-game.html</a></p>",
        "id": 270001967,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643621387
    },
    {
        "content": "<blockquote>\n<p>My personal understanding of why Leo dropped univalence was that he basically felt that it made the system complex and unintuitive to use and maintain.</p>\n</blockquote>\n<p>If I recall correctly, the immediate reason for dropping HoTT was that it was incompatible with the code extraction for the VM.  In HoTT, an argument <code>h : x = y</code> cannot be dropped because it can be executed (<code>h.elim</code> might e.g. be Boolean negation).  However we want to erase proofs for performance reasons.</p>",
        "id": 270002166,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1643621487
    },
    {
        "content": "<p>My comments are a muddled recollection of something Leo told me verbally once, of the form \"it was hard to make it work efficiently\". Probably Gabriel's comments are a more precise summary of the story</p>",
        "id": 270003059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1643621931
    }
]
[
    {
        "content": "<p>Hi,</p>\n<p>Does anyone know how to demonstrate the following result:</p>\n<p>Let k be a field, and  V a vector space over k,  let  W a  subspace of V. There exists a projector of V of image W !</p>",
        "id": 198114676,
        "sender_full_name": "orlando",
        "timestamp": 1589916335
    },
    {
        "content": "<p>You mean, in maths or in Lean?</p>",
        "id": 198114785,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589916384
    },
    {
        "content": "<p>I guess Yury's PRs from today will do that for you?</p>",
        "id": 198114809,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589916409
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>  In lean !</p>",
        "id": 198114838,
        "sender_full_name": "orlando",
        "timestamp": 1589916436
    },
    {
        "content": "<p>It's <a href=\"https://github.com/leanprover-community/mathlib/issues/2739\">#2739</a></p>",
        "id": 198114866,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1589916454
    },
    {
        "content": "<p>ohhhh nice !</p>",
        "id": 198114970,
        "sender_full_name": "orlando",
        "timestamp": 1589916507
    },
    {
        "content": "<p>Use <code>exists_is_compl</code> + <code>linear_proj_of_is_compl</code></p>",
        "id": 198117023,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589917562
    },
    {
        "content": "<p>If you need it more than once, feel free to add <code>submodule.exists_linear_proj</code>.</p>",
        "id": 198117083,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589917581
    },
    {
        "content": "<p>BTW, <code>quotient_prod_linear_equiv</code> doesn't claim that the equivalence is <code>id</code> on <code>p</code> which makes the statement less useful.</p>",
        "id": 198117339,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589917705
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>   I need to read your code a bit but I think it will help me a lot. I just need to adjust my definitions a bit.</p>",
        "id": 198118302,
        "sender_full_name": "orlando",
        "timestamp": 1589918209
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>  it's ok for me, thank's ! </p>\n<p>I take this opportunity to ask another question. Does anyone have an idea to define the trace of an endomorphism of a vector space of finite dimension. We can define the trace for an endomorphism of a vector space provided with a base and prove that this trace is independent of the base. But is there a way to forget the reference to the base ?</p>",
        "id": 198595778,
        "sender_full_name": "orlando",
        "timestamp": 1590347634
    },
    {
        "content": "<p>It's the unique linear map with some properties</p>",
        "id": 198595824,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590347689
    },
    {
        "content": "<p>It sends an idempotent to its rank and it's linear</p>",
        "id": 198595837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590347722
    },
    {
        "content": "<p>oh i never see this caracterisation !!!</p>",
        "id": 198595914,
        "sender_full_name": "orlando",
        "timestamp": 1590347846
    },
    {
        "content": "<p>I'm not sure it helps you though :-)</p>",
        "id": 198595918,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590347861
    },
    {
        "content": "<p>It's also the sum of the eigenvalues!</p>",
        "id": 198595922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590347876
    },
    {
        "content": "<p>One definition is via <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>V</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mi>V</mi><mo>⊗</mo><msup><mi>V</mi><mo>∗</mo></msup><mo>→</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">Hom(V,V) \\cong V\\otimes V^* \\to k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">m</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.688696em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>, the last map is contraction, evaluating a dual vector at  a vector</p>",
        "id": 198595969,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1590347921
    },
    {
        "content": "<p>Wait</p>",
        "id": 198596076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590348093
    },
    {
        "content": "<p>(got it)</p>",
        "id": 198596082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590348117
    },
    {
        "content": "<p>I think it's also the coefficient of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">t</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>det</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>+</mo><mi>t</mi><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\det (1 + tA)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">det</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">A</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 198596126,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590348167
    },
    {
        "content": "<p>Right, but det also wants to be defined via choosing a basis</p>",
        "id": 198596133,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590348191
    },
    {
        "content": "<p>ok but we already have det for an endomorphism I think <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 198596138,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590348213
    },
    {
        "content": "<p>Or at least, I heard we were going to</p>",
        "id": 198596142,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590348230
    },
    {
        "content": "<p>Alex's definition is one of these phenomena I've never understood properly. There's a natural map from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><msup><mi>V</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">V\\otimes V^*</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.688696em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Hom(V,V)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">m</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span>, which in the finite-dimensional case is an isomorphism (and which isn't an isomorphism otherwise). In the finite-dimensional case you can hence take its inverse.</p>",
        "id": 198596184,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590348246
    },
    {
        "content": "<p>hum <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  i don't see ( in lean)  det for endomorphism !</p>",
        "id": 198596193,
        "sender_full_name": "orlando",
        "timestamp": 1590348272
    },
    {
        "content": "<p>Yeah, maybe it was a false rumor.</p>",
        "id": 198596195,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590348280
    },
    {
        "content": "<p>In Langlands' paper on abelian local and global Langlands he pulls this trick off a couple of times. There is a map which is computable, and by a hard theorem it's a bijection, and then he merrily uses the inverse when doing calculations, but it's impossible to unravel them because the proof that it's a bijection is nonconstructive</p>",
        "id": 198596206,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590348309
    },
    {
        "content": "<p>If we're doing vector spaces over a field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> and we put the discrete norm on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><msup><mi>V</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">V\\otimes V^*</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.688696em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> corresponds to precisely the trace class endomorphisms in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Hom(V,V)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">m</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span>, so the leap of faith is the assertion that every endomorphism is trace class</p>",
        "id": 198596255,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590348376
    },
    {
        "content": "<p>Anyways the right way to give a direct definition like this (which we never do in mathlib AFAIK) is to prove the trace is independent of the choice of basis, then use unique choice to choose a value which is the trace of the matrix in some basis</p>",
        "id": 198596380,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590348616
    },
    {
        "content": "<p>or equivalently, use unique choice to get a <code>trunc ([basis for V])</code> and then use <code>trunc.lift</code> to get out the trace</p>",
        "id": 198596400,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590348707
    },
    {
        "content": "<p>Are you explaining how to make it computable or something? What do you mean by the \"right\" way?</p>",
        "id": 198596441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590348737
    },
    {
        "content": "<p>It won't be computable (ever?)</p>",
        "id": 198596448,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590348789
    },
    {
        "content": "<p>this way it's obviously independent of the choice of basis, and theoretically a tactic could see this and prove that the trace of the corresponding endomorphism of an isomorphic vector space is equal</p>",
        "id": 198596504,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590348865
    },
    {
        "content": "<p>It's also the right way in the sense that this is how mathematicians make definitions</p>",
        "id": 198596506,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590348875
    },
    {
        "content": "<p>Didn't we have to deal with something like this when we defined the dimension of a vector space?</p>",
        "id": 198596526,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1590348954
    },
    {
        "content": "<p>The right way is really to use the identification with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><msup><mi>V</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">V \\otimes V^*</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.688696em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> to define the trace of a finite-rank endomorphism, without assuming that the space is finite-dimensional.</p>",
        "id": 198596528,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590348959
    },
    {
        "content": "<p>I think for the dimension of a vector space mathlib uses a more ad-hoc trick, like the minimum cardinality of a basis</p>",
        "id": 198596568,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590348966
    },
    {
        "content": "<p>The right way is to set up the theory of trace class endomorphisms of projective normed modules over normed rings, and then apply the theory in the case where the normed ring is a field with the discrete norm</p>",
        "id": 198596583,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590349024
    },
    {
        "content": "<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> is finite-rank and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is anything, then you have the formula <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>r</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mi>B</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>T</mi><mi>r</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Tr(AB)=Tr(BA)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathdefault\">A</span><span class=\"mclose\">)</span></span></span></span>. Finite-dimensionality is not really relevant.</p>",
        "id": 198596588,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590349036
    },
    {
        "content": "<p>The right way is to show this for A compact and B anything</p>",
        "id": 198596601,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590349071
    },
    {
        "content": "<p>Compact operators are not always trace-class...</p>",
        "id": 198596640,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590349089
    },
    {
        "content": "<p>Oh obviously I am assuming the norm is non-archimedean</p>",
        "id": 198596642,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590349103
    },
    {
        "content": "<p>because this is the right way to do it</p>",
        "id": 198596646,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590349116
    },
    {
        "content": "<p>Yes, I was guessing the real case is too boring for you.</p>",
        "id": 198596652,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590349138
    },
    {
        "content": "<p>it is pathological</p>",
        "id": 198596657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590349149
    },
    {
        "content": "<p>Definitely. But still interesting.</p>",
        "id": 198596662,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590349160
    },
    {
        "content": "<p>You have some phenomenon about the limit of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is zero but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sum a_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> doesn't converge, right?</p>",
        "id": 198596673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590349187
    },
    {
        "content": "<p>Doing analysis over such fields must be a nightmare</p>",
        "id": 198596733,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590349203
    },
    {
        "content": "<p>That's what we tell undergraduates, yes. But then we forget happily about it.</p>",
        "id": 198596739,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590349210
    },
    {
        "content": "<p>That's why it's called real analysis, as opposed to trivial analysis.</p>",
        "id": 198596752,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590349239
    },
    {
        "content": "<p>I'm just looking at my paper on this and apparently I need my base ring to be Noetherian too</p>",
        "id": 198596824,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590349333
    },
    {
        "content": "<p>It's hard to tell for sure because I can't click on the lemma name and see all hypotheses which are in place at this point, and I wrote the paper 15 years ago so have forgotten the details</p>",
        "id": 198596838,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590349392
    },
    {
        "content": "<p>I think it's not difficult to show the independance of the basis, we have the lemma :</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">trace_mul_comm</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">trace</span> <span class=\"n\">n</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">⬝</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">trace</span> <span class=\"n\">m</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⬝</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>So if i understand <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  idea. We make a function <code> trace (f : V \\to V)  (B : basis of V) </code> and we show that this function is constant  and use <code>trunc.lift</code> to make <code>trace (f : V \\to V) </code></p>",
        "id": 198596950,
        "sender_full_name": "orlando",
        "timestamp": 1590349568
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/vector.20space/near/198596568\">said</a>:</p>\n<blockquote>\n<p>I think for the dimension of a vector space mathlib uses a more ad-hoc trick, like the minimum cardinality of a basis</p>\n</blockquote>\n<p>That wasn't supposed to be an ad hoc trick, it was intended to apply to modules as well</p>",
        "id": 198600548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590354943
    },
    {
        "content": "<p>although the git history says it has only ever been on vector spaces</p>",
        "id": 198600872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590355413
    },
    {
        "content": "<p>but I distinctly remember researching notions of dimension on modules (and not finding anything very definitive)</p>",
        "id": 198600923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590355450
    },
    {
        "content": "<p>I actually have defining traces of finite-dimensional vector space endomorphisms on a list of things to PR at some point. I actually started this with <a href=\"https://github.com/leanprover-community/mathlib/pull/1973\">https://github.com/leanprover-community/mathlib/pull/1973</a> a few months ago and then got distracted, but I have been intending to come back to it. That PR at least introduces the map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo>∗</mo></msup><mo>⊗</mo><mi>W</mi><mo>→</mo><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>W</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">V^* \\otimes W \\to Hom(V, W)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.772026em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">m</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span></span></span></span> so a possible next step is to prove that it is a bijection when <code>W</code> is a finite-dimensional vector space, prove formulae about dimensions of tensor products and homs and use <code>linear_map.injective_iff_surjective</code> (or else skip the dimension stuff and just prove the map is injective over a field).</p>",
        "id": 198601432,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1590356328
    },
    {
        "content": "<p>For the map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mo>∗</mo></msup><mo>⊗</mo><mi>W</mi><mo>→</mo><mtext>Hom</mtext><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>W</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> V^* \\otimes W \\to \\text{Hom}(V,W)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.772026em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span></span></span></span> i suppose the definition is : (the map associated) to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>ϕ</mi><mo separator=\"true\">,</mo><mi>w</mi><mo stretchy=\"false\">)</mo><mo>↦</mo><mrow><mo fence=\"true\">[</mo><mi>v</mi><mo>↦</mo><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>∙</mo><mi>w</mi><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\"> (\\phi, w) \\mapsto \\left[ v \\mapsto \\phi (v) \\bullet w \\right]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">ϕ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∙</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose delimcenter\" style=\"top:0em;\">]</span></span></span></span></span>.</p>\n<p>I don't see other map so <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 198634406,
        "sender_full_name": "orlando",
        "timestamp": 1590383890
    },
    {
        "content": "<p>For what it's worth: Given a finite basis <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>w</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">w_1, \\ldots, w_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> for W with dual basis <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>ϕ</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>ϕ</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\phi_1, \\ldots, \\phi_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">ϕ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">ϕ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, the other map is just <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>↦</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msup><mi>f</mi><mo>∗</mo></msup><msub><mi>ϕ</mi><mi>i</mi></msub><mo>⊗</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">f \\mapsto \\sum_{i=1}^n f^*\\phi_i \\otimes w_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.104002em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathdefault\">ϕ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. But in the absence of a basis, there is no better name than \"the inverse of the natural map\".</p>\n<p>I think this is why <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  called this a trick. I guess this trick is also at the heart of classical logic: there is a natural map <code>bool -&gt; Prop</code>. Some people assert that this is a bijection, and merrily use the inverse map in their calculations. Then they prove things like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">¬</mi><mi>P</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi mathvariant=\"normal\">∃</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>P</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">(\\neg \\forall x, \\neg P x) \\to \\exists x, P x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">¬</span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathdefault\">x</span></span></span></span>, and you ask them why it's true. But because their inverse map is noncomputable, they have no way to unravel their calculations! (The vector space situation seems different though, since the inverse map is actually computable if you interpret \"W is finite-dimensional\" constructively.)</p>",
        "id": 198641609,
        "sender_full_name": "David Wärn",
        "timestamp": 1590392083
    },
    {
        "content": "<p>Right. We have a map one way with a \"formula\", and it's not bijective in general, but if V is finite-dimensional then it's an injective map between two vector spaces of the same dimension hence it must be bijective and so an inverse exists, and the inverse must exist, although might not have a \"formula\". We can get a formula but only if we pick a basis. My claim about Langlands is that this phenomenon shows up in other places eg in the definition of the local and global Langlands correspondences. I still don't understand what's going on on a conceptual level here. Is it something to do with <a href=\"https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/\">this blog post</a> or is it a different thing?</p>",
        "id": 198647589,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590396823
    },
    {
        "content": "<p>Ah, your blog post definitely seems related. Maybe the source of confusion is that you have a constructive idea of what a function is (it's something you can write down with a formula) but a non-constructive idea of what a \"proof of a proposition\" is (it just says that something is true, but not why it's true)? This is how Lean without <code>classical.choice</code> works.</p>",
        "id": 198657902,
        "sender_full_name": "David Wärn",
        "timestamp": 1590405832
    },
    {
        "content": "<p>what libraries of mathlib can i use to prove that some set is a vector space? for example real numbers</p>",
        "id": 233832154,
        "sender_full_name": "bumby bumby",
        "timestamp": 1617979123
    },
    {
        "content": "<p>That's not how things work formally. You need more than a set (in fact Lean works with type theory, not set theory, and you need more than a type). Given a random \"thing\" (e.g. a set or a type) you literally can't prove that it's a vector space, because being a vector space is not a theorem, it's a definition. What is your mathematical background?</p>",
        "id": 233833210,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617979504
    },
    {
        "content": "<p>but here says Lean allow work with abstract structures like rings, fields or vector spaces <a href=\"/user_uploads/3121/uqX5cgNDJ4atEbcViYW8Rb2p/imagen.png\">imagen.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/uqX5cgNDJ4atEbcViYW8Rb2p/imagen.png\" title=\"imagen.png\"><img src=\"/user_uploads/3121/uqX5cgNDJ4atEbcViYW8Rb2p/imagen.png\"></a></div>",
        "id": 233836376,
        "sender_full_name": "bumby bumby",
        "timestamp": 1617980497
    },
    {
        "content": "<p>There's already a discussion about this in <a href=\"#narrow/stream/113489-new-members/topic/vector.20spaces/near/233829510\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/vector.20spaces/near/233829510</a>, right?</p>",
        "id": 233836913,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617980581
    }
]
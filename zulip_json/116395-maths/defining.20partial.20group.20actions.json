[
    {
        "content": "<p>I'm trying to define partial group actions in lean (see pg. 5 of <a href=\"https://arxiv.org/pdf/1604.06393.pdf\">https://arxiv.org/pdf/1604.06393.pdf</a> for a definition). This is what I have so far, but I'm stuck:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.partial</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.support</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">filter</span> <span class=\"n\">classical</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">partial_group_action</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X'</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">X'1</span> <span class=\"o\">:</span> <span class=\"n\">X'</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">X'</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">X'</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">α1</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span><span class=\"c1\">-- Complains here because the types don't match.</span>\n</code></pre></div>\n<p>I'm not sure how to proceed here.</p>",
        "id": 265695781,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640099740
    },
    {
        "content": "<p>I would unbundle the subset requirement from the type of <code>α</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">partial_group_action</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X'</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">X'1</span> <span class=\"o\">:</span> <span class=\"n\">X'</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">α_subset</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">X'</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">)),</span> <span class=\"n\">α</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">X'</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">α1</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 265697215,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1640100306
    },
    {
        "content": "<p>I assume you mean <code>(α_subset : ∀ (g : G), x ∈ X' (g⁻¹) → α g x ∈ X' g)</code>?</p>",
        "id": 265697444,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640100408
    },
    {
        "content": "<p>Not really? We need to introduce <code>x</code>, no?</p>",
        "id": 265697640,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1640100496
    },
    {
        "content": "<p>I think Anne's approach might work better in the long run, but one alternative is to do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.partial</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.support</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">filter</span> <span class=\"n\">classical</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">partial_group_action</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X'</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">X'1</span> <span class=\"o\">:</span> <span class=\"n\">X'</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">X'</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">X'</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">α1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"mi\">1</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">X'1</span><span class=\"o\">]⟩</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">X'1</span><span class=\"o\">]⟩)</span> <span class=\"c1\">-- Complains here because the types don't match.</span>\n</code></pre></div>",
        "id": 265697784,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1640100586
    },
    {
        "content": "<p>Maybe have a look at <a href=\"https://github.com/leanprover-community/mathlib/pull/10497\">#10497</a> for a similar case where I need to define homomorphisms which partially respect some condition.</p>",
        "id": 265698539,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640100977
    },
    {
        "content": "<p>Maybe the simplest approach is to replace the α by a family of relations</p>",
        "id": 265698722,
        "sender_full_name": "Reid Barton",
        "timestamp": 1640101081
    },
    {
        "content": "<p>Does the following definition (or something similar) work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.partial</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.support</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">filter</span> <span class=\"n\">classical</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">partial_group_action</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">μ_def</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_def_id</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"mi\">1</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_def_inv</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_id</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"mi\">1</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">μ_def_id</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_def_assoc</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g₁</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"bp\">*</span> <span class=\"n\">g₂</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_assoc</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g₁</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">μ</span> <span class=\"n\">g₁</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">h'</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"bp\">*</span> <span class=\"n\">g₂</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">μ_def_assoc</span> <span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 265700482,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640101936
    },
    {
        "content": "<p>Maybe <code>μ_def_inv</code> isn't actually needed?</p>",
        "id": 265700783,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640102076
    },
    {
        "content": "<p>Presumably one should start by defining a partial monoid action...</p>",
        "id": 265700813,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640102094
    },
    {
        "content": "<p>Why the <span aria-label=\"oh no\" class=\"emoji emoji-1f615\" role=\"img\" title=\"oh no\">:oh_no:</span> ?</p>",
        "id": 265701089,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640102220
    },
    {
        "content": "<p>That sounds like a long-winded way.</p>",
        "id": 265701127,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640102238
    },
    {
        "content": "<p>I haven't seen a definition of partial monoid action.</p>",
        "id": 265701131,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640102242
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">partial_monoid_action</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">μ_def</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_def_id</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"mi\">1</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_id</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"mi\">1</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">μ_def_id</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_def_assoc</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g₁</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"bp\">*</span> <span class=\"n\">g₂</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_assoc</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g₁</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">μ</span> <span class=\"n\">g₁</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">h'</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"bp\">*</span> <span class=\"n\">g₂</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">μ_def_assoc</span> <span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 265701172,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640102263
    },
    {
        "content": "<p>I'm just guessing that would be the right definition...</p>",
        "id": 265701297,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640102301
    },
    {
        "content": "<p>Is there really no way we can recycle usual actions to make partial ones?</p>",
        "id": 265701377,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640102347
    },
    {
        "content": "<p>I thought about it, but I can't think of a way to do it.</p>",
        "id": 265701410,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640102370
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I've never seen this kind of expression before. What's going on here?</p>",
        "id": 265701694,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640102478
    },
    {
        "content": "<p>This is saying that the action of <code>g</code> on <code>x</code> will only be defined when <code>\\mu_def g x</code> holds, and will be an element of <code>X</code>.</p>",
        "id": 265701757,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640102512
    },
    {
        "content": "<p>It's simply not naming the hypothesis of type <code>g x</code> and putting stuff before the <code>:</code>.</p>",
        "id": 265701912,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640102581
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">α1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"mi\">1</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">X'1</span><span class=\"o\">]⟩</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">X'1</span><span class=\"o\">]⟩)</span>\n</code></pre></div>\n<p>This solves the problem I'm currently having. Is this not an OK approach?</p>",
        "id": 265702017,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640102637
    },
    {
        "content": "<p>Here are all the types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.partial</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.support</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">filter</span> <span class=\"n\">classical</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">partial_monoid_action</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">μ_def</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_def_id</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"mi\">1</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_id</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"mi\">1</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">μ_def_id</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_def_assoc</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g₁</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">μ_def</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"bp\">*</span> <span class=\"n\">g₂</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">μ_assoc</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">μ_def</span> <span class=\"n\">g₁</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">μ</span> <span class=\"n\">g₁</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">h'</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"bp\">*</span> <span class=\"n\">g₂</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">μ_def_assoc</span> <span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 265702152,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640102688
    },
    {
        "content": "<p>Ah, that makes it clear. Thanks.</p>",
        "id": 265702216,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640102713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416322\">Bernd Losert</span> <a href=\"#narrow/stream/116395-maths/topic/defining.20partial.20group.20actions/near/265702017\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">α1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"mi\">1</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">X'1</span><span class=\"o\">]⟩</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">X'1</span><span class=\"o\">]⟩)</span>\n</code></pre></div>\n<p>This solves the problem I'm currently having. Is this not an OK approach?</p>\n</blockquote>\n<p>You are working with subtypes with this approach, which can get annoying in the long run.</p>",
        "id": 265702223,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640102717
    },
    {
        "content": "<p>But the partial action stuff relies on subsets everywhere. I can't really escape it.</p>",
        "id": 265702287,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640102758
    },
    {
        "content": "<p>The subset <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mi>g</mi></msub></mrow><annotation encoding=\"application/x-tex\">X_g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> you defined would  become <code>set_of (μ_def g)</code></p>",
        "id": 265702419,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640102810
    },
    {
        "content": "<p>Yes.</p>",
        "id": 265702481,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640102846
    },
    {
        "content": "<p>The issue with using sets is that terms of <code>X_g</code> are <em>not</em> terms of <code>X</code>, so if you start by using such subsets, you will always need to rely on coercions..</p>",
        "id": 265702685,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640102926
    },
    {
        "content": "<p>I like your relation approach involving μ_def. I'll have to try it out.</p>",
        "id": 265702852,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640103004
    },
    {
        "content": "<p>Ultimately, I need to define continuous versions of partial group actions and then I need to talk about convergent filters on the \"domain\" of the partial action.</p>",
        "id": 265702884,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640103037
    },
    {
        "content": "<p>I see... Is there an analogue of the group chunk theorem for convergence spaces?</p>",
        "id": 265702942,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640103070
    },
    {
        "content": "<p>I can't tell if using μ_def will be easier than dealing with subsets.</p>",
        "id": 265702945,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640103071
    },
    {
        "content": "<p>A lot of the theory of partial group actions can be generalized to convergence spaces.</p>",
        "id": 265702997,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640103105
    },
    {
        "content": "<p>I don't know what the \"group chunk theorem\" is.</p>",
        "id": 265703092,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640103134
    },
    {
        "content": "<p>The context of this paper is probably the closest:<br>\n<a href=\"https://projecteuclid.org/journals/illinois-journal-of-mathematics/volume-34/issue-1/Weils-group-chunk-theorem-A-topological-setting/10.1215/ijm/1255988498.full\">https://projecteuclid.org/journals/illinois-journal-of-mathematics/volume-34/issue-1/Weils-group-chunk-theorem-A-topological-setting/10.1215/ijm/1255988498.full</a></p>",
        "id": 265703179,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640103188
    },
    {
        "content": "<p>OK.</p>",
        "id": 265703288,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640103245
    },
    {
        "content": "<p>The reason my suggestion is maybe bad is because while it works in this case you may well end up hitting other similar issues with <code>X' (g\\inv * g * h)</code> not being the same type as <code>X' h</code> or other goals like this. Probably you can always  make the statements work in the same way assuming <code>x : X</code> and <code>hx : x \\in X' g</code>, but as a general principle having the types of things depend on your variables that you are applying algebraic operations too causes headaches.</p>",
        "id": 265703536,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1640103375
    },
    {
        "content": "<p>Indeed. I'm already feeling the pain.</p>",
        "id": 265703708,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640103478
    },
    {
        "content": "<p>Thanks everyone. I will go with the relation approach for now and see where it takes me.</p>",
        "id": 265703787,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640103506
    },
    {
        "content": "<p>The approach I had in mind was something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group</span>\n<span class=\"kn\">import</span> <span class=\"n\">logic.relation</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">partial_group_action</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>          <span class=\"c1\">-- ρ g x y ↔ (α g x = y). X_{g⁻¹} = {x | ∃ y, ρ g x y}.</span>\n<span class=\"o\">(</span><span class=\"n\">ρ_bij</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">relator.bi_unique</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"n\">g</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">ρ_1</span> <span class=\"o\">:</span> <span class=\"n\">ρ</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">=</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">ρ_mul</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">relation.comp</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">ρ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">ρ_inv</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">flip</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ρ</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 265704410,
        "sender_full_name": "Reid Barton",
        "timestamp": 1640103812
    },
    {
        "content": "<p>though it's likely I have the <code>relation.comp</code> arguments backwards, and I didn't actually check that this is what the definition of a partial group action is, but I assume it ought to be</p>",
        "id": 265704577,
        "sender_full_name": "Reid Barton",
        "timestamp": 1640103876
    },
    {
        "content": "<p>The main disadvantage is you can't just apply <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> as a function</p>",
        "id": 265704670,
        "sender_full_name": "Reid Barton",
        "timestamp": 1640103927
    },
    {
        "content": "<p>Adam's definition is basically the same as your original one except that instead of taking a single argument of type which is a subtype, the operation takes two separate arguments.</p>",
        "id": 265704795,
        "sender_full_name": "Reid Barton",
        "timestamp": 1640103990
    },
    {
        "content": "<blockquote>\n<p>The main disadvantage is you can't just apply α as a function</p>\n</blockquote>\n<p>That's going to be troublesome since I want to map α to a filter. In fact, I am already going to run into a problem with Adam's definition since it requires of proof that the action is defined. There is also the problem that it's not uncurried.</p>",
        "id": 265705353,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640104290
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/defining.20partial.20group.20actions/near/265701377\">said</a>:</p>\n<blockquote>\n<p>Is there really no way we can recycle usual actions to make partial ones?</p>\n</blockquote>\n<p>Maybe I can define actions on option X?</p>",
        "id": 265707880,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640105487
    },
    {
        "content": "<p>Or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/part\">docs#part</a>, but I'm not sure that works.</p>",
        "id": 265708106,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640105603
    },
    {
        "content": "<p>I think one problem with <code>part</code> that I'll have is mapping the action over a filter.</p>",
        "id": 265708651,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1640105859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416322\">Bernd Losert</span> <a href=\"#narrow/stream/116395-maths/topic/defining.20partial.20group.20actions/near/265705353\">said</a>:</p>\n<blockquote>\n<p>That's going to be troublesome since I want to map α to a filter.</p>\n</blockquote>\n<p>Mathematically this shouldn't be a problem (a relation can be viewed as a kind of span, and you can <code>comap</code> and then <code>map</code> across the legs of the span) but mathlib might not have good existing support for this operation.</p>",
        "id": 265710146,
        "sender_full_name": "Reid Barton",
        "timestamp": 1640106600
    }
]
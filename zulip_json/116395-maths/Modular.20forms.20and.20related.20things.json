[
    {
        "content": "<p>So I think its time I start trying to get some of the modular forms code and related things PR'd. The issue is that I have several files with lots of dependencies, so what is the best thing to do? Should each file be a separate PR? </p>\n<p>I've made a draft PR here <a href=\"https://github.com/leanprover-community/mathlib/pull/8979\">https://github.com/leanprover-community/mathlib/pull/8979</a>, so any advice on how to split things is welcome.</p>\n<p>It basically contains the definitions of modular forms, a definition of holomorphic functions, and facts about <code>SL(2,Z)</code> , including that it is generated by two well-known matrices \"S\" and \"T\". (There are also things like the Weierstrass M-test and a definition of the Riemann zeta function (for real values), but these should be easier to split off).</p>",
        "id": 251898334,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630683016
    },
    {
        "content": "<p>Is  <a href=\"https://github.com/leanprover-community/mathlib/issues/8611\">#8611</a> related?</p>",
        "id": 251898835,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1630683203
    },
    {
        "content": "<p>A PR should be a couple of hundred lines at most, really, so even some of those single files are too long for one PR. It will be a lot of effort getting this stuff into mathlib (but this effort should be undertaken!).</p>",
        "id": 251898854,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630683210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/251898835\">said</a>:</p>\n<blockquote>\n<p>Is  <a href=\"https://github.com/leanprover-community/mathlib/issues/8611\">#8611</a> related?</p>\n</blockquote>\n<p>Yes I used some of the definitions from here! But also extended some of the things in this PR.<br>\nEdit: or at least I used things from a recent PR related to this</p>",
        "id": 251899019,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630683267
    },
    {
        "content": "<p>Maybe you could start with a <code>general_linear_group.lean</code> PR and/or a Weierstrass M test PR?</p>",
        "id": 251899033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630683271
    },
    {
        "content": "<p>Note that making a PR is hard work and takes some time. Do you already have push access to non-master branches of mathlib?</p>",
        "id": 251899107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630683298
    },
    {
        "content": "<p>Yeah the <code>general_linear_group</code> is on the way.</p>",
        "id": 251899165,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630683311
    },
    {
        "content": "<p>and yes the M-test should be fine on its own. The issue is where there are several things with dependencies. I guess if you're saying each PR should only be a couple of hundred lines then that tells me what to do.</p>",
        "id": 251899499,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630683415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/251899107\">said</a>:</p>\n<blockquote>\n<p>Note that making a PR is hard work and takes some time. Do you already have push access to non-master branches of mathlib?</p>\n</blockquote>\n<p>yes</p>",
        "id": 251899587,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630683455
    },
    {
        "content": "<p>Other relatively straightforward things to do could be to PR short lemmas which you needed and which weren't in the API already (i.e. a PR with just one lemma in), e.g. the lemmas at the start of <code>SL2Z_generators.lean</code> shouldn't be in that file (and could well be in mathlib already, but if they're not then they could be made into a PR to data.int.basic and other appropriate places)</p>",
        "id": 251900181,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630683689
    },
    {
        "content": "<p>What is the consensus about holomorphic functions? Holomorphic on open subset of <code>C</code> is general enough? I think we really need to have <code>complex_analysis.lean</code> in mathlib...</p>",
        "id": 251900313,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1630683733
    },
    {
        "content": "<p>Well the upper half plane is now a type of its own!</p>",
        "id": 251900368,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630683757
    },
    {
        "content": "<p>We already have analytic functions.</p>",
        "id": 251900501,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1630683813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/251900313\">said</a>:</p>\n<blockquote>\n<p>What is the consensus about holomorphic functions? Holomorphic on open subset of <code>C</code> is general enough? I think we really need to have <code>complex_analysis.lean</code> in mathlib...</p>\n</blockquote>\n<p>Yeah I don't really feel qualified to make the holomorphic definition, but I needed it so just went with that for now. Not that I can prove anything is holomorphic, so can definitely change once someone with more authority makes the correct definition</p>",
        "id": 251900634,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630683852
    },
    {
        "content": "<p>I have to catch up what happened in mathlib in the last month, but I am pretty sure we don't want to develop complex analysis for holomorphic functions over <code>H</code>, or <code>C</code> or whatever, but at least over any open subset of <code>C</code></p>",
        "id": 251900782,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1630683918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/251900501\">said</a>:</p>\n<blockquote>\n<p>We already have analytic functions.</p>\n</blockquote>\n<p>Yes I think this is what I should use instead. I did have some issues in that lots of things wanted my maps to be from <code>C</code> to <code>C</code> and not from an open subset to <code>C</code> so the extend_by_zero was a hack from Kevins birthday repo that I used.</p>",
        "id": 251900958,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630683997
    },
    {
        "content": "<p>Looking at Chris' code, I begin to think mathlib is missing some theory on (local) uniform convergence.  We have the definitions <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tendsto_uniformly_on\">docs#tendsto_uniformly_on</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tendsto_locally_uniformly_on\">docs#tendsto_locally_uniformly_on</a>, but it would be nice to have <code>topological_space</code> instances on <code>α → β</code> such that these definitions are precisely <code>filter.tendsto</code> for those topologies.</p>",
        "id": 251923530,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1630693733
    },
    {
        "content": "<p>There also seems to be glue missing between <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tendsto_uniformly_on\">docs#tendsto_uniformly_on</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function\">docs#bounded_continuous_function</a></p>",
        "id": 251925504,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1630694731
    },
    {
        "content": "<p>With those in place, you have the Weierstrass M-test as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/summable_of_norm_bounded\">docs#summable_of_norm_bounded</a>.</p>",
        "id": 251927043,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1630695482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/251923530\">said</a>:</p>\n<blockquote>\n<p>Looking at Chris' code, I begin to think mathlib is missing some theory on (local) uniform convergence.  We have the definitions <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tendsto_uniformly_on\">docs#tendsto_uniformly_on</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tendsto_locally_uniformly_on\">docs#tendsto_locally_uniformly_on</a>, but it would be nice to have <code>topological_space</code> instances on <code>α → β</code> such that these definitions are precisely <code>filter.tendsto</code> for those topologies.</p>\n</blockquote>\n<p>Possibly related: <a href=\"#narrow/stream/116395-maths/topic/Metrisability.20of.20compact-open.20topology/near/251696483\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Metrisability.20of.20compact-open.20topology/near/251696483</a></p>",
        "id": 251935593,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1630699904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/251927043\">said</a>:</p>\n<blockquote>\n<p>With those in place, you have the Weierstrass M-test as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/summable_of_norm_bounded\">docs#summable_of_norm_bounded</a>.</p>\n</blockquote>\n<p>Yes I must admit, you mentioned proving it this way but I haven't had the chance to think about it this way.  I PR'd the version I have, but do you think proving it this way would be better?</p>",
        "id": 251991120,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630752163
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> Indeed it seems quite closely related.  Will continue the discussion over there ...</p>",
        "id": 252100610,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1630874484
    },
    {
        "content": "<p>So I'm a bit lost as to what to do about the complex holomorphic definition. Originally I used this</p>\n<p><code>def is_holomorphic_on {D : open_subs} (f : D.1 → ℂ) : Prop :=\n  ∀ z : D.1, ∃ f', has_deriv_within_at (extend_by_zero f) (f') D.1 z</code></p>\n<p>as my definition,  which I can prove forms ring. There is also enough in mathlib to prove </p>\n<p><code>lemma is_holomorphic_on_iff_differentiable_on  (D : open_subs) (f : D.1 → ℂ):\n  differentiable_on ℂ  (extend_by_zero f) D.1 ↔ is_holomorphic_on f:=</code></p>\n<p>Now, as far as I can tell we don't have an <code>analytic_on</code> definition, but we do have <code>analytic_at</code>, so the extension wouldn't be an issue. The issue is as far as I can see, we don't have a result (or at least I can't find) that says the product of two analytic functions is analytic. So I guess these things would need to be added.</p>\n<p>I guess all of these definitions also have the slight annoyance that if one wants functions only defined on some open subset, then we need to use an <code>extend_by_zero</code> or similar, since as far as I can see all of these definitions are for functions between normed  vector spaces. Is there a better way around this?</p>\n<p>So  there seem to be three possibilities  for complex holomorphic functions, so my question is what should I use? are we close enough to having the necessary machinery for proving that they are all equivalent and therefore it makes no difference?</p>",
        "id": 252156871,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630924571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"389019\">@Chris Birkbeck</span> Isn't this a bit of a moot point? We don't have the tools yet to prove the functions you're interested in are holomorphic, right?  (You're interested in the Eisenstein series for the modular group, and in the Riemann zeta function, and if I understand correctly both of these require the theorem that a uniform limit of holomorphic functions is holomorphic.)</p>",
        "id": 252178574,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1630936320
    },
    {
        "content": "<p>I think that <code>differentiable_on</code> or <code>mdifferentiable_on</code> are the definitions for which we are most likely, soon-ish, to be able to prove that a uniform limit of holomorphic functions is holomorphic.  (This is via Yury's WIP on Stokes.)</p>",
        "id": 252178934,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1630936470
    },
    {
        "content": "<p>So you could either work with functions <code>f : ℂ → ℂ</code> which are <code>differentiable_on D</code>, or with functions <code>f : ℍ → ℂ</code> which are <code>mdifferentiable</code>.</p>",
        "id": 252179225,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1630936604
    },
    {
        "content": "<p>Ah so you're saying I should just wait until we have have the uniform limit of holo is holo proven and then go with that definition of holomorphic? I guess that is very reasonable.</p>",
        "id": 252179259,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630936622
    },
    {
        "content": "<p>Can on do <code>differentiable_on D</code>? I thought the D would have to be a normed vector space</p>",
        "id": 252179429,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630936704
    },
    {
        "content": "<p>No, here <code>ℂ</code> is the normed vector space, so you consider functions on <code>ℂ</code> which are <code>differentiable_on D</code> (and just consider the values outside <code>D</code> as junk values).</p>",
        "id": 252179499,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1630936752
    },
    {
        "content": "<p>Aha I get you, this is what I was doing with the <code>extend_by_zero</code>.</p>",
        "id": 252179639,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630936812
    },
    {
        "content": "<p>Right, but don't literally extend by zero, instead just start with a function on the whole of <code>ℂ</code>.</p>",
        "id": 252179929,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1630936936
    },
    {
        "content": "<p>Hmm but is that what we want? I only want to define modular forms on the upper half plane,  so maybe using  <code>mdifferentiable</code> is better (if it lets you work with <code>f : ℍ → ℂ</code>).</p>",
        "id": 252180245,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630937088
    },
    {
        "content": "<p>tbh I didn't know about <code>mdifferentiable_on</code> until now, but looking at it quickly it might be the best choice.</p>",
        "id": 252180537,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630937211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"389019\">Chris Birkbeck</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/252180245\">said</a>:</p>\n<blockquote>\n<p>Hmm but is that what we want? I only want to define modular forms on the upper half plane,  so maybe using  <code>mdifferentiable</code> is better (if it lets you work with <code>f : ℍ → ℂ</code>).</p>\n</blockquote>\n<p>btw this is just a personal preference, it would just feel weird having modular forms  defined on the complex plane who satisfy some tranformation property on <code>ℍ </code>, it seems this would get messy</p>",
        "id": 252180806,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630937348
    },
    {
        "content": "<p>To use <code>mdifferentiable</code> you will need to establish that the upper half-plane is a manifold.  But this is not very difficult.  Use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_space.opens.smooth_manifold_with_corners\">docs#topological_space.opens.smooth_manifold_with_corners</a> probably.</p>",
        "id": 252194831,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1630943973
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"389019\">@Chris Birkbeck</span> Here's how I would set up the Eisenstein series construction.  Following mathlib standard notation, denote by <code>C(ℍ, ℂ)</code> the space of continuous functions on the upper half-plane, equipped with the compact-open topology (i.e., the topology of locally uniform convergence).  For now you would just like to construct <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mrow><mn>2</mn><mi>k</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">G_{2k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as an element of <code>C(ℍ, ℂ)</code>, although eventually (when more complex analysis is available in mathlib) you will want to prove it is holomorphic.</p>\n<p>Let's slightly modify what you wrote in your file and start by defining</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Eise</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">×</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">ℍ</span><span class=\"o\">,</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"n\">x.1</span><span class=\"bp\">*</span><span class=\"n\">z</span><span class=\"bp\">+</span><span class=\"n\">x.2</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"bp\">...</span> <span class=\"n\">proof</span> <span class=\"n\">of</span> <span class=\"n\">continuity</span> <span class=\"bp\">...</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>You want to prove <code>∀ k, summable (Eise k)</code>, i.e. that for each <code>k</code> the Eisenstein series is summable locally uniformly.</p>\n<p>It will turn out that there is a family of seminorms on <code>C(ℍ, ℂ)</code>, parametrized by the compact subsets <code>s</code> of <code>ℍ</code>, which induce topologies <code>uniform_on ℂ s</code> on <code>C(ℍ, ℂ)</code> (the topologies of uniform convergence on the <code>s</code>), with the following property:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">summable_compact_open_iff_forall</span> <span class=\"o\">[</span><span class=\"n\">locally_compact_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">summable</span> <span class=\"n\">F</span>\n  <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">summable</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">uniform_on</span> <span class=\"n\">β</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>(This is what Oliver and I were discussing in the other stream.  See <a href=\"https://github.com/leanprover-community/mathlib/tree/compact-open-gluing\">branch#compact-open-gluing</a> for a sketch, with some sorries.)</p>\n<p>Then you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/summable_of_norm_bounded\">docs#summable_of_norm_bounded</a> as I was suggesting, and your proof obligation becomes: prove that for any compact subset <code>s</code> of <code>ℍ</code>, there exists a summable nonnegative function <code>M : ℤ × ℤ → ℝ</code>, such that the sup-norm of <code>Eise k x</code> over the set <code>s</code> is at most <code>M x</code>.  (You can do this using the \"strip\" argument which you have written the beginnings of.)</p>\n<p>Let me know if you think this approach will work.  I think it should be more efficient, in the sense of making the \"end-user\" (modular forms) files as short as possible.</p>",
        "id": 252246795,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1630986134
    },
    {
        "content": "<p>Yes I think working with <code>C(ℍ, ℂ)</code> is a good idea, thank you. I'm busy today, but I'll start translating things into this language tomorrow and see how it goes.</p>",
        "id": 252260912,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1630998524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/252246795\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"389019\">Chris Birkbeck</span> Here's how I would set up the Eisenstein series construction.  Following mathlib standard notation, denote by <code>C(ℍ, ℂ)</code> the space of continuous functions on the upper half-plane, equipped with the compact-open topology (i.e., the topology of locally uniform convergence).  For now you would just like to construct <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mrow><mn>2</mn><mi>k</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">G_{2k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> as an element of <code>C(ℍ, ℂ)</code>, although eventually (when more complex analysis is available in mathlib) you will want to prove it is holomorphic.</p>\n<p>Let's slightly modify what you wrote in your file and start by defining</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Eise</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">×</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">ℍ</span><span class=\"o\">,</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"n\">x.1</span><span class=\"bp\">*</span><span class=\"n\">z</span><span class=\"bp\">+</span><span class=\"n\">x.2</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"bp\">...</span> <span class=\"n\">proof</span> <span class=\"n\">of</span> <span class=\"n\">continuity</span> <span class=\"bp\">...</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>You want to prove <code>∀ k, summable (Eise k)</code>, i.e. that for each <code>k</code> the Eisenstein series is summable locally uniformly.</p>\n<p>It will turn out that there is a family of seminorms on <code>C(ℍ, ℂ)</code>, parametrized by the compact subsets <code>s</code> of <code>ℍ</code>, which induce topologies <code>uniform_on ℂ s</code> on <code>C(ℍ, ℂ)</code> (the topologies of uniform convergence on the <code>s</code>), with the following property:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">summable_compact_open_iff_forall</span> <span class=\"o\">[</span><span class=\"n\">locally_compact_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">summable</span> <span class=\"n\">F</span>\n  <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">summable</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">uniform_on</span> <span class=\"n\">β</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>(This is what Oliver and I were discussing in the other stream.  See <a href=\"https://github.com/leanprover-community/mathlib/tree/compact-open-gluing\">branch#compact-open-gluing</a> for a sketch, with some sorries.)</p>\n<p>Then you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/summable_of_norm_bounded\">docs#summable_of_norm_bounded</a> as I was suggesting, and your proof obligation becomes: prove that for any compact subset <code>s</code> of <code>ℍ</code>, there exists a summable nonnegative function <code>M : ℤ × ℤ → ℝ</code>, such that the sup-norm of <code>Eise k x</code> over the set <code>s</code> is at most <code>M x</code>.  (You can do this using the \"strip\" argument which you have written the beginnings of.)</p>\n<p>Let me know if you think this approach will work.  I think it should be more efficient, in the sense of making the \"end-user\" (modular forms) files as short as possible.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>  So I was just looking at some of the new additions relating to the compact-open topology. Has <code>summable_compact_open_iff_forall</code> also been PR'd? I couldn't find it.</p>",
        "id": 255388156,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1632917848
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"389019\">@Chris Birkbeck</span> Sorry for not updating you.  Since <a href=\"https://github.com/leanprover-community/mathlib/issues/9240\">#9240</a> you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.continuous_function.algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.compact_open</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.algebra.infinite_sum</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_continuous_add</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">restrict_sum</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrict</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrict</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">summable_compact_open_iff_forall</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">locally_compact_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">summable</span> <span class=\"n\">F</span>\n  <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">summable</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrict</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">continuous_map.exists_tendsto_compact_open_iff_forall</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(in fact these should both be added as lemmas at some point).  What's left (<span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> is working on it) is to show that on a compact space <code>α</code>, the compact-open topology is the same as the topology induced by the sup-norm.</p>",
        "id": 255415979,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1632928193
    },
    {
        "content": "<p>It's true that I promised Heather I'm working on it but I must confess it will be at least a week before I take this up again, and furthermore this has been the case for several weeks!</p>",
        "id": 255416220,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1632928278
    },
    {
        "content": "<p>(I do want to get to this though.)</p>",
        "id": 255416284,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1632928304
    },
    {
        "content": "<p>Oh no don't worry, I was just wondering if I'd missed it! I'm not in a huge rush as the other complex analysis parts are still being done. But I'm glad this is still moving forward :)</p>",
        "id": 255416824,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1632928480
    },
    {
        "content": "<p>Ok so <a href=\"https://github.com/leanprover-community/mathlib/pull/8979\">#8979</a> now has a definition of modular forms , Eisenstein series and a sorry-free proof Eisenstein series are modular forms. Its still really just a  \"test area\", i.e. a huge mess, but at least I can see now what things are good and bad with my current definition of modular forms. The main missing result was the \"uniform limit of holomorphic functions is holomorphic\" but it is possible to get this using <a href=\"https://github.com/leanprover-community/mathlib/pull/10000\">#10000</a> (but what is in <a href=\"https://github.com/leanprover-community/mathlib/pull/8979\">#8979</a> is probably not really the neatest way of doing this). </p>\n<p>What I want to start thinking about is breaking this up into PR-able chunks. One of the first things that I want to fix with the current definition of modular forms are \"coe\" issues. For example, I defined the action of <code>GL_pos (fin 2) ℝ</code> on the <code>upper_half_plane</code> but at some points one wants to take a matrix in  <code>SL(2,ℤ)</code> or some subgroup of this, and make them act on the <code>upper_half_plane</code>. But this ends up being a pain with how I've currently done it (at the moment there are lots of ugly coe lemmas to just get it done). Is there a particularly nice way to give an action of a group <code>G</code> on a set <code>X</code> which behaves nicely when restricting to subgroups of <code>G</code> or subgroups of subgroups of <code>G</code> and so on?</p>\n<p>Similarly, I wonder if modular forms should be defined as  functions <code>ℂ → ℂ</code> which satisfy some properties on <code>ℍ</code>. Instead of functions <code>ℍ → ℂ</code>. I think the former probably is probably a better fit with other things (such as <code>differentiable_on</code>), but also one sometimes wants to say things like <code>f(1+z)=f(z)</code> for <code>z : ℍ</code>, but one then needs to give <code>ℍ</code> an <code>add_action ℤ ℍ</code>, which one would have already if one worked with <code>ℂ</code> instead. That said, it does still make me uneasy having modular forms defined on all the complex numbers...</p>\n<p>In any case, any ideas on how to approach there issues are most welcome!</p>",
        "id": 266715152,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1641231953
    },
    {
        "content": "<p>I doubt SL_2(Z) is a subgroup of GL_pos(fin2) R as far as Lean is concerned!</p>",
        "id": 266721866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641235450
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266721866\">said</a>:</p>\n<blockquote>\n<p>I doubt SL_2(Z) is a subgroup of GL_pos(fin2) R as far as Lean is concerned!</p>\n</blockquote>\n<p>OK you got me there! I guess I mean subgroups of <code>SL(2,Z)</code> coerced into <code>GL_pos</code></p>",
        "id": 266722068,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1641235593
    },
    {
        "content": "<p>If you define modular forms as functions on the complexes then you'd better have some extra axiom such as Im(z)&lt;=0 -&gt; f(z)=0, or else you'll run into problems with different functions agreeing on the upper half plane but not being equal modular forms. I don't see what's wrong with this approach though -- we use it in lots of other places. However GL_pos (fin 2) R and SL(2,Z) don't act on the complex numbers so then you get problems elsewhere.</p>",
        "id": 266722077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641235600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"389019\">Chris Birkbeck</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266722068\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266721866\">said</a>:</p>\n<blockquote>\n<p>I doubt SL_2(Z) is a subgroup of GL_pos(fin2) R as far as Lean is concerned!</p>\n</blockquote>\n<p>OK you got me there! I guess I mean subgroups of <code>SL(2,Z)</code> coerced into <code>GL_pos</code></p>\n</blockquote>\n<p>We should surely have that if G -&gt; H is a group hom and H acts on X then there's an induced action of G on X?</p>",
        "id": 266722137,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641235644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266722137\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"389019\">Chris Birkbeck</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266722068\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266721866\">said</a>:</p>\n<blockquote>\n<p>I doubt SL_2(Z) is a subgroup of GL_pos(fin2) R as far as Lean is concerned!</p>\n</blockquote>\n<p>OK you got me there! I guess I mean subgroups of <code>SL(2,Z)</code> coerced into <code>GL_pos</code></p>\n</blockquote>\n<p>We should surely have that if G -&gt; H is a group hom and H acts on X then there's an induced action of G on X?</p>\n</blockquote>\n<p>ah yes good point. The issue might be that I didnt define them a group homs! just coes, I'll go back and check</p>",
        "id": 266722271,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1641235715
    },
    {
        "content": "<p>Can scalar towers be used, so that you don't have to coerce so much?</p>",
        "id": 266724988,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1641237053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266724988\">said</a>:</p>\n<blockquote>\n<p>Can scalar towers be used, so that you don't have to coerce so much?</p>\n</blockquote>\n<p>Maybe. I must admit I've yet to look at how they work and how much they help with coe issues!</p>",
        "id": 266727649,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1641238386
    },
    {
        "content": "<p>Can you define modular forms as functions from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">H</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{H}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">H</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> with the right equivariance property, and which are complex-differentiable (when you see <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">H</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{H}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">H</span></span></span></span> as a complex manifold)?</p>",
        "id": 266728062,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1641238593
    },
    {
        "content": "<p>Long story short, instead of coercing you can make groups act on each other, like <code>A</code> on <code>B</code>, <code>C</code>, <code>D</code>, <code>B</code> on <code>C</code>, <code>D</code>, <code>C</code> on <code>D</code>... Then <code>is_scalar_tower</code>will state that the scalar multiplications associate with each other.</p>",
        "id": 266728162,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641238669
    },
    {
        "content": "<p>(Unless you want to define them as sections of some vector bundle, for which the differential geometry machinery will be even more useful).</p>",
        "id": 266728177,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1641238677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266728062\">said</a>:</p>\n<blockquote>\n<p>Can you define modular forms as functions from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">H</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{H}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">H</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> with the right equivariance property, and which are complex-differentiable (when you see <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">H</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{H}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">H</span></span></span></span> as a complex manifold)?</p>\n</blockquote>\n<p>Yes this is something I was weighing up.  When I first started I didn't know about <code>mdifferentiable</code> which would be one way of doing this. This is probably the most pleasing definition, but I don't know how well it would end up playing with the other analysis things</p>",
        "id": 266728415,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1641238813
    },
    {
        "content": "<p>By which you mean you don't know how easy it would be to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>m</mi><mo separator=\"true\">,</mo><mi>n</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>m</mi><mi>z</mi><mo>+</mo><mi>n</mi><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mi>k</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\sum_{m,n}(mz+n)^{-k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span></span> is a modular form with this definition?</p>",
        "id": 266728496,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641238854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266728162\">said</a>:</p>\n<blockquote>\n<p>Long story short, instead of coercing you can make groups act on each other, like <code>A</code> on <code>B</code>, <code>C</code>, <code>D</code>, <code>B</code> on <code>C</code>, <code>D</code>, <code>C</code> on <code>D</code>... Then <code>is_scalar_tower</code>will state that the scalar multiplications associate with each other.</p>\n</blockquote>\n<p>Aha I see, so I make all my groups act on each other via multiplication, but then also , each on the upper half plane? and then scalar_tower will say that the actions all work out?</p>",
        "id": 266728566,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1641238896
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266728496\">said</a>:</p>\n<blockquote>\n<p>By which you mean you don't know how easy it would be to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>m</mi><mo separator=\"true\">,</mo><mi>n</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>m</mi><mi>z</mi><mo>+</mo><mi>n</mi><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mi>k</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\sum_{m,n}(mz+n)^{-k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span></span> is a modular form with this definition?</p>\n</blockquote>\n<p>Exactly!</p>",
        "id": 266728646,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1641238930
    },
    {
        "content": "<p>But do you ever use this coercion from SL_2(Z) to SL_2(R) anyway? You'd be replacing it with an explicit function if you did this. Can you just make do with defining an action of SL_2(Z) on H?</p>",
        "id": 266728675,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641238952
    },
    {
        "content": "<p>It might be just as easy, I just haven't looked at <code>mdifferentiable</code> enough</p>",
        "id": 266728687,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1641238962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266728675\">said</a>:</p>\n<blockquote>\n<p>But do you ever use this coercion from SL_2(Z) to SL_2(R) anyway? You'd be replacing it with an explicit function if you did this. Can you just make do with defining an action of SL_2(Z) on H?</p>\n</blockquote>\n<p>Well eventually we'll want Hecke operators, so I wanted to use <code>GL_pos</code> for this reason.</p>",
        "id": 266728767,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1641239011
    },
    {
        "content": "<p>But then you only need GL_2^+(Q)</p>",
        "id": 266728807,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641239038
    },
    {
        "content": "<p>Oh yeah, sure the reals are just there because I thought being more general would appease the mathlib gods more.</p>",
        "id": 266728934,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1641239105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266728062\">said</a>:</p>\n<blockquote>\n<p>Can you define modular forms as functions from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">H</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{H}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">H</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> with the right equivariance property, and which are complex-differentiable (when you see <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">H</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{H}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">H</span></span></span></span> as a complex manifold)?</p>\n</blockquote>\n<p>I agree with this.</p>",
        "id": 266740012,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641246168
    },
    {
        "content": "<p>And I still think that the Weierstrass M-test should be deduced as a simple consequence of the identification of the sup-norm topology with the compact-open topology -- did you encounter difficulties in doing it this way?</p>",
        "id": 266740192,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641246274
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"389019\">@Chris Birkbeck</span> See <a href=\"https://github.com/leanprover-community/mathlib/pull/11229\">#11229</a>; this should be able to replace your Weierstrass M-test.</p>",
        "id": 266779097,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641283362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266740192\">said</a>:</p>\n<blockquote>\n<p>And I still think that the Weierstrass M-test should be deduced as a simple consequence of the identification of the sup-norm topology with the compact-open topology -- did you encounter difficulties in doing it this way?</p>\n</blockquote>\n<p>Oh no I've just not gotten around to doing this way yet. Since I was just aiming for a sorry-free statement I just left the old version which I already had. My intention is to do it the way you suggested for the PR'ed version. Similarly, I think it was you who told me about <code>mdifferentiable</code>. I think this might be the way to go in the end, I just went with <code>differentiable_on</code> as a first attempt as that was what is in <a href=\"https://github.com/leanprover-community/mathlib/pull/10000\">#10000</a></p>",
        "id": 266784266,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1641287206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Modular.20forms.20and.20related.20things/near/266779097\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"389019\">Chris Birkbeck</span> See <a href=\"https://github.com/leanprover-community/mathlib/pull/11229\">#11229</a>; this should be able to replace your Weierstrass M-test.</p>\n</blockquote>\n<p>This looks great! exactly what is needed, thank you!</p>",
        "id": 266784317,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1641287249
    }
]
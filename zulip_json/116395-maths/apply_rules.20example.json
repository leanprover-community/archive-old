[
    {
        "content": "<p>I thought this might be a clever way to automate simple continuity proofs, but it's not working except on the very simplest case. I would be looking to recover a proof like this, which seems reasonably similar to the example for <code>apply_rules</code> in the docs. </p>\n<div class=\"codehilite\"><pre><span></span>theorem continuous_sin_sin_sin : continuous (λ (x : ℝ), sin (sin (sin x))) :=\ncontinuous.comp (continuous.comp continuous_sin continuous_sin) continuous_sin\n</pre></div>\n\n\n<p>Here's what I tried:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">intervals</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">exponential</span>\n<span class=\"kn\">open</span> <span class=\"n\">real</span> <span class=\"n\">set</span>\n\n<span class=\"c1\">-- * sin(sin(x)) and friends are continuous on ℝ</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">user_attribute</span><span class=\"o\">]</span>\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">cts_rules</span> <span class=\"o\">:</span> <span class=\"n\">user_attribute</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">cts_rules</span><span class=\"o\">,</span>\n  <span class=\"n\">descr</span> <span class=\"o\">:=</span> <span class=\"s2\">&quot;lemmas usable to prove continuity&quot;</span> <span class=\"o\">}</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">cts_rules</span><span class=\"o\">]</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">continuous_sin</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">continuous_sin&#39;</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">apply_rules</span> <span class=\"o\">[</span><span class=\"n\">cts_rules</span><span class=\"o\">]</span> <span class=\"mi\">3</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">continuous_sin&#39;</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">continuous_sin_sin</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">sin</span><span class=\"o\">(</span><span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">apply_rules</span> <span class=\"o\">[</span><span class=\"n\">cts_rules</span><span class=\"o\">]</span> <span class=\"mi\">6</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">continuous_sin_sin_sin</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">sin</span> <span class=\"o\">(</span><span class=\"n\">sin</span> <span class=\"o\">(</span><span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">refine</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"n\">refine</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">continuous_sin</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">continuous_sin</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">continuous_sin</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">continuous_sin_sin_sin</span>\n</pre></div>",
        "id": 165911155,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558107921
    },
    {
        "content": "<p>I guess <code>apply_rules</code> doesn't know how to do the equivalent of <code>refine</code>, is that correct?</p>",
        "id": 165911338,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558108048
    },
    {
        "content": "<p>Digging into the code, I guess the name <code>apply_rules</code> says it all.  </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">apply_list_expr</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>     <span class=\"o\">:=</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;no matching rule&quot;</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span> <span class=\"n\">interactive</span><span class=\"bp\">.</span><span class=\"n\">concat_tags</span> <span class=\"o\">(</span><span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">apply_list_expr</span> <span class=\"n\">t</span>\n</pre></div>",
        "id": 165912611,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558108885
    },
    {
        "content": "<p>This example has come up before. One problem is that <code>apply</code> is not smart enough to insert the right number of <code>_</code>s to make <code>apply continuous.comp</code> work. If I recall correctly it is related to the fact that <code>continuous f</code> is itself a Pi-type (for all <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span>, if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span> is open then ...). Another problem is that blindly applying <code>continuous.comp</code> is not a good idea either--even if the function we're trying to prove continuous is not visibly a composition, applying <code>continuous.comp</code> will succeed in writing it as the composition of itself and the identity.</p>",
        "id": 165913561,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558109588
    },
    {
        "content": "<p>i wonder why marking <code>continuous.comp</code> and <code>continuous_sin</code> as <code>simp</code> doesn't cause them to trigger when trying to prove <code>continuous (sin \\circ sin)</code> with <code>simp</code></p>",
        "id": 165916682,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1558112079
    },
    {
        "content": "<p>marking<code> continuous.comp</code> with <code>simp</code> has no effect, because it has proof assumptions. I think it might have an effect if you use <code>simp * at *</code> and there is a local constant of type <code>continuous sin</code>.</p>",
        "id": 165916835,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1558112207
    },
    {
        "content": "<p>i'm puzzled because we solved a <a href=\"https://github.com/flypitch/flypitch/blob/f24b0581b10012769ad8ce7ce87df6fcffd6bce8/src/bvm.lean#L552\" target=\"_blank\" title=\"https://github.com/flypitch/flypitch/blob/f24b0581b10012769ad8ce7ce87df6fcffd6bce8/src/bvm.lean#L552\">similar problem</a> (generating Boolean-valued congruence lemmas) in <code>flypitch</code> in exactly this way, where the <code>simp</code> lemmas also had proof assumptions (you can see where they're used in the source code as <code>change B_ext _, simp</code>)</p>\n<p>in that case, there are multiple operations (binary inf and sup, indexed Inf and Sup) and <code>simp</code> seems to know how to break apart the expressions and recursively fulfill the new proof obligations</p>",
        "id": 165917644,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1558112814
    },
    {
        "content": "<p>I'm confused. Everywhere <code>change B_ext _, simp</code> is used that I saw, the only <code>simp</code> lemma used was <code>bSet.B_ext_mem_right</code> which has no assumptions to prove.</p>",
        "id": 165919758,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1558114266
    },
    {
        "content": "<p>I suppose each of the problems Reid mentioned could be tackled head on.</p>\n<p>Each lemma here always has the same number of underscores, so that could be preprogrammed rather then guessed. </p>\n<p>I suppose there must be some way to tell if a function is a composition, so that the application of <code>continuous.comp</code> can be constrained.</p>",
        "id": 165920073,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558114494
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> that's odd---was that from <code>squeeze_simp</code>? on my machine, if i <code>squeeze_simp</code> the <code>change B_ext _, simp</code> in <code>theorem bSet_axiom_of_infinity'</code> (line 1750), i get</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">bSet</span><span class=\"bp\">.</span><span class=\"n\">subst_congr_inf</span><span class=\"o\">,</span>\n <span class=\"n\">bSet</span><span class=\"bp\">.</span><span class=\"n\">subst_congr_supr</span><span class=\"o\">,</span>\n <span class=\"n\">bSet</span><span class=\"bp\">.</span><span class=\"n\">subst_congr_const</span><span class=\"o\">,</span>\n <span class=\"n\">bSet</span><span class=\"bp\">.</span><span class=\"n\">mem</span><span class=\"o\">,</span>\n <span class=\"n\">bSet</span><span class=\"bp\">.</span><span class=\"n\">B_ext_mem_left</span><span class=\"o\">,</span>\n <span class=\"n\">forall_true_iff</span><span class=\"o\">]</span>\n</pre></div>\n\n\n<p>(<code>subst_congr</code> and <code>B_ext</code> are unfortunately synonymous prefixes)</p>",
        "id": 165921532,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1558115566
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"122022\">@Joseph Corneli</span> maybe there's a <code>meta</code> way to query Lean for the number of explicit arguments for a lemma?</p>",
        "id": 165921734,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1558115697
    },
    {
        "content": "<p>I've tried making a (simple) variant of <code>apply_rules</code> that can also do <code>refine</code>, but I've run into an unexpected syntax problem.  I don't want to detract from a wider and more interesting discussion with a \"debug my code\" discussion, but might get another thread going, because I'm likely to stay stuck.</p>",
        "id": 165922628,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558116335
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> that's odd---was that from <code>squeeze_simp</code>? on my machine, if i <code>squeeze_simp</code> the <code>change B_ext _, simp</code> in <code>theorem bSet_axiom_of_infinity'</code> (line 1750), i get</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">bSet</span><span class=\"bp\">.</span><span class=\"n\">subst_congr_inf</span><span class=\"o\">,</span>\n <span class=\"n\">bSet</span><span class=\"bp\">.</span><span class=\"n\">subst_congr_supr</span><span class=\"o\">,</span>\n <span class=\"n\">bSet</span><span class=\"bp\">.</span><span class=\"n\">subst_congr_const</span><span class=\"o\">,</span>\n <span class=\"n\">bSet</span><span class=\"bp\">.</span><span class=\"n\">mem</span><span class=\"o\">,</span>\n <span class=\"n\">bSet</span><span class=\"bp\">.</span><span class=\"n\">B_ext_mem_left</span><span class=\"o\">,</span>\n <span class=\"n\">forall_true_iff</span><span class=\"o\">]</span>\n</pre></div>\n\n\n<p>(<code>subst_congr</code> and <code>B_ext</code> are unfortunately synonymous prefixes)</p>\n</blockquote>\n<p>I didn't look at that one. I'm confused about that. <code>set_option trace.simplify.rewrite true</code> seems to be rewriting things that aren't even in the goal.</p>",
        "id": 165922634,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1558116341
    },
    {
        "content": "<p>maybe <code>simp</code> is suited to do this kind of reasoning when the operations (inf, sup, +, -) are lifted pointwise from the codomain, but actual function composition is confusing it somehow</p>",
        "id": 165922871,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1558116511
    },
    {
        "content": "<blockquote>\n<p>I don't want to detract from a wider and more interesting discussion with a \"debug my code\" discussion</p>\n</blockquote>\n<p>you clearly have different views on what is interesting than me</p>",
        "id": 165923374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558116894
    },
    {
        "content": "<p>I posted the code in the new members list.</p>",
        "id": 165924476,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558117591
    },
    {
        "content": "<p>... and here's some revised code that looks very close to working.  <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  it gets up to an application of <code>exact</code> but for some reason that fails and accordingly the goal doesn't close.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">core</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">defs</span>\n<span class=\"kn\">open</span> <span class=\"n\">real</span> <span class=\"n\">set</span>\n\n<span class=\"c1\">----------------------</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Attempt to use `refine` alongside `apply` -/</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">sin_sin</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">refine_list_expr</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>     <span class=\"o\">:=</span> <span class=\"n\">do</span> <span class=\"o\">{</span><span class=\"n\">trace</span> <span class=\"s2\">&quot;fail&quot;</span><span class=\"o\">,</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;no matching rule&quot;</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span> <span class=\"o\">{</span><span class=\"n\">trace</span> <span class=\"s2\">&quot;refine, initial target:&quot;</span><span class=\"o\">,</span>\n                <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">target</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span><span class=\"o\">,</span>\n                <span class=\"o\">(</span><span class=\"n\">refine</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"err\">%%</span><span class=\"n\">h</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)),</span>\n                <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;REFINE: {h}&quot;</span><span class=\"o\">),</span>\n                <span class=\"n\">pure</span><span class=\"o\">()</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">refine_list_expr</span> <span class=\"n\">t</span> <span class=\"o\">}</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">exact_list_expr</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>     <span class=\"o\">:=</span> <span class=\"n\">do</span> <span class=\"o\">{</span><span class=\"n\">trace</span> <span class=\"s2\">&quot;fail&quot;</span><span class=\"o\">,</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;no matching rule&quot;</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span> <span class=\"o\">{</span><span class=\"n\">trace</span> <span class=\"s2\">&quot;exact, initial target:&quot;</span><span class=\"o\">,</span>\n                <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">target</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span><span class=\"o\">,</span>\n                <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;EXACT: {h}&quot;</span><span class=\"o\">),</span>\n                <span class=\"c1\">-- Some problem here...</span>\n                <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n                <span class=\"n\">trace</span> <span class=\"s2\">&quot;exact, final target:&quot;</span><span class=\"o\">,</span>\n                <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">target</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span><span class=\"o\">,</span>\n                <span class=\"n\">return</span> <span class=\"o\">()</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">exact_list_expr</span> <span class=\"n\">t</span> <span class=\"o\">}</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">apply_list_expr</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>     <span class=\"o\">:=</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;no matching rule&quot;</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span> <span class=\"o\">{</span> <span class=\"n\">trace</span> <span class=\"s2\">&quot;apply, initial target:&quot;</span><span class=\"o\">,</span>\n                 <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">target</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span><span class=\"o\">,</span>\n                 <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;APPLY: {h}&quot;</span><span class=\"o\">)</span> <span class=\"o\">,</span>\n                 <span class=\"n\">interactive</span><span class=\"bp\">.</span><span class=\"n\">concat_tags</span> <span class=\"o\">(</span><span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">),</span> <span class=\"n\">pure</span><span class=\"o\">()</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">apply_list_expr</span> <span class=\"n\">t</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">iterate_at_most_on_all_goals&#39;</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>        <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"n\">trace</span> <span class=\"s2\">&quot;maximal iterations reached&quot;</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">all_goals</span> <span class=\"err\">$</span> <span class=\"o\">(</span><span class=\"n\">do</span> <span class=\"n\">tac</span><span class=\"o\">,</span> <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;{n}&quot;</span><span class=\"o\">),</span> <span class=\"n\">iterate_at_most_on_all_goals&#39;</span> <span class=\"n\">n</span> <span class=\"n\">tac</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">skip</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">iterate_at_most_on_subgoals&#39;</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>        <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"n\">trace</span> <span class=\"s2\">&quot;maximal iterations reached&quot;</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"n\">focus1</span> <span class=\"o\">(</span><span class=\"n\">do</span> <span class=\"n\">tac</span><span class=\"o\">,</span> <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;{n}&quot;</span><span class=\"o\">),</span> <span class=\"n\">iterate_at_most_on_all_goals&#39;</span> <span class=\"n\">n</span> <span class=\"n\">tac</span><span class=\"o\">)</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">apply_rules_with_refine</span> <span class=\"o\">(</span><span class=\"n\">apps</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">refs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">exas</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">a</span> <span class=\"err\">←</span> <span class=\"n\">build_list_expr_for_apply</span> <span class=\"n\">apps</span><span class=\"o\">,</span>\n   <span class=\"n\">r</span> <span class=\"err\">←</span> <span class=\"n\">build_list_expr_for_apply</span> <span class=\"n\">refs</span><span class=\"o\">,</span>\n   <span class=\"n\">e</span> <span class=\"err\">←</span> <span class=\"n\">build_list_expr_for_apply</span> <span class=\"n\">exas</span><span class=\"o\">,</span>\n   <span class=\"n\">iterate_at_most_on_subgoals&#39;</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">assumption</span> <span class=\"bp\">&lt;|&gt;</span>\n                                  <span class=\"c1\">-- guess: we can refine iff the expression is a lambda?</span>\n                                  <span class=\"c1\">-- oh, but we need to peel off the &quot;continuous&quot; part</span>\n                                  <span class=\"o\">(</span><span class=\"n\">do</span> <span class=\"n\">t</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">target</span><span class=\"o\">,</span>\n                                        <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">app_arg</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n                                        <span class=\"k\">if</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">is_lambda</span> <span class=\"n\">a</span> <span class=\"k\">then</span> <span class=\"n\">refine_list_expr</span> <span class=\"n\">r</span>\n                                        <span class=\"k\">else</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;can&#39;t refine&quot;</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span>\n                                  <span class=\"o\">(</span><span class=\"n\">sin_sin</span><span class=\"bp\">.</span><span class=\"n\">apply_list_expr</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span>\n                                  <span class=\"o\">(</span><span class=\"n\">sin_sin</span><span class=\"bp\">.</span><span class=\"n\">exact_list_expr</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">sin_sin</span>\n<span class=\"c1\">----------------------</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">interactive</span>\n<span class=\"kn\">open</span> <span class=\"n\">lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">lean</span><span class=\"bp\">.</span><span class=\"n\">parser</span>\n<span class=\"kn\">open</span> <span class=\"n\">interactive</span> <span class=\"n\">interactive</span><span class=\"bp\">.</span><span class=\"n\">types</span> <span class=\"n\">expr</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">apply_rules_with_refine_interactive</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">pexpr_list_or_texpr</span><span class=\"o\">)</span>\n                                             <span class=\"o\">(</span><span class=\"n\">rs</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">pexpr_list_or_texpr</span><span class=\"o\">)</span>\n                                             <span class=\"o\">(</span><span class=\"n\">es</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">pexpr_list_or_texpr</span><span class=\"o\">)</span>\n                                             <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"mi\">50</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">sin_sin</span><span class=\"bp\">.</span><span class=\"n\">apply_rules_with_refine</span> <span class=\"n\">as</span> <span class=\"n\">rs</span> <span class=\"n\">es</span> <span class=\"n\">n</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">interactive</span>\n<span class=\"kn\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"c1\">-- * sin(sin(x)) and friends are continuous on ℝ</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">real</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">continuous_sin_sin</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">sin</span><span class=\"o\">(</span><span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">apply_rules_with_refine_interactive</span> <span class=\"o\">[</span><span class=\"n\">continuous_sin</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">continuous_id</span><span class=\"o\">]</span> <span class=\"mi\">30</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">continuous_sin_sin</span>\n\n<span class=\"c1\">-- Note, with latest version of mathlib, this proof is slightly different from earlier versions</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">continuous_sin_sin_sin</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">sin</span> <span class=\"o\">(</span><span class=\"n\">sin</span> <span class=\"o\">(</span><span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">refine</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">continuous_sin</span><span class=\"o\">,</span>\n<span class=\"n\">refine</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">continuous_sin</span><span class=\"o\">,</span>\n<span class=\"n\">refine</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">continuous_sin</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">continuous_id</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">continuous_sin_sin_sin</span>\n</pre></div>",
        "id": 166086086,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558360024
    },
    {
        "content": "<p>You'll see I separated out the rules for <code>apply</code>, <code>refine</code>, and <code>exact</code>, and that here there's just one rule available for each such step.  So obvs. this is preliminary to anything more general.</p>",
        "id": 166086384,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558360241
    },
    {
        "content": "<p>Is there a way to run <code>sorry</code> inside of a tactic, so I can at least get it to print out a proof with a hole in it as opposed to <code>⁇</code> <span aria-label=\"question\" class=\"emoji emoji-2753\" role=\"img\" title=\"question\">:question:</span></p>",
        "id": 166164744,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558439460
    },
    {
        "content": "<p>Naively substituting in <code>sorry</code> I get this error:</p>\n<div class=\"codehilite\"><pre><span></span>don&#39;t know how to synthesize placeholder\ncontext:\nexact_list_expr : list expr → tactic unit,\nh : expr,\nt : list expr,\n_x _x _x _x : unit\n⊢ Type\n</pre></div>\n\n\n<p>That seems a bit suspicious, i.e., <code>_x _x _x _x </code> looks weird.</p>",
        "id": 166164811,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558439510
    },
    {
        "content": "<p><code>tactic.admit</code></p>",
        "id": 166165201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558439871
    },
    {
        "content": "<p>Ah, <code>tactic.admit</code>, I just found it.  But impressively it doesn't work.</p>",
        "id": 166165253,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558439887
    },
    {
        "content": "<p>The trace commands are like this:</p>\n<div class=\"codehilite\"><pre><span></span>$  lean refine_rules.lean\nrefine, initial target:\ncontinuous (λ (x : ℝ), sin (sin x))\nREFINE: continuous.comp.{?_mlocal._fresh.13.928650 ?_mlocal._fresh.13.928651 ?_mlocal._fresh.13.928652}\n29\napply, initial target:\ncontinuous sin\nAPPLY: real.continuous_sin\n28\nrefine, initial target:\ncontinuous (λ (x : ℝ), sin x)\nREFINE: continuous.comp.{?_mlocal._fresh.13.928650 ?_mlocal._fresh.13.928651 ?_mlocal._fresh.13.928652}\n28\napply, initial target:\ncontinuous sin\nAPPLY: real.continuous_sin\n27\nrefine, initial target:\ncontinuous (λ (x : ℝ), x)\napply, initial target:\ncontinuous (λ (x : ℝ), x)\nAPPLY: real.continuous_sin\nexact, initial target:\ncontinuous (λ (x : ℝ), x)\nEXACT: continuous_id.{?_mlocal._fresh.13.928653}\nexact, final target:\n/Users/joe/my_playground_tidy2/src/refine_rules.lean:87:0: error: tactic failed, there are unsolved goals\nstate:\n⊢ continuous (λ (x : ℝ), x)\ntheorem continuous_sin_sin : continuous (λ (x : ℝ), sin (sin x)) :=\n⁇\n</pre></div>",
        "id": 166165329,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558439989
    },
    {
        "content": "<p>So it seems to claim there's no target in the last step, but then there are unsolved goals at the end of the run.</p>",
        "id": 166165433,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558440029
    },
    {
        "content": "<p>Oh, maybe this is the difference between <code>pure</code> and <code>return</code>?</p>",
        "id": 166165567,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558440133
    },
    {
        "content": "<p><span aria-label=\"fingers crossed\" class=\"emoji emoji-1f91e\" role=\"img\" title=\"fingers crossed\">:fingers_crossed:</span></p>",
        "id": 166165582,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558440158
    },
    {
        "content": "<p>Nope, that's not the problem.</p>",
        "id": 166165617,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558440204
    },
    {
        "content": "<p>The steps exactly match those of my interactive proof:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">continuous_sin_sin&#39;</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">sin</span> <span class=\"o\">(</span><span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">refine</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">continuous_sin</span><span class=\"o\">,</span>\n<span class=\"n\">refine</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">continuous_sin</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">continuous_id</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>... well, almost exactly.  There's an extra <code>apply</code> but it doesn't change the target.</p>",
        "id": 166166141,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558440644
    },
    {
        "content": "<p>maybe that extra apply made a new subgoal</p>",
        "id": 166166300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558440794
    },
    {
        "content": "<p>for example if it was <code>continuous.comp</code> and lean said \"aha, composition with identity\"</p>",
        "id": 166166316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558440812
    },
    {
        "content": "<blockquote>\n<p>for example if it was <code>continuous.comp</code> and lean said \"aha, composition with identity\"</p>\n</blockquote>\n<p>If only Lean could stop saying that...</p>",
        "id": 166170385,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1558444172
    },
    {
        "content": "<p>there is an easy way to make that happen: take off that dang <code>@[reducible]</code> on <code>comp</code></p>",
        "id": 166170521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558444273
    },
    {
        "content": "<p>however in that case this won't match at all because the input is <code>continuous (λ x : ℝ, sin (sin x))</code> instead of <code>continuous (sin ∘ sin)</code></p>",
        "id": 166170597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558444334
    },
    {
        "content": "<p>About <code>apply</code> and continuity, would it be evil to change the definition of continuity so that it's no longer a forall? It would feel weird, and many proofs we already have would need to start with a rewrite to get back to the forall definition. But having automatic proofs of continuity of the kind Joe is hoping would be a huge progress (and Isabelle have them). Our stupid manual proofs are very visible in the perfectoid project. They generate many many lines that don't exist in real world</p>",
        "id": 166170599,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1558444337
    },
    {
        "content": "<p>an easy way to make it not a forall without really changing anything is to wrap it in a <code>structure</code></p>",
        "id": 166170655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558444392
    },
    {
        "content": "<p>with luck you just have to add a few anonymous constructors in places</p>",
        "id": 166170678,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558444422
    },
    {
        "content": "<p>This would bring no mathematical benefit. With a different mathematical definition we would at least get <em>some</em> simpler proofs</p>",
        "id": 166170973,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1558444641
    },
    {
        "content": "<p>?</p>",
        "id": 166170993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558444667
    },
    {
        "content": "<p>The current definition is certainly the best one</p>",
        "id": 166171009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558444679
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L428\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L428\">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L428</a> could become the definition</p>",
        "id": 166171060,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1558444688
    },
    {
        "content": "<p>I want to disturb that as little as possible</p>",
        "id": 166171064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558444694
    },
    {
        "content": "<p>No one would recognize it but it's not a forall</p>",
        "id": 166171077,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1558444708
    },
    {
        "content": "<p>Well okay when you put it like that... but it's defeq to the obvious definition</p>",
        "id": 166171100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558444732
    },
    {
        "content": "<p>So <code>apply</code> would fail as well?</p>",
        "id": 166171145,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1558444768
    },
    {
        "content": "<p>the usual definition <em>is</em> a forall</p>",
        "id": 166171164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558444788
    },
    {
        "content": "<p>this one is just a le which unfolds to a forall</p>",
        "id": 166171218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558444804
    },
    {
        "content": "<p>By the way, is the order relation on <code>topological_space</code> and <code>uniform_space</code> open for debate? Currently we have incompatibility with the order on filters, as seen in <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L147-L148\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L147-L148\">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L147-L148</a> and <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L472\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L472\">https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L472</a>, generating things like <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L542\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L542\">https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L542</a> and generating a push-forward which is <em>right</em>-adjoint to pull-back</p>",
        "id": 166171415,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1558444959
    },
    {
        "content": "<blockquote>\n<p>this one is just a le which unfolds to a forall</p>\n</blockquote>\n<p>I understand that, my question is: is this enough to hide from the <code>apply</code> bug?</p>",
        "id": 166171435,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1558444982
    },
    {
        "content": "<p>As far as I can see, real world never write <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">t_1 \\leq t_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.63597em;\"></span><span class=\"strut bottom\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mrel\">≤</span><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> for topologies <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">t_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.61508em;\"></span><span class=\"strut bottom\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">t_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.61508em;\"></span><span class=\"strut bottom\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> but write sentences randomly using either the \"finer than\" or \"coarser than\" relation</p>",
        "id": 166171583,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1558445065
    },
    {
        "content": "<p>you can't hide from the apply bug</p>",
        "id": 166171682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558445157
    },
    {
        "content": "<p>seriously, it can see through <code>irreducible</code> and theorems, it's crazy</p>",
        "id": 166171741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558445179
    },
    {
        "content": "<p>Got the example working, thanks to <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> for suggesting to use <code>@continuous_id ℝ _</code>.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">core</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">defs</span>\n<span class=\"kn\">open</span> <span class=\"n\">real</span> <span class=\"n\">set</span>\n\n<span class=\"c1\">----------------------</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Attempt to use `refine` alongside `apply` -/</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">sin_sin</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">refine_list_expr</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>     <span class=\"o\">:=</span> <span class=\"n\">do</span> <span class=\"o\">{</span><span class=\"n\">trace</span> <span class=\"s2\">&quot;fail&quot;</span><span class=\"o\">,</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;no matching rule&quot;</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span> <span class=\"o\">{</span><span class=\"n\">trace</span> <span class=\"s2\">&quot;refine, initial goals:&quot;</span><span class=\"o\">,</span>\n                <span class=\"n\">gs</span> <span class=\"err\">←</span> <span class=\"n\">get_goals</span><span class=\"o\">,</span>\n                <span class=\"n\">mmap</span> <span class=\"n\">infer_type</span> <span class=\"n\">gs</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">trace</span><span class=\"o\">,</span>\n                <span class=\"o\">(</span><span class=\"n\">refine</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"err\">%%</span><span class=\"n\">h</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)),</span>\n                <span class=\"c1\">--trace &quot;refine, subsequent target:&quot;,</span>\n                <span class=\"c1\">--tactic.target &gt;&gt;= tactic.trace,</span>\n                <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot; REFINE: {h}&quot;</span><span class=\"o\">),</span>\n                <span class=\"n\">trace</span> <span class=\"s2\">&quot;refine, final goals:&quot;</span><span class=\"o\">,</span>\n                <span class=\"n\">gs</span> <span class=\"err\">←</span> <span class=\"n\">get_goals</span><span class=\"o\">,</span>\n                <span class=\"n\">mmap</span> <span class=\"n\">infer_type</span> <span class=\"n\">gs</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">trace</span><span class=\"o\">,</span>\n                <span class=\"n\">pure</span><span class=\"o\">()</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">refine_list_expr</span> <span class=\"n\">t</span> <span class=\"o\">}</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">exact_list_expr</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>     <span class=\"o\">:=</span> <span class=\"n\">do</span> <span class=\"o\">{</span><span class=\"n\">trace</span> <span class=\"s2\">&quot;fail&quot;</span><span class=\"o\">,</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;no matching rule&quot;</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span> <span class=\"o\">{</span><span class=\"n\">trace</span> <span class=\"s2\">&quot;exact, initial goals:&quot;</span><span class=\"o\">,</span>\n                <span class=\"n\">gs</span> <span class=\"err\">←</span> <span class=\"n\">get_goals</span><span class=\"o\">,</span>\n                <span class=\"n\">mmap</span> <span class=\"n\">infer_type</span> <span class=\"n\">gs</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">trace</span><span class=\"o\">,</span>\n                <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot; EXACT: {h}&quot;</span><span class=\"o\">),</span>\n                <span class=\"c1\">-- Some problem here...</span>\n                <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n                <span class=\"n\">trace</span> <span class=\"s2\">&quot;exact, final goals:&quot;</span><span class=\"o\">,</span>\n                <span class=\"n\">gs</span> <span class=\"err\">←</span> <span class=\"n\">get_goals</span><span class=\"o\">,</span>\n                <span class=\"n\">mmap</span> <span class=\"n\">infer_type</span> <span class=\"n\">gs</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">trace</span><span class=\"o\">,</span>\n                <span class=\"n\">pure</span><span class=\"o\">()</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">exact_list_expr</span> <span class=\"n\">t</span> <span class=\"o\">}</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">apply_list_expr</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>     <span class=\"o\">:=</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;no matching rule&quot;</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">do</span> <span class=\"o\">{</span> <span class=\"n\">trace</span> <span class=\"s2\">&quot;apply, initial goals:&quot;</span><span class=\"o\">,</span>\n                 <span class=\"n\">gs</span> <span class=\"err\">←</span> <span class=\"n\">get_goals</span><span class=\"o\">,</span>\n                 <span class=\"n\">mmap</span> <span class=\"n\">infer_type</span> <span class=\"n\">gs</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">trace</span><span class=\"o\">,</span>\n                 <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot; APPLY: {h}&quot;</span><span class=\"o\">)</span> <span class=\"o\">,</span>\n                 <span class=\"n\">interactive</span><span class=\"bp\">.</span><span class=\"n\">concat_tags</span> <span class=\"o\">(</span><span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n                 <span class=\"n\">trace</span> <span class=\"s2\">&quot;apply, final goals:&quot;</span><span class=\"o\">,</span>\n                 <span class=\"n\">gs</span> <span class=\"err\">←</span> <span class=\"n\">get_goals</span><span class=\"o\">,</span>\n                 <span class=\"n\">mmap</span> <span class=\"n\">infer_type</span> <span class=\"n\">gs</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">trace</span><span class=\"o\">,</span>\n                 <span class=\"n\">pure</span><span class=\"o\">()</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">apply_list_expr</span> <span class=\"n\">t</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">iterate_at_most_on_all_goals&#39;</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>        <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"n\">trace</span> <span class=\"s2\">&quot;All goals: maximal iterations reached&quot;</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">all_goals</span> <span class=\"err\">$</span> <span class=\"o\">(</span><span class=\"n\">do</span> <span class=\"n\">tac</span><span class=\"o\">,</span> <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;All goals:{n}&quot;</span><span class=\"o\">),</span> <span class=\"n\">iterate_at_most_on_all_goals&#39;</span> <span class=\"n\">n</span> <span class=\"n\">tac</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">skip</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">iterate_at_most_on_subgoals&#39;</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>        <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"n\">trace</span> <span class=\"s2\">&quot;Subgoals: maximal iterations reached&quot;</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"n\">focus1</span> <span class=\"o\">(</span><span class=\"n\">do</span> <span class=\"n\">tac</span><span class=\"o\">,</span> <span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;Subgoals:{n}&quot;</span><span class=\"o\">),</span> <span class=\"n\">iterate_at_most_on_all_goals&#39;</span> <span class=\"n\">n</span> <span class=\"n\">tac</span><span class=\"o\">)</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">apply_rules_with_refine</span> <span class=\"o\">(</span><span class=\"n\">apps</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">refs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">exas</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">a</span> <span class=\"err\">←</span> <span class=\"n\">build_list_expr_for_apply</span> <span class=\"n\">apps</span><span class=\"o\">,</span>\n   <span class=\"n\">r</span> <span class=\"err\">←</span> <span class=\"n\">build_list_expr_for_apply</span> <span class=\"n\">refs</span><span class=\"o\">,</span>\n   <span class=\"n\">e</span> <span class=\"err\">←</span> <span class=\"n\">build_list_expr_for_apply</span> <span class=\"n\">exas</span><span class=\"o\">,</span>\n   <span class=\"n\">iterate_at_most_on_subgoals&#39;</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">assumption</span>\n                                    <span class=\"bp\">&lt;|&gt;</span> <span class=\"o\">(</span><span class=\"n\">do</span> <span class=\"n\">t</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">target</span><span class=\"o\">,</span>\n                                          <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">app_arg</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n                                          <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">band</span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">is_lambda</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n                                                   <span class=\"o\">(</span><span class=\"n\">bnot</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"n\">a</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"o\">))))</span>\n                                          <span class=\"k\">then</span> <span class=\"n\">refine_list_expr</span> <span class=\"n\">r</span>\n                                          <span class=\"k\">else</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;can&#39;t refine&quot;</span><span class=\"o\">)</span>\n                                    <span class=\"bp\">&lt;|&gt;</span> <span class=\"o\">(</span><span class=\"n\">sin_sin</span><span class=\"bp\">.</span><span class=\"n\">apply_list_expr</span> <span class=\"n\">a</span><span class=\"o\">)),</span>\n   <span class=\"n\">sin_sin</span><span class=\"bp\">.</span><span class=\"n\">exact_list_expr</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n   <span class=\"c1\">-- trace &quot;context at the end of the run:&quot;,</span>\n   <span class=\"c1\">-- tactic.local_context &gt;&gt;= tactic.trace,</span>\n   <span class=\"c1\">-- trace &quot;target at the end of the run:&quot;,</span>\n   <span class=\"c1\">-- tactic.target &gt;&gt;= tactic.trace,</span>\n   <span class=\"n\">pure</span><span class=\"o\">()</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">sin_sin</span>\n<span class=\"c1\">----------------------</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">interactive</span>\n<span class=\"kn\">open</span> <span class=\"n\">lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">lean</span><span class=\"bp\">.</span><span class=\"n\">parser</span>\n<span class=\"kn\">open</span> <span class=\"n\">interactive</span> <span class=\"n\">interactive</span><span class=\"bp\">.</span><span class=\"n\">types</span> <span class=\"n\">expr</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">apply_rules_with_refine_interactive</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">pexpr_list_or_texpr</span><span class=\"o\">)</span>\n                                             <span class=\"o\">(</span><span class=\"n\">rs</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">pexpr_list_or_texpr</span><span class=\"o\">)</span>\n                                             <span class=\"o\">(</span><span class=\"n\">es</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">pexpr_list_or_texpr</span><span class=\"o\">)</span>\n                                             <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"mi\">50</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">sin_sin</span><span class=\"bp\">.</span><span class=\"n\">apply_rules_with_refine</span> <span class=\"n\">as</span> <span class=\"n\">rs</span> <span class=\"n\">es</span> <span class=\"n\">n</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">interactive</span>\n<span class=\"kn\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"c1\">-- * sin(sin(x)) and friends are continuous on ℝ</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">real</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">continuous_sin_sin</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">sin</span><span class=\"o\">(</span><span class=\"n\">sin</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">apply_rules_with_refine_interactive</span> <span class=\"o\">[</span><span class=\"n\">continuous_sin</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">continuous_id</span> <span class=\"n\">ℝ</span> <span class=\"bp\">_</span><span class=\"o\">]</span> <span class=\"mi\">5</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">continuous_sin_sin</span>\n</pre></div>",
        "id": 166172243,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558445563
    },
    {
        "content": "<p>And <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> thanks for the advice on printing goals, that helped me debug it properly.</p>",
        "id": 166172318,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558445627
    },
    {
        "content": "<p>And I appreciate the comment from <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> -- this is only a small step towards a more full automation; a reimplementation of Hanne Gottliebsen's <code>cts</code> tactic from PVS would be impressive :-)</p>",
        "id": 166172573,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558445781
    },
    {
        "content": "<p>what does it do?</p>",
        "id": 166172592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558445813
    },
    {
        "content": "<p>I mean precisely</p>",
        "id": 166172600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558445822
    },
    {
        "content": "<p>Much as this example, but for a broader class of functions.  So, it would automate continuity proofs for many compositions.  It runs into trouble with examples like <code>1/(cos x + 2)</code>.</p>",
        "id": 166173068,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558446134
    },
    {
        "content": "<p>... Compositions, and combinations under arithmetic operations.</p>",
        "id": 166173092,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558446161
    },
    {
        "content": "<p>Can we write a tactic that determines whether some expression is a composition or not?</p>",
        "id": 166173660,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1558446564
    },
    {
        "content": "<p>By inspecting it syntactically</p>",
        "id": 166173664,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1558446571
    },
    {
        "content": "<p>yes, that's how this should be done</p>",
        "id": 166173841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558446681
    },
    {
        "content": "<p>My continuity tactic <a href=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/homotopy_theory/topological_spaces/tactic.lean#L14\" target=\"_blank\" title=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/homotopy_theory/topological_spaces/tactic.lean#L14\">does this</a> in a different way</p>",
        "id": 166173929,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558446723
    },
    {
        "content": "<p>But it waited forever for <code>backwards_reasoning</code></p>",
        "id": 166173979,
        "sender_full_name": "Reid Barton",
        "timestamp": 1558446766
    },
    {
        "content": "<p>Ah, I had initially set off to write this example with <code>tidy</code> using <code>apply_rules</code> inside, I didn't realise that you could feed individual rules into <code>tidy</code> quite so straightforwardly.</p>",
        "id": 166174198,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558446904
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I think Reid's tactic is pretty much equivalent to the <code>cts</code> tactic I mentioned.  Again it wouldn't do <code>1/(cos x + 2)</code>. The idea I was pursuing in some other threads was to get a bound <code>cos x + 2 &gt; 0</code> using an SMT solver.</p>",
        "id": 166174889,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558447274
    },
    {
        "content": "<p>why not just spit out a subgoal for it? Proving cos x + 2 != 0 seems out of scope for a continuity prover</p>",
        "id": 166174979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558447323
    },
    {
        "content": "<p>Well, proving things to be non-zero is needed in order to apply <code>continuous_inv</code>.  So, the check would play a similar role to the conditions in Reid's <code>apply_continuous.comp</code>.</p>",
        "id": 166175543,
        "sender_full_name": "Joseph Corneli",
        "timestamp": 1558447652
    },
    {
        "content": "<p>right, that's why it is a subgoal</p>",
        "id": 166175666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558447727
    },
    {
        "content": "<p>it's a tactic, you don't have to prove everything</p>",
        "id": 166175681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1558447738
    }
]
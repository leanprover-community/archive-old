[
    {
        "content": "<div class=\"codehilite\"><pre><span></span>tactic.mk_instance failed to generate instance for\n  module (polynomial R) (polynomial R)\n</pre></div>\n\n\n<p>That didn't used to happen.</p>\n<p>From <code>algebra/module.lean</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">to_semimodule</span> <span class=\"o\">[</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">semimodule</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">stuff</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_module</span> <span class=\"o\">[</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">to_semimodule</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>Is this definitely OK? My rings are no longer modules over themselves for some reason.</p>",
        "id": 133914925,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536874465
    },
    {
        "content": "<blockquote>\n<p>nein danke</p>\n</blockquote>",
        "id": 133914954,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536874518
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">nonzero_comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">is_submodule</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">failed to synthesize type class instance for</span>\n<span class=\"cm\">R : Type ?,</span>\n<span class=\"cm\">_inst_1 : nonzero_comm_ring R,</span>\n<span class=\"cm\">I : set (polynomial R)</span>\n<span class=\"cm\">⊢ module ?m_1 (polynomial R)</span>\n\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>Am I just making a rookie error? I thought this used to work?</p>",
        "id": 133915566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536875298
    },
    {
        "content": "<p>Oh -- I am -- this is not the problem. I need decidable equality. I'll keep looking for the problem.</p>",
        "id": 133915592,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536875393
    },
    {
        "content": "<p>FYI I'm currently working on a big rewrite of most of this, so stay tuned.</p>",
        "id": 133915650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536875489
    },
    {
        "content": "<p>Oh Ok. I just pulled again and the errors moved to different places, so I guess that's progress.</p>",
        "id": 133915817,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536875704
    },
    {
        "content": "<p>Oh I still have (in the middle of some code)</p>\n<div class=\"codehilite\"><pre><span></span>      <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"c1\">-- works fine</span>\n      <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"c1\">-- fails to generate instance</span>\n</pre></div>\n\n\n<p>but if you're changing stuff then perhaps I will just leave things for now.</p>",
        "id": 133916124,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536876074
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">submodule</span>\n\n<span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">,</span> <span class=\"n\">priority</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">prop_decidable</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_module</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">@[instance]</span>\n<span class=\"cm\">protected def ring.to_module : Π {α : Type u} [r : ring α], module α α := ...</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">leading_term_bdd_deg_ideal</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nonzero_comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">is_submodule</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"err\">∈</span> <span class=\"n\">I</span> <span class=\"bp\">∧</span> <span class=\"n\">degree</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">leading_coeff</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">},{</span>\n  <span class=\"n\">zero_</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">is_submodule</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">bot_le</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">add_</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">Hf</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">Hg</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n    <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"c1\">-- works</span>\n    <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"c1\">-- fails</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">}</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>There's a fairly minimal working example of something which is stopping me from doing anything on Hilbert basis at the minute. Type class inference can find the ring instance, and the ring to module instance is there, but type class inference can't find the module instance.</p>",
        "id": 133939719,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536914676
    },
    {
        "content": "<p>I can't add the instance explictly -- well, I can -- but then I get weird diamond errors later on. I am going to put Hilbert basis on hold for a while until I can understand what is going on here -- currently my understanding is that this is not user error and I should just wait, and of course I'm happy to wait.</p>",
        "id": 133939818,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536914793
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> You could use  the explicit<br>\n<code>letI : module (polynomial R) (polynomial R) := @ring.to_module (polynomial R) _,</code></p>",
        "id": 133940044,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536915127
    },
    {
        "content": "<p>It is a bit ugly, but maybe it would unblock you?</p>",
        "id": 133940048,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536915140
    },
    {
        "content": "<p>No because then I get diamond issues with exactly the instances that Mario is currently refactoring</p>",
        "id": 133940379,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536915692
    },
    {
        "content": "<p>I just thought I'd post this example because either it's something which seems to be to be currently broken or I've made a mistake and it doesn't work for a good reason (note that I go from term mode to tactic mode and for all I know this has consequences for type class inference). If I've not made a mistake then it's something that should work after the refactoring</p>",
        "id": 133940459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536915797
    },
    {
        "content": "<p>Hmmm... that's crazy.</p>",
        "id": 133940518,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536915877
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>invalid type ascription, term has type\n  @is_submodule R (@polynomial R (@comm_ring.to_comm_semiring R (@nonzero_comm_ring.to_comm_ring R _inst_1)))\n    (@comm_ring.to_ring R (@nonzero_comm_ring.to_comm_ring R _inst_1))\n    (@polynomial.module R (λ (a b : R), classical.prop_decidable (a = b)) (@nonzero_comm_ring.to_comm_ring R _inst_1))\n    I\nbut is expected to have type\n  @is_submodule (@polynomial R (@comm_ring.to_comm_semiring R (@nonzero_comm_ring.to_comm_ring R _inst_1)))\n    (@polynomial R (@comm_ring.to_comm_semiring R (@nonzero_comm_ring.to_comm_ring R _inst_1)))\n    (@comm_ring.to_ring (@polynomial R (@comm_ring.to_comm_semiring R (@nonzero_comm_ring.to_comm_ring R _inst_1)))\n       _inst)\n    _inst_3\n    I\n</pre></div>\n\n\n<p>for what it's worth. Oh! What is this <code>polynomial.module</code>?? That's the statement that <code>R[X]</code> is a module over <code>R</code>. Is that relevant? Anyway, this is not the point -- the point is that either my original thing should work and it doesn't (in which case I should stop, because I am using modules all over the place and will surely see other problems later, even though no module actually occurs in the proofs, only ideals, and part of me wants to define ideals as subsets of rings plus blah because we all know that type classes for modules have problems, whereas type classes for ideals will probably work fine), or I've made a mistake (in which case I need help because I can't see it).</p>",
        "id": 133940963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536916675
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> So the math strategy would be something like \"wlog we have deg(f) ≤ deg(g), now look at <code>X^(degree g - degree f) * f + g</code>. Done.\"</p>",
        "id": 133941521,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536917560
    },
    {
        "content": "<p>I don't know how to do <code>wlog</code> in Lean, so I'll just do cases on <code>have H := le_or_gt f.degree g.degree,</code></p>",
        "id": 133941543,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536917599
    },
    {
        "content": "<p>The next step fails, because Lean doesn't know how to subtract <code>with_bot ℕ</code> thingies. Is that intended? Or should we use <code>nat_degree</code>?</p>",
        "id": 133941553,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536917638
    },
    {
        "content": "<p>Oh I've done all this bit -- you should look at the <code>kmb_hilbert_basis</code> branch of community mathlib.</p>",
        "id": 133941852,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536918060
    },
    {
        "content": "<blockquote>\n<p>why are you making me commit just becuase I want to change branch</p>\n</blockquote>\n<p><code>git stash</code></p>",
        "id": 133941999,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536918295
    },
    {
        "content": "<p>Oh that's what it's for!</p>",
        "id": 133942704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536919420
    },
    {
        "content": "<p><code>unexpected occurrence of recursive function</code><br>\nDid I unlock something?</p>",
        "id": 133943962,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536921505
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I tried using <code>wlog</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- zero ring a special case so let&#39;s deal with it separately</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">hilbert_basis_zero_ring</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">is_noetherian_ring</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">is_noetherian_of_zero_eq_one</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">semiring</span><span class=\"bp\">.</span><span class=\"n\">zero_of_zero_eq_one</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">coeff</span> <span class=\"bp\">_</span> <span class=\"n\">n</span><span class=\"o\">)}</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">hilbert_basis</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hR</span> <span class=\"o\">:</span> <span class=\"n\">is_noetherian_ring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_noetherian_ring</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"c1\">-- deal with zero ring first</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h01</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hilbert_basis_zero_ring</span> <span class=\"n\">h01</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">nonzero_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">comm_ring</span><span class=\"bp\">.</span><span class=\"n\">non_zero_of_zero_ne_one</span> <span class=\"n\">h01</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">leading_coeff</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">HL</span> <span class=\"o\">:</span> <span class=\"n\">is_ideal</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">zero_</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">add_</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">Hf</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"n\">Hg</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">h0</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">Hf</span><span class=\"o\">,</span> <span class=\"err\">←</span><span class=\"n\">Hg</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">leading_coeff_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_add</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">Hf</span><span class=\"o\">,</span> <span class=\"err\">←</span><span class=\"n\">Hg</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">leading_coeff_zero</span><span class=\"o\">,</span> <span class=\"n\">add_zero</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n      <span class=\"n\">wlog</span> <span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">nat_degree</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">nat_degree</span> <span class=\"n\">g</span> <span class=\"kn\">using</span> <span class=\"o\">[</span><span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">],</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"o\">(</span><span class=\"n\">le_or_lt</span> <span class=\"o\">(</span><span class=\"n\">nat_degree</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nat_degree</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">H</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">X</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"n\">nat_degree</span> <span class=\"n\">g</span> <span class=\"bp\">-</span> <span class=\"n\">nat_degree</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">Htemp</span> <span class=\"o\">:</span> <span class=\"n\">leading_coeff</span> <span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">leading_coeff</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"n\">nat_degree</span> <span class=\"n\">g</span> <span class=\"bp\">-</span> <span class=\"n\">nat_degree</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">leading_coeff_X_pow</span><span class=\"o\">,</span><span class=\"n\">mul_one</span><span class=\"o\">],</span>\n          <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hf</span> <span class=\"err\">$</span> <span class=\"n\">leading_coeff_eq_zero</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n        <span class=\"k\">have</span> <span class=\"n\">Ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">leading_coeff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">X</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"n\">nat_degree</span> <span class=\"n\">g</span> <span class=\"bp\">-</span> <span class=\"n\">nat_degree</span> <span class=\"n\">f</span><span class=\"o\">)),</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">leading_coeff_mul&#39;</span> <span class=\"n\">Htemp</span><span class=\"o\">,</span><span class=\"n\">leading_coeff_X_pow</span><span class=\"o\">,</span><span class=\"n\">mul_one</span><span class=\"o\">,</span><span class=\"n\">Hf</span><span class=\"o\">],</span>\n        <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">begin</span> <span class=\"n\">convert</span> <span class=\"n\">leading_coeff_add_of_degree_eq</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">Hg</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n                      <span class=\"n\">rw</span> <span class=\"n\">degree_mul_eq&#39;</span> <span class=\"n\">Htemp</span><span class=\"o\">,</span>\n                      <span class=\"n\">rw</span> <span class=\"n\">degree_X_pow</span><span class=\"o\">,</span>\n                      <span class=\"n\">rw</span> <span class=\"n\">degree_eq_nat_degree</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n                      <span class=\"n\">rw</span> <span class=\"n\">degree_eq_nat_degree</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n                      <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">with_bot</span><span class=\"bp\">.</span><span class=\"n\">coe_add</span><span class=\"o\">,</span>\n                      <span class=\"n\">rw</span> <span class=\"n\">with_bot</span><span class=\"bp\">.</span><span class=\"n\">coe_eq_coe</span><span class=\"o\">,</span>\n                      <span class=\"n\">exact</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">add_sub_cancel&#39;</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n                    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">Ha</span><span class=\"o\">,</span><span class=\"n\">Hg</span><span class=\"o\">],</span>\n                  <span class=\"kn\">end</span><span class=\"bp\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"kn\">end</span><span class=\"o\">,</span>\n    <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 133943968,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536921530
    },
    {
        "content": "<p>I also proved <code>hilbert_basis_zero_ring</code></p>",
        "id": 133943976,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536921546
    },
    {
        "content": "<p>I wonder whether Hilbert ever proved it</p>",
        "id": 133944142,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536921815
    },
    {
        "content": "<p>Lol...</p>",
        "id": 133944224,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536921935
    },
    {
        "content": "<p>Do you have any idea how I managed to get into this recursive function? Is this a bug in <code>wlog</code>?</p>",
        "id": 133944235,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536921956
    },
    {
        "content": "<p>Usually when I get that recursive function error it's because I have some <code>_fun_match</code> or similar thing among my hypotheses and some tactic tried to apply it</p>",
        "id": 133945017,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536922969
    },
    {
        "content": "<p>Is that the whole error message?<br>\nGuessing from previous discussion here I can't run your code that easily</p>",
        "id": 133945027,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536922986
    },
    {
        "content": "<p>The <code>add := λ a b ⟨f,Hf⟩ ⟨g,Hg⟩,</code> looks possibly to blame, if that is the cause</p>",
        "id": 133945044,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536923042
    },
    {
        "content": "<p>There are indeed <code>_fun_match</code> hypotheses in the context.</p>",
        "id": 133945203,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536923269
    },
    {
        "content": "<p>see if moving that lambda stuff to an <code>rintros</code> tactic helps</p>",
        "id": 133945257,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536923310
    },
    {
        "content": "<p>Ok, I'll try</p>",
        "id": 133945263,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536923321
    },
    {
        "content": "<p><code>wlog</code> is too good to miss out on</p>",
        "id": 133945268,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536923328
    },
    {
        "content": "<blockquote>\n<p>Hilbert (1890) proved the theorem (for the special case of polynomial rings over a field)</p>\n</blockquote>",
        "id": 133945363,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536923467
    },
    {
        "content": "<p>And here we are, about 130 years later, proving it for the zero ring!</p>",
        "id": 133945386,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536923511
    },
    {
        "content": "<p>Maybe you don't have my most recent commits. I have more than this. I gave up on wlog for exactly the reason you posted</p>",
        "id": 133945454,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536923629
    },
    {
        "content": "<p>Hmmm, too bad.</p>",
        "id": 133945517,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536923710
    },
    {
        "content": "<p>I feel like you could avoid this zero ring stuff if you worked at it. For example, instead of the ideal of all leading coefficients, take the ideal <code>{ coeff f i | coeff f j = 0 for all j &gt; i }</code>. Probably not worth it though.</p>",
        "id": 133945653,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536923923
    },
    {
        "content": "<p>Hmm, I don't know. Doesn't that lead to rather clean proofs?</p>",
        "id": 133945733,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536924028
    },
    {
        "content": "<p>I honestly don't think that trying to write proofs that work with the zero ring is worth it. Every third step you need to check that something is non-zero. To prove that if I is an ideal of R[X] then the set of leading terms of polynomials in I is an ideal involves so many edge cases; leading term f non-zero, leading term g non-zero, leading term f + g non-zero, and this is all in the case R non-zero. The proof is edge case after edge case and edge case 1 is very naturally R = 0.</p>",
        "id": 133945741,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536924049
    },
    {
        "content": "<p>You need a little lemma saying <code>coeff f j = 0</code> for all <code>j &gt; degree f</code>.</p>",
        "id": 133945743,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536924052
    },
    {
        "content": "<p>Loads of the lemmas about how leading coefficients of polynomials behave rely on terms being non-zero, e.g. you use f*X^(deg g - deg f) to get degree of f up to that of g, and to compute the degree of this you need degree of X is 1 and this demands a proof that 1 isn't 0</p>",
        "id": 133945826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536924132
    },
    {
        "content": "<p>Oh I see -- you mean avoid leading terms completely? But we also need the ideal of leading terms of polys of degree at most n. Maybe you're right and there's some way of doing it.</p>",
        "id": 133945859,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536924209
    },
    {
        "content": "<p>PS I pushed some more commits</p>",
        "id": 133945862,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536924217
    },
    {
        "content": "<p>the j thing -- you have to be careful because degree is not a nat, it's a with_bot nat, and coeff takes a nat</p>",
        "id": 133945921,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536924250
    },
    {
        "content": "<p>I think if you avoid ever saying the word \"degree\", and unravel its definition everywhere, then possibly all the \"R is not zero\" steps disappear.</p>",
        "id": 133945927,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536924262
    },
    {
        "content": "<p>(But they may be replaced by having to do more other work, and in any case it's a bit unnatural.)</p>",
        "id": 133945951,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536924345
    },
    {
        "content": "<p>Apparently they proved this in Mizar</p>\n<blockquote>\n<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> be a Noetherian Abelian add-associative right zeroed right complementable associative distributive well unital commutative non empty double loop structure. One can verify that Polynom-Ring <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is Noetherian.</p>\n</blockquote>",
        "id": 133946079,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536924554
    },
    {
        "content": "<p>You need to talk about degrees because given an ideal <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mo>[</mo><mi>X</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">R[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> you need to consider the ideal <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>J</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">J_k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> (<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span></span></span></span> a natural) comprising of 0 and the leading terms of the polynomials in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> of degree <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span></span></span></span>. But I agree there might be tricks. Here's another example of an edge case -- if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span></span></span> has degree <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span></span></span></span> and leading term <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">c</span></span></span></span> is in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> then you want to prove that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">a*c</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.46528em;\"></span><span class=\"strut bottom\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span><span class=\"mbin\">∗</span><span class=\"mord mathit\">c</span></span></span></span> is in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, but <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi><mo>∗</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">c*f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\">c</span><span class=\"mbin\">∗</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span></span></span> might not have degree <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span></span></span></span> any more and you have to deal with that case separately. It's quite an annoying proof to formalise :-)</p>",
        "id": 133949236,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536928905
    },
    {
        "content": "<p>Aah! I found my type class problem!</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">submodule</span>\n\n<span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">,</span> <span class=\"n\">priority</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">prop_decidable</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"c1\">-- Maths :  &quot;Let I be an ideal of R[X]&quot;</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">ABC</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">is_submodule</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n\n<span class=\"c1\">-- ...but I is not an ideal of (polynomial R)!</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">_inst_2 :</span>\n<span class=\"cm\">  @is_submodule.{u u} R (@polynomial.{u} R (@comm_ring.to_comm_semiring.{u} R _inst_1))</span>\n<span class=\"cm\">    (@comm_ring.to_ring.{u} R _inst_1)</span>\n<span class=\"cm\">    (@polynomial.module.{u} R (λ (a b : R), classical.prop_decidable (@eq.{u+1} R a b)) _inst_1)</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- I is an R-submodule :-/</span>\n\n<span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>There's an instance making (polynomial R) an R-module, and another instance making it a (polynomial R)-module, and <code>is_submodule</code> chooses the one I don't want. <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is there a coherent strategy to deal with this? Any time a ring is a module over another ring (and this happens all the time in commutative ring theory) we will have instances of <code>module R M</code> for fixed <code>M</code> and lots of <code>R</code>. I propose scrapping stuff like <code>is_submodule M</code> and replacing it with <code>is_submodule R M</code>. What do you think?</p>",
        "id": 133963161,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536941360
    },
    {
        "content": "<p>It's probably worth saying that it is not uncommon at all to hear mathematicians saying \"let N be an A-submodule of B\" or \"let W be a k-subspace of V\".</p>",
        "id": 133963705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536941936
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- Maths :  &quot;Let I be an ideal of R[X]&quot;</span>\n\n<span class=\"c1\">-- Lean</span>\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">is_submodule</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_module</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 133975502,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536954970
    },
    {
        "content": "<p>Lean currently has to be told that the ring <code>polynomial R</code> is a module over itself.</p>",
        "id": 133975549,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536955024
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">polynomial</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">submodule</span>\n\n<span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">,</span> <span class=\"n\">priority</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">prop_decidable</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"c1\">-- Maths :  &quot;Let I be an ideal of R[X]. Then 0 ∈ I. &quot;</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">ABC</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">is_submodule</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">I</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_submodule</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">function expected at</span>\n<span class=\"cm\">  is_submodule.zero</span>\n<span class=\"cm\">term has type</span>\n<span class=\"cm\">  ?m_1 0</span>\n<span class=\"cm\">Additional information:</span>\n<span class=\"cm\">/home/buzzard/lean-projects/mathlib-community/tests/scratch.lean:16:0: context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message</span>\n<span class=\"cm\">  too many arguments</span>\n\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>Does anyone know what <code>too many arguments</code> means in this context and why it happened?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">ABC</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">is_submodule</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_module</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">I</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_submodule</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"c1\">-- also fails</span>\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span>\n</pre></div>",
        "id": 133976193,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536955763
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">ABC</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">is_submodule</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_module</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">is_submodule</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_module</span><span class=\"o\">)</span> <span class=\"n\">I</span> <span class=\"bp\">_</span>\n</pre></div>\n\n\n<p>Zero is in an ideal of a polynomial ring! Why am I so bad at this? Is it broken or am I just overlooking something simple?</p>",
        "id": 133976867,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536956630
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> how do you prove zero is in an ideal of the ring <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mo>[</mo><mi>X</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">R[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span>?</p>",
        "id": 133976930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536956677
    },
    {
        "content": "<p>I don't</p>",
        "id": 133976938,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536956687
    },
    {
        "content": "<p>Why not?</p>",
        "id": 133976946,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536956703
    },
    {
        "content": "<p>You want algebraic closure to finish your rigorous formulation of the statement of the local Langlands conjectures for all abelian algebraic groups, a theorem of Langlands. More mathematicians will be interested in Lean if you do that. Tom Hales has already mentioned it in a talk of his -- did you see?</p>",
        "id": 133977036,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536956817
    },
    {
        "content": "<p>and for algebraic closure you're going to have to use ideals in polynomial rings quite a lot.</p>",
        "id": 133977043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536956840
    },
    {
        "content": "<p>What is the current status of your formulation project?</p>",
        "id": 133977058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536956880
    },
    {
        "content": "<p>I mean, aren't we waiting for the refactoring?</p>",
        "id": 133977216,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536957048
    },
    {
        "content": "<p>The Langlands philosophy is notorious for being a \"philosophy\", a vague web of general ideas that it's hard to make rigorous, which occasionally specialise down to very explicit conjectures but sometimes are not actually rigorous mathematical statements. If you get stuck formulating them in general then you can start asking experts in number theory how they actually formulate their grand conjectures. I think it would be really cool. Toby Gee and I spent several years of our lives trying to formulate an actual rigorous conjecture which could rightly be given the name of \"Langlands' Reciprocity Conjecture for a general connected reductive group\" and we still do not have a general conjecture which encompasses everything.</p>",
        "id": 133977241,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536957113
    },
    {
        "content": "<p><a href=\"https://arxiv.org/abs/1009.0785\" target=\"_blank\" title=\"https://arxiv.org/abs/1009.0785\">https://arxiv.org/abs/1009.0785</a></p>",
        "id": 133977297,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536957157
    },
    {
        "content": "<blockquote>\n<p>You want algebraic closure to finish your rigorous formulation of the statement of the local Langlands conjectures for all abelian algebraic groups, a theorem of Langlands. More mathematicians will be interested in Lean if you do that. Tom Hales has already mentioned it in a talk of his -- did you see?</p>\n</blockquote>\n<p>in fact I saw it recently while searching for myself</p>",
        "id": 133977302,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536957176
    },
    {
        "content": "<p>I believe that our conjecture can be formalised in Lean and I am not sure that Langlands' philosophy can, not in a way that everyone would find satisfactory at least. What if someone claimed it was the existence of some Global Langlands Group with some properties and then someone like Reid Barton or you just observed that such a group with these properties trivially exists because it's just some pullback. The \"ultimate conjecture\" is extremely vague. It says that the global Langlands group should be constructed in some way using some generalisation of Galois theory that we don't actually have.</p>",
        "id": 133977411,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536957302
    },
    {
        "content": "<p>If you just say that it's some \"Galoisish\" group whose representation theory looks like the set of automorphic representations in some vague way, and then you try to formalise what you mean, then you're in danger of someone just building a group whose representation theory has this property for trivial reasons.</p>",
        "id": 133977541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536957465
    },
    {
        "content": "<p>Jim Arthur wrote a paper about this many years ago and I wish I understood that paper better. <a href=\"http://www.claymath.org/library/cw/arthur/pdf/automorphic-langlands-group.pdf\" target=\"_blank\" title=\"http://www.claymath.org/library/cw/arthur/pdf/automorphic-langlands-group.pdf\">http://www.claymath.org/library/cw/arthur/pdf/automorphic-langlands-group.pdf</a></p>",
        "id": 133977788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536957724
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  I thought a bit more about your suggestion and of course you're right. One wants a new subtype <code>deg_le n</code> of polynomials of degree at most n, we want to prove that this is an R-module, and we want to define these increasing ideals as the projection map given by the n'th coefficient. That way we should still to the construction of the finite generating set for the ideal. There's then an induction to go but it looks really easy in this optic.</p>",
        "id": 133981310,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536961910
    },
    {
        "content": "<p>No need to assume R is non zero</p>",
        "id": 133981394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536962015
    },
    {
        "content": "<p>We just need deg (f + g) &lt;= max(deg f,deg g) and deg r*f &lt;= deg f, both of which are true unconditionally</p>",
        "id": 133981491,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536962115
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> these are the nice statements about degrees of polynomials.</p>",
        "id": 133981512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536962146
    },
    {
        "content": "<p>In some sense I'm back to square 1 with my proof but this time it's going to be far more mathlib-ready!</p>",
        "id": 133981618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536962252
    },
    {
        "content": "<p>Dumb question: if R is a ring considered as a semiring and M is a semimodule over the semiring R, is then M a module over the ring R?</p>",
        "id": 133983245,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536964073
    },
    {
        "content": "<p>Yes because <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mo>↦</mo><mo>−</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m \\mapsto -m</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.58333em;\"></span><span class=\"strut bottom\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"base\"><span class=\"mord mathit\">m</span><span class=\"mrel\">↦</span><span class=\"mord\">−</span><span class=\"mord mathit\">m</span></span></span></span> is provided by multiplication by <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>−</mo><mn>1</mn><mo>∈</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">-1 \\in R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"base\"><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span><span class=\"mrel\">∈</span><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and it satisfies the expected equation by distributivity <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>=</mo><mo>(</mo><mn>1</mn><mo>+</mo><mo>(</mo><mo>−</mo><mn>1</mn><mo>)</mo><mo>)</mo><mi>m</mi><mo>=</mo><mi>m</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">0 = (1 + (-1)) m = m - m</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathrm\">0</span><span class=\"mrel\">=</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">+</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mord mathit\">m</span><span class=\"mrel\">=</span><span class=\"mord mathit\">m</span><span class=\"mbin\">−</span><span class=\"mord mathit\">m</span></span></span></span>.</p>",
        "id": 133984088,
        "sender_full_name": "Reid Barton",
        "timestamp": 1536965286
    },
    {
        "content": "<p>I've been too busy to respond today but I see you have converged on the same solution as I have for the ideal of degree &lt;= n polynomials :)</p>",
        "id": 133985287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1536967027
    },
    {
        "content": "<p>it's not an ideal :-/</p>",
        "id": 133985565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536967374
    },
    {
        "content": "<p>this is exactly the difference between an ideal and a submodule :-) It's a submodule for one module structure but not for the other.</p>",
        "id": 133985586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536967402
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">coeff_zero_iff_deg_le</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">with_bot</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">degree</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">coeff</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">H</span> <span class=\"n\">m</span> <span class=\"n\">Hm</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">degree</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"err\">∉</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">,</span>\n      <span class=\"n\">intro</span> <span class=\"n\">H2</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sup_le_iff</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">H3</span> <span class=\"o\">:=</span> <span class=\"n\">H</span> <span class=\"n\">m</span> <span class=\"n\">H2</span><span class=\"o\">,</span>\n      <span class=\"n\">revert</span> <span class=\"n\">Hm</span><span class=\"o\">,</span>\n      <span class=\"k\">show</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">),</span>\n      <span class=\"n\">apply</span> <span class=\"n\">not_lt_of_ge</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">H3</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">not_not_iff</span> <span class=\"o\">(</span><span class=\"n\">coeff</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n      <span class=\"n\">intro</span> <span class=\"n\">H4</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">mem_support_to_fun</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">H4</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n<span class=\"c1\">--    have H2 := H (with_bot_succ n) (with_bot_lt_succ n),</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">degree</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sup_le</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">b</span> <span class=\"n\">Hb</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">mem_support_to_fun</span> <span class=\"n\">at</span> <span class=\"n\">Hb</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">coeff</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"n\">at</span> <span class=\"n\">Hb</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">of_not_not</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">Hn</span><span class=\"o\">,</span>\n    <span class=\"n\">replace</span> <span class=\"n\">Hn</span> <span class=\"o\">:=</span> <span class=\"n\">lt_of_not_ge</span> <span class=\"n\">Hn</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Hb</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Hn</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>This is with the <code>poly_coeffs</code> branch of community mathlib, with Kenny's coeff commands. I think that it might be possible to golf that a bit.</p>",
        "id": 133986217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536968179
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">coeff_zero_iff_deg_le</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">with_bot</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">degree</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">coeff</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sup</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">)</span> <span class=\"n\">some</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">Hm</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">with_bot</span> <span class=\"bp\">ℕ</span><span class=\"o\">)),</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">of_not_not</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">H4</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"err\">∉</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">,</span>\n    <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">H2</span><span class=\"o\">,</span> <span class=\"n\">not_lt_of_ge</span> <span class=\"o\">((</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sup_le_iff</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">H2</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">with_bot</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">Hm</span><span class=\"o\">,</span>\n  <span class=\"n\">H1</span> <span class=\"err\">$</span> <span class=\"o\">(</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">mem_support_to_fun</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">H4</span><span class=\"o\">,</span>\n<span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sup_le</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">Hb</span><span class=\"o\">,</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">of_not_not</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">Hn</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">mem_support_to_fun</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">Hb</span> <span class=\"err\">$</span> <span class=\"n\">H</span> <span class=\"n\">b</span> <span class=\"err\">$</span> <span class=\"n\">lt_of_not_ge</span> <span class=\"n\">Hn</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>That'a a bit better</p>",
        "id": 134000891,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536996508
    },
    {
        "content": "<p>This code seems to demonstrate various things which are currently not optimal:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">leading_term_bdd_deg_ideal</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonzero_comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">is_submodule</span> <span class=\"n\">R</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">submodule</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">coeff</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">coeff_is_linear</span> <span class=\"n\">R</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">I</span><span class=\"o\">,</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"bp\">⟩</span> <span class=\"err\">⊓</span> <span class=\"bp\">⟨</span><span class=\"n\">deg_le</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">,</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I has type <code>set S</code> for <code>S</code> a ring which is hence an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-module and an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module. I want to prove a relatively straightforward theorem about a sub-<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span>. I could have proved it for sub-<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-modules but it's true for sub-<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-modules so I have written it in the correct generality. Of course I now want to immediately apply it to a sub-<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-module and type class inference is going to struggle with that because there is some content there (the lemma that the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module structure on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is induced by a ring map <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">R\\to S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and hence any <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-module is naturally an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module, and that all these <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module structures are the same). I also have a problem with intersections of submodules. I carry around the <em>sets</em>, because the proofs that they are submodules are known to type class inference. However when I want to construct their intersection using the lattice structure I find myself having to explicitly magic up the instances to turn the sets into modules. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> this is real-world module usage -- in general I want to know that if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is a map of rings then a <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span>-module \"is\" an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span>-module. It does not sound to me like this is appropriate for type class inference. Is it? If I have to make the instances explicitly then is this an indication that modules shouldn't be typeclasses at all, or that some other sort of rethink is needed?</p>",
        "id": 134006427,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537007059
    },
    {
        "content": "<p>I will not start on this until I've finished the current refactoring, but I think it is the right time to bring this up. I think that we should drop the out_param on the scalar field of a module. Downsides:</p>\n<p>1. <code>linear_map</code>, <code>submodule</code>, <code>module</code> and other such types will require an explicit ring argument<br>\n2. <code>a • x</code> will not typecheck if the type of <code>a</code> is not specified<br>\n3. <code>add_comm_group B</code> cannot be a parent of <code>module A B</code></p>\n<p>I think (1) is mainly a problem for notation, i.e. something like <code>M1 -&gt;l M2</code> won't work since you have to shove <code>R</code> in the notation somewhere. (2) is possibly a problem if we are leaving off the type in pis or such but I can't see it having a big effect. (3) is the biggest problem, since it will add to the things you have to say about modules in proofs, but I'm already testing this change with the current refactoring. Upsides:</p>\n<p>1. no more mysterious module typeclass timeout problems<br>\n2. no more questions about what to have implicit and what to have typeclass implicit<br>\n3. you can freely use modules over different rings, even in the same proof or statement<br>\n4. we can fill out the module typeclass hierarchy, rather than hiding some instances that have bad behavior like the endomorphism ring</p>\n<p>I think that on the whole the benefits outweigh the downsides. The contract of an out_param is that you should only have one instance for <code>module ? B</code> for fixed B. This is just not true in advanced math. Indeed it's false even in the most trivial case, since you can always restrict the ring to a subring. <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thoughts?</p>",
        "id": 134026366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537045844
    },
    {
        "content": "<p>will it be finally possible to tell Lean that every abelian group is a Z-module? :D</p>",
        "id": 134026520,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1537046171
    },
    {
        "content": "<p>yes</p>",
        "id": 134026534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537046266
    },
    {
        "content": "<p>yay</p>",
        "id": 134026535,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1537046276
    },
    {
        "content": "<p>it is very similar to the removal of out_param for <code>^</code></p>",
        "id": 134026575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537046299
    },
    {
        "content": "<p>now we can have has_pow instances for <code>monoid, nat</code>, <code>group, int</code>, and <code>cardinal, cardinal</code> all at the same time</p>",
        "id": 134026583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537046352
    },
    {
        "content": "<p>I don't think I am competent enough to understand the ramifications of what you are suggesting, but I am all for changing things if you think it's a good idea, and will report back if I find any problems -- when things have settled down I will simply just go back to Hilbert and see what happens.</p>",
        "id": 134027008,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537047249
    },
    {
        "content": "<p>All I can say is that I have now seen with my own eyes that I want subsets of M to be either A-submodules or B-submodules and I am happy to say which.</p>",
        "id": 134027015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537047315
    },
    {
        "content": "<p>are you comfortable saying which in all circumstances, even when there is only one reasonable choice?</p>",
        "id": 134027060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537047366
    },
    {
        "content": "<p>I am going to say yes I'm happy doing this. It doesn't feel unnatural to say \"R-submodule\" everywhere even if there is only one ring R -- after all, the axioms for a submodule really do depend on R.</p>",
        "id": 134027170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537047634
    },
    {
        "content": "<p>and now <code>ideal</code> actually has some work to do - <code>ideal of R</code> means <code>R-submodule of R</code></p>",
        "id": 134027183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537047696
    },
    {
        "content": "<p>Of course others might not be so happy but I think that even when I teach students about vector spaces over k I might even say \"k-subspace\" a lot.</p>",
        "id": 134027185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537047710
    },
    {
        "content": "<p>Oh but actually this is now better, because for ideals I would get annoyed.</p>",
        "id": 134027225,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537047731
    },
    {
        "content": "<p>For ideals there's only one choice.</p>",
        "id": 134027226,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537047738
    },
    {
        "content": "<p>Although <code>subspace</code> is still being useless</p>",
        "id": 134027229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537047768
    },
    {
        "content": "<p>but that's Ok I think. I like the sound of this.</p>",
        "id": 134027238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537047804
    },
    {
        "content": "<p>I don't understand why <code>module A B</code> cannot have <code>add_comm_group</code> as parent? What is the problem?<br>\nFor me Point 3 (a type often has multiple different modules for different rings) is the main reason. I think everything else could be worked around eventually (maybe in Lean 4). And it looks we were already running into problems with the field instance for vector spaces. So I think this is a very good change!</p>",
        "id": 134028228,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537050108
    },
    {
        "content": "<p>If <code>module A B</code> requires both <code>A</code> and <code>B</code> before being synthesized, as would happen if <code>A</code> was no longer marked an out_param, but it had a parent coercion to <code>add_comm_group B</code>, then you could not resolve a goal like <code>has_zero B</code>. It would climb the hierarchy to <code>add_comm_group B</code>, but then the parent coercion <code>\\all A B [ring A] [module A B], add_comm_group B</code> would not be triggered since <code>A</code> is not yet known. Indeed this is a classic example of an unusable instance, since it has dependencies that don't appear in the target type.</p>",
        "id": 134038660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537072384
    },
    {
        "content": "<p>Is there a place where I can find all the classes (like linear_order or module)? I think my distances are a semi module, but I don't know where they are, and they might even be something stronger.</p>",
        "id": 134045911,
        "sender_full_name": "Ali Sever",
        "timestamp": 1537087017
    },
    {
        "content": "<p><code>git grep</code> says there are about 200 classes</p>",
        "id": 134045961,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537087117
    },
    {
        "content": "<p>but probably there's a bunch of false positives. What do you want to do with them now? Just look at them?</p>",
        "id": 134045966,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537087138
    },
    {
        "content": "<p>I don't think I could sift through 200</p>",
        "id": 134046014,
        "sender_full_name": "Ali Sever",
        "timestamp": 1537087227
    },
    {
        "content": "<p>If you're now assuming the parallel postulate then you can divide by a positive integer, so your distances are now probably a semi vector space over the semi field Q_{&gt;=0}. But I am not sure that these concepts exist or are useful</p>",
        "id": 134046015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537087239
    },
    {
        "content": "<p>Hmm, I guess <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span></span></span> is a semi-module over <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"double-struck\">Q</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.938001em;vertical-align:-0.16667em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> with no basis, so there will be no theorem of the form that every semimodule over <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"double-struck\">Q</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.938001em;vertical-align:-0.16667em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> has a basis (in contrast to the theory of fields, where every vector space has a basi).</p>",
        "id": 134046021,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537087312
    },
    {
        "content": "<p>I have a linear_order, with a 0. My angles have a maximum in addition to that, but I plan to turn them into mod 360 (or 2*pi).</p>",
        "id": 134046058,
        "sender_full_name": "Ali Sever",
        "timestamp": 1537087324
    },
    {
        "content": "<p>Your angles currently are [0,180] basically, right? Or (0,180) or something.</p>",
        "id": 134046061,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537087358
    },
    {
        "content": "<p>inclusive, but I don't need to make those at the moment. But I would like to have a linear order and a minimum (which is 0).</p>",
        "id": 134046067,
        "sender_full_name": "Ali Sever",
        "timestamp": 1537087425
    },
    {
        "content": "<p>The point of this thread was for me to whinge about modules and ideals and things, but mathlib is currently undergoing a bit of a transition in the way it handles this stuff. So introducing semimodules into your work might mean that you have to rewrite later. As you might have seen from yesterday, there seems to be still some discussion about exactly how the semiring will be mentioned (or perhaps decisions have been made but not implemented yet).</p>",
        "id": 134046108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537087501
    },
    {
        "content": "<p>Ok, I guess I'll just have a linear_order, and a theorem that says everything is bigger than 0.</p>",
        "id": 134046156,
        "sender_full_name": "Ali Sever",
        "timestamp": 1537087596
    },
    {
        "content": "<p>well you can certainly have a linear order. I don't think looking through all of Lean trying to spot classes is the way to see what's there. I think you should look through mathlib, spot a directory or a file which looks relevant to you like <code>order/basic.lean</code> and then take a look at the types and typeclasses being used in that file. Right click on something like <code>preorder</code> to find where it's defined (a preorder is another example of something which is used a lot in Lean but which is hardly ever defined or used in a maths UG degree, we see partial orders but this is even weaker) and then just poke around. I just tried this and ending up finding my way to core Lean's <code>init/algebra/order.lean</code> very quickly. I think doing stuff like this can be pretty instructive.</p>",
        "id": 134046163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537087672
    },
    {
        "content": "<blockquote>\n<p>will it be finally possible to tell Lean that every abelian group is a Z-module? :D</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> do you think we're ready to teach Lean this fact?</p>",
        "id": 147286411,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541667758
    }
]
[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> Why doesn't <code>equiv_like</code> extend <code>fun_like</code>? I mean, I know why it can't with the current definition (because the the <code>coe_injective</code> is different). But it seems that this is not required because the second argument of <code>equiv_like.coe_injective</code> can be derived from everything else, so it is redundant in the implicaiton. See below. Changing this would allow all the <code>equiv_type</code> classes to be just extensions of <code>equiv_like</code> as well as the corresponding <code>fun_like</code> instances for whatever morphisms we care about.</p>\n<p>I was led to this from the consideration about <code>alg_equiv_class</code> that I mentioned before in this thread: <a href=\"#narrow/stream/113488-general/topic/redefining.20alg_equiv_class\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/redefining.20alg_equiv_class</a>. Namely, I really wanted to simplify the typeclass assumptions to <code>has_{mul,add,smul}</code> on both the source and the target. If we had a <code>smul_equiv_class</code>, I could do that, but we don't, we only have a <code>smul_hom_class</code>. (Maybe we <em>should</em> have a <code>smul_equiv_class</code>, but that's beside the point.) So, I tried <code>smul_hom_class</code> and that led to an error because I can't extend both <code>smul_hom_class</code> and <code>ring_equiv_class</code> since <code>equiv_like</code> and <code>fun_like</code> have different <code>coe_injective</code> fields.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fun_like.equiv</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">equiv_like</span> <span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">e₁</span> <span class=\"n\">e₂</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">equiv_like.coe</span> <span class=\"n\">e₁</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>  <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">equiv_like.coe</span> <span class=\"n\">e₂</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">equiv_like.inv</span> <span class=\"n\">e₁</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">equiv_like.inv</span> <span class=\"n\">e₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">funext</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">equiv_like.left_inv</span> <span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">_</span> <span class=\"n\">e₂</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">equiv_like.right_inv</span> <span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">_</span> <span class=\"n\">e₁</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h₂</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">nth_rewrite</span> <span class=\"mi\">0</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n  <span class=\"n\">nth_rewrite</span> <span class=\"mi\">1</span> <span class=\"bp\">←</span><span class=\"n\">h₂</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h₁</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 294177370,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660860289
    },
    {
        "content": "<p>I recall my reasoning was that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv_like.coe_injective'\">docs#equiv_like.coe_injective'</a> is much easier to prove in practice: <code>by { intros f g h₁ h₂; cases f; cases g; congr'}</code>. Not allowing diamond inheritance is annoying indeed, so if you know a nice way to keep proofs of <code>coe_injective</code> easy then I'm not going to object to changing this.</p>",
        "id": 294219027,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1660896450
    },
    {
        "content": "<p>Note however that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_equiv_class\">docs#ring_equiv_class</a> is not just <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_hom_class\">docs#ring_hom_class</a> with an extra inverse: bijective maps automatically preserve zero and one, so we don't include <code>map_zero</code> and <code>map_one</code> fields. So I don't know how many cases the diamond inheritance actually helps with. (Similarly for <code>alg_equiv_class</code>.)</p>",
        "id": 294219426,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1660896652
    },
    {
        "content": "<p><del>Why do we case whether equiv_like extends fun_like when we already have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv_like.fun_like\">docs#equiv_like.fun_like</a>?</del> oh, we don't have that</p>",
        "id": 294219487,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660896689
    },
    {
        "content": "<p>We do, it just goes via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv_like.to_embedding_like\">docs#equiv_like.to_embedding_like</a> :)</p>",
        "id": 294219635,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1660896748
    },
    {
        "content": "<p>The specific thing that we don't have is being able to say <code>extends foo_equiv_class, bar_hom_class</code>.</p>",
        "id": 294219750,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1660896822
    },
    {
        "content": "<p>I think one way to keep the equiv_like proofs easy is just to have a custom constructor for <code>equiv_like</code> which eats the current version and spits out the new version with the fun_like coe_injective field. Of course, we probably wouldn't want to have such a constructor for every extension of equiv_like, so this may lead to slightly ugly proofs like the one below. And of course this isn't quite as intuitive, so we would need to add something to the documentation to the effect of \"always use the custom constructor when creating instances.\"</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">add_equiv_class</span> <span class=\"n\">F</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_add</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">custom_constructor</span>\n  <span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">coe_injective</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 294272633,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660917698
    },
    {
        "content": "<p>does this seem reasonable?</p>",
        "id": 294273369,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660917927
    },
    {
        "content": "<p>I just saw your code note in <code>equiv_like</code> about your reasoning for including the <code>inv</code> in the <code>coe_injective</code> field, sorry!</p>",
        "id": 294275355,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660918596
    },
    {
        "content": "<p>This is what it would look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fun_like.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.congr</span>\n\n<span class=\"c1\">-- this would be the basic setup</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">equiv_like.core</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">left_inv</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">function.left_inverse</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">function.right_inverse</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n<span class=\"c1\">-- The `inv` hypothesis makes this easier to prove with `congr'`</span>\n<span class=\"o\">(</span><span class=\"n\">coe_injective'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">coe</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">inv</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">inv</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">equiv_like.inv_eq_of_coe_eq</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">equiv_like.core</span> <span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">e₁</span> <span class=\"n\">e₂</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h_eq</span> <span class=\"o\">:</span> <span class=\"n\">h.coe</span> <span class=\"n\">e₁</span> <span class=\"bp\">=</span> <span class=\"n\">h.coe</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">h.inv</span> <span class=\"n\">e₁</span> <span class=\"bp\">=</span> <span class=\"n\">h.inv</span> <span class=\"n\">e₂</span> <span class=\"o\">:=</span>\n<span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h.left_inv</span> <span class=\"n\">e₂</span> <span class=\"o\">(</span><span class=\"n\">h.inv</span> <span class=\"n\">e₁</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">h.inv</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_eq</span> <span class=\"bp\">▸</span> <span class=\"n\">h.right_inv</span> <span class=\"n\">e₁</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">equiv_like</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">fun_like</span> <span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">left_inv</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">function.left_inverse</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">function.right_inverse</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">equiv_like.of_core</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">equiv_like.core</span> <span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">equiv_like</span> <span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">h.coe</span><span class=\"o\">,</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">h.coe_injective'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">he</span> <span class=\"o\">(</span><span class=\"n\">equiv_like.inv_eq_of_coe_eq</span> <span class=\"n\">h</span> <span class=\"n\">he</span><span class=\"o\">),</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">h.inv</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"n\">h.left_inv</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"n\">h.right_inv</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">----- then an example to see how it works in practice</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">add_equiv_class</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">equiv_like</span> <span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">e</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">add_equiv</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inv_fun</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">left_inv</span> <span class=\"o\">:</span> <span class=\"n\">function.left_inverse</span> <span class=\"n\">inv_fun</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"n\">function.right_inverse</span> <span class=\"n\">inv_fun</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_add'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">to_fun</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">to_fun</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">add_equiv.add_equiv_class</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">add_equiv_class</span> <span class=\"o\">(</span><span class=\"n\">add_equiv</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.map_add'</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"n\">equiv_like.of_core</span> <span class=\"o\">(</span><span class=\"n\">add_equiv</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.to_fun</span><span class=\"o\">,</span>\n    <span class=\"n\">coe_injective'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">e₁</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">e₂</span><span class=\"bp\">;</span> <span class=\"n\">congr'</span> <span class=\"o\">},</span>\n    <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.inv_fun</span><span class=\"o\">,</span>\n    <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.left_inv</span><span class=\"o\">,</span>\n    <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.right_inv</span><span class=\"o\">,</span> <span class=\"o\">})</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 294286827,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660922154
    },
    {
        "content": "<p>Another way, almost certainly better: rename the current <code>equiv_like.coe_injective'</code> field to <code>equiv_like.coe_inv_injective</code>, and then have autofill the <code>equiv_like.coe_injective'</code> (with the <code>fun_like.coe_injective'</code> definition) with the necessary lemma.</p>",
        "id": 294334352,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660931433
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 294334928,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660931637
    },
    {
        "content": "<p>Why not just have a lemma that proves <code>fun_like.coe_injective'</code> from the current <code>equiv_like.coe_injective'</code>, that we would then systematically apply, instead of doing this with a whole structure?</p>",
        "id": 294338002,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1660932689
    },
    {
        "content": "<p>Also, if we make <code>equiv_like</code> extend <code>fun_like</code>, my guess is that the <code>coe_injective'</code> proof would almost always come from the corresponding hom anyway, so we would almost never actually have to prove it \"by hand\".</p>",
        "id": 294338297,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1660932809
    },
    {
        "content": "<p>What are you trying to achieve, Jireh? I don't understand how this has to do with what class extends what.</p>",
        "id": 294338396,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660932843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/116395-maths/topic/equiv_like.20extending.20fun_like/near/294338297\">said</a>:</p>\n<blockquote>\n<p>Also, if we make <code>equiv_like</code> extend <code>fun_like</code>, my guess is that the <code>coe_injective'</code> proof would almost always come from the corresponding hom anyway, so we would almost never actually have to prove it \"by hand\".</p>\n</blockquote>\n<p>No, Anne has a point here, it would be (comparatively) hard to prove the <code>fun_like.coe_injective'</code> field when creating an instance of <code>equiv_like</code> for some kind of <code>equiv</code> type. (if you don't understand, try it directly and you'll realize why it's hard.)</p>",
        "id": 294340033,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660933516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/equiv_like.20extending.20fun_like/near/294338396\">said</a>:</p>\n<blockquote>\n<p>What are you trying to achieve, Jireh? I don't understand how this has to do with what class extends what.</p>\n</blockquote>\n<p>The point is to make <code>equiv_like</code> extend <code>fun_like</code>, and that way you can write things like <code>class new_equiv_class extends old_equiv_class, some_hom_class</code>, which we currently can't do.</p>",
        "id": 294340222,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660933587
    },
    {
        "content": "<p>Give me a few minutes and I'll have something nice working that should be almost a drop-in replacement.</p>",
        "id": 294340275,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660933611
    },
    {
        "content": "<p>Okay, but why do you care about the extension mechanism? This is an implementation detail, even from the point of view of API writing!</p>",
        "id": 294340411,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660933662
    },
    {
        "content": "<p>I'm not sure how what I just said doesn't explain why I care. Yes, of course this is an implementation detail, but the point is I'm looking to improve the implementation slightly.</p>",
        "id": 294340901,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660933841
    },
    {
        "content": "<p>I am trying to un-xy, and you just gave me another x!</p>",
        "id": 294341149,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660933930
    },
    {
        "content": "<p>Read the second paragraph of the first post in the thread. If that doesn't explain it, then I'm not sure why we're not understanding each other.</p>",
        "id": 294341308,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660933995
    },
    {
        "content": "<blockquote>\n<p>So, I tried <code>smul_hom_class</code> and that led to an error because I can't extend both <code>smul_hom_class</code> and <code>ring_equiv_class</code> since <code>equiv_like</code> and <code>fun_like</code> have different <code>coe_injective</code> fields.</p>\n</blockquote>\n<p>Why can't you copy over the fields? This is the standard procedure when you can't use <code>extends</code>.</p>",
        "id": 294341458,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660934056
    },
    {
        "content": "<p>Of course you can! I don't want to. I want things to Just Workᵀᴹ. This is just one small way to make that happen.</p>",
        "id": 294341814,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660934181
    },
    {
        "content": "<p>It's certainly not a dire point.</p>",
        "id": 294341872,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660934204
    },
    {
        "content": "<p>I'm not sure why this is broken, presumably it has something to do with the <code>show</code>, but if I could fix whatever the issue here is, this change would essentially amount to a renaming of <code>coe_injective'</code> to <code>coe_inv_injective'</code> wherever an instance of <code>some_equiv_class</code> is declared.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fun_like.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.congr</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">equiv_like.coe_injective_of_coe_inv</span> <span class=\"o\">(</span><span class=\"n\">coe'</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inv'</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">left_inverse</span> <span class=\"o\">(</span><span class=\"n\">inv'</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">coe'</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">right_inverse</span> <span class=\"o\">(</span><span class=\"n\">inv'</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">coe'</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">,</span> <span class=\"n\">coe'</span> <span class=\"n\">e₁</span> <span class=\"bp\">=</span> <span class=\"n\">coe'</span> <span class=\"n\">e₂</span> <span class=\"bp\">→</span> <span class=\"n\">inv'</span> <span class=\"n\">e₁</span> <span class=\"bp\">=</span> <span class=\"n\">inv'</span> <span class=\"n\">e₂</span> <span class=\"bp\">→</span> <span class=\"n\">e₁</span> <span class=\"bp\">=</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">injective</span> <span class=\"n\">coe'</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span> <span class=\"n\">he</span> <span class=\"bp\">$</span> <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hl</span> <span class=\"n\">e₂</span> <span class=\"o\">(</span><span class=\"n\">inv'</span> <span class=\"n\">e₁</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">▸</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">inv'</span> <span class=\"n\">e₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">he</span> <span class=\"bp\">▸</span> <span class=\"n\">hr</span> <span class=\"n\">e₁</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">equiv_like</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">fun_like</span> <span class=\"n\">E</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">left_inv</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">function.left_inverse</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">function.right_inverse</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">coe_inv_injective'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">coe</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">inv</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">inv</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">coe_injective'</span> <span class=\"o\">:=</span> <span class=\"n\">equiv_like.coe_injective_of_coe_inv</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">coe</span><span class=\"o\">)</span> <span class=\"n\">inv</span> <span class=\"n\">left_inv</span>\n  <span class=\"n\">right_inv</span> <span class=\"n\">coe_inv_injective'</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inv_fun</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">left_inv</span> <span class=\"o\">:</span> <span class=\"n\">function.left_inverse</span> <span class=\"n\">inv_fun</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"n\">function.right_inverse</span> <span class=\"n\">inv_fun</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">equiv.equiv_class</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">equiv_like</span> <span class=\"o\">(</span><span class=\"n\">equiv</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.to_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.inv_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.left_inv</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.right_inv</span><span class=\"o\">,</span>\n  <span class=\"n\">coe_inv_injective'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 294343148,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660934742
    },
    {
        "content": "<p>Any help fixing it is appreciated, although it seems like I'm the only one who values this! <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 294343712,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660934993
    },
    {
        "content": "<p>okay, I would actually really appreciate if someone can debug the code immediately above (I have edited it slightly), because it feels like an actual bug in Lean to me, but I know virtually nothing. Note that with <code>pp.all true</code> the two types that it is complaining about are <em>verbatim</em> the same; I know for certain because I copied them to two files and <code>diff</code>ed them.</p>",
        "id": 294349574,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660937435
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, is this an actual bug, or am I just really stupid somehow?</p>",
        "id": 294355852,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660939987
    },
    {
        "content": "<p>sorry, I just noticed there is also this error, but I'm not sure why it's happening: <code>Error updating: deep recursion was detected at 'expression replacer' (potential solution: increase stack space in your system).</code></p>",
        "id": 294356369,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660940183
    },
    {
        "content": "<p>I don't know what to make of the fact that <code>?coe_inv_injective'</code> appears in that type</p>",
        "id": 294356414,
        "sender_full_name": "Reid Barton",
        "timestamp": 1660940209
    },
    {
        "content": "<p>In case you didn't read the whole thread (expected), this almost certainly has something to do with line 21, note that <code>coe_injective'</code> is a field of <code>fun_like</code>, the class that this <code>equiv_like</code> is extending. Have I done something we're not allowed to do?</p>",
        "id": 294356647,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660940307
    },
    {
        "content": "<p>yeah I think reid found the bug. The type of the metavariable refers to the metavariable itself, so you can't assign it</p>",
        "id": 294357160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660940534
    },
    {
        "content": "<p>if you put something other than <code>sorry</code> there, or remove it, or type ascribe it the error may go away</p>",
        "id": 294357349,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1660940617
    },
    {
        "content": "<p>with the additional import <code>tactic.congr</code> and replacing the <code>sorry</code> by the usual proof that goes here, namely: <code>λ e g h₁ h₂, by { cases e; cases g; congr' }</code>, then this fails with </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">result</span> <span class=\"n\">contains</span> <span class=\"kd\">meta</span><span class=\"bp\">-</span><span class=\"kd\">variables</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">no</span> <span class=\"n\">goals</span>\n</code></pre></div>",
        "id": 294357759,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660940804
    },
    {
        "content": "<p>what does <code>recover</code> do?</p>",
        "id": 294358134,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660940997
    },
    {
        "content": "<p>Same type mismatch as before, although this time without the deep recursion problem. The metavariable ?coe_inv_injective' still appears in the type.</p>",
        "id": 294358336,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660941073
    },
    {
        "content": "<p>Is this just something we're not capable of doing (i.e., assigning default values to fields of structures we're extending)?</p>",
        "id": 294358501,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660941144
    },
    {
        "content": "<p>It is definitely possible, but <a href=\"#narrow/stream/113488-general/topic/.22type.20has.20metavariables.22.20error.20in.20structure.20default.20field\">I've encountered problems doing so myself</a>.</p>",
        "id": 294358634,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660941221
    },
    {
        "content": "<p>Ha! fixed with <code>set_option old_structure_command true</code>, which I probably wanted anyway. <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 294359750,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660941759
    },
    {
        "content": "<p>The real fix is not extracting that lemma <code>equiv_like.coe_injective_of_coe_inv</code>.</p>",
        "id": 294364751,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660944047
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/16161\">#16161</a> is essentially a drop-in replacement for <code>equiv_like</code>.</p>",
        "id": 294477887,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661025496
    },
    {
        "content": "<blockquote>\n<p>And of course this isn't quite as intuitive, so we would need to add something to the documentation to the effect of \"always use the custom constructor when creating instances.\"</p>\n</blockquote>\n<p>But conversely, users of <code>{! !}</code> will now be prompted to provide both versions of the <code>coe_injective</code> field;  so the new version will also need something in the documentation explaining that <code>coe_injective</code> should not be provided explicitly.</p>",
        "id": 294764908,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661201482
    },
    {
        "content": "<p>In fact, I've been doing the reverse change in other structures throughout the library: If making <code>A</code> extend <code>B</code> results in a redundant field, do not extend <code>B</code> and write the instance manually.</p>",
        "id": 294765196,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661201611
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>, do you have an example based on <a href=\"https://github.com/leanprover-community/mathlib/pull/16161\">#16161</a> that demonstrates a situation where <code>class new_equiv_class extends old_equiv_class, some_hom_class</code> is useful? I note that you don't change any of the existing typeclasses to use this spelling; was that to keep the PR small, or because none of the existing typeclasses fit into this pattern?</p>",
        "id": 294765467,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661201743
    },
    {
        "content": "<p>And there are many common examples as well. Eg <a href=\"https://leanprover-community.github.io/mathlib_docs/find/group\">docs#group</a> doesn't extend <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cancel_monoid\">docs#cancel_monoid</a> but instead we have the manual <a href=\"https://leanprover-community.github.io/mathlib_docs/find/group.to_cancel_monoid\">docs#group.to_cancel_monoid</a>. Or again <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring\">docs#ring</a> doesn't extend <a href=\"https://leanprover-community.github.io/mathlib_docs/find/semiring\">docs#semiring</a>.</p>",
        "id": 294765511,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661201759
    },
    {
        "content": "<p>I think the difference here is that those all share a common <code>has_mul</code> ancestor though, so you can still extend them all at once later without duplicate field name conflicts.</p>",
        "id": 294765685,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661201836
    },
    {
        "content": "<p>We don't have a <code>barely_fun_like</code> ancestor to share the <code>coe</code> field of <code>equiv_like</code> and <code>fun_like</code></p>",
        "id": 294765809,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661201883
    },
    {
        "content": "<p>If we did, then I think Jireh's problem would be solvable using <code>renaming</code> to solve the conflict in the non-data fields</p>",
        "id": 294765882,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661201923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/equiv_like.20extending.20fun_like/near/294765685\">said</a>:</p>\n<blockquote>\n<p>I think the difference here is that those all share a common <code>has_mul</code> ancestor though, so you can still extend them all at once later without duplicate field name conflicts.</p>\n</blockquote>\n<p>But we never do! because that would still result in redundant fields, however far in the hierarchy you're going.</p>",
        "id": 294765922,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661201948
    },
    {
        "content": "<p>But at least in user code, you <em>could</em> do that. You're right though, the cases probably doesn't come up in mathlib</p>",
        "id": 294766100,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661202016
    },
    {
        "content": "<p>I maintain that whether a typeclass extends another or not is an implementation detail, even from the implementation perspective.</p>",
        "id": 294766287,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661202118
    },
    {
        "content": "<p>The tradeoff here is \"easeness to extend structure <code>A</code>\" vs \"easeness to provide instances/definitions of structure <code>A</code>\". Most likely, the latter is more common.</p>",
        "id": 294766432,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661202177
    },
    {
        "content": "<p>To answer the <code>@</code> mention: the example that caused me to look at this in the first place was redefining <code>alg_equiv_class</code> so that it works for both unital and non-unital (even non-associative) algebras. For this it should (or could) be <code>extends ring_equiv_class, smul_hom_class</code>.</p>",
        "id": 294766609,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661202247
    },
    {
        "content": "<p>I tried to do that, it didn't work, I went hunting and realized it should be possible to make <code>equiv_like</code> extend <code>fun_like</code>, hence this PR.</p>",
        "id": 294766740,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661202307
    },
    {
        "content": "<p>Yaël, I contend that it's just as easy to provide instances now as it was before. I made sure that this would be a drop-in replacement.</p>",
        "id": 294766823,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661202346
    },
    {
        "content": "<p>And Eric, I'm not sure of other examples, but yes, I was trying to keep the PR small and make sure nothing really worked differently.</p>",
        "id": 294766923,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661202380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/equiv_like.20extending.20fun_like/near/294764908\">said</a>:</p>\n<blockquote>\n<p>But conversely, users of <code>{! !}</code> will now be prompted to provide both versions of the <code>coe_injective</code> field;  so the new version will also need something in the documentation explaining that <code>coe_injective</code> should not be provided explicitly.</p>\n</blockquote>\n<p>I thought I had this explanation in the PR already; <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> maybe I <code>git stash</code>ed that documentation somewhere.</p>",
        "id": 294767499,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661202623
    },
    {
        "content": "<p>I still feel like this is a move in the wrong direction. Many less people will try extending <code>equiv_like</code> than there will be people proving <code>equiv_like</code> instances.</p>",
        "id": 294768275,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661202965
    },
    {
        "content": "<p>To me, extending it makes more sense, despite the fact that I concede your contention that instances are more common than extensions. I fully expected <code>equiv_like</code> to extend <code>fun_like</code> because I think of it has <code>some_fun_like</code> + an inverse, where the <code>fun_like</code> assumptions that go in the <code>equiv_like</code> are as weak as possible, not necessarily the one for the hom class. </p>\n<p>But look, I agree it's just an implementation detail. It's one that I quite like to have this way, but I am content to be overruled as well. It's a collaboration after all, so if people don't prefer it then that's fine.</p>",
        "id": 294769355,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661203511
    },
    {
        "content": "<blockquote>\n<p>I fully expected <code>equiv_like</code> to extend <code>fun_like</code> because I think of it has <code>some_fun_like</code> + an inverse</p>\n</blockquote>\n<p>Actually, this pattern basically never holds:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_equiv\">docs#order_equiv</a> doesn't extend <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_hom\">docs#order_hom</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_equiv\">docs#mul_equiv</a> doesn't extend <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_hom\">docs#monoid_hom</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/homeomorph\">docs#homeomorph</a> doesn't extend <a href=\"https://leanprover-community.github.io/mathlib_docs/find/continuous_map\">docs#continuous_map</a></li>\n</ul>\n<p>Maybe your expectation comes from this set-theoretic idea of using bijections, rather than equivalences?</p>",
        "id": 294770573,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661204148
    },
    {
        "content": "<p>Yaël, that's not what I meant. I mean that I think of <code>mul_equiv_class</code> as <code>mul_hom_class</code> + <code>equiv_like</code>. I think of <code>ring_equiv_class</code> as <code>mul_hom_class</code> + <code>add_equiv_class</code>, etc. I do <em>not</em> think of them as extending the <em>corresponding</em> hom, only the hom which is the \"right\" one. I know that the pattern you described doesn't hold; hence my desire to redefine <code>alg_equiv_class</code> in the first place.</p>",
        "id": 294771165,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661204433
    },
    {
        "content": "<p>The point is: we only ever assume properties about the <code>coe</code> function, not the <code>inv</code> (aside from the fact that it's an inverse).</p>",
        "id": 294771396,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661204559
    },
    {
        "content": "<p>Wrong: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/homeomorph\">docs#homeomorph</a></p>",
        "id": 294771486,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661204626
    },
    {
        "content": "<p>aha, touché. That is the canonical example after all, I should have been more careful.</p>",
        "id": 294771813,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661204797
    },
    {
        "content": "<p>In any case, if people don't want it, then we just don't merge it. You're welcome to set up a poll if you wish.</p>",
        "id": 294772076,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661204946
    },
    {
        "content": "<p>I don't follow the argument against this change. I can see this being not very useful and not worth the effort in the worst case, but since the work is already done, why not?</p>",
        "id": 294774977,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1661206572
    },
    {
        "content": "<p>As I said above, I already performed the analogous change in the opposite direction for other classes, like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/boolean_algebra\">docs#boolean_algebra</a>.</p>",
        "id": 294775117,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661206661
    },
    {
        "content": "<p>Perhaps the conclusion we should be drawing from this discussion is that the Hierarchy Builder people are onto something with their notion of Factory (which corresponds in Lean to something like the <code>{..s}</code> notation for defining a structure).</p>",
        "id": 295041629,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1661346088
    },
    {
        "content": "<p>Sorry, I don't understand that comment. Can you elaborate?</p>",
        "id": 295042755,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661346504
    },
    {
        "content": "<p>The problem we're kind of running into here is that we have no good way to customize the relation between <code>fun_like</code>s and <code>equiv_like</code>s, because the built-in structure syntax <code>{ inv := inv, .. (by apply_instance : fun_like whatever) }</code> doesn't work. Hierarchy Builder's factories by default work something like Lean's built-in structure syntax but can be overridden to do the right thing here.</p>",
        "id": 295043579,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1661346761
    }
]
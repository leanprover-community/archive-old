[
    {
        "content": "<p>Ok so here is the perfectoid spaces thread. As many people here know, I've long been mulling over the idea of formalising the notion of a perfectoid space in Lean. To the CS people -- it's just some structure, like a group, just a few more axioms and things.</p>",
        "id": 127307288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686544
    },
    {
        "content": "<p>The problem is that I'm a mathematician and I'm not very good at building structures in Lean yet because I haven't practiced enough yet.</p>",
        "id": 127307303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686569
    },
    {
        "content": "<p>So here's the plan.</p>",
        "id": 127307309,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686582
    },
    {
        "content": "<p>I'm going to make a public github repo called lean-perfectoid-spaces</p>",
        "id": 127307320,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686601
    },
    {
        "content": "<p>and then we develop what we need in there.</p>",
        "id": 127307327,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686618
    },
    {
        "content": "<p>What are the main ingredients? I'll explain these things in an issue.</p>",
        "id": 127307333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686640
    },
    {
        "content": "<p>But in short, we need adic spaces</p>",
        "id": 127307375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686657
    },
    {
        "content": "<p>so we need presheaves and sheaves of topological rings</p>",
        "id": 127307379,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686671
    },
    {
        "content": "<p>and we need affinoid adic spaces</p>",
        "id": 127307384,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686690
    },
    {
        "content": "<p>so we need the notion of a valuation on a ring</p>",
        "id": 127307387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686696
    },
    {
        "content": "<p>Now here's a dumb thing that everyone knew already but only dawned on me recently.</p>",
        "id": 127307407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686723
    },
    {
        "content": "<p>There are two ways to make a perfectoid space -- a \"top down\" way, where you define a perfectoid space to be an adic space with some property and define an adic space afterwards -- you sorry your way from the top and attempt to connect to the bottom.</p>",
        "id": 127307465,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686768
    },
    {
        "content": "<p>Or there's a \"bottom up\" way, where you think \"we'll definitely need adic spaces so we'll need affinoid adic spaces so we'll need valuations so we'll need a way of turning a totally ordered group into a totally ordered monoid by adding a bottom element and I think we have that, or we nearly have that anyway, so let's start with that and then build up\"</p>",
        "id": 127307477,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686818
    },
    {
        "content": "<p>With schemes I read the stacks project from front to back and I made the definition from the bottom up.</p>",
        "id": 127307485,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686842
    },
    {
        "content": "<p>Are there advantages in working from the top down?</p>",
        "id": 127307495,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686866
    },
    {
        "content": "<p>Next, who should be allowed to push? Is it sensible to start with just me and force other people to learn about PRs and so on?</p>",
        "id": 127307556,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686925
    },
    {
        "content": "<p>As a git newbie I found it far easier to just give Kenny full access to the stacks project repo</p>",
        "id": 127307565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686946
    },
    {
        "content": "<p>but the result of this was that one day I realised there were a bunch of files in my project which I had no idea what they did</p>",
        "id": 127307574,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686980
    },
    {
        "content": "<p>and then when Lean upgraded and they all broke and Kenny was revising for exams I was sort-of stuck.</p>",
        "id": 127307578,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527686995
    },
    {
        "content": "<p>Should I concentrate on making sure I understand every line of code in the project, or should this be something which I should be happy to delegate?</p>",
        "id": 127307635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527687020
    },
    {
        "content": "<p>Those are my initial thoughts. I've been really busy recently with marking issues but now these things are over and I hope to find some time to put into this.</p>",
        "id": 127307644,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527687055
    },
    {
        "content": "<p>I think that you should be able to understand every line of code in the project, but it does not mean than you cannot delegate and grant push access to others. Just that you should be ready to revert commits, ask for freezing etc. This is how the Feit Thompson proof was written, with many people having commit rights (it was not even a git repo).</p>",
        "id": 127307979,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1527687559
    },
    {
        "content": "<p>I have never seen anything serious being done top down. I have been working for some time with some axiomatic algebraic numbers, waiting form the completion of the closure construction, and even for such a simple thing, one of the axioms was wrong (I don't remember the details) . So I find it scary because it is usually hard to get definitions right at the first stab. And the one you're aiming at is a truly complex one. But may be you could try to build the bridge simultaneously from the two ends, and hope for the best. One really useful thing is to write down the complete roadmap somewhere, as precise as possible. But this is what will go in your issue right? Are there components that can be done in parallel?</p>",
        "id": 127308229,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1527687960
    },
    {
        "content": "<p>I love this place.</p>",
        "id": 127309013,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527688948
    },
    {
        "content": "<p>Assia -- <em>many</em> thanks for your very quick and extremely helpful response.</p>",
        "id": 127309018,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527688962
    },
    {
        "content": "<p>I will begin, hopefully before the weekend, by creating a repo and writing an extended issue explaining as much as I know about what needs to be done.</p>",
        "id": 127309036,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527688995
    },
    {
        "content": "<p>There should be several things which can be done in parallel.</p>",
        "id": 127309046,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527689015
    },
    {
        "content": "<p>I remember now -- when I talked about making something else I wanted in mathlib, Mario suggested that I wrote as detailed an explanation as possible and made it an issue.</p>",
        "id": 127309097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527689066
    },
    {
        "content": "<p>I'm at the London Number Theory Seminar and it's being given by Matthew Morrow, co-author of several papers with Scholze and perfectoid expert! I just asked him what the definition of a perfectoid space was and I'm glad I did -- he said that he definition has gone through several iterations but he was now happy with it, and gave me a precise reference -- Scholze's paper \"etale cohomology of diamonds\".</p>",
        "id": 127312071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527692770
    },
    {
        "content": "<p><a href=\"https://arxiv.org/abs/1709.07343\" target=\"_blank\" title=\"https://arxiv.org/abs/1709.07343\">https://arxiv.org/abs/1709.07343</a></p>",
        "id": 127312094,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527692798
    },
    {
        "content": "<p>That is the definition we will be formalizing.</p>",
        "id": 127312095,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527692806
    },
    {
        "content": "<p>The paper is under 9 months old. To the CS people -- the reason that defining a random structure is interesting to mathematicians is that this is a cutting-edge structure.</p>",
        "id": 127312134,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527692861
    },
    {
        "content": "<p>It is definition 3.19 on page 18 of (v1 of) the paper at the above link</p>",
        "id": 127312247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527692952
    },
    {
        "content": "<p>It's funny Scholze refers to Fontaine's Bourbaki talk about Scholze</p>",
        "id": 127312333,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1527693015
    },
    {
        "content": "<p>Maybe this theory is actually circular</p>",
        "id": 127312343,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1527693035
    },
    {
        "content": "<p>:-)</p>",
        "id": 127312587,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693305
    },
    {
        "content": "<p>Fontaine only defines perfectoid rings</p>",
        "id": 127312594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693312
    },
    {
        "content": "<p>Technical interlude: in Scholze's original paper he only defined a perfectoid space over a field; Fontaine was the first person to make the definition live independently without being bound to an underlying field</p>",
        "id": 127312661,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693365
    },
    {
        "content": "<p>OK so here's a theorem in maths:</p>",
        "id": 127312669,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693375
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi><mrow><mi>c</mi><mi>y</mi><mi>c</mi><mi>l</mi></mrow></msubsup><mo>[</mo><mo>[</mo><msup><mi>T</mi><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi mathvariant=\"normal\">∞</mi></msup></mrow></msup><mo>]</mo><mo>]</mo><mo>⟨</mo><mo>(</mo><mi>p</mi><mi mathvariant=\"normal\">/</mi><mi>T</mi><msup><mo>)</mo><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi mathvariant=\"normal\">∞</mi></msup></mrow></msup><mo>⟩</mo><mo>[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>T</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p^{cycl}[[T^{1/p^\\infty}]]\\langle(p/T)^{1/p^\\infty}\\rangle[1/T]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8879999999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.271108em;vertical-align:-0.383108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.383108em;\"></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mord mathrm mtight\">/</span><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7385428571428572em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathrm mtight\">∞</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mclose\">]</span><span class=\"mopen\">⟨</span><span class=\"mopen\">(</span><span class=\"mord mathit\">p</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mord mathrm mtight\">/</span><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7385428571428572em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathrm mtight\">∞</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mclose\">⟩</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">]</span></span></span></span> is a perfectoid ring</p>",
        "id": 127312705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693443
    },
    {
        "content": "<p>You show that to any number theorist in the area and they'll know what that notation means</p>",
        "id": 127312730,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693473
    },
    {
        "content": "<p>Can we use it in Lean?</p>",
        "id": 127312736,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693476
    },
    {
        "content": "<p>We refer to the pointy brackets as \"langle/rangle\"</p>",
        "id": 127312782,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693494
    },
    {
        "content": "<p>Definitely looks like the kind of sequences of symbols that show up in talks about perfectoid stuff</p>",
        "id": 127312784,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1527693495
    },
    {
        "content": "<p>because LaTeX</p>",
        "id": 127312785,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693497
    },
    {
        "content": "<p>Nobody is raising a prime number to the power infinity</p>",
        "id": 127312802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693533
    },
    {
        "content": "<p>this is a limit of rings where the infinity is replaced by n</p>",
        "id": 127312805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693544
    },
    {
        "content": "<p>and then n goes to infinity</p>",
        "id": 127312811,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693548
    },
    {
        "content": "<p>That's not the major concern. Of course all those things are schematic</p>",
        "id": 127312830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527693582
    },
    {
        "content": "<p>If this stuff were written out in full the definition would double in length and would involve two and possibly more limits</p>",
        "id": 127312834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693593
    },
    {
        "content": "<p>How many ring construction mechanisms are nested there?</p>",
        "id": 127312835,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527693596
    },
    {
        "content": "<p>I think three or four</p>",
        "id": 127312896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693629
    },
    {
        "content": "<p>depending on whether it's a theorem that something commutes with something</p>",
        "id": 127312901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693641
    },
    {
        "content": "<p>I don't think these things commute</p>",
        "id": 127312903,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693645
    },
    {
        "content": "<p>I think maybe four</p>",
        "id": 127312906,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693648
    },
    {
        "content": "<p>oh</p>",
        "id": 127312910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693654
    },
    {
        "content": "<p>maybe far more</p>",
        "id": 127312915,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693658
    },
    {
        "content": "<p>it depends on what you mean</p>",
        "id": 127312917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693661
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi><mrow><mi>c</mi><mi>y</mi><mi>c</mi><mi>l</mi></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p^{cycl}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8491079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.2322159999999998em;vertical-align:-0.383108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.383108em;\"></span></span></span></span></span></span></span></span></p>",
        "id": 127312928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693672
    },
    {
        "content": "<p>is a ring</p>",
        "id": 127312930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693676
    },
    {
        "content": "<p>In lean syntax with constants, no notation, what would it look like roughly?</p>",
        "id": 127312932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527693679
    },
    {
        "content": "<p>So am I allowed to make the ring Z_p^cycl?</p>",
        "id": 127312949,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693698
    },
    {
        "content": "<p>yes</p>",
        "id": 127312951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527693702
    },
    {
        "content": "<p>I mean I can call it X?</p>",
        "id": 127312954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693707
    },
    {
        "content": "<p>that's like <code>Z_cycl p</code> I guess</p>",
        "id": 127312955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527693711
    },
    {
        "content": "<p>no</p>",
        "id": 127312962,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693718
    },
    {
        "content": "<p>it's much worse</p>",
        "id": 127312963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693720
    },
    {
        "content": "<p>maybe it's about as bad</p>",
        "id": 127313007,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693732
    },
    {
        "content": "<p>there is an issue with completions</p>",
        "id": 127313010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693737
    },
    {
        "content": "<p>everything has to be complete at every stage</p>",
        "id": 127313015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693743
    },
    {
        "content": "<p>so <code>completion (Z_cycl p)</code>?</p>",
        "id": 127313026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527693757
    },
    {
        "content": "<p>Let me define, for A an abelian group, <code>P A</code> to be the projective limit of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi>n</mi></msup><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A/p^nA</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mord mathrm\">/</span><span class=\"mord\"><span class=\"mord mathit\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord mathit\">A</span></span></span></span></p>",
        "id": 127313033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693773
    },
    {
        "content": "<p>where's <code>p</code>?</p>",
        "id": 127313036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527693782
    },
    {
        "content": "<p>it's a constant</p>",
        "id": 127313042,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693787
    },
    {
        "content": "<p>we fix a prime p on line 1</p>",
        "id": 127313046,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693791
    },
    {
        "content": "<p>It never changes</p>",
        "id": 127313052,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693809
    },
    {
        "content": "<p>yeah okay, parameters</p>",
        "id": 127313058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527693822
    },
    {
        "content": "<p>there is no relation between the different p-adic theories for different primes p</p>",
        "id": 127313059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693822
    },
    {
        "content": "<p>So <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mi mathvariant=\"bold\">Z</mi><mi>p</mi><mrow><mi>c</mi><mi>y</mi><mi>c</mi><mi>l</mi></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Z}_p^{cycl}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8491079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.2322159999999998em;vertical-align:-0.383108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.383108em;\"></span></span></span></span></span></span></span></span> is:</p>",
        "id": 127313115,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693852
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"bold\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Z}_p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68611em;\"></span><span class=\"strut bottom\" style=\"height:0.972218em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span></span> is the p-adic integers</p>",
        "id": 127313123,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693871
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"bold\">Z</mi><mi>p</mi></msub><mo>[</mo><msub><mi>ζ</mi><msup><mi>p</mi><mi>n</mi></msup></msub><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Z}_p[\\zeta_{p^n}]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.26548em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07378em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5935428571428571em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> is the extension of that ring obtained by adjoining a primitive $$p^n$$th root of unity</p>",
        "id": 127313140,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693895
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"bold\">Z</mi><mi>p</mi></msub><mo>[</mo><msub><mi>ζ</mi><msup><mi>p</mi><mi mathvariant=\"normal\">∞</mi></msup></msub><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Z}_p[\\zeta_{p^\\infty}]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.26548em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07378em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5935428571428571em;\"><span style=\"top:-2.786em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathrm mtight\">∞</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> is the direct limit of those things</p>",
        "id": 127313156,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693913
    },
    {
        "content": "<p>But <code>Z_cycl_p</code> is one thing after all that construction</p>",
        "id": 127313159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527693925
    },
    {
        "content": "<p>and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mi mathvariant=\"bold\">Z</mi><mi>p</mi><mrow><mi>c</mi><mi>y</mi><mi>c</mi><mi>l</mi></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Z}_p^{cycl}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8491079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.2322159999999998em;vertical-align:-0.383108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.383108em;\"></span></span></span></span></span></span></span></span> is <code>P</code> of that</p>",
        "id": 127313160,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693927
    },
    {
        "content": "<p>As in, the notation is not decomposable</p>",
        "id": 127313171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527693941
    },
    {
        "content": "<p>it depends only on p</p>",
        "id": 127313173,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693943
    },
    {
        "content": "<p>it's not p of Z^cycl or ^cycl of Z_p, really</p>",
        "id": 127313204,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693962
    },
    {
        "content": "<p>right</p>",
        "id": 127313225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527693972
    },
    {
        "content": "<p>We build from left to right</p>",
        "id": 127313232,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527693985
    },
    {
        "content": "<p>So with that in mind, how many decomposable parts are there in the ring you mentioned at the top?</p>",
        "id": 127313243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527693999
    },
    {
        "content": "<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span> is a ring</p>",
        "id": 127313247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694004
    },
    {
        "content": "<p>then <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><mo>[</mo><msup><mi>T</mi><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi>n</mi></msup></mrow></msup><mo>]</mo><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[[T^{1/p^n}]]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8879999999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mord mathrm mtight\">/</span><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7385428571428572em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mclose\">]</span></span></span></span> is formal power series in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>T</mi><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi>n</mi></msup></mrow></msup></mrow><annotation encoding=\"application/x-tex\">T^{1/p^n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8879999999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8879999999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mord mathrm mtight\">/</span><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7385428571428572em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> with coefficients in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span></p>",
        "id": 127313272,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694029
    },
    {
        "content": "<p>and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><mo>[</mo><msup><mi>T</mi><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi mathvariant=\"normal\">∞</mi></msup></mrow></msup><mo>]</mo><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[[T^{1/p^\\infty}]]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8879999999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mord mathrm mtight\">/</span><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7385428571428572em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathrm mtight\">∞</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mclose\">]</span></span></span></span> is <code>P</code> of the direct limit of these things</p>",
        "id": 127313288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694052
    },
    {
        "content": "<p>So that's just A[[X]] with some quotient?</p>",
        "id": 127313289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694052
    },
    {
        "content": "<p>no quotient involved</p>",
        "id": 127313294,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694060
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is a variable with no relations</p>",
        "id": 127313302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694069
    },
    {
        "content": "<p>Each ring is isomorphic to <code>A[[X]]</code></p>",
        "id": 127313352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694085
    },
    {
        "content": "<p>the mentioning of the powers of p is just to show how to take the union</p>",
        "id": 127313360,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694097
    },
    {
        "content": "<p>what makes <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>T</mi><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi>n</mi></msup></mrow></msup></mrow><annotation encoding=\"application/x-tex\">T^{1/p^n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8879999999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8879999999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mord mathrm mtight\">/</span><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7385428571428572em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> different from X</p>",
        "id": 127313366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694102
    },
    {
        "content": "<p>the maps between the various rings</p>",
        "id": 127313371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694112
    },
    {
        "content": "<p><span class=\"tex-error\">$$T^{1/p^{n+1}}^p=T^{1/p^n}$$</span></p>",
        "id": 127313375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694130
    },
    {
        "content": "<p>For fixed n all those rings are isomorphic</p>",
        "id": 127313396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694159
    },
    {
        "content": "<p>but if you want to call them all X</p>",
        "id": 127313397,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694166
    },
    {
        "content": "<p>So the notation here is <code>p_infty_completion A p</code></p>",
        "id": 127313401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694170
    },
    {
        "content": "<p>then the maps all send X to X^p</p>",
        "id": 127313402,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694172
    },
    {
        "content": "<p>where there are only two arguments A and p</p>",
        "id": 127313408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694182
    },
    {
        "content": "<p>yes</p>",
        "id": 127313418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694193
    },
    {
        "content": "<p>that's what A[[T^{1/p^infty}]] means</p>",
        "id": 127313462,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694204
    },
    {
        "content": "<p>depends only on A and p</p>",
        "id": 127313473,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694208
    },
    {
        "content": "<p>This is my question</p>",
        "id": 127313478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694213
    },
    {
        "content": "<p>Depends only on the ring A and the prime number p</p>",
        "id": 127313483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694225
    },
    {
        "content": "<p>for each of those notations, what are the dependencies and atomic bits</p>",
        "id": 127313484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694226
    },
    {
        "content": "<p>OK so I will say less about what you're not interested in for the pointy brackets</p>",
        "id": 127313492,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694250
    },
    {
        "content": "<p>I now understand the game we're playing</p>",
        "id": 127313494,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694254
    },
    {
        "content": "<p>If A is a topological ring</p>",
        "id": 127313507,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694272
    },
    {
        "content": "<p>and p is a prime number</p>",
        "id": 127313515,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694283
    },
    {
        "content": "<p>then I can build <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>⟨</mo><mo>(</mo><mi>p</mi><mi mathvariant=\"normal\">/</mi><mi>T</mi><msup><mo>)</mo><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi mathvariant=\"normal\">∞</mi></msup></mrow></msup><mo>⟩</mo></mrow><annotation encoding=\"application/x-tex\">A\\langle(p/T)^{1/p^\\infty}\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8879999999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">⟨</span><span class=\"mopen\">(</span><span class=\"mord mathit\">p</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mord mathrm mtight\">/</span><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7385428571428572em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathrm mtight\">∞</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mclose\">⟩</span></span></span></span></p>",
        "id": 127313523,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694297
    },
    {
        "content": "<p>Remark: <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi><mrow><mi>c</mi><mi>y</mi><mi>c</mi><mi>l</mi></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p^{cycl}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8491079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.2322159999999998em;vertical-align:-0.383108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.383108em;\"></span></span></span></span></span></span></span></span> has a topology</p>",
        "id": 127313568,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694326
    },
    {
        "content": "<p>and we need this topology to build a topology on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mi mathvariant=\"bold\">Z</mi><mi>p</mi><mrow><mi>c</mi><mi>y</mi><mi>c</mi><mi>l</mi></mrow></msubsup><mo>[</mo><mo>[</mo><msup><mi>T</mi><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi mathvariant=\"normal\">∞</mi></msup></mrow></msup><mo>]</mo><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Z}_p^{cycl}[[T^{1/p^\\infty}]]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8879999999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.271108em;vertical-align:-0.383108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.383108em;\"></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mord mathrm mtight\">/</span><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7385428571428572em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathrm mtight\">∞</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mclose\">]</span></span></span></span></p>",
        "id": 127313581,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694356
    },
    {
        "content": "<p>Finally [1/T] is a localization</p>",
        "id": 127313591,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694372
    },
    {
        "content": "<p>if A is a ring and T is in A then A[1/T] is a localization of A</p>",
        "id": 127313602,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694389
    },
    {
        "content": "<p>I assume that the big expression is meant to be suggestive of the interpretation of the maps in the limit, but are there other expressions that could go there?</p>",
        "id": 127313604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694392
    },
    {
        "content": "<p>It is \"standard notation\"</p>",
        "id": 127313606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694408
    },
    {
        "content": "<p>this is really interesting</p>",
        "id": 127313615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694427
    },
    {
        "content": "<p>like does <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>⟨</mo><mo>(</mo><mi>p</mi><mi>T</mi><msup><mo>)</mo><mrow><msup><mi>p</mi><mi mathvariant=\"normal\">∞</mi></msup><mo>−</mo><mn>2</mn></mrow></msup><mo>⟩</mo></mrow><annotation encoding=\"application/x-tex\">A\\langle(pT)^{p^\\infty-2}\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.87998em;\"></span><span class=\"strut bottom\" style=\"height:1.12998em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">⟨</span><span class=\"mopen\">(</span><span class=\"mord mathit\">p</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.87998em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7385428571428572em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathrm mtight\">∞</span></span></span></span></span></span></span></span><span class=\"mbin mtight\">−</span><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mclose\">⟩</span></span></span></span> make any sense?</p>",
        "id": 127313617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694430
    },
    {
        "content": "<p>no!</p>",
        "id": 127313619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694433
    },
    {
        "content": "<p>Are you crazy?</p>",
        "id": 127313621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694437
    },
    {
        "content": "<p>what kind of nonsense is that?</p>",
        "id": 127313671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694457
    },
    {
        "content": "<p>So what is the question? :-/</p>",
        "id": 127313685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694476
    },
    {
        "content": "<p>if there's only one thing that the expression can be, it seems like a waste of notation :P</p>",
        "id": 127313693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694502
    },
    {
        "content": "<p>but sure, if you want that exact thing only then you can get a reasonable approximation in lean</p>",
        "id": 127313709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694526
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><mo>[</mo><msup><mi>X</mi><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi mathvariant=\"normal\">∞</mi></msup></mrow></msup><mo>]</mo><mo>]</mo><mo>⟨</mo><mo>(</mo><msup><mi>p</mi><mn>3</mn></msup><mi mathvariant=\"normal\">/</mi><mi>X</mi><msup><mo>)</mo><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi mathvariant=\"normal\">∞</mi></msup></mrow></msup><mo>⟩</mo><mo>[</mo><mi>p</mi><mi mathvariant=\"normal\">/</mi><mi>X</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[[X^{1/p^\\infty}]]\\langle (p^3/X)^{1/p^\\infty}\\rangle[p/X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8879999999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mord mathrm mtight\">/</span><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7385428571428572em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathrm mtight\">∞</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mclose\">]</span><span class=\"mopen\">⟨</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">3</span></span></span></span></span></span></span></span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mord mathrm mtight\">/</span><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7385428571428572em;\"><span style=\"top:-2.931em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathrm mtight\">∞</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"mclose\">⟩</span><span class=\"mopen\">[</span><span class=\"mord mathit\">p</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> makes sense</p>",
        "id": 127313717,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694545
    },
    {
        "content": "<p>I assume changing <code>T</code> for <code>X</code> does nothing?</p>",
        "id": 127313759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694565
    },
    {
        "content": "<p>you got me</p>",
        "id": 127313763,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694570
    },
    {
        "content": "<p>I was just showing you how amazingly flexible our notation was</p>",
        "id": 127313767,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694583
    },
    {
        "content": "<p>T</p>",
        "id": 127313769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694584
    },
    {
        "content": "<p>X</p>",
        "id": 127313770,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694585
    },
    {
        "content": "<p>any letter at all</p>",
        "id": 127313771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694587
    },
    {
        "content": "<p>except most of them would be completely unsuitable</p>",
        "id": 127313773,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694596
    },
    {
        "content": "<p>I would stick with T</p>",
        "id": 127313776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694610
    },
    {
        "content": "<p>From a CS standpoint those letters are kind of silly</p>",
        "id": 127313779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694621
    },
    {
        "content": "<p>I can't quite work out who is laughing at who in this conversation :-)</p>",
        "id": 127313784,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694630
    },
    {
        "content": "<p>it's like a bound variable, but it isn't binding anything</p>",
        "id": 127313785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694632
    },
    {
        "content": "<p>The ring contains an element called <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span></span></span></span></p>",
        "id": 127313788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694646
    },
    {
        "content": "<p>that's the trick</p>",
        "id": 127313789,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694649
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>[</mo><mi>T</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">k[T]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">]</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi><mo>[</mo><mi>X</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">k[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> for polynomial rings</p>",
        "id": 127313797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694664
    },
    {
        "content": "<p>they're defeq for you</p>",
        "id": 127313808,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694680
    },
    {
        "content": "<p>but for us, one has a T in and the other has an X in</p>",
        "id": 127313846,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694686
    },
    {
        "content": "<p>A simple idea that is surprisingly hard to formalize</p>",
        "id": 127313859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694705
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi><mo>∈</mo><mi>k</mi><mo>[</mo><mi>T</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">T \\in k[T]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"mrel\">∈</span><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">]</span></span></span></span> just like <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo separator=\"true\">,</mo><mi>x</mi><mo>⊢</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma, x \\vdash x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathrm\">Γ</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">x</span><span class=\"mrel\">⊢</span><span class=\"mord mathit\">x</span></span></span></span></p>",
        "id": 127313862,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527694709
    },
    {
        "content": "<p>A man who speaks both languages</p>",
        "id": 127313869,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694725
    },
    {
        "content": "<p>In that case <code>x</code> is in the context though</p>",
        "id": 127313872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694734
    },
    {
        "content": "<p><code>k[T]</code> isn't a context or a context like thing, it's a concrete ring</p>",
        "id": 127313879,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694751
    },
    {
        "content": "<p>(I guess <code>k</code> is in the context)</p>",
        "id": 127313885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694763
    },
    {
        "content": "<p>Oh here is a question</p>",
        "id": 127313896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694786
    },
    {
        "content": "<p>Is this question about notation</p>",
        "id": 127313897,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694790
    },
    {
        "content": "<p><em>completely independent</em> of the question of formalizing the definition?</p>",
        "id": 127313902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694799
    },
    {
        "content": "<p>i.e. the notation is something which can be thought about later</p>",
        "id": 127313950,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694808
    },
    {
        "content": "<p>not completely, but for the most part yes</p>",
        "id": 127313953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694819
    },
    {
        "content": "<p>Those rings are not needed in the definition</p>",
        "id": 127313954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694821
    },
    {
        "content": "<p>it affects what things get definitions</p>",
        "id": 127313957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694831
    },
    {
        "content": "<p>that ring I posted is a famous example of a perfectoid ring</p>",
        "id": 127313959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694840
    },
    {
        "content": "<p>nowhere in the definition of perfectoid space does that definition show up</p>",
        "id": 127313961,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694857
    },
    {
        "content": "<p>so for example since <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mrow><mi mathvariant=\"bold\">Z</mi></mrow><mi>p</mi><mrow><mi>c</mi><mi>y</mi><mi>c</mi><mi>l</mi></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">{\\bf Z}^{cycl}_p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8491079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.2322159999999998em;vertical-align:-0.383108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">Z</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathit mtight\">c</span><span class=\"mord mathit mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.383108em;\"></span></span></span></span></span></span></span></span> is a notation you need a definition <code>Z_cycl p</code></p>",
        "id": 127313962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694862
    },
    {
        "content": "<p>however proving that that ring is a perfectoid ring is a theorem</p>",
        "id": 127313970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527694876
    },
    {
        "content": "<p>To answer your explicit question, yes you can (and probably should) defer all consideration of notation until late in the development</p>",
        "id": 127314046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694971
    },
    {
        "content": "<p>It's basically easy to retrofit</p>",
        "id": 127314058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527694993
    },
    {
        "content": "<p>Probably in lean you wouldn't be able to have this X/T magic stuff, it would be just one fixed letter as part of the notation</p>",
        "id": 127314138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527695051
    },
    {
        "content": "<p>p151  : \"choose a quasi-pro-etale surjection q from a strictly totally disconnected perfectoid space that can be written as an inverse limit of quasicompact separated etale maps q_i as in Proposition 11.24\"</p>",
        "id": 127314558,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695530
    },
    {
        "content": "<p>This is going to be so much fun</p>",
        "id": 127314560,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695535
    },
    {
        "content": "<p>Lean is made for this sort of stuff</p>",
        "id": 127314565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695542
    },
    {
        "content": "<p>Mario, this is what real maths looks like</p>",
        "id": 127314572,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695567
    },
    {
        "content": "<p>super-complex structures</p>",
        "id": 127314588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695600
    },
    {
        "content": "<p>at least it's what some kinds of real maths looks like</p>",
        "id": 127314596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695609
    },
    {
        "content": "<p>it is a million miles from anything that has ever been formalized</p>",
        "id": 127314603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695625
    },
    {
        "content": "<p>and it will be easy to formalize</p>",
        "id": 127314607,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695631
    },
    {
        "content": "<p>that's why it's important</p>",
        "id": 127314615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695639
    },
    {
        "content": "<p>and easy</p>",
        "id": 127314657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695644
    },
    {
        "content": "<p>it's a huge gap in the market</p>",
        "id": 127314675,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695683
    },
    {
        "content": "<p>and I want to be part of a group which naturally fills this gap</p>",
        "id": 127314699,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695719
    },
    {
        "content": "<p>and has a great deal of fun and learns a bunch of stuff at the same time</p>",
        "id": 127314704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695727
    },
    {
        "content": "<p>and there are huge gaps everywhere</p>",
        "id": 127314769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695776
    },
    {
        "content": "<p>I'm sure Patrick can just reel off one in his area</p>",
        "id": 127314778,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695784
    },
    {
        "content": "<p>some complicated definition which turns out to be super-important in the kind of geometry he does</p>",
        "id": 127314793,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695800
    },
    {
        "content": "<p>Doing all this is <strong>one way</strong> of doing Tom Hales' fabstracts</p>",
        "id": 127314812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695838
    },
    {
        "content": "<p>another way is: \"scheme := sorry, now let's keep going\"</p>",
        "id": 127314818,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695853
    },
    {
        "content": "<p>but this way is much more fun</p>",
        "id": 127314825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695858
    },
    {
        "content": "<p>and you'll end up with types that typecheck</p>",
        "id": 127314834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695869
    },
    {
        "content": "<p>Lean is a big puzzle game</p>",
        "id": 127314882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695893
    },
    {
        "content": "<p>and we will be able to make some really cool levels for this game</p>",
        "id": 127314888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695906
    },
    {
        "content": "<p>\"construct a term of this type\"</p>",
        "id": 127314891,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695912
    },
    {
        "content": "<p>that's the game</p>",
        "id": 127314897,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695918
    },
    {
        "content": "<p>the type is the level, the term is the solution</p>",
        "id": 127314901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695926
    },
    {
        "content": "<p>All the old levels are boring</p>",
        "id": 127314915,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695944
    },
    {
        "content": "<p>\"prove quadratic reciprocity\"</p>",
        "id": 127314924,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695951
    },
    {
        "content": "<p>\"prove the prime number theorem\"</p>",
        "id": 127314927,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695956
    },
    {
        "content": "<p>kids want new levels</p>",
        "id": 127314928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695959
    },
    {
        "content": "<p>they are bored with those old levels</p>",
        "id": 127314931,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695966
    },
    {
        "content": "<p>and the computer scientists keep solving them again and again</p>",
        "id": 127314936,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527695974
    },
    {
        "content": "<p>all those websites</p>",
        "id": 127314998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696009
    },
    {
        "content": "<p>\"100 classic levels in the formal proof verification game\"</p>",
        "id": 127315009,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696025
    },
    {
        "content": "<p>we want better levels with funkier graphics</p>",
        "id": 127315019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696037
    },
    {
        "content": "<p>I mean objects</p>",
        "id": 127315022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696041
    },
    {
        "content": "<p>it's like when I show my kids the old text-based adventure games which I used to love at their age</p>",
        "id": 127315037,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696069
    },
    {
        "content": "<p>they are like \"...dad, it's just a bunch of text\"</p>",
        "id": 127315040,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696078
    },
    {
        "content": "<p>\"where are the perfectoid spaces?\"</p>",
        "id": 127315045,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696091
    },
    {
        "content": "<p>I mean graphics</p>",
        "id": 127315097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696124
    },
    {
        "content": "<p>the cool objects</p>",
        "id": 127315106,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696136
    },
    {
        "content": "<p>things have moved on in maths</p>",
        "id": 127315119,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696160
    },
    {
        "content": "<p>Should one put pdfs of papers in a github repo?</p>",
        "id": 127315326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696473
    },
    {
        "content": "<p>\"Here are some foundational papers containing important definitions\"</p>",
        "id": 127315366,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696483
    },
    {
        "content": "<p>\"which we are formalising\"</p>",
        "id": 127315370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696487
    },
    {
        "content": "<p>Choice 1: offer a link</p>",
        "id": 127315375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696496
    },
    {
        "content": "<p>Choice 2: offer a pdf subdirectory</p>",
        "id": 127315377,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696502
    },
    {
        "content": "<p>[Choice 3: both]</p>",
        "id": 127315385,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527696515
    },
    {
        "content": "<p>If arxiv version are up to date then a link is enough</p>",
        "id": 127315476,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1527696605
    },
    {
        "content": "<p>But it's much more important to write a roadmap</p>",
        "id": 127315487,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1527696620
    },
    {
        "content": "<p>unless you want to formalize everything in those papers...</p>",
        "id": 127315496,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1527696637
    },
    {
        "content": "<p>This is very helpful.</p>",
        "id": 127317549,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527699745
    },
    {
        "content": "<p>It will take me some time to write a good roadmap</p>",
        "id": 127317553,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527699753
    },
    {
        "content": "<p>by which I mean a couple of days</p>",
        "id": 127317562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527699777
    },
    {
        "content": "<blockquote>\n<p>Probably in lean you wouldn't be able to have this X/T magic stuff, it would be just one fixed letter as part of the notation</p>\n</blockquote>\n<p>In Sage it is possible to choose your own symbol for the polynomial variable. I don't know what magic Python has to do this. But it is really nice!</p>",
        "id": 127324192,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527707657
    },
    {
        "content": "<p>Hmm, we probably also need some \"almost mathematics\". Or is that not needed for the definition, but only for using these guys? I don't remember...</p>",
        "id": 127349529,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527751412
    },
    {
        "content": "<p>That's only needed for the tilting correspondence I think</p>",
        "id": 127354214,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527760179
    },
    {
        "content": "<p>although we will surely need some facts about perfectoid rings</p>",
        "id": 127354219,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527760191
    },
    {
        "content": "<p>What are the arguments for and against making <code>Tate_ring</code> into a typeclass?</p>",
        "id": 127446113,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900259
    },
    {
        "content": "<p><a href=\"https://arxiv.org/pdf/1709.07343.pdf\" target=\"_blank\" title=\"https://arxiv.org/pdf/1709.07343.pdf\">https://arxiv.org/pdf/1709.07343.pdf</a></p>",
        "id": 127446114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900269
    },
    {
        "content": "<p>page 14 just before definition 3.1 for Tate ring. And then there is also the notion of <code>perfectoid_ring</code> in the definition itself.</p>",
        "id": 127446115,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900285
    },
    {
        "content": "<p>it's a condition on a pair consisting of a Tate ring and a prime number</p>",
        "id": 127446128,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900326
    },
    {
        "content": "<p>for example a certain subring of the ring (defined by the topology) has to be p-adically complete</p>",
        "id": 127446174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900410
    },
    {
        "content": "<p>we will constantly be localizing Tate rings and getting other Tate rings</p>",
        "id": 127446182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900436
    },
    {
        "content": "<p>it's some sort of p-adic version of usual ring localization</p>",
        "id": 127446190,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900448
    },
    {
        "content": "<p>against: the pseudo-uniformiser is not canonical</p>",
        "id": 127446306,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527900612
    },
    {
        "content": "<p>Kenny it's just the assertion that there exists pi with pi^p divides p</p>",
        "id": 127446310,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900643
    },
    {
        "content": "<p>you don't have to give it</p>",
        "id": 127446312,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900648
    },
    {
        "content": "<p>pi pseudouniformiser</p>",
        "id": 127446313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900658
    },
    {
        "content": "<p>See Remark 3.2</p>",
        "id": 127446319,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900680
    },
    {
        "content": "<p>all you need is that one exists</p>",
        "id": 127446320,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900685
    },
    {
        "content": "<p>any choices are equivalent in some strong way</p>",
        "id": 127446324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900715
    },
    {
        "content": "<p>I don't see why it wouldn't be a typeclass</p>",
        "id": 127446366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527900737
    },
    {
        "content": "<p>so no diamonds?</p>",
        "id": 127446368,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900766
    },
    {
        "content": "<p>with what?</p>",
        "id": 127446372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527900781
    },
    {
        "content": "<p>I have no idea how these things work</p>",
        "id": 127446380,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900812
    },
    {
        "content": "<p>where is <code>p</code> coming from though? Is it a component of any lower structures?</p>",
        "id": 127446381,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527900813
    },
    {
        "content": "<p>it's a prime number</p>",
        "id": 127446383,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900819
    },
    {
        "content": "<p>best described as a parameter</p>",
        "id": 127446384,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900823
    },
    {
        "content": "<p>because you never change it</p>",
        "id": 127446387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900830
    },
    {
        "content": "<p>The problem with parameters is they don't last long</p>",
        "id": 127446427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527900844
    },
    {
        "content": "<p>then it's just an input which is a prime number</p>",
        "id": 127446432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900859
    },
    {
        "content": "<p>and which goes everywhere</p>",
        "id": 127446434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527900866
    },
    {
        "content": "<p>once you exit the section, the parameter becomes explicit and you can't make it a parameter again</p>",
        "id": 127446436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527900875
    },
    {
        "content": "<p>The question is: if lean is inferring <code>Tate_ring ?p R</code>, how can it infer <code>p</code>?</p>",
        "id": 127446453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527900950
    },
    {
        "content": "<p>I guess as long as all the theorems have <code>p</code> mentioned explicitly it may be solvable by unification, but I don't know how well this will work with notation and such that doesn't have a <code>p</code> explicitly in it</p>",
        "id": 127446513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527901017
    },
    {
        "content": "<p><code>Tate_ring.p</code>?</p>",
        "id": 127446518,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527901025
    },
    {
        "content": "<p>that's also a possibility</p>",
        "id": 127446521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527901034
    },
    {
        "content": "<blockquote>\n<p>Let p be a fixed prime throughout.  Recall that a topological ring R is Tate if it contains an open and bounded subring R0 ⊂ R and a topologically nilpotent unit omega∈R; such elements are called pseudo-uniformizers.</p>\n</blockquote>\n<p>Where is p mentioned in that definition? Looks like Tate doesn't depend on p</p>",
        "id": 127446586,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527901162
    },
    {
        "content": "<p>Right, I was confused earlier. You don't need p for Tate</p>",
        "id": 127446653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527901259
    },
    {
        "content": "<p>but you do need it for perfectoid</p>",
        "id": 127446656,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527901263
    },
    {
        "content": "<p>so Tate_ring is I think fine, it's just a top ring plus some axioms</p>",
        "id": 127446665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527901281
    },
    {
        "content": "<p>and perfectoid_ring needs a Tate ring and a prime</p>",
        "id": 127446666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527901289
    },
    {
        "content": "<p>I suggest using a parameter (a two-argument typeclass) and see how it goes</p>",
        "id": 127446713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527901354
    },
    {
        "content": "<p>So my options are: (1) just make it a structure on a type alpha -- (a) it's a Tate ring (b) there's a prime (c) axioms</p>",
        "id": 127446729,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527901429
    },
    {
        "content": "<p>or (2) demand both alpha and p as inputs and then it's a structure with (a) Tate ring and (b) axioms</p>",
        "id": 127446772,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527901453
    },
    {
        "content": "<p>this is me building perfectoid ring</p>",
        "id": 127446773,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527901463
    },
    {
        "content": "<p>I am building perfectoid space from the top down</p>",
        "id": 127446774,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527901472
    },
    {
        "content": "<p>it's a long way up</p>",
        "id": 127446775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527901480
    },
    {
        "content": "<p>I'm taking tentative steps down</p>",
        "id": 127446776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527901486
    },
    {
        "content": "<p>and Mario is suggesting (2)</p>",
        "id": 127446787,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527901524
    },
    {
        "content": "<p>Eew prime numbers</p>",
        "id": 127447844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903426
    },
    {
        "content": "<p>how am I supposed to input a prime number?</p>",
        "id": 127447847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903433
    },
    {
        "content": "<p>there's a function</p>",
        "id": 127447848,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903448
    },
    {
        "content": "<p>prime : nat -&gt; Prop</p>",
        "id": 127447849,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903452
    },
    {
        "content": "<p>so it could be carrying round <code>{p : nat} {p_prime : prime p}</code></p>",
        "id": 127447889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903496
    },
    {
        "content": "<p>just make a subtype</p>",
        "id": 127447891,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527903523
    },
    {
        "content": "<p>I have an issue with the subtype solution</p>",
        "id": 127447892,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903536
    },
    {
        "content": "<p>then you have to spend your entire life writing p.1 instead of p</p>",
        "id": 127447900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903550
    },
    {
        "content": "<p>and it is an absolutely fundamental part of the notation, it is on every line</p>",
        "id": 127447901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903567
    },
    {
        "content": "<blockquote>\n<p>then you have to spend your entire life writing p.1 instead of p</p>\n</blockquote>\n<p>\\u p</p>",
        "id": 127447905,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527903580
    },
    {
        "content": "<p>and then you show it to people with the up-arrows off or something.</p>",
        "id": 127447963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903616
    },
    {
        "content": "<p>like our dirty underwear</p>",
        "id": 127447973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903680
    },
    {
        "content": "<p>Is the subtype already there?</p>",
        "id": 127447987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903722
    },
    {
        "content": "<p>I can't see it explicitly defined. What is the subtype's name?</p>",
        "id": 127448066,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903851
    },
    {
        "content": "<p><code>prime</code> is taken by the predicate</p>",
        "id": 127448069,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527903876
    },
    {
        "content": "<p>I don't think there is one</p>",
        "id": 127448203,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527904202
    },
    {
        "content": "<p>so I call it <code>prime'</code>?</p>",
        "id": 127448254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527904299
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span>\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n<span class=\"kn\">definition</span> <span class=\"n\">prime&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">subtype</span> <span class=\"n\">prime</span>\n<span class=\"c1\">-- unit test</span>\n<span class=\"kn\">definition</span> <span class=\"n\">two&#39;</span> <span class=\"o\">:</span> <span class=\"n\">prime&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"n\">prime_two</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">prime&#39;_is_nat</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"n\">prime&#39;</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 127448505,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527904764
    },
    {
        "content": "<p>Anyone any comments on style or anything that's missing?</p>",
        "id": 127448508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527904800
    },
    {
        "content": "<p>make it an autoparam like pnat lol</p>",
        "id": 127448555,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527904812
    },
    {
        "content": "<p>oh ha ha</p>",
        "id": 127448559,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527904823
    },
    {
        "content": "<p>that is a really cool idea</p>",
        "id": 127448561,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527904837
    },
    {
        "content": "<p>wait</p>",
        "id": 127448562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527904838
    },
    {
        "content": "<p>how does this work</p>",
        "id": 127448563,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527904848
    },
    {
        "content": "<p>that open should be a namespace I think -- I'll edit</p>",
        "id": 127448569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527904870
    },
    {
        "content": "<p>I'll post a gist</p>",
        "id": 127448612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527904938
    },
    {
        "content": "<p>what about <code>a_prime</code>? as in, “I have a prime number <code>p : a_prime</code>” (just my own way of doing it, I don’t think it’s common)</p>",
        "id": 127448613,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1527904960
    },
    {
        "content": "<p><a href=\"https://gist.github.com/kbuzzard/327a9c466e3aaecf38fe93109ef8fde6\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/327a9c466e3aaecf38fe93109ef8fde6\">https://gist.github.com/kbuzzard/327a9c466e3aaecf38fe93109ef8fde6</a></p>",
        "id": 127448615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527904968
    },
    {
        "content": "<p>I would like to maximise the chance that this stuff gets into mathlib</p>",
        "id": 127448620,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527904989
    },
    {
        "content": "<p>or rename the predicate to <code>is_prime</code></p>",
        "id": 127448621,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1527904993
    },
    {
        "content": "<p>so I'd like to get it right as soon as possible</p>",
        "id": 127448623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905008
    },
    {
        "content": "<p>It's very mathematical coding and the more I do it the better i'll get at it. I hope.</p>",
        "id": 127448626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905028
    },
    {
        "content": "<p>for all I know there are standard rules of thumb concerning whether a name like <code>prime</code> should be used for the subtype or the predicate</p>",
        "id": 127448667,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905095
    },
    {
        "content": "<p>this is probably a bad idea but</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">predicate</span><span class=\"bp\">.</span><span class=\"n\">has_coe_to_sort</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">ℕ</span><span class=\"o\">))</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">prime</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 127448668,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527905100
    },
    {
        "content": "<p>lmao</p>",
        "id": 127448675,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527905116
    },
    {
        "content": "<p>folly</p>",
        "id": 127448676,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527905120
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">constant</span> <span class=\"n\">p</span>\n</pre></div>",
        "id": 127448678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905128
    },
    {
        "content": "<p>ensues</p>",
        "id": 127448680,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527905135
    },
    {
        "content": "<p>I think that's the best place to start</p>",
        "id": 127448682,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905140
    },
    {
        "content": "<p><code>constant p : nat</code></p>",
        "id": 127448684,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905149
    },
    {
        "content": "<p><code>axiom hp : prime p</code></p>",
        "id": 127448723,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527905175
    },
    {
        "content": "<p>I think that's consistent</p>",
        "id": 127448724,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905177
    },
    {
        "content": "<p>the guys doing <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>L</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">L^p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span></span></span></span></span></span></span></span> spaces will hit the roof</p>",
        "id": 127448726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905222
    },
    {
        "content": "<p>chaos</p>",
        "id": 127448733,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527905253
    },
    {
        "content": "<p>Can I branch the mathlib in my perfectoid space repo</p>",
        "id": 127448828,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905416
    },
    {
        "content": "<p>and edit it</p>",
        "id": 127448829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905419
    },
    {
        "content": "<p>and create a PR?</p>",
        "id": 127448830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905428
    },
    {
        "content": "<p>and just make some note in a file: \"this needs some stuff which isn't in mathlib yet -- when it's in mathlib then remove the <code>import mathlib-foo-branch</code> import\"</p>",
        "id": 127448840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905500
    },
    {
        "content": "<p>Is that a sane workflow or does it lead to madness?</p>",
        "id": 127448843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905516
    },
    {
        "content": "<p>and get leanpkg to keep my branch up to date</p>",
        "id": 127448883,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905536
    },
    {
        "content": "<p>it is sane</p>",
        "id": 127448887,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527905548
    },
    {
        "content": "<p>What I am not clear on</p>",
        "id": 127448888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905558
    },
    {
        "content": "<p>is whether I am supposed to say that my project has Mario's mathlib as a dependency</p>",
        "id": 127448892,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905581
    },
    {
        "content": "<p>or whether I am supposed to say that my project has some fork of mathlib, perhaps on my github website, as a dependency</p>",
        "id": 127448899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527905613
    },
    {
        "content": "<p>If you have things you want to add to mathlib, I would have mathlib as its own project</p>",
        "id": 127449063,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1527905947
    },
    {
        "content": "<p>and you work on it in that folder</p>",
        "id": 127449064,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1527905954
    },
    {
        "content": "<p>editing <code>_target</code> is bad news</p>",
        "id": 127449066,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1527905989
    },
    {
        "content": "<p>I see. So you're saying that the perfectoid space repository could have as a dependency a perfectoid space mathlib</p>",
        "id": 127449170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906153
    },
    {
        "content": "<p>yes</p>",
        "id": 127449171,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1527906167
    },
    {
        "content": "<p>which is some fork of mathlib</p>",
        "id": 127449172,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906172
    },
    {
        "content": "<p>and we maybe have some directory like <code>src/for_mathlib</code> subdirectory</p>",
        "id": 127449178,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906204
    },
    {
        "content": "<p>and then when things are looking tidy</p>",
        "id": 127449220,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906257
    },
    {
        "content": "<p>we can just edit our mathlib, submit a PR, and press on</p>",
        "id": 127449223,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906283
    },
    {
        "content": "<p>Have I got all this straight?</p>",
        "id": 127449232,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906324
    },
    {
        "content": "<p>yes</p>",
        "id": 127449276,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1527906379
    },
    {
        "content": "<p>_target is not for things you plan on editing or working on</p>",
        "id": 127449280,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1527906413
    },
    {
        "content": "<p>I see</p>",
        "id": 127449282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906420
    },
    {
        "content": "<p>you know what I sometimes creep in there in the middle of the night and run <code>leanpkg build</code></p>",
        "id": 127449289,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906439
    },
    {
        "content": "<p>because I know my project won't</p>",
        "id": 127449292,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906452
    },
    {
        "content": "<p>Is <code>adic_space</code> a typeclass?</p>",
        "id": 127449333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906500
    },
    {
        "content": "<p>Is <code>scheme</code> a typeclass?</p>",
        "id": 127449335,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906512
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> what are your thoughts?</p>",
        "id": 127449336,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906524
    },
    {
        "content": "<p>indeed package distribution in lean is a bit annoying right now since it's hard to distribute <code>.oleans</code></p>",
        "id": 127449337,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1527906525
    },
    {
        "content": "<p>I just rebuild whenever I upgrade</p>",
        "id": 127449340,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906537
    },
    {
        "content": "<p>worth the initial wait</p>",
        "id": 127449345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906548
    },
    {
        "content": "<p>if mathlib really wants to contain all of mathematics, at some point people are not going to be able to run leanpkg build in a sane amount of time</p>",
        "id": 127449347,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1527906561
    },
    {
        "content": "<p>unfortunately we are not quite near that point though</p>",
        "id": 127449349,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1527906573
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/lean-stacks-project/blob/6617de7dd5f11af46f0c7e0d2223ee065d71b9f3/src/scheme.lean#L366\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-stacks-project/blob/6617de7dd5f11af46f0c7e0d2223ee065d71b9f3/src/scheme.lean#L366\">https://github.com/kbuzzard/lean-stacks-project/blob/6617de7dd5f11af46f0c7e0d2223ee065d71b9f3/src/scheme.lean#L366</a></p>",
        "id": 127449353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906596
    },
    {
        "content": "<p>if you have a sensible project that builds, then I think you can just build your project and it will only build the bits of mathlib that it needs</p>",
        "id": 127449399,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906628
    },
    {
        "content": "<p>this is one of my motivations for defining perfectoid spaces by the way -- to see performance.</p>",
        "id": 127449401,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906640
    },
    {
        "content": "<p>It's all very well proving things about finite groups</p>",
        "id": 127449402,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906648
    },
    {
        "content": "<p>the proof of the odd order theorem is just John Thompson and his friends writing down everything they know about finite groups and noticing that it happens to be enough</p>",
        "id": 127449410,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906686
    },
    {
        "content": "<p>but to write down even one thing about perfectoid spaces</p>",
        "id": 127449412,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906697
    },
    {
        "content": "<p>will force Lean to handle the notion of a perfectoid space</p>",
        "id": 127449413,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906705
    },
    {
        "content": "<p>we also want oleans so we can search everything though (although there are ways to handle this differently)</p>",
        "id": 127449414,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1527906718
    },
    {
        "content": "<p>Oh -- does e.g. hover or ctrl-space not work in VS Code without the olean files? What exactly do you need them for?</p>",
        "id": 127449466,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906787
    },
    {
        "content": "<p>I have no idea what they are</p>",
        "id": 127449469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906789
    },
    {
        "content": "<p>all I know is that if you type leanpkg build in _target/deps/mathlib then afterwards it goes quicker</p>",
        "id": 127449470,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527906824
    },
    {
        "content": "<blockquote>\n<p>unfortunately we are not quite near that point though</p>\n</blockquote>\n<p>Did you see <a href=\"#narrow/stream/113488-general/subject/travis.20caching/near/127367872\" title=\"#narrow/stream/113488-general/subject/travis.20caching/near/127367872\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/subject/travis.20caching/near/127367872</a> ?</p>",
        "id": 127449563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527907068
    },
    {
        "content": "<p>dammit</p>",
        "id": 127449603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907112
    },
    {
        "content": "<p>I want to get some headline definition of perfectoid space</p>",
        "id": 127449604,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907119
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">,</span>  <span class=\"n\">blah</span> <span class=\"n\">blah</span> <span class=\"n\">blah</span>\n</pre></div>",
        "id": 127449605,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907137
    },
    {
        "content": "<p>so I need <code>adic_space</code></p>",
        "id": 127449610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907149
    },
    {
        "content": "<p>but</p>",
        "id": 127449611,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907151
    },
    {
        "content": "<p>Using <code>structure</code> for schemes and so on seems reasonable. I don't see any practical advantages to using a type class.</p>",
        "id": 127449612,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527907163
    },
    {
        "content": "<p><code>structure adic_space (α : Type) : Type := sorry</code> doesn't work</p>",
        "id": 127449613,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907179
    },
    {
        "content": "<p>I mean the sorry doesn't work</p>",
        "id": 127449614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907187
    },
    {
        "content": "<p>that's not an adequate structure</p>",
        "id": 127449615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907191
    },
    {
        "content": "<p>you can write <code>structure adic_space (α : Type) : Type.</code></p>",
        "id": 127449616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527907197
    },
    {
        "content": "<p>or <code>def adic_space (α : Type) : Type := sorry</code></p>",
        "id": 127449658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527907245
    },
    {
        "content": "<p>the problem with the structure solution is that then it is far less obvious that something is missing</p>",
        "id": 127449663,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907298
    },
    {
        "content": "<p>the problem with the def solution is that I can't then extend the structure to a perfectoid space</p>",
        "id": 127449664,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907312
    },
    {
        "content": "<p>If you want to make sure to get the sorry warning with a structure you can do <code>structure adic_space (α : Type) : Type := (unfinished : sorry)</code></p>",
        "id": 127449665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527907313
    },
    {
        "content": "<p>rofl</p>",
        "id": 127449666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907320
    },
    {
        "content": "<p>Why are rings typeclasses? Why are they any different to schemes?</p>",
        "id": 127449710,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907420
    },
    {
        "content": "<p>Product of schemes is a scheme etc</p>",
        "id": 127449712,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907433
    },
    {
        "content": "<p>[wrong thread <span class=\"user-mention\" data-user-id=\"110025\">@Andrew Ashworth</span> ] -- you can edit the post and just change the thread by editing it</p>",
        "id": 127449752,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907462
    },
    {
        "content": "<p>but the product of schemes isn't a \"scheme structure\" on the product of the underlying sets</p>",
        "id": 127449857,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527907698
    },
    {
        "content": "<p>because that is sort of a weird way of thinking about it, but more importantly because its set of points is different</p>",
        "id": 127449859,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527907729
    },
    {
        "content": "<p>Somehow the relationship between a ring and its underlying set is much more important than the relationship between a scheme and its underlying set</p>",
        "id": 127449866,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527907778
    },
    {
        "content": "<p>o_O so it depends on the underlying type?</p>",
        "id": 127449911,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907818
    },
    {
        "content": "<p>I see</p>",
        "id": 127449914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907833
    },
    {
        "content": "<p>Well, if you were going to write</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">scheme</span> <span class=\"o\">(</span><span class=\"err\">\\</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</pre></div>",
        "id": 127449915,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527907847
    },
    {
        "content": "<p>what about if I just wrote <code>class scheme := </code> and then asked the user to provide the type?</p>",
        "id": 127449921,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907883
    },
    {
        "content": "<p>oh is that somehow the canonically bad thing to do</p>",
        "id": 127449924,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907916
    },
    {
        "content": "<p>then nobody would know which scheme you were talking about</p>",
        "id": 127449925,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527907918
    },
    {
        "content": "<p>right</p>",
        "id": 127449926,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527907921
    },
    {
        "content": "<p>Somehow, I feel that <code>class group (\\a : Type) := ...</code> is related to the abuse of notation where we identify a group with its underlying set</p>",
        "id": 127449969,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527907972
    },
    {
        "content": "<p>we feel that we can identify the group just by naming the set</p>",
        "id": 127449970,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527907982
    },
    {
        "content": "<p>I do think it is rare that you find yourself putting two group structures on one set</p>",
        "id": 127449976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908001
    },
    {
        "content": "<p>and even if it happened you could imagine that it was for some temporary calculation</p>",
        "id": 127449978,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908018
    },
    {
        "content": "<p>possibly which ultimately even proved they were equal</p>",
        "id": 127449980,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908033
    },
    {
        "content": "<p>on the other hand I'd say just the same thing about schemes</p>",
        "id": 127450019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908055
    },
    {
        "content": "<p>but I guess, do you think of a scheme as a set equipped with \"scheme structure\"?</p>",
        "id": 127450020,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527908072
    },
    {
        "content": "<p>Maybe it's a locally-ringed space with a scheme set-of-axioms</p>",
        "id": 127450023,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908095
    },
    {
        "content": "<p>Yes, that seems much better</p>",
        "id": 127450032,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527908117
    },
    {
        "content": "<p>oh god that would make it a dreaded subtype</p>",
        "id": 127450033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908121
    },
    {
        "content": "<p>Anyways, you wouldn't be able to write <code>instance (scheme α) (scheme β) : scheme (α × β)</code> to get <code>α × β</code> notation for product schemes because the underlying set is wrong</p>",
        "id": 127450041,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527908159
    },
    {
        "content": "<p>As a mathematician I find it extremely hard to distinguish whether I \"think about a scheme as a set equipped with the structures of a topological space, a sheaf of rings on the space and an axiom about the rings\"</p>",
        "id": 127450081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908183
    },
    {
        "content": "<p>or whether I \"think about it as a locally ringed space equipped with an axiom\"</p>",
        "id": 127450082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908200
    },
    {
        "content": "<p>By the way re: your prime question, there is the naming convention of capitalizing <code>p : Prime</code> for bundled structures</p>",
        "id": 127450093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527908232
    },
    {
        "content": "<p>oh great! Thanks!</p>",
        "id": 127450095,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908240
    },
    {
        "content": "<p>Yeah, I think it's hard to pin anything down too precisely in this direction.<br>\nThat's why I wrote \"practical advantages\" above <span class=\"emoji emoji-1f642\" title=\"simple smile\">:simple_smile:</span></p>",
        "id": 127450150,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527908367
    },
    {
        "content": "<p>current v</p>",
        "id": 127450200,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908422
    },
    {
        "content": "<p><a href=\"https://gist.github.com/kbuzzard/327a9c466e3aaecf38fe93109ef8fde6\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/327a9c466e3aaecf38fe93109ef8fde6\">https://gist.github.com/kbuzzard/327a9c466e3aaecf38fe93109ef8fde6</a></p>",
        "id": 127450201,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908423
    },
    {
        "content": "<p>of Prime</p>",
        "id": 127450202,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908429
    },
    {
        "content": "<blockquote>\n<p>Yes, that seems much better</p>\n</blockquote>\n<p>So a scheme should extend a locally ringed space by adding one axiom?</p>",
        "id": 127450230,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908489
    },
    {
        "content": "<p>Ha ha that would break my proof that affine schemes are schemes :-)</p>",
        "id": 127450234,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908497
    },
    {
        "content": "<p>the dirty truth coming out :-)</p>",
        "id": 127450235,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908509
    },
    {
        "content": "<p>I figured that I could define a scheme to be a topological space with a sheaf of rings which was locally an affine scheme</p>",
        "id": 127450279,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908529
    },
    {
        "content": "<p>because this would imply it was a locally ringed space</p>",
        "id": 127450281,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908539
    },
    {
        "content": "<p>I was cutting corners :-)</p>",
        "id": 127450282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527908549
    },
    {
        "content": "<p>and you wonder why I think it isn't ready for mathlib...</p>",
        "id": 127450288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527908584
    },
    {
        "content": "<p>Oh, I forgot \"locally ringed\" includes an extra condition</p>",
        "id": 127450291,
        "sender_full_name": "Reid Barton",
        "timestamp": 1527908588
    },
    {
        "content": "<blockquote>\n<p>I do think it is rare that you find yourself putting two group structures on one set</p>\n</blockquote>\n<p>I think the most famous example is Eckman-Hilton for homotopy groups.</p>",
        "id": 127450748,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527909663
    },
    {
        "content": "<p>And indeed, you prove that they are the same group structure.</p>",
        "id": 127450791,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527909768
    },
    {
        "content": "<p>Personally I definitely would love to be able to write <code>X \\times Y</code> for the product of schemes.</p>",
        "id": 127450807,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527909839
    },
    {
        "content": "<p>The only way that I currently see to make this happen, is that we have some sort of <code>has_cat_prod</code> notation for categorical products. And then a proof that <code>Schemes</code> has products.</p>",
        "id": 127450851,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527909891
    },
    {
        "content": "<p>Pullbacks become a problem (notationwise) because we cannot but a subscript scheme under the <code>\\times</code>.</p>",
        "id": 127450863,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527909921
    },
    {
        "content": "<p>I've got two elements of a ring.</p>",
        "id": 127450968,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910093
    },
    {
        "content": "<p>Oh I know the bloody answer to what I was going to ask</p>",
        "id": 127450969,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910093
    },
    {
        "content": "<p>Mathematicians are great</p>",
        "id": 127450970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910093
    },
    {
        "content": "<p>\"use a subtype\"</p>",
        "id": 127450971,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910093
    },
    {
        "content": "<p>\"elements a and b in R, with a dividing b in the subring S\"</p>",
        "id": 127450972,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910093
    },
    {
        "content": "<p>Having p as a subtype is awful</p>",
        "id": 127450974,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910108
    },
    {
        "content": "<p><code>x ^ p</code></p>",
        "id": 127450975,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910114
    },
    {
        "content": "<p>Lean : ?!</p>",
        "id": 127450978,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910132
    },
    {
        "content": "<p>yeah this is going to be difficult</p>",
        "id": 127450983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527910151
    },
    {
        "content": "<p>x is in a ring and p has a coercion to nat</p>",
        "id": 127450986,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910167
    },
    {
        "content": "<p>you can either coerce, or have a <code>has_pow A Prime</code> instance</p>",
        "id": 127450988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527910178
    },
    {
        "content": "<p>rofl</p>",
        "id": 127450991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910198
    },
    {
        "content": "<p>I coerce with \\u?</p>",
        "id": 127451034,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910210
    },
    {
        "content": "<p>lean can't coerce and do typeclass inference at the same time</p>",
        "id": 127451036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527910214
    },
    {
        "content": "<p>you would have to say it's a nat</p>",
        "id": 127451038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527910223
    },
    {
        "content": "<p><code>x ^ (p:nat)</code></p>",
        "id": 127451043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527910231
    },
    {
        "content": "<blockquote>\n<p>lean can't coerce and do typeclass inference at the same time</p>\n</blockquote>\n<p>Is this something that might change in Lean 4?</p>",
        "id": 127451055,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527910281
    },
    {
        "content": "<p>I think that a prime typeclass might work better for you</p>",
        "id": 127451056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527910287
    },
    {
        "content": "<p>no, that's unlikely to change</p>",
        "id": 127451058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527910294
    },
    {
        "content": "<p>if you think about it that's a really large search space</p>",
        "id": 127451060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527910306
    },
    {
        "content": "<p>it's too underdetermined</p>",
        "id": 127451099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527910330
    },
    {
        "content": "<p>Yes, I agree. Somehow humans are extremely good at navigating that search space.</p>",
        "id": 127451100,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527910340
    },
    {
        "content": "<p>wait</p>",
        "id": 127451102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910358
    },
    {
        "content": "<p><code>example (R : Type) [comm_ring R] : has_pow R ℕ := by apply_instance </code></p>",
        "id": 127451103,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910360
    },
    {
        "content": "<p>is that not a thing? Doesn't run for me</p>",
        "id": 127451104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910370
    },
    {
        "content": "<p>you have <code>algebra.group_power</code>?</p>",
        "id": 127451109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527910387
    },
    {
        "content": "<p>I have one lying around somewhere</p>",
        "id": 127451114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910395
    },
    {
        "content": "<p>How about adding p as a constant and the fact that it's prime as an axiom?</p>",
        "id": 127451214,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910575
    },
    {
        "content": "<p>Is that just a bridge too far?</p>",
        "id": 127451215,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910579
    },
    {
        "content": "<p>so if the predicate is called <code>prime</code> and the subtype <code>Prime</code>, what is the typeclass called?</p>",
        "id": 127451223,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910630
    },
    {
        "content": "<p><code>is_prime</code> I guess?</p>",
        "id": 127451224,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527910637
    },
    {
        "content": "<p>eew</p>",
        "id": 127453513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527915711
    },
    {
        "content": "<p><code>definition complete (R : Type) [topological_space R] [ring R] [topological_ring R] : Prop := sorry </code></p>",
        "id": 127453514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527915713
    },
    {
        "content": "<p>is that going away in Lean 4?</p>",
        "id": 127453551,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527915726
    },
    {
        "content": "<p>Yes, we've decided that no one needs topology anymore</p>",
        "id": 127453554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527915751
    },
    {
        "content": "<p>you're going to use sites?</p>",
        "id": 127453555,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527915774
    },
    {
        "content": "<p>nothing but pointless topology for us</p>",
        "id": 127453564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527915790
    },
    {
        "content": "<p>No, infty-topoi.</p>",
        "id": 127453565,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527915791
    },
    {
        "content": "<blockquote>\n<p>nothing but pointless topology for us</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">complete</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">pointless_topological_space</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">pointless_topological_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 127453569,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527915832
    },
    {
        "content": "<p>much better</p>",
        "id": 127453606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527915843
    },
    {
        "content": "<p>Kevin, so the problem is that <code>topological_ring</code> should imply <code>ring</code> and <code>topological_space</code>, right?</p>",
        "id": 127453618,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527915960
    },
    {
        "content": "<p>I don't know why I had to say all three</p>",
        "id": 127453662,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916068
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> should field this one, I'm not sure why it's not a class extending those others</p>",
        "id": 127453664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527916069
    },
    {
        "content": "<p>I tried using type class inference</p>",
        "id": 127453704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916096
    },
    {
        "content": "<p><code>class perfectoid_ring (R : Type) [Tate_ring R] (p : ℕ) [is_prime p] :=</code></p>",
        "id": 127453705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916116
    },
    {
        "content": "<p>and then when I ask type class inference to prove the hypothesis that R is a perfectoid ring</p>",
        "id": 127453710,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916159
    },
    {
        "content": "<p>I mean I know why you had to write that, are you asking what is happening or why is it set up that way?</p>",
        "id": 127453711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527916172
    },
    {
        "content": "<p>I have typeclass woes</p>",
        "id": 127453755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916213
    },
    {
        "content": "<p>I am writing my flagship definition</p>",
        "id": 127453757,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916217
    },
    {
        "content": "<p>so it has to look lovely</p>",
        "id": 127453759,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916221
    },
    {
        "content": "<p>and I write <code> [∀ i, perfectoid_ring (R i) p]</code></p>",
        "id": 127453760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916240
    },
    {
        "content": "<p>and curse the <code>p</code></p>",
        "id": 127453761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916246
    },
    {
        "content": "<p>and it complains that it can't see why <code>R i</code> is a Tate ring</p>",
        "id": 127453763,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916261
    },
    {
        "content": "<p>because perfectoid ring depends on Tate ring</p>",
        "id": 127453769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527916294
    },
    {
        "content": "<p>The way you declared it, you always have to write <code>[Tate_ring R] [is_prime p] [perfectoid_ring R p]</code></p>",
        "id": 127453813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527916340
    },
    {
        "content": "<p>since <code>perfectoid_ring </code> takes the other two as parameters</p>",
        "id": 127453821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527916387
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Tate_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_complete</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_uniform</span>  <span class=\"o\">:</span> <span class=\"n\">uniform</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ramified</span>    <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">ᵒ</span><span class=\"o\">,</span>\n                 <span class=\"o\">(</span><span class=\"n\">is_pseudo_uniformizer</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"err\">^</span> <span class=\"n\">p</span> <span class=\"err\">∣</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n <span class=\"o\">(</span><span class=\"n\">Frob</span>       <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">ᵒ</span><span class=\"o\">,</span>\n                 <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"err\">^</span> <span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hello</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">perfectoid_ring</span> <span class=\"n\">R</span> <span class=\"n\">p</span><span class=\"o\">],</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"c1\">-- failed to synthesize Tate_ring</span>\n</pre></div>",
        "id": 127453882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916546
    },
    {
        "content": "<p><code>(hello : ∃ (R : Type) [Tate_ring R] [perfectoid_ring R p], 1 + 1 = 2) </code></p>",
        "id": 127453922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916597
    },
    {
        "content": "<p>works but looks silly</p>",
        "id": 127453923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916602
    },
    {
        "content": "<p>of course it's a Tate ring -- it's a perfectoid ring!</p>",
        "id": 127453924,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916608
    },
    {
        "content": "<p>It can't synthesize any of those classes</p>",
        "id": 127453925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527916622
    },
    {
        "content": "<p>it's right of the colon, so no typeclass inference for you</p>",
        "id": 127453931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527916640
    },
    {
        "content": "<p>So, you should extend Tate_ring?</p>",
        "id": 127453932,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527916646
    },
    {
        "content": "<p>use <code>by exactI</code> to workaround</p>",
        "id": 127453935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527916654
    },
    {
        "content": "<p>but I don't want by exactI everywhere</p>",
        "id": 127453936,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916669
    },
    {
        "content": "<p>it's an ugly hack</p>",
        "id": 127453937,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527916673
    },
    {
        "content": "<p>Wait we're talking about different things again</p>",
        "id": 127453976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527916705
    },
    {
        "content": "<p>to make Tate_ring inferrable from perfectoid_ring, just make it <code>extends</code> the other</p>",
        "id": 127453978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527916735
    },
    {
        "content": "<p>instead of taking it as parameter</p>",
        "id": 127453983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527916749
    },
    {
        "content": "<p>I changed for a reason</p>",
        "id": 127454080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527917033
    },
    {
        "content": "<p>Why did you write out the divisibility condition instead of using the existing definition?</p>",
        "id": 127454128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527917159
    },
    {
        "content": "<p>I didn't know how to reduce mod p offhand</p>",
        "id": 127454264,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527917445
    },
    {
        "content": "<p>so just wrote something mathematically equivalent</p>",
        "id": 127454265,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527917460
    },
    {
        "content": "<p>reducing mod p would be fine</p>",
        "id": 127454271,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527917476
    },
    {
        "content": "<p>I'd just need to look up how to make a principal ideal and then quotient out by an ideal, and then I would have had to verify that the p'th power map was well-defined on the  quotient</p>",
        "id": 127454311,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527917527
    },
    {
        "content": "<p>or you could write <code>p | b ^ p - a</code></p>",
        "id": 127454313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527917559
    },
    {
        "content": "<p>try that with a subtype</p>",
        "id": 127454314,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527917578
    },
    {
        "content": "<p>?</p>",
        "id": 127454322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527917589
    },
    {
        "content": "<p>just noting that a lot of coercion would be happening if we used subtypes</p>",
        "id": 127454324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527917611
    },
    {
        "content": "<p>for p</p>",
        "id": 127454325,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527917616
    },
    {
        "content": "<p>I don't recommend it. You need it more often as a nat than a prime</p>",
        "id": 127454367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527917648
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  pow b\nterm\n  b\nhas type\n  :Rᵒ\nbut is expected to have type\n  ℕ\n</pre></div>",
        "id": 127454376,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527917753
    },
    {
        "content": "<p>b has type some strange smiley</p>",
        "id": 127454415,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527917770
    },
    {
        "content": "<p><code>                 ∃ b : R ᵒ, (p : R ᵒ) ∣ (b ^ p - a))</code></p>",
        "id": 127454422,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527917825
    },
    {
        "content": "<p>looks less cool</p>",
        "id": 127454425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527917829
    },
    {
        "content": "<p>Hmm, this doesn't score many readability points with me...</p>",
        "id": 127454720,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527918531
    },
    {
        "content": "<p>why? that seems plenty readable</p>",
        "id": 127454727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527918573
    },
    {
        "content": "<p>you may also be able to get away with just <code>\\u p</code></p>",
        "id": 127454728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527918597
    },
    {
        "content": "<p>Well, we are optimising this definition for maximal readability, because it will be the first Lean a lot of mathematicians will read this summer.</p>",
        "id": 127454771,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527918615
    },
    {
        "content": "<p>And then <code>(p : R ᵒ)</code> will already scare them away.</p>",
        "id": 127454772,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527918636
    },
    {
        "content": "<p>Why is it even there?</p>",
        "id": 127454773,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527918641
    },
    {
        "content": "<p>because <code>p</code> is a nat but it is being mapped into the ring so it can be a divisor</p>",
        "id": 127454779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527918678
    },
    {
        "content": "<p>Can't we tell somewhere else that this division happens in <code>R ᵒ</code> ?</p>",
        "id": 127454781,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527918690
    },
    {
        "content": "<p>yes, that's why I suggested <code>\\u p</code></p>",
        "id": 127454785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527918719
    },
    {
        "content": "<p>I think in the end, I would rather prefer something close to <code>∃ b : R ᵒ, a = b ^ p mod p</code></p>",
        "id": 127454833,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527918820
    },
    {
        "content": "<p>Even if it is just notation for what we had before.</p>",
        "id": 127454835,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527918832
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> something like that should be possible. And then you don't need quotient rings.</p>",
        "id": 127454876,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1527918884
    },
    {
        "content": "<blockquote>\n<p>Maybe <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> should field this one, I'm not sure why it's not a class extending those others</p>\n</blockquote>\n<p>If <code>topological_ring</code> would contain the topology or the ring itself, then we would need to duplicate the algebraic and topological type class hierarchy.  So we would need a <code>topological_domain</code>, a <code>uniform_space_ring</code>, a <code>uniform_domain</code> etc. by keeping it a relation this type class hierarchy duplication is avoided. Also <code>topological_ring</code> is a <code>Prop</code> now, so we can add arbitrary instances proving that something is a <code>topological_ring</code> without worrying that they are definitional equal.</p>",
        "id": 127458263,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1527927408
    },
    {
        "content": "<p>OK so a perfectoid space is an adic space with some properties, so we need to develop the theory of adic spaces</p>",
        "id": 127515805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061384
    },
    {
        "content": "<p>and a basic constructor for adic spaces is the <code>Spa</code> function, which takes as input a so-called \"Huber pair\" and outputs an affinoid pre-adic space</p>",
        "id": 127515855,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061461
    },
    {
        "content": "<p>I am thinking about how to formalize that in Lean and I have a question regarding the input, that is, the Huber Pair.</p>",
        "id": 127515865,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061492
    },
    {
        "content": "<p>A Huber Pair is a topological ring <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> satisfying some axioms, and a subring <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> satisfying some more axioms related to both <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> and how it sits in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>.</p>",
        "id": 127515909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061551
    },
    {
        "content": "<p>So I can envisage several ways of setting this up</p>",
        "id": 127515917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061583
    },
    {
        "content": "<p>and what of course I would really like to know is which one is the \"best\" way, where by \"best\" I mean \"one for which the interface will be easiest to write\".</p>",
        "id": 127515966,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061650
    },
    {
        "content": "<p>so how do I analyse this further?</p>",
        "id": 127515968,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061690
    },
    {
        "content": "<p>I definitely want easy access to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span></p>",
        "id": 127515970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061698
    },
    {
        "content": "<p>and most of the time, when creating new pairs from old, you build the new <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> from the old <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and then let the new <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> be \"the same construction but with <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span>\"</p>",
        "id": 127516022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061770
    },
    {
        "content": "<p>e.g. new <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> could be the image of the old <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> or whatever</p>",
        "id": 127516024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061807
    },
    {
        "content": "<p>and occasionally <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> stays the same but <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> changes</p>",
        "id": 127516027,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061824
    },
    {
        "content": "<p>one could think of changing <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> as \"changing <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> infinitesimally\"</p>",
        "id": 127516032,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061851
    },
    {
        "content": "<p>\"so mostly you don't notice\"</p>",
        "id": 127516034,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061862
    },
    {
        "content": "<p>and everything will be a topological ring</p>",
        "id": 127516038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061882
    },
    {
        "content": "<p>and every map will be continuous</p>",
        "id": 127516076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061887
    },
    {
        "content": "<p>and we'll be building things like \"polynomial ring over a Huber Pair\", sending <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo separator=\"true\">,</mo><msup><mi>R</mi><mo>+</mo></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(R,R^+)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:1.021331em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo>[</mo><mi>X</mi><mo>]</mo><mo separator=\"true\">,</mo><msup><mi>R</mi><mo>+</mo></msup><mo>[</mo><mi>X</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(R[X],R^+[X])</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:1.021331em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 127516084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061945
    },
    {
        "content": "<p>or \"completion of a Huber Pair\", sending <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo separator=\"true\">,</mo><msup><mi>R</mi><mo>+</mo></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(R,R^+)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:1.021331em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mover accent=\"true\"><mrow><mi>R</mi></mrow><mo>^</mo></mover><mo separator=\"true\">,</mo><msup><mover accent=\"true\"><mrow><mi>R</mi></mrow><mo>^</mo></mover><mo>+</mo></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(\\hat{R},\\hat{R}^+)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.9467699999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.19677em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9467699999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span><span style=\"top:-3.25233em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"margin-left:0.16668em;\"><span>^</span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9467699999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span><span style=\"top:-3.25233em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"margin-left:0.16668em;\"><span>^</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 127516087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528061981
    },
    {
        "content": "<p>where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>R</mi></mrow><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.9467699999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.9467699999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9467699999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span><span style=\"top:-3.25233em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"margin-left:0.16668em;\"><span>^</span></span></span></span></span></span></span></span></span></span> is a certain kind of completion of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> etc</p>",
        "id": 127516134,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528062018
    },
    {
        "content": "<p>and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mover accent=\"true\"><mrow><mi>R</mi></mrow><mo>^</mo></mover><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\hat{R}^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.9467699999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.9467699999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9467699999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span><span style=\"top:-3.25233em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"margin-left:0.16668em;\"><span>^</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> is the topological closure of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span></p>",
        "id": 127516137,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528062062
    },
    {
        "content": "<p>I'm going to make a structure containing <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span>, and rely on <code>has_coe_to_sort</code> to enable me to treat it as <code>R</code>.</p>",
        "id": 127517460,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528064933
    },
    {
        "content": "<p>Is there trouble ahead?</p>",
        "id": 127517466,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528064949
    },
    {
        "content": "<p>There will be maps between different $$R$$s but in TPIL they sketch a method of how to use <code>has_coe_to_fun</code> which was designed for this purpose I guess.</p>",
        "id": 127517537,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528065071
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> I am looking at the definition of f-adic ring in Wedhorn's notes (section 6.1) and he talks about a finitely-generated ideal of a ring. What's the best way of saying \"there exists a finitely-generated ideal of R such that blah\" in Lean, for a <code>comm_ring</code>?</p>",
        "id": 127518088,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528066228
    },
    {
        "content": "<p>we have all about that in <code>linear_algebra/something</code> I think</p>",
        "id": 127518093,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528066256
    },
    {
        "content": "<p>they proved that every vector space has a basis</p>",
        "id": 127518097,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528066266
    },
    {
        "content": "<p><a href=\"http://www2.math.uni-paderborn.de/fileadmin/Mathematik/People/wedhorn/Lehre/AdicSpaces.pdf\" target=\"_blank\" title=\"http://www2.math.uni-paderborn.de/fileadmin/Mathematik/People/wedhorn/Lehre/AdicSpaces.pdf\">http://www2.math.uni-paderborn.de/fileadmin/Mathematik/People/wedhorn/Lehre/AdicSpaces.pdf</a></p>",
        "id": 127518100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528066273
    },
    {
        "content": "<p>it's the finiteness I am interested in</p>",
        "id": 127518113,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528066288
    },
    {
        "content": "<p>I just want a smooth way of formalizing that definition</p>",
        "id": 127518114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528066302
    },
    {
        "content": "<p>p46 of the pdf</p>",
        "id": 127518116,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528066312
    },
    {
        "content": "<p>finiteness is just either <code>fintype</code> or <code>set.finite</code></p>",
        "id": 127518117,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528066316
    },
    {
        "content": "<p>OK I'll write something</p>",
        "id": 127518159,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528066350
    },
    {
        "content": "<p>and then you can laugh at me :-)</p>",
        "id": 127518161,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528066354
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\">- Linear span of a set of vectors -/</span>\n<span class=\"n\">def</span> <span class=\"n\">span</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span><span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">lc</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"err\">∉</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"err\">•</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 127518162,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528066356
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/mathlib/blob/master/linear_algebra/basic.lean#L122\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/linear_algebra/basic.lean#L122\">https://github.com/leanprover/mathlib/blob/master/linear_algebra/basic.lean#L122</a></p>",
        "id": 127518164,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528066358
    },
    {
        "content": "<p>Oh!</p>",
        "id": 127518165,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528066358
    },
    {
        "content": "<p>I forgot -- see you on the R thread</p>",
        "id": 127518167,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528066368
    },
    {
        "content": "<p>Does this already have a name in mathlib:</p>",
        "id": 127519719,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528069514
    },
    {
        "content": "<p><code>definition is_cover {X γ : Type} (U : γ → set X) := ∀ x, ∃ i, x ∈ U i</code></p>",
        "id": 127519721,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528069520
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">compact_elim_finite_subcover</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span>\n  <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">compact</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">t</span><span class=\"err\">∈</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc₂</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"err\">⊆</span> <span class=\"err\">⋃₀</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">c&#39;</span><span class=\"err\">⊆</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">finite</span> <span class=\"n\">c&#39;</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"err\">⊆</span> <span class=\"err\">⋃₀</span> <span class=\"n\">c&#39;</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 127519834,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528069758
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_space.lean#L475\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_space.lean#L475\">https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_space.lean#L475</a></p>",
        "id": 127519835,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528069764
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">Huber_Pair</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">[</span><span class=\"n\">is_Hring</span> <span class=\"o\">:</span> <span class=\"n\">Huber_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">Rp</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">intel</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_of_integral_elements</span> <span class=\"n\">Rp</span><span class=\"o\">]</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">Huber_Pair&#39;</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Huber_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">Rp</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">intel</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_of_integral_elements</span> <span class=\"n\">Rp</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 127519839,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528069795
    },
    {
        "content": "<p>Is the first one just silly or does it ever have its uses?</p>",
        "id": 127519890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528069814
    },
    {
        "content": "<p>A Huber Pair is a Huber Ring plus a subring which is a ring of integral elements (i.e. satisfies a bunch of axioms)</p>",
        "id": 127519897,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528069849
    },
    {
        "content": "<blockquote>\n<p><a href=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_space.lean#L475\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_space.lean#L475\">https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_space.lean#L475</a></p>\n</blockquote>\n<p><code>is_cover</code> is about as long as <code>s ⊆ ⋃₀ c</code></p>",
        "id": 127519913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528069909
    },
    {
        "content": "<p>lol</p>",
        "id": 127519915,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528069921
    },
    {
        "content": "<p>it's all about the interface though</p>",
        "id": 127519954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528069932
    },
    {
        "content": "<p><code>(R⁺ : set R)</code></p>",
        "id": 127519974,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528070036
    },
    {
        "content": "<p>what is this \"unexpected token\" error?</p>",
        "id": 127520012,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528070044
    },
    {
        "content": "<p>can I PR it in somehow?</p>",
        "id": 127520018,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528070068
    },
    {
        "content": "<p>hmm</p>",
        "id": 127520022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528070079
    },
    {
        "content": "<p>can I use it in notation?</p>",
        "id": 127520024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528070087
    },
    {
        "content": "<p>yes :-)</p>",
        "id": 127520077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528070180
    },
    {
        "content": "<blockquote>\n<p>Is the first one just silly or does it ever have its uses?</p>\n</blockquote>\n<p>aargh the second one doesn't compile :-/</p>",
        "id": 127520414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528070857
    },
    {
        "content": "<p>because of type class inference woes</p>",
        "id": 127520418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528070869
    },
    {
        "content": "<p><code>definition is_ring_of_integral_elements {R : Type} [Huber_ring R] (Rplus : set R) : Prop := sorry</code></p>",
        "id": 127520461,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528070922
    },
    {
        "content": "<p>needs huber ring</p>",
        "id": 127520464,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528070931
    },
    {
        "content": "<p><em>boggle</em> &lt;goes back to type class woes thread&gt;</p>",
        "id": 127520514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528071038
    },
    {
        "content": "<p>I don't understand why that would make the second one not compile</p>",
        "id": 127520522,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528071119
    },
    {
        "content": "<p>no I am an idiot</p>",
        "id": 127520617,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528071340
    },
    {
        "content": "<p>it works fine</p>",
        "id": 127520618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528071347
    },
    {
        "content": "<p>I am still very unsteady on my feet with typeclasses</p>",
        "id": 127520619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528071361
    },
    {
        "content": "<p>all I know is \"it sometimes doesn't work\" and it's something about where the colon is</p>",
        "id": 127520659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528071385
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">Huber_pair</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">RHuber</span> <span class=\"o\">:</span> <span class=\"n\">Huber_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">Rplus</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">intel</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_of_integral_elements</span> <span class=\"n\">Rplus</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 127520797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528071724
    },
    {
        "content": "<p>This is annoying</p>",
        "id": 127520800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528071734
    },
    {
        "content": "<p>I don't think I can use type class inference to get a Huber pair structure on R, because I want the freedom to change <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span></p>",
        "id": 127520804,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528071764
    },
    {
        "content": "<p><code>postfix </code>⁺<code> : 66 := λ R : Huber_pair _, R.Rplus  </code></p>",
        "id": 127520809,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528071791
    },
    {
        "content": "<p>and if I add it as a family of structures on R</p>",
        "id": 127520813,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528071814
    },
    {
        "content": "<p>then I am forever having to make R and then the pair</p>",
        "id": 127520814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528071821
    },
    {
        "content": "<p>I can't just say \"Let <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> be a Huber Pair\" like we'd say in maths</p>",
        "id": 127520817,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528071838
    },
    {
        "content": "<p>So, often a good solution when you want two different typeclasses on the same underlying type,</p>",
        "id": 127520863,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528071903
    },
    {
        "content": "<p>is to use the trick that Mario showed me, of making a \"wrapper\".</p>",
        "id": 127520868,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528071915
    },
    {
        "content": "<p>As an example, to define the opposite category, I use:</p>\n<div class=\"codehilite\"><pre><span></span>def op (C : Type u₁) : Type u₁ := C\n\nnotation C `ᵒᵖ` := op C\n\nvariable {C : Type u₁}\nvariable [𝒞 : category.{u₁ v₁} C]\ninclude 𝒞\n\ninstance Opposite : category.{u₁ v₁} (Cᵒᵖ) := ...\n</pre></div>",
        "id": 127520871,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528071956
    },
    {
        "content": "<p>Here the idea is that <code>op C</code> is of course just <code>C</code>, \"thought of\" as objects of the opposite category.</p>",
        "id": 127520912,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528071982
    },
    {
        "content": "<p>It's something mathematicians do all the time and are perfectly comfortable with, and maybe works for your Huber pairs setting, in particular when you want to change R+, but leave R alone.</p>",
        "id": 127520922,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528072051
    },
    {
        "content": "<p>On the other hand, I suspect that you never ever actually want to look at an element of the <code>R</code> of a Huber pair, so making a typeclass on <code>R</code> maybe doesn't have that much value.</p>",
        "id": 127520975,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528072129
    },
    {
        "content": "<p>I think I will forever be playing around with pi's and p's in R I think</p>",
        "id": 127521056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528072222
    },
    {
        "content": "<p>as I explicitly evaluate my completions etc</p>",
        "id": 127521060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528072242
    },
    {
        "content": "<p>Scratch that suggestion then!</p>",
        "id": 127521063,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528072260
    },
    {
        "content": "<blockquote>\n<p>I can't just say \"Let <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> be a Huber Pair\" like we'd say in maths</p>\n</blockquote>\n<p>I think it is important that we try to keep this \"feature\". But I don't see how to implement it in Lean, and also give you the freedom to change <code>R⁺</code>.</p>",
        "id": 127540813,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528112397
    },
    {
        "content": "<p>Unless we also have some postfix accessor notation for the ambient ring. So that a Huber pair <code>R</code> is <code>(R^?,R⁺)</code>. But I don't have any cute ideas for what <code>?</code> should actually be. And it is going to be annoying and offputing for mathematicians anyway.</p>",
        "id": 127540890,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528112521
    },
    {
        "content": "<p>Could that notation for the ambient ring just be a coercion?</p>",
        "id": 127541067,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528112881
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">Huber_pair</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">is_ring</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">Rp</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">huber</span> <span class=\"o\">:</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"n\">Huber_pair</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">Huber_pair</span><span class=\"bp\">.</span><span class=\"n\">R</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Huber_pair</span><span class=\"bp\">.</span><span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"bp\">.</span><span class=\"n\">is_ring</span>\n</pre></div>",
        "id": 127541198,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528113028
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> is currently the only one who knows enough about Huber pairs to see if this will give trouble down the road.</p>",
        "id": 127541212,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528113116
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">notation</span> <span class=\"n\">R</span> <span class=\"bp\">`</span><span class=\"err\">⁺</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">99</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"bp\">.</span><span class=\"n\">Rp</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">R</span><span class=\"err\">⁺</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 127541258,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528113168
    },
    {
        "content": "<p>Yes, probably.</p>",
        "id": 127541260,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528113171
    },
    {
        "content": "<p>So far that looks promising, I would say.</p>",
        "id": 127541391,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528113382
    },
    {
        "content": "<p>I am trying to understand the maths a little bit more, to see if I can help. But I am a bit lost. In <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s  <a href=\"http://www2.math.uni-paderborn.de/fileadmin/Mathematik/People/wedhorn/Lehre/AdicSpaces.pdf\" target=\"_blank\" title=\"http://www2.math.uni-paderborn.de/fileadmin/Mathematik/People/wedhorn/Lehre/AdicSpaces.pdf\">first ref</a>, p46 defines what an f-adic ring is, but there is no f right? Can I understand them as an I-adic ring? Then, for the question on Huber pairs. I do not understand this \"pair\" vocabulary yet. Can I think of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> as an ambiant (topological) ring, and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> as the actual interesting thing?</p>",
        "id": 127541994,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1528114484
    },
    {
        "content": "<p>I think both rings in a Huber pair are interesting...</p>",
        "id": 127542016,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528114559
    },
    {
        "content": "<p>It is like <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><mo>⊂</mo><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z} \\subset \\mathbb{Q}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mrel\">⊂</span><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span></span></span> on steroids.</p>",
        "id": 127542064,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528114594
    },
    {
        "content": "<p>Also, I think the \"f\" in <em>f-adic</em> stands for finite: there is a finiteness condition in both items in the condition, first on the subset <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, and then on the ideal <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> in the second condition of the definition.</p>",
        "id": 127542079,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528114678
    },
    {
        "content": "<p>Disclaimer: I'm not an expert on this stuff. Only followed some seminars on this.</p>",
        "id": 127542135,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528114788
    },
    {
        "content": "<p>Sorry my sentence was misleading and in fact I think it was even nonsensical, as  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>A</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">A^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> should be integrally closed in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span>.</p>",
        "id": 127542992,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1528116142
    },
    {
        "content": "<p><del>Don't you mean it the other way round?</del></p>",
        "id": 127543129,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528116451
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 127543178,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1528116542
    },
    {
        "content": "<blockquote>\n<p>I am trying to understand the maths a little bit more, to see if I can help. But I am a bit lost. In <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s  <a href=\"http://www2.math.uni-paderborn.de/fileadmin/Mathematik/People/wedhorn/Lehre/AdicSpaces.pdf\" target=\"_blank\" title=\"http://www2.math.uni-paderborn.de/fileadmin/Mathematik/People/wedhorn/Lehre/AdicSpaces.pdf\">first ref</a>, p46 defines what an f-adic ring is, but there is no f right? Can I understand them as an I-adic ring? Then, for the question on Huber pairs. I do not understand this \"pair\" vocabulary yet. Can I think of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> as an ambiant (topological) ring, and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> as the actual interesting thing?</p>\n</blockquote>\n<p>Yes \"f-adic ring\" is a terrible name, there is no f, \"f-adic ring\" is just a ring with some structure and some axioms. In fact it's such a terrible name that Scholze proposed renaming it to \"Huber ring\" and that's what we're going to use in the project.</p>",
        "id": 127543965,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528117766
    },
    {
        "content": "<p>The modern terminology is that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a Huber ring and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo separator=\"true\">,</mo><msup><mi>R</mi><mo>+</mo></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(R,R^+)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:1.021331em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is a Huber pair. In the old terminology <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is an f-adic ring and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> is a ring of integral elements (I guess this definition will stay)</p>",
        "id": 127544039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528117837
    },
    {
        "content": "<p>So many of the proofs do not care about <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span>, but I am beginning to see more about how this is going to work. I suspect often we will not make the Huber pair -- we will just have a ring <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and a subring <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^+</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> and do calculations with them</p>",
        "id": 127544056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528117904
    },
    {
        "content": "<p>Should I have <code>structure perfectoid_space := (X : Type) ...</code> or <code>structure perfectoid_space (X : Type) := ...</code>?</p>",
        "id": 127564051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143575
    },
    {
        "content": "<p>I was using the latter</p>",
        "id": 127564056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143584
    },
    {
        "content": "<p>but here's something I ran into.</p>",
        "id": 127564063,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143593
    },
    {
        "content": "<p>A perfectoid space is a topological space equipped with a presheaf of rings and satisfying a bunch of axioms.</p>",
        "id": 127564135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143627
    },
    {
        "content": "<p>A presheaf of rings on a topological space is the assignment, for every open subset U of the topological space, of a ring <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>U</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">F(U)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span>, and a bit more data, and some axioms.</p>",
        "id": 127564153,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143673
    },
    {
        "content": "<p>Given a perfectoid space <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, and an open subset <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span> of the underlying topological space (which is also called <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span>), I can pull back all the structure and get a perfectoid space structure on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span> (e.g. I need to associate a ring to an open subset of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span>, but an open subset of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span> is an open subset of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> so we use the presheaf of rings on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> to do this).</p>",
        "id": 127564242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143787
    },
    {
        "content": "<p>So far so good.</p>",
        "id": 127564243,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143793
    },
    {
        "content": "<p>But I was kind of expecting <code>perfectoid_space</code> to be a typeclass</p>",
        "id": 127564264,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143824
    },
    {
        "content": "<p>and (finally the question!) I don't know how to get type class inference to get us from X to U</p>",
        "id": 127564288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143842
    },
    {
        "content": "<p>because U is an open set in X so it's not even a type</p>",
        "id": 127564346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143886
    },
    {
        "content": "<p>and if we use the associated subtype <code>{x : X // x \\in U}</code></p>",
        "id": 127564366,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143908
    },
    {
        "content": "<p>then I don't know how to say \"...oh, and U needs to be open\" to type class inference.</p>",
        "id": 127564378,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143925
    },
    {
        "content": "<p>In short -- if I have <code>(X : Type) [perfectoid_space X]</code></p>",
        "id": 127564399,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143958
    },
    {
        "content": "<p>(perfectoid space extends topological space)</p>",
        "id": 127564446,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143971
    },
    {
        "content": "<p>and if <code>(U : set X)</code> is open</p>",
        "id": 127564461,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528143994
    },
    {
        "content": "<p>then my instance wants to look like <code>(X : Type) [perfectoid_space X] (U : set X) (HU : is_open U) : perfectoid_space {x : X // x \\in U}</code></p>",
        "id": 127564501,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528144069
    },
    {
        "content": "<p>\"an open subset of a perfectoid space is a perfectoid space\"</p>",
        "id": 127564555,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528144091
    },
    {
        "content": "<p>but how is type class inference going to spot that U is open?</p>",
        "id": 127564574,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528144115
    },
    {
        "content": "<p>I guess I could work with subtypes and make is_open a typeclass on them? Is this crazy? Would it even work?</p>",
        "id": 127564631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528144194
    },
    {
        "content": "<p>Or should I just give up on making perfectoid space a typeclass?</p>",
        "id": 127564861,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528144409
    },
    {
        "content": "<p>Presumably typeclass inference only works on things which have been tagged as classes</p>",
        "id": 127564911,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528144451
    },
    {
        "content": "<p>I would say it makes sense to make them either both typeclasses or plain structures (you can still write a function to do what you want to do with typeclass inference there, I think); perhaps it wouldn’t hurt to start with all the structure explicit, and then determine what could be converted to use typeclass machinery ...</p>",
        "id": 127565448,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1528145222
    },
    {
        "content": "<p><code>theorem perfectoid_space_on_open_set (X : Type) (U : set X) (HU : is_open U) : perfectoid_space X -&gt; perfectoid_space {x : X // x \\in U}</code></p>",
        "id": 127565546,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1528145351
    },
    {
        "content": "<p>So I can prove that theorem</p>",
        "id": 127565731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528145546
    },
    {
        "content": "<p>my question is whether I can persuade the type class inference system to use it</p>",
        "id": 127565739,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528145558
    },
    {
        "content": "<p>if <code>perfectoid_space</code> is a class</p>",
        "id": 127565748,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528145569
    },
    {
        "content": "<p>and what I can't get my head around</p>",
        "id": 127565756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528145577
    },
    {
        "content": "<p>is how type class inference can possibly guess that a subset is open</p>",
        "id": 127565766,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528145587
    },
    {
        "content": "<p>I agree, that’s why I think <code>is_open</code> would also have to be a typeclass</p>",
        "id": 127565777,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1528145610
    },
    {
        "content": "<p>but there is a technical problem there</p>",
        "id": 127565788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528145618
    },
    {
        "content": "<p>because U is not a type</p>",
        "id": 127565792,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528145625
    },
    {
        "content": "<p>it's a term</p>",
        "id": 127565793,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528145627
    },
    {
        "content": "<p>hmm</p>",
        "id": 127565853,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528145651
    },
    {
        "content": "<p>I am just assuming that it's impossible to make this work</p>",
        "id": 127565857,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528145658
    },
    {
        "content": "<p>Does it actually work?</p>",
        "id": 127565861,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528145662
    },
    {
        "content": "<p>I somehow can't get it all to fit together but maybe it's possible</p>",
        "id": 127565903,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528145745
    },
    {
        "content": "<p>aren’t the (ring, group) homomorphisms classes? I don’t see how a set would be much different</p>",
        "id": 127565961,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1528145786
    },
    {
        "content": "<p><code>class is_ring_hom</code></p>",
        "id": 127566151,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1528146054
    },
    {
        "content": "<p>That's true!</p>",
        "id": 127566567,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528146668
    },
    {
        "content": "<p>Maybe it all just works?</p>",
        "id": 127566572,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528146684
    },
    {
        "content": "<p><code>variables {X : Type} [topological_space X]</code></p>",
        "id": 127566720,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528146860
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_open</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>or some such thing</p>",
        "id": 127566745,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528146913
    },
    {
        "content": "<p>hmm maybe I need to think a bit about variable names...</p>",
        "id": 127566800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528146968
    },
    {
        "content": "<p>You can potentially also just make <code>is_open</code> into a class, with <code>attribute [class] is_open</code> (or <code>local attribute</code>)</p>",
        "id": 127567528,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528147912
    },
    {
        "content": "<p>I don't have time for this now but hopefully I'll be able to get to it tomorrow. Once I've resolved this I think I'm ready to go. I've been writing stuff from the top down, i.e. I have a definition of a perfectoid space but it depends on several other definitions, some of which I have and some of which I don't. Up here it feels very close to maths and looks very close to maths too.</p>",
        "id": 127571664,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528154060
    },
    {
        "content": "<p>Are doing all this privately in the end?</p>",
        "id": 127586717,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528183499
    },
    {
        "content": "<p>No not at all -- but I wanted to get the definition of perfectoid space written (modulo lots of other definitions which are not written)</p>",
        "id": 127588260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528186580
    },
    {
        "content": "<p>before I \"went public\" as it were</p>",
        "id": 127588261,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528186587
    },
    {
        "content": "<p>I am currently struggling with type class inference issues but I think I had the same ones before</p>",
        "id": 127588263,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528186604
    },
    {
        "content": "<p>so I will look in the old thread</p>",
        "id": 127588266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528186612
    },
    {
        "content": "<p>Patrick here's the state of things:</p>",
        "id": 127589169,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528188328
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">adic_space</span>\n\n<span class=\"c1\">--notation</span>\n<span class=\"kn\">postfix</span> <span class=\"bp\">`</span><span class=\"err\">ᵒ</span><span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">66</span> <span class=\"o\">:=</span> <span class=\"n\">power_bounded_subring</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- A perfectoid ring, following Fontaine Sem Bourb-/</span>\n<span class=\"n\">class</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">Tate_ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_complete</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_uniform</span>  <span class=\"o\">:</span> <span class=\"n\">uniform</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ramified</span>    <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">is_pseudo_uniformizer</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"err\">^</span> <span class=\"n\">p</span> <span class=\"err\">∣</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">Frob</span>        <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">ᵒ</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"err\">^</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span>\n  <span class=\"c1\">-- gamma is our indexing set, U_i are the open cover for i in gamma</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">U_cover</span> <span class=\"o\">:</span> <span class=\"n\">is_cover</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- U i is isomorphic to Spa(A_i,A_i^+) with A_i a perfectoid ring</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is_perfectoid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">))</span>    <span class=\"o\">)</span>\n</pre></div>",
        "id": 127589172,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528188332
    },
    {
        "content": "<p>doesn't quite typecheck</p>",
        "id": 127589173,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528188341
    },
    {
        "content": "<p>but once it does it's very readable if you already know pretty much what a perfectoid space is</p>",
        "id": 127589195,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528188362
    },
    {
        "content": "<p><code>adic_space</code> full of sorries</p>",
        "id": 127589225,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528188379
    },
    {
        "content": "<p>I am in the middle of writing some long issues explaining exactly what needs to be done to finish the job, plus references</p>",
        "id": 127589233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528188405
    },
    {
        "content": "<p><code>is_preadic_space_equiv</code> extends <code>homeo</code> -- did you get that into mathlib?</p>",
        "id": 127589248,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528188451
    },
    {
        "content": "<p>The problem, by the way, is <code>failed to synthesize ⊢ preadic_space {x // x ∈ U i}</code></p>",
        "id": 127589367,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528188611
    },
    {
        "content": "<p><code>instance preadic_space_restriction {X : Type} [preadic_space X] {U : set X} [is_open U] :\n  preadic_space {x : X // x ∈ U} := sorry</code></p>",
        "id": 127589375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528188651
    },
    {
        "content": "<p>so all the ingredients are there -- a proof that U i is open, an instance saying an open subspace of a preadic space is a preadic space, oh and adic_space extends preadic_space</p>",
        "id": 127589393,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528188721
    },
    {
        "content": "<p>The  <code> ∃ {γ : Type}</code> looks very suspicious to me. Is it really what you want? And not a set of some type?</p>",
        "id": 127589489,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1528188846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> , could you explain why it looks suspicious? I've seen the same sentiment expressed about similar things, but never really understood how you decide between indexing by a type, and having a set of things. The one time I tried both approaches (defining a Grothendieck topology), it eventually became clear that the set approach was smoother, but I didn't really grok why that was the case.</p>",
        "id": 127589621,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528189083
    },
    {
        "content": "<p>This is supposed to say \"my topological space has a cover by nice topological subspaces\"</p>",
        "id": 127589634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189130
    },
    {
        "content": "<p>but the actual cover is not part of the structure</p>",
        "id": 127589636,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189137
    },
    {
        "content": "<p>it's just the fact that such a cover exists</p>",
        "id": 127589642,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189143
    },
    {
        "content": "<p>for each <code>i : gamma</code> I need an open set U_i and a ring A_i and an isomorphism Spa(A_i) = U_i</p>",
        "id": 127589657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189185
    },
    {
        "content": "<p>Here's a MWE of my final problem</p>",
        "id": 127589718,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189258
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">topological_space</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"n\">is_open</span>\n\n<span class=\"n\">class</span> <span class=\"n\">preadic_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">topological_space</span> <span class=\"n\">X</span>\n\n<span class=\"n\">class</span> <span class=\"n\">adic_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">Huber_pair</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Spa_topology</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">preadic_space_equiv</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AX</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AY</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">equiv</span> <span class=\"n\">X</span> <span class=\"n\">Y</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AX</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AY</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">preadic_space_equiv</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">not_perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span>\n  <span class=\"c1\">-- gamma is our indexing set, U_i are the open cover for i in gamma</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">Huber_pair</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n</pre></div>",
        "id": 127589723,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189264
    },
    {
        "content": "<p>I might have just made a stupid mistake</p>",
        "id": 127589727,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189275
    },
    {
        "content": "<p>oh ignore all this I am sure I have made a stupid mistake -- my error is somewhere else now in the MWE. I just need to sort this out myself. I think I'm there but just being stupid</p>",
        "id": 127589806,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189410
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">topological_space</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"n\">is_open</span>\n\n<span class=\"n\">class</span> <span class=\"n\">preadic_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">topological_space</span> <span class=\"n\">X</span>\n\n<span class=\"n\">class</span> <span class=\"n\">adic_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">Huber_pair</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Spa_topology</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">preadic_space_equiv</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AX</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AY</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">equiv</span> <span class=\"n\">X</span> <span class=\"n\">Y</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AX</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AY</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">preadic_space_equiv</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">not_perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span>\n  <span class=\"c1\">-- gamma is our indexing set, U_i are the open cover for i in gamma</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">Huber_pair</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n</pre></div>",
        "id": 127589859,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189474
    },
    {
        "content": "<p><code>failed to synthesize type class instance for ⊢ preadic_space {x // x ∈ U i}</code></p>",
        "id": 127589862,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189495
    },
    {
        "content": "<p>That's my problem</p>",
        "id": 127589865,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189498
    },
    {
        "content": "<p>I think maybe type class inference doesn't know <code>U i</code> is open</p>",
        "id": 127589876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189519
    },
    {
        "content": "<p>but I thought that <code>[U_open : ∀ i, is_open (U i)]</code> would tell it this</p>",
        "id": 127589884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189546
    },
    {
        "content": "<p>but it might all be happening too quickly for type class inference</p>",
        "id": 127589885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528189560
    },
    {
        "content": "<p>Is it because you should be using a coercion to subtype instead of this <code>{x // x ∈ U i}</code></p>",
        "id": 127589932,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528189588
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> : disclaimer: I do not know what Groethendick topology is. But it is much more difficult to \"combine\" things which have different types. For instance, if two families are indexed using two a priori distinct types, then in order to speak about the family obtained as the union of these two, you always first have to craft a new type for the indices of this union, which will be something like the sum type of the two previous index types (phew). As opposed to offering the option, when possible, to use the union set of two sets (indexed with the same nature of datas, ie. with sets of a same type).</p>",
        "id": 127590175,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1528190016
    },
    {
        "content": "<blockquote>\n<p>This is supposed to say \"my topological space has a cover by nice topological subspaces\"</p>\n</blockquote>\n<p>You could consider <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"script\">U</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathcal{U}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">U</span></span></span></span></span> a subset of the powerset of <code>X</code>, and then demand for every <code>U : calU</code> that it is open, and that <code>calU</code> is a cover.</p>",
        "id": 127590308,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528190229
    },
    {
        "content": "<p>I guess that <code>is_cover</code> is something you defined yourself. I didn't find it in mathlib.</p>",
        "id": 127590358,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528190295
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> But with indexing sets you usually don't want to take the union (in some ambient set) right? You would want to take the disjoint union. And the mathematician in me doesn't really see why disjoint unions or sum types differ in complexity. Please enlighten this DTT newbie (-;</p>",
        "id": 127590450,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528190440
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">preadic_space_restriction</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">preadic_space</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 127590761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528190922
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">topological_space</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"n\">is_open</span>\n\n<span class=\"n\">class</span> <span class=\"n\">preadic_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">topological_space</span> <span class=\"n\">X</span>\n\n<span class=\"n\">class</span> <span class=\"n\">adic_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">Huber_pair</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Spa_topology</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">preadic_space_equiv</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AX</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AY</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">equiv</span> <span class=\"n\">X</span> <span class=\"n\">Y</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AX</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AY</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">preadic_space_equiv</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">preadic_space_restriction</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">preadic_space</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">loc</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">),</span>\n  <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)))</span>  <span class=\"c1\">-- fails ⊢ preadic_space {x // x ∈ U}</span>\n</pre></div>",
        "id": 127590858,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528191099
    },
    {
        "content": "<p>Kevin, isn't there some coercion that turns <code>U</code> into a (sub)type? Because <code>{x : X // x ∈ U}</code> is really weird to a mathematician. (I understand that you are having troubles here... but I think we should aim to get rid of that expression in the end.)</p>",
        "id": 127590861,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528191104
    },
    {
        "content": "<p>We can't have everything</p>",
        "id": 127590922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528191184
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">topological_space</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"n\">is_open</span>\n\n<span class=\"n\">class</span> <span class=\"n\">preadic_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">topological_space</span> <span class=\"n\">X</span>\n\n<span class=\"n\">class</span> <span class=\"n\">adic_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">Huber_pair</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Spa_topology</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">preadic_space_equiv</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AX</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AY</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">equiv</span> <span class=\"n\">X</span> <span class=\"n\">Y</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AX</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AY</span> <span class=\"o\">:</span> <span class=\"n\">preadic_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">preadic_space_equiv</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">preadic_space_restriction</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">preadic_space</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">loc</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">),</span>\n  <span class=\"n\">is_preadic_space_equiv</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)))</span>  <span class=\"c1\">-- fails ⊢ preadic_space ↥U</span>\n</pre></div>",
        "id": 127590977,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528191277
    },
    {
        "content": "<p>Right, so the issue remains...</p>",
        "id": 127590986,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528191305
    },
    {
        "content": "<p>Which is really annoying.</p>",
        "id": 127590992,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528191312
    },
    {
        "content": "<p>Now we have weird arrows</p>",
        "id": 127591056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528191430
    },
    {
        "content": "<p>I'm sure it can be fixed. The only reason I'm chatting about this at all is that Patrick wanted to know what was going on</p>",
        "id": 127591057,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528191430
    },
    {
        "content": "<p>It would be a shame to have to start going on about letI or whatever</p>",
        "id": 127591062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528191460
    },
    {
        "content": "<p>My problem, i now realise, is that whilst Mario showed me how to overcome various typeclass inference issues in the schemes project</p>",
        "id": 127591071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528191477
    },
    {
        "content": "<p>I don't actually understand what is going on</p>",
        "id": 127591111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528191486
    },
    {
        "content": "<p>I don't understand what the \"type class inference machine\" has access to at any time</p>",
        "id": 127591120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528191497
    },
    {
        "content": "<p>For example I am not even sure if it knows X is an adic space</p>",
        "id": 127591125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528191511
    },
    {
        "content": "<p>Kevin, the first lines of the error are:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"n\">class</span> <span class=\"kn\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">to_adic_space</span> <span class=\"o\">:</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n<span class=\"n\">to_preadic_space</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">to_adic_space</span> <span class=\"o\">:=</span> <span class=\"n\">adic_space</span><span class=\"bp\">.</span><span class=\"n\">to_preadic_space</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n</pre></div>\n\n\n<p>That last line shows how to turn <code>X</code> into a <code>preadic_space</code>.</p>",
        "id": 127591240,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528191699
    },
    {
        "content": "<p>But it hasn't actually done it!</p>",
        "id": 127591242,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528191705
    },
    {
        "content": "<p>Maybe if that term was actually an instance, then the machine would do the rest for you.</p>",
        "id": 127591287,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528191738
    },
    {
        "content": "<p>Hmm, no. Because if I change the class of <code>X</code> to <code>adic_space</code> in <code>preadic_space_restriction</code>, then it still fails in <code>test</code>.</p>",
        "id": 127591424,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528192012
    },
    {
        "content": "<p>It's very easy to get Lean to say things like \"I know <code>X : Y</code> and type class inference is failing to find anything of type <code>Y</code>\"</p>",
        "id": 127592068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528193271
    },
    {
        "content": "<p>Do we know of any strategy for attacking this issue? Or should we wait 3 weeks till Mario and Johannes are back?</p>",
        "id": 127593408,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528195792
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">loc</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">),</span>\n  <span class=\"bp\">@</span><span class=\"n\">is_preadic_space_equiv</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">preadic_space_restriction</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">U</span> <span class=\"n\">U_open</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>The trouble is with <code>U_open</code>. If I replace that with an <code>_</code>, then typeclass inference can't figure it out itself...</p>",
        "id": 127594010,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528196750
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c1\">--failed to synthesize type class instance for</span>\n<span class=\"err\">⊢</span> <span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">U</span>\n</pre></div>\n\n\n<p>Is <code>_root_</code> a pointer to the trouble?</p>",
        "id": 127594207,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528197044
    },
    {
        "content": "<p>Maybe. Kenny pointed this out to me too. There's a long typeclass thread which might solve my problems.</p>",
        "id": 127594781,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528198019
    },
    {
        "content": "<p>Kenny suggested making another typeclass for subtypes being open</p>",
        "id": 127594789,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528198040
    },
    {
        "content": "<p>I don't see why that would fix things...</p>",
        "id": 127594794,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528198080
    },
    {
        "content": "<p>The stupid system is looking in the root namespace for an instance of <code>is_open U</code>, but it should just look 2 lines up in the local context...</p>",
        "id": 127594838,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528198127
    },
    {
        "content": "<p>It feels very much like a bug to me. (Wait. I'll first run this with <code>pp.all</code> set to true.)</p>",
        "id": 127594847,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528198158
    },
    {
        "content": "<p>Ok, so this is another (ugly) way to get it to work.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">loc</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"bp\">@_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">is_open</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"bp\">_</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">),</span>\n  <span class=\"n\">is_preadic_space_equiv</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)))</span>\n</pre></div>",
        "id": 127595002,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528198393
    },
    {
        "content": "<p>I doubt it's a bug.</p>",
        "id": 127595071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528198475
    },
    {
        "content": "<p>It's probably just how typeclass inference works</p>",
        "id": 127595074,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528198484
    },
    {
        "content": "<p>Yes, I also think that now.</p>",
        "id": 127595075,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528198493
    },
    {
        "content": "<p>So, what the heck is the difference between <code>@_root_.is_open.{0} X _ U</code> and <code>is_open U</code>?</p>",
        "id": 127595093,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528198542
    },
    {
        "content": "<p>One more golf (<span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">loc</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">),</span>\n  <span class=\"n\">is_preadic_space_equiv</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)))</span>\n</pre></div>",
        "id": 127595234,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528198796
    },
    {
        "content": "<p>So it really is about this <code>_root_</code> thingy. But at least now it looks somewhat readable again.</p>",
        "id": 127595282,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528198823
    },
    {
        "content": "<p>Of course a mathematician (like me!) doesn't know at all what <code>_root_</code> means, or what it is doing there. But hey! Cargo cult proofs for the win (-;</p>",
        "id": 127595308,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528198893
    },
    {
        "content": "<p>The problem is that <code>is_open</code> refers to two things here: the inherited field <code>topological_space.is_open</code> and the global definition <code>_root_.is_open</code>, which are different.</p>",
        "id": 127595461,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1528199157
    },
    {
        "content": "<p>Aah, because of a long chain of <code>extends</code>, right?</p>",
        "id": 127595510,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528199187
    },
    {
        "content": "<p>Right, that makes a lot (<em>a whole lot</em>!) of sense</p>",
        "id": 127595521,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528199221
    },
    {
        "content": "<p>It has been staring us right in the face, all the time.</p>",
        "id": 127595527,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528199232
    },
    {
        "content": "<p>So it is just some stupid overloading, and preferably one of the two <code>is_open</code>s should have another name.</p>",
        "id": 127595542,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528199274
    },
    {
        "content": "<p>Anyway, <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> thanks for enlightening me!</p>",
        "id": 127595874,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528199791
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> 'nother problem solved. Next!</p>",
        "id": 127595894,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528199871
    },
    {
        "content": "<p>Definition currently looks like this:</p>",
        "id": 127595943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528199935
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span>\n  <span class=\"c1\">-- gamma is our indexing set, U_i are the open cover for i in gamma</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Uopen</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">@_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">X</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">U_cover</span> <span class=\"o\">:</span> <span class=\"n\">is_cover</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- U i is isomorphic to Spa(A_i,A_i^+) with A_i a perfectoid ring</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is_perfectoid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">))</span>    <span class=\"o\">)</span>\n</pre></div>",
        "id": 127595944,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528199939
    },
    {
        "content": "<p>Typechecks fine</p>",
        "id": 127595948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528199945
    },
    {
        "content": "<p>The <code>is_open</code> overloading is one thing</p>",
        "id": 127595956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528199979
    },
    {
        "content": "<p>I guess you can remove the <code>@</code> and the <code>X _ </code></p>",
        "id": 127595957,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528199981
    },
    {
        "content": "<p>yes</p>",
        "id": 127595959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528199998
    },
    {
        "content": "<p>thanks</p>",
        "id": 127595960,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528200000
    },
    {
        "content": "<p>And just a <code>(U i)</code> on the last line? Instead of all the <code>{x ... }</code></p>",
        "id": 127596017,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528200023
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span>\n  <span class=\"c1\">-- gamma is our indexing set, U_i are the open cover for i in gamma</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Uopen</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">U_cover</span> <span class=\"o\">:</span> <span class=\"n\">is_cover</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- U i is isomorphic to Spa(A_i,A_i^+) with A_i a perfectoid ring</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is_perfectoid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">))</span>    <span class=\"o\">)</span>\n</pre></div>",
        "id": 127596119,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528200191
    },
    {
        "content": "<p>I'm not happy with that <code>_root_</code> but everything else is great</p>",
        "id": 127596120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528200204
    },
    {
        "content": "<p>Yes, completely agree.</p>",
        "id": 127596124,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528200219
    },
    {
        "content": "<p>We should just overhaul the definition in <code>topological_space.lean</code></p>",
        "id": 127596126,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528200232
    },
    {
        "content": "<p>It's only a silly namespacing issue.</p>",
        "id": 127596168,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528200244
    },
    {
        "content": "<p>I it has a field <code>open_subsets</code> instead of <code>is_open</code>, then we're fine.</p>",
        "id": 127596174,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528200267
    },
    {
        "content": "<p>can I fix this by writing my own <code>open</code> or <code>is_open'</code> or whatever?</p>",
        "id": 127596190,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528200330
    },
    {
        "content": "<p>Probably even <code>notation `is_open` := _root_.is_open</code> would work</p>",
        "id": 127596248,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528200402
    },
    {
        "content": "<p>Here's the full file</p>",
        "id": 127596251,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528200405
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">adic_space</span>\n\n<span class=\"c1\">--notation</span>\n<span class=\"kn\">postfix</span> <span class=\"bp\">`</span><span class=\"err\">ᵒ</span><span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">66</span> <span class=\"o\">:=</span> <span class=\"n\">power_bounded_subring</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- A perfectoid ring, following Fontaine Sem Bourb-/</span>\n<span class=\"n\">class</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">Tate_ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_complete</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_uniform</span>  <span class=\"o\">:</span> <span class=\"n\">uniform</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ramified</span>    <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">is_pseudo_uniformizer</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"err\">^</span> <span class=\"n\">p</span> <span class=\"err\">∣</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">Frob</span>        <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">ᵒ</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"err\">^</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span>\n  <span class=\"c1\">-- gamma is our indexing set, U_i are the open cover for i in gamma</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Uopen</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">U_cover</span> <span class=\"o\">:</span> <span class=\"n\">is_cover</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- U i is isomorphic to Spa(A_i,A_i^+) with A_i a perfectoid ring</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is_perfectoid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">))</span>    <span class=\"o\">)</span>\n</pre></div>",
        "id": 127596253,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528200411
    },
    {
        "content": "<p>I am really happy with all of it apart from the <code>_root_</code></p>",
        "id": 127596266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528200429
    },
    {
        "content": "<p>Some mathlib classes have the actual field name with a trailing <code>'</code> to avoid this kind of collision</p>",
        "id": 127596272,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528200458
    },
    {
        "content": "<p>except now I can't find any</p>",
        "id": 127596317,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528200500
    },
    {
        "content": "<blockquote>\n<p>can I fix this by writing my own <code>open</code> or <code>is_open'</code> or whatever?</p>\n</blockquote>\n<p>Sure, but you would also need all the simp-lemmas etc. That's why I suggested we might as well overhaul <code>topological_space.lean</code>.</p>",
        "id": 127599582,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528204721
    },
    {
        "content": "<p>And we have 6 commits! The game is on!</p>",
        "id": 127599673,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528204812
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> What is your git workflow for this repo? fork -&gt; feature branch -&gt; push? Or just write access for everyone interested?</p>",
        "id": 127600758,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528206103
    },
    {
        "content": "<p>Yeah, it should run. I have absolutely no idea about git workflows.</p>",
        "id": 127602811,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528208359
    },
    {
        "content": "<p>I guess I do understand the question. For the stacks project I just let Kenny push anything -- I gave him write access. But for mathlib I have to do that fork feature push thing.</p>",
        "id": 127602911,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528208473
    },
    {
        "content": "<p>Ok, so this is your chance to level-up in git!</p>",
        "id": 127605457,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528211505
    },
    {
        "content": "<p>Next job is the roadmap. I'll hopefully do this this evening (some issues explaining what needs to be done). Basically it's \"type in a bunch of stuff from Wedhorn's paper\"</p>",
        "id": 127607754,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528214401
    },
    {
        "content": "<p>Kenny did chapter 1 but I'm sitting on it because it needs some non-mathlib imports</p>",
        "id": 127607824,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528214425
    },
    {
        "content": "<p>I like it that you moved the <code>_root_</code> issue out of the perfectoid file</p>",
        "id": 127610418,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528217784
    },
    {
        "content": "<p>I'm sorry I missed this early fight. I was busy with administration all day (including writing letter to Jean-Pierre Serre explaining how to come to our new math building next week).</p>",
        "id": 127616339,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528225245
    },
    {
        "content": "<p>Is there a reason why <code>perfectoid_spaces.lean</code> is not inside the <code>src</code> directory?</p>",
        "id": 127616361,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528225271
    },
    {
        "content": "<blockquote>\n<p>Yeah, it should run. I have absolutely no idea about git workflows.</p>\n</blockquote>\n<p>Did you try using <a href=\"https://github.com/jlord/git-it-electron\" target=\"_blank\" title=\"https://github.com/jlord/git-it-electron\">https://github.com/jlord/git-it-electron</a> to learn? I never tried but it seems to be popular</p>",
        "id": 127616450,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528225364
    },
    {
        "content": "<p>Why not using ϖ (\\varpi)?</p>",
        "id": 127617146,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226177
    },
    {
        "content": "<p>Here it looks ugly but in my VScode it looks ok</p>",
        "id": 127617158,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226206
    },
    {
        "content": "<p>Why the space in <code>R ᵒ</code>? It works fine and looks better as <code>Rᵒ</code></p>",
        "id": 127617235,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226301
    },
    {
        "content": "<p>I'm such an expert about perfectoid spaces now...</p>",
        "id": 127617242,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226337
    },
    {
        "content": "<p>Is <code>instance subring_to_ring (R : Type) : has_coe (power_bounded_subring R) R := ⟨subtype.val⟩</code> meant to be useful right now? Deleting it changes nothing</p>",
        "id": 127617264,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226393
    },
    {
        "content": "<p>Is there any reason to use gamma instead of iota for the indexing type?</p>",
        "id": 127617602,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226833
    },
    {
        "content": "<p>no</p>",
        "id": 127617609,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528226853
    },
    {
        "content": "<p>iota is the mathlib tradition, and consistent with using <code>i</code> as a variable name</p>",
        "id": 127617613,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226859
    },
    {
        "content": "<p>OK</p>",
        "id": 127617619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528226865
    },
    {
        "content": "<p>I guess the thing is never named in math papers</p>",
        "id": 127617622,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226872
    },
    {
        "content": "<p>I can change all these things. Thanks for the review!</p>",
        "id": 127617623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528226874
    },
    {
        "content": "<p>Now, serious question:</p>",
        "id": 127617632,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226882
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∐</mo><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\coprod R_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"base\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∐</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span></p>",
        "id": 127617674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528226886
    },
    {
        "content": "<p>who needs a name for the index set</p>",
        "id": 127617677,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528226892
    },
    {
        "content": "<p>maybe I'll call it <code>_</code></p>",
        "id": 127617679,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528226899
    },
    {
        "content": "<p>You should not use existential quantification over <code>Type</code> in your definition</p>",
        "id": 127617683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528226904
    },
    {
        "content": "<p>eew</p>",
        "id": 127617688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528226913
    },
    {
        "content": "<p>for the index set</p>",
        "id": 127617691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528226917
    },
    {
        "content": "<p>Is this the thing Assia was also unhappy about?</p>",
        "id": 127617695,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528226923
    },
    {
        "content": "<p>Yes</p>",
        "id": 127617699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528226927
    },
    {
        "content": "<p>What about this strange way of putting things before and after the existential comma?</p>",
        "id": 127617702,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226933
    },
    {
        "content": "<p>It will needlessly push up the universe level of the definition</p>",
        "id": 127617707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528226944
    },
    {
        "content": "<p>How do you do it then?</p>",
        "id": 127617712,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528226950
    },
    {
        "content": "<p>And why naming instance implicit variables you don't use in the def?</p>",
        "id": 127617715,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226954
    },
    {
        "content": "<p>Even though it's inside an <code>\\ex</code>?</p>",
        "id": 127617722,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528226966
    },
    {
        "content": "<p>Instead you should quantify over all families that could possibly matter</p>",
        "id": 127617723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528226967
    },
    {
        "content": "<p>What about:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span>\n  <span class=\"c1\">-- gamma is our indexing set, U_i are the open cover for i in gamma</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n  <span class=\"c1\">-- U i is isomorphic to Spa(A_i,A_i^+) with A_i a perfectoid ring</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">],</span>\n  <span class=\"o\">(</span><span class=\"n\">is_cover</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n</pre></div>",
        "id": 127617724,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226968
    },
    {
        "content": "<p>Does it make any difference (what I wrote vs Kevin's version)?</p>",
        "id": 127617732,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528226983
    },
    {
        "content": "<p>oh, actually reid you're right, impredicativity makes it okay</p>",
        "id": 127617793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227007
    },
    {
        "content": "<p>Note that all data and instance implicit stuff is left of comma, and conditions are right of comma</p>",
        "id": 127617805,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528227023
    },
    {
        "content": "<p>Still, I would prefer to quantify over subsets of set X</p>",
        "id": 127617809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227031
    },
    {
        "content": "<p>Maybe you should make <code>ι</code> a field of <code>perfectoid_space</code> (and the others as well).</p>",
        "id": 127617820,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1528227055
    },
    {
        "content": "<p>unless there is a reason that having many duplicates adds power?</p>",
        "id": 127617824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227060
    },
    {
        "content": "<p>What Gabriel says was my next question</p>",
        "id": 127617850,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528227090
    },
    {
        "content": "<p>There are a lot of equivalent ways one could write this definition, but this way matches the way we speak</p>",
        "id": 127617853,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528227093
    },
    {
        "content": "<p>I agree it looks more mathematicial, I'm asking if this will bring pain</p>",
        "id": 127617898,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528227123
    },
    {
        "content": "<p>alternatively, name the thing \"perfectoid cover\" or something and existentially quantify in the structure</p>",
        "id": 127617906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227132
    },
    {
        "content": "<p>^ also sounds nice</p>",
        "id": 127617927,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528227159
    },
    {
        "content": "<p>i.e. define what is a perfectoid cover and define a perfectoid space to be one which has a cover</p>",
        "id": 127617928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227159
    },
    {
        "content": "<p>But again it would sound further away from math-speak</p>",
        "id": 127617948,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528227189
    },
    {
        "content": "<p>It think having the cover be a term of type <code>set (set X)</code> is not \"un-mathematical\". Except for the fact that we would call <code>set X</code> something like <code>subset_of X</code>.</p>",
        "id": 127617952,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528227197
    },
    {
        "content": "<p>or \"powerset\"</p>",
        "id": 127617967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227219
    },
    {
        "content": "<p>My definition is readable by mathematicians</p>",
        "id": 127618031,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528227264
    },
    {
        "content": "<p>In fact, in math usually open covers are defined to be subsets of the collection of open sets</p>",
        "id": 127618032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227265
    },
    {
        "content": "<p>and I don't understand what the problem with it is yet</p>",
        "id": 127618039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528227276
    },
    {
        "content": "<p>This thing with the indexing set makes it look like some kind of étale covering but it's actually a honest covering, right?</p>",
        "id": 127618049,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528227286
    },
    {
        "content": "<p>I have an exotic construction \"Spa\" which basically takes a ring and spits out a \"special\" topological space</p>",
        "id": 127618057,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528227300
    },
    {
        "content": "<p>The thing is that often one has some auxiliary data attached to each member of the cover, and then indexing the set with the set itself is awkward (what if the other data is not a function of the set)</p>",
        "id": 127618058,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528227302
    },
    {
        "content": "<p>and the claim is that my perfectoid space has a covering by these \"special\" spaces</p>",
        "id": 127618078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528227317
    },
    {
        "content": "<p>that's the theorem</p>",
        "id": 127618081,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227321
    },
    {
        "content": "<p>What Reid wrote seems important to me</p>",
        "id": 127618099,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528227349
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> yes it's just an honest covering of a topological space by open subsets</p>",
        "id": 127618101,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528227351
    },
    {
        "content": "<p>It's good to know that you only \"need\" to talk about small things in the definition and prove that you can do it even for large families</p>",
        "id": 127618104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227355
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, did you ever write down a definition of manifold?<br>\nEven if it is just parameterized on a variable (i.e., not yet defined) notion of \"smooth\" maps of R^n, it might be an interesting exercise.</p>",
        "id": 127618142,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528227363
    },
    {
        "content": "<blockquote>\n<p>Maybe you should make <code>ι</code> a field of <code>perfectoid_space</code> (and the others as well).</p>\n</blockquote>\n<p>The covering and the set indexing the covering are <em>not</em> part of the data of a perfectoid space.</p>",
        "id": 127618154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528227382
    },
    {
        "content": "<p>Even if you quantify over type 0 in the definition, you might want a family in type 1 and then you have a theorem to prove anyway</p>",
        "id": 127618160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227391
    },
    {
        "content": "<p>A perfectoid space is a space for which such a cover exists</p>",
        "id": 127618165,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528227405
    },
    {
        "content": "<p>No I'm stuck in type class loops, <code>out_param</code> hell when I try to put a norm on R^n</p>",
        "id": 127618183,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528227431
    },
    {
        "content": "<p>But indeed I could try to write the definition sorrying the definition of diffeomorphisms between open subsets of R^ n</p>",
        "id": 127618202,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528227460
    },
    {
        "content": "<p>I understood everything Patrick said but I'm having trouble with these CS objections about iota. Can someone suggest something which you'd be happy with but which is the same idea and which is still readable by mathematicians?</p>",
        "id": 127618205,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528227475
    },
    {
        "content": "<p>Note that my version of <code>perfectoid_space</code> quoted above is a variation in a direction orthogonal to this question of iota vs subsets</p>",
        "id": 127618281,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528227537
    },
    {
        "content": "<p>just use <code>U : set (opens X)</code></p>",
        "id": 127618291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227543
    },
    {
        "content": "<blockquote>\n<p>i.e. define what is a perfectoid cover and define a perfectoid space to be one which has a cover</p>\n</blockquote>\n<p>Aah I do understand this</p>",
        "id": 127618295,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528227547
    },
    {
        "content": "<p>for more readability, it should probably be more like <code>cover : set (opens X)</code></p>",
        "id": 127618353,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528227608
    },
    {
        "content": "<p>Oh wait, you already have an example of the issue I was bringing up earlier here.</p>",
        "id": 127618388,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528227653
    },
    {
        "content": "<p>We also have this <code>(A : ι → Huber_pair) [∀ i, perfectoid_ring (A i) p]</code> stuff</p>",
        "id": 127618399,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528227669
    },
    {
        "content": "<p>BTW I think the <code>p</code> should come first</p>",
        "id": 127618415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227706
    },
    {
        "content": "<p>because it's the parameter</p>",
        "id": 127618421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528227713
    },
    {
        "content": "<blockquote>\n<p>The covering and the set indexing the covering are not part of the data of a perfectoid space.</p>\n</blockquote>\n<p>Existentials are problematic since you'll have to use choice to access them, and in general you won't get the data back that you used to construct the perfectoid space in the first place.  If you make them fields, then you can actually get back the Huber pair <code>A</code> that you used to construct the perfectoid space---just via definitional reduction.</p>",
        "id": 127618473,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1528227750
    },
    {
        "content": "<p>He doesn't want to get it back</p>",
        "id": 127618493,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528227781
    },
    {
        "content": "<p>It's not part of the structure</p>",
        "id": 127618507,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528227789
    },
    {
        "content": "<blockquote>\n<p>for more readability, it should probably be more like <code>cover : set (opens X)</code></p>\n</blockquote>\n<p>and now I need a Huber Pair for each element of the cover</p>",
        "id": 127618938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528228305
    },
    {
        "content": "<p>What about Reid's concern? That we are not only indexing open subsets, but also other stuff with the same indexing set/type?</p>",
        "id": 127618944,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528228321
    },
    {
        "content": "<p>I think in this case, you could write something like \"there exists a set of open subsets which cover X and for each of these subsets, a Huber pair\" such that ...\". But there is a small subtlety here, in that the original definition allows you to choose the same open subset repeatedly with different Huber pairs. Here, there's no reason why you would want to do that, so it ends up not mattering.</p>",
        "id": 127618989,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528228335
    },
    {
        "content": "<p>But if you try to define a smooth manifold, you cannot begin \"there exists a set of open subsets which cover M and for each of these subsets, a continuous function to R^n such that ...\"</p>",
        "id": 127619007,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528228368
    },
    {
        "content": "<p>that's what makes the theorem not completely trivial</p>",
        "id": 127619013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528228373
    },
    {
        "content": "<blockquote>\n<p>But if you try to define a smooth manifold, you cannot begin \"there exists a set of open subsets which cover M and for each of these subsets, a continuous function to R^n such that ...\"</p>\n</blockquote>\n<p>Huh, why not?</p>",
        "id": 127619035,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528228414
    },
    {
        "content": "<p>theorem claiming this doesn't matter?</p>",
        "id": 127619036,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528228416
    },
    {
        "content": "<p>right</p>",
        "id": 127619046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528228423
    },
    {
        "content": "<p>Or, maybe you can?</p>",
        "id": 127619052,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528228436
    },
    {
        "content": "<p>that given the definition using sets of opens you can recover the version with families indexed in an arbitrary type</p>",
        "id": 127619103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528228454
    },
    {
        "content": "<blockquote>\n<p>Huh, why not?</p>\n</blockquote>\n<p>Because it wouldn't be correct</p>",
        "id": 127619104,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528228456
    },
    {
        "content": "<p>but it's not the usual definition of an atlas, since there you can have multiple charts on the same open but with different coordinates</p>",
        "id": 127619114,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528228471
    },
    {
        "content": "<p>but in general you should try to minimize your domain of quantification to something which is somehow bounded by the original input data</p>",
        "id": 127619120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528228479
    },
    {
        "content": "<p>You can build exotic spheres by gluing two open balls</p>",
        "id": 127619130,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528228496
    },
    {
        "content": "<p>if you don't, this is when mathematicians have to write \"chapter 4\" or whatever on ZFC embedding subtleties</p>",
        "id": 127619150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528228512
    },
    {
        "content": "<p>All the exotictness is in the gluing map</p>",
        "id": 127619161,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528228528
    },
    {
        "content": "<p>in the manifold case, I'm sure you can bound it by all the ways that maps can possibly fit together</p>",
        "id": 127619191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528228556
    },
    {
        "content": "<p>isn't it kind of a moot point anyways, since we are also asking for these Huber pairs, which also contain types?</p>",
        "id": 127619246,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528228594
    },
    {
        "content": "<p>maybe the Huber pairs can't get that large either</p>",
        "id": 127619271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528228626
    },
    {
        "content": "<p>in the manifold case the atlas is a set of pairs (U_i, f_i) where U_i is an open set and f_i is a homeomorphism from U_i to some open set in R^n.</p>",
        "id": 127619279,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528228641
    },
    {
        "content": "<p>I totally agree that if you find yourself with something that looks like a perfectoid space, but the indexing family is large, then it's a nontrivial theorem to show that you actually have a genuine perfectoid space</p>",
        "id": 127619284,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528228644
    },
    {
        "content": "<p>anyway, let's focus on the perfectoid case</p>",
        "id": 127619340,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528228685
    },
    {
        "content": "<p>I'm sort of speculating here, but really if you need all that extra indexing power, then the definition is probably not correct anyway because then Type is probably not enough</p>",
        "id": 127619374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528228725
    },
    {
        "content": "<p>it's an arbitrary stopping point in the ZFC world</p>",
        "id": 127619397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528228751
    },
    {
        "content": "<p>Kevin disappeared. Maybe he suddenly realized Scholze's perfectoid business makes no sense at all because of this issue</p>",
        "id": 127619462,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528228806
    },
    {
        "content": "<p>Ok, I don't know enough about manifolds. (They are weird, because they aren't defined as locally ringed spaces with some property.) But in the scheme case (and I think also in the perfectoid case) it should be fine to just work with a set of opens. Every point has an affine neighbourhood. That is what you need/want. Or am I messing up?</p>",
        "id": 127619586,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528228970
    },
    {
        "content": "<p>Nevertheless, if we use a set of opens, I don't know if that is a pretty thing to use as indexing set for the Huber pairs, and other data indexed on it. It might lead to ugly formalisation, it might lead to \"un-mathematical\" code. I really don't know.</p>",
        "id": 127619667,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528229050
    },
    {
        "content": "<p>You can define smooth manifolds as ringed space, see <a href=\"https://bookstore.ams.org/gsm-65\" target=\"_blank\" title=\"https://bookstore.ams.org/gsm-65\">https://bookstore.ams.org/gsm-65</a></p>",
        "id": 127619686,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528229086
    },
    {
        "content": "<p>I'm trying to do 10 things at once. I was hoping to get some work done tonight but my partner just got back from Canada and her sleeping patterns are in chaos; it might be bedtime.</p>",
        "id": 127619772,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528229193
    },
    {
        "content": "<p>I am not sure that anyone has ever used a perfectoid space for which the index set is any bigger than countably infinite</p>",
        "id": 127619781,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528229220
    },
    {
        "content": "<p>hmm</p>",
        "id": 127619783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528229223
    },
    {
        "content": "<p>maybe the size of the real numbers</p>",
        "id": 127619791,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528229233
    },
    {
        "content": "<p>I can't imagine anything bigger. Mario's \"chapter 4\" reference is pertinent -- this is the same paper as the one I've taken the definition of perfectoid space from.</p>",
        "id": 127619861,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528229291
    },
    {
        "content": "<blockquote>\n<p>maybe the Huber pairs can't get that large either</p>\n</blockquote>\n<p>I am not sure there is a single object in this story that has size &gt; 2^aleph_0</p>",
        "id": 127619894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528229345
    },
    {
        "content": "<p>Which \"chapter 4\" are we referring to?</p>",
        "id": 127620277,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528229774
    },
    {
        "content": "<p><a href=\"https://arxiv.org/abs/1709.07343\" target=\"_blank\" title=\"https://arxiv.org/abs/1709.07343\">https://arxiv.org/abs/1709.07343</a></p>",
        "id": 127620286,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528229789
    },
    {
        "content": "<p>We should have a file/issue with references. Because now there is the diamonds paper, Fontaine's bourbaki notes, Wedhorn's notes...</p>",
        "id": 127620309,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528229838
    },
    {
        "content": "<p>I have all these things as pdfs in my project directory but just didn't push them.</p>",
        "id": 127620323,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528229872
    },
    {
        "content": "<p>Maybe some list of links on the README?</p>",
        "id": 127620370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528229893
    },
    {
        "content": "<p>Yes, that should be fine.</p>",
        "id": 127620423,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528229981
    },
    {
        "content": "<p>I can PR the readme tomorrow</p>",
        "id": 127620435,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528229992
    },
    {
        "content": "<p>Maybe make a separate repository with the pdfs, if you want to commit them somewhere. Then people don't have to download them if they don't want to</p>",
        "id": 127620917,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528230520
    },
    {
        "content": "<p>I don't see the point of hosting the pdf on github if they were taken from arXiv</p>",
        "id": 127621535,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528231206
    },
    {
        "content": "<p>It would also be great to have a \"Getting it working\" section in your README.</p>",
        "id": 127622457,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1528232402
    },
    {
        "content": "<blockquote>\n<p>I don't see the point of hosting the pdf on github if they were taken from arXiv</p>\n</blockquote>\n<p>Agreed, I meant \"better not to commit pdfs to the main repository, whether or not you host them elsewhere\"</p>",
        "id": 127622699,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528232709
    },
    {
        "content": "<blockquote>\n<p>It would also be great to have a \"Getting it working\" section in your README.</p>\n</blockquote>\n<p>ha ha, I guess it currently doesn't work :-) (unless you allow sorrys). OK I'll write something about that in the README.</p>",
        "id": 127623463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528233729
    },
    {
        "content": "<blockquote>\n<p>It would also be great to have a \"Getting it working\" section in your README.</p>\n</blockquote>\n<p><a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/\">https://github.com/kbuzzard/lean-perfectoid-spaces/</a></p>",
        "id": 127624740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528235690
    },
    {
        "content": "<p>On my TODO list: (1) refactor definition of perfectoid space according to comments above, and move it into <code>src</code> (2) write a couple of issues explaining the details of what needs to be done to finish formalising the definition.</p>",
        "id": 127624758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528235743
    },
    {
        "content": "<p>Any comments / criticism / suggestions / anything -- I'd be happy to hear it. Once I've written the issues I will perhaps begin to circulate a link to the project amongst my mathematician chums</p>",
        "id": 127624806,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528235790
    },
    {
        "content": "<p>And of course, many thanks to those who have already commented!</p>",
        "id": 127624810,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528235816
    },
    {
        "content": "<p><em>boggle</em> Every change I made bring new typeclass inference problems</p>",
        "id": 127626651,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528238583
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">perfectoid_cover</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">adic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"err\">𝓤</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"o\">[</span><span class=\"err\">𝓤</span><span class=\"bp\">_</span><span class=\"n\">open</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"err\">𝓤</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"err\">𝓤</span><span class=\"bp\">_</span><span class=\"n\">cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"err\">𝓤</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"err\">𝓤</span><span class=\"bp\">_</span><span class=\"n\">affinoid_perfectoid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"err\">𝓤</span><span class=\"o\">,</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Aperf</span> <span class=\"o\">:</span> <span class=\"n\">perfectoid_ring</span> <span class=\"n\">p</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)))</span>   <span class=\"o\">)</span>\n</pre></div>",
        "id": 127626706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528238668
    },
    {
        "content": "<p>𝓤</p>",
        "id": 127626709,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528238685
    },
    {
        "content": "<p>and now I'm back with failing to synthesize <code>⊢ preadic_space ↥U</code></p>",
        "id": 127626712,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528238690
    },
    {
        "content": "<blockquote>\n<p>𝓤</p>\n</blockquote>\n<p>Collection of open sets</p>",
        "id": 127626723,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528238706
    },
    {
        "content": "<p>except that Lean does not notice they're open</p>",
        "id": 127626728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528238721
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">preadic_space_restriction</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preadic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">@_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">X</span> <span class=\"bp\">_</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">preadic_space</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 127626740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528238762
    },
    {
        "content": "<p>I guess I really liked the idea of typeclass inference showing automatically that if X is some kind of nice top space (an adic space or perfectoid space) and U is an open subset then U inherits the niceness. I might just give up and spell it out.</p>",
        "id": 127627182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528239490
    },
    {
        "content": "<p>I've given up on typeclass inference because it's midnight.</p>",
        "id": 127627396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528239890
    },
    {
        "content": "<p>In the old version above, I had <code>is_preadic_space_equiv (U i) (Spa (A i))</code></p>",
        "id": 127627414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528239923
    },
    {
        "content": "<p>and the preadic space structure on <code>U i</code> came from typeclass inference.</p>",
        "id": 127627417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528239943
    },
    {
        "content": "<p>I can't get it to work for U in some covering set</p>",
        "id": 127627420,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528239951
    },
    {
        "content": "<p>but this works:</p>",
        "id": 127627423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528239954
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- definitions of adic_space, preadic_space, Huber_pair etc</span>\n<span class=\"kn\">import</span> <span class=\"n\">adic_space</span>\n\n<span class=\"c1\">--notation</span>\n<span class=\"kn\">postfix</span> <span class=\"bp\">`</span><span class=\"err\">ᵒ</span><span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">66</span> <span class=\"o\">:=</span> <span class=\"n\">power_bounded_subring</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- A perfectoid ring, following Fontaine Sem Bourb-/</span>\n<span class=\"n\">class</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">Tate_ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_complete</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_uniform</span>  <span class=\"o\">:</span> <span class=\"n\">uniform</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ramified</span>    <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ϖ</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">is_pseudo_uniformizer</span> <span class=\"n\">ϖ</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">ϖ</span> <span class=\"err\">^</span> <span class=\"n\">p</span> <span class=\"err\">∣</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">Frob</span>        <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"err\">^</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">perfectoid_cover</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">adic_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"err\">𝓤</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"o\">[</span><span class=\"err\">𝓤</span><span class=\"bp\">_</span><span class=\"n\">open</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"err\">𝓤</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"err\">𝓤</span><span class=\"bp\">_</span><span class=\"n\">cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"err\">𝓤</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"err\">𝓤</span><span class=\"bp\">_</span><span class=\"n\">affinoid_perfectoid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"err\">𝓤</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Aperf</span> <span class=\"o\">:</span> <span class=\"n\">perfectoid_ring</span> <span class=\"n\">p</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n  <span class=\"n\">is_preadic_space_equiv</span> <span class=\"o\">(</span><span class=\"n\">preadic_space_pullback</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span>  <span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_perfectoid_cover</span> <span class=\"o\">:</span> <span class=\"n\">perfectoid_cover</span> <span class=\"n\">p</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 127627463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528239966
    },
    {
        "content": "<p><code>preadic_space_pullback U</code> is just <code>U</code> again :-) (actually it's {x : X // x \\in U})</p>",
        "id": 127627484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528240015
    },
    {
        "content": "<p>but the instance can key on it</p>",
        "id": 127627491,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528240026
    },
    {
        "content": "<p>I only half-know what those words mean</p>",
        "id": 127627494,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528240035
    },
    {
        "content": "<p>but type class inference works with this trick</p>",
        "id": 127627499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528240051
    },
    {
        "content": "<p>I said <code>set (opens X)</code> for a reason</p>",
        "id": 127632328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528248329
    },
    {
        "content": "<p>it's past time you had a <code>opens X</code> type of open subsets of X</p>",
        "id": 127632374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528248374
    },
    {
        "content": "<p>I don't have Lean here, so there might be stupid typos. But how about something like this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Aperf</span> <span class=\"o\">:</span> <span class=\"n\">perfectoid_ring</span> <span class=\"n\">p</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 127635899,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528255487
    },
    {
        "content": "<p>That seems very readable to me. And I basically just squashed some lines together.</p>",
        "id": 127635907,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528255512
    },
    {
        "content": "<blockquote>\n<p>it's past time you had a <code>opens X</code> type of open subsets of X</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> do you imagine something like this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">opens</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">open_is_subset</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">U</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 127641910,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528267524
    },
    {
        "content": "<p>Yes. You will also want a <code>has_mem A (opens A)</code> instance</p>",
        "id": 127642757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528269051
    },
    {
        "content": "<p>You could also use <code>subtype</code> for the definition</p>",
        "id": 127642759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528269062
    },
    {
        "content": "<p>Voila, another attempt.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">section</span> <span class=\"n\">opens</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n<span class=\"n\">include</span> <span class=\"n\">X</span> <span class=\"n\">t</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">opens</span> <span class=\"o\">:=</span> <span class=\"n\">subtype</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span><span class=\"n\">x</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">opens</span>\n</pre></div>",
        "id": 127643208,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528269954
    },
    {
        "content": "<p>It shouldn't make too much difference, but you should use <code>is_open</code> instead of <code>topological_space.is_open</code></p>",
        "id": 127643260,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528270028
    },
    {
        "content": "<p>Done.</p>",
        "id": 127643434,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528270374
    },
    {
        "content": "<p>But I'm having type class inference issues with Kevin's latest code (that he posted above).</p>",
        "id": 127643443,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528270412
    },
    {
        "content": "<p>And it doesn't help if I change <code>set (set X)</code> to <code>set (opens X)</code>.</p>",
        "id": 127643446,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528270434
    },
    {
        "content": "<p>Somehow Lean starts looking for an instance of <code>has_coe_to_sort nat</code>, and I have no idea why Lean would do that.</p>",
        "id": 127643487,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528270469
    },
    {
        "content": "<p>Never mind... error was between keyboard and chair.</p>",
        "id": 127643707,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528270942
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- definitions of adic_space, preadic_space, Huber_pair etc</span>\n<span class=\"kn\">import</span> <span class=\"n\">adic_space</span>\n\n<span class=\"c1\">--notation</span>\n<span class=\"kn\">postfix</span> <span class=\"bp\">`</span><span class=\"err\">ᵒ</span><span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">66</span> <span class=\"o\">:=</span> <span class=\"n\">power_bounded_subring</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- A perfectoid ring, following Fontaine Sem Bourb-/</span>\n<span class=\"n\">class</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">Tate_ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_complete</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_uniform</span>  <span class=\"o\">:</span> <span class=\"n\">uniform</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ramified</span>    <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ϖ</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">is_pseudo_uniformizer</span> <span class=\"n\">ϖ</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">ϖ</span><span class=\"err\">^</span><span class=\"n\">p</span> <span class=\"err\">∣</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">Frob</span>        <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"err\">^</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"n\">class</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_prime</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">perfectoid_ring</span> <span class=\"n\">p</span> <span class=\"n\">A</span><span class=\"o\">],</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 127643712,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528270972
    },
    {
        "content": "<p>I think it would be really nice if we also made the <code>[p : Prime]</code> stuff work. I'll try to look into it.</p>",
        "id": 127643724,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528271021
    },
    {
        "content": "<p>Oh yes, I remember. That means that <code>ϖ^p</code> breaks. And we don't want up-arrows or <code>p.val</code> or the likes.</p>",
        "id": 127644045,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528271680
    },
    {
        "content": "<p>Well, you can use <code>[fixed_prime]</code> plus <code>fixed_prime.p</code> to avoid the coercion stuff</p>",
        "id": 127644065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528271726
    },
    {
        "content": "<p>Right, with your \"hack\" we get</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- definitions of adic_space, preadic_space, Huber_pair etc</span>\n<span class=\"kn\">import</span> <span class=\"n\">adic_space</span>\n\n<span class=\"c1\">--notation</span>\n<span class=\"kn\">postfix</span> <span class=\"bp\">`</span><span class=\"err\">ᵒ</span><span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">66</span> <span class=\"o\">:=</span> <span class=\"n\">power_bounded_subring</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span>\n<span class=\"kn\">variable</span> <span class=\"o\">[</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"o\">]</span> <span class=\"c1\">-- fix a prime p</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- A perfectoid ring, following Fontaine Sem Bourb-/</span>\n<span class=\"n\">class</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">Tate_ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_complete</span> <span class=\"o\">:</span> <span class=\"n\">complete</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_uniform</span>  <span class=\"o\">:</span> <span class=\"n\">uniform</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ramified</span>    <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ϖ</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">is_pseudo_uniformizer</span> <span class=\"n\">ϖ</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">ϖ</span><span class=\"err\">^</span><span class=\"n\">p</span> <span class=\"err\">∣</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">Frob</span>        <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"err\">^</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"n\">class</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">perfectoid_ring</span> <span class=\"n\">A</span><span class=\"o\">],</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 127644117,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528271823
    },
    {
        "content": "<p>Look ma! No primes in our type signatures!</p>",
        "id": 127644121,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528271844
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">perfectoid_space</span> <span class=\"c1\">-- perfectoid_space : Π [_inst_1 : nat.Prime], Type → Type</span>\n</pre></div>",
        "id": 127644170,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528271933
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Is there a reason why <code>perfectoid_ring</code> has hypothesis <code>is_complete</code> and <code>is_uniform</code> and also <code>ramified</code>. Why not <code>is_ramified</code>?</p>",
        "id": 127644441,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528272441
    },
    {
        "content": "<p>It's just random -- like in Lean. It's <code>group</code> but <code>is_group_hom</code> right?</p>",
        "id": 127644488,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528272522
    },
    {
        "content": "<p><code>is_group_hom</code> because that's a prop</p>",
        "id": 127644494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528272538
    },
    {
        "content": "<p><code>group</code> is not</p>",
        "id": 127644499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528272543
    },
    {
        "content": "<p>Aah!</p>",
        "id": 127644506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528272551
    },
    {
        "content": "<p>So how about <code>is_perfectoid_space</code></p>",
        "id": 127644513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528272574
    },
    {
        "content": "<p>because it's an adic space plus some prop</p>",
        "id": 127644516,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528272582
    },
    {
        "content": "<p>I guess that makes sense. And similarly <code>is_perfectoid_ring</code>, and I guess <code>is_ramified</code>.</p>",
        "id": 127644573,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528272689
    },
    {
        "content": "<p>Hmmm, but <code>group</code> is also just a <code>monoid</code> with some props, right?</p>",
        "id": 127644624,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528272745
    },
    {
        "content": "<p>But maybe its type is not Prop</p>",
        "id": 127644717,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528272941
    },
    {
        "content": "<p>That's the distinction I think</p>",
        "id": 127644725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528272959
    },
    {
        "content": "<p>Right, that makes sense. So then it is <code>is_ramified</code>, and the rest stays as it is.</p>",
        "id": 127644779,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528273017
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Does it also make sense to call the last condition <code>is_perfect</code> instead of <code>Frob</code>?</p>",
        "id": 127645043,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528273477
    },
    {
        "content": "<p>If you search for \"perfect ring\" then you get ads for weddings</p>",
        "id": 127645837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528274993
    },
    {
        "content": "<p>I thought Frobenius was bijective for a perfect ring, not surjective. What do you think?</p>",
        "id": 127645886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528275032
    },
    {
        "content": "<p>Hmm, you are probably right</p>",
        "id": 127645889,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528275049
    },
    {
        "content": "<p>Bam! <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/1\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/1\">https://github.com/kbuzzard/lean-perfectoid-spaces/pull/1</a></p>",
        "id": 127645905,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528275114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Your first PR (-;</p>",
        "id": 127645945,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528275125
    },
    {
        "content": "<p>I've pushed Kenny's valuation stuff by the way (first chapter of Wedhorn)</p>",
        "id": 127645950,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528275146
    },
    {
        "content": "<p>And there is also <a href=\"https://github.com/jcommelin/lean-perfectoid-spaces/tree/opens\" target=\"_blank\" title=\"https://github.com/jcommelin/lean-perfectoid-spaces/tree/opens\">https://github.com/jcommelin/lean-perfectoid-spaces/tree/opens</a></p>",
        "id": 127645981,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528275218
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Your first PR (-;</p>\n</blockquote>\n<p>One day when we have a gigantic maths brain that's taking over the universe, you'll be able to tell your children that you made the first PR.</p>",
        "id": 127645983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528275225
    },
    {
        "content": "<p>if we decided to spare them</p>",
        "id": 127646027,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528275244
    },
    {
        "content": "<p>Which defines the <code>opens</code> class. And uses it in the <code>perfectoid_space</code> definition.</p>",
        "id": 127646031,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528275256
    },
    {
        "content": "<p>Kevin, should I also PR the <code>opens</code> stuff? Or do you not like that direction?</p>",
        "id": 127646089,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528275374
    },
    {
        "content": "<blockquote>\n<p>I said <code>set (opens X)</code> for a reason</p>\n</blockquote>\n<p>I couldn't find <code>opens</code> in the topological space stuff so I left it and decided I should ask where it was later</p>",
        "id": 127646096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528275388
    },
    {
        "content": "<blockquote>\n<p>it's past time you had a <code>opens X</code> type of open subsets of X</p>\n</blockquote>\n<p>Ohh!</p>",
        "id": 127646099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528275396
    },
    {
        "content": "<p>I see that <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> made <code>ker f</code> a subset instead of a subtype. I really don't know when I should use which. Can someone clarify this for me?</p>",
        "id": 127646265,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528275690
    },
    {
        "content": "<p>you can coerce a subset to a subtype anytime</p>",
        "id": 127646316,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528275727
    },
    {
        "content": "<p>I can't. I'm constantly switching between them. I guess subsets are easier to work with</p>",
        "id": 127646318,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528275731
    },
    {
        "content": "<p>[I can't clarify, I can coerce]</p>",
        "id": 127646323,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528275753
    },
    {
        "content": "<p>Random screed by Hazewinkel claims perfect is bijective \\lam x, x^p</p>",
        "id": 127646327,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528275773
    },
    {
        "content": "<p>Ok, so <code>Frob</code> it is. I already reverted it on my branch.</p>",
        "id": 127646342,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528275814
    },
    {
        "content": "<p>I don't understand <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/b1e6489145be504e64a009226c6811bfd84a5070/src/perfectoid_space.lean#L22\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/b1e6489145be504e64a009226c6811bfd84a5070/src/perfectoid_space.lean#L22\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/b1e6489145be504e64a009226c6811bfd84a5070/src/perfectoid_space.lean#L22</a> Why isn't there a <code>∃</code> here?</p>",
        "id": 127649540,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528281568
    },
    {
        "content": "<p>Do we have a roadmap saying which parts of Wedhorn are needed?</p>",
        "id": 127649589,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528281610
    },
    {
        "content": "<p>It is equivalent up to a choice, right?</p>",
        "id": 127650170,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528282710
    },
    {
        "content": "<p>And I think the roadmap is under construction.</p>",
        "id": 127650175,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528282727
    },
    {
        "content": "<p>Ooh, there is a tiny typo in <code>subrel.lean</code>. We need <code>\\alpha</code> to be of type <code>Type*</code>. Without the <code>*</code> Kenny's code gets an error.</p>",
        "id": 127651738,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528285539
    },
    {
        "content": "<blockquote>\n<p>Do we have a roadmap saying which parts of Wedhorn are needed?</p>\n</blockquote>\n<p>It's on the way</p>",
        "id": 127652798,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528287195
    },
    {
        "content": "<p>I keep trying to do everything</p>",
        "id": 127652800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528287202
    },
    {
        "content": "<p>maybe I should post some basic info and then work on it more</p>",
        "id": 127652804,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528287212
    },
    {
        "content": "<p>Yes, some issues with basics would be totally fine.</p>",
        "id": 127666129,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528304688
    },
    {
        "content": "<p>I ran into <a href=\"https://en.wikipedia.org/wiki/Guy_Henniart\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Guy_Henniart\">Guy Henniart</a> on the train this morning. I told him about schemes and perfectoid spaces in Lean, he was very interested. He told me proof assistants will probably be part of the future of mathematics and we should try to use this opportunity to tighten our links with the CS department, maybe hiring someone working on this.</p>",
        "id": 127669147,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528308342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span></p>",
        "id": 127669203,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528308365
    },
    {
        "content": "<p>he proved local langland for GL(n) :o</p>",
        "id": 127669223,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528308416
    },
    {
        "content": "<p>Yes it's that level: stuff Scholze reproved when he was a 1st year undergrad</p>",
        "id": 127669251,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528308443
    },
    {
        "content": "<p>very impressive from Guy</p>",
        "id": 127669259,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528308459
    },
    {
        "content": "<blockquote>\n<p>\"Une preuve simple des conjectures de Langlands pour GL(n) sur un corps p-adique\"</p>\n</blockquote>",
        "id": 127669267,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528308472
    },
    {
        "content": "<p>\"une preuve simple\"</p>",
        "id": 127669269,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528308477
    },
    {
        "content": "<p>and one of my body parts is made of chicken</p>",
        "id": 127669317,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528308489
    },
    {
        "content": "<p>maybe the proof has no nontrivial subproofs</p>",
        "id": 127669338,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528308525
    },
    {
        "content": "<p>Patrick, that's cool news! I really like it that people are enthusiastic about these formalisations. So far most people I encounter only shrug their shoulders...</p>",
        "id": 127669449,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528308630
    },
    {
        "content": "<p>It was also funny seeing him reacting when I said there would be riots if Scholze doesn't get his medal in Rio. He completely failed to picture how this could happen (Scholze not getting the medal).</p>",
        "id": 127669474,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528308651
    },
    {
        "content": "<p>Johan: yes, this is why I tell this story here. It was a pretty unusual reaction</p>",
        "id": 127669505,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528308705
    },
    {
        "content": "<p>Especially since Guy is from a generation that can barely use a computer to write an email</p>",
        "id": 127669560,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528308733
    },
    {
        "content": "<p>Next week I should try to ask Serre what he thinks about proof assistants</p>",
        "id": 127669574,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528308763
    },
    {
        "content": "<p>Trollolol</p>",
        "id": 127669580,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528308777
    },
    {
        "content": "<p>An algebraist in my department went to the Loeser conference last week and said that Hales had mentioned the schemes work in his talk. But I guess Hales is biased :-)</p>",
        "id": 127669878,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528309114
    },
    {
        "content": "<p>Ok, but this is only an encouragement that we really should get perfectoid spaces in Lean before Rio!</p>",
        "id": 127670020,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528309247
    },
    {
        "content": "<p>It looks like it's almost done</p>",
        "id": 127670044,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528309276
    },
    {
        "content": "<p>If Scholze showed some interest, and now Henniart...</p>",
        "id": 127670049,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528309284
    },
    {
        "content": "<p>who is Rio?</p>",
        "id": 127670057,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528309300
    },
    {
        "content": "<blockquote>\n<p>It looks like it's almost done</p>\n</blockquote>\n<p>I guess you have to place quite a bit of emphasis on <em>looks</em></p>",
        "id": 127670524,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528309886
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/issues/3\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/issues/3\">https://github.com/kbuzzard/lean-perfectoid-spaces/issues/3</a></p>",
        "id": 127735398,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528400488
    },
    {
        "content": "<p>I had a good look through the maths last night and I don't see any major difficulties, but who knows.</p>",
        "id": 127735457,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528400543
    },
    {
        "content": "<p>\"Page numbers are all for Huber's notes.\" I guess you meant Wedhorn?</p>",
        "id": 127735490,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528400597
    },
    {
        "content": "<p>ooh thanks</p>",
        "id": 127735493,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528400603
    },
    {
        "content": "<p>I do that a lot!</p>",
        "id": 127735498,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528400612
    },
    {
        "content": "<p>Lean 7 will tell you about such typos on Github</p>",
        "id": 127735549,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528400645
    },
    {
        "content": "<p>I'm not sure I understand the dependency graph</p>",
        "id": 127735742,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528400931
    },
    {
        "content": "<p>I'm not surprised</p>",
        "id": 127735754,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528400959
    },
    {
        "content": "<p>Should I explain it?</p>",
        "id": 127735755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528400964
    },
    {
        "content": "<p>In the issue, I mean?</p>",
        "id": 127735758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528400971
    },
    {
        "content": "<p>It would help if you want help on this</p>",
        "id": 127735763,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528400984
    },
    {
        "content": "<p>Because currently it's not clear how the work could be divided</p>",
        "id": 127735815,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528401008
    },
    {
        "content": "<p>Is Spv(A) a typo or something different from Spa(A)?</p>",
        "id": 127735841,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528401077
    },
    {
        "content": "<p>Maybe v is valuation?</p>",
        "id": 127735842,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528401084
    },
    {
        "content": "<p>something different</p>",
        "id": 127735843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528401088
    },
    {
        "content": "<p>I didn't make the notation</p>",
        "id": 127735844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528401091
    },
    {
        "content": "<p>it appears only once in the issue</p>",
        "id": 127735848,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528401118
    },
    {
        "content": "<p>It's an auxilary definition :-)</p>",
        "id": 127735889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528401138
    },
    {
        "content": "<p>I'll add some comments</p>",
        "id": 127735896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528401151
    },
    {
        "content": "<p>Roughly, how many pages of Wedhorn are actually required for this definition of adic spaces?</p>",
        "id": 127735998,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528401303
    },
    {
        "content": "<p>In retrospect I don't think that many.</p>",
        "id": 127736514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528401958
    },
    {
        "content": "<p>The hard work might be proving that an affinoid adic space is an adic space</p>",
        "id": 127736560,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528401973
    },
    {
        "content": "<p>however</p>",
        "id": 127736562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528401975
    },
    {
        "content": "<p>that might be easier than proving that an affine scheme is a scheme</p>",
        "id": 127736570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528401986
    },
    {
        "content": "<p>because O_X is a sheaf on Spec(R)</p>",
        "id": 127736573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528401994
    },
    {
        "content": "<p>and the analogous fact for Spa(R) is not true</p>",
        "id": 127736577,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402003
    },
    {
        "content": "<p>so an affinoid adic space is Spa(R) for an R for which it is true</p>",
        "id": 127736581,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402018
    },
    {
        "content": "<p>Aah, I've got it</p>",
        "id": 127736587,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402026
    },
    {
        "content": "<p>The hard thing will be proving that an affinoid perfectoid space is a perfectoid space</p>",
        "id": 127736591,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402037
    },
    {
        "content": "<p>That will need far more stuff</p>",
        "id": 127736594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402049
    },
    {
        "content": "<p>but we don't need to advertise that, right? ;-)</p>",
        "id": 127736737,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402243
    },
    {
        "content": "<p>Is there any easier example of a perfectoid space?</p>",
        "id": 127736757,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528402272
    },
    {
        "content": "<p>The empty space</p>",
        "id": 127736817,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402323
    },
    {
        "content": "<p>there is literally no simple example of a perfectoid space other than this</p>",
        "id": 127736826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402340
    },
    {
        "content": "<p>That's what I feared</p>",
        "id": 127736835,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528402357
    },
    {
        "content": "<p>because the second simplest example is Spa(K,K^o) with K a perfectoid field</p>",
        "id": 127736836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402360
    },
    {
        "content": "<p>So we can't really escape that example</p>",
        "id": 127736840,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528402370
    },
    {
        "content": "<p>well, at least it's a field</p>",
        "id": 127736847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402377
    },
    {
        "content": "<p>Something like C_p, the completion of an algebraic closure of the p-adic numbers, is a relatively straightforward example of a perfectoid field</p>",
        "id": 127736863,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402407
    },
    {
        "content": "<p>don't worry, it's algebraically closed</p>",
        "id": 127736872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402424
    },
    {
        "content": "<p>you don't have to go on forever</p>",
        "id": 127736875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402428
    },
    {
        "content": "<p>And if we want to prove any result about this definition, beyond having an example, is it super hard to prove that tilting thing?</p>",
        "id": 127736878,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528402435
    },
    {
        "content": "<p>We number theorists tell people that C_p is our version of the complex numbers</p>",
        "id": 127736879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402439
    },
    {
        "content": "<p>Corollary 3.20 in the diamonds paper</p>",
        "id": 127736921,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528402447
    },
    {
        "content": "<p>Oh yeah the tilting thing needs a whole bunch of commutative algebra</p>",
        "id": 127736923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402458
    },
    {
        "content": "<p>almost etale extensions</p>",
        "id": 127736931,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402469
    },
    {
        "content": "<p>probably cotangent complex</p>",
        "id": 127736932,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402477
    },
    {
        "content": "<p>although actually maybe you could instead use my work with Verberkmoes</p>",
        "id": 127736936,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402487
    },
    {
        "content": "<p>a bunch of almost mathematics though</p>",
        "id": 127736947,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402505
    },
    {
        "content": "<p>derived categories</p>",
        "id": 127736956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402516
    },
    {
        "content": "<p>yeah it would be a good challenge</p>",
        "id": 127736962,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402524
    },
    {
        "content": "<p>If you did that then serious people would get interested</p>",
        "id": 127736976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402559
    },
    {
        "content": "<p>because that is like an odd order theorem but one that people are interested in</p>",
        "id": 127737029,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528402577
    },
    {
        "content": "<p>The proof is only two lines long in that diamonds paper: \"The tilting process glues to give a functor X \\maptos X^b . Theorem 3.13 globalizes to the following result.\" and the proof of Theorem 3.13 is \"In [Sch12], these are only proved over a perfectoid field, but the proof works in general.\"</p>",
        "id": 127737067,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528402677
    },
    {
        "content": "<p>doesn't looks too bad</p>",
        "id": 127737115,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528402699
    },
    {
        "content": "<p>Yes the work is tilting an affinoid perfectoid and...I guess writing down the definition of the tilt might not be so hard, come to think of it. It's proving that the space and its tilt have the same geometry that's hard</p>",
        "id": 127737413,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528403052
    },
    {
        "content": "<p>A huge generalisation of Fontaine-Wintenberger and Faltings</p>",
        "id": 127737432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528403092
    },
    {
        "content": "<p>OK so I just looked at the paper (I'm travelling currently). The hard part is the equivalence, that is a lot of content. Maybe the definition of tilting might be possible.</p>",
        "id": 127737728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528403458
    },
    {
        "content": "<p>Is there  anything simpler but still significant that could be proved about those spaces?</p>",
        "id": 127737756,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528403511
    },
    {
        "content": "<p>I guess one could prove that if A is perfectoid then Spa (A) is a perfectoid space. Scholze's original proof used tilting and a whole bunch of machinery. Verberkmoes and I found a much shorter direct proof. But doing basic stuff like defining perfectoids is the sort of thing we can do \"in our spare time\" -- formalising my paper would be a serious endeavour, although of course it's something I've considered. Most things in the area are impossibly hard or just very long. There are hundreds of pages by gabber and Romero that would be a joy to do but would take forever</p>",
        "id": 127741865,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528409267
    },
    {
        "content": "<p>I do think that it would be dissapointing if we have no examples at all... Defining tilting will be very nice PR I think. But it would be more 'honest' to first prove that Spa(A) is perfectoid (given that you have a proof without tilting).</p>",
        "id": 127751773,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528427341
    },
    {
        "content": "<p>I think that most mathematicians will not really understand what is going on, and wouldn't know the difference between defining a perfectoid space and defining tilting. But I'd happily be proved wrong. There are two independent questions. The one I was interested in (and still am) is: \"given that most of the non-trivial work doing maths on computers is of a Kepler conjecture / odd order theorem nature, i.e. hundreds of lemmas about relative simply things, are these programs even _capable_ of doing mathematics with non-trivial objects?\"</p>",
        "id": 127758361,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440424
    },
    {
        "content": "<p>I now think they are. But there's a different question, which is much more complicated:</p>",
        "id": 127758370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440458
    },
    {
        "content": "<p>how to get one non-trivial theorem about one non-trivial object into these systems?</p>",
        "id": 127758374,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440471
    },
    {
        "content": "<p>And that will cost time and money</p>",
        "id": 127758376,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440474
    },
    {
        "content": "<p>it's not just a \"hobby project\" like defining a perfectoid space</p>",
        "id": 127758416,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440486
    },
    {
        "content": "<p>I have 4.5 hours of meetings with the UK science funding council EPSRC today (it's one big reason that I couldn't go to Hanoi)</p>",
        "id": 127758424,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440537
    },
    {
        "content": "<p>and this will come up</p>",
        "id": 127758429,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440545
    },
    {
        "content": "<p>Ok, good luck!</p>",
        "id": 127758430,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528440554
    },
    {
        "content": "<p>Sounds like today is an important day</p>",
        "id": 127758432,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528440562
    },
    {
        "content": "<p>but if they're not interested then I don't quite know what happens next</p>",
        "id": 127758433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440572
    },
    {
        "content": "<p>I guess I am more interested in hearing their thoughts about setting up something big</p>",
        "id": 127758435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440584
    },
    {
        "content": "<p>and whether they'd encourage me to apply for funding</p>",
        "id": 127758437,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440600
    },
    {
        "content": "<p>So, when does the meeting start? (Or rather, when will you be back to tell us about the good news <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span>?)</p>",
        "id": 127758735,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528441091
    },
    {
        "content": "<p>I don't think any decisions will be made today!</p>",
        "id": 127759770,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528443273
    },
    {
        "content": "<p>But there will be a chance to test the water.</p>",
        "id": 127759772,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528443286
    },
    {
        "content": "<p><a href=\"http://www.math.columbia.edu/~harris/otherarticles_files/perfectoid.pdf\" target=\"_blank\" title=\"http://www.math.columbia.edu/~harris/otherarticles_files/perfectoid.pdf\">www.math.columbia.edu/~harris/otherarticles_files/perfectoid.pdf</a></p>",
        "id": 127760289,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528444361
    },
    {
        "content": "<p>I hadn't been aware of this article until the other day</p>",
        "id": 127760292,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528444374
    },
    {
        "content": "<p>The introduction is really nice.</p>",
        "id": 127760379,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528444557
    },
    {
        "content": "<p>[sorry, double post fail]</p>",
        "id": 127761231,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528446183
    },
    {
        "content": "<p>Kevin, do we even need the notion of Tate ring?</p>",
        "id": 127765205,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528453842
    },
    {
        "content": "<p>Maybe not but it's pretty easy to formalise if you have everything else. A perfectoid ring is a Tate ring plus ...</p>",
        "id": 127769845,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528461941
    },
    {
        "content": "<p>If type class inference tries to turn an ideal into a module it starts looping to find a ring. Same issue that Patrick has I guess.</p>",
        "id": 127771741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528464262
    },
    {
        "content": "<p>modules are very dangerous for type class resolution. I'm still waiting for Mario, Johannes and Sebastian to really solve this issue</p>",
        "id": 127771945,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528464493
    },
    {
        "content": "<p>Hmmz... we need finitely generated ideals. It would be very useful to have <code>span</code> from linear algebra. But then we need to treat an ideal as a module.</p>",
        "id": 127772171,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528464756
    },
    {
        "content": "<p>If there are actual technical problem with modules being a typeclass then surely one solution is just to stop them being a typeclass?</p>",
        "id": 127772199,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528464822
    },
    {
        "content": "<p>And have all the code be utterly unreadable to mathematicians...</p>",
        "id": 127772245,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528464844
    },
    {
        "content": "<p>By the way, Kevin, are the meetings over yet? Were they receptive to your ideas/plans?</p>",
        "id": 127772268,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528464899
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Is it ok to add <a href=\"https://github.com/johoelzl/mason-stother\" target=\"_blank\" title=\"https://github.com/johoelzl/mason-stother\">https://github.com/johoelzl/mason-stother</a> as dependency. Then we have univariate polynomials. And this is scheduled to go into mathlib anyway, so the dependecy would be temporary.</p>",
        "id": 127772447,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528465085
    },
    {
        "content": "<p><a href=\"https://github.com/jcommelin/lean-perfectoid-spaces/tree/Huber_pair\" target=\"_blank\" title=\"https://github.com/jcommelin/lean-perfectoid-spaces/tree/Huber_pair\">https://github.com/jcommelin/lean-perfectoid-spaces/tree/Huber_pair</a> is a clumsy attempt to define Huber rings (up to the topological stuff).</p>",
        "id": 127774148,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467261
    },
    {
        "content": "<p>But there is still a sorry to turn an ideal into a module.</p>",
        "id": 127774162,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467277
    },
    {
        "content": "<p>Money: I was encouraged to apply for it. Mason-Stothers -- is there a risk that we make this a dependency and then M-S gets PRed to mathlib and then stuff gets changed and then our code doesn't work? Or doesn't this matter?</p>",
        "id": 127788416,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528485177
    },
    {
        "content": "<p>Not so much... we really use very little of it. That part of the interface shouldn't change.</p>",
        "id": 127788447,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528485219
    },
    {
        "content": "<p>I can PR my subring branch into your repo if you want... it adds Mason-Stothers as dep.</p>",
        "id": 127788507,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528485268
    },
    {
        "content": "<p>So then another question is: if we only use very little of it, is it best to just cut and paste a small part of it into our repo directly and then delete it later?</p>",
        "id": 127788511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528485285
    },
    {
        "content": "<p>I just have no idea how to run a project like this.</p>",
        "id": 127788514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528485293
    },
    {
        "content": "<p>No, I would just go with the dependency.</p>",
        "id": 127788527,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528485315
    },
    {
        "content": "<p>And move on to interesting stuff (-;</p>",
        "id": 127788536,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528485326
    },
    {
        "content": "<p>Ok then I'll add the dependency. Can it wait a day? Can you do it?</p>",
        "id": 127788540,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528485334
    },
    {
        "content": "<p>I did it.</p>",
        "id": 127788542,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528485340
    },
    {
        "content": "<p>I have relatives here so I should go</p>",
        "id": 127788545,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528485344
    },
    {
        "content": "<p>Shall I PR?</p>",
        "id": 127788546,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528485345
    },
    {
        "content": "<p>thanks</p>",
        "id": 127788547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528485345
    },
    {
        "content": "<p>yes please PR</p>",
        "id": 127788550,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528485349
    },
    {
        "content": "<p>Aaah, ok, see you later.</p>",
        "id": 127788551,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528485352
    },
    {
        "content": "<p>I will look over it later. Assia suggested that I understand all the code I accept so I'd like to read through it before I accept it but I'm sure I will</p>",
        "id": 127788598,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528485377
    },
    {
        "content": "<p>Well, I'm a newbie... so maybe you want to improve little things...</p>",
        "id": 127788625,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528485444
    },
    {
        "content": "<p>Don't you think we should write a LaTeX file describing what has been formalized so far, and update it each time something is added? If we do this in real time it shouldn't be too painful. And I think it would be really useful. It could even include some comments about the formalization choices.</p>",
        "id": 127788974,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528485872
    },
    {
        "content": "<p><code>class normal_add_subgroup [add_group α] (s : set α) extends is_add_subgroup s : Prop := (normal : ∀ n ∈ s, ∀ g : α, g + n - g ∈ s)</code> WTF?!</p>",
        "id": 127789019,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528485955
    },
    {
        "content": "<p>You can have tick boxes in Github issues, right?</p>",
        "id": 127789070,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528485975
    },
    {
        "content": "<p>Do perfectoid spaces include non commutative groups with additive notations?</p>",
        "id": 127789076,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528485983
    },
    {
        "content": "<p>That might be useful</p>",
        "id": 127789077,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528485984
    },
    {
        "content": "<p>I didn't write that file. I just copy-pasted it, and then find-replaced stuff to get additive versions.</p>",
        "id": 127789090,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528486017
    },
    {
        "content": "<p>But this bit is evil</p>",
        "id": 127789104,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528486040
    },
    {
        "content": "<p>I agree. I am just saying that I didn't actually read that part of the file.</p>",
        "id": 127789114,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528486064
    },
    {
        "content": "<p>I am still annoyed that I even had to do all that duplication.</p>",
        "id": 127789123,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528486079
    },
    {
        "content": "<p>Patrick, I think it might also be a good idea to have accompanying comments (like Kevin did in parts of the files).</p>",
        "id": 127789455,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528486493
    },
    {
        "content": "<p>That will help interested mathematicians to figure out what is going on.</p>",
        "id": 127789470,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528486516
    },
    {
        "content": "<p>Sure. Every documentation is good</p>",
        "id": 127789481,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528486544
    },
    {
        "content": "<p>Concerning the LaTeX-file, I think that's fine. But then maybe we shouldn't have issues as well. Otherwise we will have Zulip, issues, comments in the code, TeX-file,...</p>",
        "id": 127789546,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528486622
    },
    {
        "content": "<p>And then we get lost.</p>",
        "id": 127789552,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528486633
    },
    {
        "content": "<p>Issues are about things to do. LaTeX file would be about things that are done</p>",
        "id": 127789561,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528486664
    },
    {
        "content": "<p>Yes, and PR's form the boundary, and Zulip is the glue that keeps everything together.</p>",
        "id": 127789639,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528486731
    },
    {
        "content": "<p>Family request me, but see <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/commit/334581954ca07e38d16526a264ac85807ee221df\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/commit/334581954ca07e38d16526a264ac85807ee221df\">https://github.com/PatrickMassot/lean-perfectoid-spaces/commit/334581954ca07e38d16526a264ac85807ee221df</a> to see what I'm working on (comments are already welcome)</p>",
        "id": 127816932,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528541583
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span></p>",
        "id": 127816937,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528541595
    },
    {
        "content": "<p>when I'll be done proving that uniform_space instance I will quickly be stuck waiting for Johan's PR merge</p>",
        "id": 127816987,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528541673
    },
    {
        "content": "<p>Cool!</p>",
        "id": 127817563,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528542977
    },
    {
        "content": "<p>In my <code>Huber_pair</code> branch I have a stupid definition of <code>I</code>-adic topology</p>",
        "id": 127817564,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528542992
    },
    {
        "content": "<p>But it doesn't give a uniform_space. So it is pretty useless.</p>",
        "id": 127817566,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528543013
    },
    {
        "content": "<p>This:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">+</span><span class=\"c1\">-- Somehow we need R° both as a subset of R and a subtype.</span>\n<span class=\"bp\">+</span><span class=\"c1\">-- There is a coercion from the set to the subtype but relying naively on it seems to bring</span>\n<span class=\"bp\">+</span><span class=\"c1\">-- type class resolution issues</span>\n<span class=\"bp\">+</span><span class=\"kn\">definition</span> <span class=\"n\">power_bounded_subring</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">//</span> <span class=\"n\">is_power_bounded</span> <span class=\"n\">r</span><span class=\"o\">}</span>\n<span class=\"bp\">+</span><span class=\"kn\">definition</span> <span class=\"n\">power_bounded_subring_set</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">|</span> <span class=\"n\">is_power_bounded</span> <span class=\"n\">r</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>That is exactly the kind of trouble that I have also been having with subrings. I have them both as subset and subtype.</p>",
        "id": 127817720,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528543436
    },
    {
        "content": "<p>Have you tried sticking rigidly to the set notation, and always using coercions and never the subtype. If there's an instance about <code>↥{r : R | is_power_bounded r}</code>, it won't apply it to <code>{r : R // is_power_bounded r}</code></p>",
        "id": 127818859,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528546167
    },
    {
        "content": "<p>What is the advantage of working with subsets instead of subtypes?</p>",
        "id": 127819376,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528547473
    },
    {
        "content": "<p>Aah, <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> , here's a problem: we have <code>topological_space.induced</code> which happily gives you a topology on a subtype. But not—I think—on a subset. So if you want a topological subring, you need the subring as a subtype.</p>",
        "id": 127819469,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528547660
    },
    {
        "content": "<p>The point is don't mix <code>↥{r : R | is_power_bounded r}</code> and <code>{r : R // is_power_bounded r}</code> if you want type class inference to work.</p>",
        "id": 127819478,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528547730
    },
    {
        "content": "<p>And if some of your code requires sets, you have to stick to the former.</p>",
        "id": 127819518,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528547807
    },
    {
        "content": "<p>And if some of it requires subtypes? Then you stick with the latter...</p>",
        "id": 127819525,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528547824
    },
    {
        "content": "<p>But what is an example of \"code [that] requirese sets\"?</p>",
        "id": 127819526,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528547840
    },
    {
        "content": "<p>If it requires subtypes, then you use the coercion from a set and not <code>//</code></p>",
        "id": 127819528,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528547878
    },
    {
        "content": "<p>I am new to all this type theory stuff, and so far I have been thinking of types as \"sets for computer scientists\", and I just treat them as sets. And then all of a sudden there are subsets and subtypes, and I don't see why we smuggle subsets in through the backdoor.</p>",
        "id": 127819568,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528547918
    },
    {
        "content": "<p>Unless you only ever need subtypes. In which case don't use sets.</p>",
        "id": 127819569,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528547930
    },
    {
        "content": "<blockquote>\n<p>If it requires subtypes, then you use the coercion from a set and not <code>//</code></p>\n</blockquote>\n<p>seems to conflict with</p>\n<blockquote>\n<p>The point is don't mix ↥{r : R | is_power_bounded r} and {r : R // is_power_bounded r} if you want type class inference to work.</p>\n</blockquote>",
        "id": 127819574,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528547965
    },
    {
        "content": "<p>No it doesn't. Only use the first one.</p>",
        "id": 127819575,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528547991
    },
    {
        "content": "<p>I tried, and then it couldn't infer a topological space on it.</p>",
        "id": 127819620,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548012
    },
    {
        "content": "<p>Because coercion and type inference don't work together.</p>",
        "id": 127819622,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548039
    },
    {
        "content": "<p>types are not sets; the difference is that values are assigned exactly one type (typing judgments are rigid; although, of course, you can prove that two types are equal and use <code>eq.mp(r)</code> ...), whereas set membership in set theory says nothing about the type of object in the set, which is totally ridiculous imho</p>",
        "id": 127819628,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1528548080
    },
    {
        "content": "<p>Use the coercion for your topological space instance as well?</p>",
        "id": 127819629,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528548083
    },
    {
        "content": "<p>I still haven't seen (here or in other threads where the topic came up) any reason to use subsets. I am just confused, and I would like to know why they are cool.</p>",
        "id": 127819630,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548085
    },
    {
        "content": "<p>i.e. prove <code>↥{r : R | is_power_bounded r}</code> is a topological space not <code>{r : R // is_power_bounded r}</code></p>",
        "id": 127819634,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528548121
    },
    {
        "content": "<blockquote>\n<p>types are not sets; the difference is that values are assigned exactly one type (typing judgments are rigid; although, of course, you can prove that two types are equal and use <code>eq.mp(r)</code> ...), whereas set membership in set theory says nothing about the type of object in the set, which is totally ridiculous imho</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"111651\">@Nicholas Scheel</span> Ok, great, so why do we smuggle set membership back in, if it is so ridiculous?</p>",
        "id": 127819673,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548135
    },
    {
        "content": "<p>the model for a type-theoretic “set” is <code>set a := a -&gt; Prop</code> which is precisely a “set” of elements (of a particular type) satisfying that predicate (conceptually)</p>",
        "id": 127819674,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1528548150
    },
    {
        "content": "<p>Or always stick to subtypes. Subsets are good because they can intersect each other and be subsets of each other.</p>",
        "id": 127819676,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528548168
    },
    {
        "content": "<p>Ok, and subtypes find that hard?</p>",
        "id": 127819677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548181
    },
    {
        "content": "<p>We can define an intersection of subtypes right? Just take <code>\\and</code> of their properties.</p>",
        "id": 127819684,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548206
    },
    {
        "content": "<p>but <code>set</code> just a predicate, it doesn’t contain any elements of the type ... which is what a subtype is for: it contains an element and the proof that it is in the corresponding set, essentially</p>",
        "id": 127819685,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1528548219
    },
    {
        "content": "<p>Because everything only has one type, there's no such thing really as the intersection of two subtypes.</p>",
        "id": 127819687,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528548226
    },
    {
        "content": "<p>the subtypes would need to have the same supertype, otherwise it doesn’t make sense</p>",
        "id": 127819728,
        "sender_full_name": "Nicholas Scheel",
        "timestamp": 1528548298
    },
    {
        "content": "<p>Right, I see.</p>",
        "id": 127819736,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548332
    },
    {
        "content": "<p>But if I have two subtypes of X, say <code>S</code> and <code>T</code>, then I can do <code>subtype (\\lam x, S.property x \\and T.property x)</code>.</p>",
        "id": 127819776,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548410
    },
    {
        "content": "<p>But I understand that this is a clumsy way of doing intersections, and for subsets it is just a lot easier.</p>",
        "id": 127819784,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548465
    },
    {
        "content": "<p>So we need subsets and subtypes.</p>",
        "id": 127819824,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548510
    },
    {
        "content": "<p>And that would be hard to use if you had a proof that <code>∀ x : s, p x</code> and you had <code>x : subtype (\\lam x, S.property x \\and T.property x)</code></p>",
        "id": 127819827,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528548540
    },
    {
        "content": "<p>So, at some point in my code I prove that if the subset <code>S</code> is a subring, then we have an instance of <code>ring S</code>. And I think here <code>S</code> is silently coerced to a subtype, for otherwise <code>ring S</code> doesn't typecheck.</p>",
        "id": 127819834,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548573
    },
    {
        "content": "<p>yes.</p>",
        "id": 127819836,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528548588
    },
    {
        "content": "<p>But then some other code couldn't infer an instance of <code>ring (subtype S)</code>, and I got confused.</p>",
        "id": 127819837,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548600
    },
    {
        "content": "<p>So I also proved explicitly that I had an instance of <code>ring (subtype S)</code> by copy-pasting the other proof verbatim.</p>",
        "id": 127819879,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548633
    },
    {
        "content": "<p>Because it has to be the same expression for type class inference to work. definitional equality isn't good enough I think</p>",
        "id": 127819880,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528548639
    },
    {
        "content": "<p>And then it worked. But now I don't see the point of the silent coercion.</p>",
        "id": 127819881,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548646
    },
    {
        "content": "<p>Which is why it's best to stick to coercions the whole time.</p>",
        "id": 127819889,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528548673
    },
    {
        "content": "<p>I tried, but it didn't work.</p>",
        "id": 127819891,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548694
    },
    {
        "content": "<p>Maybe I didn't try hard enough (-;</p>",
        "id": 127819893,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548708
    },
    {
        "content": "<p>What didn't work?</p>",
        "id": 127819894,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528548713
    },
    {
        "content": "<p>Sticking to coercions. (Or do you mean explicit coercions, instead of silent ones?)</p>",
        "id": 127819935,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548736
    },
    {
        "content": "<p>There both the same. What in particular didn't work?</p>",
        "id": 127819941,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528548797
    },
    {
        "content": "<p>Let me try to find it.</p>",
        "id": 127819982,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548850
    },
    {
        "content": "<p>I think it was these lines: <a href=\"https://github.com/jcommelin/lean-perfectoid-spaces/blob/Huber_pair/src/adic_space.lean#L36-L38\" target=\"_blank\" title=\"https://github.com/jcommelin/lean-perfectoid-spaces/blob/Huber_pair/src/adic_space.lean#L36-L38\">https://github.com/jcommelin/lean-perfectoid-spaces/blob/Huber_pair/src/adic_space.lean#L36-L38</a></p>",
        "id": 127819991,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548914
    },
    {
        "content": "<p>But I don't have Lean here, so I can't test it. Sorry.</p>",
        "id": 127819992,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528548925
    },
    {
        "content": "<p>I couldn't find <code>for_mathlib.subring</code></p>",
        "id": 127820047,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528549062
    },
    {
        "content": "<p>Aah, that is in the <code>subring</code> branch</p>",
        "id": 127820050,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528549078
    },
    {
        "content": "<p>Found it.</p>",
        "id": 127820089,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528549086
    },
    {
        "content": "<p>I thought <code>Huber_pair</code> was a branch of <code>subring</code></p>",
        "id": 127820090,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528549090
    },
    {
        "content": "<p>need to be in branch <code>subring</code></p>",
        "id": 127820091,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528549095
    },
    {
        "content": "<p>Did the <code>is_ideal I</code> not work. Or something else?</p>",
        "id": 127820144,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528549208
    },
    {
        "content": "<p>No, I think it was with subrings and topological spaces</p>",
        "id": 127820152,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528549233
    },
    {
        "content": "<p>Ok, maybe it was both.</p>",
        "id": 127820155,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528549258
    },
    {
        "content": "<p>Because the <code>is_ideal I</code> needed to infer a ring structure <code>ring (subtype S)</code>, and that <code>(subtype S)</code> was explicit because of the topological stuff in those lines.</p>",
        "id": 127820164,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528549306
    },
    {
        "content": "<p>I think this might be the issue <code>instance subtype.comm_ring [comm_ring R] {S : set R} [is_subring S] : comm_ring (subtype S)</code><br>\nshould be <code>instance subtype.comm_ring [comm_ring R] {S : set R} [is_subring S] : comm_ring S</code></p>",
        "id": 127820257,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528549472
    },
    {
        "content": "<p>Worst case scenario if you can't get the coercion to work is to literally do <code>@has_coe_to_sort.coe whatever</code> instead of <code>subtype S</code></p>",
        "id": 127820314,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528549583
    },
    {
        "content": "<p>Ok, thanks! I'll try it out when I get back to lean!</p>",
        "id": 127820321,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528549643
    },
    {
        "content": "<p>I need help with the following annoying lemma:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">swap</span> <span class=\"err\">&#39;&#39;</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">×</span> <span class=\"n\">R</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"bp\">-</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">+</span> <span class=\"bp\">-</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">×</span> <span class=\"n\">R</span> <span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">+</span> <span class=\"bp\">-</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"err\">∈</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</pre></div>",
        "id": 127822057,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528553793
    },
    {
        "content": "<p>part of the problem is I'm not able to use <code>neg_eq_iff_neg_eq</code>, even inside <code>conv</code></p>",
        "id": 127822064,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528553852
    },
    {
        "content": "<p>I'm also stuck on</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">nhd_zero</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sets</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">nhd_zero_symmetric</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">nhd_zero</span> <span class=\"n\">R</span> <span class=\"bp\">→</span>  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">nhd_zero</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">nhd_zero</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"n\">topological_add_group</span><span class=\"bp\">.</span><span class=\"n\">continuous_neg</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">almost</span><span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 127822155,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528554028
    },
    {
        "content": "<p>But this is one is nastier since it involves filters</p>",
        "id": 127822157,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528554043
    },
    {
        "content": "<p>How about this</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">swap</span> <span class=\"err\">&#39;&#39;</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">×</span> <span class=\"n\">R</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"bp\">-</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">+</span> <span class=\"bp\">-</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">×</span> <span class=\"n\">R</span> <span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">+</span> <span class=\"bp\">-</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"err\">∈</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">image_swap_eq_preimage_swap</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"bp\">-</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">r1</span> <span class=\"bp\">-</span> <span class=\"n\">r2</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">r2</span> <span class=\"bp\">-</span> <span class=\"n\">r1</span> <span class=\"err\">∈</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">r1</span> <span class=\"bp\">-</span> <span class=\"n\">r2</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">r2</span> <span class=\"bp\">-</span> <span class=\"n\">r1</span><span class=\"o\">,</span>\n    <span class=\"k\">by</span> <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">neg_eq_iff_neg_eq</span><span class=\"o\">,</span> <span class=\"n\">eq_comm</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">],</span> <span class=\"n\">simp</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 127822393,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528554642
    },
    {
        "content": "<p>For the second one, what you proved is <code>(λ a, -a) ⁻¹' V ∈ nhd_zero R</code>, so then show that <code>(λ a, -a) ⁻¹' V = (λ a, -a) '' V</code> somehow.</p>",
        "id": 127822493,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528554852
    },
    {
        "content": "<p>Thank you very much <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>. <code>change</code> was the key for the first one</p>",
        "id": 127824162,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528558621
    },
    {
        "content": "<p>For the second one I guess I only needed some encouragement ;-)</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">nhd_zero_symmetric</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">nhd_zero</span> <span class=\"n\">A</span> <span class=\"bp\">→</span>  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">nhd_zero</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span> <span class=\"o\">(</span><span class=\"n\">topological_add_group</span><span class=\"bp\">.</span><span class=\"n\">continuous_neg</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">almost</span><span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">aux</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"bp\">-</span><span class=\"n\">r</span> <span class=\"err\">∈</span> <span class=\"n\">V</span> <span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">image</span><span class=\"o\">,</span> <span class=\"n\">neg_eq_iff_neg_eq</span><span class=\"o\">],</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">mem_map</span><span class=\"o\">,</span> <span class=\"n\">aux</span><span class=\"o\">]</span> <span class=\"kn\">using</span> <span class=\"n\">almost</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 127824168,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528558645
    },
    {
        "content": "<blockquote>\n<p>But then some other code couldn't infer an instance of <code>ring (subtype S)</code>, and I got confused.</p>\n</blockquote>\n<p>Johan -- I think the point is that given a subset there are two ways to get a subtype, the explicit and the implicit way, because someone set up a coercion. Because the coercion is set up, you're never supposed to use the explicit constructor, you are completely handing the job over to the type class inference system. So when you use commands like <code>subtype S</code> explictly, instead of that funky up-arrow, this confuses the type class inference system.</p>",
        "id": 127825898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528562395
    },
    {
        "content": "<p>[nonsense deleted]</p>",
        "id": 127825945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528562419
    },
    {
        "content": "<p>A \"subtype\" really does not mean a subset of a type, a subtype is a completely new and different inductive type; if you want to get back to the original type you can use coercion but this is still applying a function, sending a term of the subtype to its value.</p>",
        "id": 127825961,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528562484
    },
    {
        "content": "<p>subtypes are better than subsets because subtypes are types. It's easy to interact with them with the <code>.1</code> and <code>.2</code> notation and the <code>\\&lt;_,_\\&gt;</code> notation</p>",
        "id": 127826005,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528562524
    },
    {
        "content": "<p>Right, but I can imagine that at some point people want to take the intersection of two subrings, are maybe generate a subring, etc... And it seems that sutsets are useful in those cases.</p>",
        "id": 127826074,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528562675
    },
    {
        "content": "<p>Sometimes things come as subsets, for instance power bounded elements</p>",
        "id": 127826907,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528564651
    },
    {
        "content": "<p>I'm doing group_theory at the moment, and it is a little bit awkward proving things about a subgroup that's normal within another subgroup for example, or worse, quotienting by a subgroup within another subgroup. I've been copying the proofs os Sylow's theorem's over from coq, using this paper <a href=\"https://arxiv.org/pdf/cs/0611057.pdf\" target=\"_blank\" title=\"https://arxiv.org/pdf/cs/0611057.pdf\">https://arxiv.org/pdf/cs/0611057.pdf</a>, and most of the group theory in coq seems to be proved on subgroups rather than groups, i.e. they often talk about a subgroup H of a group G, without mentioning anything in G which is not in H.</p>",
        "id": 127826908,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528564659
    },
    {
        "content": "<p>This is the story Assia is always telling us</p>",
        "id": 127826950,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528564721
    },
    {
        "content": "<p>/me feels his inner mathematician shudder and cringe.</p>",
        "id": 127826960,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528564776
    },
    {
        "content": "<p>Somehow this <em>shouldn't</em> be necessary.</p>",
        "id": 127827013,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528564813
    },
    {
        "content": "<p>I agree</p>",
        "id": 127827144,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528565144
    },
    {
        "content": "<p>I'm not sure how much it would help, particularly with the quotienting issue. If you didn't quotient within the subtype, you wouldn't end up with a group, You'd have some type which had a subtype which is a group. It might help avoid notation like <code>subtype.val '' S</code>, which I seem to have to do rather a lot.</p>",
        "id": 127827196,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528565274
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Should <code>is_valuation</code> be a typeclass? It currently is</p>",
        "id": 127827625,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528566169
    },
    {
        "content": "<p>I don't know</p>",
        "id": 127827630,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528566185
    },
    {
        "content": "<p>Me neither</p>",
        "id": 127827728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528566433
    },
    {
        "content": "<p>I'm writing brief LaTeX notes as Patrick suggested</p>",
        "id": 127827731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528566453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I don't understand github well enough to review your PR. I tried to add a comment and got the error <code>Start commit oid is not part of the pull request</code></p>",
        "id": 127828207,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528567528
    },
    {
        "content": "<p>Hmm, I don't know how that happened...</p>",
        "id": 127828252,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528567627
    },
    {
        "content": "<p>I can't make sense of it... all commits in its \"local context\" are either already in your master branch, or in my PR...</p>",
        "id": 127828293,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528567693
    },
    {
        "content": "<p>I can't seem to make comments on your PR.</p>",
        "id": 127828295,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528567714
    },
    {
        "content": "<p>Or at least I can't say the following:</p>",
        "id": 127828296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528567733
    },
    {
        "content": "<p>So I was envisaging that stuff in <code>for_mathlib</code> was stuff which it was our responsibility to try and get into mathlib. But this code looks like it was written by other people -- is it even Ok to put it in our project? And then is our job to try and PR this to mathlib or will the authors take care of that?</p>",
        "id": 127828302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528567754
    },
    {
        "content": "<p>It's attached to the line <code>Authors: Johannes Hölzl, Mitchell Rowett, Scott Morrison</code></p>",
        "id": 127828307,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528567785
    },
    {
        "content": "<p>Right... that's a good point</p>",
        "id": 127828308,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528567794
    },
    {
        "content": "<p>(I hate all those license things)</p>",
        "id": 127828309,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528567801
    },
    {
        "content": "<p>Anyway, all I did was take their code and translate from multiplicative notation to additive...</p>",
        "id": 127828356,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528567823
    },
    {
        "content": "<p>I don't know what is appropriate in this case</p>",
        "id": 127828358,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528567842
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> What do you think of this subring code?</p>",
        "id": 127828453,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528568084
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">+</span><span class=\"c\">/-</span><span class=\"cm\">- `S` is a subring: a set containing 1 and closed under multiplication, addition and and additive inverse. -/</span>\n<span class=\"bp\">+</span><span class=\"n\">class</span> <span class=\"n\">is_subring</span>  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">is_add_subgroup</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">is_submonoid</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"bp\">.</span>\n<span class=\"bp\">+</span>\n<span class=\"bp\">+</span><span class=\"kn\">instance</span> <span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">ring</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">is_subring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"bp\">+</span><span class=\"o\">{</span> <span class=\"n\">add_comm</span>      <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">add_comm</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"bp\">+</span>  <span class=\"n\">left_distrib</span>  <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">left_distrib</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"bp\">+</span>  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">right_distrib</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"bp\">+</span>  <span class=\"bp\">..</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">add_group</span><span class=\"o\">,</span>\n<span class=\"bp\">+</span>  <span class=\"bp\">..</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">monoid</span> <span class=\"o\">}</span>\n<span class=\"bp\">+</span>\n<span class=\"bp\">+</span><span class=\"kn\">instance</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ring</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">is_subring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">subtype</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">+</span><span class=\"o\">{</span> <span class=\"n\">add_comm</span>      <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">add_comm</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"bp\">+</span>  <span class=\"n\">left_distrib</span>  <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">left_distrib</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"bp\">+</span>  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">right_distrib</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"bp\">+</span>  <span class=\"bp\">..</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">add_group</span><span class=\"o\">,</span>\n<span class=\"bp\">+</span>  <span class=\"bp\">..</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">monoid</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 127828455,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528568088
    },
    {
        "content": "<p>We will be playing with several subrings of a given Huber ring so we will surely need some way to formalise the idea of <code>is_subring</code>.</p>",
        "id": 127828466,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528568151
    },
    {
        "content": "<p>Why use both <code>ring S</code> and <code>ring (subtype S)</code> ?</p>",
        "id": 127828507,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528568186
    },
    {
        "content": "<p>But should we just avoid subsets completely? Or is it hard to say without context?</p>",
        "id": 127828508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528568195
    },
    {
        "content": "<p>Chris I am just cutting and pasting what Johan wrote. I don't know what is best. My understanding is that you're saying <code>ring (subtype S)</code> is unnecessary</p>",
        "id": 127828514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528568225
    },
    {
        "content": "<p>I think so.</p>",
        "id": 127828515,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528568238
    },
    {
        "content": "<p>and we should use typeclass inference at all times</p>",
        "id": 127828516,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528568241
    },
    {
        "content": "<p>but what I am unclear about is if we should be using sets at all</p>",
        "id": 127828519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528568250
    },
    {
        "content": "<p>Whenever possible it's better to. I think you have to use sets. <code>is_subring</code> has to be defined on a predicate anyway. How would you define it on a subtype?</p>",
        "id": 127828565,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528568320
    },
    {
        "content": "<p>I see your point!</p>",
        "id": 127828570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528568358
    },
    {
        "content": "<p>The reason that both versions are there is simply that stuff doesn't typecheck without the <code>(subtype S)</code> version. Which is probably due to \"mistakes\" I made in other parts of the code.</p>",
        "id": 127828624,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528568501
    },
    {
        "content": "<p>I would love to get rid of it, because it looks \"unmathematical\"</p>",
        "id": 127828629,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528568519
    },
    {
        "content": "<p>and <code>x \\in S</code> is more natural than <code>S x</code> so it may as well be a set. Going between sets and subtypes isn't the hard part, it's when you have to deal with subtypes of subtypes, and then the same set but as a subtype.</p>",
        "id": 127828630,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528568520
    },
    {
        "content": "<p>So what exactly breaks when you remove the subtype version?</p>",
        "id": 127828726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528568755
    },
    {
        "content": "<p>I think some code in my <code>Huber_pair</code> branch. The topology on <code>S</code> is the induced topology, via <code>subtype.val</code>. And this turns <code>S</code> into <code>subtype S</code>. But then you also want a ring structure on it...</p>",
        "id": 127828772,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528568858
    },
    {
        "content": "<p>Kevin, I will get back to the PR on monday morning I guess...</p>",
        "id": 127828974,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528569246
    },
    {
        "content": "<p>Yeah, let's figure out how it all works</p>",
        "id": 127828975,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528569259
    },
    {
        "content": "<p>this PR business</p>",
        "id": 127828977,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528569263
    },
    {
        "content": "<p>there's no hurry</p>",
        "id": 127828978,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528569270
    },
    {
        "content": "<p>Ok, let's do that.</p>",
        "id": 127829131,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528569682
    },
    {
        "content": "<p>(Oh and by the way, you can <code>git rm *.aux</code> etc in the LaTeX folder, to get rid of those files that you don't actually want to track.)</p>",
        "id": 127829173,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528569730
    },
    {
        "content": "<p>And put them in <code>.gitignore</code> file: at root of project, a file containing lines like <code>*.aux</code>, <code>*.dvi</code> (dvi?!)</p>",
        "id": 127831710,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528575193
    },
    {
        "content": "<p>I'm the king of filters! <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/5\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/5\">https://github.com/kbuzzard/lean-perfectoid-spaces/pull/5</a></p>",
        "id": 127834784,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528582272
    },
    {
        "content": "<blockquote>\n<p>What do you think of this subring code?</p>\n</blockquote>\n<p>It's fine, except that the two instances are defeq so you need not prove it twice</p>",
        "id": 127850654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528620887
    },
    {
        "content": "<blockquote>\n<p>(Oh and by the way, you can <code>git rm *.aux</code> etc in the LaTeX folder, to get rid of those files that you don't actually want to track.)</p>\n</blockquote>\n<p>Sure, but every time the file is updated they come back, right?</p>",
        "id": 127852926,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528626482
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>What do you think of this subring code?</p>\n</blockquote>\n<p>It's fine, except that the two instances are defeq so you need not prove it twice</p>\n</blockquote>\n<p>Johan -- defeq is not the same as equal (for example rw won't make some random change from a thing to a defeq thing before rewriting), so Mario is not saying \"your code is bound to still work if you remove the second instance\", but my impression is that we should kill that last instance and then try and understand how to correctly work around the problems that this causes. The type class inference system is not something you can just add to -- my understanding is that careful thought needs to go into it. The moment there is more than one route from A to B, or a non-trivial way of getting from A to A, there's a risk that there will be problems down the line (time-outs, obscure errors).</p>",
        "id": 127853064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528626777
    },
    {
        "content": "<p>That's not quite what I'm saying. You should have both instances, but you can prove one by just referencing the other</p>",
        "id": 127853257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528627313
    },
    {
        "content": "<p>This whole type class inference thing is still a mystery to me in places.</p>",
        "id": 127853394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528627658
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>(Oh and by the way, you can <code>git rm *.aux</code> etc in the LaTeX folder, to get rid of those files that you don't actually want to track.)</p>\n</blockquote>\n<p>Sure, but every time the file is updated they come back, right?</p>\n</blockquote>\n<p><code>git</code> will never track a file without being explicitly instructed to do so. You could issue this instruction by mistake, using a careless <code>git add *</code>. This is where <code>.gitignore</code> comes in. In a file matches a pattern listed in <code>.gitignore</code> you need a <code>git add -f file_name</code> to add it. This way you can safely add <code>*.pdf</code> in <code>.gitignore</code> but still put, say Wedhorn's lecture notes, in the repository if you want to. Adding compiled versions of the TeX files present in the repository is pointless.</p>",
        "id": 127855360,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528632103
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Does</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">toplogical_ring</span><span class=\"bp\">.</span><span class=\"n\">to_uniform_space</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">R</span>\n</pre></div>\n\n\n<p>use the ring structure?</p>",
        "id": 127886064,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528700258
    },
    {
        "content": "<p>Cool PR by the way! I added some comments.</p>",
        "id": 127886304,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528700680
    },
    {
        "content": "<p>No, it should be about topological groups. I PR'ed this quickly to make sure no work is duplicated (we should maybe declare somewhere on what part we intend to work), but really it should go to the <code>for_mathlib</code> directory, and be stated for topological groups (maybe even non abelian). <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> did you intend to build this instance (canonical uniform structure on commutative topological groups) at some point?</p>",
        "id": 127886319,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528700713
    },
    {
        "content": "<p>Yes, it would be nice to know who is working on what.</p>",
        "id": 127886536,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528701204
    },
    {
        "content": "<p>But I think we have done most low-hanging fruit</p>",
        "id": 127886537,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528701226
    },
    {
        "content": "<p>Sure</p>",
        "id": 127886651,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528701442
    },
    {
        "content": "<p>Isn't it all low-hanging fruit? ;-)</p>",
        "id": 127904303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528730321
    },
    {
        "content": "<p>I guess someone needs to think about completions at some point. Perhaps we need some more issues, perhaps of a smaller nature.</p>",
        "id": 127904307,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528730336
    },
    {
        "content": "<blockquote>\n<p>Isn't it all low-hanging fruit? ;-)</p>\n</blockquote>\n<p>Well, I think that <code>Spa</code> will be non-trivial (Leanwise).</p>",
        "id": 127908740,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528736570
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Will stuff like the following line mess up the type class system?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">toplogical_ring</span><span class=\"bp\">.</span><span class=\"n\">to_uniform_space</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">stuff_goes_here</span>\n</pre></div>",
        "id": 127909048,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528737017
    },
    {
        "content": "<p>I don't see any obvious reason for this to cause a problem</p>",
        "id": 127909061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528737051
    },
    {
        "content": "<p>Ok, I thought you would get a non-trivial route <code>topological_ring → uniform_space → topological_space</code>.</p>",
        "id": 127909091,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528737090
    },
    {
        "content": "<p>oh, well that's true, I suppose you need to make sure that this is defeq to the other path to topological space</p>",
        "id": 127909150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528737137
    },
    {
        "content": "<p>A uniform space extends a topological space, so you just need to let the topological component be the one inherited from <code>topological_ring</code></p>",
        "id": 127909168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528737194
    },
    {
        "content": "<p>that means that you can't use the default proof of <code>is_open_uniformity</code></p>",
        "id": 127909171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528737211
    },
    {
        "content": "<p>This might create some trouble...</p>",
        "id": 127909634,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528737813
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Does this suggest that in fact <code>topological_ring</code> should extend <code>ring</code> and <code>uniform_space</code>. And have constructor from ring + top_space ?</p>",
        "id": 127909696,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528737882
    },
    {
        "content": "<p>(In fact, this is more about topological groups... the ring structure is not relevant.)</p>",
        "id": 127909701,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528737903
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> we are talking about <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/top_rings/src/adic_space.lean#L60\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/top_rings/src/adic_space.lean#L60\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/top_rings/src/adic_space.lean#L60</a> It uses <a href=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/uniform_space.lean#L117\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/uniform_space.lean#L117\">uniform_space.of_core</a> I'm not sure about things that should be defeq are defeq</p>",
        "id": 127914420,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528743692
    },
    {
        "content": "<p>I'll try to ask Lean</p>",
        "id": 127914468,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528743724
    },
    {
        "content": "<p>It doesn't want to answer, which is probably not good. I tries</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">toplogical_ring</span><span class=\"bp\">.</span><span class=\"n\">to_uniform_space</span> <span class=\"n\">R</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span>  <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</pre></div>\n\n\n<p>but Lean says <code>tactic failed, type mismatch</code> on the opening parenthesis on RHS. Checking the type of LHS and RHS looks good, even with pp.all</p>",
        "id": 127915787,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528745311
    },
    {
        "content": "<p>Ah yes, you shouldn't use <code>uniform_space.of_core</code>, that generates the uniformity topology but you want to pick up the default topology on a topological ring</p>",
        "id": 127930196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528768368
    },
    {
        "content": "<blockquote>\n<p>No, it should be about topological groups. I PR'ed this quickly to make sure no work is duplicated (we should maybe declare somewhere on what part we intend to work), but really it should go to the <code>for_mathlib</code> directory, and be stated for topological groups (maybe even non abelian). <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> did you intend to build this instance (canonical uniform structure on commutative topological groups) at some point?</p>\n</blockquote>\n<p>Yes, I would like to see uniform spaces derived from topological groups.</p>",
        "id": 127931824,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1528771904
    },
    {
        "content": "<p>Right, but picking up the existing topology is going to be pretty hard, I guess.</p>",
        "id": 127939941,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528787422
    },
    {
        "content": "<p>Noob question: if we have a situation like this in the type class system, or more generally... to paths $$f$ and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span></span></span></span> to go from <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, and they are not defeq, but there is a proof that they are equal. Would parametricity help out? Or is it an idle hope to envision some synergy between this lambda-Prolog unification and parametricity?</p>",
        "id": 127940012,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528787622
    },
    {
        "content": "<p>(I still don't know if parametricity is the promising silver bullet that I want it to be. If it is, then I think I ought to spend most of my time in bringing it to Lean... but I fear that it doesn't actually help that much in doing maths.)</p>",
        "id": 127940054,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528787681
    },
    {
        "content": "<p>well, that would require a lot more brains on the part of the type class inference system</p>",
        "id": 127940207,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528787944
    },
    {
        "content": "<p>/me loves type class inference systems with brains <span class=\"emoji emoji-1f393\" title=\"graduation cap\">:graduation_cap:</span></p>",
        "id": 127940273,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528788008
    },
    {
        "content": "<p>while I personally haven't encountered it, Leo is already worried about the performance of the type class inference system</p>",
        "id": 127940278,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528788057
    },
    {
        "content": "<p>so I don't think it's a practical thing to hope for in the future</p>",
        "id": 127940284,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528788069
    },
    {
        "content": "<p>the more you ask a tactic to do, the slower it runs...</p>",
        "id": 127940288,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528788083
    },
    {
        "content": "<p>i wonder if anyone here is interested in old-style chess engines</p>",
        "id": 127940345,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528788175
    },
    {
        "content": "<p>Hmmm too bad. And Kudos to human brains...</p>",
        "id": 127940353,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528788204
    },
    {
        "content": "<p>type class inference works like that, it searches all the possible ways to get from A to B</p>",
        "id": 127940354,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528788206
    },
    {
        "content": "<p>the number of possible paths grows exponentially</p>",
        "id": 127940355,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528788224
    },
    {
        "content": "<p>with each step</p>",
        "id": 127940356,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528788227
    },
    {
        "content": "<p>Yes, how would the old-style Chess engines help? (I never studied them.)</p>",
        "id": 127940357,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528788228
    },
    {
        "content": "<p>they don't help, it's a comment on how hard the problem is</p>",
        "id": 127940399,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528788283
    },
    {
        "content": "<p>type class inference is something that must be done in a sane amount of time, or users of Lean will get really frustrated when their proof takes ages to type-check</p>",
        "id": 127940420,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528788346
    },
    {
        "content": "<p>Would new-style chess engines help? I wonder if we are willing to give up \"determinism\" to win a lot of speed.</p>",
        "id": 127940462,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528788394
    },
    {
        "content": "<p>no, because if lean manages to synthesize a proof at 2 pm and then doesn't at 4pm, you've got a problem</p>",
        "id": 127940472,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528788435
    },
    {
        "content": "<p>I mean, maybe you can find some way to cache the proof, but.... this is very out there</p>",
        "id": 127940522,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1528788486
    },
    {
        "content": "<p>Right. I would think that maybe Lean could output some hints that will help it to verify the proof deterministically and fast the next time round.</p>",
        "id": 127940530,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528788524
    },
    {
        "content": "<p>There's also no need to give up determinism merely because you have good heuristics for searching the \"interesting\" parts of the tree first.</p>",
        "id": 127940543,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528788554
    },
    {
        "content": "<p>Hmm, true</p>",
        "id": 127940546,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528788570
    },
    {
        "content": "<p>But, do you know of good heuristics?</p>",
        "id": 127940554,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528788586
    },
    {
        "content": "<p>I really need to explore uses of my <code>rewrite_search</code> tactic outside of category theory. It attempts to prove <code>A = B</code> by exploring the graph of all possible rewrites by a given set of lemmas, but targets the search by exploring the parts of the graph with least \"edit distance\" between the LHS and the RHS, for various interpretations of \"edit distance\".</p>",
        "id": 127940618,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528788645
    },
    {
        "content": "<p>Sounds promising.</p>",
        "id": 127940678,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528788761
    },
    {
        "content": "<p>Can't wait to have such stuff available at my fingertips (-;</p>",
        "id": 127940687,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528788795
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Do you understand the consequences of all this for the perfectoid project?</p>",
        "id": 127940850,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528789175
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> What do you mean? The consequences of Scott's tactics, or the consequences of this topological diamond?</p>",
        "id": 127940967,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528789381
    },
    {
        "content": "<p>Now that I think of it, we can probably remove the diamond by just not making it an instance. That means we can write nice stuff like <code>is_complete R</code> but we can still write <code>is_complete (to_uniform R)</code>.</p>",
        "id": 127941012,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528789451
    },
    {
        "content": "<p>I just mean whether you now know the answer to the question \"will stuff like [instance top_ring_to_uniform_space] mess up the type class system?\"</p>",
        "id": 127941017,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528789471
    },
    {
        "content": "<p>And then, when those with more Lean-fu then the mortal mathematicians have some time,  they can fix the diamond issue, and we can write nice code again.</p>",
        "id": 127941020,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528789496
    },
    {
        "content": "<p>I mean that I have not really been following the details of this typeclass discussion and am wondering if you now know enough to tell me how to set up the perfectoid project.</p>",
        "id": 127941026,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528789529
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> can join in. But my suggestion would be to have an explicit map from top_rings to uniform_spaces, and just use it explicitly when needed. (Because I think we don't need it that often.)</p>",
        "id": 127941071,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528789593
    },
    {
        "content": "<p>I should note that when I started writing schemes I didn't use type class inference for anything (I had lots of rings and didn't use it for them). You don't have to use it. It's just supposed to make things easier. If it doesn't make them easier then we can probably avoid it. If we convince ourselves that it's not robust enough then we can avoid it. Is there some sort of underlying unfixable problem with modules?</p>",
        "id": 127941129,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528789693
    },
    {
        "content": "<p>We don't need modules for this project, right?</p>",
        "id": 127941192,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528789816
    },
    {
        "content": "<p>Modules seem to be rather easy to agitate in Lean. I think we could write <code>module'</code> that avoids the type class system, but it would duplicate a lot of effort; and ultimately it is not the path we want to take.</p>",
        "id": 127941201,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528789911
    },
    {
        "content": "<p>But in the current situation it seems to me that modules are almost unusable.</p>",
        "id": 127941240,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528789936
    },
    {
        "content": "<p>In that Gitter link, Mario said that the ring shouldn't be a field in the <code>module</code> structure. But I don't really understand why not. I think it would solve a lot of problems, and I don't really see what kind of problems it creates.</p>",
        "id": 127941312,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528790149
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> If you have time, could you say a few words about why the ring shouldn't be a field of the <code>module</code> structure?</p>",
        "id": 127941414,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528790327
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">poly</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">map_range</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">is_ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_zero</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 127941683,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528790833
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> Should this map be noncomputable, or should we try to make it computable by making extra assumptions on <code>R</code> and/or <code>S</code> and then over-riding them later?</p>",
        "id": 127941723,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528790884
    },
    {
        "content": "<p>I think it is fine to have this in <code>for_mathlib</code>, but it should go into the mason_stothers lib at some point.</p>",
        "id": 127941728,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528790922
    },
    {
        "content": "<p>err... it should go in mathlib!</p>",
        "id": 127941732,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528790941
    },
    {
        "content": "<p>Yes, by transitivity</p>",
        "id": 127941737,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528790951
    },
    {
        "content": "<p>And then in mason_stothers they can make it as computable as they want <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>",
        "id": 127941775,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528791003
    },
    {
        "content": "<blockquote>\n<p>Right, but picking up the existing topology is going to be pretty hard, I guess.</p>\n</blockquote>\n<p>It is not difficult to set this up with the current setup. You should just not use <code>uniform_space.to_core</code>, just construct the uniform space using the constructor</p>",
        "id": 127944104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528795243
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> Should this map be noncomputable, or should we try to make it computable by making extra assumptions on <code>R</code> and/or <code>S</code> and then over-riding them later?</p>\n</blockquote>\n<p>this should be computable now, in the recent mathlib versions, <code>finsupp.map_range</code> is computable</p>",
        "id": 127944105,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1528795246
    },
    {
        "content": "<blockquote>\n<p>If you have time, could you say a few words about why the ring shouldn't be a field of the module structure?</p>\n</blockquote>\n<p>At least with the current setup, it is generally not a good idea to have types as fields in the structure. If you did this with the scalar ring of module, you wouldn't be able to talk about ℝ-modules without imposing an equality condition, which would cause cast headaches</p>",
        "id": 127944182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528795421
    },
    {
        "content": "<p>Hmm, do you mean that all of a sudden you have 1 type for <em>all</em> modules? So, if you would have fields <code>(R : Type) (hR : ring R)</code> in the structure, then you want to define <code>is_linear_map [module M] [module N] (M -&gt; N) : Prop</code>, but now they might be modules over different rings!</p>",
        "id": 127944318,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528795652
    },
    {
        "content": "<p>Or do you mean something more subtle?</p>",
        "id": 127944319,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528795661
    },
    {
        "content": "<p>If you have rings <code>A</code> and <code>B</code> and a ring map <code>A -&gt; B</code>, and an <code>A</code>-module <code>M</code> and a <code>B</code>-module <code>N</code> then mathematicians would quite happily talk about <code>A</code>-module homomorphisms <code>M -&gt; N</code></p>",
        "id": 127945989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528797554
    },
    {
        "content": "<p>because <code>N</code> inherits an <code>A</code>-module structure from the map <code>A-&gt;B</code></p>",
        "id": 127945991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528797575
    },
    {
        "content": "<p>but as Johan points out, this discussion is, at least at this point, in the wrong thread, this is Patrick's type class woes</p>",
        "id": 127946051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528797610
    },
    {
        "content": "<p>Right, so returning to perfectoid spaces... what is the next step?</p>",
        "id": 127946876,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528799177
    },
    {
        "content": "<p>Should we pull stuff on presheaves in from your schemes-repo?</p>",
        "id": 127946880,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528799192
    },
    {
        "content": "<p>The next step is for me to accept these PRs and then have a look at what is left.</p>",
        "id": 127951650,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807518
    },
    {
        "content": "<p>I think I want to do presheaves because I did them before</p>",
        "id": 127951658,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807527
    },
    {
        "content": "<p>I think the next step is the topological space Spa(A)</p>",
        "id": 127951663,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807536
    },
    {
        "content": "<p>for A a Huber pair</p>",
        "id": 127951665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807540
    },
    {
        "content": "<p>and that goes via Spv(R)</p>",
        "id": 127951668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528807549
    },
    {
        "content": "<blockquote>\n<p>It is not difficult to set this up with the current setup. You should just not use <code>uniform_space.to_core</code>, just construct the uniform space using the constructor</p>\n</blockquote>\n<p>What do you call \"the constructor\"? I'm not worried at all, I'm pretty sure I have the mathematical content right, and I used the filter library so we will have all lemmas we need. But I'm not quite sure what I should do (And I had no time at all since Saturday, because of a conference and invited people).</p>",
        "id": 128030961,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1528925188
    },
    {
        "content": "<p>I mean the default, built in constructor for a structure, the thing that you get with <code>{ x := ... }</code> notation</p>",
        "id": 128034520,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528930736
    },
    {
        "content": "<p>I guess the constant is called <code>uniform_space.mk</code></p>",
        "id": 128034532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528930764
    },
    {
        "content": "<p>If you just delete the <code>of_core</code> function application in the instance, and just use that structure directly as the instance, it will more or less work, except there will be a new proof obligation for the part of the proof that <code>of_core</code> was doing</p>",
        "id": 128034688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528931035
    },
    {
        "content": "<p>I've spent the last few days doing non-Lean stuff but I would like to accept these PRs soon; I read through them all properly today. One thing that occurred to me about this uniform space business is that Patrick's construction of a uniform space on a topological ring should (a) probably work for a topological group and (b) might already be in mathlib (if the docstring for <code>uniform_space</code> is anything to go by). <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> you wrote \"A topological group also has a natural uniformity, even when it is not metrizable\" in the docstring for uniform space -- is this theorem somewhere in mathlib?</p>",
        "id": 128382738,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529527807
    },
    {
        "content": "<p>This is in the pipeline last I checked. it should appear soonish</p>",
        "id": 128382990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529528114
    },
    {
        "content": "<p>I think Johannes is working on merging Patrick's normed space stuff</p>",
        "id": 128383004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529528139
    },
    {
        "content": "<p>Thanks. I've not been at all Lean-active for the last week or so, and today I tried to catch up with perfectoid spaces but there's a whole bunch of stuff which should be in mathlib but isn't; I could open about 8 small PRs but I didn't want to add to the pile because I can happily store them in my project. However stuff like polynomials in 1 variable, which is lengthy, presents more of a problem because mason-stother doesn't compile at the minute. Patrick has explicitly proved that a topological ring has a uniform space structure and it wouldn't surprise me if his proof worked for topological groups. So we have something if you or Johannes want it. For the schemes project I just kept bundling everything in my repo but this time I'd rather do it more sensibly.</p>",
        "id": 128383352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529528574
    },
    {
        "content": "<p>I'm not sure how useful this will be given that Johannes is working on this stuff at the moment - it may just be additional merging overhead. You should coordinate with him</p>",
        "id": 128383430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529528673
    },
    {
        "content": "<p>OK thanks for the tips.</p>",
        "id": 128383472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529528751
    },
    {
        "content": "<p>I'm sorry I haven't talk at all since last saturday. I'm attending a conference and have extremely bad internet access in my hotel (only my phone is able to use the wifi, at very slow speed). I have completely rewritten my uniform structure stuff, and I hope to PR it tomorrow from the lecture hall. It now provides a uniform structure on commutative topological groups which gives back a topology defeq to the original one. I'm very grateful for Johannes work but it seems both over-engineered and nit enough. I have no idea what kind of generalization he has in mind.</p>",
        "id": 128385520,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1529531083
    },
    {
        "content": "<p>Polynomials in 1 variable I'd really like to see in mathlib; so even if Kevin can \"happily store them in my project\", let's try to accumulate as little as possible in the perfectoid repository.</p>",
        "id": 128385715,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529531339
    },
    {
        "content": "<blockquote>\n<p>Polynomials in 1 variable I'd really like to see in mathlib; so even if Kevin can \"happily store them in my project\", let's try to accumulate as little as possible in the perfectoid repository.</p>\n</blockquote>\n<p>Currently we're unhappy when it comes to polynomials. We tried using Johannes' mason-stother but not all of it compiles. Currently we're sorrying stuff.</p>",
        "id": 128387586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529534182
    },
    {
        "content": "<p>I proved its UMP :P although Chris did much more than me</p>",
        "id": 128387592,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529534207
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">UMP</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">A</span> <span class=\"err\">≃</span> <span class=\"n\">alg_hom</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"bp\">ℕ.</span><span class=\"n\">UMP</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">monoid_ring</span><span class=\"bp\">.</span><span class=\"n\">UMP</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 128387602,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529534225
    },
    {
        "content": "<p><a href=\"https://github.com/kckennylau/local-langlands-abelian/blob/master/src/polynomial.lean#L37\" target=\"_blank\" title=\"https://github.com/kckennylau/local-langlands-abelian/blob/master/src/polynomial.lean#L37\">https://github.com/kckennylau/local-langlands-abelian/blob/master/src/polynomial.lean#L37</a></p>",
        "id": 128387603,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529534228
    },
    {
        "content": "<p>o_O there is group cohomology, Galois theory, and local class field theory in that repo too!</p>",
        "id": 128387688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529534377
    },
    {
        "content": "<p>You have been busy.</p>",
        "id": 128387692,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529534382
    },
    {
        "content": "<p>well I can’t talk too much ‘bout it now :p</p>",
        "id": 128387745,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529534459
    },
    {
        "content": "<p>we both know the reason</p>",
        "id": 128387750,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529534464
    },
    {
        "content": "<p>I shall be grilling you on it in about 36 hours.</p>",
        "id": 128387762,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529534518
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  the situation with uniform structures is now as follows. Contrary to what the docstrings you mentioned suggests, mathlib currently doesn't know that a commutative topological group has a canonical uniform structure. What <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> did recently was to write <a href=\"https://gist.github.com/johoelzl/ca90562c46b49a1bbb1be36272ec3b1a\" target=\"_blank\" title=\"https://gist.github.com/johoelzl/ca90562c46b49a1bbb1be36272ec3b1a\">https://gist.github.com/johoelzl/ca90562c46b49a1bbb1be36272ec3b1a</a> At the same time I decided to use my flight to learn a bit about filters instead of complaining I'm not used to them. Then I wrote <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/top_rings/src/for_mathlib/topological_structures.lean\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/top_rings/src/for_mathlib/topological_structures.lean\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/top_rings/src/for_mathlib/topological_structures.lean</a>. What are the differences then? The obvious one is that Johannes' code is shorter and most probably cleaner. But it also doesn't address the main question. He defines a class <code>group_with_nhds_zero</code> which seems to be a generalization of topological groups, remembering just enough about properties of neighborhoods of zero in a topological group to define the uniform structure. He doesn't prove topological groups give instances of this new class but this should be easy (one would need to be careful with the topology induced by the uniform structure to be defeq to the original one, which is what I messed up in my first attempt). My concern is over-engineering: I see no use of this new class beyond topological group. AFAIK this only adds a layer of complexity. Actually I was already completely puzzled by <a href=\"https://github.com/leanprover/mathlib/blob/905345a2ceaa5d0c7bc2f6310026961416b2cae4/analysis/topology/topological_structures.lean#L198\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/905345a2ceaa5d0c7bc2f6310026961416b2cae4/analysis/topology/topological_structures.lean#L198\">this section</a>. I have no idea how this could be useful beyond the obvious case where the uniform structure is the canonical one.</p>",
        "id": 128411780,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1529578275
    },
    {
        "content": "<p>I don't think these CS people worry about over-engineering. I guess as we just saw from the filter stuff, it's actually sometimes convenient to have these things around. I've written a paper about adic spaces and I don't understand filters, but that's only because for actual adic spaces you only basically deal with rings whose topology is generated by a finitely-generated ideal, when sanity is restored. [by \"generated by\" I mean that powers of the ideal form a basis of neighbourhoods of zero]</p>",
        "id": 128431953,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529605579
    },
    {
        "content": "<p>Oh wow I have universe issues! </p>\n<p>A valuation on a ring <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a map from <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> to a totally ordered commutative monoid satisfying some axioms. Two valuations <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02691em;\">w</span></span></span></span> are <em>equivalent</em> if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi><mo>(</mo><mi>r</mi><mo>)</mo><mo>≤</mo><mi>v</mi><mo>(</mo><mi>s</mi><mo>)</mo><mspace width=\"0.277778em\"></mspace><mo>⟺</mo><mspace width=\"0.277778em\"></mspace><mi>w</mi><mo>(</mo><mi>r</mi><mo>)</mo><mo>≤</mo><mi>w</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">v(r)\\leq v(s) \\iff w(r)\\leq w(s)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mrel\">≤</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathit\">s</span><span class=\"mclose\">)</span><span class=\"mrel\"><span class=\"mspace thickspace\"></span><span class=\"mrel\">⟺</span></span><span class=\"mord mathit\"><span class=\"mspace thickspace\"></span><span class=\"mord mathit\" style=\"margin-right:0.02691em;\">w</span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mrel\">≤</span><span class=\"mord mathit\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathit\">s</span><span class=\"mclose\">)</span></span></span></span>. The <em>valuation spectrum</em> <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mi>p</mi><mi>v</mi><mo>(</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">Spv(R)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathit\">p</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is the set of equivalence classes of valuations.   As a ZFC-ist I did a little calculation here -- I checked that every valuation (which could take values in a monoid which gigantic cardinality, far far bigger than that of R) was equivalent to a valuation taking values in basically the monoid generated by the image of R (I'm being a bit sloppy -- one has to check that there is no issue here with the axioms for a valuation). But at the end of the day I have a set.</p>\n<p>In Lean I have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">valuations</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">Hα</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Hf</span> <span class=\"o\">:</span> <span class=\"n\">is_valuation</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>and I can define two valuations to be equivalent </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">valuations</span><span class=\"bp\">.</span><span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">valuations</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">g</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</pre></div>\n\n\n<p>but the associated quotient has type <code>Type 1</code>, so in theory I have left the world of ZFC. As I just outlined above, in ZFC I know how to claw my way back [I can put an upper bound on the cardinality of alpha and hence build a <em>set</em> containing at least one instance of every equivalence class]. Can I do this in Lean somehow?</p>\n<div class=\"codehilite\"><pre><span></span>\n</pre></div>",
        "id": 128437221,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529612029
    },
    {
        "content": "<p>If you don't care about computational content (I hear you Kenny, keep it down), you can notice that a valuation equivalence class is determined by the relation <code>S : R -&gt;  R -&gt; Prop</code> defined by <code>S r s &lt;-&gt; v r &lt;= v s</code>. That is, two valuations are equivalent if and only if they have equal induced relations on R. Thus you can define the spectrum to be the collection of all relations that arise from some valuation (from a commutative monoid in the same universe as R).</p>",
        "id": 128438592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529613713
    },
    {
        "content": "<p>This is a good example of the kind of situation I was asking about here -- <a href=\"#narrow/stream/113488-general/subject/type.20resizing/near/127424550\" title=\"#narrow/stream/113488-general/subject/type.20resizing/near/127424550\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/subject/type.20resizing/near/127424550</a></p>",
        "id": 128440055,
        "sender_full_name": "Reid Barton",
        "timestamp": 1529615414
    },
    {
        "content": "<p>The answer is ad hoc. Essentially you figure out the \"reason\" why your set is small, which will take the form of some small set that enumerates your large objects, and use that as the index instead</p>",
        "id": 128441152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529616823
    },
    {
        "content": "<p>The \"reason\" for me was a standard ZFC-ish one: one can \"shrink\" the target until it's generated by the image of R, and hence has the same cardinality of R (or aleph_null if R is finite). So we get a bound on the cardinality of the target and this suffices because the set of isomorphism classes is now a set. The relation argument is alien to me, although obviously I believe it. I am torn about whether I should care about this -- should I write my own \"section 4\" or just forget it? Interestingly, I notice that the foundational paper <a href=\"https://arxiv.org/abs/math/0409584\" target=\"_blank\" title=\"https://arxiv.org/abs/math/0409584\">https://arxiv.org/abs/math/0409584</a> (section 1 page 7) which is strongly related to the foundations of what Scholze is doing, assumes that every set is contained in a universe. This paper would be really nice to formalise! Although those that look at it will quickly see what the issue is...</p>",
        "id": 128445451,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529623276
    },
    {
        "content": "<p>There is nothing wrong with your argument, and indeed you can also use it to get a bound as well. The relation argument just seemed easier since it literally defines the equivalence relation, making the quotient trivial. Actually you would probably want to run that argument anyway to prove that given a valuation in any universe you get a relation, since this amounts to constructing an equivalent valuation in the same universe as the ring.</p>",
        "id": 128448999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529630027
    },
    {
        "content": "<p>So I finally followed up on this. Here's what the code looks like (I removed the actual definition of valuation to simplify things):</p>",
        "id": 128551939,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529834090
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_valuation</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">valuations</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Hα</span> <span class=\"o\">:</span> <span class=\"n\">linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Hf</span> <span class=\"o\">:</span> <span class=\"n\">is_valuation</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">to_make_next_line_work</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuations</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">linear_order</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">Hα</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">valuations</span><span class=\"bp\">.</span><span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">valuations</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">valuations</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">H</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,(</span><span class=\"n\">H</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span><span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">x</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H2</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n<span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Spv1</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">valuations</span><span class=\"bp\">.</span><span class=\"n\">setoid</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Spv2</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuations</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">Spv1</span> <span class=\"bp\">_</span> <span class=\"c1\">-- Type 1</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">Spv2</span> <span class=\"bp\">_</span> <span class=\"c1\">-- Type</span>\n</pre></div>",
        "id": 128551947,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529834118
    },
    {
        "content": "<p><code>Spv1</code> is the equivalance classes of valuations, and <code>Spv2</code> is the associated vague notions of order (it's not antisymmetric because <code>f</code> might not be injective -- maybe it's a preorder?) on <code>R</code>. The constructions live in different type universes. But are they equiv?</p>",
        "id": 128552037,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529834289
    },
    {
        "content": "<p>equiv can take different universes</p>",
        "id": 128552038,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529834311
    },
    {
        "content": "<p>In other words, should I expect to be able to prove <code>noncomputable definition they_are_the_same (R : Type) [comm_ring R] : equiv (Spv1 R) (Spv2 R) := sorry</code>?</p>",
        "id": 128552039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529834320
    },
    {
        "content": "<p>Yes Kenny, I noticed this -- so at least my question typechecks.</p>",
        "id": 128552040,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529834334
    },
    {
        "content": "<p>Here are perhaps the functions:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Spv1</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">Spv2</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,(</span><span class=\"bp\">⟨λ</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">valuations</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">,</span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"bp\">⟩⟩</span> <span class=\"o\">:</span> <span class=\"n\">Spv2</span> <span class=\"n\">R</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">H</span><span class=\"o\">,</span><span class=\"k\">begin</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span><span class=\"n\">congr</span><span class=\"o\">,</span><span class=\"n\">funext</span><span class=\"o\">,</span><span class=\"n\">exact</span> <span class=\"n\">propext</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"kn\">end</span><span class=\"o\">)</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">inv_fun</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Spv2</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">Spv1</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">ineq</span><span class=\"o\">,</span><span class=\"n\">H</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"err\">⟦</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">H</span><span class=\"err\">⟧</span>\n</pre></div>",
        "id": 128552048,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529834360
    },
    {
        "content": "<p>I don't know if that's going to give me trouble because I used tactics in a definition -- but it was for a proof.</p>",
        "id": 128552092,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529834415
    },
    {
        "content": "<p>To prove either direction I need to show something about a map constructed using quotient.lift (assuming this is the way to define <code>to_fun</code>). For example <code>right_inv</code> boils down to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n<span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n<span class=\"n\">Hrel</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuations</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">rel</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n<span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span>\n<span class=\"err\">⊢</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">R</span> <span class=\"err\">⟦</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">Hrel</span><span class=\"err\">⟧</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">rel</span> <span class=\"n\">r</span> <span class=\"n\">s</span>\n</pre></div>",
        "id": 128552471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529835414
    },
    {
        "content": "<p>Is this quotient.something?</p>",
        "id": 128552571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529835673
    },
    {
        "content": "<p>and <code>left_inv</code> looks like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n<span class=\"n\">vs</span> <span class=\"o\">:</span> <span class=\"n\">Spv1</span> <span class=\"n\">R</span>\n<span class=\"err\">⊢</span> <span class=\"n\">inv_fun</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">R</span> <span class=\"n\">vs</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">vs</span>\n</pre></div>",
        "id": 128552610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529835745
    },
    {
        "content": "<p>just <code>unfold</code> everything</p>",
        "id": 128552613,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529835772
    },
    {
        "content": "<p>I don't need this equiv, but I'm trying to get a feeling for the relative merits of either definition</p>",
        "id": 128552614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529835776
    },
    {
        "content": "<p>If you unfold everything you end up with classical.somes which don't behave</p>",
        "id": 128552619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529835788
    },
    {
        "content": "<p>or at least I did</p>",
        "id": 128552620,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529835791
    },
    {
        "content": "<p>you end up with a goal of the form <code>classical.some _ a &lt;= classical.some _ b iff classical.some _ a &lt;= classical.some _ b</code> or something, and iff.refl doesn't work because the <code>_</code>s are slightly different -- or at least they were for me (with the definition of valuation filled in)</p>",
        "id": 128552657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529835843
    },
    {
        "content": "<p>what is the property of each some</p>",
        "id": 128552662,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529835887
    },
    {
        "content": "<p>Kenny it must be more than an unfold -- the <code>left_inv</code> goal has <code>vs</code> in it and we know nothing about <code>vs</code> other than its type --</p>",
        "id": 128552663,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529835888
    },
    {
        "content": "<p>I don't know if I'm making a wrong turn, but I tried <code>quotient.exists_rep</code></p>",
        "id": 128552672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529835947
    },
    {
        "content": "<p>Here's an example of the sort of mess I get into:</p>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">vs</span><span class=\"o\">,</span><span class=\"k\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">exists_rep</span> <span class=\"n\">vs</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">v</span> <span class=\"n\">Hv</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">Hv</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">R</span> <span class=\"n\">vs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"c1\">-- fails</span>\n    <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">    rewrite tactic failed, did not find instance of the pattern in the target expression</span>\n<span class=\"cm\">  (classical.some _).f r ≤ (classical.some _).f s</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">R : Type,</span>\n<span class=\"cm\">_inst_1 : comm_ring R,</span>\n<span class=\"cm\">vs : Spv1 R,</span>\n<span class=\"cm\">v : valuations R,</span>\n<span class=\"cm\">Hv : ⟦v⟧ = vs,</span>\n<span class=\"cm\">r s : R,</span>\n<span class=\"cm\">H : ∀ (r s : R), (to_fun R vs).val r s ↔ (classical.some _).f r ≤ (classical.some _).f s</span>\n<span class=\"cm\">⊢ (classical.some _).f r ≤ (classical.some _).f s ↔ v.f r ≤ v.f s</span>\n<span class=\"cm\">    -/</span>\n</pre></div>",
        "id": 128552813,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529836243
    },
    {
        "content": "<p>I wondered if I'd made a wrong turn</p>",
        "id": 128552819,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529836310
    },
    {
        "content": "<p><a href=\"https://gist.github.com/kbuzzard/e0b36acade48f955212e8ea5142cb7b1\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/e0b36acade48f955212e8ea5142cb7b1\">https://gist.github.com/kbuzzard/e0b36acade48f955212e8ea5142cb7b1</a> is where I'm at. Somehow I was expecting this to be easier. Various failures deleted.</p>",
        "id": 128553388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529837658
    },
    {
        "content": "<p>Perhaps I should outline the reason I'm even thinking about this. Part of me still wants to work in ZFC so everything should live in <code>Type</code>. But the natural definition of <code>Spv R</code> lives in <code>Type 1</code>. I just wanted to weigh up the pros and cons of the two approaches. If I can prove they're equiv then many of the assertions I'll be making about one type will be true for the other one by some general \"canonical isomorphism\" principle. I figured that if I kept track of both then I could see to what extent my code was affected by the choice I'll ultimately make. But if I can't prove the equiv then I am less sure that the two approaches are \"the same\". Probably the equiv is fine and it's just my general incompetence with quotient types. Maybe I should instead be proving that <code>to_fun</code> is a bijection?</p>",
        "id": 128553587,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529838167
    },
    {
        "content": "<p>I wish there was an option to display the type of proofs in the pp.</p>",
        "id": 128553768,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1529838603
    },
    {
        "content": "<p>Proved<code> left_inv</code></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"kn\">definition</span> <span class=\"n\">they_are_the_same</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">Spv1</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Spv2</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">to_fun</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">inv_fun</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">vs</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span> <span class=\"n\">vs</span> <span class=\"k\">begin</span>\n    <span class=\"k\">assume</span> <span class=\"n\">vs</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">R</span> <span class=\"err\">⟦</span><span class=\"n\">vs</span><span class=\"err\">⟧</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">R</span> <span class=\"err\">⟦</span><span class=\"n\">vs</span><span class=\"err\">⟧</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">property</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s2</span><span class=\"o\">,</span><span class=\"k\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">s2</span> <span class=\"k\">with</span> <span class=\"n\">rel</span> <span class=\"n\">Hrel</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">inv_fun</span><span class=\"o\">,</span>\n    <span class=\"n\">funext</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span>\n  <span class=\"kn\">end</span>\n<span class=\"o\">}</span>\n</pre></div>",
        "id": 128553915,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1529838994
    },
    {
        "content": "<p>Often when the inverse function is <code>classical.some</code>, it's much easier to use <code>equiv.of_bijective</code></p>",
        "id": 128553921,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1529839037
    },
    {
        "content": "<p>Done</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">open</span> <span class=\"n\">function</span>\n<span class=\"n\">noncomputable</span> <span class=\"kn\">definition</span> <span class=\"n\">they_are_the_same</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">Spv1</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Spv2</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">of_bijective</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">bijective</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n<span class=\"k\">from</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on₂</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">iff_of_eq</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">inj</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">))),</span>\n  <span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"bp\">⟩⟩</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"err\">⟦</span><span class=\"n\">v</span><span class=\"err\">⟧</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">funext</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">propext</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">))</span><span class=\"bp\">⟩⟩</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 128554214,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1529839751
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 128555828,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529843619
    },
    {
        "content": "<blockquote>\n<p>I wish there was an option to display the type of proofs in the pp.</p>\n</blockquote>\n<p><code>set_option pp.proofs true</code></p>",
        "id": 128556386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529844989
    },
    {
        "content": "<p>That displays the proofs, not their type.</p>",
        "id": 128558361,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1529849660
    },
    {
        "content": "<blockquote>\n<p>I think Johannes is working on merging Patrick's normed space stuff</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span>  What do you mean? Is he extracting stuff from <a href=\"https://github.com/PatrickMassot/lean-differential-topology/blob/master/src/norms.lean\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-differential-topology/blob/master/src/norms.lean\">https://github.com/PatrickMassot/lean-differential-topology/blob/master/src/norms.lean</a>? This effort is completely stopped because of type class resolution issues in the very last declaration of that file that seems to be related again to the modules and rings issue.  I would really love to be able to move forward. Especially since I should have quite a lot of time for Lean in the coming weeks.</p>",
        "id": 128567000,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1529869446
    },
    {
        "content": "<p>Yes, I want to work on normed spaces. I won't have time this week (we have two workshops in Amsterdam) but the following week.</p>",
        "id": 128583585,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1529903940
    },
    {
        "content": "<p>Do you intend to fix my stuff or restart from scratch?</p>",
        "id": 128583975,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1529904814
    },
    {
        "content": "<p>Also, did you see my new version of uniform structures on topological groups (that I discussed  in this thread four days ago)?</p>",
        "id": 128584020,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1529904880
    },
    {
        "content": "<p>I wanted to start working on completions of abelian topological groups and noticed I forgot to prove the uniform group instance. This is now done in <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/commit/adb5140ecc46a577325cda46dcf6626424f5ef02\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/commit/adb5140ecc46a577325cda46dcf6626424f5ef02\">https://github.com/PatrickMassot/lean-perfectoid-spaces/commit/adb5140ecc46a577325cda46dcf6626424f5ef02</a></p>",
        "id": 128602123,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1529936254
    },
    {
        "content": "<p><code>sub_eq_add_neg</code> being a simp rule is really a nuisance. I can't imagine any situation where I would want to replace <code>a - b</code> with <code>a + -b</code></p>",
        "id": 128602198,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1529936335
    },
    {
        "content": "<p>The idea that neg is a \"simpler\" function than sub I guess. Computer scientists seem to have some crazy ordering of things which is very counterintuitive to mathematicians. Concepts which we regard as having equal weight often don't have equal weight in Lean. I guess Lean is trying to put something into some kind of canonical form with simp, and clearly this canonical form isn't supposed to have any subs in.</p>",
        "id": 128609748,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529944898
    },
    {
        "content": "<p>I guess some <code>simp</code> lemmas deal with add and neg, but not sub. It's not that weird, everyone writes <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><msup><mi>b</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">a b^{-1}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span><span class=\"mord\"><span class=\"mord mathit\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> in a group, but never <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mi mathvariant=\"normal\">/</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a / b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\">b</span></span></span></span></p>",
        "id": 128610190,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1529945431
    },
    {
        "content": "<p>Conversely no schoolkid writes 5 + (-3), they all write 5 - 3</p>",
        "id": 128610297,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529945595
    },
    {
        "content": "<p>I just discovered the <code>[norm]</code> simp set thanks to Simon:</p>\n<blockquote>\n<p>Add [norm] simp set. It contains all lemmas tagged with [simp] plus any lemma tagged with [norm]. These rules are used to produce normal forms and/or reduce the number of constants used in a goal. For example, we plan to add the lemma f &lt;$&gt; x = x &gt;&gt;= pure ∘ f to [norm].</p>\n</blockquote>\n<p>I agree that the sub elimination theorem is a horrible simp lemma, and it's a candidate for <code>[norm]</code> if anything is.</p>",
        "id": 128634201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529978690
    },
    {
        "content": "<p>I think we can improve readability of the code that uses valuations by using slightly longer names in <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/cc415fe8834b4886a5305feb89ac566d7b04ba94/src/valuations.lean#L338\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/cc415fe8834b4886a5305feb89ac566d7b04ba94/src/valuations.lean#L338\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/cc415fe8834b4886a5305feb89ac566d7b04ba94/src/valuations.lean#L338</a><br>\nI suggest that the field <code>f</code> be called <code>fun</code> and <code>Hf</code> be called <code>is_val</code>.</p>",
        "id": 128703012,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530085737
    },
    {
        "content": "<p>Hmm, I see that there was a coercion that would coerce <code>v</code> to <code>v.f</code>. <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Why was that removed? I think it greatly improves readability...</p>",
        "id": 128759497,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530171536
    },
    {
        "content": "<p>And it hides the <code>.f</code> so then I don't care so much how that field is called (-;</p>",
        "id": 128759506,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530171560
    },
    {
        "content": "<p>It didn't work sometimes</p>",
        "id": 128759708,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530171966
    },
    {
        "content": "<p>But I was too lazy to debug. I was sitting next to Chris when I wrote it and he said \"oh yeah, has coe to fun is a bit rubbish and doesn't always work\" and although I interpreted this as \"we need to ask Mario why it is failing\" I just wanted the code to work so I removed it. Put it back, see what breaks, and ask for help!</p>",
        "id": 128759763,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530172083
    },
    {
        "content": "<p>Yeah, my experience of coercions is that the pain of them mysteriously not working (usually it's not so mysterious, just Lean isn't quite as clever as you are guessing what you really meant to say) far outweighs the smoothness when they do work. But I like writing verbose code, anyway. :-)</p>",
        "id": 128759780,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1530172166
    },
    {
        "content": "<p>Ok, will do (-; So far nothing is breaking...</p>",
        "id": 128759886,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530172352
    },
    {
        "content": "<p>Scott, yes I understand that. But in this case I think there are some crucial parts of the code that should be as readible as possible.</p>",
        "id": 128759965,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530172473
    },
    {
        "content": "<p>I removed the coercion for all the wrong reasons. It was Thursday night at Xena, I was low on battery, I had nearly finished a file, it was time to go home, I asked Chris why my code didn't work and he said he'd had trouble with <code>has_coe_to_fun</code> and I thought \"sod it I'll just remove it\". I commented it out specifically to remind future me to come back to it.</p>",
        "id": 128768192,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530187100
    },
    {
        "content": "<p>In other news, I discovered a subtlety in the definition of continuous. Two valuations <code>v : R -&gt; option alpha</code> and <code>v' : R -&gt; option beta</code> are equivalent if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi><mo>(</mo><mi>r</mi><mo>)</mo><mo>≤</mo><mi>v</mi><mo>(</mo><mi>s</mi><mo>)</mo><mspace width=\"0.277778em\"></mspace><mo>⟺</mo><mspace width=\"0.277778em\"></mspace><msup><mi>v</mi><mo mathvariant=\"normal\">′</mo></msup><mo>(</mo><mi>r</mi><mo>)</mo><mo>≤</mo><msup><mi>v</mi><mo mathvariant=\"normal\">′</mo></msup><mo>(</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">v(r)\\leq v(s)\\iff v'(r)\\leq v'(s)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.751892em;\"></span><span class=\"strut bottom\" style=\"height:1.001892em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mrel\">≤</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathit\">s</span><span class=\"mclose\">)</span><span class=\"mrel\"><span class=\"mspace thickspace\"></span><span class=\"mrel\">⟺</span></span><span class=\"mord\"><span class=\"mspace thickspace\"></span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mrel\">≤</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathit\">s</span><span class=\"mclose\">)</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi><mo separator=\"true\">,</mo><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">r,s</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">s</span></span></span></span>. There are other equivalent ways of writing the equivalence, and it's a lemma that they all coincide. Unsurprisingly, at some point I found I needed the lemma, but surprisingly it was in the definition of continuous. My slightly superficial (as it turns out) understanding of the definition of a continuous valuation was that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span></span></span></span> was continuous iff the pre-image of <code>a : option alpha // a &lt; b</code> was open for all b in alpha -- but this is not always constant on an equivalence class! The problem is that alpha might be embedded as some infinitesimally small subgroup of beta, and then beta contains elements smaller than everything in the image other than 0 (the <code>none</code> option) which have no analogue in alpha. One has to restrict to b's which are in the group generated by the image of v. I'd never noticed this before. </p>\n<p>So we need to prove 1.25 and 1.27 in Wedhorn -- but then it turns out that we don't even have quotient rings and the fact that the quotient of a comm ring by a prime ideal is an integral domain. These are not hard -- but it's funny to see how holey everything still is. I am about to ask Kenny to fill in my sorries :-) [I just committed some stuff]</p>",
        "id": 128768441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530187484
    },
    {
        "content": "<p>That actually sounds pretty technical! I would have glossed over this for sure...</p>",
        "id": 128955982,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530526422
    },
    {
        "content": "<p>Working on the definition of manifolds in Lean also taught me that the well known fact that the relation of equivalence of atlases is an equivalence relation has slightly more content that I was aware of. I don't think there is any book proving this fact. Most of them simply use the word \"equivalence class\" without writing \"equivalence relation\" anywhere (this includes my own lecture notes on differential topology). Some write \"is easily seen to be an equivalence relation\". I haven't seen any proof anywhere except on my scratchpad.</p>",
        "id": 128956469,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1530527297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I'm confused: why are you changing <code>is_valuation</code> to <code>valuation</code>? I thought that it should be <code>is_*</code> because the type is <code>Prop</code>.</p>",
        "id": 129008758,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530604223
    },
    {
        "content": "<p>Is there a good explanation of these naming conventions somewhere?</p>",
        "id": 129008765,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530604237
    },
    {
        "content": "<p>We can have <code>is_</code> if you like.</p>",
        "id": 129008771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604249
    },
    {
        "content": "<p>Well... you're the boss <span class=\"emoji emoji-1f923\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 129008781,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530604273
    },
    {
        "content": "<p>It is just that I got a bit confused... but I'm not sure if there even is a solid convention.</p>",
        "id": 129008784,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530604301
    },
    {
        "content": "<p>Boss -- not really. And I don't understand the rules properly. I think Kenny had a namespace <code>is_valuation</code> which I thought was going a bit far.</p>",
        "id": 129008794,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604320
    },
    {
        "content": "<p>What is the convention in question? (I think I am the MC - Master of Conventions)</p>",
        "id": 129008844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604352
    },
    {
        "content": "<p>So a function f from a ring R to some totally ordered monoid M is a _valuation_ if it satisfies some axioms.</p>",
        "id": 129008854,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604386
    },
    {
        "content": "<p>Is it a property of the function, or an augmented function?</p>",
        "id": 129008884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604409
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">valuation</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_zero</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_one</span>  <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_mul</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_add</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 129008899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604427
    },
    {
        "content": "<p>That used to say <code>class is_valuation</code></p>",
        "id": 129008901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604434
    },
    {
        "content": "<p>I think it should be <code>is_valuation</code> then</p>",
        "id": 129008949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604454
    },
    {
        "content": "<p>The next line in the code is <code>namespace valuation</code></p>",
        "id": 129008954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604474
    },
    {
        "content": "<p>Kevin, you see <code>Prop</code> stands for <em>property</em> <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>",
        "id": 129008957,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530604486
    },
    {
        "content": "<p>and did it used to say <code>namespace is_valuation</code>?</p>",
        "id": 129008961,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604496
    },
    {
        "content": "<p><code>namespace valuation</code> will be annoying since it's not accessed by projection</p>",
        "id": 129008974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604514
    },
    {
        "content": "<p>since it's a typeclass</p>",
        "id": 129008976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604520
    },
    {
        "content": "<p>I don't understand that. I've never understood projection properly.</p>",
        "id": 129008981,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604535
    },
    {
        "content": "<p>I just muddle through with projections. I write <code>G.mul_assoc</code> and if it doesn't work I write <code>group.mul_assoc G</code></p>",
        "id": 129008999,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604562
    },
    {
        "content": "<p>To use projection you have to be projecting on an expression whose type has the same name as the namespace</p>",
        "id": 129009031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604571
    },
    {
        "content": "<p>and I never have a clue which one I'm supposed to use or which one will work</p>",
        "id": 129009033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604572
    },
    {
        "content": "<p>If you use typeclass inference, then the operative name is in a hidden parameter, so it doesn't work</p>",
        "id": 129009044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604604
    },
    {
        "content": "<p>These words are too hard for me</p>",
        "id": 129009049,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604613
    },
    {
        "content": "<p>i.e. you can't write <code>f.map_zero</code> when you know <code>is_valuation f</code> because lean looks at the type of <code>f</code>, which is <code>pi</code>, and then checks the <code>pi</code> namespace only</p>",
        "id": 129009064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604649
    },
    {
        "content": "<p>(actually that doesn't really work, <code>pi</code> isn't a namespace)</p>",
        "id": 129009071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604666
    },
    {
        "content": "<p>but for inductive types like <code>nat</code> which are also namespaces, it works well</p>",
        "id": 129009118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604688
    },
    {
        "content": "<p>Kevin, you can write <code>H.bla</code> for <code>[H: is_valuation f]</code>, but not <code>f.bla</code>. But then, we want <code>H</code> to be implicit (type class inference, etc...) so in practice you won't be able to type <code>H.bla</code> because there is no explicit <code>H</code>.</p>",
        "id": 129009119,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530604688
    },
    {
        "content": "<p>What I do not understand (at all) is whether I should have _something_ called <code>valuation</code>. We have <code>group G</code>, right? Why can't I have <code>valuation f</code>?</p>",
        "id": 129009130,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604703
    },
    {
        "content": "<p>I don't see the difference</p>",
        "id": 129009133,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604709
    },
    {
        "content": "<p>I think lean might complain if <code>H</code> turns out to be implicit in <code>is_valuation.bla</code> though</p>",
        "id": 129009135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604721
    },
    {
        "content": "<p>Because <code>group</code> has extra structure.</p>",
        "id": 129009136,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530604722
    },
    {
        "content": "<p>Why do I want to use type class inference for valuations?</p>",
        "id": 129009156,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604756
    },
    {
        "content": "<p>I do not understand what we want here</p>",
        "id": 129009160,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604768
    },
    {
        "content": "<p>I was just sick of writing is_</p>",
        "id": 129009162,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604773
    },
    {
        "content": "<p>If you use the augmented function approach you can use the name <code>valuation</code> and call functions by projection</p>",
        "id": 129009166,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604782
    },
    {
        "content": "<p>So, if you have a <code>monoid</code> or something like that, you could have a <code>is_group G : Prop</code>, but <code>group G</code> is not a <code>Prop</code>.</p>",
        "id": 129009169,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530604793
    },
    {
        "content": "<p>You can also just ignore conventions if you think <code>valuation</code> will never be defined</p>",
        "id": 129009214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604805
    },
    {
        "content": "<p>What's worse is that \"valuation\" in the literature actually means \"equivalence class of valuations\"</p>",
        "id": 129009220,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604808
    },
    {
        "content": "<p>You didn't like my valuation = relation suggestion?</p>",
        "id": 129009224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604828
    },
    {
        "content": "<p>I don't know about that either. I implemented both</p>",
        "id": 129009235,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604839
    },
    {
        "content": "<p>I have <code>zfc.valuation</code> too</p>",
        "id": 129009240,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604846
    },
    {
        "content": "<p>ooh, mysterious</p>",
        "id": 129009244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604856
    },
    {
        "content": "<p>just means \"I only use Type\"</p>",
        "id": 129009254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604867
    },
    {
        "content": "<p>why would you do that? You can just restrict the universe variables of polymorphic functions</p>",
        "id": 129009263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604903
    },
    {
        "content": "<p>I've just realised I don't even know what is being suggested. (1) I change <code>class valuation ... : Prop</code> back to <code>class is_valuation</code>. Then what? Is <code>namespace valuation</code> changing back to <code>namespace is_valuation</code>?</p>",
        "id": 129009310,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604929
    },
    {
        "content": "<p>\"I only use Type\" is just a maths thing</p>",
        "id": 129009315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530604943
    },
    {
        "content": "<p>You can put it in a namespace if you want, or use <code>valuation_*</code> pseudo-namespacing, or put the theorems in the parent namespace</p>",
        "id": 129009329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530604985
    },
    {
        "content": "<p>Kevin, I think Mario would want</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">valuations</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">Hα</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Hf</span> <span class=\"o\">:</span> <span class=\"n\">is_valuation</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>to be called <code>valuation</code></p>",
        "id": 129009332,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530604987
    },
    {
        "content": "<p>But I am not sure about that...</p>",
        "id": 129009341,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530605014
    },
    {
        "content": "<p>Only the <code>f</code> and <code>hf</code> should be in the structure</p>",
        "id": 129009343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605026
    },
    {
        "content": "<p>No...</p>",
        "id": 129009345,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530605036
    },
    {
        "content": "<p>Two valuations are equivalent if they \"only differ by the alpha\"</p>",
        "id": 129009385,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605051
    },
    {
        "content": "<p>you can still state that with the alpha as parameter</p>",
        "id": 129009388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605064
    },
    {
        "content": "<p>But then <code>valuations</code> depends on <code>alpha</code>, that becomes horrible right?</p>",
        "id": 129009398,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530605089
    },
    {
        "content": "<p>I have valuations defined to be something else</p>",
        "id": 129009399,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605092
    },
    {
        "content": "<p>no, that becomes tractable</p>",
        "id": 129009402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605099
    },
    {
        "content": "<p>(I would drop the <code>s</code> though)</p>",
        "id": 129009414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605112
    },
    {
        "content": "<p>no I don't, I have valuations to be defined exactly like that</p>",
        "id": 129009419,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605123
    },
    {
        "content": "<p>then</p>\n<div class=\"codehilite\"><pre><span></span>instance valuations.setoid (R : Type) [comm_ring R] : setoid (valuations R) :=\n{ r := λ v w, ∀ r s : R, v.f r ≤ v.f s ↔ w.f r ≤ w.f s,...\n</pre></div>",
        "id": 129009441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605151
    },
    {
        "content": "<p>Mario, then you have defined \"valuation on R with value group alpha\" (why not <code>Gamma</code>?)</p>",
        "id": 129009442,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530605152
    },
    {
        "content": "<p>alpha not Gamma because Kenny wrote it</p>",
        "id": 129009486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605168
    },
    {
        "content": "<p>Note that <code>valuations</code> as Johan quotes lives in <code>Type 1</code>, so if it's aiming for zfc land it's not doing so great</p>",
        "id": 129009488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605171
    },
    {
        "content": "<p>I don't know whether I should be worrying about ZFC or not. It seems futile really because I use so much other stuff with universes in</p>",
        "id": 129009494,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605199
    },
    {
        "content": "<p>Yes, and <em>I</em> am completely fine with that (-;</p>",
        "id": 129009498,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530605202
    },
    {
        "content": "<p>Maybe I'm just making sure that one day I can write my own section 4</p>",
        "id": 129009512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605230
    },
    {
        "content": "<blockquote>\n<p>Mario, then you have defined \"valuation on R with value group alpha\" (why not Gamma?)</p>\n</blockquote>\n<p>Yes, that's the point. The equivalence relation can span two value groups</p>",
        "id": 129009521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605237
    },
    {
        "content": "<blockquote>\n<p>Only the <code>f</code> and <code>hf</code> should be in the structure</p>\n</blockquote>\n<p>I don't understand how to make the setoid if alpha is not where Johan put it</p>",
        "id": 129009581,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605296
    },
    {
        "content": "<p>Kevin, someday I will write a treatise on lean in ZFC and there will be an automated analysis to find out if your theorem uses universes in an essential way. Until then, just write things that are intuitively not using universes essentially and don't otherwise worry about it</p>",
        "id": 129009608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605342
    },
    {
        "content": "<p>There is a \"minimal\" alpha associated with every valuation, which is unique up to unique isomorphism -- it's just the group generated by the image of teh valuation</p>",
        "id": 129009616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605352
    },
    {
        "content": "<p>Mario -- that's great news about ZFC. I'm sure there will be mathematicians out there who genuinely care (those who read the section 4's in this world)</p>",
        "id": 129009623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605397
    },
    {
        "content": "<p><em>I</em> care</p>",
        "id": 129009665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605406
    },
    {
        "content": "<p>There was a lot of fuss after FLT was proved, on the foundations of maths mailing list, because Wiles had used categories</p>",
        "id": 129009680,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605428
    },
    {
        "content": "<p>so a rumour started that the proof didn't fit into ZFC</p>",
        "id": 129009685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605440
    },
    {
        "content": "<p>but the analysis is not quite as easy as \"just stick to Type\", even if it is morally just that</p>",
        "id": 129009688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605445
    },
    {
        "content": "<p>Isn't the analysis just \"just stick to Type, and demand that all your libraries do the same\"?</p>",
        "id": 129009696,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605468
    },
    {
        "content": "<p>Or is even that not enough?</p>",
        "id": 129009699,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605474
    },
    {
        "content": "<p>The problem is that almost everything you write is trivially not just in Type</p>",
        "id": 129009704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605495
    },
    {
        "content": "<p>?!</p>",
        "id": 129009709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605509
    },
    {
        "content": "<p>for example, any function Type -&gt; Type is not in Type</p>",
        "id": 129009710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605510
    },
    {
        "content": "<p>i.e. <code>huber_ring</code> or whatever</p>",
        "id": 129009754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605525
    },
    {
        "content": "<p>these are justifiable in ZFC as class functions</p>",
        "id": 129009765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605550
    },
    {
        "content": "<p>Ok I give in</p>",
        "id": 129009772,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605563
    },
    {
        "content": "<p>As far as I am concerned, universes are just the axiom of infinity on steroids. Which means I am not concerned...</p>",
        "id": 129009796,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530605605
    },
    {
        "content": "<p>But my point is that this analysis, when it eventually arrives, will handle universe polymorphic functions, so you shouldn't avoid polymorphism for the sake of \"chapter 4\"</p>",
        "id": 129009801,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605615
    },
    {
        "content": "<p>Mario, so how do we write an alpha-agnostic setoid with your version of <code>valuation</code>?</p>",
        "id": 129009850,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530605660
    },
    {
        "content": "<p>You shouldn't literally write a setoid</p>",
        "id": 129009861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605690
    },
    {
        "content": "<p>it's too big</p>",
        "id": 129009862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605695
    },
    {
        "content": "<p>instead you just use the equivalence relation</p>",
        "id": 129009872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605709
    },
    {
        "content": "<p>and use the relation as a small representative when you need one</p>",
        "id": 129009877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605735
    },
    {
        "content": "<p>But we need the actual valuation functions all the time</p>",
        "id": 129009879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605743
    },
    {
        "content": "<p>Mario, so what is morally wrong with the current version that I quoted?</p>",
        "id": 129009928,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530605778
    },
    {
        "content": "<p>Line 1 of <code>valuation_spectrum.lean</code> is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">valuation</span><span class=\"bp\">.</span><span class=\"n\">valuations</span><span class=\"bp\">.</span><span class=\"n\">setoid</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Spv</span>\n</pre></div>",
        "id": 129009929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605780
    },
    {
        "content": "<p>and this is a fundamental object</p>",
        "id": 129009935,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605800
    },
    {
        "content": "<p>Spv is almost an adic space</p>",
        "id": 129009940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605806
    },
    {
        "content": "<p>Right, and <code>Spv</code> is the basic building block of all this theory. It is all over the place.</p>",
        "id": 129009941,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530605809
    },
    {
        "content": "<p>You can define the setoid, but it is one of the things that \"essentially uses universes\"</p>",
        "id": 129009943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605811
    },
    {
        "content": "<p>and we're constantly choosing points</p>",
        "id": 129009945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605816
    },
    {
        "content": "<p>The fundamental topological space which we use all the time is the space of equivalence classes of valuations</p>",
        "id": 129009954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605853
    },
    {
        "content": "<p>so we have to get this right</p>",
        "id": 129009956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605856
    },
    {
        "content": "<blockquote>\n<p>You can define the setoid, but it is one of the things that \"essentially uses universes\"</p>\n</blockquote>\n<p>Is that its only moral failure?</p>",
        "id": 129009960,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530605863
    },
    {
        "content": "<p>What's wrong, again, with defining <code>Spv</code> as the collection of all valuation relations?</p>",
        "id": 129009961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605864
    },
    {
        "content": "<p>All proofs need an actual valuation</p>",
        "id": 129009967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605875
    },
    {
        "content": "<p>You can define your own version of <code>quot.lift</code> and <code>quot.mk</code> that take valuations</p>",
        "id": 129010011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605903
    },
    {
        "content": "<p>valuation functions that is</p>",
        "id": 129010013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605908
    },
    {
        "content": "<p>Aah</p>",
        "id": 129010014,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605924
    },
    {
        "content": "<p>You only use the relations as inhabitants of the type so that the universe isn't pushed up, but all the work uses functions</p>",
        "id": 129010026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530605975
    },
    {
        "content": "<p>So we hide all the noncomputable stuff in some functions like this, and prove everything we need about them. Is this going to cause problems later?</p>",
        "id": 129010027,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530605975
    },
    {
        "content": "<p>We define Spv as the preorders on R (or whatever the word is) for which there exists a valuation inducing it, and then write some horrible-looking functions which actually produce a valuation...wait. The valuation is only defined up to equivalence. How does this work?</p>",
        "id": 129010086,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606057
    },
    {
        "content": "<p>You will need to prove the computation rule, so it won't be definitional, but otherwise it should work smoothly if your API is solid</p>",
        "id": 129010087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606059
    },
    {
        "content": "<p>Is my API the thing I sometimes call my interface?</p>",
        "id": 129010096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606074
    },
    {
        "content": "<p>No function to produce a valuation</p>",
        "id": 129010101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606081
    },
    {
        "content": "<p>that's not how <code>quot</code> works either</p>",
        "id": 129010105,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606090
    },
    {
        "content": "<p>The function produces an equivalence class? Do we make the setoid anyway?</p>",
        "id": 129010114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606106
    },
    {
        "content": "<p>The \"I\" in API is \"interface\"</p>",
        "id": 129010115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606106
    },
    {
        "content": "<p>No equivalence class needed either</p>",
        "id": 129010162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606129
    },
    {
        "content": "<p>Like I said, <code>quot.mk</code> and <code>quot.lift</code></p>",
        "id": 129010164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606141
    },
    {
        "content": "<p><code>quot.mk</code> takes a valuation function and produces an element of <code>Spv</code></p>",
        "id": 129010169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606156
    },
    {
        "content": "<p><code>quot.lift</code> takes a function defined on valuation functions and produces a function defined on <code>Spv</code></p>",
        "id": 129010174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606177
    },
    {
        "content": "<p>So what about proofs which go \"Spv(R) is compact. Proof: take an element of Spv(R), call it v or f or whatever, and now manipulate f in the following way...\"</p>",
        "id": 129010188,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606199
    },
    {
        "content": "<p>That's <code>quot.lift</code></p>",
        "id": 129010195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606210
    },
    {
        "content": "<p>Actually you will want <code>quot.ind</code> as well</p>",
        "id": 129010200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606218
    },
    {
        "content": "<p>or equivalently <code>quot.exists_rep</code></p>",
        "id": 129010210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606230
    },
    {
        "content": "<p>that is, for every element of <code>Spv</code> there is a valuation function that <code>quot.mk</code>'s to it</p>",
        "id": 129010262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606249
    },
    {
        "content": "<p>Note it's not actually a function producing valuation functions, it's an exists</p>",
        "id": 129010274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606284
    },
    {
        "content": "<p>So if I step back here, you're saying \"Experts wrote an API for <code>quot</code>. Because of some design decisions I'm suggesting about alphas, you can't use this, but write your own, everything will be fine\"?</p>",
        "id": 129010284,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606310
    },
    {
        "content": "<p>Just because you don't want an alpha inside a structure?</p>",
        "id": 129010289,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606331
    },
    {
        "content": "<p>The definitions on <code>quot</code> are all very canonical</p>",
        "id": 129010291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606337
    },
    {
        "content": "<p>they are essentially the universal property of quotients</p>",
        "id": 129010296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606347
    },
    {
        "content": "<p>Can you define \"very canonical\" in Lean?</p>",
        "id": 129010297,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606353
    },
    {
        "content": "<p>That sounds even harder than defining canonical</p>",
        "id": 129010299,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606359
    },
    {
        "content": "<p>if you prove analogues of those theorems for your type, then you have constructed the quotient up to isomorphism</p>",
        "id": 129010343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606387
    },
    {
        "content": "<p>up to canonical isomorphism maybe</p>",
        "id": 129010345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606402
    },
    {
        "content": "<p>indeed</p>",
        "id": 129010348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606407
    },
    {
        "content": "<p>It had better be canonical, because if R -&gt; S then I need Spv(S) -&gt; Spv(R)</p>",
        "id": 129010350,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606414
    },
    {
        "content": "<p>Not that I can define canonical in Lean...</p>",
        "id": 129010368,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606448
    },
    {
        "content": "<p>This all has a category theoretic interpretation as a coequalizer, and all constructions are natural in that category</p>",
        "id": 129010409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606495
    },
    {
        "content": "<p>As opposed to, say, <code>quot.out</code>, which picks an element from an equivalence class</p>",
        "id": 129010411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606530
    },
    {
        "content": "<p>Although in your case if I understand correctly you also have a canonical way to define <code>quot.out</code> satisfying some other universal property to do with the ordered group</p>",
        "id": 129010428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606600
    },
    {
        "content": "<p>So in summary, we should have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">valuation</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Hα</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Hf</span> <span class=\"o\">:</span> <span class=\"n\">is_valuation</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>and then maybe <code>namespace valuation</code> except I still don't properly understand what the word projection means and what it has to do with namespaces, and then we define <code>Spv</code> to be </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">zfc</span><span class=\"bp\">.</span><span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuations</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>except \"valuations\" there isn't quite right yet</p>",
        "id": 129010534,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606727
    },
    {
        "content": "<p>and then we need to write <a href=\"http://quot.mk\" target=\"_blank\" title=\"http://quot.mk\">quot.mk</a>, quot.lift, quot.ind and quot.ind</p>",
        "id": 129010537,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606755
    },
    {
        "content": "<p>I see <a href=\"http://www.quot.mk\" target=\"_blank\" title=\"http://www.quot.mk\">www.quot.mk</a> is available</p>",
        "id": 129010539,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606779
    },
    {
        "content": "<p>For augmented functions, I recommend a <code>has_coe_to_fun</code> instance so you can write <code>v r &lt;= v s</code> at the end there</p>",
        "id": 129010547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606812
    },
    {
        "content": "<p>Yeah I want to move back to the coe_to_fun approach. I dumped it too early when Chris told me he'd had trouble with it.</p>",
        "id": 129010596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530606863
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>definition zfc.Spv (A : Type) [comm_ring A] : Type :=\n{ineq : A → A → Prop // ∃ (A : Type) [linear_ordered_comm_group A]\n  (v : valuation R A), ∀ r s : A, ineq r s ↔ v r ≤ v s}\n</pre></div>",
        "id": 129010605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606904
    },
    {
        "content": "<p>If you want to be polymorphic, I suggest writing</p>\n<div class=\"codehilite\"><pre><span></span> def zfc.Spv (A : Type u) [comm_ring A] : Type :=\n{ineq : A → A → Prop // ∃ (A : Type u) [linear_ordered_comm_group A]\n  (v : valuation R A), ∀ r s : A, ineq r s ↔ v r ≤ v s}\n</pre></div>\n\n\n<p>where the valuation and ring have to share the same universe</p>",
        "id": 129010667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530606983
    },
    {
        "content": "<p>You can prove that the universe need not be the same as part of the universal properties</p>",
        "id": 129010679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530607046
    },
    {
        "content": "<p>i.e. <code>Spv.mk</code> takes as input a valuation function <code> (v : valuation R A)</code> where <code>{R : Type u}</code> and <code>{A : Type v}</code> (so it isn't just instantiating the exists)</p>",
        "id": 129010727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530607118
    },
    {
        "content": "<p>\"If you want to be polymorphic\" -- I just want to do maths. I have no idea if I want to be polymorphic. If I just want to define a perfectoid space, do I want to be polymorphic?</p>",
        "id": 129010827,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530607289
    },
    {
        "content": "<p>In lean, you should usually be polymorphic</p>",
        "id": 129010994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530607563
    },
    {
        "content": "<p>at least in contravariant positions (i.e. the inputs should be maximally polymorphic, the output should be minimally polymorphic)</p>",
        "id": 129011010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530607621
    },
    {
        "content": "<p>This is why we don't have <code>nat : Type u</code></p>",
        "id": 129011016,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530607636
    },
    {
        "content": "<p>If I read correctly, you want to have a class <code>is_valuation</code>, and then a structure type <code>valuation</code> made of all functions <code>f</code> satisfying the valuation axioms, i.e., with <code>is_valuation f</code>. What is the advantage of this approach (with typeclass inference) over the more direct approach with a structure type <code>valuation</code> in which you put directly the axioms, and then when you want to work with a valuation you just use <code>(v : valuation R A)</code> (so, getting rid completely of the typeclass <code>is_valuation</code>)?</p>",
        "id": 129012912,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1530610886
    },
    {
        "content": "<p>The problem is that a valuation is a function from a ring to some totally ordered monoid, and there's an equivalence relation which needs to be taken into account, of the form \"these monoids might not be the same, but there's a map from the image of one function to the image of the other which makes lots of things commute\". <code>Spv R</code> is the equivalence classes of valuations.</p>",
        "id": 129013477,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530611895
    },
    {
        "content": "<p>I understand this. My question is about the beginning of the discussion, with this <code>is_valuation</code> class at the start of your formalization.</p>",
        "id": 129014391,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1530613323
    },
    {
        "content": "<p>I am not the person to ask, I don't think. I have no understanding of how best to do these things in Lean, that's why I'm floundering around here. I understand the maths perfectly. Let me try and read your messages. Yes we have an inductive prop <code>is_valuation f</code>which is a class although I don't know if that's sensible (I think Kenny made it a class so it probably is). We then apparently are supposed to have  a type <code>valuation R alpha</code> which is all valuations taking values in alpha; I have no real understanding of why this is needed because I definitely don't care about all valuations taking values in alpha. You mention typeclass inference but I have no idea what should be a class because whilst I now understand what typeclass inference is and how to use it when other people have made the typeclasses, I am still extremely unclear myself about which of my own objects should be typeclasses. You now suggest I could be making a structure type <code>valuation</code> -- would this take alpha as part of the structure? I think we used to have that; Johan maybe mentioned it, and Mario said that alpha should not be part of the structure. Is A the totally ordered monoid? The only reason we have is_valuation is that someone else wrote it. I say again -- I completely understand the mathematics I want to do; I am extremely foggy about how to do it in Lean in the sense that I can see several ways and simply do not possess the toolkit necessary to work out the best way. There's my attempt to answer your question in full. At the end of the day I want <code>Spv R</code> to be the equivalence classes of valuations on R, and I have no idea whether <code>valuation</code> or <code>valuations</code> or <code>is_valuation</code> or structure or class or what is the best approach. I would happily be told explicitly what to do.</p>",
        "id": 129015550,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530615103
    },
    {
        "content": "<p>Am I right in thinking that Mario basically told me a way of doing it above, and you are suggesting another way?</p>",
        "id": 129015600,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530615171
    },
    {
        "content": "<p>I don't think Sebastien is suggesting anything different from what I recommended (using augmented functions)</p>",
        "id": 129015763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530615424
    },
    {
        "content": "<blockquote>\n<p>I have no real understanding of why this is needed because I definitely don't care about all valuations taking values in alpha. </p>\n</blockquote>\n<p>The general rule is to keep types out of classes if at all possible. Lean behaves better when the types are given as \"alpha\" rather than \"the type inside v\", particularly if you start manipulating the functions (adding them, say)</p>",
        "id": 129015837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530615547
    },
    {
        "content": "<p>Although you want to deal with \"the collection of all valuations\" (which is what <code>Spv</code> is for), when doing a concrete calculation you will have a <em>fixed</em> alpha with respect to which to do your monoid algebra stuff</p>",
        "id": 129015903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530615619
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>I have no real understanding of why this is needed because I definitely don't care about all valuations taking values in alpha. </p>\n</blockquote>\n<p>The general rule is to keep types out of classes if at all possible. Lean behaves better when the types are given as \"alpha\" rather than \"the type inside v\", particularly if you start manipulating the functions (adding them, say)</p>\n</blockquote>\n<p>Hmmm, can you be more precise about how Lean would misbehave? Because it seems \"mathematically natural/convenient\" to make <code>alpha</code> part of the structure, instead of a parameter.</p>",
        "id": 129019297,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530620756
    },
    {
        "content": "<p>it is the same things that make the difference between bundled vs unbundled groups. When working \"internally\", i.e. calculations using the monoid structure, it is better for the type to be exposed as a variable</p>",
        "id": 129019647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530621232
    },
    {
        "content": "<p>When working externally, there is already the type <code>Spv</code> to do this</p>",
        "id": 129019693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530621259
    },
    {
        "content": "<p>Also, there is a universe issue for the ZFC diehards</p>",
        "id": 129019728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1530621337
    },
    {
        "content": "<p>If I understand Sebastien correctly, then he suggesting to just merge <code>is_valuation f</code>and <code>valuation R Gamma</code> into one class. In other words, substitute the fields of <code>is_valuation</code> for the <code>Hf</code> field in <code>valuation</code>.</p>",
        "id": 129020385,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1530622157
    },
    {
        "content": "<blockquote>\n<p>it is the same things that make the difference between bundled vs unbundled groups. When working \"internally\", i.e. calculations using the monoid structure, it is better for the type to be exposed as a variable</p>\n</blockquote>\n<p>I am still not up to speed with notation. \"bundled\" means alpha is part of the structure? exposed type means it's not?</p>",
        "id": 129025279,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1530627333
    },
    {
        "content": "<blockquote>\n<p>If I understand Sebastien correctly, then he suggesting to just merge <code>is_valuation f</code>and <code>valuation R Gamma</code> into one class. In other words, substitute the fields of <code>is_valuation</code> for the <code>Hf</code> field in <code>valuation</code>.</p>\n</blockquote>\n<p>Exactly (except that I don't think it should be a class, only a structure, as typeclass inference will not help you there and you want to put several valuations on the same object).</p>",
        "id": 129044880,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1530648355
    },
    {
        "content": "<p>So I didn't think about perfectoid spaces for two weeks because I've been running my summer project, doing a bunch of Lean but not this sort of thing.</p>",
        "id": 129734678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531724303
    },
    {
        "content": "<p>I just pushed everything I had which wasn't pushed.</p>",
        "id": 129734680,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531724315
    },
    {
        "content": "<p>But I remember exactly where I was when things got crazy -- I had defined <code>Spv</code> to be the equivalence class of valuations, and then I wanted to define <code>Cont</code> to be the subset of continuous valuations. However the naive definition of continuous is not constant on equivalence classes! Every equivalence class of valuations contains some sort of canonical subset, consisting of the valuations v taking values in Gamma union 0, where the image of v in Gamma generates Gamma, and it's these valuations that have to be continuous. To isolate this canonical subclass I had to prove Wedhorn 1.27, giving various equivalent criteria for what it meant for two valuations to be equivalent. I began to formalise this but quickly realised that I needed to extend a valuation on A to A/P (P the prime ideal corresponding to the support of v) and then to Frac(A/P) (the field of fractions) and nothing was there. I began to formalise this and then never finished, and then my summer project started. I believe Chris Hughes pushed a PR over the weekend which did this ring theory stuff though, so perhaps we can get going again. Independent of all this was the naming changes, where <code>blah</code> was changed to <code>is_blah</code> and I think I managed to half-change everything and break most of the code.</p>",
        "id": 129734940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531724838
    },
    {
        "content": "<p>Perhaps I should have the decency to actually try and make it all compile (various names are changed in some files but noe others -- I was persuaded to go for the <code>is_blah</code> notation for Props...)</p>",
        "id": 129735065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531725110
    },
    {
        "content": "<p>I have a class <code>is_valuation</code> now, and then a namespace <code>valuation</code> which needs to be changed to <code>is_valuation</code>. Hopefully that's an acceptable name for a namespace...</p>",
        "id": 129735159,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531725243
    },
    {
        "content": "<blockquote>\n<p>Hopefully that's an acceptable name for a namespace...</p>\n</blockquote>\n<p>Why not? Is you want to prove lemma's about <code>is_valuation</code>, then it would make a lot of sense to do that in the <code>is_valuation</code> namespace.</p>",
        "id": 129735173,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531725295
    },
    {
        "content": "<p>Oh -- I remember the other thing which happened -- Mario suggested that the target group alpha for a valuation be moved from the structure into the input.</p>",
        "id": 129735251,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531725445
    },
    {
        "content": "<p>I didn't do any of this.</p>",
        "id": 129735255,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531725448
    },
    {
        "content": "<p>OK it should mostly compile</p>",
        "id": 129735457,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531725823
    },
    {
        "content": "<p>(Zulip ought to have a :compiling: emoji...)</p>",
        "id": 129735877,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531726587
    },
    {
        "content": "<p>Kevin, I think the last few lines in valuations.lean should not be in the <code>is_valuation</code> namespace. Because that is actually about <code>valuations</code>.</p>",
        "id": 129735947,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531726747
    },
    {
        "content": "<p>Johan feel free to fix up everything. I had <code>valuation</code> and <code>valuations</code>, and then <code>valuation</code> changed to <code>is_valuation</code>, and then random <code>valuations</code> turned into <code>is_valuations</code> etc etc. I can quite believe some namespaces are wrong / don't exist etc</p>",
        "id": 129736294,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531727446
    },
    {
        "content": "<p>Ok, I'll see what I can do (-;</p>",
        "id": 129736306,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531727471
    },
    {
        "content": "<p>I may as well explain the subtlety more carefully. If Gamma is some totally ordered abelian group with group law <code>*</code> then we can consider the totally ordered monoid Gamma union {0}, with {0} less than everything in Gamma (think Gamma = positive reals and the extension is the non-negative reals). A valuation on R is a map R -&gt; Gamma union {0} plus some axioms. But in general Gamma is too big -- one only needs the subgroup of Gamma generated by v(a) for a in R and v(a) non-zero, so there's some notion of equivalent valuations. </p>\n<p>If the ring R has a topology then we say that v is continuous if for all g in Gamma, the pre-image of {x in Gamma union 0 | x &lt; g} is open (definition 7.7, page 58 of Wedhorn). But this definition is not constant on equivalence classes! If v is a sensible valuation (e.g. the usual valuation on the p-adic numbers) and then we enlarge Gamma by throwing in a new variable G which is bigger than 0 but less than every element of Gamma (i.e. replace Gamma with Z x Gamma, Z the integers, with lexicographic ordering) then now all of a sudden there are lots of new elements of our value group so we can consider sets such as {x in Z x Gamma | x &lt; G} whose pre-image is now just the support of v, which is not in general open even if v is continuous (e.g. {0} is not an open subset of the p-adics). Hence one has to stick to Gamma generated by v. That's the subtlety which stopped me working.</p>",
        "id": 129736611,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531728078
    },
    {
        "content": "<p>Do we still want to move <code>alpha</code> out of the structure <code>valuations</code> into a parameter? I thought this was mostly to keep universes at bay...</p>",
        "id": 129736720,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531728358
    },
    {
        "content": "<p>Isn't the easy fix to just say that we only consider preimages of {x in Gamma union 0 | x &lt; v(a)} for some a?</p>",
        "id": 129737343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531729597
    },
    {
        "content": "<p>or perhaps g in the subgroup of Gamma generated by the range of v</p>",
        "id": 129737360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531729647
    },
    {
        "content": "<p>That would work, but I guess we will still want to know that in fact you just replaced the valuation with something equivalent.</p>",
        "id": 129737414,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531729697
    },
    {
        "content": "<p>I didn't change the valuation there</p>",
        "id": 129737432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531729738
    },
    {
        "content": "<p>I thought that the valuation equivalence relation was already defined; I mean that's what <code>Spv</code> was all about</p>",
        "id": 129737440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531729768
    },
    {
        "content": "<p>I mentioned that one of the axioms you want for <code>Spv</code> is an equivalent to either <code>quot.ind</code> or <code>quot.exists_rep</code>; you can strengthen this theorem to say that every equivalence relation has a representative valuation on some Gamma union 0 such that the valuation is surjective (or essentially surjective? The range generates the group)</p>",
        "id": 129737514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531729916
    },
    {
        "content": "<p>Hopefully such a Gamma is unique up to isomorphism on the equivalence class</p>",
        "id": 129737556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531729949
    },
    {
        "content": "<p>(Note that it would be very hard to state this theorem if <code>alpha</code> in the structure <code>valuations</code> was a field)</p>",
        "id": 129737571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531730016
    },
    {
        "content": "<p>because here we need to say that <code>alpha</code> is <code>with_zero Gamma</code> for some <code>Gamma</code>, but we don't want to impose an equality to cast over</p>",
        "id": 129737617,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531730052
    },
    {
        "content": "<p>Ok, I see</p>",
        "id": 129737769,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531730344
    },
    {
        "content": "<p>This might be a good way to go forward with</p>",
        "id": 129737772,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531730366
    },
    {
        "content": "<p>What is the best way to prove that the intersection of two neighbourhoods is a neighbourhood?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Va</span> <span class=\"err\">∩</span> <span class=\"n\">Vb</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sets</span>\n</pre></div>",
        "id": 129738129,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531731094
    },
    {
        "content": "<p>I guess this is already in mathlib somewhere, but I can't find it...</p>",
        "id": 129738131,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531731108
    },
    {
        "content": "<p>It's a filter</p>",
        "id": 129738181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531731179
    },
    {
        "content": "<p>use <code>inter_mem_sets</code></p>",
        "id": 129738191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531731212
    },
    {
        "content": "<p>Johan, what are you working on? I'd like to be sure we don't duplicate efforts.</p>",
        "id": 129738246,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531731334
    },
    {
        "content": "<p>Trying to prove that power_bounded_subring is in fact a subring.</p>",
        "id": 129738353,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531731540
    },
    {
        "content": "<p>You weren't doing something similar, were you?</p>",
        "id": 129738441,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531731672
    },
    {
        "content": "<p>No, I'm working on completions of topological rings</p>",
        "id": 129740202,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531734663
    },
    {
        "content": "<p>I have a continuous map <code>f</code>, a point <code>x</code> and a nhd <code>U</code> of <code>f x</code>. How do I prove that the inverse image of <code>U</code> under <code>f</code> is a nhd of <code>x</code>? That should be in mathlib already, I guess... but I can't find it.</p>",
        "id": 129750955,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531749304
    },
    {
        "content": "<p>Concretely, I have a top ring <code>R</code>, and a nhd <code>U</code> of <code>0 : R</code>. And I want to prove that <code>{u | -u \\in U}</code> is also a nhd of <code>0</code>.</p>",
        "id": 129750979,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531749342
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/topological_structures.lean#L52\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/topological_structures.lean#L52\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/topological_structures.lean#L52</a></p>",
        "id": 129751036,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531749398
    },
    {
        "content": "<p>This is exactly this lemma</p>",
        "id": 129751041,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531749411
    },
    {
        "content": "<p>also why are we using <code>nhds</code> instead of <code>nbhd</code></p>",
        "id": 129751043,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1531749422
    },
    {
        "content": "<p>the filter <code>nhds x</code> is the filter of all neighborhoods of <code>x</code></p>",
        "id": 129751062,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531749459
    },
    {
        "content": "<p>The plural is because it is a filter</p>",
        "id": 129751066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531749462
    },
    {
        "content": "<p><code>nbhds</code>?</p>",
        "id": 129751071,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1531749471
    },
    {
        "content": "<p>I like four letters</p>",
        "id": 129751116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531749492
    },
    {
        "content": "<p>it took me a while to get to the point where I could type <code>nhds</code> on the first try</p>",
        "id": 129751147,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531749555
    },
    {
        "content": "<p>Patrick, thanks. I somehow didn't see how to apply that lemma. I'll try again.</p>",
        "id": 129751363,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531749760
    },
    {
        "content": "<p>Done! And thanks again.</p>",
        "id": 129751576,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531749991
    },
    {
        "content": "<p>After that lemma, you can get to your statement with:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">G</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"bp\">-</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">G</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sets</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">U</span> <span class=\"n\">U_in</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">nhds_zero_symm</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_vmap_sets</span><span class=\"o\">,</span>\n  <span class=\"n\">existsi</span> <span class=\"o\">[</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">U_in</span><span class=\"o\">],</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>but maybe there is a shorter way</p>",
        "id": 129751740,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531750185
    },
    {
        "content": "<p>I just copied part of the proof: <code>apply continuous.tendsto (topological_add_group.continuous_neg R) 0, simpa</code>.</p>",
        "id": 129751916,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531750330
    },
    {
        "content": "<p>Just posting this here to report on what I've tried so far: <a href=\"https://github.com/jcommelin/lean-perfectoid-spaces/blob/power_bounded/src/power_bounded.lean\" target=\"_blank\" title=\"https://github.com/jcommelin/lean-perfectoid-spaces/blob/power_bounded/src/power_bounded.lean\">https://github.com/jcommelin/lean-perfectoid-spaces/blob/power_bounded/src/power_bounded.lean</a></p>",
        "id": 129754628,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531752946
    },
    {
        "content": "<p>Nothing serious done yet...</p>",
        "id": 129754641,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531752958
    },
    {
        "content": "<p>And off to catch a train <span class=\"emoji emoji-1f68b\" title=\"train\">:train:</span></p>",
        "id": 129754690,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531752979
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I proved that power bounded elements form a submonoid, containing 0 and closed under negation.</p>",
        "id": 129806596,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531825196
    },
    {
        "content": "<p>To prove that it is a ring we need extra conditions on the topology. (Powers of 2 are not bounded in <code>\\R</code>.)</p>",
        "id": 129806652,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531825228
    },
    {
        "content": "<p>Do we need the fact that the power bounded elements form a subring? If so, in which generality?</p>",
        "id": 129806657,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531825251
    },
    {
        "content": "<p>I am not 100% convinced that we need that they form a subring (but we definitely need the notion of the set of power-bounded elements). This [power bounded elements are a subring] might be one of those things which is natural to define but which it turns out that we don't logically need. I _do_ know for sure that the only topological rings we care about are Huber rings a.k.a. f-adic rings; these are topological rings <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span> which have an open subring <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> and a finitely-generated ideal <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> such that the induced topology on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">A_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> is the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span>-adic one (see Def 6.1 Wedhorn, p46). In particular <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span> is non-archimedean (definition 5.23 of Huber) and and Wedhorn 5.30(3) is the result in this case. However for perfectoid spaces we only care about Tate rings (def 6.10 p48) and these rings have the property that there's some unit <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">π</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>π</mi><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\pi A_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">π</span><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> is an ideal of definition, i.e. you can assume <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> is principal. In that case <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>=</mo><msub><mi>A</mi><mn>0</mn></msub><mo>[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>π</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A=A_0[1/\\pi]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mrel\">=</span><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">π</span><span class=\"mclose\">]</span></span></span></span> and boundedness just says \"I'm contained in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>π</mi><mrow><mo>−</mo><mi>n</mi></mrow></msup><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\pi^{-n}A_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.921331em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathit mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> for some $n$\". Proofs are probably easier in this case.</p>",
        "id": 129819314,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531841902
    },
    {
        "content": "<p>Ok, then I'll stop working on the power_bounded branch for a while.</p>",
        "id": 129824275,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531848605
    },
    {
        "content": "<p>I had a couple of silly definitions (like ideal_of_definition, etc...) in a Huber_pair branch. I will take a look at those tomorrow, maybe I can turn that into something useful.</p>",
        "id": 129824315,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531848655
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  <a href=\"https://github.com/jcommelin/lean-perfectoid-spaces/blob/Huber_pair/src/adic_space.lean\" target=\"_blank\" title=\"https://github.com/jcommelin/lean-perfectoid-spaces/blob/Huber_pair/src/adic_space.lean\">https://github.com/jcommelin/lean-perfectoid-spaces/blob/Huber_pair/src/adic_space.lean</a> contains some definitions for Huber pairs. Do you think this is useful?</p>",
        "id": 129856374,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531898844
    },
    {
        "content": "<p>I admit that it could use some tidying.</p>",
        "id": 129856377,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531898863
    },
    {
        "content": "<p>So both Patrick and Johan have made me aware of files in their own forks of the perfectoid repo which they've asked for comments on. But I am miles away from this. I (or someone) really needs to understand all these comments made on 3rd July just before the big pause in this thread (which was to a large extent caused by the fact that I knew I'd need to find some time to understand them, and am only just finding this time). </p>\n<p>I now have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">is_valuation</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_zero</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_one</span>  <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_mul</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_add</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>in the root namespace -- is that even right? Is that ever right for a niche notion like this? </p>\n<p>I have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">valuation</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"err\">Γ</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">Hf</span> <span class=\"o\">:</span> <span class=\"n\">is_valuation</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n</pre></div>\n\n\n<p>-- is this supposed to go in the same namespace as <code>is_valuation</code> or it is supposed to be <code>is_valuation.valuation</code>? And am I right in thinking that there's no point putting the square brackets there? I have re-instated the coe to fun:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">H</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>and in an attempt to use type class inference (which I have no idea whether I should be using or not) I have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_valuation</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">Hf</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">valuation</span><span class=\"bp\">.</span><span class=\"n\">Hf</span>\n</pre></div>\n\n\n<p>I am unclear about which one is right or whether I'm supposed to have both. </p>\n<p>I am now attempting to define the \"equivalence classes\" for an equivalence relation that I will never define even though mathematicians talk about it:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">A</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>and I discover that type class inference won't let me do this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"n\">class</span> <span class=\"kn\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n<span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span>\n<span class=\"err\">⊢</span> <span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span>\n</pre></div>\n\n\n<p>The mathematical hold-up with the project is that I need to define what it means for an equivalence class to be a continuous (equivalence class of) valuation(s) so I can work on this, but the above is where I am with the infrastructure issue and as you can see I'm not there yet, and not 100% clear that what I've already done is OK.</p>\n<div class=\"codehilite\"><pre><span></span>\n</pre></div>",
        "id": 129860713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531905421
    },
    {
        "content": "<blockquote>\n<p>in the root namespace -- is that even right? Is that ever right for a niche notion like this? </p>\n</blockquote>\n<p>Well, Wiki knows about 3 mathematical uses for <code>valuation</code>, so I don't think it is very niche. At some point we might need to move it into a namespace, but I don't think we need to worry about that now.</p>",
        "id": 129860942,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531905710
    },
    {
        "content": "<p>And I keep getting confused why type class inference doesn't grab the instance from the local context. I really don't understand that behaviour. Because sometimes it does... and sometimes it doesn't (from my layman's POV).</p>",
        "id": 129861074,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531905877
    },
    {
        "content": "<p>Kevin, of course you can fix it by giving the instance a name, and then writing <code>@valuation _ _ _ foo _ _ A \\Gamma</code> or something like that (didn't check the number of <code>_</code> that you need).</p>",
        "id": 129861179,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531906017
    },
    {
        "content": "<p>I'm not sure this is the universally agreed notion of \"valuation\" though. What's up with that last axiom?</p>",
        "id": 129861356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531906242
    },
    {
        "content": "<p>Oh, wikipedia says you have the inequality backwards</p>",
        "id": 129861376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531906291
    },
    {
        "content": "<p>No?</p>",
        "id": 129861427,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531906350
    },
    {
        "content": "<blockquote>\n<p>v(a + b) ≥ min(v(a), v(b))</p>\n</blockquote>",
        "id": 129861447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531906373
    },
    {
        "content": "<p>That is the additive version</p>",
        "id": 129861454,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531906383
    },
    {
        "content": "<blockquote>\n<p><code>∀ x y, f (x + y) ≤ f x ∨ f (x + y) ≤ f y</code></p>\n</blockquote>",
        "id": 129861463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531906388
    },
    {
        "content": "<p>not the same</p>",
        "id": 129861464,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531906391
    },
    {
        "content": "<p>They add infinity to an additive group. If you scroll down, you get the multiplicative version, with 0 added.</p>",
        "id": 129861475,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531906423
    },
    {
        "content": "<p>I guess at some point we will also have <code>is_add_valuation</code>...</p>",
        "id": 129861526,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531906467
    },
    {
        "content": "<p>Oh, so <code>(f : R → option α)</code> should be <code>(f : R → with_zero α)</code></p>",
        "id": 129861550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531906517
    },
    {
        "content": "<p>Yes the notation is a nightmare. Our valuations should be called seminorms.</p>",
        "id": 129861553,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531906527
    },
    {
        "content": "<p>and yes, option alpha is alpha plus a bottom. option (positive reals) = non-negative reals in this context.</p>",
        "id": 129861557,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531906559
    },
    {
        "content": "<p>If you call it a seminorm, then I think you don't have to worry about naming conflicts at all (-;</p>",
        "id": 129861601,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531906583
    },
    {
        "content": "<p>Huber's decision to call it a valuation is very unfortunate.</p>",
        "id": 129861619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531906608
    },
    {
        "content": "<p>I mention this because mathlib defines like 6 meanings for the none element of option depending on the name</p>",
        "id": 129861620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531906608
    },
    {
        "content": "<p><code>with_zero</code>, <code>with_bot</code>, <code>with_top</code>, <code>with_one</code>,...</p>",
        "id": 129861632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531906623
    },
    {
        "content": "<p>Kenny wrote the code extending &lt;= etc to option alpha before these things existed, I believe</p>",
        "id": 129861648,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531906639
    },
    {
        "content": "<p>and I had trouble using <code>with_top</code> recently; I posted a question about it but I don't think I got any responses.</p>",
        "id": 129861660,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531906671
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/multiset.20min.20on.20with_top\" title=\"#narrow/stream/113488-general/topic/multiset.20min.20on.20with_top\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/multiset.20min.20on.20with_top</a></p>",
        "id": 129861719,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531906721
    },
    {
        "content": "<p>so I'm slightly scared of these things now</p>",
        "id": 129861722,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531906726
    },
    {
        "content": "<blockquote>\n<p>Kevin, of course you can fix it by giving the instance a name, and then writing <code>@valuation _ _ _ foo _ _ A \\Gamma</code> or something like that (didn't check the number of <code>_</code> that you need).</p>\n</blockquote>\n<p>Now the problem moves to</p>\n<div class=\"codehilite\"><pre><span></span>failed to synthesize type class instance for\n⊢ has_le (option Γ)\n</pre></div>\n\n\n<p>because if Gamma is known by type class inference to be a linear_ordered_comm_group then type class inference knows what the le is on option Gamma, but it doesn't.</p>",
        "id": 129862031,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531907171
    },
    {
        "content": "<p>There's some weird way of making all this work with haveI or exactI or something</p>",
        "id": 129862044,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531907195
    },
    {
        "content": "<p>put a <code>by exactI</code> in the middle</p>",
        "id": 129862111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531907319
    },
    {
        "content": "<p>between the instance binder and the definition that uses it</p>",
        "id": 129862118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531907345
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">H</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">valuation</span> <span class=\"n\">A</span> <span class=\"bp\">_</span> <span class=\"err\">Γ</span> <span class=\"n\">H</span><span class=\"err\">Γ</span><span class=\"o\">),</span>\n  <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>Black magic!</p>",
        "id": 129862135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531907401
    },
    {
        "content": "<p>I keep meaning to write some docs on this -- I asked about 5 questions of this nature on the typeclass woes thread but then I didn't write up a coherent summary (I just starred a bunch of messages from Mario) and it still comes back to burn me because I can no longer remember anything which I don't use regularly so I need notes.</p>",
        "id": 129862214,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531907494
    },
    {
        "content": "<p>Thanks Mario.</p>",
        "id": 129862222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531907512
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Would it be possible to use <code>exactI</code> and avoid the explicit mention of <code>H\\Gamma</code>?</p>",
        "id": 129862312,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531907635
    },
    {
        "content": "<p>yes, just move it earlier</p>",
        "id": 129862360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531907663
    },
    {
        "content": "<p>Also, is this something that Lean 4 will fix? So that Kevin's first attempt will just work?</p>",
        "id": 129862363,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531907682
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>definition Spv (A : Type*) [comm_ring A] :=\n{ineq : A → A → Prop // ∃ (Γ : Type*) [HΓ : linear_ordered_comm_group Γ],\n  by exactI ∃ (v : valuation A Γ) ∀ r s : A, ineq r s ↔ v r ≤ v s}\n</pre></div>",
        "id": 129862366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531907692
    },
    {
        "content": "<p><del>No, you still have <code>H\\Gamma</code>.</del> <span class=\"emoji emoji-1f44d\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 129862378,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531907711
    },
    {
        "content": "<p>I have no idea if lean 4 will fix this. It was \"broken on purpose\" by leo</p>",
        "id": 129862438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531907769
    },
    {
        "content": "<p>Does it make sense to add <code>def is_unit (r : R) : Prop := ∃ r' : units R, r = r'.val</code>?</p>",
        "id": 129867159,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531914652
    },
    {
        "content": "<p>Or am I thinking to classical?</p>",
        "id": 129867166,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531914670
    },
    {
        "content": "<p>For reference:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- Scholze : &quot;Recall that a topological ring R is Tate if it contains an</span>\n<span class=\"c1\">-- open and bounded subring R0 ⊂ R and a topologically nilpotent unit pi ∈ R; such elements are</span>\n<span class=\"c1\">-- called pseudo-uniformizers.</span>\n\n<span class=\"n\">def</span> <span class=\"n\">topologically_nilpotent</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span><span class=\"n\">R</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"err\">^</span><span class=\"n\">n</span> <span class=\"err\">∈</span> <span class=\"n\">U</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">r&#39;</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">r&#39;</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">is_pseudo_uniformizer</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">topologically_nilpotent</span> <span class=\"n\">r</span> <span class=\"bp\">∧</span> <span class=\"n\">is_unit</span> <span class=\"n\">r</span>\n</pre></div>",
        "id": 129867232,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531914747
    },
    {
        "content": "<p>I think there is a set for this</p>",
        "id": 129867238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531914772
    },
    {
        "content": "<p>oh, no, there is a set for <code>nonunits</code> though</p>",
        "id": 129867257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531914817
    },
    {
        "content": "<p>Ok, so should I make <code>units_set : set R</code>?</p>",
        "id": 129867304,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531914852
    },
    {
        "content": "<p>You could have <code>pseudo_uniformizer</code> be a property of <code>units R</code></p>",
        "id": 129867323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531914926
    },
    {
        "content": "<p>Ok, that make sense</p>",
        "id": 129867377,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531914992
    },
    {
        "content": "<p>Ok, I finished the definition of pseudo-uniformisers and Tate rings. Nothing deep happening: <a href=\"https://github.com/jcommelin/lean-perfectoid-spaces/blob/Huber_pair/src/adic_space.lean\" target=\"_blank\" title=\"https://github.com/jcommelin/lean-perfectoid-spaces/blob/Huber_pair/src/adic_space.lean\">https://github.com/jcommelin/lean-perfectoid-spaces/blob/Huber_pair/src/adic_space.lean</a></p>",
        "id": 129874533,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1531923893
    },
    {
        "content": "<p>I have not looked at either Johan's or Patrick's commits. I've been concerned today with trying to get valuations right, following the discussion on July 3rd. <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> I now understand what you are saying. I now have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">valuation</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"err\">Γ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_zero</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_one</span>  <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_mul</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_add</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>and a coercion to fun. I refactored a bunch of Kenny's code today. We now finally have a <code>valuation</code> namespace instead of an <code>is_valuation</code> one. </p>\n<p>One technical question I now have <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  : I have now decided to give up on making everything in <code>Type</code>, so I have to choose whether to make <code>R</code> and <code>Gamma</code> live in the same universe <code>u</code> or let one be in <code>u</code> and the other be in <code>v</code>. There was a subtlety in the Jul 3 comments I didn't understand with <code>Spv</code> : my definition of <code>Spv</code> is now</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"o\">],</span>\n  <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>with my two types in the same universe. Do the same ideas (which I don't understand) apply to <code>valuation</code>?</p>",
        "id": 129887843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531937892
    },
    {
        "content": "<p>OK so I have refactored valuations. The valuation spectrum now uses the \"ZFC\" approach -- instead of it being \"equivalence classes\" on an \"equivalence relation\" defined on a class, it's a concrete thing (preorders with some property). I have the correct definition of continuous, the main fundamental theorem about them is sorried (being continuous is constant on equivalence classes), I have a topology on the type of all valuations, and we can put the subspace topology on the continuous valuations. Although I haven't looked at Johan's work yet I am hoping that it will let us easily define Spa(R) for R a Huber pair (it's just continuous valuations which are bounded by 1 on R^+). Although I haven't looked at Patrick's work yet I am hoping that it will easily let us put a presheaf on some \"basic\" open sets in Spa(R) [we need to localise and then complete; Kenny has localised and Patrick is completing]. Then we extend from a basis to the whole space using some limit procedure. That's it. This sorried theorem about continuous valuations is what I will work on next. I can see my way to the end of this now, but my experience with schemes was that there were some things which were far harder to formalise in practice than I had imagined.</p>",
        "id": 129924606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531995859
    },
    {
        "content": "<p>I had no time for Lean yesterday and this morning, but I hope to move on during this afternoon</p>",
        "id": 129926038,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531997918
    },
    {
        "content": "<p>On 3rd July Mario said</p>\n<blockquote>\n<p>If you want to be polymorphic, I suggest writing</p>\n<div class=\"codehilite\"><pre><span></span> <span class=\"n\">def</span> <span class=\"n\">zfc</span><span class=\"bp\">.</span><span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>where the valuation and ring have to share the same universe</p>\n</blockquote>\n<p>I don't understand why these two universes need to be the same. It seems to directly contradict the advice to be as polymorphic as possible. It's a <em>theorem</em> (I think!) that if there exists Gamma of type v such that blah, then there exists Gamma of type u such that blah. The proof (in maths) is \"I only care about the subgroup of Gamma generated by the image of v, which is a function from R to Gamma\". So why don't we do it this way -- with a definition which allows two universes and then a theorem remarking that we could get away with one.</p>",
        "id": 129934215,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532009582
    },
    {
        "content": "<p>because then the definition will have an \"internal universe variable\", and these are always unpleasant to work with</p>",
        "id": 129934289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532009684
    },
    {
        "content": "<p>you will have to write stuff like <code>zfc.Spv.{u v}</code> all the time</p>",
        "id": 129934310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532009716
    },
    {
        "content": "<p>the advice is to be polymorphic in your inputs, and monomorphic in your outputs</p>",
        "id": 129934363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532009767
    },
    {
        "content": "<p>since the valuation or commutative group are not inputs (arguments to the function), they should not involve additional universe variables</p>",
        "id": 129934395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532009827
    },
    {
        "content": "<p>Over 200 lines of code later...</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"o\">],</span>\n  <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>[note both in universe u]</p>\n<p>and its universe-polymorphic constructor</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"err\">Γ</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"mi\">2</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">f</span>\n</pre></div>\n\n\n<p>[note <code>R</code> and <code>Γ2</code> in different universes]. I hope I understood correctly what you said I should do <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  because it's taken hours! I had to prove the universal property for quotient groups! And define quotient abelian groups! I'm trying to be a good student (and avoid Patrick's universe hell). </p>\n<p>I needed decidable equality for <code>R</code> (which ironically will never be true, <code>R</code> is always something like a power series ring over the p-adic numbers) for some intermediate <code>finsupp</code> calculation involving the free abelian group on <code>R</code> (Thanks <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> ).</p>",
        "id": 130068343,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532204394
    },
    {
        "content": "<p>Now to finally get onto what I was supposed to be doing yesterday, which was defining continuous valuations...</p>",
        "id": 130068396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532204480
    },
    {
        "content": "<p>Hopefully you now also have that \"canonical valuation\" you mentioned</p>",
        "id": 130068405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532204507
    },
    {
        "content": "<p>Yes I guess I do.</p>",
        "id": 130068434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532204522
    },
    {
        "content": "<p>Actually, that's a very pertinent comment because it was the fact that I'd not constructed the canonical valuation which was stopping me from defining continuity -- the equiv class is continuous iff the canonical valuation is continuous.</p>",
        "id": 130068461,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532204572
    },
    {
        "content": "<p>I was initially going to do it another way but perhaps I can dodge that now (and run into trouble later on ;-) )</p>",
        "id": 130068472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532204606
    },
    {
        "content": "<p>I had to use the first isomorphism theorem to move my universe. Kind of funny. Basically an elaborate version of the following observation: if <code>G</code> and <code>H</code> are groups in different universes with a map <code>f </code>between them, then <code>G/ker(f)</code> and <code>im(f)</code> are isomorphic, but the latter is in <code>G</code>'s universe and the former in <code>H</code>'s.</p>",
        "id": 130068531,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532204735
    },
    {
        "content": "<p>yep, that's the idea</p>",
        "id": 130068571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1532204769
    },
    {
        "content": "<p>except I had to do it with totally ordered commutative monoids</p>",
        "id": 130068577,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532204796
    },
    {
        "content": "<p>Oh dear there is so much basic stuff about group closures which is not there. Or is it there? Here's what I think I need:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">coset</span>\n<span class=\"c1\">-- and hence group_theory.subgroup -- note this only arrived in mathlib a few weeks ago</span>\n\n<span class=\"c1\">-- for images</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"c1\">-- finsupp for free abelian groups</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finsupp</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- maybe use group.in_closure?</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">closure_image</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">f</span> <span class=\"err\">&#39;&#39;</span> <span class=\"o\">(</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">is_group_hom</span><span class=\"bp\">.</span><span class=\"n\">ker</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"err\">∪</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"c1\">-- don&#39;t know why we need decidable equality -- maybe some finsupp reason</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span><span class=\"err\">₀</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">free_ab_gens</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span><span class=\"err\">₀</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">single</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- do we have to copy out all of the definitions here?</span>\n<span class=\"kn\">definition</span> <span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">add_closure</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"c1\">-- maybe use finsupp.induction?</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">closure_free_gens</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">add_closure</span> <span class=\"o\">((</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">free_ab_gens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>I have to go to bed now and I'm not sure I have time for Lean tomorrow. This is the current hold-up for defining continuous valuations and hence the topological space <code>Spa R</code> associated to a Huber pair.</p>",
        "id": 130075632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532219563
    },
    {
        "content": "<p>I did quotient groups: <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/quotient_group.lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/quotient_group.lean\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/quotient_group.lean</a></p>",
        "id": 130075906,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532220259
    },
    {
        "content": "<p>or at least the stuff I needed</p>",
        "id": 130075911,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532220298
    },
    {
        "content": "<p>Did you use <code>elan toolchain link</code> to create that <code>master</code> version you indicated in the <code>leanpkg.toml</code>? Is it a link to <code>nightly-2018-06-21</code>?</p>",
        "id": 130090336,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532251866
    },
    {
        "content": "<p>I didn't really know what I was doing. I had <code>lean_version = \"3.4.1\"</code> there before, I just changed it manually because I updated my Lean ( knew that <code>group_theory/coset.lean</code> had changed relatively recently and I wanted to be 100% sure I had the correct version because I was thinking of PR-ing my write-up of basic properties of quotient groups). If <code>lean_version</code> is set to <code>3.4.1</code> then I think <code>leanpkg upgrade</code> upgrades to a now-fixed version of mathlib, which is <em>perfect</em> for me and my students, but might not be so ideal for a project which is nearer to the boundaries of mathlib.</p>",
        "id": 130091434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532254222
    },
    {
        "content": "<p>Feel free to change it back</p>",
        "id": 130091435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532254228
    },
    {
        "content": "<p>I created the <code>master</code> link at home and was able to proceed. See also <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/6\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/6\">https://github.com/kbuzzard/lean-perfectoid-spaces/pull/6</a></p>",
        "id": 130092071,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532255686
    },
    {
        "content": "<p>OK so I have a topological space <code>Cont R</code>. I am not sure how usable it will be because some key lemmas about valuations remain unproved.</p>",
        "id": 130246268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532477720
    },
    {
        "content": "<p>Next step is Spa(R) for R a Huber pair. This is easy, except for all the missing things which I've lost track of. <code>is_integral</code> is not defined in <code>for_mathlib/subring.lean</code> -- <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> is this now easy now we have polynomials?</p>",
        "id": 130246618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532478398
    },
    {
        "content": "<blockquote>\n<p>Next step is Spa(R) for R a Huber pair. This is easy, except for all the missing things which I've lost track of. <code>is_integral</code> is not defined in <code>for_mathlib/subring.lean</code> -- <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> is this now easy now we have polynomials?</p>\n</blockquote>\n<p>Right. This shouldn't be hard to do now.</p>",
        "id": 130257814,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1532500013
    },
    {
        "content": "<p>I haven't updated my local copy of the perfectoid project yet (and rebuilds are slow....). But I guess you can just uncomment those lines in <code>subring.lean</code>. Everything looks fine to my eyeball-parse.</p>",
        "id": 130258076,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1532500500
    },
    {
        "content": "<p>Yesterday Kevin complained we don't have fraction fields. Johan, isn't it something you could rather easily do?</p>",
        "id": 130258256,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532500803
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Fraction fields are already in mathlib, in the localization file. (<code>kenny</code> is a wonderful tactic!)</p>",
        "id": 130258285,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1532500872
    },
    {
        "content": "<p>I quote from the bottom of that file:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">quotient_ring</span><span class=\"bp\">.</span><span class=\"n\">field</span><span class=\"bp\">.</span><span class=\"n\">of_integral_domain</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"o\">(</span><span class=\"n\">quotient_ring</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">implementation_follows</span><span class=\"bp\">...</span>\n</pre></div>",
        "id": 130258345,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1532500957
    },
    {
        "content": "<p>Well done Johan! That's efficient.</p>",
        "id": 130258367,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532501001
    },
    {
        "content": "<p>I'm a bit confused by terminology. Is <code>quotient_ring</code> the localization with respect to non-zero elements?</p>",
        "id": 130258416,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532501064
    },
    {
        "content": "<p>The name seems a bit too general.</p>",
        "id": 130258421,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532501080
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">quotient_ring</span> <span class=\"o\">:=</span> <span class=\"n\">loc</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">non_zero_divisors</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 130258567,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1532501309
    },
    {
        "content": "<p>Yes there are definitions but it's the API that's always missing.</p>",
        "id": 130262120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532507263
    },
    {
        "content": "<p>That's how Kevin speaks nowadays <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>",
        "id": 130262638,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532507972
    },
    {
        "content": "<blockquote>\n<p>Yes there are definitions but it's the API that's always missing.</p>\n</blockquote>\n<p>Is Kevin turning into a CS person? It wasn't too long ago he was asking what an “interface” was, and now he's throwing around terms like “API” as if they were second nature.</p>",
        "id": 130262856,
        "sender_full_name": "Sean Leather",
        "timestamp": 1532508297
    },
    {
        "content": "<p>For example there was a definition of quotient group -- but nothing else; I needed that if f:G-&gt;H and g:G-&gt;K and ker(f) was a subset of ker(g) then there was some induced map etc etc, I needed facts about kernels for additive groups and everything was set up for multiplicative groups etc. I've now managed to understand this whole API business. I want my maths students to be able to write maths! In some sense I want their Lean code to look the same as the maths they write on paper, so when I start on formalizing example sheet questions I will take all the \"obvious\" things like 2x=x+x and prove them myself and tell the students what these functions are called (I'll put them all in a xena library and tell them to import it) so they can have the feeling of formalization without having to get bogged down in all the details like I got bogged down when I was solving my own problem sheets last Oct.</p>",
        "id": 130263113,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532508608
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> the quotient group lemmas are in <a href=\"https://github.com/kckennylau/local-langlands-abelian/blob/master/src/quotient_group.lean\" target=\"_blank\" title=\"https://github.com/kckennylau/local-langlands-abelian/blob/master/src/quotient_group.lean\">my local langlands project</a></p>",
        "id": 130263141,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1532508665
    },
    {
        "content": "<p>This is also something I will have to do for my classes next spring. I plan to prepare specialized files to import for each session.</p>",
        "id": 130263150,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532508688
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> the quotient group lemmas are in <a href=\"https://github.com/kckennylau/local-langlands-abelian/blob/master/src/quotient_group.lean\" target=\"_blank\" title=\"https://github.com/kckennylau/local-langlands-abelian/blob/master/src/quotient_group.lean\">my local langlands project</a></p>\n</blockquote>\n<p>We really really need more mathlib PR</p>",
        "id": 130263164,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532508716
    },
    {
        "content": "<blockquote>\n<p>Next step is Spa(R) for R a Huber pair. This is easy, except for all the missing things which I've lost track of. <code>is_integral</code> is not defined in <code>for_mathlib/subring.lean</code> -- <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> is this now easy now we have polynomials?</p>\n</blockquote>\n<p>OK I've got a definition of <code>is_integrally_closed</code>. Just pushing now.</p>",
        "id": 130303814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532554626
    },
    {
        "content": "<p>PS <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> we really do need Lean \"master\" now, or at least mathlib beyond 3.4.1, because I'm using Chris' recent monster polynomial PR (which has been accepted).</p>",
        "id": 130303911,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532554778
    },
    {
        "content": "<p>I don't see the link between Lean master and \"mathlib beyond 3.4.1\"</p>",
        "id": 130303980,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532554838
    },
    {
        "content": "<p>I think that before it said <code>lean_version = \"3.4.1\"</code> and Mario, either intentionally or by accident, has created a branch of mathlib called 3.4.1 and has stopped updating it, which is great for my students because we can all stay on the same version and code that one of them works for another one (they are all running the same version of Lean and mathlib), but is not so great if we want bleeding edge stuff, which we do want here.</p>",
        "id": 130304598,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532555608
    },
    {
        "content": "<p>Oh -- perhaps you're saying that the reason the behaviour has changed for me is not because I've changed <code>lean_version</code> but because I've changed which version of lean i'm actually running?</p>",
        "id": 130304668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532555674
    },
    {
        "content": "<p>mathlib version has nothing to do with Lean version, right?</p>",
        "id": 130304676,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532555693
    },
    {
        "content": "<p>All I know is that when my students type <code>leanpkg upgrade</code> they all upgrade to the same version regardless of when they type it.</p>",
        "id": 130304698,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532555733
    },
    {
        "content": "<p>which is good because new ones arrive (e.g. we've got two new students this week)</p>",
        "id": 130304706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532555751
    },
    {
        "content": "<p>Anyway, how did you get that <code>master</code> toolchain for <code>elan</code>?</p>",
        "id": 130304781,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532555816
    },
    {
        "content": "<p>I just edited the .toml file. I've never used elan. I think I should start -- I now have a situation where I genuinely want to use different versions of Lean for different projects.</p>",
        "id": 130305339,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532556575
    },
    {
        "content": "<p>Oh, so maybe that's why it doesn't work the same here.</p>",
        "id": 130305402,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532556634
    },
    {
        "content": "<p>Why don't you merge <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/7\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/7\">https://github.com/kbuzzard/lean-perfectoid-spaces/pull/7</a>?</p>",
        "id": 130306015,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532557555
    },
    {
        "content": "<p>Thanks to crucial help from Johannes, I was able to unlock <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L226\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L226\">\"completions of products are products of completions\" </a>. With some more effort and much help from the <code>change</code> tactic I also proved the <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L238\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/completion.lean#L238\">lifting property</a> of this isomorphism (basically it does what it should to elements present before completion). Then I made a huge push and unsorried <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean#L261\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean#L261\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean#L261</a>. It means that every topological abelian group G now has a Hausdorff completion which is an abelian group, and the map from G to its completion is a group morphism. Next step is to prove some more properties and push to rings.</p>",
        "id": 130375846,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532645350
    },
    {
        "content": "<p>So I have a topological space Spa(R,R+) [in the sense that I have an unsorried definition in Lean, where (R,R+) is a Huber pair), and I want to put a sheaf on it. Its global sections are the completion of R; R is a commutative topological ring and, thought of as an abelian group, a basis of neighbourhoods of zero for the topology is induced by a (countable, if this matters) decreasing family of subgroups. More generally its sections on some appropriate opens are completions of other such rings. If I have the sections on the appropriate opens I can get the sheaf on all opens by some direct limit procedure, and then we have affinoid pre-adic spaces. The hard work in schemes was then to prove that this presheaf was a sheaf -- but this is not true in this generality, because completeness is quite a poorly-behaved functor when it comes to algebraic properties (unlike localisation it doesn't preserve exactness), so an affinoid adic space is simply <em>defined</em> to be a preadic space for which the presheaf is a sheaf. An adic space is something glued from affinoid adic spaces, and a perfectoid space is an adic space glued from affinoids built from (R,R+) which are perfectoid rings. The end is in sight!</p>\n<p>So given a topological ring with the topology defined by a collection of additive subgroups, how do I complete it? Will you push to my repo?</p>",
        "id": 130391508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532672257
    },
    {
        "content": "<p>Of course I will PR to your repo. I can do it now if you want but, as explained yesterday, there is still work to be done</p>",
        "id": 130395480,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532678959
    },
    {
        "content": "<p>I worked a bit this morning, but I'm stuck in type class inference hell, and it's lunch time. See <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean#L366\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean#L366\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean#L366</a></p>",
        "id": 130402876,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532689215
    },
    {
        "content": "<p>This instance should be a trvial consequence of the previous one, but suddenly Lean doesn't find the relevant intermediate type classes instances.</p>",
        "id": 130402893,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532689299
    },
    {
        "content": "<p>But I do have the universal mapping property of completions of abelian topological groups modulo <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean#L200\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean#L200\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean#L200</a> claiming that continuity of group morphisms implies uniform continuity (there I'm not stuck, I haven't found time to try yet)</p>",
        "id": 130402954,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532689407
    },
    {
        "content": "<p>I'm done with uniform continuity to continuous (abelian) group morphisms. But I'd be really grateful if someone can sort out the type class inference hell at the end of <a href=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean\" target=\"_blank\" title=\"https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean\">https://github.com/PatrickMassot/lean-perfectoid-spaces/blob/completions/src/for_mathlib/topological_structures.lean</a></p>",
        "id": 130408236,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532695889
    },
    {
        "content": "<p>I'm afraid I can't minimize this, it's precisely the complexity of type classes that triggers the issue. But feel free to clone and fix, I need to go back to real world for a while.</p>",
        "id": 130408302,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532695964
    },
    {
        "content": "<p>Johannes explained the source of my trouble. I have an interesting diamond here. I have an instance saying that every abelian topological group is a uniform space. Another one says every completion of a uniform space is a uniform space. And the last one says the completion of an abelian topological group is an abelian topological group. Question: what is the uniform space structure on the completion of an abelian topological group? The completion one or the group one?</p>",
        "id": 130417136,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532705157
    },
    {
        "content": "<p>Are they (non-definitionally) equal? Presumably! Maybe use some cool priority trick ;-)</p>",
        "id": 130419183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532706916
    },
    {
        "content": "<p>Of course there are equal, <code>by otherwise_we_would_know_it</code>. But there certainly not definitionally equal. I'll see if I can get around that. But my family will return from vacation in a couple of minutes, so I may slow down a bit on the Lean side (I was alone at home for the past two weeks).</p>",
        "id": 130426702,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532714895
    },
    {
        "content": "<p>You should prove a theorem that the two instances are equal and add it to the type class inference system in some way that's presumably impossible. You should decide which instance you prefer and give it a higher priority. Let the system carry around both proofs and if your favourite one doesn't pan out then we can try the other one</p>",
        "id": 130438821,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532729544
    },
    {
        "content": "<p>OK so the perfectoid library currently compiles, with some sorries, and I want to spend some time today trying to figure out what we need to do next. I'd be happy to accept WIP PR's as long as they compile (sorrys are fine). Johan did PR something but I screwed up the merge and just rewrote history so it never happened.</p>",
        "id": 130465792,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532781502
    },
    {
        "content": "<p>I feel like a bunch of things need refactoring but I'm worried I'll screw up everyone's forks if I start moving stuff around.</p>",
        "id": 130466055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532782089
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Currently <code>adic_space.lean</code> is just a dumping ground for everything which hasn't got a proper file to live in. We need a file <code>Spa.lean</code> containing the definition of Spa of a Huber pair, and perhaps a file <code>Huber_pair.lean</code> containing basic definitions of Huber rings, Huber pairs and things like bounded subsets and power-bounded elements. If I make all this refactoring before I accept your PRs then you will both have messes to tidy up, right? Currently all these definitions are in <code>adic_space.lean</code>.</p>",
        "id": 130466968,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1532783550
    },
    {
        "content": "<p>No problem with me. All my work is in files independant from <code>adic_space.lean</code></p>",
        "id": 130484907,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532806857
    },
    {
        "content": "<p>I'm also fine with this. If I have any mess to tidy up, it won't be too huge.</p>",
        "id": 130484954,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1532806926
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/10\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/10\">https://github.com/kbuzzard/lean-perfectoid-spaces/pull/10</a></p>",
        "id": 130607206,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1532988167
    },
    {
        "content": "<p><a href=\"https://mathoverflow.net/questions/65729/what-are-perfectoid-spaces#307239\" target=\"_blank\" title=\"https://mathoverflow.net/questions/65729/what-are-perfectoid-spaces#307239\">https://mathoverflow.net/questions/65729/what-are-perfectoid-spaces#307239</a></p>",
        "id": 130638624,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533038006
    },
    {
        "content": "<p>Patrick -- somewhere you asked how close we were to actually finishing this project. I'm on holiday at the minute so I have time for this sort of thing (I implored my xena students to bother me with questions but of course inevitably things are less busy than when I'm spending about 20 hours a week in the same room as them). I tried to just finish the job, as it were, and the main thing that is left now is the definition of the presheaf on Spa(A). This is a multi-stage process. The first stage is to locate some \"nice\" open sets (analogous to the basic open sets D(f) in Spec(A)) and to define the presheaf on these. To do that we need to show that the completion of a topological commutative ring is a topological commutative ring. To define the restriction maps we'll need some commutative algebra, which I had a superficial look at and decided it shouldn't be too bad, plus the universal property of completions (we will have a ring map B -&gt; C and we'll want to extend it to B-hat -&gt; C-hat). This gives the presheaf defined on these nice open sets. We then want to extend to all open sets via some limit procedure and this should hopefully be easy. Then that's pretty much it, as far as the definition goes. Thanks a lot for your work on completions. I now feel like I know enough about uniform spaces to understand what is going on in these files -- I spent the last 24 hours or so trying to understand all this basic maths that's in Lean which I was never taught and of course now I've done it I just realise that I should have done it much earlier instead of whingeing about how I didn't understand all this uniform stuff.</p>",
        "id": 130936504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533486052
    },
    {
        "content": "<p>Thanks Kevin. I'm still slowly working on completions when  I'm not at the beach. There are a couple of things I need to figure out, on the mathematical side, and then explain to Lean. But you can easily sorry the desired properties and keep going.</p>",
        "id": 130942351,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533499477
    },
    {
        "content": "<p>Of course I agree we should have learned about filters and uniform spaces earlier this year. Now I'm getting used to them. Of course knowing how to translate everything back to sets and topology is only the beginning. Unwrapping all definitions before doing anything else only brings chaos. You really need to use all those lemmas about direct and inverse image of filters. For instance, the proof I'm trying to wrap up right now begins with </p>\n<div class=\"codehilite\"><pre><span></span> <span class=\"n\">rw</span> <span class=\"n\">uniformity_eq_vmap_nhds_zero</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">prod_map_map_eq</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">map_le_iff_le_vmap</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">map_map</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">prod_vmap_vmap_eq</span><span class=\"o\">,</span><span class=\"bp\">```</span>\n</pre></div>",
        "id": 130942514,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533499914
    },
    {
        "content": "<p>I keep it that way instead of one <code>rw</code> because I still want to be able to see what each of them does</p>",
        "id": 130942560,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533500004
    },
    {
        "content": "<p>You can still see what each one does if you put them in a <code>[ , , ]</code> list</p>",
        "id": 130942652,
        "sender_full_name": "Reid Barton",
        "timestamp": 1533500176
    },
    {
        "content": "<p>Really?</p>",
        "id": 130942656,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533500188
    },
    {
        "content": "<p>In emacs at least</p>",
        "id": 130942666,
        "sender_full_name": "Reid Barton",
        "timestamp": 1533500236
    },
    {
        "content": "<p>Indeed!</p>",
        "id": 130942716,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533500309
    },
    {
        "content": "<p>Thanks for the tip!</p>",
        "id": 130942717,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533500316
    },
    {
        "content": "<p>It's just more of a pain because you have to do more precise clicking rather than just moving the cursor up and down :-)</p>",
        "id": 130945352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533506216
    },
    {
        "content": "<p>regarding multiple rewrites and unfolding -- yes, I learnt from working with multisets that random unfolding is often not the right thing to do :-) But Johannes [and sometimes Mario] wrote all this stuff and I am now beginning to appreciate the art of it all; it would not surprise me if everything were there, once you have got the hang of how to think about these things...</p>",
        "id": 130945458,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533506418
    },
    {
        "content": "<p>I don't know what you mean by \"it would not surprise me if everything were there\" but I can tell you that there were nothing about  uniform structures on  topological groups, and that's quite a bit of maths</p>",
        "id": 130945670,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533506950
    },
    {
        "content": "<p>Oh!</p>",
        "id": 130945713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533507035
    },
    {
        "content": "<p>Uniform continuity is overrated. Remember you can build the completion of a commutative topological group by extending the addition by continuity. The result is continuous because addition is uniformly continuous. When going for rings, things are more complicated because multiplication is not uniformly continuous (even on real numbers). But uniform continuity is an overly expensive way to assume that Cauchy filters go to Cauchy filters. And bilinearity is enough to ensure this, as explained in <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/11/files#diff-83f5ebe2bcf6329ac3366ea2deb7848dR70\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/11/files#diff-83f5ebe2bcf6329ac3366ea2deb7848dR70\">https://github.com/kbuzzard/lean-perfectoid-spaces/pull/11/files#diff-83f5ebe2bcf6329ac3366ea2deb7848dR70</a></p>",
        "id": 131134402,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533764756
    },
    {
        "content": "<p>This is by far the most subtle theorem I ever explained to Lean, and the proof is about 170 lines long. Actually this is typically the kind of subtle proof where I love that Lean can tell me I didn't miss anything, although I would prefer if formalizing this proof were easier.</p>",
        "id": 131134458,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533764831
    },
    {
        "content": "<p>I haven't yet applied this theorem to the case of multiplication, but it should immediately imply extension to the Cauchy filter space. Then I'll need to see what happens to the separation relation (Bourbaki first gets rid of the separation issue and then completes, so things are a bit different).</p>",
        "id": 131134525,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533764935
    },
    {
        "content": "<p>I did prove that, before Cauchyfication, the separation relation is <code>x - y ∈ closure ({0} : set G)</code></p>",
        "id": 131134640,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533765109
    },
    {
        "content": "<p>Kevin, I'd be very interested to know if you can read this big proof of extension of bilinear stuff. It's clearly not in the category \"this is trivial hence the proof must be obfuscated\".</p>",
        "id": 131134696,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533765166
    },
    {
        "content": "<p>I think <code>neg_left</code> follows from <code>add_left</code>, right? A Z-linear map between abelian groups just satisfies f(x+y)=f(x)+f(y) and you can deduce everything else from that.</p>",
        "id": 131134769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533765269
    },
    {
        "content": "<p>I wrote that part <em>very</em> quickly</p>",
        "id": 131134791,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533765317
    },
    {
        "content": "<p>You proved Z-bilinear maps on dense subgroups extend uniquely. Presumably also Z-linear maps on dense subgroups extend uniquely. Can you deduce the bilinear case from the linear case? If not, then will we need some trilinear version some day?</p>",
        "id": 131135055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533765675
    },
    {
        "content": "<p>Bourbaki states it that way, presumably this generality is good enough for a number of things</p>",
        "id": 131135125,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533765760
    },
    {
        "content": "<p>It's hard to read. I mean, it's not impossible, because I can see what every line does, but I look at it and I think \"I'd rather be reading GT for sure\". I certainly didn't get to the end of it.</p>",
        "id": 131135326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533766077
    },
    {
        "content": "<p>Too many filters :-)</p>",
        "id": 131135371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533766088
    },
    {
        "content": "<p>Don't forget that most filter-fu is hidden in the lemma I posted here yesterday <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/continuity.lean#L82\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/continuity.lean#L82\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/continuity.lean#L82</a></p>",
        "id": 131135395,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533766148
    },
    {
        "content": "<p>which has been taken out of the main proof</p>",
        "id": 131135405,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533766169
    },
    {
        "content": "<p>And I see what you mean about all those instances! What can you do about that? </p>\n<div class=\"codehilite\"><pre><span></span>_inst_12 : topological_space A,\n_inst_13 : add_comm_group A,\n_inst_14 : topological_add_group A,\n</pre></div>\n\n\n<p>because of the way the typeclasses work, and you have five of these, so you've already just lost 15 lines the output window.</p>",
        "id": 131135410,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533766175
    },
    {
        "content": "<p>and I was even worse in the beginning, because I followed Bourbaki and assumed E and F were complete Hausdorff</p>",
        "id": 131135476,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533766217
    },
    {
        "content": "<p>Btw this is a great use of Lean: I proved the theorem but thought those hypotheses were useless. Then I removed the hypotheses and Lean was still happy.</p>",
        "id": 131135504,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533766262
    },
    {
        "content": "<p>No need to go through the proof to triple check I wasn't implicitly using them</p>",
        "id": 131135519,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533766292
    },
    {
        "content": "<p>Now I try to apply this lemma to <code>A</code> inside <code>Cauchy A</code> and get into class resolution hell. It's time to go to bed.</p>",
        "id": 131135586,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533766346
    },
    {
        "content": "<p>I know exactly what you mean about the satisfaction of going through this sort of a proof and at the end knowing <em>for sure</em> that you've dotted all the i's and crossed all the t's -- I mean, maybe not 100% sure, but I'm not even sure I operate at 99% accuracy with pencil and paper whereas I feel like I'm operating at 99.999% accuracy here.</p>",
        "id": 131135596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533766360
    },
    {
        "content": "<blockquote>\n<p>It's hard to read. I mean, it's not impossible, because I can see what every line does, but I look at it and I think \"I'd rather be reading GT for sure\". I certainly didn't get to the end of it.</p>\n</blockquote>\n<p>You should read GT, but really it took me Lean to understand it's much more subtle that I originally thought.</p>",
        "id": 131135615,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533766398
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">δ</span> <span class=\"err\">∘</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)),</span> <span class=\"n\">φ</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">φ</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n      <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">clear</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n</pre></div>\n\n\n<p>You know you can do stuff like <code>rw (show blah, from refl)</code>?</p>",
        "id": 131135781,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533766624
    },
    {
        "content": "<p>You seem to be saying that the proof is <em>not</em> \"just follow your nose\". Even that I find interesting -- if you'd asked me to guess beforehand, I would have suggested that it's just one of those proofs where anyone could work it out given enough paper and time by just heading slowly and surely towards the goal.</p>",
        "id": 131135859,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533766783
    },
    {
        "content": "<p>There are epsilon/4's :-)</p>",
        "id": 131135992,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1533766952
    },
    {
        "content": "<p>Would have you guessed the role of <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/complete_groups.lean#L206\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/complete_groups.lean#L206\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/complete_groups.lean#L206</a>?</p>",
        "id": 131136011,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533767006
    },
    {
        "content": "<p>I'm not saying this is super difficult or deep. But this is far beyond anything I wrote in Lean.</p>",
        "id": 131136023,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533767034
    },
    {
        "content": "<p>This epsilon/4 is exactly the key formula trick</p>",
        "id": 131136094,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533767121
    },
    {
        "content": "<p>But all the subtlety comes from constantly going back and forth between the dense subgroups and the ambient groups</p>",
        "id": 131136104,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533767162
    },
    {
        "content": "<p>using limits in the subgroup for the filter induced from the neighborhood filter of a point <em>not</em> in the subgroup</p>",
        "id": 131136155,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533767197
    },
    {
        "content": "<p>Now I'll sleep.</p>",
        "id": 131136174,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1533767238
    },
    {
        "content": "<p>By the way, <a href=\"https://mathoverflow.net/questions/65729/what-are-perfectoid-spaces#307239\" target=\"_blank\" title=\"https://mathoverflow.net/questions/65729/what-are-perfectoid-spaces#307239\">https://mathoverflow.net/questions/65729/what-are-perfectoid-spaces#307239</a> is now  the second answer, with 27 upvotes!</p>",
        "id": 131220048,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1533883650
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/15\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/15\">https://github.com/kbuzzard/lean-perfectoid-spaces/pull/15</a></p>",
        "id": 133069116,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535644955
    },
    {
        "content": "<p>Posting on Zulip is a much better strategy for letting me know about PR's :-)</p>",
        "id": 133069232,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535645088
    },
    {
        "content": "<p>Oh, maybe I know how to fix this -- I have to follow my own repo or something.</p>",
        "id": 133069237,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535645099
    },
    {
        "content": "<p>Thanks for the PR's Johan and Patrick. I'm going to spend some time today seeing what compiles and what doesn't. After our conversation last Tues I'm tempted to start sorrying theorems we need if they properly belong in \"standard Masters level commutative algebra\" (whatever that means) and see what actually needs doing. I had planned on doing this sort of thing in Paris but in practice I spent Monday and Tuesday evening doing admin :-(</p>",
        "id": 133210528,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535883401
    },
    {
        "content": "<p>The units of a ring <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> are traditionally denoted <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^\\times</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.771331em;\"></span><span class=\"strut bottom\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^*</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.688696em;\"></span><span class=\"strut bottom\" style=\"height:0.688696em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> (I prefer the former). Is there a unicode \"small cross\" character which we can use as postfix notation, like the power-bounded subring notation <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>R</mi><mo>∘</mo></msup></mrow><annotation encoding=\"application/x-tex\">R^\\circ</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∘</span></span></span></span></span></span></span></span></span></span></span> which we already are using?</p>",
        "id": 133212852,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535889119
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> In <code>for_mathlib/quotient_group.lean</code> there is <code>local attribute [instance] left_rel normal_subgroup.to_is_subgroup</code> and I have <code>unknown declaration 'left_rel'</code>. Do you know what this is?</p>",
        "id": 133213085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535889667
    },
    {
        "content": "<p>On the next line I have <code>unknown identifier 'left_cosets'</code> -- <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> is this called something else now? I have the current mathlib.</p>",
        "id": 133213087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535889710
    },
    {
        "content": "<p><code>left_rel</code> seems to be still here: <a href=\"https://github.com/leanprover/mathlib/blob/master/group_theory/coset.lean\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/group_theory/coset.lean\">https://github.com/leanprover/mathlib/blob/master/group_theory/coset.lean</a></p>",
        "id": 133213743,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535891168
    },
    {
        "content": "<p>it's <code>quotient_group.left_rel</code> now</p>",
        "id": 133213795,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1535891290
    },
    {
        "content": "<p>about units, at worse we could use <a href=\"https://github.com/leanprover/vscode-lean/blob/master/translations.json#L1698\" target=\"_blank\" title=\"https://github.com/leanprover/vscode-lean/blob/master/translations.json#L1698\">https://github.com/leanprover/vscode-lean/blob/master/translations.json#L1698</a></p>",
        "id": 133214046,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535891881
    },
    {
        "content": "<p>kenny is that a no?</p>",
        "id": 133214243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535892327
    },
    {
        "content": "<p>no, that's the unit symbol that he proposed</p>",
        "id": 133214343,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1535892574
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> am I doing something wrong? Many files in <code>for_mathlib</code> in the perfectoid repo now clash with files in mathlib. This is presumably because things got merged. But because I don't know exactly what is merged and what isn't, I am not entirely sure what I am doing. For example there is a file <code>for_mathlib/quotient_group.lean</code> which is apparently copyright you and me, and then there is also a file in mathlib called <code>group_theory/quotient_group.lean</code> which is also apparently copyright you and me, looks quite different (they seem to share a function <code>lift_mk</code> but  not too much else...). Am I now supposed to delete <code>for_mathlib/quotient_group.lean</code> and change all the imports in all the other files? I am fine doing this, I just wanted to check I'm not doing something stupid. I know there are plenty of sorrys in the project it but when I try to build it I currently get plenty of errors too.</p>",
        "id": 133224672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535914104
    },
    {
        "content": "<blockquote>\n<p>looks quite different</p>\n</blockquote>\n<p>This is usually the way these things go. It's been rewritten two or three times by now</p>",
        "id": 133224733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535914229
    },
    {
        "content": "<p>Now that it is merged, your job is to adjust your repo to the changes. If there are any difficulties that arise, ask, since there may be a trick, or the mathlib version may need more adjustment given your needs</p>",
        "id": 133224745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535914316
    },
    {
        "content": "<p>One of the invariants I try to maintain in mathlib changes is that anything you can do in a previous version of mathlib or using a PR that was merged but modified to unrecognizability, should still be possible and at most epsilon harder (ideally it should be either much easier or about the same)</p>",
        "id": 133224844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1535914474
    },
    {
        "content": "<p>Thanks for the explanations. This didn't happen so much with the schemes project because we just filled up <code>for_mathlib</code> on the whole. Anything that got PR'ed was done by Kenny and Kenny dealt with these issues when they arose.</p>",
        "id": 133224974,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535914780
    },
    {
        "content": "<p>I'm sorry, I did some cleanup related to mathlib update, but I didn't finish the job. I got distracted by the issue is the ramified condition, hence couldn't go all the way to make it compile again. Is it ok now?</p>",
        "id": 133226760,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535918558
    },
    {
        "content": "<p>It's better than it was. I see what needs to be done but have not had the time to do it yet. I feel like there's such momentum with the Noetherian stuff that I want to do some more of that. Kenny pointed out a proof of integral closure being a subring which didn't need Noetherian hypotheses and went via some lemma in Atiyah--Macdonald, but this one needs Cayley-Hamilton which we don't have either. I'm sure I saw a write-up by someone (Gonthier?) explaining how this was done in Coq -- or am I confusing this with det(AB)=det(A)det(B)? Is it in the big operators paper?</p>",
        "id": 133228903,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535923218
    },
    {
        "content": "<blockquote>\n<p>Is it in the big operators paper?</p>\n</blockquote>\n<p>Yes, looks like it's in <a href=\"https://hal.inria.fr/inria-00331193/document\" target=\"_blank\" title=\"https://hal.inria.fr/inria-00331193/document\">section 6.2</a>.</p>",
        "id": 133228954,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1535923344
    },
    {
        "content": "<p>Thanks. <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> how far are we from this? <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> are you interested in doing it? I am going to push on with the Noetherian proof even though it needs Hilbert basis, because Noetherian stuff is so important in general that it should be in mathlib. </p>\n<p>It's worth remarking that algebra is coming on in leaps and bounds (encroaching on Masters level stuff, and there's all this Zariski topology stuff in the schemes repo too), and we still don't have the definition of exp(x) or the derivative of a differentiable function.</p>",
        "id": 133229011,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535923531
    },
    {
        "content": "<p>Keji proved it. I might sort it out, but there's a lot of lean things I have going on to finish off.</p>",
        "id": 133229054,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1535923620
    },
    {
        "content": "<p>I know Keji did det(AB)=det(A)det(B) -- he did C-H too?</p>",
        "id": 133229106,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535923711
    },
    {
        "content": "<p>Kenny might do a really good job of making it all mathlib-ready -- he likes to have other people planning the code out first :-)</p>",
        "id": 133229107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535923731
    },
    {
        "content": "<p>He didn't do Cayley Hamilton</p>",
        "id": 133229116,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1535923765
    },
    {
        "content": "<p>It's pretty much the next thing in the paper after det(AB)=det(A)det(B) :-)</p>",
        "id": 133229160,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535923818
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, perhaps \"read-the-effing-repository\" is the answer, but in your schemes project did you construct any examples? e.g. just a topological space as Spec C(X)? I'm trying to set up filtered colimits in such a way that it's actually possible to describe the stalk of a sheaf in practice, and not enjoying it. :-)</p>",
        "id": 133230907,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1535928067
    },
    {
        "content": "<p>No, we are proud to be example free. But if you give me a commutative ring then I can give you an affine scheme plus proof it's a scheme so in some sense we have examples</p>",
        "id": 133231085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535928484
    },
    {
        "content": "<p>Out of curiosity, what would e.g. Spec <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"bold\">C</mi></mrow><mo>[</mo><mi>x</mi><mo>]</mo><mi mathvariant=\"normal\">/</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbf{C}[x]/(x^2)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbf\">C</span></span><span class=\"mopen\">[</span><span class=\"mord mathit\">x</span><span class=\"mclose\">]</span><span class=\"mord mathrm\">/</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> look like in lean?</p>",
        "id": 133231523,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1535929531
    },
    {
        "content": "<p>It looks like a topological space with a sheaf of rings, like every other scheme. I'm not sure I understand the question :-)</p>",
        "id": 133248288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535964143
    },
    {
        "content": "<p>it looks like a point</p>",
        "id": 133248503,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1535964474
    },
    {
        "content": "<p>Also in Lean? <span class=\"emoji emoji-1f61c\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 133248552,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1535964502
    },
    {
        "content": "<p>it looks like a bunch of code in Lean</p>",
        "id": 133248558,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1535964521
    },
    {
        "content": "<p>Is there a <code>looks_like</code> predicate?</p>",
        "id": 133248562,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1535964528
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">k_epsilon</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">Spec</span> <span class=\"o\">(</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">*</span><span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span><span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">))</span>\n</pre></div>",
        "id": 133248643,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1535964624
    },
    {
        "content": "<p>Something like that?</p>",
        "id": 133248645,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1535964629
    },
    {
        "content": "<p>Sorry for the vague question, I was curious what the code defining it would look like.</p>",
        "id": 133255737,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1535975491
    },
    {
        "content": "<p>I have a function <code>Spec</code> from commutative rings to schemes which works for any commutative ring</p>",
        "id": 133255800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535975532
    },
    {
        "content": "<p>I guess that's not entirely true. Spec goes from commutative rings to types</p>",
        "id": 133255851,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535975619
    },
    {
        "content": "<p>Huge cleanup in <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/16\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/16\">https://github.com/kbuzzard/lean-perfectoid-spaces/pull/16</a></p>",
        "id": 133268730,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535991547
    },
    {
        "content": "<p>We are compiling against current mathlib</p>",
        "id": 133268738,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535991573
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I had to sorry away your <code>is_integral</code> definition which needs fixing</p>",
        "id": 133268801,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535991608
    },
    {
        "content": "<p>Ok, but that shouldn't be hard.</p>",
        "id": 133268808,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1535991626
    },
    {
        "content": "<p>it's currently in Huber_pair since for_mathlib/subring was blasted</p>",
        "id": 133268827,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535991684
    },
    {
        "content": "<p><code>valuation_spectrum.lean</code> length was almost divided by two</p>",
        "id": 133268884,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535991726
    },
    {
        "content": "<p>In a couple of days it can move to <code>integral_closure.lean</code> in mathlib... if the noetherian momentum keeps going.</p>",
        "id": 133268889,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1535991731
    },
    {
        "content": "<p>that's partly why I didn't care too much</p>",
        "id": 133268898,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1535991755
    },
    {
        "content": "<p>For integral closure the main thing we need now is Hilbert basis, which should be really nice to prove. Then the quotient thing should give that rings finitely-generated over a Noetherian ring are finitely-generated, and then we have one of the two proper maths proof of integral closure done. I might just try Hilbert basis now; I haven't written any Lean code for ages, it's really nice to be able to get back to it.</p>",
        "id": 133269462,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535992632
    },
    {
        "content": "<p>Patrick -- many thanks for fixing up the repo.</p>",
        "id": 133269465,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1535992643
    },
    {
        "content": "<p>So, to get the <code>is_integral</code> stuff working we will need some form of <code>polynomial.map</code> or <code>eval\\2</code>.</p>",
        "id": 133270365,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1535994109
    },
    {
        "content": "<p>I currently don't have much time for Lean, alas...</p>",
        "id": 133270403,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1535994126
    },
    {
        "content": "<p>But I think it is best if the <code>eval\\2</code> from <code>mv_polynomial</code> gets a little brother for univariate polynomials.</p>",
        "id": 133270410,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1535994158
    },
    {
        "content": "<p>This might be a nice project to experiment with transfer rules.</p>",
        "id": 133270411,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1535994177
    },
    {
        "content": "<p>(Unless this has malign computational ramifications; about which I know no-thing.)</p>",
        "id": 133270418,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1535994216
    },
    {
        "content": "<p>Kevin, you should carefully review the new <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/702f50b9bb1951626a10cb5098415c002f719c35/src/valuation_spectrum.lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/702f50b9bb1951626a10cb5098415c002f719c35/src/valuation_spectrum.lean\">valuation_spectrum.lean</a>. I tried to write something equivalent to what was there, but I didn't try to make sure I understood the math</p>",
        "id": 133275596,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536003097
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, I wrote a draft of a roadmap for getting a simple example of an affine scheme into <code>mathlib</code>.</p>\n<p>It's at <a href=\"https://github.com/semorrison/lean-category-theory/blob/master/schemes_roadmap.md\" target=\"_blank\" title=\"https://github.com/semorrison/lean-category-theory/blob/master/schemes_roadmap.md\">https://github.com/semorrison/lean-category-theory/blob/master/schemes_roadmap.md</a></p>",
        "id": 133287065,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536027077
    },
    {
        "content": "<p>I suspect some things on the list already exist, and I would love to have pointers to these.</p>",
        "id": 133287069,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536027098
    },
    {
        "content": "<p>Perhaps <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> can PR (co)products of (commutative) (topological) rings into mathlib?</p>",
        "id": 133287115,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536027156
    },
    {
        "content": "<p>and/or filtered (or just direct) colimits of (commutative) (topological) rings?</p>",
        "id": 133287116,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536027181
    },
    {
        "content": "<p>A while ago I tried proving that the forgetful functor <code>CommRing ⥤ Type u</code> is represented by <code>ℤ[x]</code> (i.e. this just says that ring homomorphisms <code>ℤ[x] ⟶ R</code> are the same as elements of <code>R</code>), but got frustrated dealing with polynomials. I think we now have much better polynomials, and perhaps I can tempt someone who has worked with them into showing this fact. (<span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>?).</p>",
        "id": 133287172,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536027315
    },
    {
        "content": "<p>It's not strictly necessary for the shortest path on the roadmap, however.</p>",
        "id": 133287174,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536027330
    },
    {
        "content": "<blockquote>\n<p>A while ago I tried proving that the forgetful functor <code>CommRing ⥤ Type u</code> is represented by <code>ℤ[x]</code> (i.e. this just says that ring homomorphisms <code>ℤ[x] ⟶ R</code> are the same as elements of <code>R</code>), but got frustrated dealing with polynomials. I think we now have much better polynomials, and perhaps I can tempt someone who has worked with them into showing this fact. (<span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>?).</p>\n</blockquote>\n<p>I actually proved that A[X] is the universal A-algebra... in my langlands repo</p>",
        "id": 133291784,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536037400
    },
    {
        "content": "<p>but it's actually easy to prove</p>",
        "id": 133291789,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536037408
    },
    {
        "content": "<p>Could you PR it in usable form?</p>",
        "id": 133294149,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536042245
    },
    {
        "content": "<p>maybe ignore my comment about langlands repo</p>",
        "id": 133294245,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536042481
    },
    {
        "content": "<p>I was lazy with locally ringed spaces. I knew that it was a theorem (in real life, not in mathlib) that Spec(R) was a locally ringed space, so any ringed space which was covered by affine schemes had to be locally ringed, it seemed to me. So I skipped the definition.</p>",
        "id": 133295147,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536044067
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_space.lean#L944\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_space.lean#L944\">https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_space.lean#L944</a></p>",
        "id": 133295150,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536044075
    },
    {
        "content": "<p>this is on the list</p>",
        "id": 133295166,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536044118
    },
    {
        "content": "<p>We should probably start a new thread if you want to discuss this list, this is not directly about the perfectoid project</p>",
        "id": 133295172,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536044142
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110524\">@Scott Morrison</span> That's a really nice list! But I agree it might be better to discuss this in a new thread.</p>",
        "id": 133297866,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536048889
    },
    {
        "content": "<p>I think we should build monoid rings</p>",
        "id": 133299021,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536050687
    },
    {
        "content": "<p>and then make mv_polynomial a special case</p>",
        "id": 133299022,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536050693
    },
    {
        "content": "<p>I think monoid rings are a great idea. I have group cohomology on my todo list -- I think it would be really nice to do in Lean, even though I don't have the time to take it on right now. Monoid and group rings are the start of this. Then some nonsense commutative algebra about ext and tor which would be probably quite fun to do in Lean, and if it turns out not to be fun then this is Lean's fault and might give us more of a concrete goal for <code>transportable</code> -- my impression of this is that something non-trivial got written by <span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> and homological algebra would be a nice testing ground for getting a baby strategy working. Then things like group cohomology would be a really nice application.</p>",
        "id": 133299199,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536050918
    },
    {
        "content": "<p>I did write something non-trivial, you're right. Then <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> cast doubt to its usefulness because he already implemented <code>transfer</code> which I still have to look into.</p>",
        "id": 133299417,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1536051219
    },
    {
        "content": "<p>Simon this is a few months away at least. The only reason I mentioned it was that when trying to apply a general result about some abelian groups in a situation where I had isomorphic groups, it was tough (hence my moaning last time round which started it all off). Doing a big homological algebra project will give rise to a slightly simpler use case which will be showing up in every second line of the argument.</p>",
        "id": 133299675,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536051596
    },
    {
        "content": "<p>It might be a better test case for what we want and how far we can get it to go, because I'm asking for less but conversely the thought of doing it \"by hand\" would be a nightmare.</p>",
        "id": 133299726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536051624
    },
    {
        "content": "<p>That sounds like an interesting example. And maybe a good motivation to look more closely at Johannes' work. I'm certainly willing to pick up the project again but maybe we don't have start from scratch (or my scraps, anyway)</p>",
        "id": 133300209,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1536052424
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/subject/Perfectoid.20spaces/near/133287172\" title=\"#narrow/stream/116395-maths/subject/Perfectoid.20spaces/near/133287172\">@**Scott Morrison** 04/09/2018 02:15:15 (UTC):</a></p>\n<blockquote>\n<p>A while ago I tried proving that the forgetful functor <code>CommRing ⥤ Type u</code> is represented by <code>ℤ[x]</code> (i.e. this just says that ring homomorphisms <code>ℤ[x] ⟶ R</code> are the same as elements of <code>R</code>), but got frustrated dealing with polynomials. I think we now have much better polynomials, and perhaps I can tempt someone who has worked with them into showing this fact. (<span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>?).</p>\n</blockquote>\n<p>done:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">//</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"err\">≃</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"err\">&#39;</span> <span class=\"bp\">ℤ</span> <span class=\"n\">R</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n    <span class=\"bp\">@</span><span class=\"n\">is_alg_hom</span><span class=\"bp\">.</span><span class=\"n\">to_is_ring_hom</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">algebra</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n      <span class=\"o\">(</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">is_alg_hom</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">funext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"err\">$</span> <span class=\"bp\">@</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"kn\">eval</span><span class=\"err\">&#39;</span><span class=\"bp\">_</span><span class=\"n\">unique</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">f</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">is_ring_hom</span><span class=\"bp\">.</span><span class=\"n\">to_is_ℤ_alg_hom</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">algebra</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p><a href=\"https://github.com/kckennylau/Lean/blob/master/polynomial.lean\" target=\"_blank\" title=\"https://github.com/kckennylau/Lean/blob/master/polynomial.lean\">https://github.com/kckennylau/Lean/blob/master/polynomial.lean</a></p>",
        "id": 133304087,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536058515
    },
    {
        "content": "<p>I won't PR this until the typeclass issues with algebra can be resolved</p>",
        "id": 133304101,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536058559
    },
    {
        "content": "<p>Cool! Thanks.</p>",
        "id": 133304295,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536058874
    },
    {
        "content": "<p>I can't believe I spent 6 hours to write 210 lines of code</p>",
        "id": 133304350,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536058981
    },
    {
        "content": "<p>Is that a lot or not many? :-)</p>",
        "id": 133304590,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536059349
    },
    {
        "content": "<p>a lot of time and not many lines of code</p>",
        "id": 133304735,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1536059538
    },
    {
        "content": "<p>Lean code has a lot more content than, say, python code. If you spent 6 hours writing 210 lines of python code you were either doing something super-hard, or being lazy. But 6 hours for 210 lines of Lean code looks fine to me. I saw Mario spending 3 hours writing about 100 lines of code last week.</p>",
        "id": 133306823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536062622
    },
    {
        "content": "<p>6 hours for 210 lines sounds quite fast to me.</p>",
        "id": 133317508,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1536075082
    },
    {
        "content": "<p>So, what is the status here. We now have basic stuff on Noetherian modules.</p>",
        "id": 133682677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536606667
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Hilbert basis isn't there yet, right?</p>",
        "id": 133682693,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536606687
    },
    {
        "content": "<p>And I remember something about <code>V_pre</code>. Can we now define that, using all Scott's stuff?</p>",
        "id": 133682704,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536606714
    },
    {
        "content": "<p>Yeah, who cares about matrices when we still don't have perfectoid spaces?</p>",
        "id": 133682707,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536606721
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"110524\">@Scott Morrison</span> was working on sheaves with values in another category.</p>",
        "id": 133682786,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536606798
    },
    {
        "content": "<p>Hmmm, this only seems to be about sheaves of types: <a href=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/sheaves/of_types.lean\" target=\"_blank\" title=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/sheaves/of_types.lean\">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/sheaves/of_types.lean</a></p>",
        "id": 133682912,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536606925
    },
    {
        "content": "<p>I did matrices because I was spending the day with undergraduates. Hilbert Basis I'm working on. Polynomials are subtle beasts.</p>",
        "id": 133683704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536607855
    },
    {
        "content": "<p>Ok cool. I really love how fast things are moving.</p>",
        "id": 133683813,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536608009
    },
    {
        "content": "<p>Completions are not moving fast <span class=\"emoji emoji-2639\" title=\"sad\">:sad:</span></p>",
        "id": 133683867,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536608052
    },
    {
        "content": "<p>It's partly because real life caught me, partly because I really need help</p>",
        "id": 133683876,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536608077
    },
    {
        "content": "<p>Hmmm... I've looked a bit a filters recently. But I'm really a novice. Can you indicate in one or two lines what the problem is?</p>",
        "id": 133683994,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536608272
    },
    {
        "content": "<p>I have fewer Lean students now, many of them stopped at the end of August; two MSc student went back to France and next week my UK MSc students will hand in their projects. I need to think hard about UG teaching but I think Patrick is right, we've said we'll do perfectoids, there's nothing in theory that prevents us from doing it, it looks good, it's a good ad for Lean, we should do it.</p>",
        "id": 133683996,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536608276
    },
    {
        "content": "<p>The better file to look at for sheaves is &lt;<a href=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/sheaves.lean\" target=\"_blank\" title=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/sheaves.lean\">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/sheaves.lean</a>&gt;. The one Johan linked above is actually a convenience: if you have the right sort of concrete category (the forgetful functor is <code>faithful</code>, <code>continuous</code>, and <code>reflects_isos</code>) then to check the sheaf condition it's enough to check the sheaf condition on the underlying presheaf of types.</p>",
        "id": 133713456,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536648993
    },
    {
        "content": "<p>(Not that I actually prove that there: it's just the statement for now!)</p>",
        "id": 133713463,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536649011
    },
    {
        "content": "<p>I should look at this V_pre thing.</p>",
        "id": 133713467,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536649023
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/iSqAQpjcqT1pLw65lBtIkCbo/Screenshot-2018-09-11-16.58.27.png\" target=\"_blank\" title=\"Screenshot-2018-09-11-16.58.27.png\">Screenshot-2018-09-11-16.58.27.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/iSqAQpjcqT1pLw65lBtIkCbo/Screenshot-2018-09-11-16.58.27.png\" target=\"_blank\" title=\"Screenshot-2018-09-11-16.58.27.png\"><img src=\"/user_uploads/3121/iSqAQpjcqT1pLw65lBtIkCbo/Screenshot-2018-09-11-16.58.27.png\"></a></div>",
        "id": 133713545,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536649192
    },
    {
        "content": "<p>Right... as far as I can see almost all ingredients for this definition exist.</p>",
        "id": 133713604,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1536649274
    },
    {
        "content": "<p>Just some comments on the definition. (1) we will be interested in sheaves of course; the presheaf category is just a bigger category where some auxiliary constructions take place. (2) Line 4 of the screenshot means \"compute the stalk in the category of presheaves of rings not topological rings\" (i.e. forget the topology) rather than \"these stalks form a presheaf in some way\". (3) An equivalence class of valuations on a commutative ring <code>R</code> is simply a term of type <code>Spv R</code>, with <code>Spv</code> (the \"valuation spectrum\") defined in <code>valuation_spectrum.lean</code> in the perfectoid project, and the condition about the support being the maximal ideal is just a predicate (which only makes sense if <code>R</code> is local and hence is not yet there). I'm hoping that this is all the information Scott needs.</p>",
        "id": 133714540,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536650878
    },
    {
        "content": "<p>I made a start of <code>prev_V</code>: <a href=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/V_pre.lean\" target=\"_blank\" title=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/V_pre.lean\">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/V_pre.lean</a>. So far no hurdles, it's just like building Lego.</p>",
        "id": 133714676,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536651019
    },
    {
        "content": "<p>I'm not sure whether I really want to add <code>perfectoid</code> as a dependency.</p>",
        "id": 133714681,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536651041
    },
    {
        "content": "<p>I guess I should move across to the perfectoid project to do that bit.</p>",
        "id": 133714700,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536651079
    },
    {
        "content": "<p>Why don't you do the opposite? PR to perfectoid-spaces?</p>",
        "id": 133714701,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536651083
    },
    {
        "content": "<p>Is it okay having perfectoid depend on lean-category-theory?</p>",
        "id": 133714710,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536651093
    },
    {
        "content": "<p>you might be surprised to hear that defining an equivalence class of valuations was extremely painful. There were universe issues.</p>",
        "id": 133714715,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536651105
    },
    {
        "content": "<p>:-)</p>",
        "id": 133714716,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536651111
    },
    {
        "content": "<p>Dependencies -- my only worry is that when I did that in the past (with the schemes project I think) what happened was that my code never seemed to compile, because category theory was very much a WIP at that time</p>",
        "id": 133714771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536651164
    },
    {
        "content": "<p>(this was months ago, when the category theory library was undergoing major refactoring)</p>",
        "id": 133714774,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536651180
    },
    {
        "content": "<p>I think perfectoid depending on category theory is fine, especially since merges come in at a steady pace</p>",
        "id": 133714776,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536651183
    },
    {
        "content": "<p>so it will soon be depending on mathlib only</p>",
        "id": 133714783,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536651194
    },
    {
        "content": "<p>My instinct is not to push for perfectoids to go into mathlib until after Lean 4. Is that crazy?</p>",
        "id": 133714787,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536651228
    },
    {
        "content": "<p>[if indeed they go in at all]</p>",
        "id": 133714789,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536651236
    },
    {
        "content": "<p>I meant: category-theory will be in mathlib</p>",
        "id": 133714826,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536651244
    },
    {
        "content": "<p>right</p>",
        "id": 133714833,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536651271
    },
    {
        "content": "<p>I was just thinking aloud</p>",
        "id": 133714837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1536651280
    },
    {
        "content": "<p>If we manage to define perfectoid spaces then many things will go into mathlib without hesitation. And then you'l be left with a couple of files that could go as well, in a somewhat lonely directory</p>",
        "id": 133714856,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1536651331
    },
    {
        "content": "<p>Ugh. I just finished a construction of the category of presheaves (that is, the objects are pairs (X, O), for X a topological space and O a presheaf of somethings on it, and the morphisms are pairs (f, f'), f a continuous map X \\to Y, and f' a natural transformation from O_Y to the pushforward of O_X).</p>",
        "id": 133734386,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536674556
    },
    {
        "content": "<p>Hopefully after this, <code>V_pre</code> is just picking out an appropriate subcategory.</p>",
        "id": 133734418,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536674590
    },
    {
        "content": "<p>Unfortunately, at some point it stopped being easy --- the proofs I've written that morphisms of presheaves compose, and compose correctly, are really really deeply horrible.</p>",
        "id": 133734442,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536674624
    },
    {
        "content": "<p><a href=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/V_pre.lean\" target=\"_blank\" title=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/V_pre.lean\">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/V_pre.lean</a></p>",
        "id": 133734495,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1536674644
    },
    {
        "content": "<p>Here's a perfectoid update. </p>\n<p>We need integral closures and for this we need either Cayley-Hamilton or Hilbert Basis. Somebody will do Cayley-Hamilton some day (we do have matrices after all ;-) ) so I'm doing Hilbert basis. It's taking a long time because whilst I now know a beautiful way to do it thanks to <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> , working with the theory of polynomial rings and modules over multiple rings has given me a clear picture about exactly what needs doing, and I still have problems with the underlying set-up, basically because a type M might be a module for more than one ring. I am not even sure if typeclass inference is appropriate for the kind of calculations I am doing, and it's not something strange -- the ideas I'm formalising show up everywhere in commutative algebra. So that's the situation regarding integral closure. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> did you say you were going to refactor...something to do with modules? Should I wait until you finish this? The Hilbert basis code relies on the <code>poly_coeffs</code> branch of community mathlib, which has been PR'ed. Let me know if any work needs doing on this PR. Here is an explicit question. In maths, if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mo>[</mo><mi>X</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">R[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span>-submodule of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mo>[</mo><mi>X</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">R[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> then it is naturally an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-submodule of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mo>[</mo><mi>X</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">R[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span>. How to say this in Lean? That is the goal I am looking at now and I think I might take a break until it's clearer to me what mathlib's general approach to this sort of question is.</p>\n<p>Completion of a ring -- <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  has done a <em>lot</em> of stuff about completions, but I think he said the other day that something was blocking him from proceeding. Maybe we have completions of topological abelian additive groups, but not yet of commutative rings?</p>\n<p>And finally this category. Thanks <span class=\"user-mention\" data-user-id=\"110524\">@Scott Morrison</span>  for the valiant V_pre effort! I stopped \"racing to the goal\" a while ago because I didn't know whether we could make V_pre easily or not and I thought I'd defer to you. I think that what I need to do now is to actually think about how much of this category we actually need. Ultimately one should prove that there's a morphism from the category of Huber pairs to V_pre, however whether we need something so strong depends on exactly how far we want to go. Merely writing down the definition of a perfectoid space might not need it, but saying anything at all about them will surely need something like this.</p>\n<p>Maybe it is time to think about things in a \"top-down\" way a bit more, and in particular it might be worth formalising the <em>statements</em> of integral closure and completion of a ring, leaving them as \"TODO\" (Scott -- these are exactly the things which are stopping me from constructing objects of V_pre -- to make an object corresponding to a Huber Pair A I need to build a presheaf on Spa(A) and the above constructions are part of the infrastructure I need for building this presheaf).</p>",
        "id": 134008420,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537010406
    },
    {
        "content": "<p>I pushed (non-working) branch <code>kmb_hilbert2</code> to community mathlib in case anyone wants to see the status of Hilbert basis. The proof I'm aiming for goes like this: if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> is an ideal in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mo>[</mo><mi>X</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">R[X]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> and if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mo>[</mo><mi>X</mi><msub><mo>]</mo><mrow><mo>≤</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">R[X]_{\\le n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.295179em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≤</span><span class=\"mord mathit mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"></span></span></span></span></span></span></span></span> is the sub-<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module of polys of degree at most <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">n</span></span></span></span> (<code>deg_le R n</code> in Lean) then <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>J</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">J_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span>, the ideal of terms of the form <code>coeff f n</code> as <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span></span></span> runs through the elements of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> with degree at most <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">n</span></span></span></span>, is an increasing sequence of ideals. There are several ways to define <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>J</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">J_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> but this one does not need the gazillion edge cases which I had before. Then it's just the standard proof -- the union of the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>J</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">J_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> is finitely-generated so is <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>J</mi><mi>N</mi></msub></mrow><annotation encoding=\"application/x-tex\">J_N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> for some <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and choosing generators of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>J</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">J_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">i\\leq N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\">i</span><span class=\"mrel\">≤</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and looking at corresponding polynomials finishes the job easily.</p>",
        "id": 134008922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537011564
    },
    {
        "content": "<p>But I propose not working on it any more for a while until I understand what Mario is doing with modules and the poly_coeffs PR; I'll instead concentrate on the top down questions (i.e. how far are we from a definition modulo a few concrete sorries which are basically independent simpler questions)</p>",
        "id": 134008983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537011616
    },
    {
        "content": "<p>Again, the status for completion is I'm stuck at three points: </p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L124\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L124\">https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L124</a> where I'm also not clear on the math proof (and Bourbaki doesn't really help because Johannes didn't follow Bourbaki when defining completions of uniform spaces) but I should be able to understand this.</li>\n<li>I don't know how to use the previous point (even sorried) in order to unlock <a href=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L132\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L132\">https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L132</a> Because it seems hard to opt out of the automatic instance resolution to manually insert a propositional equality of two uniform structure on the same type. I think this is the crucial point where I really need help</li>\n<li>when I try to use <a href=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L132\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L132\">https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/group_completion.lean#L132</a> with multiplication on topological rings I have instance loops (I could push my failed attempt if needed)</li>\n</ul>",
        "id": 134009618,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537012914
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">completion</span><span class=\"bp\">.</span><span class=\"n\">map₂</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">completion</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">completion</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">completion</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">completion</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">uncurry</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">completion</span><span class=\"bp\">.</span><span class=\"n\">prod</span>\n</pre></div>\n\n\n<p>Why do you uncurry in <code>completion.lean</code>?</p>",
        "id": 134017508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537027279
    },
    {
        "content": "<p>Here <code>α</code>, <code>β</code> and <code> γ</code> are uniform spaces.  <code>α × β</code> is also a uniform space, but <code>β → γ</code> isn't</p>",
        "id": 134019674,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537031403
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> while you wait for Mario's module refactor, why don't try to LaTeX a precise roadmap? As I said in the very beginning of the project (we even have a LaTeX_docs folder) it would be much easier to have a full LaTeX writeup of the definition of a perfectoid space, assuming only knowledge of basic theory of topological rings and sheaves</p>",
        "id": 134088693,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537174479
    },
    {
        "content": "<p>You mean of what still needs to be done, or everything?</p>",
        "id": 134089151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537175116
    },
    {
        "content": "<p>Wedhorns paper defines an adic space and it's 100 pages</p>",
        "id": 134089166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537175146
    },
    {
        "content": "<p>Of course everything would be better, but what still needs to be done would be enough for now</p>",
        "id": 134089206,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537175164
    },
    {
        "content": "<p>You claimed earlier that those 100 pages are not all necessary for the definition</p>",
        "id": 134089214,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537175179
    },
    {
        "content": "<p>I'm not suggesting to rewrite that paper, which obviously contains preparation for things coming after the definition, as well as motivation</p>",
        "id": 134089236,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537175220
    },
    {
        "content": "<p>We don't need any of this to define perfectoid spaces</p>",
        "id": 134089245,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537175229
    },
    {
        "content": "<p>Patrick I'm going to do this right now. What exactly do you want me to cover?</p>",
        "id": 134089548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537175693
    },
    {
        "content": "<p>Just statements such as \"if R is a topological ring then there's a completion R-hat which satisfies a universal property -- for the property see section blah of Wedhorn and for the construction see section blah\"?</p>",
        "id": 134089575,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537175754
    },
    {
        "content": "<p>Have I now completely covered completions of topological rings, once I fill in the references, as far as this document is concerned?</p>",
        "id": 134089621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537175778
    },
    {
        "content": "<p>The reason I want to do it now is that I was thinking about exactly this sort of thing when you suggested it.</p>",
        "id": 134089624,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537175793
    },
    {
        "content": "<p>Yes, at least until you reach the end goal (definition of perfectoid space). Then we may or may not want to add details</p>",
        "id": 134089627,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537175812
    },
    {
        "content": "<p>and I have an hour before my first meeting this morning. But I don't want to write something and then you say something else was better.</p>",
        "id": 134089628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537175816
    },
    {
        "content": "<p>OK I pushed a first draft. Patrick -- let me know what else you want from this doc. All refs are to Wedhorn, I didn't put the citation in explicitly because I'm in a rush</p>",
        "id": 134091570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537178741
    },
    {
        "content": "<p>It's looks like a good start, but obviously more details are needed in Section 3</p>",
        "id": 134094182,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537182809
    },
    {
        "content": "<p>Today I spent some time working out the maths part of why the two natural uniformities on the completion of a commutative topological group coincide. It won't be easy to Lean, but it should work. Then I would really need to think about how to get Lean to use this fact...</p>",
        "id": 134125363,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537216916
    },
    {
        "content": "<p>Returning to the LaTeX documentation, I guess the real test would be: Kevin, could you finish the definition by sorrying only lemmas and no definition?</p>",
        "id": 134125768,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537217424
    },
    {
        "content": "<p>We need to define the presheaf on <code>Spa A</code>. The reason I stopped is because for a rational open subset <code>U</code>, the value of the presheaf is a completion, and we don't have ring completions yet. Nice work on the group completion, by the way. After that we need to define the presheaf on all open sets, and that's via a projective limit construction; we need a statement that this limit is unique up to unique isomorphism. Then we need to define the valuations on the stalks etc etc. Are you saying I should write more Lean code or more LaTeX?</p>",
        "id": 134126506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537218360
    },
    {
        "content": "<p>You could write both more Lean and LaTeX. You can sorry the ring completion thing.  State the existence of the completion and its universal property and move on.</p>",
        "id": 134129017,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537221277
    },
    {
        "content": "<p>I'm watching these Zurich videos though :-)</p>",
        "id": 134129693,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537221950
    },
    {
        "content": "<blockquote>\n<p>It's looks like a good start, but obviously more details are needed in Section 3</p>\n</blockquote>\n<p>I am unclear about what you want to know (in particular you are saying things are obvious but they're not obvious to me yet). Sorry to go on about this. I'm happy to write stuff, I'm just not sure what I am supposed to be writing. </p>\n<p>Let me pick out a few examples from section 3 to make my question more explicit. </p>\n<p>I say that Spa(A) is an equivalence class of valuations. I imply that these are \"done\". In fact the maths definition of valuation is in Wedhorn chapter 1 and the Lean definition is in <code>valuation.lean</code>, which has no sorrys.  Do you also want me to write out the definition in LaTeX or just make the references more precise or what?</p>\n<p>Next I say Spa(A) is a topological space. Here I am lazier -- the maths in in Wedhorn and the formalisation is in <code>Spa.lean</code> but I just say it can be done. Do you want more precise references, or an explicit definition of the topology in the document?</p>\n<p>Finally for this message, the presheaf. Here I just say it can be defined on the rational subsets and then it can be extended. This is not in Lean for the simple reason that here we are part of the \"bottom up\" way of thinking, and the definition of the global sections of the presheaf on Spa(A) is equal to the completion of A. Here I say nothing, and there is no Lean file, but I give a precise citation to Wedhorn. Is there a problem with the LaTeX file here or is the only problem that we need more Lean code?</p>",
        "id": 134146650,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537249029
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I updated the file a bit. Let me know what you want from this file -- I will have some time on the tube home this evening to work on it.</p>",
        "id": 134156459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537264894
    },
    {
        "content": "<p>I tried to clarify my question by opening an empty PR. It adds sorried statements in <code>ring_completions.lean</code>. Question is: would proving this be enough for you to finish everything?</p>",
        "id": 134159914,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537270171
    },
    {
        "content": "<p>It would take me some time, I guess, and time is something I don't have much of at the minute. We need to take an integral closure, for sure. I don't see any obstruction to finishing everything apart from the fact that someone actually has to do it. But I have 250 students arriving here in 13 days' time and I need to be ready for them.</p>",
        "id": 134160873,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537271330
    },
    {
        "content": "<p>PS to take integral closure we either need Cayley-Hamilton or working modules, and currently we have neither, but both are possible.</p>",
        "id": 134160890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537271368
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> do you know if <code>separated α</code>implies  <code>separated (Cauchy α)</code>? I'm still struggling a bit with with uniform spaces</p>",
        "id": 134162113,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537272903
    },
    {
        "content": "<p>No, for example the rationals are separated, but <code>Cauchy</code> over the rationals isn't</p>",
        "id": 134162185,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537272970
    },
    {
        "content": "<p>Kevin, if you don't have time for this and don't have time for a detailed LaTeX file then I guess we are stuck. Otherwise people (Johan or me say) could try to do the Lean job from the LaTeX file (although I have a lot to do with completions)</p>",
        "id": 134162197,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537273001
    },
    {
        "content": "<p>Johannes, this is what I suspected. But somehow it should be true that if α is separated then it should inject into its separated completion</p>",
        "id": 134162214,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537273054
    },
    {
        "content": "<p>I'm struggling because you set up everything to avoid minimal Cauchy filters that Bourbaki uses everywhere</p>",
        "id": 134162267,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537273119
    },
    {
        "content": "<p>Bourbaki first makes things separated and then takes the space of minimal Cauchy filters</p>",
        "id": 134162286,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537273155
    },
    {
        "content": "<p>And the second operation is always injective</p>",
        "id": 134162295,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537273187
    },
    {
        "content": "<p>So we get injection of separated stuff into their separated completion for free</p>",
        "id": 134162340,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537273205
    },
    {
        "content": "<p>But it should still work with your way of doing things, since I proved the separated complete space obtained and the separation space of Cauchy α satisfies the obvious universal property</p>",
        "id": 134162369,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537273264
    },
    {
        "content": "<p>I had a proof for the reals that the usual embedding <code>α -&gt; quotient (Cauchy α)</code> was injective if <code>separated α</code></p>",
        "id": 134162375,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537273270
    },
    {
        "content": "<p>I thought also you had this already</p>",
        "id": 134162378,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537273279
    },
    {
        "content": "<p>No I don't have it</p>",
        "id": 134162390,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537273306
    },
    {
        "content": "<p>Ah, I had it directly on <code>rat</code>: <a href=\"https://github.com/leanprover/mathlib/blob/7fd7ea8c323c5f622bda6bc8de6dd352cc2732a8/analysis/real.lean#L401\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/7fd7ea8c323c5f622bda6bc8de6dd352cc2732a8/analysis/real.lean#L401\">https://github.com/leanprover/mathlib/blob/7fd7ea8c323c5f622bda6bc8de6dd352cc2732a8/analysis/real.lean#L401</a></p>",
        "id": 134162555,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537273499
    },
    {
        "content": "<p>It looks like a specific proof</p>",
        "id": 134162622,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537273564
    },
    {
        "content": "<p>yes :(</p>",
        "id": 134162635,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537273580
    },
    {
        "content": "<p>Do you remember where you saw this story of the space <code>Cauchy α</code> (as opposed to the space of minimal Cauchy filters)?</p>",
        "id": 134162759,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537273775
    },
    {
        "content": "<p>Hm no</p>",
        "id": 134163062,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537274090
    },
    {
        "content": "<p>But I will try to proof this injectivity now</p>",
        "id": 134163074,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537274105
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  it was surprisingly straight-forward:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"err\">⟦</span><span class=\"n\">pure_cauchy</span> <span class=\"n\">a</span><span class=\"err\">⟧</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n<span class=\"k\">have</span> <span class=\"n\">a_rel_b</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">pure_cauchy</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">pure_cauchy</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"err\">⋂₀</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniformity</span> <span class=\"o\">(</span><span class=\"n\">Cauchy</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">by_contradiction</span> <span class=\"err\">$</span> <span class=\"k\">assume</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"k\">let</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">ne</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">separated_def&#39;</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">this</span> <span class=\"k\">in</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_embedding_pure_cauchy</span> <span class=\"n\">α</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">mem_comap_sets</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hs</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">pure_cauchy</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">pure_cauchy</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">a_rel_b</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">a_rel_b</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ne</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">hts</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">this</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 134163694,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537274756
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 134163821,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537274873
    },
    {
        "content": "<p>I'll need to decipher this now</p>",
        "id": 134163878,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537274888
    },
    {
        "content": "<p>actually the contradiction is not necessary: <a href=\"https://github.com/leanprover/mathlib/commit/7dedf3ca65f4a183909f51879cffddd6edc6e20a\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/commit/7dedf3ca65f4a183909f51879cffddd6edc6e20a\">https://github.com/leanprover/mathlib/commit/7dedf3ca65f4a183909f51879cffddd6edc6e20a</a></p>",
        "id": 134165812,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537276991
    },
    {
        "content": "<p>Thanks! Too bad this proof is locked into term mode. I'd love to know the maths there</p>",
        "id": 134167252,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537278545
    },
    {
        "content": "<p>I need to make sure that I'm ready for the students so I should concentrate on that for the next 13 days, but hopefully then the modules are refactored, I'll know what I'm doing with CoCalc, and I can come back to this.</p>",
        "id": 134172968,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537284262
    },
    {
        "content": "<p>Could you still review my PR?</p>",
        "id": 134172988,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537284292
    },
    {
        "content": "<blockquote>\n<p>I'll need to decipher this now</p>\n</blockquote>\n<p>Ok, I managed to read it. It contained enough tactic mode. I also deduced from it that the map to the Hausdorff completion is a uniform embedding when the original space is Hausdorff.</p>",
        "id": 134174890,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537286129
    },
    {
        "content": "<p>Patrick I don't review your PR's, I just accept them :-) I will \"review\" this one later on today hopefully. Does <code>for_mathlib/topological_structures.lean</code> work for you? It has an import <code>for_mathlib.function</code> which isn't there for me...</p>",
        "id": 134183580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537295274
    },
    {
        "content": "<p>Oh crap, it works here because <code>for_mathlib/function.olean</code> is still there</p>",
        "id": 134184098,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537295857
    },
    {
        "content": "<p>This is so annoying. Is there any drawback to making sure <code>leanpkg build</code> deletes <code>olean</code> files that don't have <code>lean</code> file?</p>",
        "id": 134184166,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537295913
    },
    {
        "content": "<p>I guess this question was already asked many times</p>",
        "id": 134184170,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537295923
    },
    {
        "content": "<p>I just manually removed 9 dangling olean files</p>",
        "id": 134184302,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537296061
    },
    {
        "content": "<p>Let's see where we are</p>",
        "id": 134184305,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537296066
    },
    {
        "content": "<p>Maybe that also explains why I needed to \"fix\" stuff and Johan complained about the fixes</p>",
        "id": 134184321,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537296097
    },
    {
        "content": "<p>No, the fixes are still needed</p>",
        "id": 134184558,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537296323
    },
    {
        "content": "<p>Kevin: it should compile on your end now</p>",
        "id": 134184569,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537296333
    },
    {
        "content": "<p>You should still make sure my fixes didn't change the intended semantic</p>",
        "id": 134184686,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537296420
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I reviewed Patrick's changes. If neither of you have any more to say then I am happy to merge.</p>",
        "id": 134222042,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537350349
    },
    {
        "content": "<p>I just explained how to ignore whitespace <span class=\"emoji emoji-1f606\" title=\"lol\">:lol:</span>  Other than that... <code>-- no comments</code></p>",
        "id": 134222118,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537350469
    },
    {
        "content": "<p>I really need to take two weeks off from the perfectoid repo at this point. It looks to me that it's in good shape. Other than ring completions and integral closures (which are disjoint independent problems) the main thing that is needed is the definition of the presheaf on Spa(A) and the valuation on the stalks -- i.e. constructing an object of the category V^pre from a Huber pair. Assuming a sorried (ring completion + universal property) and a sorried (integral closure of a ring is a ring) this seems to be the key remaining construction.</p>",
        "id": 134222156,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537350484
    },
    {
        "content": "<p>I will see if I can do some work on this. But I'm currently in a train to Ben's birthday party, and beginning of next week I'm also busy in NL. So I won't be back at Lean until Thursday next week.</p>",
        "id": 134222181,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537350552
    },
    {
        "content": "<p>I would like to try some stuff with the presheaves. As soon as <span class=\"user-mention\" data-user-id=\"110524\">@Scott Morrison</span> is back at Lean, I hope he will also get some sheafy PR ready. Or do you think this is something that I could get PR ready myself, Scott?</p>",
        "id": 134222242,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537350643
    },
    {
        "content": "<p>The integral closure project is currently blocked by the module refactorisation, I guess.</p>",
        "id": 134222265,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537350690
    },
    {
        "content": "<p>With completions I don't think I can be of much help, because my filter-fu is nilpotent</p>",
        "id": 134222314,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537350733
    },
    {
        "content": "<p>Regarding sheafy stuff... That stuff can't actually make it into mathlib before all the work on limits gets to mathlib.</p>",
        "id": 134222322,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537350750
    },
    {
        "content": "<p>That is pretty close, mostly filling in gaps.</p>",
        "id": 134222325,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537350764
    },
    {
        "content": "<p>I got distracted last time I was working on it by the prospect of writing tactics to work with diagrams.</p>",
        "id": 134222335,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537350787
    },
    {
        "content": "<p>Aaah, I see. Is it best if we just sit back and wait? Or can we contribute in a constructive way?</p>",
        "id": 134222339,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537350798
    },
    {
        "content": "<p>The diagram stuff could be pretty cool, but maybe more on that later. :-)</p>",
        "id": 134222352,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537350831
    },
    {
        "content": "<p>I had wanted to prove some basic facts like \"has_limits implies has_equalizers\", etc. etc., but as none of that is necessary for basic sheafy stuff, I should just leave that for a later PR.</p>",
        "id": 134222405,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537350890
    },
    {
        "content": "<p>We probably also want all sort of lemmas about defining a sheaf on a basis of a topology and extending it to a sheaf by blah, etc...</p>",
        "id": 134222544,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537351125
    },
    {
        "content": "<p>But that is something <em>we</em> could do, once the definition of a sheaf is in mathlib.</p>",
        "id": 134222546,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537351139
    },
    {
        "content": "<p>Can't we add Scott's lib to the perfectoid project dependencies ?</p>",
        "id": 134222557,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537351174
    },
    {
        "content": "<p>Hmmm, that has been discussed before. I think it is a good idea.</p>",
        "id": 134222564,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537351193
    },
    {
        "content": "<p>Patrick, did you recently look through <code>for_mathlib</code> to see if we could PR stuff from there?</p>",
        "id": 134222622,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537351228
    },
    {
        "content": "<p>Otherwise that might be something I could do somewhere on this trip</p>",
        "id": 134222634,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537351243
    },
    {
        "content": "<p>I guess <code>add_subgroup.lean</code> is already in mathlib... <code>ideals.lean</code> should probably wait till the module-refactorisation is done. Afterwards we can see how much survives. <code>option_inj</code> and <code>quotient</code> and <code>topology</code>could at least partly be PR'd I think</p>",
        "id": 134222868,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537351588
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/uniform_space.lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/uniform_space.lean\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/uniform_space.lean</a> could go in, those bits were forgotten in a previous PR</p>",
        "id": 134223515,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537352557
    },
    {
        "content": "<p>Are you sure add_subgroup.lean is in mathlib?</p>",
        "id": 134223533,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537352596
    },
    {
        "content": "<p>No</p>",
        "id": 134223534,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537352607
    },
    {
        "content": "<p>I just couldn't imagine it wasn't</p>",
        "id": 134223543,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537352639
    },
    {
        "content": "<p>I think Mario at some point merged it into mathlib using <code>to_additive</code> magic that I still don't understand. But maybe my memory is bad.</p>",
        "id": 134223619,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537352726
    },
    {
        "content": "<p>I think this was is_add_group_hom</p>",
        "id": 134225024,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537355072
    },
    {
        "content": "<p>No, you're right, <a href=\"https://github.com/leanprover/mathlib/blob/master/group_theory/subgroup.lean\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/group_theory/subgroup.lean\">https://github.com/leanprover/mathlib/blob/master/group_theory/subgroup.lean</a> is also there</p>",
        "id": 134225054,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537355152
    },
    {
        "content": "<p>I removed it (including the olean...) and I confirm it doesn't change anything</p>",
        "id": 134225201,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537355318
    },
    {
        "content": "<p>I have to make a confession about this <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"script\">V</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">{\\mathcal V}^{pre}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">V</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"mord mathit mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit mtight\">e</span></span></span></span></span></span></span></span></span></span></span></span> stuff: a natural question when you read Wedhorn is \"can Lean do stuff like <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"script\">V</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">{\\mathcal V}^{pre}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">V</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"mord mathit mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit mtight\">e</span></span></span></span></span></span></span></span></span></span></span></span> nowadays?\", and can we prove that <code>Spa</code> is a functor from Huber pairs to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"script\">V</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">{\\mathcal V}^{pre}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">V</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"mord mathit mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit mtight\">e</span></span></span></span></span></span></span></span></span></span></span></span>? But actually the category theory language is just a convenient language for mathematicians to use here, because it's a way of saying \"5 lemmas about <code>Spa</code> are true\" all in one go. I am not so sure that we need to make a structure called \"the category <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"script\">V</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">{\\mathcal V}^{pre}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">V</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"mord mathit mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit mtight\">e</span></span></span></span></span></span></span></span></span></span></span></span> in order to achieve our primary objective.</p>",
        "id": 134228990,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537360307
    },
    {
        "content": "<p>Whether or not the category <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"script\">V</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">{\\mathcal V}^{pre}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">V</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"mord mathit mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit mtight\">e</span></span></span></span></span></span></span></span></span></span></span></span> goes into the repo, this does not change the fact that someone, probably me, needs to actually construct the map on objects.</p>",
        "id": 134229055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537360371
    },
    {
        "content": "<p>So if it helps to have the category theory repo as a dependency then that's fine, and of course ultimately if one is going to actually define the category of perfectoid spaces then one will need to be able to talk about categories -- but if one is just going to define the structure and then say \"we did it\" then we might not need <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"script\">V</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">{\\mathcal V}^{pre}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">V</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">p</span><span class=\"mord mathit mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit mtight\">e</span></span></span></span></span></span></span></span></span></span></span></span>. It depends on what the ultimate goal is. It should be there but we can work around it is I guess what I'm saying. I never defined a morphism of schemes in the schemes project.</p>",
        "id": 134229142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537360486
    },
    {
        "content": "<p>As you wrote elsewhere, we want mathematicians to recognize the theory when browsing the perfectoid repository. So it would probably be better to have the category where it belongs</p>",
        "id": 134229450,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537360832
    },
    {
        "content": "<p>I think we should go the way of the category (-;<br>\nIf this means that we have to pay for it because there is too much bundled stuff or so... then we have identified a pain point that has to be fixed. Like you say the categories will be inevitable anyway.</p>",
        "id": 134260907,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537382598
    },
    {
        "content": "<p>I am happy if both of you want to do this. But I don't quite see the logic -- it's like saying we need Scott's repo as a dependency if we're working with groups, because we can't say that groups form a category otherwise. What I'm trying to say is that just need to construct a <em>function</em>, not a <em>functor</em>, which eats <code>A</code> and spits out a structure which happens to be an object in a category which we don't strictly speaking need (we don't need to take limits, or products, or even compose morphisms -- or even use morphisms -- indeed it will be hard work to define the morphisms and we won't need them).</p>",
        "id": 134261243,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537382957
    },
    {
        "content": "<p>Ok, so maybe we don't need <code>V^pre</code> as a category. But if we add Scott's lib as a dependency we do get immediate access to sheaves. That seems enough reason for me to add the dependency.</p>",
        "id": 134262632,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537384240
    },
    {
        "content": "<p>I didn't understand that getting V^pre a category would mean useless work</p>",
        "id": 134263777,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537385572
    },
    {
        "content": "<p>But it's a virtual discussion anyway if nobody can work on this. I have a <em>lot</em> of work to do on the topological group front</p>",
        "id": 134263799,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537385606
    },
    {
        "content": "<p><code>definition power_bounded_subring := {r : R | is_power_bounded r}</code></p>",
        "id": 134323352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537464234
    },
    {
        "content": "<p>Should this be a set or a subtype?</p>",
        "id": 134323354,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537464239
    },
    {
        "content": "<p>Someone will have to prove it's a subring at some point</p>",
        "id": 134323397,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537464255
    },
    {
        "content": "<p>It should be a subring</p>",
        "id": 134323631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537464503
    },
    {
        "content": "<p>I think I want to focus on the perfectoid project for the next few days.</p>",
        "id": 134531313,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537800981
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> You had some discussion with Kevin on where the gaps are.</p>",
        "id": 134531324,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537801001
    },
    {
        "content": "<p>Do you see a gap that isn't \"completions\" on which I could work?</p>",
        "id": 134531331,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537801021
    },
    {
        "content": "<p>(I finished several maths projects, so I will treat myself on some Lean time.)</p>",
        "id": 134531347,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537801036
    },
    {
        "content": "<p>Should I try to define V_pre?</p>",
        "id": 134531357,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537801056
    },
    {
        "content": "<p>Have you checked the outline tex file which Kevin added somewhat recently?</p>",
        "id": 134533591,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537803184
    },
    {
        "content": "<p>Scott has been trying to define V_pre over in the category theory repo, I think</p>",
        "id": 134533826,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537803369
    },
    {
        "content": "<p>But maybe it's not quite the same thing.</p>",
        "id": 134533855,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537803405
    },
    {
        "content": "<p>Ok, I'll try to dig those up.</p>",
        "id": 134533912,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537803479
    },
    {
        "content": "<p>It looks like what Scott is doing specifically is the category where an object is a topological space X plus a C-valued presheaf on X, for some arbitrary category C.</p>",
        "id": 134534018,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537803574
    },
    {
        "content": "<p>Is V_pre a specialization of that for C = something?</p>",
        "id": 134534031,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537803583
    },
    {
        "content": "<p>I looked it up--not exactly</p>",
        "id": 134534157,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537803712
    },
    {
        "content": "<p>but I guess a good start would be to define a category of complete topological rings?</p>",
        "id": 134534216,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537803750
    },
    {
        "content": "<p>Yes, I agree.</p>",
        "id": 134534434,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537803971
    },
    {
        "content": "<p>I was doing that, and then I got distracted. I'm doing a small cleanup of Huber pair atm.</p>",
        "id": 134534462,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537803991
    },
    {
        "content": "<p>But let's return to complete topological rings.</p>",
        "id": 134534474,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537804000
    },
    {
        "content": "<p>This might be too nitpicky, but possibly it would be better to have the subcategory of all topological rings.<br>\nBecause on p. 80, V is defined to be the full subcategory of V^pre on the objects for which O_X is a sheaf of topological rings, and a priori the definition of \"sheaf of topological rings\" is not the same as \"sheaf of complete topological rings\".</p>",
        "id": 134534672,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537804177
    },
    {
        "content": "<p>Agreed</p>",
        "id": 134534694,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537804202
    },
    {
        "content": "<p>Do we have subcategories yet?</p>",
        "id": 134534766,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537804228
    },
    {
        "content": "<p>(I am happy to see Remark 8.19--I wondered if they would notice that a sheaf of topological rings is genuinely not the same thing as a sheaf of rings)</p>",
        "id": 134534767,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537804229
    },
    {
        "content": "<p>I think so, category_theory/embedding.lean</p>",
        "id": 134534769,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537804237
    },
    {
        "content": "<p>You have to attach this extra valuation data anyways, so I think the definition of V^pre is going to be rather custom</p>",
        "id": 134534904,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537804359
    },
    {
        "content": "<p>Ok, good.</p>",
        "id": 134534907,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537804362
    },
    {
        "content": "<p>It's not a subcategory of a presheaf category in an obvious way</p>",
        "id": 134534932,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537804389
    },
    {
        "content": "<p>No, I agree...</p>",
        "id": 134534941,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537804404
    },
    {
        "content": "<p>So, what do you suggest. (1) topological rings. (2) subcategory of complete topological rings. (3) presheaf with values in (2).</p>",
        "id": 134534971,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537804441
    },
    {
        "content": "<p>And then just going on with the custom stuff?</p>",
        "id": 134535014,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537804451
    },
    {
        "content": "<p>I think it might be simpler to skip 2 and put the completeness condition in the custom stuff, since later you're going to want to assert that the presheaf of topological rings is a sheaf, but it probably doesn't matter much</p>",
        "id": 134535179,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537804605
    },
    {
        "content": "<p>Ok, I'll try to define a category of topological rings.</p>",
        "id": 134535259,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537804665
    },
    {
        "content": "<p>I don't understand where all these conditions come from, so my opinion might be ill-informed.</p>",
        "id": 134535264,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537804671
    },
    {
        "content": "<p>Well, I'm not an expert either (-;</p>",
        "id": 134535310,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537804685
    },
    {
        "content": "<p>It appears to me that</p>\n<ul>\n<li>a limit of complete topological rings is complete,</li>\n<li>consequently, the sheaf on any pre-adic space takes values in complete topological rings automatically, even if we did not require it in the definition,</li>\n</ul>\n<p>and so it shouldn't matter where you insert \"complete\", if anywhere. But I'm not 100% sure.</p>",
        "id": 134536345,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537805592
    },
    {
        "content": "<p>So, how would you define the category of topological rings? Start from scratch? Or build on top of <code>Ring</code>?</p>",
        "id": 134536785,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537805958
    },
    {
        "content": "<p>We can't do <code>bundled topological_ring</code> because that requires <code>ring</code> and <code>topological_space</code> to be present.</p>",
        "id": 134536983,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537806178
    },
    {
        "content": "<p>What goes wrong with that exactly?</p>",
        "id": 134536999,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537806208
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">bundled</span> <span class=\"n\">topological_ring</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">topological_ring</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"kt\">Prop</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"err\">?</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"err\">?</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"err\">?</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">?</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 134537005,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537806227
    },
    {
        "content": "<p>Oh I see</p>",
        "id": 134537009,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537806237
    },
    {
        "content": "<p>I guess we could bundle up <code>[topological_space a] [ring a] [topological_ring a]</code> into one class for use when defining the category</p>",
        "id": 134537064,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537806275
    },
    {
        "content": "<p>So start from scratch</p>",
        "id": 134537077,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537806290
    },
    {
        "content": "<p>Well, using <code>bundled</code> with a custom class which can just be <code>extends ...</code>, I think, with an empty body</p>",
        "id": 134537100,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537806322
    },
    {
        "content": "<p>Aaah, I can try that</p>",
        "id": 134537174,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537806408
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">actual_topological_ring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"kn\">extends</span> <span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">topological_ring</span> <span class=\"n\">α</span>\n</pre></div>",
        "id": 134537185,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537806442
    },
    {
        "content": "<p>Right.</p>",
        "id": 134537203,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537806473
    },
    {
        "content": "<p>I was going for a <code>'</code> at the end, but <code>actual</code> is also a good idea.</p>",
        "id": 134537253,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537806489
    },
    {
        "content": "<p>Should we do <code>ring</code> or <code>comm_ring</code>?</p>",
        "id": 134537259,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537806499
    },
    {
        "content": "<p>Or just do both, and make the <code>comm_</code> explicit: <code>actual_topological_comm_ring</code></p>",
        "id": 134537268,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537806522
    },
    {
        "content": "<p>Oops, <code>comm_ring</code> of course. Oh wait, there is no <code>topological_comm_ring</code>. So you could just use that name...</p>",
        "id": 134537383,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537806638
    },
    {
        "content": "<p>Probably too confusing...</p>",
        "id": 134537385,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537806651
    },
    {
        "content": "<p>I thought my <code>actual_</code> sounded a bit irritated <span class=\"emoji emoji-263a\" title=\"smile\">:smile:</span></p>",
        "id": 134537400,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537806672
    },
    {
        "content": "<p>Hales topological commutative ring</p>",
        "id": 134537409,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537806695
    },
    {
        "content": "<p>I think then you should get all three of those classes on the underlying type of an object for free</p>",
        "id": 134537473,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537806747
    },
    {
        "content": "<p>Haha</p>",
        "id": 134537587,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537806858
    },
    {
        "content": "<p><code>class is_topological_ring_hom</code> or <code>class is_continuous_ring_hom</code>. What do we choose?</p>",
        "id": 134537588,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537806858
    },
    {
        "content": "<p>Wedhorn says \"continuous ring homomorphism\"</p>",
        "id": 134537920,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537807240
    },
    {
        "content": "<p>I guess go with that one</p>",
        "id": 134537924,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537807256
    },
    {
        "content": "<p>I bet Wedhorn doesn't say <code>add_comm_group</code></p>",
        "id": 134537943,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1537807295
    },
    {
        "content": "<p>Nope.<br>\n\"Let <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">G</span></span></span></span> be a filtered abelian group (written additively), ...\"</p>",
        "id": 134538394,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537807867
    },
    {
        "content": "<blockquote>\n<p>Do you see a gap that isn't \"completions\" on which I could work?</p>\n</blockquote>\n<p>Unfortunately I don't have anything better than <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/LaTeX_docs/overview.tex\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/LaTeX_docs/overview.tex\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/LaTeX_docs/overview.tex</a> and Wedhorn. I think it's pretty hard to work on this without a clear view of the maths. However it should be rather easy for you to work on extracting from Wedhorn and Kevin's overview a detailed LaTeX file containing the full definition we are trying to formalize. Then everything would be easier</p>",
        "id": 134540645,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537810586
    },
    {
        "content": "<p>I really think that it would be super useful for everybody to have a complete LaTeX'ed version of the perfectoid project, including everything from the beginning (of course LaTeXing the definition of a group would be really low priority). It would be useful before finishing the Lean project but also after finishing, since people could then go back and forth between LaTeX and Lean, trying to match things.</p>",
        "id": 134540769,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537810716
    },
    {
        "content": "<p>Sorry, late to the party.</p>",
        "id": 134558347,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537824952
    },
    {
        "content": "<p>On the <code>working</code> branch of <code>lean-category-theory</code> there is a file defining the category of topological rings.</p>",
        "id": 134558396,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537824971
    },
    {
        "content": "<p>Does it work? <span class=\"emoji emoji-263a\" title=\"smile\">:smile:</span></p>",
        "id": 134558412,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537825003
    },
    {
        "content": "<p>Sorry this wasn't on <code>master</code> -- I've been trying to keep that compiling, and not depending on PRs to mathlib, but I have a stack of open PRs waiting on mathlib so it's been hard to reunite my <code>working</code> branch with <code>master</code>.</p>",
        "id": 134558417,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537825009
    },
    {
        "content": "<p>So <code>working</code> is the non-working branch</p>",
        "id": 134558435,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537825028
    },
    {
        "content": "<p>It may actually work :-)</p>",
        "id": 134558522,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537825097
    },
    {
        "content": "<p>Haven't actually looked at it in a few days.</p>",
        "id": 134558526,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537825104
    },
    {
        "content": "<p>It depends on commits to <code>leanprover-community/mathlib</code>.</p>",
        "id": 134558539,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537825130
    },
    {
        "content": "<p>which branch?</p>",
        "id": 134558629,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537825221
    },
    {
        "content": "<p>It looks like <code>TopRing.lean</code> itself compiles fine :-)</p>",
        "id": 134558630,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537825224
    },
    {
        "content": "<p>It depends on a branch called <code>scott/supremum</code> which is the supremum of my PRs. :-)</p>",
        "id": 134558643,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537825247
    },
    {
        "content": "<p>I should enquire sometime if there is an obstacle for those PRs. I think they're ready to go.</p>",
        "id": 134558657,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537825279
    },
    {
        "content": "<p>I see</p>",
        "id": 134558664,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537825291
    },
    {
        "content": "<p>You don't happen to have a branch with limits do you? I was thinking of making one</p>",
        "id": 134558680,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537825318
    },
    {
        "content": "<p>because most of the things I want to do are dependent on limits, and it's somewhat less convenient to use lean-category-theory as a dependency (for example I might want to modify the files related to limits)</p>",
        "id": 134558746,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537825378
    },
    {
        "content": "<p>I started on making one, but then it seemed like it might involve pulling in nontrivial amounts of lean-tidy</p>",
        "id": 134558771,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537825417
    },
    {
        "content": "<p>No, there's not yet. I did start porting, but realised I really wanted <code>backwards_reasoning</code> available in <code>mathlib</code> first, and then hit pause because I already have too many open PRs, and needed to do other work too. :-)</p>",
        "id": 134558850,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537825494
    },
    {
        "content": "<p>If you happen to want to push that to happen, you could either PR <code>backwards_reasoning</code> yourself, or review some of my open PRs so I either retract them or they get merged. :-)</p>",
        "id": 134558892,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537825544
    },
    {
        "content": "<p>Yes, I might take a stab at backwards_reasoning, since I also want it for other things (continuity).</p>",
        "id": 134558990,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537825662
    },
    {
        "content": "<p>Sorry I'm even later -- after quite a hectic weekend I'm spending Mon and Tue focussed on real life issues. <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I had a lot of energy for doing the Hilbert Basis Theorem last week, but when I realised that I had to fight with the old module system and then Mario kindly decided to refactor everything I decided I would use this as an excuse for focussing on my upcoming teaching (my class starts in 9 days' time and I'm still not ready). I did find the time to look at the repo from the top down. Johan if you're looking for some easy pickings then here are a couple of things which need doing. </p>\n<p>1) in valuations.lean I skipped a proof and this will surely bite us later. A valuation is continuous if (blah -- see Wedhorn). Note that in this definition you replace the target group Gamma with the subgroup generated by the image of the valuation -- this is important. With this definition, if two valuations are equivalent then one is continuous iff the other is. I did not prove this because at the time it involved extending a valuation on <code>R</code> to a valuation on <code>Frac(R/P)</code> with P the kernel (the \"support\") of the valuation and we didn't have field of fraction of an integral domain or proof that R/P is an integral domain for P prime -- I believe these are now there.</p>\n<p>2) in Spa.lean we need to prove completely trivial stuff about the topology, I'm in a rush now but basically the we have something like basic opens and rational opens, and for one of these things (maybe rational opens) the definition of the presheaf is \"the set is defined by |t1|&lt;=1,|t2|&lt;=1,... and |s|&gt;0, so localise R at s and then look at the ideal of R0 generated by the t_i and complete\". If we have a sorried ring completion we can make this definition and then ones attention turns to extending this definition across all of Spa(R) via a limit construction (if U is a union of rational opens Ui then define O_X(U) = proj lim of O_X(U_i)). You'll then run into the problem of having defined O_X(U) twice for U a rational open, so the first definition might be O_X^aux or something. But all this stuff is very do-able right now</p>",
        "id": 134580882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537862116
    },
    {
        "content": "<p>Thanks Kevin! I'll see if I can make progress on those while I'm on the train back to Freiburg tomorrow. Today is the PhD defense of my PhD brother. So I won't have much time for Lean today.</p>",
        "id": 134581284,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537862661
    },
    {
        "content": "<p>Do we really need Wedhorn's \"Remark and definition 8.5\" in order to define adic spaces? To me it looks like we could use the same kind of loophole as in the early scheme formalization, at a time when affine schemes were not yet schemes.</p>",
        "id": 134591981,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537877532
    },
    {
        "content": "<p>Maybe I should write 8.6 instead of 8.5. I meant: do we need to prove that, in the model case of Spa(A), stalks of the structure sheaf are local, with maximal ideal the support of the associated valuation</p>",
        "id": 134592095,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537877697
    },
    {
        "content": "<p>I think we do. The problem is that whilst the stalks and support are defined by the sheaf, the valuation is not. An adic space has a cover by affinoid adic spaces. If we only demand that the identification of an element of this cover with Spa(A) is an isomorphism of top spaces + presheaf of rings then we risk there potentially being the issue that two different rings corresponding to two open sets which have non-trivial intersection give rise to two different valuations on the local ring with the same support, so this would not be an adic space. I have absolutely no idea whether this can happen.</p>",
        "id": 134593124,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537878785
    },
    {
        "content": "<p>So there is a <code>quot.lift_beta</code> which I think is called <code>lift_mk</code> for other quotient types. But for <code>quotient</code> itself I didn't find anything like <code>lift_mk</code>... did I miss something?</p>",
        "id": 134661684,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537956465
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Is there a reason why <code>valuation.map_add</code> uses <code>.. ≤ .. ∨ .. ≤ ..</code> instead of <code>.. ≤ max .. ..</code>?</p>",
        "id": 134812584,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538127434
    },
    {
        "content": "<p>Did <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> write this?</p>",
        "id": 134812601,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538127464
    },
    {
        "content": "<p>If you didn't: yes</p>",
        "id": 134812607,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538127473
    },
    {
        "content": "<p>I am 50 now, I can't remember what I wrote :-(</p>",
        "id": 134812648,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538127487
    },
    {
        "content": "<p>Wait, you're 50? When did that happen? <span class=\"emoji emoji-1f606\" title=\"lol\">:lol:</span></p>",
        "id": 134812661,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538127505
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I've unlocked <code>rational_open_is_open</code>. So I think we can now define the sheaf on the rational open sets (up to ring completions).</p>",
        "id": 134825074,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538142299
    },
    {
        "content": "<p>After that we want to extend it to all opens, but this seems like a very generic procedure. So maybe we should prove some categorical lemmas about sheaves on basic opens</p>",
        "id": 134825112,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538142339
    },
    {
        "content": "<p>Kevin, I created a PR for this. It also fixes some notations and coercions. Please only merge the PR from my <code>Spa</code> branch.</p>",
        "id": 134825830,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538142995
    },
    {
        "content": "<p>After that, I guess there will be merge conflicts for my other two PR's. I will fix those later.</p>",
        "id": 134825847,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538143012
    },
    {
        "content": "<p>I have PR's??</p>",
        "id": 134831626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538147766
    },
    {
        "content": "<p>I do not get notified about these in any way.</p>",
        "id": 134831634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538147775
    },
    {
        "content": "<p>Johan -- can you follow Patrick's lead and just bluntly tell me about them? ;-)</p>",
        "id": 134831653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538147798
    },
    {
        "content": "<p>I am even watching the repo</p>",
        "id": 134831666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538147818
    },
    {
        "content": "<p>Weird... I expected you to get notified.</p>",
        "id": 134832218,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538148272
    },
    {
        "content": "<p>Anyway, you've got 3 PR's <span class=\"emoji emoji-1f606\" title=\"lol\">:lol:</span></p>",
        "id": 134832220,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538148280
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> In the upper right hand corner of the Github screen there is a bell icon <span class=\"emoji emoji-1f514\" title=\"bell\">:bell:</span>. If there is a blue dot <span class=\"emoji emoji-1f535\" title=\"blue circle\">:blue_circle:</span> on it, then it means you have notifications.</p>",
        "id": 134834619,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538150605
    },
    {
        "content": "<p>In that notification area I see all the activity on PR's to mathlib etc... I hope you would also see PR's to your repos there.</p>",
        "id": 134834682,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538150644
    },
    {
        "content": "<p>Not for me.</p>",
        "id": 134835382,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538151419
    },
    {
        "content": "<p>Oh thanks, I have some notification thing switched off.</p>",
        "id": 134836268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538152229
    },
    {
        "content": "<blockquote>\n<p>So I think we can now define the sheaf on the rational open sets (up to ring completions). After that we want to extend it to all opens, but this seems like a very generic procedure. So maybe we should prove some categorical lemmas about sheaves on basic opens</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Can you give an idea of how far we are from being able to do these things with our library? I guess the important thing we need is to be able to write down a (directed?) limit of complete topological rings (and prove that it exists...)</p>",
        "id": 134838777,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538155184
    },
    {
        "content": "<p>wait wait. We need a projective limit of topological rings with its topology, and we need a direct limit of topological rings but taken in the category of rings.</p>",
        "id": 134844825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538161397
    },
    {
        "content": "<p>My PR of limits into mathlib is held up at the moment because I want to PR <code>backwards_reasoning</code> first, and that is held up because I can significantly improve <code>backwards_reasoning</code>, essentially making it a generalisation of <code>solve_by_elim</code>, but I have a PR extending the behaviour of <code>solve_by_elim</code> already waiting for merge/review.</p>",
        "id": 134858374,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538177752
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/mathlib/pull/324\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/pull/324\">https://github.com/leanprover/mathlib/pull/324</a></p>",
        "id": 134858416,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538177811
    },
    {
        "content": "<p>Oh, I hadn't realized you were working on <code>backwards_reasoning</code>. I took a look at it today, but all I really did was clean up the code some--no functional changes (hopefully!)</p>",
        "id": 134860508,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538181771
    },
    {
        "content": "<p>I could PR my changes (to lean-tidy?) if that would still be useful</p>",
        "id": 134860515,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538181785
    },
    {
        "content": "<p>Absolutely! Maybe my comment above overstated what work I'd actually done. I've been _thinking_ about how to unify backwards_reasoning and solve_by_elim, but no code got written yet. :-)</p>",
        "id": 134861412,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538183374
    },
    {
        "content": "<p>I'm really looking forward to all this new stuff. <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> what is the status of colimits? In Orsay we discussed several strategies. Is there still something that needs to be resolved, or is it mostly a matter of time and administration?</p>",
        "id": 134867397,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538194815
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Github says that there are no merge conflicts for the other 2 PR's. So I think they are good to go.</p>",
        "id": 134888527,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538239539
    },
    {
        "content": "<p>OK, as good things go, they went.</p>",
        "id": 134900439,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538264867
    },
    {
        "content": "<p>So it seems that we're getting nearer. I added some comments in spa.lean briefly outlining the way. Proving things are presheafs -- we'll need some maps. We might need Wedhorn 8.2(2), not sure.</p>",
        "id": 134901337,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538267013
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, my plan for <code>backwards_reasoning</code> was to build on the new functionality for <code>solve_by_elim</code>, which lets you specify lemmas (or attributes to gather collections of lemmas) to also apply. </p>\n<p>Step 1 is probably to add <code>solve_by_elim!</code> which will succeed even if it doesn't finish the goal, as long as it can apply something (this one won't do any backtracking -- once some applies, it's applied). </p>\n<p>Step 2 is then just to define</p>\n<div class=\"codehilite\"><pre><span></span>meta  def backwards_reasoning = solve_by_elim [back]\n</pre></div>\n\n\n<p>(i.e. use solve_by_elim, but also use any lemma with attribute `back), and</p>\n<div class=\"codehilite\"><pre><span></span>meta def backwards_reasoning! = solve_by_elim! only [back!]\n</pre></div>\n\n\n<p>which will apply any lemmas tagged with <code>back!</code> (but won't use apply local hypotheses), even it it can't finish the goal.</p>\n<p>Step 3 is possibly to realise that there's almost no space between <code>solve_by_elim</code> and <code>backwards_reasoning</code>, decide which name should survive, and merge them.</p>",
        "id": 134910845,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538287733
    },
    {
        "content": "<p>Step 1b is to add an output mode which actually reports the successful <code>apply</code> steps, for creating tactic scripts.</p>",
        "id": 134910850,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538287757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> the status of colimits is exactly the same as the status of limits: both are waiting on me finding time to either remove the use of <code>backwards_reasoning</code> from their proofs, or PR <code>backwards_reasoning</code> as outlined to Reid just above.</p>",
        "id": 134910892,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538287811
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thanks for merging those PR's.</p>",
        "id": 134939944,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538349770
    },
    {
        "content": "<p>Pretty soon there should be a more general cleanup of the valuation files. All the <code>option</code> stuff can be replaced by <code>with_zero</code> for great good. Also, some of the files can probably be merged.</p>",
        "id": 134940002,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538349867
    },
    {
        "content": "<p>I think Kenny might have written those things just before those with bot etc types appeared</p>",
        "id": 134952532,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538374338
    },
    {
        "content": "<p>I agree. But now that they are there, it is nice to use them.</p>",
        "id": 134953041,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538375326
    },
    {
        "content": "<p>Kevin, I have defined a <code>Spv.lift</code> which should allow for \"nicer\" definitions, where we can treat valuations as actual valuation functions instead of inequality relations on the ring.</p>",
        "id": 134955166,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538379207
    },
    {
        "content": "<p>Oh that would be great! I was looking at the code the other day thinking how unreadable it was because of that inequality notation . It's done this way (inequalities) for universe reasons.</p>",
        "id": 134956471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538381372
    },
    {
        "content": "<p>Yes... I did have to impose <code>decidable_eq R</code> everywhere. I guess you don't care.</p>",
        "id": 134956696,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538381724
    },
    {
        "content": "<p>Not at all</p>",
        "id": 134956705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538381749
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Is this ok (see the other thread):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"err\">&#39;&#39;</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Valuation</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">is_continuous</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"err\">⁺</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 134956911,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538382072
    },
    {
        "content": "<p>I'm changing it to something that isn't defeq, but provably the same as you had. And I think this is pretty readable.</p>",
        "id": 134956956,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538382124
    },
    {
        "content": "<p>it would be even more readable with <code>∀ r ∈ A⁺</code> if the elaborator can do it</p>",
        "id": 134957178,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538382560
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Agreed, but alas. It doesn't like that <span class=\"emoji emoji-2639\" title=\"sad\">:sad:</span></p>",
        "id": 134957458,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538382960
    },
    {
        "content": "<p>I already had this issue, sometimes it needs a tiny bit of extra characters to put things in order</p>",
        "id": 134957513,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538383019
    },
    {
        "content": "<p>This is frustrating because it doesn't need <code>∀ r : A, r ∈ A⁺</code> so it looks like it could figure it out</p>",
        "id": 134957526,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538383059
    },
    {
        "content": "<p>Yes, but compared to what we had before this is a really minor inconvenience.</p>",
        "id": 134957643,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538383216
    },
    {
        "content": "<p>Mario told me to use the inequality definition</p>",
        "id": 134959313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538385861
    },
    {
        "content": "<p>I don't have access to lean right now but there are universe issues if you're not careful. I will have to collect my thoughts and try and remember what they were. Didn't I leave a bunch of Mario comments in the source code?</p>",
        "id": 134959358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538385958
    },
    {
        "content": "<p>You did</p>",
        "id": 134959401,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538385973
    },
    {
        "content": "<p>But your <code>minimal_valuation</code> stuff fixes those issues.</p>",
        "id": 134959410,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538385987
    },
    {
        "content": "<p>So you define <code>Valuation R</code> to be all the valuations that live in the same universe as <code>R</code>. And then you quotient by equivalence.</p>",
        "id": 134959423,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538386015
    },
    {
        "content": "<p>Given any valuation, you can always take the associated minimal one to lower your universe.</p>",
        "id": 134959435,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538386036
    },
    {
        "content": "<p>So <code>Spv.mk</code> takes any valuation, and gives an element of <code>Spv R</code>.</p>",
        "id": 134959446,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538386056
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Voila</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Valuation</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">is_continuous</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"err\">⁺</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"n\">heq</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">intro</span><span class=\"bp\">;</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">Valuation</span><span class=\"bp\">.</span><span class=\"n\">is_continuous_of_equiv_is_continuous</span> <span class=\"n\">heq</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">left</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">map_one</span> <span class=\"n\">at</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">v₂</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">map_one</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">r</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">heq</span> <span class=\"n\">r</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">right</span> <span class=\"n\">r</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">Valuation</span><span class=\"bp\">.</span><span class=\"n\">is_continuous_of_equiv_is_continuous</span> <span class=\"o\">(</span><span class=\"n\">setoid</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">heq</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">left</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">map_one</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">v₂</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">map_one</span> <span class=\"n\">at</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">r</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">heq</span> <span class=\"n\">r</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">right</span> <span class=\"n\">r</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Of course there is still a <code>sorry</code> hidden behind <code>Valuation.is_continuous_of_equiv_is_continuous</code>. But otherwise this stuff seems to be working.</p>",
        "id": 134970436,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538400962
    },
    {
        "content": "<p>Is it sufficiently universe polymorphic?</p>",
        "id": 134970607,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538401112
    },
    {
        "content": "<p>I have no idea what this question means, but it sounds cool when Mario write it</p>",
        "id": 134970636,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538401148
    },
    {
        "content": "<p>Well, <code>Spv R</code> should live in the same universe as <code>R</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">Spv</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">R</span><span class=\"o\">],</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">R</span><span class=\"o\">],</span>\n  <span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Valuation</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 134970737,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538401276
    },
    {
        "content": "<p>And <code>Spa</code> is just a subset</p>",
        "id": 134970741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538401290
    },
    {
        "content": "<p>The question is whether we think this is more readable then the inequalities.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">basic_open</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Valuation</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"n\">heq</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">intro</span><span class=\"bp\">;</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">heq</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">left</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">Valuation</span><span class=\"bp\">.</span><span class=\"n\">ne_zero_of_equiv_ne_zero</span> <span class=\"n\">heq</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">right</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">heq</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">left</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">Valuation</span><span class=\"bp\">.</span><span class=\"n\">ne_zero_of_equiv_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">setoid</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">heq</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">right</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span><span class=\"o\">)</span>\n<span class=\"err\">∘</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n</pre></div>\n\n\n<p>Note the last line. Isn't it ugly <span class=\"emoji emoji-1f61c\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span> ?</p>",
        "id": 134974057,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538404288
    },
    {
        "content": "<p>With the inequalities, all these definitions are one-liners. But there is a mathematical disconnect with the code.</p>",
        "id": 134974090,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538404320
    },
    {
        "content": "<p>With all this <code>Spv.lift</code>, we are actually formalising the maths. But I'm not sure if readability increases...</p>",
        "id": 134974162,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538404353
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I think that all the rewriting I've done so far is probably useful. Now I feel I'm at a fork: either we decide to use the ugly inequalities, or we decide to use the ugly lift. I'dd like to get feedback (from Kevin, but also from others) what the best path is.</p>",
        "id": 134974758,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538404806
    },
    {
        "content": "<p>For comparison, this is what we used to have: <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/Spa.lean#L8-L12\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/Spa.lean#L8-L12\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/Spa.lean#L8-L12</a></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">vs</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">is_continuous</span> <span class=\"n\">vs</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"err\">⁺</span> <span class=\"bp\">→</span> <span class=\"n\">vs</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">r</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- basic open corresponding to r, s is v : v(r) &lt;= v(s) and v(s) isn&#39;t 0 ( = v(0) ) -/</span>\n<span class=\"kn\">definition</span> <span class=\"n\">basic_open</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">vs</span> <span class=\"bp\">|</span> <span class=\"n\">vs</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">vs</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">s</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 134974817,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538404875
    },
    {
        "content": "<p>And <a href=\"https://github.com/jcommelin/lean-perfectoid-spaces/blob/valuations/src/Spa.lean#L11-L43\" target=\"_blank\" title=\"https://github.com/jcommelin/lean-perfectoid-spaces/blob/valuations/src/Spa.lean#L11-L43\">https://github.com/jcommelin/lean-perfectoid-spaces/blob/valuations/src/Spa.lean#L11-L43</a> is my branch</p>",
        "id": 134975154,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538405200
    },
    {
        "content": "<p>One thing I do know is that by the time I wrote <code>basic_open</code> I realised I was very unhappy with the definition, which is simple and readable in Wedhorn and looks awful the way I wrote it. It says <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi><mo>(</mo><mi>r</mi><mo>)</mo><mo>≤</mo><mi>v</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">v(r)\\leq v(s)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mrel\">≤</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathit\">s</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi><mo>(</mo><mi>s</mi><mo>)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">v(s)&gt;0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathit\">s</span><span class=\"mclose\">)</span><span class=\"mrel\">&gt;</span><span class=\"mord mathrm\">0</span></span></span></span>, but what I wrote looks nothing like this.</p>",
        "id": 134975244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538405288
    },
    {
        "content": "<p>But what is your first impression when you see my version?</p>",
        "id": 134975272,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538405333
    },
    {
        "content": "<p>Regarding lifts -- why not just prove that continuity is constant across equivalence classes first, and then make a beautiful definition?</p>",
        "id": 134975295,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538405356
    },
    {
        "content": "<p>What would that sorried definition look like?</p>",
        "id": 134975308,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538405381
    },
    {
        "content": "<p>I don't think that continuity is the problem</p>",
        "id": 134975312,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538405390
    },
    {
        "content": "<p>I have sorried the proof that continuity is constant on equivalence classes. But you still get something ugly. You could factor out the <code>Cont</code>, but then the second condition would remain, and it would require a <code>Spv.lift</code> that is about as long and nasty as what I have now.</p>",
        "id": 134975497,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538405584
    },
    {
        "content": "<p>I hope a CS wizard sees some pattern in what we are doing, and knows how to improve it.</p>",
        "id": 134975510,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538405603
    },
    {
        "content": "<p>I think the CS people will never read this stuff until we produce a MWE which is comprehensible</p>",
        "id": 134975588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538405670
    },
    {
        "content": "<p>One can abstract away all the maths and get straight to the point</p>",
        "id": 134975598,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538405685
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> understands what we are up to.</p>",
        "id": 134975604,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538405700
    },
    {
        "content": "<p>Oh OK. I thought he said he still couldn't run the code.</p>",
        "id": 134975612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538405712
    },
    {
        "content": "<p>I am only half paying attention today, I'm busy in Cambridge</p>",
        "id": 134975624,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538405729
    },
    {
        "content": "<p>I haven't even understood what this <code>Valuation</code> is. Did the v change to a capital for a reason? What I'm saying is that I'm not at all on top of the point of this thread yet.</p>",
        "id": 134975692,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538405771
    },
    {
        "content": "<p><code>Valuation</code> bundles <code>valuation</code> with groups in the same universe as <code>R</code>.</p>",
        "id": 134975710,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538405803
    },
    {
        "content": "<p>In my experience it makes <code>mk</code> and <code>lift</code> etc easier to work with.</p>",
        "id": 134975726,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538405825
    },
    {
        "content": "<p>Even though <code>Spv</code> is still defined via inequalities, instead of using <code>quot</code></p>",
        "id": 134975745,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538405847
    },
    {
        "content": "<p>Anyway, I need to be caught by a train. See you later.</p>",
        "id": 134975828,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538405932
    },
    {
        "content": "<p>Those statements aren't in contradiction. I know what you guys are doing, but I still can't run the code</p>",
        "id": 134976338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538406367
    },
    {
        "content": "<p>As for \"sufficiently universe polymorphic\", now the goal is to prove the defining equation of <code>basic_open</code>, which BTW will be much easier to read since it won't have that well definedness part in the statement</p>",
        "id": 134976400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538406453
    },
    {
        "content": "<p>The reason for fussing about minimal valuations is so that you can prove it even when the valuation lives in a universe other than the one over which the quotient is defined</p>",
        "id": 134976484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538406519
    },
    {
        "content": "<p>I am just going to try and write some minimal working code right now because I have half-forgotten the definitions.</p>",
        "id": 134976845,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538406871
    },
    {
        "content": "<p>Here's what I remember. <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I have written two definitions of <code>Spa</code> corresponding to the way I did it at</p>\n<p><a href=\"https://gist.github.com/kbuzzard/a3ef594410cd184c992e73d06cbad229\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/a3ef594410cd184c992e73d06cbad229\">https://gist.github.com/kbuzzard/a3ef594410cd184c992e73d06cbad229</a></p>\n<p>Can you summarise what you're saying?</p>\n<p>I am wondering whether Spv is just a waste of time by the way. I'm not sure we ever use it. See my Spa2 which avoids it completely.</p>",
        "id": 134979116,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538409260
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> We had a working <code>Spa</code> including topology. When you say</p>\n<blockquote>\n<p>now the goal is to prove the defining equation of basic_open, which BTW will be much easier to read since it won't have that well definedness part in the statement</p>\n</blockquote>\n<p>Do you mean to prove it in terms of the inequalities?<br>\nMy objection to that is that it looks very unfamiliar to a mathematician. Let me put it like this: the definition in terms of inequalities is provably equal to the one mathematicians use, but it is not <em>defeq</em>.<br>\nHence I started working on <code>lift</code>, and now we can define these things in the way a mathematician does. But it comes with more proof obligations, and it seems that readability decreases.</p>",
        "id": 134982114,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538412547
    },
    {
        "content": "<p>defeq is impossible here, because the \"definition\" would have to quantify over all universes</p>",
        "id": 134982465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538412967
    },
    {
        "content": "<p>In terms of kevin's MWE:</p>\n<div class=\"codehilite\"><pre><span></span>def Spa2.mk {R : Type u} {Γ : Type v} [preorder Γ] (v : valuation R Γ) : Spa2 R := sorry\n\ntheorem mem_basic_open2 {R : Type u} [has_zero R] (r s : R) {Γ : Type v} [preorder Γ] (v : valuation R Γ) :\n  Spa2.mk v ∈ basic_open2 r s ↔ v r ≤ v s ∧ v 0 &lt; v s := sorry\n</pre></div>",
        "id": 134982885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538413530
    },
    {
        "content": "<p>Re: Spv is a waste of time, how much do discontinuous valuations matter for your work? You could just bundle continuity into the properties of a valuation otherwise</p>",
        "id": 134982951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538413615
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Of course it is impossible to make those definitions defeq. But we have to choose a definition in the end. So my question to Zulip is: is there a clear preference for one or the other?</p>",
        "id": 134983081,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538413768
    },
    {
        "content": "<p>Concerning <code>Spv</code>, I think it would also be useful for Zariski-Riemann spaces. But I'm not planning to work on those in the near future.</p>",
        "id": 134983089,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538413798
    },
    {
        "content": "<p>I would have a preference either for the relational version (because it's short and correct), which you could also clean up with some notations probably, or using the <code>quotient.mk ''</code> approach, written out as <code>\\ex {Γ : Type v} [preorder Γ] (v : valuation R Γ), Spa.mk v = q /\\ facts about v</code></p>",
        "id": 134983189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538413904
    },
    {
        "content": "<p>Bundling valuations is also an option, but I think that since you don't get to pick the valuation group with this approach, it has little to recommend it over plain relations</p>",
        "id": 134983270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538413984
    },
    {
        "content": "<p>If I recall correctly the content of <code>minimal_valuation</code> is that for any <code>Spa</code> there is a canonical valuation that represents it</p>",
        "id": 134983390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538414107
    },
    {
        "content": "<p>I think we can even construct a valuation given an <code>ineq</code>.</p>",
        "id": 134983407,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538414139
    },
    {
        "content": "<p>that's what I mean</p>",
        "id": 134983411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538414146
    },
    {
        "content": "<p>interface is something like this</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">Spa2</span><span class=\"bp\">.</span><span class=\"err\">Γ</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spa2</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">instance</span> <span class=\"n\">Spa2</span><span class=\"bp\">.</span><span class=\"n\">preorder</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spa2</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"err\">Γ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"n\">def</span> <span class=\"n\">Spa2</span><span class=\"bp\">.</span><span class=\"n\">minimal_valuation</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spa2</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"err\">Γ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">Spa2</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">minimal_valuation</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 134983625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538414388
    },
    {
        "content": "<p>then you can just write</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">basic_open3</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">Spa2</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">vs</span> <span class=\"bp\">|</span> <span class=\"n\">vs</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">vs</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">vs</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">vs</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 134983730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538414499
    },
    {
        "content": "<p>What I meant is that I think you can pick everything. The value group would be a subgroup of <code>units (Frac (R/P))</code> where <code>P</code> is the prime ideal <code>{ x | ineq x 0 }</code>. But I should add that I haven't worked out the math details... so maybe I'm wrong.</p>",
        "id": 134984137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538414886
    },
    {
        "content": "<p>right, kevin did this already</p>",
        "id": 134984156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538414908
    },
    {
        "content": "<p>So there should be a (computable?) map from <code>Spv</code> to <code>quot Valuation.setoid</code>. And <code>mk</code> goes the other way. This pair is then an equiv.</p>",
        "id": 134984182,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538414936
    },
    {
        "content": "<p>and that's what would go in for the <code>sorry</code>s above</p>",
        "id": 134984184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538414938
    },
    {
        "content": "<p>No, Kevin, didn't do that.</p>",
        "id": 134984189,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538414942
    },
    {
        "content": "<p>(the map is not computable but w/e)</p>",
        "id": 134984207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538414957
    },
    {
        "content": "<p>Kevin constructed a minimal candidate given a <code>v : valuation</code>, but not starting from <code>ineq</code>.</p>",
        "id": 134984209,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538414962
    },
    {
        "content": "<p>By definition, that candidate is equivalent to the original valuation</p>",
        "id": 134984229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415001
    },
    {
        "content": "<p>and it only uses facts about the relation</p>",
        "id": 134984290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415020
    },
    {
        "content": "<p>Could you link to it?</p>",
        "id": 134984308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415045
    },
    {
        "content": "<p>To what?</p>",
        "id": 134984312,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415052
    },
    {
        "content": "<p><code>minimal_valuation</code></p>",
        "id": 134984396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415136
    },
    {
        "content": "<p>What I am saying is that currently <code>lift</code> is <code>noncomputable</code>, but I think we can remove the <code>noncomputable</code>.</p>",
        "id": 134984405,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415158
    },
    {
        "content": "<p>Ok, I'll look it up.</p>",
        "id": 134984407,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415166
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/valuation_spectrum.lean#L99\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/valuation_spectrum.lean#L99\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/valuation_spectrum.lean#L99</a></p>",
        "id": 134984417,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415196
    },
    {
        "content": "<p>That's Kevin's version.</p>",
        "id": 134984419,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415201
    },
    {
        "content": "<p>My current version is the same up to moving stuff around and bundling.</p>",
        "id": 134984434,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415230
    },
    {
        "content": "<p>What we currently do not have is anything about <code>Frac (R / P)</code></p>",
        "id": 134984478,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415247
    },
    {
        "content": "<p>But that stuff should certainly be doable. I tried it and ran into trouble with <code>ideal</code> instances, and decided to wait for you module refactor.</p>",
        "id": 134984492,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415290
    },
    {
        "content": "<p>In Kevin's definition, the Gamma is <code>quotient (is_group_hom.ker φ)</code> where <code>φ : FG → Γ2 := λ f, finsupp.prod f (λ r n,(φ₀ r) ^ n)</code></p>",
        "id": 134984694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415558
    },
    {
        "content": "<p>is there a way to write that in terms of the <code>ineq</code> generated by the valuation?</p>",
        "id": 134984706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415574
    },
    {
        "content": "<p>There is a map from <code>R</code> to <code>with_zero (units (Frac (R/P)))</code>, right?</p>",
        "id": 134984791,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415632
    },
    {
        "content": "<p>You take the subgroup generated by the non-zero elements in the image</p>",
        "id": 134984813,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415659
    },
    {
        "content": "<p>No universe issues, if I'm not silly again.</p>",
        "id": 134984830,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415688
    },
    {
        "content": "<p>Is that what's happening here? It's hard to tell</p>",
        "id": 134984834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415693
    },
    {
        "content": "<p>Kevin has the free Z module and an extension to option</p>",
        "id": 134984847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415713
    },
    {
        "content": "<p>Right, but the <code>option</code> is just <code>with_zero</code></p>",
        "id": 134984893,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415731
    },
    {
        "content": "<p>and the free <code>Z</code>-module is for universe lowering.</p>",
        "id": 134984904,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415746
    },
    {
        "content": "<p>yes, this used to be the only option <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>",
        "id": 134984905,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538415750
    },
    {
        "content": "<p>There is no universe lowering needed if you start from the <code>ineq</code></p>",
        "id": 134984929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415788
    },
    {
        "content": "<p>Right, that's exactly what I'm saying.</p>",
        "id": 134984939,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415801
    },
    {
        "content": "<p>You do need an API to fraction fields etc</p>",
        "id": 134984951,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415827
    },
    {
        "content": "<p>What is needed in mathlib's fraction fields?</p>",
        "id": 134985007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415851
    },
    {
        "content": "<p>I think Kenny wrote localizations a while back</p>",
        "id": 134985016,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415867
    },
    {
        "content": "<p>I think most of it is there. I'm just hoping that it works more smoothly after your refactoring</p>",
        "id": 134985022,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415877
    },
    {
        "content": "<p>Currently all my code gravitates to a lot of <code>@</code>s</p>",
        "id": 134985032,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415889
    },
    {
        "content": "<p>I don't like that</p>",
        "id": 134985034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415893
    },
    {
        "content": "<p>Then stop preventing Mario from working on his module refactoring!</p>",
        "id": 134985060,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538415916
    },
    {
        "content": "<p>it occurs to me that perhaps I should try to avoid letting expectations rise too much on this refactoring</p>",
        "id": 134985087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415949
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> So you are saying we should just go for the <code>ineq</code> statements everywhere, even though that is <em>non-trivially</em> equal to what mathematicians write. Is that correct?</p>",
        "id": 134985089,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415956
    },
    {
        "content": "<p>yes</p>",
        "id": 134985118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415962
    },
    {
        "content": "<p>Hmmm, I don't like that... but you are probably right.</p>",
        "id": 134985150,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415980
    },
    {
        "content": "<p>This is the replacement for using <code>quot.lift</code></p>",
        "id": 134985152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538415982
    },
    {
        "content": "<p>It also means that we don't need any form of <code>lift</code> anymore</p>",
        "id": 134985167,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538415999
    },
    {
        "content": "<p>you have to use operations that are manifestly invariant of the choice</p>",
        "id": 134985170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538416004
    },
    {
        "content": "<p>For example <code>v s \\ne 0</code> becomes <code>\\not ineq s 0</code>. That the two are equal requires thought. Not much, but it means that every time we have to triple check if we are actually still doing the same as in the \"maths world\".</p>",
        "id": 134985302,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538416117
    },
    {
        "content": "<p>This sounds bad</p>",
        "id": 134985499,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538416289
    },
    {
        "content": "<p>You can write the statement as <code>v' s \\ne 0</code> where <code>v' : Spa R</code> has a coercion to the minimal valuation</p>",
        "id": 134985610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538416390
    },
    {
        "content": "<p>that's what I did above</p>",
        "id": 134985618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538416401
    },
    {
        "content": "<p>Aah, that's smart! I like that.</p>",
        "id": 134985628,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538416420
    },
    {
        "content": "<p>Where did you do that?</p>",
        "id": 134985630,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538416425
    },
    {
        "content": "<p>I didn't register a <code>coe</code> anywhere</p>",
        "id": 134985637,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538416433
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/subject/Perfectoid.20spaces/near/134983625\" title=\"#narrow/stream/116395-maths/subject/Perfectoid.20spaces/near/134983625\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/subject/Perfectoid.20spaces/near/134983625</a></p>",
        "id": 134985641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538416436
    },
    {
        "content": "<p>Nice. That is good!</p>",
        "id": 134985721,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538416485
    },
    {
        "content": "<p>Then you can write theorems (simp lemmas) saying <code>Spa.mk v s = 0 &lt;-&gt;  v s = 0</code> and so on</p>",
        "id": 134985724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538416487
    },
    {
        "content": "<p>and these are using the fact that the minimal valuation is equivalent to the generator</p>",
        "id": 134985763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538416532
    },
    {
        "content": "<p>Right. And that is a non-trivial theorem.</p>",
        "id": 134985783,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538416556
    },
    {
        "content": "<p>So we could already do this now. Even though the <code>minimal_valuation</code> is currently not computable from <code>ineq</code>, right?</p>",
        "id": 134985853,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538416588
    },
    {
        "content": "<p>Also, does the inverse of <code>mk</code> have a canonical name?</p>",
        "id": 134985928,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538416666
    },
    {
        "content": "<p>it doesn't usually have an inverse</p>",
        "id": 134985988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538416686
    },
    {
        "content": "<p>mathlib uses <code>quot.out</code> for a noncomputable inverse</p>",
        "id": 134986012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538416701
    },
    {
        "content": "<p><code>section</code>?</p>",
        "id": 134986232,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538416902
    },
    {
        "content": "<p>Ok, and I guess no one will be angry if <code>out</code> turns out to be computable in the end, right?</p>",
        "id": 134986451,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538417083
    },
    {
        "content": "<p>If there is no choice...</p>",
        "id": 134986487,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538417110
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> The computer scientists keep stealing all our favourite keywords and letters....</p>",
        "id": 134986497,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538417120
    },
    {
        "content": "<p>lambda, section, etc...</p>",
        "id": 134986504,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538417128
    },
    {
        "content": "<blockquote>\n<p>What I meant is that I think you can pick everything. The value group would be a subgroup of <code>units (Frac (R/P))</code> where <code>P</code> is the prime ideal <code>{ x | ineq x 0 }</code>. But I should add that I haven't worked out the math details... so maybe I'm wrong.</p>\n</blockquote>\n<p>I made the value group a quotient group of the free abelian group on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> if I remember correctly, and this was because at the time I believe that neither \"<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">R/P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span></span></span></span> is an ID\" nor construction of field of fractions of an ID were in mathlib. I asked Chris explicitly if he'd do them and I believe he did (they might be next to each other somewhere in an algebra file?)</p>",
        "id": 135000526,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538432951
    },
    {
        "content": "<p>I like the look of this <code>coe</code> trick. Sorry, I've been away all day marketing (telling Coates and Wiles about Lean).</p>",
        "id": 135000686,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538433154
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> and <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> thanks a lot both of you for your work on the perfectoid project during this very busy time for me.</p>",
        "id": 135000963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538433600
    },
    {
        "content": "<blockquote>\n<p>Sorry, I've been away all day marketing (telling Coates and Wiles about Lean).</p>\n</blockquote>\n<p>Did you get any interesting reactions?</p>",
        "id": 135018113,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538463961
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Voila</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">Spv</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Valuation</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_continuous</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"err\">⁺</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 135018609,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538464916
    },
    {
        "content": "<p>I think that is looking really nice! Kudos to Mario!</p>",
        "id": 135018652,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538464936
    },
    {
        "content": "<p>The <code>coe</code> isn't transparent, but maybe that's not a problem.</p>",
        "id": 135018667,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538464961
    },
    {
        "content": "<p>Coates said I'd be putting everyone out of a job (and whenever anyone makes that comment I tell them that this is exactly my plan). With Wiles I had a technical discussion involving papers we both knew and which had technical flaws in, and how formal proof verification methods were nowhere near being able to help with these issues. But then I argued that it was not impossible that computers would be able to help in the future, perhaps with basic sanity checks or edge cases, and to make this a reality we needed to engage. My case was helped a great deal by Jack Thorne, a young guy who is Cambridge math's newest full professor, being present too, and Thorne randomly announced very early on in the discussion that he followed my blog and found it very interesting. That was basically when I decided I'd go for it.</p>",
        "id": 135018671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538464979
    },
    {
        "content": "<p>Of course this means that we aren't checking independence of <code>v</code>. We are just imposing conditions on a \"canonical\" representative.</p>",
        "id": 135018679,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538465015
    },
    {
        "content": "<p>Aah, that's cool!</p>",
        "id": 135018728,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538465055
    },
    {
        "content": "<p>Did you invite Jack to this Zulip?</p>",
        "id": 135018735,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538465070
    },
    {
        "content": "<blockquote>\n<p>I think that is looking really nice! Kudos to Mario!</p>\n</blockquote>\n<p>And to you sir. That is looking much better. Thanks for thinking about this! I really have my hands full until Thursday. I am hoping to get some Lean done over the weekend.</p>",
        "id": 135018740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538465086
    },
    {
        "content": "<p>No problem.</p>",
        "id": 135018741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538465096
    },
    {
        "content": "<p>We need that if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi><mo>⊆</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">U\\subseteq V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">V</span></span></span></span> are rational opens then there's a continuous restriction map.</p>",
        "id": 135018758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538465141
    },
    {
        "content": "<p>I am still on the fence about the \"well-definedness\" thing. Mathematicians almost never mention it. They just keep track when they think it is necessary to mention it.</p>",
        "id": 135018759,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538465144
    },
    {
        "content": "<p>Somehow checking on a canonical representative comes close enough. And I really don't like interspersing everything with long proofs.</p>",
        "id": 135018804,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538465185
    },
    {
        "content": "<p>Maybe an <code>auto_param</code> could make <code>obviously</code> take care of those things in the near future. That would be really nice.</p>",
        "id": 135018813,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538465215
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I am going to rewrite the rest of the Spa file with this new setup, and then you can expect another PR.</p>",
        "id": 135018824,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538465241
    },
    {
        "content": "<p>You should define <code>Spa.is_continuous</code>, as both a way to eliminate the coercion in the middle and also to indicate that this is an invariant property</p>",
        "id": 135019272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538465914
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/21\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/pull/21\">https://github.com/kbuzzard/lean-perfectoid-spaces/pull/21</a></p>",
        "id": 135019393,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466115
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Yes, we could do that. But then you prove that continuity is an invariant property, but you don't prove this for the other conditions.</p>",
        "id": 135019437,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466151
    },
    {
        "content": "<p>I think we could indeed rewrite it into <code>v \\in (Cont A)</code></p>",
        "id": 135019444,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466179
    },
    {
        "content": "<p>I think that all the definitions on Spa should be invariant, since it is morally a quotient, even though your canonical representative means you don't strictly speaking need to be invariant when you don't want to</p>",
        "id": 135019519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538466321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Sure, but should they be invariant because <em>we</em> know they are (a proof exists), or because <em>Lean</em> knows they are?</p>",
        "id": 135019603,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466478
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/ba77b91b6108cfa3f6327fb49cd9dbe903452201/src/Spa.lean#L11-L12\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/ba77b91b6108cfa3f6327fb49cd9dbe903452201/src/Spa.lean#L11-L12\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/ba77b91b6108cfa3f6327fb49cd9dbe903452201/src/Spa.lean#L11-L12</a> now says</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spa</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">Spv</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">Cont</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"err\">⁺</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>That's almost literally what Wedhorn writes! (I'm so happy <span class=\"emoji emoji-1f606\" title=\"lol\">:lol:</span>)</p>",
        "id": 135019668,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466560
    },
    {
        "content": "<p>we know they are, and we tell lean</p>",
        "id": 135019670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538466563
    },
    {
        "content": "<p>Cool</p>",
        "id": 135019677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466581
    },
    {
        "content": "<p>Do you have a good suggestion on how to do that, without ruining all our nice readable formulas?</p>",
        "id": 135019688,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466601
    },
    {
        "content": "<p>I don't really see how.</p>",
        "id": 135019731,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466606
    },
    {
        "content": "<p>the theorems will look reasonably nice</p>",
        "id": 135019740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538466625
    },
    {
        "content": "<p><code>P (Spa.mk v) &lt;-&gt; P' v</code> where <code>P</code> and <code>P'</code> are properties on <code>Spa</code> and <code>valuation</code> respectively</p>",
        "id": 135019753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538466672
    },
    {
        "content": "<p>i.e. <code>Spa.mk v ∈ Cont A &lt;-&gt; v.is_continuous</code></p>",
        "id": 135019812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538466743
    },
    {
        "content": "<p>I see. And you just state those theorems. But they don't appear in the definitions of <code>Spa</code> and <code>basic_open</code> etc...</p>",
        "id": 135019850,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466841
    },
    {
        "content": "<p>right</p>",
        "id": 135019898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538466861
    },
    {
        "content": "<p>you might want to set them up as simp lemmas</p>",
        "id": 135019904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538466872
    },
    {
        "content": "<p>How would you name these?</p>",
        "id": 135019907,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466875
    },
    {
        "content": "<p><code>Spa.sound</code> and <code>basic_open.sound</code> etc?</p>",
        "id": 135019910,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466885
    },
    {
        "content": "<p><code>Spa.mk_mem_Cont</code></p>",
        "id": 135019916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538466900
    },
    {
        "content": "<p><code>sound</code> is a specific property of quotients that I don't think has come up yet</p>",
        "id": 135019928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538466934
    },
    {
        "content": "<p><code>v \\equiv v' -&gt; Spa.mk v = Spa.mk v'</code></p>",
        "id": 135019934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538466958
    },
    {
        "content": "<p>I see. Should I prove that one?</p>",
        "id": 135019976,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466976
    },
    {
        "content": "<p>I guess so</p>",
        "id": 135019977,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538466981
    },
    {
        "content": "<p>yes, I don't think it follows from the other stuff</p>",
        "id": 135019980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538467001
    },
    {
        "content": "<p>How about <code>basic_open.well_defined</code>?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">basic_open</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 135019986,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538467016
    },
    {
        "content": "<p>but it's pretty trivial given what you know about the minimal valuation</p>",
        "id": 135019988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538467019
    },
    {
        "content": "<p><code>Spa.mk v \\in basic_open r s &lt;-&gt; v r ≤ v s ∧ v s ≠ 0</code></p>",
        "id": 135020001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538467045
    },
    {
        "content": "<p>note that the stuff on the right is not the same as what was in the set builder</p>",
        "id": 135020011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538467069
    },
    {
        "content": "<p>I'd call it <code>mk_mem_basic_open</code></p>",
        "id": 135020058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538467100
    },
    {
        "content": "<p>Ok, I see.</p>",
        "id": 135020223,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538467362
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Next problem <span class=\"emoji emoji-1f606\" title=\"lol\">:lol:</span> :</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">basic_open</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">mk_mem_basic_open</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Valuation</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">mk</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">basic_open</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 135022593,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538470895
    },
    {
        "content": "<p>It is unhappy about the <code>\\in</code>.</p>",
        "id": 135022595,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538470904
    },
    {
        "content": "<p>Because <code>mk v</code> lives in <code>Spv A</code> and now <code>Spa A</code> is a subtype of <code>Spv A</code>.</p>",
        "id": 135022643,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538470928
    },
    {
        "content": "<p>Should I just create a <code>has_mem (Spv A) (Spa A)</code>?</p>",
        "id": 135022651,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538470954
    },
    {
        "content": "<p>you mathematicians always making identifications</p>",
        "id": 135022652,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1538470957
    },
    {
        "content": "<p>Well, it brought us quite far. We're still ahead of the formalisation community...</p>",
        "id": 135022668,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538471004
    },
    {
        "content": "<p>I agree we had a couple thousand years head start</p>",
        "id": 135022673,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538471016
    },
    {
        "content": "<p>Does this make sense. Or is it evil?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">set_Spa_has_mem_Spv</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"o\">(</span><span class=\"n\">Spv</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">v</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">dite</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">false</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 135023984,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538472696
    },
    {
        "content": "<p>why not using the <code>if h : v ∈ Spa A then (⟨v, h⟩ : Spa A) ∈ S else false</code> syntax?</p>",
        "id": 135024077,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538472812
    },
    {
        "content": "<p>This is so much easier to read</p>",
        "id": 135024083,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538472821
    },
    {
        "content": "<p>You are right. But in the end I think we shouldn't do this anyway. It might be better to just carry the <code>h : v ∈ Spa A</code> around.</p>",
        "id": 135024789,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538473552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Ok, I pushed one more commit. I'm really happy about this now.</p>",
        "id": 135025390,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538474127
    },
    {
        "content": "<p>Thanks for letting me know Johan.</p>",
        "id": 135025395,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538474137
    },
    {
        "content": "<p>And thanks a lot for your work on this.</p>",
        "id": 135025396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538474142
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Oops. There was a silly tiny bug left. I opened a new PR. It also deletes the file <code>valuation_universes</code> because that is now merged into the other files.</p>",
        "id": 135038909,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538489955
    },
    {
        "content": "<blockquote>\n<p>Now stop kidding: where is our sheaf theory?</p>\n</blockquote>\n<p>If module refactoring and completion of rings and integral closure were all done, and I had the time to write some more code myself, my <em>first question</em> would be: \"Am I supposed to prove that a projective limit of complete topological rings is a complete topological ring? If so, should I just prove it from first principles? Or am I supposed to be waiting for some sort of category-theoretic knight in shining armour to come and whisk me away, and he'll tell me it's OK because the category of complete topological rings is known to have all limits by some sort of magic?\" This is the first question I do not know the answer to.</p>",
        "id": 135155301,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538635513
    },
    {
        "content": "<p>If the knight in shining armour exists I would definitely suggest waiting for him.</p>",
        "id": 135155572,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538635988
    },
    {
        "content": "<p>Let's ping him then</p>",
        "id": 135155574,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538636001
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> ?</p>",
        "id": 135155575,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538636005
    },
    {
        "content": "<p>And <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span></p>",
        "id": 135155578,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538636015
    },
    {
        "content": "<p>sure</p>",
        "id": 135155580,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538636026
    },
    {
        "content": "<p>but that knight might be sleeping</p>",
        "id": 135155635,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538636092
    },
    {
        "content": "<p>In the mean, let me say that I wrote <a href=\"https://gist.github.com/PatrickMassot/7b2576129e7f7b61d328f7fb10d5214d\" target=\"_blank\" title=\"https://gist.github.com/PatrickMassot/7b2576129e7f7b61d328f7fb10d5214d\">https://gist.github.com/PatrickMassot/7b2576129e7f7b61d328f7fb10d5214d</a> yesterday night. I still need some cleanup in the general stuff, but mostly it needs to be rewritten multiplicatively put through the <code>to_additive</code> machine, and then see how much this can be reused for rings</p>",
        "id": 135155817,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538636404
    },
    {
        "content": "<p>But today I have six math talks to attend</p>",
        "id": 135155875,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538636443
    },
    {
        "content": "<p>Ouch. Good luck!</p>",
        "id": 135155905,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538636506
    },
    {
        "content": "<p>And thanks for that gist! Sweet progress</p>",
        "id": 135155953,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538636546
    },
    {
        "content": "<p>It's our research group official academic year kick off. All those talks are given by new members (one permanent and many post-docs). It's hard to skip since I'm the new head of the group</p>",
        "id": 135155971,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538636609
    },
    {
        "content": "<p>Well, in that case: enjoy!</p>",
        "id": 135156017,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538636653
    },
    {
        "content": "<p>Maybe I should ping <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> about that gist: it's not yet push-ready but you can already have a look. My plan is to put everything before groups into <code>continuity.lean</code>, and the end into <code>topological_structure.lean</code></p>",
        "id": 135156049,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538636733
    },
    {
        "content": "<p>I should also point out something weird: I cannot <code>open quotient_add_group</code> at the beginning of the file, or even one declaration earlier, Lean complains that's an invalid name</p>",
        "id": 135156111,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538636819
    },
    {
        "content": "<p><code>lemma quotient_group_saturate</code> would go in <code>quotient_group.lean</code></p>",
        "id": 135156126,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538636860
    },
    {
        "content": "<p>The gist looks good to me. I guess for the <code>is_open_map.prod</code> it would help to express <code>is_open_map</code> in terms of neighborhoods:<br>\n<code>∀(a:α) (U ∈(nhd a).sets), f '' U ∈(nhd (f a)).sets</code>.</p>",
        "id": 135156581,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538637550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> When Wedhorn says that a ring is <em>adic</em>, this just means that there exists an ideal <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi><mo>⊂</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">I \\subset A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mrel\">⊂</span><span class=\"mord mathit\">A</span></span></span></span> such that the topology on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span> is the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span>-adic topology. Is that right? Maybe it includes the condition that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> is finitely generated?</p>",
        "id": 135159185,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538641608
    },
    {
        "content": "<p>I am looking at Wedhorn's lemma 6.2, and wondering if (i) =&gt; (ii) is <code>rfl</code>.</p>",
        "id": 135159205,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538641660
    },
    {
        "content": "<p>In the proof he says that implication is trivial. But you never know if that actually means <code>rfl</code> (-;</p>",
        "id": 135159250,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538641685
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> When Wedhorn says that a ring is <em>adic</em>, this just means that there exists an ideal <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi><mo>⊂</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">I \\subset A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mrel\">⊂</span><span class=\"mord mathit\">A</span></span></span></span> such that the topology on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span> is the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span>-adic topology. Is that right? Maybe it includes the condition that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> is finitely generated?</p>\n</blockquote>\n<p>It's definition 5.18 and yes, there appears to be no finitely-generated condition here. But for Huber rings (a.k.a. f-adic rings) there is a finite generation condition.</p>",
        "id": 135160986,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538644146
    },
    {
        "content": "<blockquote>\n<p>If the knight in shining armour exists I would definitely suggest waiting for him.</p>\n</blockquote>\n<p>I am still unclear about how this is working. Module refactoring, completion of rings, integral closure, I understand exactly what needs to be done and who is doing it. I am in no hurry (although I know Patrick is; I am using module refactoring as an excuse to concentrate on other projects at the minute, e.g. informal documentation for mathematicians which I am actually now writing and which needs to be done because my course started today). But projective limit of complete rings is a complete ring has some content, there is as far as I know not some magic category theory button which proves this. If Scott is intending to actually do this work then great -- but I had not picked up on this as one of his plans. <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> is an arbitrary product of complete topological rings complete, and is a closed subring of a complete topological ring complete? That's what we need. This whole completion thread terrifies me. I had no idea it was going to be so subtle. Unlike Patrick I have not engaged with the mathematics involved here at all. My huge summer project is over and I am not yet clear on how much time I will have for Lean this term, but I am hoping that I can contribute more in the near future.</p>",
        "id": 135161884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538645326
    },
    {
        "content": "<p>I have no plan to magically produce projective limits of complete rings for you. :-)</p>",
        "id": 135165309,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538649788
    },
    {
        "content": "<p>Hopefully in a PR or two mathlib will have the language to _say_ in a uniform way that something is a limit of some other thing.</p>",
        "id": 135165405,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538649915
    },
    {
        "content": "<p>But as far as I'm aware there's no magic to produce that limit in this case. (The limit of rings is trivial, and will be an example, but I'll leave to someone else the case of complete rings.)</p>",
        "id": 135165458,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538649965
    },
    {
        "content": "<p>I think you should prove first that complete topological rings form a reflective subcategory of topological rings. You already need the reflector--this is the completion of a topological ring. Then you also need its universal property: a continuous ring homomorphism from a topological ring A to a complete topological ring B factors uniquely through the completion of A (you might need this anyways as well).</p>",
        "id": 135192953,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538663773
    },
    {
        "content": "<p>Then, it follows by general nonsense that complete topological rings have the same limits as topological rings, and that case I think is best to just do by hand.</p>",
        "id": 135192970,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538663803
    },
    {
        "content": "<p>Reid I always enjoy your comments -- they are often very insightful. Yes I'm sure we need universal property of completions. What's happening here is that it's a bit like defining the structure sheaf on an affine scheme. If R is a ring and f in R then we want the structure sheaf on the D(f) of Spec(R) (the points where f doesn't vanish) to be R[1/f], and then we extend to all opens using that D(f) form a basis and we constantly need universal property of localisation. Here it's a very similar story, we're defining a presheaf on Spa(A) which is some modification of Spec(A) for A a topological ring, there are \"special\" open sets for which the structure presheaf is \"localise and then complete\", and then for general open sets it's \"take limits\", but to define all the morphisms you constantly have to use universal property of localisation and then universal property of completion. I didn't know enough of this abstract nonsense to know that the notion of a reflective subcategory could help.</p>",
        "id": 135199578,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538669730
    },
    {
        "content": "<p>I'm back. Of course we (almost) have that \"reflector\". I didn't know the terminology, but this is what we have been very slowly building since July, and indeed this is not formal. The question is: can we plug this into the category theory repository stuff to get the formal consequences for free</p>",
        "id": 135201442,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538671767
    },
    {
        "content": "<blockquote>\n<p>Hopefully in a PR or two mathlib will have the language to _say_ in a uniform way that something is a limit of some other thing.</p>\n</blockquote>\n<p>Can we already have your repo as a dependency and use that?</p>",
        "id": 135201580,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538671889
    },
    {
        "content": "<blockquote>\n<p>The gist looks good to me. I guess for the <code>is_open_map.prod</code> it would help to express <code>is_open_map</code> in terms of neighborhoods:<br>\n<code>∀(a:α) (U ∈(nhd a).sets), f '' U ∈(nhd (f a)).sets</code>.</p>\n</blockquote>\n<p>Using that reformulation leads to the proof:</p>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"n\">rw</span> <span class=\"n\">is_open_map_iff_nhds</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"bp\">⟩</span> <span class=\"n\">U</span> <span class=\"n\">U_nhd</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nhds_prod_eq</span><span class=\"o\">,</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">mem_prod_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">U_nhd</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">U_nhd</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s_in</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">t_in</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">sets_of_superset</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">image_subset</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)))</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">prod_image_image_eq</span><span class=\"o\">,</span> <span class=\"n\">nhds_prod_eq</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">prod_mem_prod</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">s_in</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"n\">c</span> <span class=\"n\">t</span> <span class=\"n\">t_in</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I'm not sure if it's really an improvement</p>",
        "id": 135203616,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538673878
    },
    {
        "content": "<p>It's shorter but less natural for the average mathematician</p>",
        "id": 135203631,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538673900
    },
    {
        "content": "<p>And I proved your lemma:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">is_open_map_iff_nhds</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_open_map</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"err\">∈</span><span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">U</span> <span class=\"err\">∈</span><span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sets</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">H</span> <span class=\"n\">a</span> <span class=\"n\">U</span> <span class=\"n\">U_nhd</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mem_nhds_sets_iff</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">U_nhd</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s_sub</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">s_op</span><span class=\"o\">,</span> <span class=\"n\">a_in_s</span><span class=\"bp\">⟩⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">existsi</span> <span class=\"o\">[</span><span class=\"n\">f</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">image_subset</span> <span class=\"bp\">_</span> <span class=\"n\">s_sub</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"n\">H</span> <span class=\"n\">s</span> <span class=\"n\">s_op</span><span class=\"o\">,</span> <span class=\"n\">mem_image_of_mem</span> <span class=\"bp\">_</span> <span class=\"n\">a_in_s</span><span class=\"bp\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">H</span> <span class=\"n\">U</span> <span class=\"n\">U_op</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">is_open_iff_mem_nhds</span><span class=\"o\">,</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">b</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a_in</span><span class=\"o\">,</span> <span class=\"n\">fa</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">fa</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">H</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">mem_nhds_sets</span> <span class=\"n\">U_op</span> <span class=\"n\">a_in</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 135204356,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538674629
    },
    {
        "content": "<p>Ten minutes to Lean this, without writing a proof on paper first. I may end up comfortable with this filter non-sense!</p>",
        "id": 135204389,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538674674
    },
    {
        "content": "<p>Hm, I was a little bit off with my nhds version of <code>is_open_map</code>. It can expressed directly using <code>filter.map</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">is_open_map_iff_nhds_le</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_open_map</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">is_open_map_iff_nhds</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"n\">forall_congr</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"k\">let</span> <span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">mem_map_sets_iff</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hs</span> <span class=\"k\">in</span>\n    <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">mem_sets_of_superset</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">)</span> <span class=\"n\">hts</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"n\">u</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">image_mem_map</span> <span class=\"n\">hu</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">protected</span> <span class=\"kn\">lemma</span> <span class=\"n\">prod</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">is_open_map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">is_open_map</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_open_map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">is_open_map_iff_nhds_le</span><span class=\"o\">],</span>\n  <span class=\"n\">rintros</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nhds_prod_eq</span><span class=\"o\">,</span> <span class=\"n\">nhds_prod_eq</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">prod_map_map_eq</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">prod_mono</span> <span class=\"o\">((</span><span class=\"n\">is_open_map_iff_nhds_le</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hf</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">is_open_map_iff_nhds_le</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hg</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 135206249,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538676254
    },
    {
        "content": "<p>I think this is similar to you wanting to write <code>is_ideal</code> using sets and functions, instead of points. Its the same with filters!<br>\nMany things can be nicely expressed using <code>map</code> or <code>comap</code> and <code>&lt;=</code>. Using this operators we don't need to handle points (i.e. sets)</p>",
        "id": 135206477,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538676470
    },
    {
        "content": "<p>I've been betrayed! I copied you statement without thinking. But of course this is consistent with how the open set definition relates to the continuity definition</p>",
        "id": 135211096,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538681674
    },
    {
        "content": "<p>Of course I also prefer set-free filter reasoning</p>",
        "id": 135211104,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538681691
    },
    {
        "content": "<p>Oh, I could tfae it!</p>",
        "id": 135211133,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538681742
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>Hopefully in a PR or two mathlib will have the language to _say_ in a uniform way that something is a limit of some other thing.</p>\n</blockquote>\n<p>Can we already have your repo as a dependency and use that?</p>\n</blockquote>\n<p>It is already a dependency since a week or so.</p>",
        "id": 135213439,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538683948
    },
    {
        "content": "<p>I understand, but is it actually usable for us, or half incompatible with what is in mathlib?</p>",
        "id": 135213464,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538683982
    },
    {
        "content": "<p>I think the stuff on limits should be mostly compatible with what is in mathlib. But I don't know for sure.</p>",
        "id": 135213590,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538684048
    },
    {
        "content": "<p>Do you know how to state that the category of topological rings has projective limits?</p>",
        "id": 135213619,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538684089
    },
    {
        "content": "<p>Well, we would first need a category of topological rings.</p>",
        "id": 135213662,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538684130
    },
    {
        "content": "<blockquote>\n<p>It looks like <code>TopRing.lean</code> itself compiles fine :-)</p>\n</blockquote>\n<p>Aah, Scott already wrote that.</p>",
        "id": 135213751,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538684218
    },
    {
        "content": "<p>I'm always confused about Scott's repositories because I was never able to find the pieces of sheaf theory that he showed us in Orsay</p>",
        "id": 135213793,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538684280
    },
    {
        "content": "<p>And then we would need to use: <a href=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/limits/limits.lean#L82\" target=\"_blank\" title=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/limits/limits.lean#L82\">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/limits/limits.lean#L82</a></p>",
        "id": 135213850,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538684306
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Do you mean things like this: <a href=\"https://github.com/semorrison/lean-category-theory/blob/6c2a7b340f19bf0da3f1904204791c343d5c3213/src/category_theory/sheaves.lean#L32\" target=\"_blank\" title=\"https://github.com/semorrison/lean-category-theory/blob/6c2a7b340f19bf0da3f1904204791c343d5c3213/src/category_theory/sheaves.lean#L32\">https://github.com/semorrison/lean-category-theory/blob/6c2a7b340f19bf0da3f1904204791c343d5c3213/src/category_theory/sheaves.lean#L32</a></p>",
        "id": 135213945,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538684405
    },
    {
        "content": "<p>Oh I was looking in the presheaf file!</p>",
        "id": 135213983,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538684453
    },
    {
        "content": "<p>while are stalks in sheaves and not presheaves?</p>",
        "id": 135214001,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538684470
    },
    {
        "content": "<p><a href=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/examples/rings/universal.lean#L43\" target=\"_blank\" title=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/examples/rings/universal.lean#L43\">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/examples/rings/universal.lean#L43</a> is sorried <span class=\"emoji emoji-2639\" title=\"sad\">:sad:</span></p>",
        "id": 135214015,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538684493
    },
    {
        "content": "<p>Right. But colimits are quite a bit harder... you need tensor products.</p>",
        "id": 135214106,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538684580
    },
    {
        "content": "<p>I know we have those. But you still need to use them</p>",
        "id": 135214116,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538684589
    },
    {
        "content": "<p>It's not as formal as limits.</p>",
        "id": 135214118,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538684594
    },
    {
        "content": "<p>but stalk is a colimit, right?</p>",
        "id": 135214134,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538684625
    },
    {
        "content": "<p>Aaah, sure, it is</p>",
        "id": 135214139,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538684636
    },
    {
        "content": "<p>So you mean we don't have stalks</p>",
        "id": 135214184,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538684647
    },
    {
        "content": "<p>Hmm... work to do (-;</p>",
        "id": 135214198,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538684664
    },
    {
        "content": "<blockquote>\n<p>Oh, I could tfae it!</p>\n</blockquote>\n<p>Doesn't work:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">is_open_map_iff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tfae</span> <span class=\"o\">[</span><span class=\"n\">is_open_map</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"err\">∈</span><span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">U</span> <span class=\"err\">∈</span><span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">tfae_have</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"mi\">3</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">H</span> <span class=\"n\">a</span> <span class=\"n\">U</span> <span class=\"n\">U_nhd</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mem_nhds_sets_iff</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">U_nhd</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s_sub</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">s_op</span><span class=\"o\">,</span> <span class=\"n\">a_in_s</span><span class=\"bp\">⟩⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">existsi</span> <span class=\"o\">[</span><span class=\"n\">f</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">image_subset</span> <span class=\"bp\">_</span> <span class=\"n\">s_sub</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"n\">H</span> <span class=\"n\">s</span> <span class=\"n\">s_op</span><span class=\"o\">,</span> <span class=\"n\">mem_image_of_mem</span> <span class=\"bp\">_</span> <span class=\"n\">a_in_s</span><span class=\"bp\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"n\">tfae_have</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">H</span> <span class=\"n\">U</span> <span class=\"n\">U_op</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">is_open_iff_mem_nhds</span><span class=\"o\">,</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">b</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a_in</span><span class=\"o\">,</span> <span class=\"n\">fa</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">fa</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">H</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">mem_nhds_sets</span> <span class=\"n\">U_op</span> <span class=\"n\">a_in</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n   <span class=\"n\">tfae_have</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">↔</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n   <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">forall_congr</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n     <span class=\"n\">split</span><span class=\"o\">,</span>\n     <span class=\"n\">exact</span> <span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"k\">let</span> <span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">mem_map_sets_iff</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hs</span> <span class=\"k\">in</span>\n       <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">mem_sets_of_superset</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">)</span> <span class=\"n\">hts</span><span class=\"o\">,</span>\n     <span class=\"n\">exact</span> <span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"n\">u</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">image_mem_map</span> <span class=\"n\">hu</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n   <span class=\"n\">tfae_finish</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>The <code>tfae_finish</code> errors like:</p>\n<div class=\"codehilite\"><pre><span></span>α : Type u_1,\n_inst_1 : topological_space α,\nβ : Type u_2,\n_inst_2 : topological_space β,\nf : α → β,\ntfae_1_to_3 : is_open_map f → ∀ (a : α) (U : set α), U ∈ (nhds a).sets → f &#39;&#39; U ∈ (nhds (f a)).sets,\ntfae_3_to_1 : (∀ (a : α) (U : set α), U ∈ (nhds a).sets → f &#39;&#39; U ∈ (nhds (f a)).sets) → is_open_map f,\ntfae_3_iff_2 :\n  (∀ (a : α) (U : set α), U ∈ (nhds a).sets → f &#39;&#39; U ∈ (nhds (f a)).sets) ↔\n    ∀ (a : α), nhds (f a) ≤ filter.map f (nhds a)\n⊢ tfae  [is_open_map f, ∀ (a : α), nhds (f a) ≤ filter.map f (nhds a), ∀ (a : α) (U : set α), U ∈ (nhds a).sets → f &#39;&#39; U ∈ (nhds (f a)).sets]\n\nexact tactic failed, type mismatch, given expression has type\n  (∀ (a : α), nhds (f a) ≤ filter.map f (nhds a)) ↔ ∀ (a : α), nhds (f a) ≤ filter.map f (nhds a)\nbut is expected to have type\n  (∀ (a : α), nhds (f a) ≤ filter.map f (nhds a)) ↔ is_open_map f\n</pre></div>",
        "id": 135215398,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538686024
    },
    {
        "content": "<p>time to sleep</p>",
        "id": 135215405,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538686031
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span>  <span class=\"emoji emoji-2b06\" title=\"up\">:up:</span> Do you know what we did wrong? I succesfully used <code>tfae</code> in another example today.</p>",
        "id": 135229951,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538706944
    },
    {
        "content": "<p>What do I need to import for that example?</p>",
        "id": 135235526,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538717822
    },
    {
        "content": "<p>4 entire projects? <span class=\"emoji emoji-1f606\" title=\"lol\">:lol:</span></p>",
        "id": 135235777,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538718294
    },
    {
        "content": "<p>Lol, just kidding.</p>",
        "id": 135235788,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538718325
    },
    {
        "content": "<p>This doesn't depend on the perfectoid project in any way.</p>",
        "id": 135235789,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538718335
    },
    {
        "content": "<p>I guess <code>analysis/topology/embedding.lean</code> or something. I don't really know. You need to get <code>is_open</code>.</p>",
        "id": 135235843,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538718372
    },
    {
        "content": "<p>So you will need some topological files.</p>",
        "id": 135235845,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538718381
    },
    {
        "content": "<p>The proof of 6.1 and 6.2 in Wedhorn is one big mess.</p>",
        "id": 135237511,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538721689
    },
    {
        "content": "<p>Do we need those?</p>",
        "id": 135237798,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538722236
    },
    {
        "content": "<p>If the proof is really messy, you will probably be faster if you fist LaTeX a precise organized proof, and then Lean it</p>",
        "id": 135237824,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538722310
    },
    {
        "content": "<p>Right. I don't know exactly if we need them.</p>",
        "id": 135237871,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538722365
    },
    {
        "content": "<p>I thought they belonged to the api of Huber and Tate rings</p>",
        "id": 135237873,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538722377
    },
    {
        "content": "<p>I'll dig in a bit deeper.</p>",
        "id": 135237884,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538722405
    },
    {
        "content": "<p>What is this Remark 6.3? Does it mean all top rings we actually care about are metrizable?</p>",
        "id": 135237935,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538722458
    },
    {
        "content": "<p>Yes, I think so</p>",
        "id": 135238026,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538722625
    },
    {
        "content": "<p>Is that good or bad news?</p>",
        "id": 135238030,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538722634
    },
    {
        "content": "<p>Is this actually ok?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">perfectoid_ring</span> <span class=\"n\">A</span><span class=\"o\">],</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>We ask for a <code>A : Huber_pair</code> to exist, and then also for the structure <code>perfectoid_ring A</code>. But we don't ask for any sort of compatibility between those...</p>",
        "id": 135238239,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538722959
    },
    {
        "content": "<p>sounds very fishy. It looks like the issue discussed about Hilbert spaces last summer</p>",
        "id": 135238703,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538723696
    },
    {
        "content": "<p>Also, in</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\">- A perfectoid ring, following Fontaine Sem Bourb-/</span>\n<span class=\"n\">class</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">Tate_ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">complete</span> <span class=\"o\">:</span> <span class=\"n\">is_complete</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">uniform</span>  <span class=\"o\">:</span> <span class=\"n\">is_uniform</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ramified</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ϖ</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">is_pseudo_uniformizer</span> <span class=\"n\">ϖ</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">((</span><span class=\"n\">ϖ</span><span class=\"err\">^</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">Frob</span>     <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"err\">^</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>I think we want the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>ϖ</mi></mrow><annotation encoding=\"application/x-tex\">\\varpi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">ϖ</span></span></span></span> not to just exist, but to actually be the one that comes with the <code>Tate_ring</code> structure.</p>",
        "id": 135238893,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538723980
    },
    {
        "content": "<p>I can hear Assia laughting...</p>",
        "id": 135239028,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538724167
    },
    {
        "content": "<p>Hmmm... I'm not sure if top-down vs bottom-up is at issue here. Although it is certainly related.</p>",
        "id": 135239040,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538724211
    },
    {
        "content": "<p>The issue seems to be that we don't have examples.</p>",
        "id": 135239044,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538724221
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Where are our algebraic closures?!!!</p>",
        "id": 135239049,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538724234
    },
    {
        "content": "<p>Yes, that's what she predicted</p>",
        "id": 135239050,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538724239
    },
    {
        "content": "<p>(Kidding)</p>",
        "id": 135239051,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538724240
    },
    {
        "content": "<p>somewhere... over the rainbow</p>",
        "id": 135239093,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1538724253
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/subject/stacks.20project.20.2F.20schemes/near/123090992\" title=\"#narrow/stream/113488-general/subject/stacks.20project.20.2F.20schemes/near/123090992\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/subject/stacks.20project.20.2F.20schemes/near/123090992</a></p>",
        "id": 135239164,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538724378
    },
    {
        "content": "<p>Thanks for that link <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>. It was from the time where I hadn't really started using Lean yet. I think Assia's comment is extremely valuable.</p>",
        "id": 135239378,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538724753
    },
    {
        "content": "<p>I am writing a blog post with an update on the perfectoid project and related things. I was not going to mention modules at all, I was going to focus on the issues which the \"completion of a topological ring\" API has run into. I don't think that mathematicians even understand that these issues are there. This whole thing has been very eye-opening.</p>",
        "id": 135243624,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538730838
    },
    {
        "content": "<p>On writing it I realise that I am interested in the question of whether we have the predicate <code>is_complete R</code> for <code>R</code> a commutative topological ring.</p>",
        "id": 135243700,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538730944
    },
    {
        "content": "<p>I have been reluctant to embark upon definition of the presheaf on Spa(A) because (a) I was super-busy, as yesterday was lecture 1 of my course and meeting 1 of Xena and (b) I knew that after this unexpected (to me -- probably not to Johannes!) hold-up regarding completions of top rings it would mean that I would have to sorry stuff when doing the last part, and I have this vague idea that sorrying stuff is bad.</p>",
        "id": 135243818,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538731114
    },
    {
        "content": "<p>I have this vague idea that to prove the thing I need (the universal property for projective limits in the category of complete topological rings) I would probably need what Patrick is doing. But now I am realising that if you think about the notion of being complete (for a topological ring) as just being some typeclass <code>is_complete</code> then I think the third thing can be thought of as an <code>instance</code>, and now I realise that I am a little unclear about whether I could just attempt to write this instance in a completely sorry-free way if I just had the definition of the predicate <code>is_complete R</code> for <code>R</code> a topological ring.</p>",
        "id": 135244014,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538731412
    },
    {
        "content": "<p>Should predicates like <code>is_complete</code> be typeclasses? <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> you always seem to have clear ideas on things like this.</p>",
        "id": 135244065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538731474
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  points out that they form a reflective subcategory.</p>",
        "id": 135244071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538731502
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Is there a full proof of the universal property of the completion of a topological ring in the mathematical literature?</p>",
        "id": 135245115,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538732960
    },
    {
        "content": "<p>i.e. if C is a complete topological ring then Hom(M, C) = Hom(completion(M), C)?</p>",
        "id": 135245284,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1538733189
    },
    {
        "content": "<p>Right.</p>",
        "id": 135245818,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538733933
    },
    {
        "content": "<p>Of course you have to define the completion first</p>",
        "id": 135245830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538733948
    },
    {
        "content": "<p>but my understanding now is that defining the completion and proving the universal property is in some sense one problem</p>",
        "id": 135245873,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538733964
    },
    {
        "content": "<p>and then the trick of deducing that projective limits in the category of complete topological rings exist by showing that projective limits exist in the category of topological rings is a totally different problem</p>",
        "id": 135245905,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538734055
    },
    {
        "content": "<p>and might be approachable using some category-theory magic</p>",
        "id": 135245967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538734086
    },
    {
        "content": "<p>we have already <code>complete_space</code> which is a type class, a predicate on uniform spaces</p>",
        "id": 135248850,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538738785
    },
    {
        "content": "<p>I'm almost done with <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/huber_tate/src/Spa.lean#L193\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/huber_tate/src/Spa.lean#L193\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/huber_tate/src/Spa.lean#L193</a><br>\nIt proves that rational opens form a basis.</p>",
        "id": 135494373,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539115146
    },
    {
        "content": "<p>But first I will sleep a bit.</p>",
        "id": 135494387,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539115165
    },
    {
        "content": "<p>Nice Johan!</p>",
        "id": 135494390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539115169
    },
    {
        "content": "<p>Good job!</p>",
        "id": 135495188,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1539115885
    },
    {
        "content": "<p>what is rational?</p>",
        "id": 135495258,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1539115924
    },
    {
        "content": "<p>It's some version of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>D</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">D(f)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span> for adic spaces.</p>",
        "id": 135495325,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539115988
    },
    {
        "content": "<p>Definition 7.29 p62 of <a href=\"https://www2.math.uni-paderborn.de/fileadmin/Mathematik/People/wedhorn/Lehre/AdicSpaces.pdf\" target=\"_blank\" title=\"https://www2.math.uni-paderborn.de/fileadmin/Mathematik/People/wedhorn/Lehre/AdicSpaces.pdf\">https://www2.math.uni-paderborn.de/fileadmin/Mathematik/People/wedhorn/Lehre/AdicSpaces.pdf</a></p>",
        "id": 135495429,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539116069
    },
    {
        "content": "<p>There is one annoying subgoal left:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">,</span>\n<span class=\"n\">U₁</span> <span class=\"n\">U₂</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n<span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n<span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">U₁</span> <span class=\"err\">∩</span> <span class=\"n\">U₂</span><span class=\"o\">,</span>\n<span class=\"n\">s₁</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">T₁</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">hfin₁</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"err\">↥</span><span class=\"n\">T₁</span><span class=\"o\">,</span>\n<span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">T₂</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">hfin₂</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"err\">↥</span><span class=\"n\">T₂</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"err\">↥</span><span class=\"n\">T₁</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"err\">↥</span><span class=\"n\">T₂</span><span class=\"o\">,</span>\n<span class=\"n\">H₂</span> <span class=\"o\">:</span> <span class=\"n\">U₂</span> <span class=\"bp\">=</span> <span class=\"n\">rational_open</span> <span class=\"n\">s₂</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">s₂</span> <span class=\"n\">T₂</span><span class=\"o\">),</span>\n<span class=\"n\">H₁</span> <span class=\"o\">:</span> <span class=\"n\">U₁</span> <span class=\"bp\">=</span> <span class=\"n\">rational_open</span> <span class=\"n\">s₁</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">s₁</span> <span class=\"n\">T₁</span><span class=\"o\">)</span>\n<span class=\"err\">⊢</span> <span class=\"n\">fintype</span>\n    <span class=\"err\">↥</span><span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span>\n         <span class=\"err\">↥</span><span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"n\">t₁</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">t₁</span> <span class=\"err\">∈</span> <span class=\"n\">insert</span> <span class=\"n\">s₁</span> <span class=\"n\">T₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t₂</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">t₂</span> <span class=\"err\">∈</span> <span class=\"n\">insert</span> <span class=\"n\">s₂</span> <span class=\"n\">T₂</span><span class=\"o\">},</span>\n         <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">t₁</span> <span class=\"bp\">*</span> <span class=\"n\">t₂</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 135512569,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539136257
    },
    {
        "content": "<p>Does anyone have some hints on how to tackle that?</p>",
        "id": 135512572,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539136269
    },
    {
        "content": "<p>I want to use <code>set.fintype_image</code> but it doesn't apply directly.</p>",
        "id": 135512741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539136571
    },
    {
        "content": "<p>Use choice to turn the goal back into <code>finite ...</code>, and then use <code>finite_subset</code> and <code>finite_image</code></p>",
        "id": 135512946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539136945
    },
    {
        "content": "<p>actually you can use <code>fintype_subset</code> instead</p>",
        "id": 135512960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539137003
    },
    {
        "content": "<p>You should be able to prove <code>fintype (uncurry (*) '' set.prod (insert s₁ T₁) (insert s₂ T₂))</code></p>",
        "id": 135513096,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539137165
    },
    {
        "content": "<p>Ok, I can try that one.</p>",
        "id": 135513106,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539137187
    },
    {
        "content": "<p>actually I don't even think you have to prove that, typeclass inference will solve it... you just have to prove your set is a subset of it</p>",
        "id": 135513196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539137313
    },
    {
        "content": "<p>(in fact it's equal but who cares)</p>",
        "id": 135513204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539137324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I'm now stuck with this kludge:</p>\n<div class=\"codehilite\"><pre><span></span>    <span class=\"o\">{</span> <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">s₁</span> <span class=\"n\">T₁</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">s₂</span> <span class=\"n\">T₂</span><span class=\"o\">)}</span> <span class=\"o\">:=</span>\n      <span class=\"k\">begin</span>\n        <span class=\"n\">sorry</span>\n      <span class=\"kn\">end</span><span class=\"o\">,</span>\n      <span class=\"n\">convert</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">fintype_image</span>\n        <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">s₁</span> <span class=\"n\">T₁</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">s₂</span> <span class=\"n\">T₂</span><span class=\"o\">)}</span>\n        <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">),</span>\n      <span class=\"n\">funext</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n      <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"bp\">⟨</span><span class=\"n\">t₁</span><span class=\"o\">,</span> <span class=\"n\">ht₁</span><span class=\"o\">,</span> <span class=\"n\">t₂</span><span class=\"o\">,</span> <span class=\"n\">ht₂</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n        <span class=\"n\">existsi</span> <span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">t₁</span><span class=\"o\">,</span><span class=\"n\">t₂</span><span class=\"bp\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n        <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"n\">ht₁</span><span class=\"o\">,</span> <span class=\"n\">ht₂</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"bp\">⟩⟩</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span><span class=\"n\">h₁</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span><span class=\"n\">h₁</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n</pre></div>",
        "id": 135513493,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539137832
    },
    {
        "content": "<p>I don't feel like I'm doing this the right way...</p>",
        "id": 135513497,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539137851
    },
    {
        "content": "<p>you should use <code>set.prod</code> for that set abstraction</p>",
        "id": 135513498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539137860
    },
    {
        "content": "<p>The <code>uncurry</code> didn't work, because Lean could figure out <code>has_insert</code> classes...</p>",
        "id": 135513500,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539137876
    },
    {
        "content": "<p>then lean will be able to fill in the sorry</p>",
        "id": 135513505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539137879
    },
    {
        "content": "<p>if lean has trouble with the has_insert class, put a type ascription on it</p>",
        "id": 135513547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539137907
    },
    {
        "content": "<p><code>uncurry (*) '' set.prod (insert s₁ T₁ : set A) (insert s₂ T₂ : set A)</code></p>",
        "id": 135513549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539137934
    },
    {
        "content": "<p>Hurray:</p>\n<div class=\"codehilite\"><pre><span></span>    <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">fintype_image</span>\n        <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">s₁</span> <span class=\"n\">T₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">s₂</span> <span class=\"n\">T₂</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">),</span>\n      <span class=\"n\">funext</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n      <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"bp\">⟨</span><span class=\"n\">t₁</span><span class=\"o\">,</span> <span class=\"n\">ht₁</span><span class=\"o\">,</span> <span class=\"n\">t₂</span><span class=\"o\">,</span> <span class=\"n\">ht₂</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n        <span class=\"n\">existsi</span> <span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">t₁</span><span class=\"o\">,</span><span class=\"n\">t₂</span><span class=\"bp\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n        <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"n\">ht₁</span><span class=\"o\">,</span> <span class=\"n\">ht₂</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"bp\">⟩⟩</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span><span class=\"n\">h₁</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span><span class=\"n\">h₁</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"n\">apply</span> <span class=\"n\">rational_open_inter</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n</pre></div>",
        "id": 135513572,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539137990
    },
    {
        "content": "<p>Still silly that I need 10 lines for this. But at least it is <code>sorry</code>-free now.</p>",
        "id": 135513614,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539138016
    },
    {
        "content": "<p>Like I said, use <code>fintype_subset</code> instead of <code>convert</code> and one of your proof obligations goes away</p>",
        "id": 135513618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539138034
    },
    {
        "content": "<p>I'll look into that after I catchup some sleep. Thanks again!</p>",
        "id": 135513636,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539138087
    },
    {
        "content": "<p>Also the reason this is work is because you \"rolled your own\" set abstraction rather than composing existing constructions so that you get something \"manifestly finite\". I would question why you had that goal to prove in the first place</p>",
        "id": 135513688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539138182
    },
    {
        "content": "<p>I pushed some more finiteness theorems to allow you to write <code>(*) &lt;$&gt; insert s₁ T₁ &lt;*&gt; insert s₂ T₂</code> and have lean automatically figure out this is finite</p>",
        "id": 135515107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539140450
    },
    {
        "content": "<blockquote>\n<p>I pushed some more finiteness theorems to allow you to write <code>(*) &lt;$&gt; insert s₁ T₁ &lt;*&gt; insert s₂ T₂</code> and have lean automatically figure out this is finite</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> What do you think of such notation? Is this something we should just get used to, or are we deviating too much from the maths we are formalising if we do that?</p>",
        "id": 135520406,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539150083
    },
    {
        "content": "<p>What are the alternatives on offer?</p>",
        "id": 135520525,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539150297
    },
    {
        "content": "<p>I am using <code>{t : A | ∃ {t₁ ∈ insert s₁ T₁} {t₂ ∈ insert s₂ T₂}, t = t₁ * t₂}</code> at the moment.</p>",
        "id": 135521990,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539152933
    },
    {
        "content": "<p>The problem with what I am currently using is that it is readable, and therefore unstructured.</p>",
        "id": 135522001,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539152961
    },
    {
        "content": "<p>You wouldn't even use this in regular maths</p>",
        "id": 135522007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539152985
    },
    {
        "content": "<p>you would give that thing a name/notation</p>",
        "id": 135522010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539152999
    },
    {
        "content": "<p>The advantage of the monad notation is that it is ridiculously general</p>",
        "id": 135522060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153031
    },
    {
        "content": "<p>Nope, we definitely write <code>{t_1 * t_2 | t_1 \\in T_1, t_2 \\in T_2}</code></p>",
        "id": 135522061,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539153038
    },
    {
        "content": "<p>Not A * B?</p>",
        "id": 135522068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153054
    },
    {
        "content": "<p>I would write something like <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><mi>t</mi><mo>∈</mo><mi>A</mi><mo>∣</mo><mi mathvariant=\"normal\">∃</mi><msub><mi>t</mi><mn>1</mn></msub><mo>∈</mo><mo>{</mo><msub><mi>s</mi><mn>1</mn></msub><mo>}</mo><mo>∪</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo>∈</mo><mo>{</mo><msub><mi>s</mi><mn>2</mn></msub><mo>}</mo><mo>∪</mo><msub><mi>T</mi><mn>2</mn></msub><mrow><mtext> </mtext><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">h</mi><mtext> </mtext><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">h</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi><mtext> </mtext></mrow><mi>t</mi><mo>=</mo><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{t\\in A\\mid \\exists t_1\\in \\{s_1\\}\\cup T_1, t_2\\in \\{s_2\\}\\cup T_2 \\mathrm{\\ such\\ that\\ }t=t_1t_2\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">{</span><span class=\"mord mathit\">t</span><span class=\"mrel\">∈</span><span class=\"mord mathit\">A</span><span class=\"mrel\">∣</span><span class=\"mord mathrm\">∃</span><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mrel\">∈</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathit\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mclose\">}</span><span class=\"mbin\">∪</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mrel\">∈</span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathit\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mclose\">}</span><span class=\"mbin\">∪</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathrm\"><span class=\"mspace\"> </span><span class=\"mord mathrm\">s</span></span><span class=\"mord mathrm\">u</span><span class=\"mord mathrm\">c</span><span class=\"mord mathrm\">h</span><span class=\"mord mathrm\"><span class=\"mspace\"> </span><span class=\"mord mathrm\">t</span></span><span class=\"mord mathrm\">h</span><span class=\"mord mathrm\">a</span><span class=\"mord mathrm\">t</span><span class=\"mspace\"> </span></span><span class=\"mord mathit\">t</span><span class=\"mrel\">=</span><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span></p>",
        "id": 135522077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539153079
    },
    {
        "content": "<p>I still don't believe you. You might write that on line 1 but you would never write it twice</p>",
        "id": 135522083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153111
    },
    {
        "content": "<p>Fair point.</p>",
        "id": 135522131,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539153143
    },
    {
        "content": "<p>My brain can't cope with two conventions for typing maths notation into a computer :-)</p>",
        "id": 135522140,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539153173
    },
    {
        "content": "<p>I write <code>\\cup</code> in lean too</p>",
        "id": 135522208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153255
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, right. So we use <code>let T := blah</code></p>",
        "id": 135522209,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539153258
    },
    {
        "content": "<p>And if you did write it that way, you would also have to explain (briefly) why it is finite</p>",
        "id": 135522211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153276
    },
    {
        "content": "<p>But in this <code>let</code>, we definitely use the unstructured set builder notation.</p>",
        "id": 135522213,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539153284
    },
    {
        "content": "<p>and in doing so you would identify it as an image</p>",
        "id": 135522214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153286
    },
    {
        "content": "<blockquote>\n<p>And if you did write it that way, you would also have to explain (briefly) why it is finite</p>\n</blockquote>\n<p>No we don't. It's done by an auto_param that calls <code>this_is_easy</code>.</p>",
        "id": 135522233,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539153330
    },
    {
        "content": "<p>I'm thinking math textbook level here</p>",
        "id": 135522234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153345
    },
    {
        "content": "<p>I'm not sure what level you are talking</p>",
        "id": 135522236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153356
    },
    {
        "content": "<p>Same level</p>",
        "id": 135522295,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539153446
    },
    {
        "content": "<p>I can believe that a mathematician proof would skip this step, maybe using \"by clearly\", but I think they would also recognize it as skipping a step and would use images when asked</p>",
        "id": 135522298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153459
    },
    {
        "content": "<p>(as opposed to some step skippage which are not even recognized as such when considered explicitly)</p>",
        "id": 135522347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153497
    },
    {
        "content": "<p>Sure. So can I just tell Lean <code>work_harder [use := it_is_an_image]</code> ?</p>",
        "id": 135522349,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539153514
    },
    {
        "content": "<p>Instead of a 10-line proof.</p>",
        "id": 135522350,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539153525
    },
    {
        "content": "<p>Sure, I mean at this point we are talking about machine learning or other ATP to prove this theorem</p>",
        "id": 135522357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153540
    },
    {
        "content": "<p>All the pieces are there, go find it computer minion</p>",
        "id": 135522366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153563
    },
    {
        "content": "<p>I want an ATP inside my ITP.</p>",
        "id": 135522367,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539153565
    },
    {
        "content": "<p>but my point is there is also a notation for this, and I want to maximize use of \"constructions\" for building sets because this provides a focus for theorems</p>",
        "id": 135522415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153605
    },
    {
        "content": "<p>Ok, I'll just use it and see what happens. I prefer the version with <code>uncurry</code>. Is that structured enough? Or do I need the crazy monadic combinators?</p>",
        "id": 135522431,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539153672
    },
    {
        "content": "<p>the advantage of the funny monadic version is you don't have to fuss with products</p>",
        "id": 135522437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153721
    },
    {
        "content": "<p>which is a side effect of the fact that (*) is a curried function</p>",
        "id": 135522479,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153742
    },
    {
        "content": "<p>Ok, I'll bite the bullet.</p>",
        "id": 135522496,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539153812
    },
    {
        "content": "<p>Unfortunately, even the funny monad version isn't exactly the same as your set notation up to defeq</p>",
        "id": 135522498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153822
    },
    {
        "content": "<p>because it uses <code>⋃ x ∈ s</code> instead of <code>{y | ∃ x ∈ s, ...</code></p>",
        "id": 135522543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153866
    },
    {
        "content": "<p>which is not defeq because of reasons</p>",
        "id": 135522548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153891
    },
    {
        "content": "<p>still, you should be able to prove it by simp</p>",
        "id": 135522555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539153904
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I don't like the look of this</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">t₁</span> <span class=\"n\">t₂</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"bp\">*</span> <span class=\"n\">s₂</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 135522625,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539154003
    },
    {
        "content": "<p>All of a sudden <code>t₁</code> is a function <code>A → A</code>...</p>",
        "id": 135522635,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539154024
    },
    {
        "content": "<p>what am I looking at?</p>",
        "id": 135522637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539154025
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">rational_open_inter</span><span class=\"bp\">.</span><span class=\"n\">aux1</span> <span class=\"o\">{</span><span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T₁</span> <span class=\"n\">T₂</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">T₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">T₂</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">s₁</span> <span class=\"err\">∈</span> <span class=\"n\">T₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">s₂</span> <span class=\"err\">∈</span> <span class=\"n\">T₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"k\">let</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">T₁</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">T₂</span> <span class=\"k\">in</span>\n<span class=\"n\">rational_open</span> <span class=\"n\">s₁</span> <span class=\"n\">T₁</span> <span class=\"err\">∩</span> <span class=\"n\">rational_open</span> <span class=\"n\">s₂</span> <span class=\"n\">T₂</span> <span class=\"err\">⊆</span> <span class=\"n\">rational_open</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"bp\">*</span> <span class=\"n\">s₂</span><span class=\"o\">)</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">T</span> <span class=\"n\">v</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">vmuls</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"bp\">*</span> <span class=\"n\">s₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"n\">s₁</span> <span class=\"bp\">*</span> <span class=\"n\">v</span> <span class=\"n\">s₂</span> <span class=\"o\">:=</span> <span class=\"n\">valuation</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">ht</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">t₁</span><span class=\"o\">,</span> <span class=\"n\">ht₁</span><span class=\"o\">,</span> <span class=\"n\">t₂</span><span class=\"o\">,</span> <span class=\"n\">ht₂</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">hv₁</span><span class=\"o\">,</span> <span class=\"n\">hs₁</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">hv₂</span><span class=\"o\">,</span> <span class=\"n\">hs₂</span><span class=\"bp\">⟩⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">subst</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n<span class=\"c1\">--- snip, the goal is now</span>\n<span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">,</span>\n<span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">T₁</span> <span class=\"n\">T₂</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"err\">↥</span><span class=\"n\">T₁</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"err\">↥</span><span class=\"n\">T₂</span><span class=\"o\">,</span>\n<span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">s₁</span> <span class=\"err\">∈</span> <span class=\"n\">T₁</span><span class=\"o\">,</span>\n<span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">s₂</span> <span class=\"err\">∈</span> <span class=\"n\">T₂</span><span class=\"o\">,</span>\n<span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"err\">↥</span><span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">has_mul</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">T₁</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">T₂</span><span class=\"o\">,</span>\n<span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n<span class=\"n\">vmuls</span> <span class=\"o\">:</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"bp\">*</span> <span class=\"n\">s₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"n\">s₁</span> <span class=\"bp\">*</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"n\">s₂</span><span class=\"o\">,</span>\n<span class=\"n\">t₁</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">ht₁</span> <span class=\"o\">:</span> <span class=\"n\">t₁</span> <span class=\"err\">∈</span> <span class=\"n\">has_mul</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">T₁</span><span class=\"o\">,</span>\n<span class=\"n\">t₂</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">ht₂</span> <span class=\"o\">:</span> <span class=\"n\">t₂</span> <span class=\"err\">∈</span> <span class=\"n\">T₂</span><span class=\"o\">,</span>\n<span class=\"n\">hv₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">t</span> <span class=\"err\">∈</span> <span class=\"n\">T₁</span> <span class=\"bp\">→</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"n\">t</span> <span class=\"bp\">≤</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"n\">s₁</span><span class=\"o\">,</span>\n<span class=\"n\">hs₁</span> <span class=\"o\">:</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"n\">s₁</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"n\">hv₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">t</span> <span class=\"err\">∈</span> <span class=\"n\">T₂</span> <span class=\"bp\">→</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"n\">t</span> <span class=\"bp\">≤</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"n\">s₂</span><span class=\"o\">,</span>\n<span class=\"n\">hs₂</span> <span class=\"o\">:</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"n\">s₂</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n<span class=\"err\">⊢</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">t₁</span> <span class=\"n\">t₂</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"err\">⇑</span><span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"bp\">*</span> <span class=\"n\">s₂</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 135522655,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539154076
    },
    {
        "content": "<p>I want it to be <code>v (t₁ * t₂) ≤ v (s₁ * s₂)</code>.</p>",
        "id": 135522702,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539154104
    },
    {
        "content": "<p>I would like to understand how to use this goofy monad stuff. But currently I'm mystified. I think it is turning <code>t₁</code> into the function that multiplies on the left with the \"old\" <code>t₁ : A</code>. But now I can't use the multiplicative property of valuations on this expression...</p>",
        "id": 135522874,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539154440
    },
    {
        "content": "<p>Sorry, I was distracted by some poor simp lemmas that fail to simplify that expression the way you would want</p>",
        "id": 135522987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539154577
    },
    {
        "content": "<p>you can fix the <code>t1</code> is a function thing by <code>rcases ht1 with &lt;t1, ht1, rfl&gt;</code></p>",
        "id": 135522989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539154605
    },
    {
        "content": "<p>Ok, let me try.</p>",
        "id": 135522995,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539154630
    },
    {
        "content": "<p>It seems to work. Thanks</p>",
        "id": 135523336,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539155106
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>example {A : Type u} [has_mul A] (T₁ T₂ : set A) :\n  {t : A | ∃ (t₁ ∈ T₁) (t₂ ∈ T₂), t = t₁ * t₂} = (*) &lt;$&gt; T₁ &lt;*&gt; T₂ :=\nbegin\n  ext t, split,\n  { rintro ⟨t₁, ht₁, t₂, ht₂, rfl⟩, exact ⟨_, ⟨_, ht₁, rfl⟩, _, ht₂, rfl⟩ },\n  { rintro ⟨_, ⟨t₁, ht₁, rfl⟩, t₂, ht₂, rfl⟩, exact ⟨_, ht₁, _, ht₂, rfl⟩ }\nend\n</pre></div>\n\n\n<p>We need a tactic for these kinds of \"bracket reassociation\" equivalences</p>",
        "id": 135523396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539155187
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> O.ooo....</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"err\">⊢</span> <span class=\"n\">fintype</span> <span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"n\">has_mul</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">insert</span> <span class=\"n\">s₁</span> <span class=\"n\">T₁</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">insert</span> <span class=\"n\">s₂</span> <span class=\"n\">T₂</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>This isn't solved by <code>apply_instance</code>... Or do I need to pull latest mathlib for that?</p>",
        "id": 135524227,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539156403
    },
    {
        "content": "<p>latest mathlib</p>",
        "id": 135524239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539156421
    },
    {
        "content": "<blockquote>\n<p>We need a tactic for these kinds of \"bracket reassociation\" equivalences</p>\n</blockquote>\n<p>Yes, we do!</p>",
        "id": 135524303,
        "sender_full_name": "Sean Leather",
        "timestamp": 1539156505
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Am I supposed to use</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">fintype_seq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">seq_eq_bind_map</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">fintype_bind&#39;</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">finite_seq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">finite</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">finite</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">hf</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">hs</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">dec_eq</span> <span class=\"n\">β</span><span class=\"bp\">;</span> <span class=\"n\">exactI</span> <span class=\"bp\">⟨</span><span class=\"n\">fintype_seq</span> <span class=\"bp\">_</span> <span class=\"bp\">_⟩</span>\n</pre></div>",
        "id": 135526582,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539159746
    },
    {
        "content": "<p>type class search isn't proving the finiteness for me by itself...</p>",
        "id": 135526587,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539159774
    },
    {
        "content": "<p>oh dear, that first <code>def</code> should be an <code>instance</code></p>",
        "id": 135526589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539159781
    },
    {
        "content": "<p>eh, just put <code>attribute [instance] set.fintype_seq</code> in your file, I'll deal with it later</p>",
        "id": 135526658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539159867
    },
    {
        "content": "<p>Is this a simp-lemma?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">rational_open_inter</span> <span class=\"o\">{</span><span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T₁</span> <span class=\"n\">T₂</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">T₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">T₂</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">s₁</span> <span class=\"err\">∈</span> <span class=\"n\">T₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">s₂</span> <span class=\"err\">∈</span> <span class=\"n\">T₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"k\">let</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">T₁</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">T₂</span> <span class=\"k\">in</span>\n<span class=\"n\">rational_open</span> <span class=\"n\">s₁</span> <span class=\"n\">T₁</span> <span class=\"err\">∩</span> <span class=\"n\">rational_open</span> <span class=\"n\">s₂</span> <span class=\"n\">T₂</span> <span class=\"bp\">=</span> <span class=\"n\">rational_open</span> <span class=\"o\">(</span><span class=\"n\">s₁</span> <span class=\"bp\">*</span> <span class=\"n\">s₂</span><span class=\"o\">)</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 135527597,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539161150
    },
    {
        "content": "<p>I don't think so</p>",
        "id": 135527663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539161226
    },
    {
        "content": "<p>I guess it depends on how you interpret <code>rational_open</code></p>",
        "id": 135527671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539161245
    },
    {
        "content": "<p>but it isn't a simp lemma in the other direction, and unless you want intersections of rational opens to \"compute\" to another rational open this is a bit of a strange simp lemma</p>",
        "id": 135527727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539161315
    },
    {
        "content": "<p>Ok, I'll give it as data to <code>simp</code> when I need it.</p>",
        "id": 135527862,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539161485
    },
    {
        "content": "<p>also I'm not positive but the <code>let</code> might get in the way in rewrites</p>",
        "id": 135527912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539161526
    },
    {
        "content": "<p>Yes, I removed the <code>let</code></p>",
        "id": 135528071,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539161822
    },
    {
        "content": "<p>Regarding \"bracket reassociation\": if the types actually uniquely constrain the answer, then telling <code>tidy</code> it's allowed to use either <code>assumption</code> or <code>solve_by_elim</code> will usually do it.</p>",
        "id": 135528592,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539162562
    },
    {
        "content": "<p>I guess you may also need to tell it it's allowed to case bash a bit too, to break apart the hypotheses. For hypotheses covered by <code>auto_cases</code> it should just work.</p>",
        "id": 135528646,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539162626
    },
    {
        "content": "<p>here the cases are all pairs and rfls</p>",
        "id": 135528670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539162672
    },
    {
        "content": "<p>If you're talking about</p>\n<div class=\"codehilite\"><pre><span></span>example {A : Type u} [has_mul A] (T₁ T₂ : set A) :\n  {t : A | ∃ (t₁ ∈ T₁) (t₂ ∈ T₂), t = t₁ * t₂} = (*) &lt;$&gt; T₁ &lt;*&gt; T₂ :=\nbegin\n  ext t, split,\n  { rintro ⟨t₁, ht₁, t₂, ht₂, rfl⟩, exact ⟨_, ⟨_, ht₁, rfl⟩, _, ht₂, rfl⟩ },\n  { rintro ⟨_, ⟨t₁, ht₁, rfl⟩, t₂, ht₂, rfl⟩, exact ⟨_, ht₁, _, ht₂, rfl⟩ }\nend\n</pre></div>\n\n\n<p>then <code>tidy</code> actually does it out of the box.</p>",
        "id": 135528716,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539162743
    },
    {
        "content": "<p>producing the somewhat unhelpful proof:</p>\n<div class=\"codehilite\"><pre><span></span>ext1, dsimp at *, simp at *, fsplit, work_on_goal 0 { intros a, cases a, cases a_h, cases a_h_right, cases a_h_right_h, fsplit, work_on_goal 0 { intros a }, work_on_goal 1 { simp at *, fsplit, work_on_goal 0 { fsplit, work_on_goal 1 { fsplit, work_on_goal 0 { assumption }, refl } }, fsplit, work_on_goal 1 { fsplit, work_on_goal 0 { assumption }, simp at *, solve_by_elim } } }, intros a, cases a, cases a_h, cases a_h_h, cases a_h_w, cases a_h_w_h, cases a_h_h_h, induction a_h_h_h_h, induction a_h_w_h_right, fsplit, work_on_goal 1 { fsplit, work_on_goal 0 { assumption }, simp at *, fsplit, work_on_goal 1 { fsplit, work_on_goal 0 { assumption }, refl } }\n</pre></div>",
        "id": 135528741,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539162814
    },
    {
        "content": "<p>If tidy is slow, and its output is ugly but much faster to compile, would it make sense to expand the tidy proofs but put some markings around them and tell vscode to fold them by default?</p>",
        "id": 135528958,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1539163149
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>I pushed some more finiteness theorems to allow you to write <code>(*) &lt;$&gt; insert s₁ T₁ &lt;*&gt; insert s₂ T₂</code> and have lean automatically figure out this is finite</p>\n</blockquote>\n<p>What do you think of such notation? Is this something we should just get used to, or are we deviating too much from the maths we are formalising if we do that?</p>\n</blockquote>\n<p>I think we need to learn how to use the power of this arcane thing. But of course I would prefer to hide this into obscure proofs of obvious facts rather than having it user-facing. But that opinion could change if suddenly some mathematician-oriented explanation appear.</p>",
        "id": 135529641,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1539164017
    },
    {
        "content": "<p>I must confess that I am absolutely with Patrick here. I've been using Lean for a year and I look at that line and I don't know what <code>&lt;$&gt;</code> or <code>&lt;*&gt;</code> mean. This is some cool monad trick? Don't have time to chase this up right now.</p>",
        "id": 135529842,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539164235
    },
    {
        "content": "<p>It is indeed some cool monad trick. As you know, <code>$</code> means application in lean, and <code>&lt;$&gt;</code> is a \"lifting\" operation on a function, that is, <code>(&lt;$&gt;) : (A -&gt; B) -&gt; F A -&gt; F B</code>, so <code>&lt;$&gt;</code> turns a plain function into a function on the mapped objects. (This is just a functor operation on a morphism, so I doubt it requires much more explanation for a mathematician.)</p>\n<p><code>&lt;*&gt;</code> is similar, but in this case the function itself is wrapped in the functor. That is, <code>(&lt;*&gt;) : F (A -&gt; B) -&gt; F A -&gt; F B</code>. This gives it a sort of behavior like binary product on the objects <code>F(-)</code>, except it deals with functions directly. Functors that have an operation like this are, reasonably enough, called applicative functors. (You can also axiomatize applicative functors using a pairing function <code>F A -&gt; F B -&gt; F (A x B)</code> plus the functor operation on objects and morphisms.)</p>\n<p>Now the cool thing you can do by combining these two is lifting n-ary functions. If <code>f : A -&gt; B -&gt; C -&gt; D</code> and <code>a : A</code>, <code>b : B</code> and <code>c:C</code> then of course <code>f a b c : D</code>, and you should parallel this with <code>f &lt;$&gt; a &lt;*&gt; b &lt;*&gt; c : F D</code> when <code>a : F A</code>, <code>b : F B</code>, <code>c : F C</code>. If you ignore the funny infix monad parts, it's just like <code>f a b c</code> except everything has been lifted across <code>F</code> (except the original function <code>f</code>, which is why the first symbol is <code>&lt;$&gt;</code> instead of <code>&lt;*&gt;</code>).</p>\n<p>What does this have to do with sets? There is a natural functor instance on <code>set</code>, where the map function, of type <code>(A -&gt; B) -&gt; set A -&gt; set B</code>, is the forward image of a set by a function. This has an applicative structure: recalling that we want a type <code>set (A -&gt; B) -&gt; set A -&gt; set B</code>, the action of this operator is to apply all the functions to all the inputs and collect all the resulting outputs. That is, <code>fs &lt;*&gt; s = {y | ∃ f ∈ fs, ∃ x ∈ s, y = f x}</code>. When you apply this specifically to the case of lifting an n-ary function as above, you get <code>f &lt;$&gt; A &lt;*&gt; B &lt;*&gt; C = {y | ∃ (a ∈ A) (b ∈ B) (c ∈ C), y = f a b c}</code>, which is exactly what you would want by the mathematician's notation <code>f(A,B,C)</code> where <code>f</code> has been implicitly lifted to a set function. Here <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> are explicitly notating this lifting process.</p>",
        "id": 135553331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539189960
    },
    {
        "content": "<p>The downside of using this notation with <code>(*)</code> is that now it is no longer in infix position, which makes it a bit stranger to read and bunches up the symbols. It would have been nicer to have some kind of notation like <code>A &lt;(*)&gt; B</code> where the <code>*</code> stays in the middle but this is more ad hoc and also a bit notationally crazy still.</p>",
        "id": 135553602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539190248
    },
    {
        "content": "<p>Thank you Mario for the explanation! I was talking to an undergraduate over lunch today and I mentioned that I was surprised to find that I was needing to have to learn more and more category theory to do number theory properly in Lean, and a logician overheard me and she asked me if I was bad-mouthing category theory, and when I said I wasn't she said not to worry because at the end of the day it was all trivial anyway :-) I still somehow believe this -- it's just that I don't quite know enough of the language (e.g. applicative functor) to talk the talk yet.</p>",
        "id": 135554392,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539191051
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Would you mind taking a look at the Huber and Tate rings files? I think there is a definition of Huber ring that extends Tate ring. But it is not the one we currently use. Is this for a good reason, or should we change the definition of Huber ring?</p>",
        "id": 135847266,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539626137
    },
    {
        "content": "<p>A Tate ring is a Huber ring plus an axiom (there exists a topologically nilpotent unit) [this is the definition in <a href=\"https://www2.math.uni-paderborn.de/fileadmin/Mathematik/People/wedhorn/Lehre/AdicSpaces.pdf\" target=\"_blank\" title=\"https://www2.math.uni-paderborn.de/fileadmin/Mathematik/People/wedhorn/Lehre/AdicSpaces.pdf\">Wedhorn</a> ]</p>",
        "id": 135849476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539628518
    },
    {
        "content": "<p>In <code>Huber_ring.lean</code> the subring and ideal are not part of the data of a Huber ring. The current definition of <code>Huber_ring</code> in the repo is a \"Huber ring plus extra piece of data\" and a Huber ring is a topological ring for which there exists S and J such that the axioms are true.</p>",
        "id": 135849657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539628751
    },
    {
        "content": "<p>The definition of <code>Tate_ring</code> which we have in <code>Tate_ring.lean</code> is from Scholze's <a href=\"https://arxiv.org/abs/1709.07343\" target=\"_blank\" title=\"https://arxiv.org/abs/1709.07343\">etale cohomology of diamonds</a> (beginning of section 3).</p>",
        "id": 135849684,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539628796
    },
    {
        "content": "<p>The proof that it's a Huber ring in the sense we have defined it is that S is R_0 and J is (pi).</p>",
        "id": 135849758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539628829
    },
    {
        "content": "<p>actually that's not quite true -- pi might not be in R_0.  Maybe the easiest thing to say is S = R^o and J is (pi)</p>",
        "id": 135849874,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539628929
    },
    {
        "content": "<p>Right, I was confused. So my question is: should <code>Tate_ring</code> extend <code>Huber_ring</code> and just only require the extra condition about the topologically nilpotent unit. Or do you want to leave the definitions as is? (Which means that the instance from <code>Tate_ring</code> to <code>Huber_ring</code> is non-trivial.)</p>",
        "id": 135850501,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539629590
    },
    {
        "content": "<p>How am I supposed to know? They're all the same mathematically. This is an implementation issue and I have no idea :-( Does it even matter?</p>",
        "id": 135850638,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539629713
    },
    {
        "content": "<p>I get the impression that it is nice to have the <code>extend</code> keyword there (-; <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> Is there a general guideline for this?</p>",
        "id": 135850701,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539629777
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Do we need both equivalent definitions of <code>Huber_ring</code>, or is 1 of them sufficient? I confess that I haven't looked deep enough into the theory to know the answer...</p>",
        "id": 135850746,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539629842
    },
    {
        "content": "<p>So I spent the last couple of hours trying to figure out how close we are. There is still a way to go. Module refactoring is holding some stuff up but there is actually some other stuff we can do now -- to define the restriction maps on the presheaf is longer than I expected. See <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/issues/25\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/issues/25\">https://github.com/kbuzzard/lean-perfectoid-spaces/issues/25</a> . We need a random bunch of lemmas from section 7 (nothing looks hard but it might be a bit long :-( ) and also a lemma from an old paper of Huber.</p>",
        "id": 135850762,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539629876
    },
    {
        "content": "<p>So where are these two definitions of Huber ring? I don't understand the question.</p>",
        "id": 135850808,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539629890
    },
    {
        "content": "<p>Currently <code>Huber_ring</code> is defined in terms of rings of definitions. But it can also be defined as a bounded, complete ring with an adic topology. Is that right?</p>",
        "id": 135850890,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539629993
    },
    {
        "content": "<p>a Huber ring is not what it says in <code>Huber_ring.lean</code></p>",
        "id": 135850949,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539630014
    },
    {
        "content": "<p>A Huber ring is a topological ring for which there exists S and J such that the axioms mentioned in the incorrect structure hold</p>",
        "id": 135850971,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539630048
    },
    {
        "content": "<p>Ok, I see. So what I mean is that there is Lemma 6.2 in Wedhorn.</p>",
        "id": 135851006,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539630092
    },
    {
        "content": "<p>So we can choose one of those three equivalent properties as a definition.</p>",
        "id": 135851014,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539630112
    },
    {
        "content": "<p>One of them closely matches what is in <code>Tate_ring</code>.</p>",
        "id": 135851018,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539630121
    },
    {
        "content": "<p>And my question is: do we need all three. Or is 1 of them sufficient.</p>",
        "id": 135851064,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539630142
    },
    {
        "content": "<p>I.e., do we need Lemma 6.2 or can we cut a corner there.</p>",
        "id": 135851075,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539630156
    },
    {
        "content": "<p>It would not surprise me if we need 6.2 at some point but we don't need it for the definition of a Huber ring.</p>",
        "id": 135851126,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539630227
    },
    {
        "content": "<p>Ok. That answers my question. On my <code>huber_tate</code> branch I have proved some implications of 6.2. But the hard one (iii) -&gt; (i) is not yet done.</p>",
        "id": 135851230,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539630328
    },
    {
        "content": "<p>Are all proofs involving ideals going to break when module refactoring hits?</p>",
        "id": 135851292,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539630369
    },
    {
        "content": "<p>You should ask the only one that knows <span class=\"emoji emoji-1f606\" title=\"lol\">:lol:</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"emoji emoji-2b06\" title=\"up\">:up:</span></p>",
        "id": 135851628,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539630691
    },
    {
        "content": "<p>Johan I know you were thinking about the sheaf on Spa(A). It's like schemes. For an affine scheme first you define the presheaf on a basis and then extend. When I was writing that stuff I would imagine that the extension really was some gadget which extended the earlier object. Now I would regard it as a completely different object.</p>",
        "id": 135851816,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539630885
    },
    {
        "content": "<p>Hmm. Is there some fancy name for the relationship between the the category of presheaves on a basis and the category of presheaves on the whole space?</p>",
        "id": 135851840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539630937
    },
    {
        "content": "<p>You get a fully faithful functor from presheaves on a basis to presheaves on the whole space. And if you restrict this functor to sheaves on a basis, you get an equivalence to sheaves on the whole space.</p>",
        "id": 135852129,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539631205
    },
    {
        "content": "<p>I tried to figure out if this was some sort of example of a morphism of sites. But that doesn't work out. I don't know if other abstract nonsense applies. I guess in the end some maintainer of mathlib might show up and suggest we formalise \"pre-sites\" and invent some new mathematics along the way <span class=\"emoji emoji-1f601\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> <span class=\"emoji emoji-1f643\" title=\"upside down\">:upside_down:</span></p>",
        "id": 135852201,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539631302
    },
    {
        "content": "<p>Yes, anything that makes any reference to modules or ideals will break, although the breakage is probably minor</p>",
        "id": 135852310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539631419
    },
    {
        "content": "<blockquote>\n<p>I tried to figure out if this was some sort of example of a morphism of sites. But that doesn't work out. I don't know if other abstract nonsense applies. I guess in the end some maintainer of mathlib might show up and suggest we formalise \"pre-sites\" and invent some new mathematics along the way <span class=\"emoji emoji-1f601\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> <span class=\"emoji emoji-1f643\" title=\"upside down\">:upside_down:</span></p>\n</blockquote>\n<p>What is usually called a 'morphism of sites' is to me far stronger than is necessary. The best definition I know is in MacLane and Moerdijk's book (<a href=\"https://ncatlab.org/nlab/show/Sheaves+in+Geometry+and+Logic\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/Sheaves+in+Geometry+and+Logic\">https://ncatlab.org/nlab/show/Sheaves+in+Geometry+and+Logic</a>) I'd have to look up the result, though.</p>\n<p>Also note that sheaves on a site can be defined relative to a \"coverage\" (<a href=\"https://ncatlab.org/nlab/show/coverage\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/coverage\">https://ncatlab.org/nlab/show/coverage</a>) rather than a Grothendieck (pre)topology, and the underlying category of a basis of a topology on a space has a coverage (see <a href=\"https://ncatlab.org/nlab/show/coverage#Examples\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/coverage#Examples\">https://ncatlab.org/nlab/show/coverage#Examples</a>), such that the comparison functor to the category of open sets with the usual topology induces an equivalence on categories of sheaves.</p>",
        "id": 135957292,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539764527
    },
    {
        "content": "<p>So don't say \"pre-sites\", but \"categories equipped with a coverage\" and you will be alright wrt the category theory literature</p>",
        "id": 135957332,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539764596
    },
    {
        "content": "<p>Actually, the best notion of a map between sites (or 'categories with coverage') inducing a map between sheaf categories would be in the Elephant (<a href=\"https://ncatlab.org/nlab/show/Elephant\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/Elephant\">https://ncatlab.org/nlab/show/Elephant</a>), I can track it down tomorrow at work</p>",
        "id": 135958401,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539765996
    },
    {
        "content": "<p>An important example in circles I move in is the category Cart whose objects are {R^n| n ≥0} and Cart(R^n,R^m) = C^\\infty(R^n,R^m). This has a coverage whereby a family of maps u_i: R^n --&gt; R^n is covering precisely when they all open embeddings and the image is all of the codomain. It's certainly <em>not</em> a Grothendieck (pre) topology!</p>",
        "id": 135959843,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539767843
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130272\">@David Michael Roberts</span> Cool. That helps. We certainly need to define what a coverage is! I don't have a copy of the Elephant. But a reference would still be helpful.</p>",
        "id": 135963362,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539772667
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/coverage\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/coverage\">https://ncatlab.org/nlab/show/coverage</a></p>",
        "id": 135964391,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539774148
    },
    {
        "content": "<p>Ah, sorry, you meant define as in formally, and a reference for the map of sites result.</p>",
        "id": 135964399,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539774178
    },
    {
        "content": "<p>Right. That page is also going to help me a lot! But I meant the other result.</p>",
        "id": 135964410,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539774202
    },
    {
        "content": "<p>For reference, Elephant C.2.1 is \"Sites and coverages\"</p>",
        "id": 135964478,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539774315
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 135964529,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539774369
    },
    {
        "content": "<p>Remark 2.3.7 in Part C gives a definition of morphism of sites where the underlying categories may fail to have finite limits (so, for example, the poset of opens in a basis for a topology), dependent on Definition 2.3.1.</p>",
        "id": 135964645,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539774567
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/rH_WHewJbvPBi9OomOBJOY0x/Screen-Shot-2018-10-17-at-9.39.13-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-17-at-9.39.13-pm.png\">Screen-Shot-2018-10-17-at-9.39.13-pm.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/rH_WHewJbvPBi9OomOBJOY0x/Screen-Shot-2018-10-17-at-9.39.13-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-17-at-9.39.13-pm.png\"><img src=\"/user_uploads/3121/rH_WHewJbvPBi9OomOBJOY0x/Screen-Shot-2018-10-17-at-9.39.13-pm.png\"></a></div>",
        "id": 135964708,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539774614
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/8MhB3RPWKTZ-m-uxF57hfAle/Screen-Shot-2018-10-17-at-9.40.02-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-17-at-9.40.02-pm.png\">Screen-Shot-2018-10-17-at-9.40.02-pm.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/8MhB3RPWKTZ-m-uxF57hfAle/Screen-Shot-2018-10-17-at-9.40.02-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-17-at-9.40.02-pm.png\"><img src=\"/user_uploads/3121/8MhB3RPWKTZ-m-uxF57hfAle/Screen-Shot-2018-10-17-at-9.40.02-pm.png\"></a></div>",
        "id": 135964712,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539774626
    },
    {
        "content": "<p>I had never realised that nLab had a different definition of <em>site</em> than I'm used to. TIL! <span class=\"emoji emoji-1f4a1\" title=\"bulb\">:bulb:</span></p>",
        "id": 135964797,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539774736
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/egI1m7Y5fw34odhWBTFVUBIT/Screen-Shot-2018-10-17-at-9.42.16-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-17-at-9.42.16-pm.png\">Screen-Shot-2018-10-17-at-9.42.16-pm.png</a> <br>\n<a href=\"/user_uploads/3121/OiIH5Dic9MPk7EzR3aignuXl/Screen-Shot-2018-10-17-at-9.42.35-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-17-at-9.42.35-pm.png\">Screen-Shot-2018-10-17-at-9.42.35-pm.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/egI1m7Y5fw34odhWBTFVUBIT/Screen-Shot-2018-10-17-at-9.42.16-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-17-at-9.42.16-pm.png\"><img src=\"/user_uploads/3121/egI1m7Y5fw34odhWBTFVUBIT/Screen-Shot-2018-10-17-at-9.42.16-pm.png\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/OiIH5Dic9MPk7EzR3aignuXl/Screen-Shot-2018-10-17-at-9.42.35-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-17-at-9.42.35-pm.png\"><img src=\"/user_uploads/3121/OiIH5Dic9MPk7EzR3aignuXl/Screen-Shot-2018-10-17-at-9.42.35-pm.png\"></a></div>",
        "id": 135964804,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539774770
    },
    {
        "content": "<p>And that last stuff is from Mac Lane–Moerdijk VII.10</p>",
        "id": 135964818,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539774809
    },
    {
        "content": "<p>Sorry, that's not what I meant to give you! Didn't read it properly</p>",
        "id": 135964866,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539774851
    },
    {
        "content": "<p>Here's the real bit you need<br>\n<a href=\"/user_uploads/3121/0ZJwc7aM2yIyLFMLKEa4XxpB/Screen-Shot-2018-10-17-at-9.45.38-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-17-at-9.45.38-pm.png\">Screen-Shot-2018-10-17-at-9.45.38-pm.png</a> <br>\n<a href=\"/user_uploads/3121/5O0FDJQTKBKFj-QwJrxOSceA/Screen-Shot-2018-10-17-at-9.46.08-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-17-at-9.46.08-pm.png\">Screen-Shot-2018-10-17-at-9.46.08-pm.png</a> <br>\n(Handy having format-shifted backups of books that are on my shelf at work ;-)</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/0ZJwc7aM2yIyLFMLKEa4XxpB/Screen-Shot-2018-10-17-at-9.45.38-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-17-at-9.45.38-pm.png\"><img src=\"/user_uploads/3121/0ZJwc7aM2yIyLFMLKEa4XxpB/Screen-Shot-2018-10-17-at-9.45.38-pm.png\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/5O0FDJQTKBKFj-QwJrxOSceA/Screen-Shot-2018-10-17-at-9.46.08-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-17-at-9.46.08-pm.png\"><img src=\"/user_uploads/3121/5O0FDJQTKBKFj-QwJrxOSceA/Screen-Shot-2018-10-17-at-9.46.08-pm.png\"></a></div>",
        "id": 135964969,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539775018
    },
    {
        "content": "<p>Should we delete <a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/data/set/basic.lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/master/src/for_mathlib/data/set/basic.lean\"><code>for_mathlib/data/set/basic.lean</code></a>?</p>",
        "id": 136658083,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540742195
    },
    {
        "content": "<p>and just how outdated is the rest of the <code>for_mathlib</code>?</p>",
        "id": 136658156,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540742283
    },
    {
        "content": "<p>I don't have time to think about perfectoid stuff right now, but Kenny if you want to do some tidying then feel free -- I'd appreciate it</p>",
        "id": 136661108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1540746398
    },
    {
        "content": "<p>Kenny, do you mean the current content of that file has been merged in mathlib?</p>",
        "id": 136670419,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1540762022
    },
    {
        "content": "<p>yes: <a href=\"https://github.com/leanprover/mathlib/blob/a33ab1294b386f5fc6465b7221d48a052412bcd8/data/set/basic.lean#L953\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/a33ab1294b386f5fc6465b7221d48a052412bcd8/data/set/basic.lean#L953\">https://github.com/leanprover/mathlib/blob/a33ab1294b386f5fc6465b7221d48a052412bcd8/data/set/basic.lean#L953</a></p>",
        "id": 136670430,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1540762079
    },
    {
        "content": "<p>indeed it was part of the completion merge of course</p>",
        "id": 136670470,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1540762113
    },
    {
        "content": "<p>so yes we can delete that one</p>",
        "id": 136670472,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1540762120
    },
    {
        "content": "<p>and everything about completions</p>",
        "id": 136670479,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1540762150
    },
    {
        "content": "<p>it's all merged upstream</p>",
        "id": 136670483,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1540762159
    },
    {
        "content": "<p>This has always been the plan. We could indeed have a big cleanup, but this is a bit pointless if nobody is working on the project. On the Lean front we are waiting for module and category theory refactor everywhere. And on the math side we are waiting for Kevin to have time, which won't happen soon.</p>",
        "id": 136670556,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1540762291
    },
    {
        "content": "<p>Kenny, why don't you PR your cleanup to the perfectoid project?</p>",
        "id": 146942589,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1541600537
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> <span class=\"emoji emoji-2b06\" title=\"up\">:up:</span></p>",
        "id": 147288728,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1541670694
    },
    {
        "content": "<p>I don't think I have cleaned up</p>",
        "id": 147288779,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541670731
    },
    {
        "content": "<p>Weren't removing lots of stuff that is now in mathlib?</p>",
        "id": 147288782,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1541670746
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  Some news about perfectoid spaces: I-adic topology at <a href=\"https://gist.github.com/PatrickMassot/59c63e7d005350120d6a81f3a0276c87\" target=\"_blank\" title=\"https://gist.github.com/PatrickMassot/59c63e7d005350120d6a81f3a0276c87\">https://gist.github.com/PatrickMassot/59c63e7d005350120d6a81f3a0276c87</a></p>",
        "id": 154271724,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1546555185
    },
    {
        "content": "<p>It's a bit rough, some lemmas should be easier, I probably have a suboptimal setup. I builds on <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> efforts starting at <a href=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_groups.lean#L108\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_groups.lean#L108\">https://github.com/leanprover/mathlib/blob/master/analysis/topology/topological_groups.lean#L108</a></p>",
        "id": 154271853,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1546555314
    },
    {
        "content": "<p>It's a nice idea to make <code>adic_ring I</code> definitionally equal to <code>R</code>. I am slowly but surely beginning to understand the ideas behind this trick. I knew that Lean could unify stuff well, and was under the impression for a while that definitionally equal types were \"just equal\", but it's more subtle than that.</p>",
        "id": 154273293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1546557014
    },
    {
        "content": "<p>I like how people are immediately making good use of <code>use</code> <span class=\"emoji emoji-1f600\" title=\"grinning\">:grinning:</span></p>",
        "id": 154417384,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1546617377
    },
    {
        "content": "<p>It reads so much better than <code>existsi</code></p>",
        "id": 154417394,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1546617389
    },
    {
        "content": "<p>four fewer characters, what's not to love</p>",
        "id": 154421371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546621232
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  I'm not so happy with the <code>decidable_eq</code> instances throughout <code>Huber_pair</code>. What do you think of adding a</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">,</span> <span class=\"n\">priority</span> <span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">prop_decidable</span>\n</pre></div>\n\n\n<p>to the top of the file, so that the rest of the file can focus on actual mathematics?</p>",
        "id": 155317920,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547712196
    },
    {
        "content": "<p>What's the difference?</p>",
        "id": 155317992,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547712244
    },
    {
        "content": "<p>Actually I realise I don't even understand what's going on here</p>",
        "id": 155318005,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547712279
    },
    {
        "content": "<p>Does lean make different terms depending on whether you say h is decidable or everything is decidable including h?</p>",
        "id": 155318024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547712316
    },
    {
        "content": "<p>Readability. Mathematicians will gloss over that incantation in the header. But if they look at the definition of <code>Huber_pair</code>, and all of a sudden they see a condition <code>[decidable_eq R]</code>, they will think \"What the hack is that doing there? That isn't in Wedhorn's text!\".</p>",
        "id": 155318025,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547712316
    },
    {
        "content": "<p>I think I'm firmly in the \"I don't care\" camp</p>",
        "id": 155318101,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547712388
    },
    {
        "content": "<p>I imagine it would be easy to change things later if the constructivists take over</p>",
        "id": 155318124,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547712425
    },
    {
        "content": "<p>I think we should hide this, as Johan suggests</p>",
        "id": 155320282,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547715554
    },
    {
        "content": "<p>I have only glanced at the definitions, but it looks like no interesting example of a Huber ring will have constructive decidable equality.  If that's right, it seems more natural to have a global blanket assumption that you are going to use <code>classical.prop_decidable</code>.</p>",
        "id": 155329632,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1547726729
    },
    {
        "content": "<p>Whilst in theory one could consider non-complete Huber rings like <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><mo>[</mo><mi>T</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[T]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">]</span></span></span></span> with the $p$-adic topology, the moment one does anything with Huber rings one assumes they're complete. I guess <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.974998em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span></span> does not have decidable equality, and more generally I would imagine that only the most trivial of complete rings (like some finite rings) have decidable equality.</p>",
        "id": 155341505,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547737394
    },
    {
        "content": "<p>what do you need decidability for?</p>",
        "id": 155345541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547740129
    },
    {
        "content": "<p>Polynomials</p>",
        "id": 155345704,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547740233
    },
    {
        "content": "<p>Because we need integral closures</p>",
        "id": 155345714,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547740248
    },
    {
        "content": "<p>yeah, that sounds pretty hopeless</p>",
        "id": 155346071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547740556
    },
    {
        "content": "<p>you can define polynomials in a way that doesn't need decidable eq, but you don't get algebraic closure or integral closure as such in constructive analysis</p>",
        "id": 155346150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547740608
    },
    {
        "content": "<p>Aaahrg, my computer is completely frozen... (typing this on my laptop)</p>",
        "id": 158027558,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549889318
    },
    {
        "content": "<p>I just wanted to invoke <code>quotient_group.map</code>... and boom \"deterministic timeout\" etc.</p>",
        "id": 158027574,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549889344
    },
    {
        "content": "<p>When I ask Lean for more info, my entire box freezes.</p>",
        "id": 158027583,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549889358
    },
    {
        "content": "<p>Is this the computer that's almost as old as one of my teenage kids?</p>",
        "id": 158027909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549889701
    },
    {
        "content": "<p>No, that's the one I'm typing on right now. My desktop (which is still frozen...) is a pretty modern beast.</p>",
        "id": 158028473,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549890252
    },
    {
        "content": "<p>I think I'll have to kill it the hard way</p>",
        "id": 158028482,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549890264
    },
    {
        "content": "<p>ssh in from the laptop and killall lean</p>",
        "id": 158028664,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549890481
    },
    {
        "content": "<p>Nah, it was completely frozen</p>",
        "id": 158028754,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549890534
    },
    {
        "content": "<p>This is failing</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">of_inj_value_group</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">minimal_value_group</span><span class=\"bp\">.</span><span class=\"err\">Γ</span> <span class=\"bp\">→</span> <span class=\"n\">v₂</span><span class=\"bp\">.</span><span class=\"n\">minimal_value_group</span><span class=\"bp\">.</span><span class=\"err\">Γ</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">monotone</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">v₂</span><span class=\"bp\">.</span><span class=\"n\">minimal_valuation</span> <span class=\"bp\">=</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">minimal_valuation</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">is_equiv</span> <span class=\"n\">v₂</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">transitivity</span><span class=\"o\">,</span> <span class=\"c1\">-- invalid apply tactic, failed to synthesize type class instance</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>but I proved</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">trans</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">h₁₂</span> <span class=\"o\">:</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">is_equiv</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂₃</span> <span class=\"o\">:</span> <span class=\"n\">v₂</span><span class=\"bp\">.</span><span class=\"n\">is_equiv</span> <span class=\"n\">v₃</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">is_equiv</span> <span class=\"n\">v₃</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">h₁₂</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂₃</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>What else should I do to make the transitivity tactic work?</p>",
        "id": 158514768,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550136063
    },
    {
        "content": "<p>Oooh snap... this doesn't look good</p>\n<div class=\"codehilite\"><pre><span></span>[class_instances]  class-instance resolution trace\n[class_instances] (0) ?x_0 : linear_ordered_comm_group ?m__fresh.1182.788 := _inst_4\nfailed is_def_eq\n[class_instances] (0) ?x_0 : linear_ordered_comm_group ?m__fresh.1182.788 := _inst_3\nfailed is_def_eq\n[class_instances] (0) ?x_0 : linear_ordered_comm_group ?m__fresh.1182.788 := @minimal_value_group.linear_ordered_comm_group ?x_1 ?x_2 ?x_3 ?x_4 ?x_5 ?x_6\nfailed is_def_eq\n</pre></div>",
        "id": 158514853,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550136155
    },
    {
        "content": "<p>Even if I explicitly give an argument</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">begin</span>\n  <span class=\"n\">transitivity</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">minimal_valuation</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>it is still not willing to create two subgoals and apply the trans-lemma.</p>",
        "id": 158514888,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550136235
    },
    {
        "content": "<p><code>refine trans _ _,</code> does work... I wish <code>transitivity</code> would work in a similar way.</p>",
        "id": 158515074,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550136412
    },
    {
        "content": "<p>Voila: Wedhorn 1.27 (i) =&gt; (iii)</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- why is this not in the library???</span>\n<span class=\"c1\">-- there are other theorems about strict monos!!!</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">monotone_of_strict_mono</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">monotone</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"err\">$</span> <span class=\"n\">le_iff_le_of_strict_mono</span> <span class=\"bp\">_</span> <span class=\"n\">H</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">of_map_of_strict_mono</span> <span class=\"o\">{</span><span class=\"err\">Γ₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ₁</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"err\">Γ</span> <span class=\"bp\">→</span> <span class=\"err\">Γ₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"c1\">-- for some reason there is no definition of strict monos. But there are theorems about them.</span>\n<span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_equiv</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">monotone_of_strict_mono</span> <span class=\"n\">H</span><span class=\"o\">))</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">swap</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">with_zero</span><span class=\"bp\">.</span><span class=\"n\">map_monotone</span> <span class=\"o\">(</span><span class=\"n\">monotone_of_strict_mono</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">with_zero</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">_</span> <span class=\"bp\">≤</span> <span class=\"n\">with_zero</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">_</span> <span class=\"bp\">→</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">le_iff_le_of_strict_mono</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">with_zero</span><span class=\"bp\">.</span><span class=\"n\">map_strict_mono</span> <span class=\"n\">H</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 158517637,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550139238
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- Wedhorn 1.27 (i) =&gt; (iii)</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">of_inj_value_group</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">minimal_value_group</span><span class=\"bp\">.</span><span class=\"err\">Γ</span> <span class=\"bp\">→</span> <span class=\"n\">v₂</span><span class=\"bp\">.</span><span class=\"n\">minimal_value_group</span><span class=\"bp\">.</span><span class=\"err\">Γ</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">v₂</span><span class=\"bp\">.</span><span class=\"n\">minimal_valuation</span> <span class=\"bp\">=</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">minimal_valuation</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">monotone_of_strict_mono</span> <span class=\"n\">H</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">is_equiv</span> <span class=\"n\">v₂</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">trans</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">v₂</span><span class=\"bp\">.</span><span class=\"n\">minimal_valuation_is_equiv</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">minimal_valuation_is_equiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">of_map_of_strict_mono</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 158517744,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550139295
    },
    {
        "content": "<p>Hello, sorry, I was on a number theory thing</p>",
        "id": 158519828,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141263
    },
    {
        "content": "<p>Did you find a workaround for your question?</p>",
        "id": 158519910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141326
    },
    {
        "content": "<p>Oh this is great!</p>",
        "id": 158519955,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141359
    },
    {
        "content": "<p>A workaround yes. But I think <code>transitivity</code> is \"broken\". I think it can be more general.</p>",
        "id": 158519956,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141360
    },
    {
        "content": "<p>Of course we don't need those tactics, but they are cute.</p>",
        "id": 158519966,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141376
    },
    {
        "content": "<p>Do we now have all of 1.27?</p>",
        "id": 158519970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141383
    },
    {
        "content": "<p>Nope, not yet.</p>",
        "id": 158519985,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141396
    },
    {
        "content": "<p>What's still missing?</p>",
        "id": 158520030,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141404
    },
    {
        "content": "<p>I did the easy bit of (iii) -&gt; (ii)</p>",
        "id": 158520051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141424
    },
    {
        "content": "<p>We have (i) =&gt; (iii) and (iii) =&gt; (ii).a</p>",
        "id": 158520057,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141431
    },
    {
        "content": "<p>Right.</p>",
        "id": 158520058,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141436
    },
    {
        "content": "<p>but we now know how to do (iii) -&gt; (ii)</p>",
        "id": 158520067,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141447
    },
    {
        "content": "<p>And I proved that (ii).a =&gt; K(v1) = K(v2)</p>",
        "id": 158520069,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141454
    },
    {
        "content": "<p>that's a key step :-)</p>",
        "id": 158520077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141464
    },
    {
        "content": "<p>So now we need to show (ii).b</p>",
        "id": 158520081,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141466
    },
    {
        "content": "<p>because it now means we can <em>state</em> (ii).b :-)</p>",
        "id": 158520085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141476
    },
    {
        "content": "<p>Yep, it's an <code>equiv</code> that is also a <code>field_hom</code>.</p>",
        "id": 158520088,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141482
    },
    {
        "content": "<p>Yes, but it's not so clean. You want to restrict an <code>equiv</code> to subtypes...</p>",
        "id": 158520103,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141508
    },
    {
        "content": "<p>Aah, I was wondering what you meant by <code>K(v1)=K(v2)</code></p>",
        "id": 158520104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141510
    },
    {
        "content": "<p>You mean \"mathematician's =\"</p>",
        "id": 158520136,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141522
    },
    {
        "content": "<p>Are there theorems about that? (Right, and that restriction should be a <code>ring_hom</code>)</p>",
        "id": 158520157,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141529
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> What is the best way to prove that a certain <code>equiv</code> preserves two given subtypes?</p>",
        "id": 158520177,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141575
    },
    {
        "content": "<p>We have two fields which are \"mathematician-equal\", i.e. an equiv, and we want to prove that two subrings are also equiv</p>",
        "id": 158520189,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141604
    },
    {
        "content": "<p>I guess we first need to prove <code>x \\in S1 \\iff e.to_fun x \\in S2</code>?</p>",
        "id": 158520195,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141617
    },
    {
        "content": "<p>That's the guts of (iii) -&gt; (ii).b</p>",
        "id": 158520205,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550141637
    },
    {
        "content": "<p>something like <code>subtype_equiv_of_subtype</code>?</p>",
        "id": 158520251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550141650
    },
    {
        "content": "<p>you might want another version of that where both subtypes are variable...</p>",
        "id": 158520270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550141688
    },
    {
        "content": "<p>No, that takes only 1 Prop.</p>",
        "id": 158520272,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141688
    },
    {
        "content": "<p>like this</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">subtype_equiv_of_subtype&#39;</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"err\">≃</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">//</span> <span class=\"n\">q</span> <span class=\"n\">b</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 158520359,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550141780
    },
    {
        "content": "<p>If you have two subtypes of <code>X</code>, given by props <code>P</code> and <code>Q</code>, and you know <code>P \\iff Q</code>, does that give an equality of the subtypes, or an equiv?</p>",
        "id": 158520400,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141851
    },
    {
        "content": "<p>I guess the equality is again evil, right?</p>",
        "id": 158520408,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141864
    },
    {
        "content": "<p>But is that equiv in mathlib?</p>",
        "id": 158520410,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141872
    },
    {
        "content": "<p>If so, we could chain it to <code>subtype_equiv_of_subtype</code></p>",
        "id": 158520456,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550141891
    },
    {
        "content": "<p>et voilà:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">subtype_equiv_of_subtype&#39;</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"err\">≃</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">//</span> <span class=\"n\">q</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">e</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n <span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n <span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq&#39;</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n <span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq&#39;</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">subtype_equiv_of_subtype</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"err\">≃</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">b</span><span class=\"o\">)}</span> <span class=\"o\">:=</span>\n<span class=\"n\">subtype_equiv_of_subtype&#39;</span> <span class=\"n\">e</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">simp</span>\n</pre></div>",
        "id": 158520596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550142065
    },
    {
        "content": "<p>Merci!</p>",
        "id": 158520625,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550142110
    },
    {
        "content": "<p>If you have two props P and Q that are pointwise iff then the subtypes are indeed equal, and that is indeed evil</p>",
        "id": 158520675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550142133
    },
    {
        "content": "<p>Are you putting the above fact into mathlib? Or should I put it on some PR queue?</p>",
        "id": 158521202,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550142761
    },
    {
        "content": "<p>put it in a PR, it's easier for me that way</p>",
        "id": 158521208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550142782
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Voila: <a href=\"https://github.com/leanprover/mathlib/issues/724\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/issues/724\">#724</a></p>",
        "id": 158523534,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550145515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">val_ring_equiv_of_is_equiv</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">is_equiv</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">valuation_ring</span> <span class=\"err\">≃</span> <span class=\"n\">v₂</span><span class=\"bp\">.</span><span class=\"n\">valuation_ring</span> <span class=\"o\">:=</span>\n<span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">subtype_congr</span> <span class=\"o\">(</span><span class=\"n\">valfield_equiv_valfield_of_eq_supp</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">supp_eq</span><span class=\"o\">)</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"bp\">_</span> <span class=\"bp\">≤</span> <span class=\"bp\">_</span> <span class=\"bp\">↔</span> <span class=\"bp\">_</span> <span class=\"bp\">≤</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">on_valuation_field</span><span class=\"bp\">.</span><span class=\"n\">map_one</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">on_valuation_field_is_equiv</span><span class=\"o\">],</span>\n  <span class=\"n\">convert</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">valuation</span><span class=\"bp\">.</span><span class=\"n\">map_one</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">xyzzy</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">is_equiv</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">val_ring_equiv_of_is_equiv</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">valfield_equiv_valfield_of_eq_supp</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">supp_eq</span> <span class=\"o\">:</span>\n      <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">valuation_field</span> <span class=\"bp\">→</span> <span class=\"n\">v₂</span><span class=\"bp\">.</span><span class=\"n\">valuation_field</span><span class=\"o\">)),</span>\n  <span class=\"n\">constructor</span><span class=\"o\">,</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val_injective</span><span class=\"o\">,</span>\n    <span class=\"n\">assumption</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">apply_assumption</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 158615675,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550239092
    },
    {
        "content": "<p>I will probably get frowned at for that last proof... It ought to be generalised.</p>",
        "id": 158615711,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550239139
    },
    {
        "content": "<p>Anyway, this proves Wedhorn 1.27 (iii) =&gt; (ii)b</p>",
        "id": 158615729,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550239155
    },
    {
        "content": "<p>You're not old enough to remember <code>xyzzy</code>!</p>",
        "id": 158637984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550256033
    },
    {
        "content": "<p>Haha... parts of me are very old.</p>",
        "id": 158637994,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550256056
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> So there is this \"fake\" quotient <code>Spv R</code> that is morally the set of equivalence classes of valuations on <code>R</code>. It isn't a Lean-quotient because of universe issues. We can manually define <code>mk</code> and <code>lift</code> etc, and prove the quotient-axioms. Now here is a question... do you think there is any value in making <code>out</code> computable?</p>",
        "id": 158638348,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550256360
    },
    {
        "content": "<p>Given an equivalence class, I can write an algorithm that \"canonically\" builds a valuation that represents this class.</p>",
        "id": 158638466,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550256435
    },
    {
        "content": "<p>Does this matter, if the computation-rule isn't going to be defeq anyway?</p>",
        "id": 158638578,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550256505
    },
    {
        "content": "<p>One key observation is that the canonical element you construct is computable! So we can just define quotient.lift by evaluating at this element and it will be computable as well. This is in contrast to my construction of general quotients using equivalence classes</p>",
        "id": 158647172,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550262925
    },
    {
        "content": "<p>Ok, getting back to this stuff with equality and equiv's. Suppose I have a type <code>X</code> and a function <code>f : X → Type u</code>. And suppose I have two terms <code>x y : X</code>, and a proof <code>h : x = y</code>. Do I understand correctly that it is now evil to apply <code>congr_arg f h</code> to conclude that <code>f x = f y</code>?</p>",
        "id": 159807884,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551549277
    },
    {
        "content": "<p>better question: what do you intend to do with this equality?</p>",
        "id": 159808130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551549675
    },
    {
        "content": "<p>For the moment I think I would mostly don't do anything and just be comforted by it</p>",
        "id": 159808136,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551549716
    },
    {
        "content": "<p>there are lots of ways to express \"equality of types\", and <code>=</code> is rarely the right one</p>",
        "id": 159808178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551549727
    },
    {
        "content": "<p>the answer depends on what <code>f</code> is</p>",
        "id": 159808183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551549765
    },
    {
        "content": "<p>Which other ones can you <code>rw</code> with?</p>",
        "id": 159808269,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551549935
    },
    {
        "content": "<p>Did you see the local ring question? Prove that if R is a local ring and S is isomorphic to R then S is a local ring.</p>",
        "id": 159808314,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551549980
    },
    {
        "content": "<p>Proof: the lattice of ideals for R and S are isomorphic.</p>",
        "id": 159808373,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550094
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Suppose I have <code>f : Y → X</code>. Then I would really like the fibre of a point in <code>x</code> to be <em>unique</em>. So if <code>x = y</code>, then they have the same fibre.</p>",
        "id": 159808396,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551550175
    },
    {
        "content": "<p>I'm working on it <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span></p>",
        "id": 159808399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551550201
    },
    {
        "content": "<blockquote>\n<p>Proof: the lattice of ideals for R and S are isomorphic.</p>\n</blockquote>\n<p>Proof: the non-units are closed under addition</p>",
        "id": 159808581,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551550482
    },
    {
        "content": "<p>You still have to write some code. And when you've done that, prove that R is Cohen-Macauley iff S is.</p>",
        "id": 159808606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550518
    },
    {
        "content": "<p>Then you have to write lots of code.</p>",
        "id": 159808607,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550531
    },
    {
        "content": "<p>But no mathematician even understands what to write.</p>",
        "id": 159808609,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550543
    },
    {
        "content": "<p>Hence automation should be doing it.</p>",
        "id": 159808655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> is a local ring a) a ring that has a unique maximal ideal, or b) a ring with an ideal such that the ideal is the unique maximal ideal?</p>",
        "id": 159808657,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551550575
    },
    {
        "content": "<p>I think (a)</p>",
        "id": 159808659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550591
    },
    {
        "content": "<p>but of course I also think (b)</p>",
        "id": 159808661,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550600
    },
    {
        "content": "<p>But when these things matter, things are usually (a)ish</p>",
        "id": 159808663,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550621
    },
    {
        "content": "<p>is Q_p a local field?</p>",
        "id": 159808668,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551550624
    },
    {
        "content": "<p>sure</p>",
        "id": 159808671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550631
    },
    {
        "content": "<p>or is the local field (Q_p, Z_p, pZ_p, F_p)?</p>",
        "id": 159808672,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551550633
    },
    {
        "content": "<p>sure</p>",
        "id": 159808674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550639
    },
    {
        "content": "<p>mathematicians are strange</p>",
        "id": 159808675,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551550647
    },
    {
        "content": "<p>let me think</p>",
        "id": 159808676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550650
    },
    {
        "content": "<p>I can give you a better answer</p>",
        "id": 159808677,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550657
    },
    {
        "content": "<p>A local field comes equipped with an equivalence class of norms</p>",
        "id": 159808680,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550677
    },
    {
        "content": "<p>and I can work out all the other stuff you wrote from the norm</p>",
        "id": 159808726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550702
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> What about my example? Fibres of a function. And suppose that the fibres are vector spaces. Will <code>f^{-1} x</code> and <code>f^{-1} y</code> be the same vector space if <code>x = y</code>?</p>",
        "id": 159808728,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551550715
    },
    {
        "content": "<p>Is x defeq to y?</p>",
        "id": 159808729,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550742
    },
    {
        "content": "<p>Nope</p>",
        "id": 159808737,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551550750
    },
    {
        "content": "<p>and there's also a theorem that you can recover the norm from the algebra</p>",
        "id": 159808738,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551550750
    },
    {
        "content": "<p>so are we just going to omit the norm?</p>",
        "id": 159808742,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551550760
    },
    {
        "content": "<p>It is not true for a general normed field that you can recover the norm from the algebra</p>",
        "id": 159808748,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550792
    },
    {
        "content": "<p>Alright you guys are being impatient so I'll just show you what I have in mind:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">ideals</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">bi_unique</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">relator</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_exists_unique_of_total</span> <span class=\"o\">[</span><span class=\"n\">bi_total</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">bi_unique</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">R</span> <span class=\"err\">⇒</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"err\">⇒</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"bp\">∃!</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"bp\">∃!</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rel_exists_of_total</span> <span class=\"n\">R</span> <span class=\"err\">$</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">rel_and</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"n\">rel_forall_of_total</span> <span class=\"n\">R</span> <span class=\"err\">$</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">rel_imp</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rel_eq</span> <span class=\"n\">R</span> <span class=\"n\">s</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span> <span class=\"n\">relator</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">equiv</span>\n\n<span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">symm_rel</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">symm_apply_eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">eq_comm</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">relator</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">rel_left_unique</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">left_unique</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a₁</span> <span class=\"n\">b</span> <span class=\"n\">a₂</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨⟩;</span> <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">bijective</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">rel_right_unique</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">right_unique</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a₁</span> <span class=\"n\">b</span> <span class=\"n\">a₂</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨⟩</span> <span class=\"bp\">⟨⟩;</span> <span class=\"n\">refl</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">rel_bi_unique</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bi_unique</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">rel_left_unique</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">rel_right_unique</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">rel_left_total</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">left_total</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span> <span class=\"n\">rel_right_total</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">right_total</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">bijective</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n<span class=\"kn\">instance</span> <span class=\"n\">rel_bi_total</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bi_total</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">equiv</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ring_equiv</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ_</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"bp\">λ</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">apply_inverse_apply</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_inverse_apply</span> <span class=\"n\">x</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">inverse_apply_apply</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span><span class=\"bp\">.</span><span class=\"n\">inverse_apply_apply</span> <span class=\"n\">x</span>\n\n<span class=\"n\">def</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">ideal_comap</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">e</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">I</span><span class=\"o\">,</span>\n  <span class=\"n\">zero</span>  <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_zero</span> <span class=\"n\">e</span><span class=\"o\">],</span>\n  <span class=\"n\">add</span>   <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_add</span> <span class=\"n\">e</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">add_mem</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n  <span class=\"n\">smul</span>  <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span> <span class=\"n\">e</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">smul_mem</span> <span class=\"bp\">_</span> <span class=\"n\">h</span> <span class=\"o\">}</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">mem_ideal_comap</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"err\">∈</span> <span class=\"n\">ideal_comap</span> <span class=\"n\">e</span> <span class=\"n\">I</span> <span class=\"bp\">↔</span> <span class=\"n\">e</span> <span class=\"n\">r</span> <span class=\"err\">∈</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">ideal_comap_top</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ideal_comap</span> <span class=\"n\">e</span> <span class=\"err\">⊤</span> <span class=\"bp\">=</span> <span class=\"err\">⊤</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"n\">def</span> <span class=\"n\">ideal_congr</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">ideal</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">ideal</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">ideal_comap</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">ideal_comap</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">ideal_congr_apply</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ideal_congr</span> <span class=\"n\">e</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">ideal_comap</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">ideal_congr_symm_apply</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ideal_congr</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">ideal_comap</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">ring_equiv</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">relator</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">rel_ideal_top</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">ideal_congr</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"err\">⊤</span> <span class=\"err\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"n\">ring_equiv</span><span class=\"bp\">.</span><span class=\"n\">ideal_comap_top</span> <span class=\"bp\">_</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">rel_lt_ideal</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">ideal_congr</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">ideal_congr</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"n\">has_lt</span><span class=\"bp\">.</span><span class=\"n\">lt</span> <span class=\"n\">has_lt</span><span class=\"bp\">.</span><span class=\"n\">lt</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">_=_</span><span class=\"o\">)</span> <span class=\"n\">I&#39;</span> <span class=\"n\">J&#39;</span> <span class=\"o\">(</span><span class=\"n\">h&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">_=_</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">substs</span> <span class=\"n\">h</span> <span class=\"n\">h&#39;</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"bp\">_</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">rel_is_maximal</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">ideal_congr</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">is_maximal</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">is_maximal</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rel_and</span>\n  <span class=\"o\">(</span><span class=\"n\">rel_not</span> <span class=\"err\">$</span> <span class=\"n\">rel_eq</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">ideal_congr</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">h</span> <span class=\"err\">$</span> <span class=\"n\">rel_ideal_top</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">rel_forall_of_total</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">ideal_congr</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"err\">$</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">I&#39;</span> <span class=\"n\">J&#39;</span> <span class=\"n\">h&#39;</span><span class=\"o\">,</span> <span class=\"n\">rel_imp</span>\n      <span class=\"o\">(</span><span class=\"n\">rel_lt_ideal</span> <span class=\"n\">f</span> <span class=\"n\">h</span> <span class=\"n\">h&#39;</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">rel_eq</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">ideal_congr</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">h&#39;</span> <span class=\"o\">(</span><span class=\"n\">ring_equiv</span><span class=\"bp\">.</span><span class=\"n\">ideal_comap_top</span> <span class=\"bp\">_</span><span class=\"o\">)))</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">relator</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">is_local_ring_congr</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"err\">≃</span><span class=\"n\">r</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_local_ring</span> <span class=\"n\">R</span> <span class=\"bp\">↔</span> <span class=\"n\">is_local_ring</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">rel_exists_unique_of_total</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">ideal_congr</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"err\">$</span>\n<span class=\"bp\">λ</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">,</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">rel_is_maximal</span> <span class=\"n\">f</span>\n</pre></div>",
        "id": 159808751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551550797
    },
    {
        "content": "<p>and I'm trying to do it properly</p>",
        "id": 159808795,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550804
    },
    {
        "content": "<p>Johan what do you mean by this fibre? Is it of type <code>set Y</code> or <code>subtype Y</code>?</p>",
        "id": 159808815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550856
    },
    {
        "content": "<p>There are definitely a lot of missing theorems for this kind of proof</p>",
        "id": 159808834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551550904
    },
    {
        "content": "<p>the fibre is the stalk of the blah blah blah</p>",
        "id": 159808837,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551550909
    },
    {
        "content": "<p>I was thinking <code>subtype</code></p>",
        "id": 159808875,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551550923
    },
    {
        "content": "<p>but the last theorem looks pretty cool</p>",
        "id": 159808880,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551550928
    },
    {
        "content": "<p>but this is what you want to do for transferring across isomorphisms in the general case</p>",
        "id": 159808881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551550932
    },
    {
        "content": "<p>sure, for every scenario one can transfer across isomorphisms</p>",
        "id": 159808883,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551550962
    },
    {
        "content": "<p>but can one transfer across isomorphisms for every scenario?</p>",
        "id": 159808891,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551550970
    },
    {
        "content": "<p>You should look in particular at how <code>rel_is_maximal</code> is being proven</p>",
        "id": 159808898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551550975
    },
    {
        "content": "<p>what is <code>⇒</code>?</p>",
        "id": 159808908,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1551551002
    },
    {
        "content": "<p><code>is_maximal</code> is some complicated proposition, but there are simple theorems you can apply in every case</p>",
        "id": 159808909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551551005
    },
    {
        "content": "<p>I am alone and not at work (very rare indeed) and I'm writing perfectoid stuff so I'd like to go back to that now but rest assured I will be back later to look at this code. I just want to keep working until my family return.</p>",
        "id": 159808911,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551551012
    },
    {
        "content": "<p><code>⇒</code> is the relation lifting for functions: <code>(R ⇒ S) f g</code> says that if the inputs to f and g are related by R then the outputs are related by S</p>",
        "id": 159808958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551551062
    },
    {
        "content": "<p>The notation isn't essential, you could just say that</p>",
        "id": 159809020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551551164
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Johan and I have now made a load of API for valuations, and I just want to check this before I launch into the next bit:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"o\">],</span>\n <span class=\"k\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>Is this definition OK, because I use the same universe in the subtype as I do for <code>R</code>?</p>\n<div class=\"codehilite\"><pre><span></span>Spv : Π (R : Type u_1) [_inst_3 : comm_ring R], Type u_1\n</pre></div>",
        "id": 159953991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551736038
    },
    {
        "content": "<p>And if I'd put Gamma : Type u\\1 then it would be less OK, right?</p>",
        "id": 159954003,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551736058
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"o\">],</span>\n <span class=\"k\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n\n<span class=\"kn\">notation</span> <span class=\"n\">r</span> <span class=\"bp\">`≤</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">v</span><span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">r</span> <span class=\"n\">s</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Spv</span>\n<span class=\"kn\">open</span> <span class=\"n\">valuation</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"bp\">⟨</span><span class=\"n\">value_group</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"n\">canonical_valuation</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">canonical_valuation_is_equiv</span> <span class=\"n\">v</span><span class=\"bp\">⟩⟩</span>\n</pre></div>\n\n\n<p><span class=\"user-mention\" data-user-id=\"210574\">@Patrick Massot</span> <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> we have a mk!</p>",
        "id": 159955916,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551737484
    },
    {
        "content": "<p>(Gamma is in universe u1)</p>",
        "id": 159955942,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551737514
    },
    {
        "content": "<p>We had one before, but this one is <em>much</em> nicer. No horrible quotient groups or anything. I've just looked at the proofs in canonical.lean and they're almost all only a few lines long. It feels like we have written some semi-professional code here. I'm sure the experts could have done better, but somehow this code feels a lot more maintainable than the sort of rubbish I was cranking out when I wrote schemes.</p>",
        "id": 159956086,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551737598
    },
    {
        "content": "<p>you don't need the <code>haveI := h; exact</code> bit, you can just <code>exactI</code></p>",
        "id": 159964978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551745466
    },
    {
        "content": "<p>your definition of <code>Spv</code> looks good</p>",
        "id": 159965119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551745621
    },
    {
        "content": "<p>I suggest using a local notation for <code>r ≤[v] s </code></p>",
        "id": 159965155,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551745675
    },
    {
        "content": "<p>So now here's one approach:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ</span><span class=\"o\">],</span>\n <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">out_</span><span class=\"err\">Γ</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_comm_group</span> <span class=\"o\">(</span><span class=\"n\">out_</span><span class=\"err\">Γ</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"err\">$</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"kn\">definition</span> <span class=\"n\">out</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">out_</span><span class=\"err\">Γ</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"err\">$</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"err\">$</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n</pre></div>\n\n\n<p>And another approach is to write a bunch of code which, given an inequality (for that is what a term of type <code>Spv R</code> actually is), actually construct a valuation on R. I am pretty sure that this is possible,  given the work we have already done. However I currently don't understand if it is worth doing this. It would involve extending the inequality on R to an inequality on a certain field and then constructing Gamma using the units of that field. If I wrote all this code, and it would not be hard to write given what we have, we would end up with a computable definition, I think.</p>\n<p>Should I write this code?</p>",
        "id": 159992017,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551781774
    },
    {
        "content": "<p>What would we do with this computable definition?</p>",
        "id": 159992300,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1551782061
    },
    {
        "content": "<p>I don't understand the point of computability. But I know it can be written now.</p>",
        "id": 159992317,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551782080
    },
    {
        "content": "<p>I'm just writing a roadmap in valuation_spectrum.lean and then I'm going to push and take a break for a few days to do work admin.</p>",
        "id": 159992353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551782113
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I just realised that I don't know the type of <code>Spv.lift</code>. For every Gamma I have <code>mk: valuation R Gamma -&gt; Spv R</code>. I have <code>equiv: valuation R Gamma1 -&gt; valuation R Gamma2 -&gt; Prop</code>. What function am I trying to descend here? A function on valuation R Gamma? Then I don't need the full force of equiv -- I only need it for when Gamma1 = Gamma2. Does that sound right?</p>",
        "id": 159992984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551782846
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">is_equiv</span> <span class=\"o\">(</span><span class=\"n\">v₁</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v₂</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">v₁</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v₁</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">v₂</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v₂</span> <span class=\"n\">s</span>\n</pre></div>",
        "id": 159993046,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551782892
    },
    {
        "content": "<p><code>definition mk (v : valuation R Γ) : Spv R := ...</code></p>",
        "id": 159993061,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551782929
    },
    {
        "content": "<p>Should my lift be descending functions defined on a big sigma type? If so, which universes should my Gammas live in? Completely general ones?</p>",
        "id": 159993109,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551783000
    },
    {
        "content": "<p>This sounds right to me. In the ZFC lying version of this story, the \"equivalence class\" has arbitrarily large Gamma's in.</p>",
        "id": 159993239,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551783103
    },
    {
        "content": "<p>Is it Ok for <code>Spv.out</code> to be a pi type <code>Spv.out : Pi (v : Spv R), valuation R (value_group v)</code>? Here <code>value_group v</code> will be in the same universe as <code>R</code> (but will depend on <code>v</code>).</p>",
        "id": 159993370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551783240
    },
    {
        "content": "<p>I had not realised these subtleties until now.</p>",
        "id": 159993417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551783258
    },
    {
        "content": "<p>I've just run through this and it looks right to me. Using what we have I believe we can define a continuity predicate on <code>valuation R Gamma</code> in such a way that if <code>v1 : valuation R Gamma1</code> and <code>v2 : valuation R Gamma2</code> are equivalent then one is continuous iff the other one is. This should be the input to <code>Spv.lift</code> in order to descend continuity to <code>Spv R</code>.</p>\n<p>In summary then,</p>\n<div class=\"codehilite\"><pre><span></span>R : Type u, Γ : Type u0, Γ1 : Type u1, Γ2 : Type u2\nSpv R : Type u\n\nSpv.mk  (v : valuation R Γ) : Spv R\n\nvalue_group {R : Type u} : Spv R -&gt; Type u -- same universe\n\nSpv.out : Pi (v : Spv(R)), valuation R (value_group v)\n\nSpv.lift : ∀ (f : Σ Γ, valuation R Γ → X),\n  (∀ v1 v2 : Σ Γ, valuation R Γ, is_equiv v1.2 v2.2)\n  → Spv R → X\n</pre></div>",
        "id": 159994621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551784564
    },
    {
        "content": "<p>Do you know if it's possible to have a single Gamma that can support all valuations in Spv R?</p>",
        "id": 160014574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551801548
    },
    {
        "content": "<p>that would simplify a lot of this</p>",
        "id": 160014586,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551801557
    },
    {
        "content": "<p>Huh, that sounds suspicious...</p>",
        "id": 160014616,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551801584
    },
    {
        "content": "<p>I mean, you could take the coproduct of <code>value_group v</code> for all <code>v : Spv R</code></p>",
        "id": 160014726,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551801641
    },
    {
        "content": "<p>I don't think it's that crazy - we know there are only set many valuations over R up to equivalence, because they are determined by relations on R, so we just need a group that embeds all of those canonical groups</p>",
        "id": 160014739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551801653
    },
    {
        "content": "<p>But that sounds like a very ugly group to work with, and it is not linearly ordered</p>",
        "id": 160014753,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551801664
    },
    {
        "content": "<p>it has to be linear ordered too</p>",
        "id": 160014766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551801674
    },
    {
        "content": "<p>is it possible to show that some valuations are incompatible with others?</p>",
        "id": 160014790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551801706
    },
    {
        "content": "<p>What do you mean precisely?</p>",
        "id": 160014856,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551801727
    },
    {
        "content": "<p>well, you said the coproduct is the natural answer but it's not linearly ordered. So either there is a way to order it, or maybe there is some innate reason it's impossible</p>",
        "id": 160014902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551801769
    },
    {
        "content": "<p>what is the construction <code>value_group</code> again?</p>",
        "id": 160015017,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551801856
    },
    {
        "content": "<p>Hmm, maybe lexicographic order works on the coproduct (but that is very non-canonical, since it depends on ordering <code>Spv</code>)</p>",
        "id": 160015047,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551801892
    },
    {
        "content": "<p><code>value_group v</code> is <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>K</mi><mo>∗</mo></msup><mi mathvariant=\"normal\">/</mi><msup><mi>A</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">K^* / A^*</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mord mathrm\">/</span><span class=\"mord\"><span class=\"mord mathit\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>K</mi><mo>=</mo><mtext>Frac</mtext><mo>(</mo><mi>R</mi><mi mathvariant=\"normal\">/</mi><mtext>supp</mtext><mo>(</mo><mi>v</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">K = \\text{Frac}(R/ \\text{supp} (v))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span><span class=\"mrel\">=</span><span class=\"mord text\"><span class=\"mord mathrm\">Frac</span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathrm\">/</span><span class=\"mord text\"><span class=\"mord mathrm\">supp</span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>=</mo><mo>{</mo><mi>k</mi><mo>∈</mo><mi>K</mi><mi mathvariant=\"normal\">∣</mi><mi>v</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>≤</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">A = \\{k \\in K | v (k) \\le 1\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mrel\">=</span><span class=\"mopen\">{</span><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel\">∈</span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathrm\">∣</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mrel\">≤</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">}</span></span></span></span></p>",
        "id": 160015166,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551801972
    },
    {
        "content": "<p>how is that ordered?</p>",
        "id": 160015207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551802009
    },
    {
        "content": "<p>By working hard (-;</p>",
        "id": 160015243,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551802037
    },
    {
        "content": "<p>By extending <code>v</code> to <code>K</code> (implicit in the above formula) you get an inequality on <code>K</code>. This descends to a linear order on <code>value_group v</code>.</p>",
        "id": 160015348,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551802086
    },
    {
        "content": "<p>(Or maybe I should say it lifts...)</p>",
        "id": 160015361,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551802096
    },
    {
        "content": "<p>So this linearly ordered group is supposed to be a multiplicative group, right, with a bottom element adjoined?</p>",
        "id": 160015757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551802404
    },
    {
        "content": "<p>What happens to the one of the group?</p>",
        "id": 160015768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551802414
    },
    {
        "content": "<p>won't they have to be identified in the coproduct?</p>",
        "id": 160015787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551802438
    },
    {
        "content": "<p>This is just a group. And (in math-speak) you show that <code>v</code> takes values in <code>value_group \\cup {0}</code></p>",
        "id": 160015839,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551802454
    },
    {
        "content": "<p>(When I say multiplicative group I mean that 0 is the exceptional element not really in the group)</p>",
        "id": 160015882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551802495
    },
    {
        "content": "<blockquote>\n<p>(Or maybe I should say it lifts...)</p>\n</blockquote>\n<p>Please don't.</p>",
        "id": 160015884,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1551802496
    },
    {
        "content": "<p><code>value_group v</code> is an honest multiplicative group. The bottom element is not yet adjoined. So if you take a coproduct of multiplicative groups, then the <code>1</code>s get identified.</p>",
        "id": 160016007,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551802566
    },
    {
        "content": "<p>But this coproduct is really a hack. Maybe <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> knows of a better way to find a universal Gamma</p>",
        "id": 160016034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551802597
    },
    {
        "content": "<p>I suspect it's a necessary condition, since if you have a family of valuations on the same group then you can linearly order them by looking at where they send a random non-one element</p>",
        "id": 160016094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551802654
    },
    {
        "content": "<p>Which condition is necessary?</p>",
        "id": 160016180,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551802686
    },
    {
        "content": "<p>That the set of valuations has a total order</p>",
        "id": 160016226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551802712
    },
    {
        "content": "<p>once you have a total order on all the valuations the lex order is canonical</p>",
        "id": 160016268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551802744
    },
    {
        "content": "<p>Ooh, but different valuations may send your random non-one element to the same <code>gamma : Gamma</code>.</p>",
        "id": 160016281,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551802752
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Okay, I think you had the right idea after all. The only thing I would change about your last post is that the sigmas should be uncurried:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"err\">Γ</span><span class=\"mi\">1</span> <span class=\"err\">Γ</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"n\">is_equiv</span> <span class=\"n\">v1</span> <span class=\"n\">v2</span><span class=\"o\">)</span>\n  <span class=\"bp\">→</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n\n<span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">f</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"err\">Γ</span> <span class=\"n\">v</span>\n</pre></div>",
        "id": 160017808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551803699
    },
    {
        "content": "<p>Note that <code>f</code> here necessarily cannot range over all gammas in all universes, so you can only use the final equation when v has an appropriate universe for its value group</p>",
        "id": 160018035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551803857
    },
    {
        "content": "<p>Actually, I think this will work better than the traditional mk/lift approach for quotients:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">u0</span> <span class=\"n\">u1</span> <span class=\"n\">u2</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u0</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"err\">Γ</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"err\">Γ</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u2</span><span class=\"o\">}</span>\n<span class=\"kn\">constant</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"kn\">constant</span> <span class=\"n\">valuation</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">u0</span><span class=\"o\">)</span>\n<span class=\"kn\">constant</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span>\n<span class=\"kn\">constant</span> <span class=\"n\">value_group</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"kn\">constant</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">out</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">value_group</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"kn\">constant</span> <span class=\"n\">valuation</span><span class=\"bp\">.</span><span class=\"n\">is_equiv</span> <span class=\"o\">(</span><span class=\"n\">v₁</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v₂</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">⦃</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">⦄,</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">out</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">lift_eq</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">⦃</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">⦄,</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">⦃</span><span class=\"err\">Γ</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u2</span><span class=\"o\">⦄,</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"err\">Γ</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">v₁</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"n\">v₁</span><span class=\"bp\">.</span><span class=\"n\">is_equiv</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">f₁</span> <span class=\"n\">v₁</span> <span class=\"bp\">=</span> <span class=\"n\">f₂</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">f₁</span> <span class=\"o\">(</span><span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f₂</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>Here the proof of equality is delayed until the lift/mk rule, rather than being embedded in the lift function itself. This makes sense since you are defining it using <code>Spv.out</code> anyway, and by delaying the proof until the equality is used, you can have the equality use a different universe variable than the one it was originally defined with</p>",
        "id": 160019298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551804869
    },
    {
        "content": "<p>Thanks for pointing out this subtlety.</p>",
        "id": 160019480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551804989
    },
    {
        "content": "<p>Yes you're absolutely right, we don't need the equivalence in the definition of lift.</p>",
        "id": 160019499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551805015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Cool, I like this idea.</p>",
        "id": 160020628,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551805815
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I think we should forget about computable <code>out</code> until we have done a bunch of other stuff. It shouldn't affect any of the code that comes after it anyway. So we should be able to change the definition of <code>out</code> later on...</p>",
        "id": 160020726,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551805905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Or do you think this is a dangerous idea?</p>",
        "id": 160020741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551805919
    },
    {
        "content": "<p>I think you shouldn't worry about anything being noncomputable here</p>",
        "id": 160027955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551811141
    },
    {
        "content": "<p>In particular <code>quot.out</code> is noncomputable anyway so if your version of it is too then it's not a big surprise</p>",
        "id": 160028033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551811191
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> We have probably discussed this before, but I'd like to hear your opinion again.<br>\nCurrently, we are defining a topology on <code>Spv</code> as follows:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span> <span class=\"n\">basic_open</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">generate_from</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"bp\">=</span> <span class=\"n\">basic_open</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 160092355,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551876822
    },
    {
        "content": "<p>This definition completely ignores the question whether those basic opens are independent of the representative of <code>v</code>.</p>",
        "id": 160092427,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551876852
    },
    {
        "content": "<p>Is that a problem?</p>",
        "id": 160092440,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551876865
    },
    {
        "content": "<p>To parse the definition of <code>basic_open</code> you need to know</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">with_zero</span> <span class=\"o\">(</span><span class=\"n\">out_</span><span class=\"err\">Γ</span> <span class=\"n\">v</span><span class=\"o\">),</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">out</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 160092460,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551876889
    },
    {
        "content": "<p>Johan can't we define it as <code>r &lt;=[v] s</code> ?</p>",
        "id": 160095100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551879140
    },
    {
        "content": "<p>This must be what you mean. What is your question?</p>",
        "id": 160095154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551879172
    },
    {
        "content": "<p>That notation is nice, but then <code>v s ≠ 0</code> becomes ugly. Or we also need notation for that...</p>",
        "id": 160095328,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551879294
    },
    {
        "content": "<p><code>0 &lt;[v] s</code></p>",
        "id": 160095363,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551879328
    },
    {
        "content": "<p>Sure... we could do that... of course it is math-equal to <code>v s ≠ 0</code>.</p>",
        "id": 160095470,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551879378
    },
    {
        "content": "<p>Isn't there some le_zero result which proves they're lean-equal too.</p>",
        "id": 160095510,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551879415
    },
    {
        "content": "<p>What I mean is that it won't be defeq, not notational-eq. Mathematicians will not immediately recognise the definition. And they will find it odd. I don't know if we care.</p>",
        "id": 160095539,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1551879458
    },
    {
        "content": "<p>The most unreadable definition in the project so far:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">away_ring_of_definition</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_of_definition</span> <span class=\"n\">A₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"o\">{</span> <span class=\"o\">((</span><span class=\"n\">to_units</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"bp\">⟩⟩</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"err\">&#39;&#39;</span> <span class=\"n\">A₀</span> <span class=\"err\">∪</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>This is saying: look at the subring generated by <code>A₀</code> and <code>E := {t_1/s, ..., t_n/s}</code> (where <code>{t_1, ..., t_n} := T</code>).</p>",
        "id": 160485626,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552316241
    },
    {
        "content": "<p>What is this <code>&lt;$&gt;</code>?</p>",
        "id": 160486195,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552316615
    },
    {
        "content": "<p>And <code>&lt;*&gt;</code>?</p>",
        "id": 160486202,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552316622
    },
    {
        "content": "<p>I don't know. I think it is called <code>seq</code></p>",
        "id": 160486209,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552316628
    },
    {
        "content": "<p><code>(*)</code> is just multiplication but as a prefix operator not infix, I _think_...</p>",
        "id": 160486274,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552316649
    },
    {
        "content": "<p>Part of the reason this is a mess is that we can't do things like <code>[t/s for t in T]</code> in a readable way, I guess.</p>",
        "id": 160486527,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552316827
    },
    {
        "content": "<p>That would be awesome</p>",
        "id": 160486553,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552316847
    },
    {
        "content": "<p>Can we do it in Lean 4?</p>",
        "id": 160486561,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552316856
    },
    {
        "content": "<p>We really want <code>[f(x) for x in X if pred(x)]</code> I guess</p>",
        "id": 160486578,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552316873
    },
    {
        "content": "<p>I've been saying this for ages: if the Lean 4 parser bring us python's list comprehension the nothing will ever be able to stop Lean</p>",
        "id": 160486581,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1552316876
    },
    {
        "content": "<p>But <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> knows it already</p>",
        "id": 160486665,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1552316906
    },
    {
        "content": "<p>Does he think it might be possible?</p>",
        "id": 160486688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552316926
    },
    {
        "content": "<p>He thinks everything will be possible with the Lean 4 parser, this is his Mission.</p>",
        "id": 160486713,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1552316945
    },
    {
        "content": "<p>Oh great :-)</p>",
        "id": 160486723,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552316958
    },
    {
        "content": "<p>I believe this is even his PhD thesis topic</p>",
        "id": 160486735,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1552316969
    },
    {
        "content": "<p>Oh even better!</p>",
        "id": 160486747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552316981
    },
    {
        "content": "<p>In the mean time we can use the unreadable way together with a good docstring displaying wht we mean</p>",
        "id": 160486838,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1552317026
    },
    {
        "content": "<p><code>ring.closure (of '' A_0 \\union {t/s for t in of '' T})</code> looks much better</p>",
        "id": 160486894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552317065
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"err\">∈</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">of</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"o\">((</span><span class=\"n\">to_units</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"bp\">⟩⟩</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"o\">(</span><span class=\"n\">away</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>This is probably defeq to the runes I casted above. And maybe slightly more readable. It's still a very awkard way of dividing by <code>s</code>.</p>",
        "id": 160487106,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552317218
    },
    {
        "content": "<p>Johan, I guess you could define <code>s_inv</code> in <code>away s</code> with another <code>let</code> and I guess you could define E to be the image of lam t, of t * s_inv<code>, and that would make it look a bit less insane. All this </code>&lt;$&gt; &lt;*&gt;` business is for multiplying general sets together, right? And one of your sets only has one element.</p>",
        "id": 160487167,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552317243
    },
    {
        "content": "<p>right.</p>",
        "id": 160487234,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552317308
    },
    {
        "content": "<p>Yes another alternative:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"err\">∈</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">localization</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">t</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"bp\">⟩</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 160487236,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552317308
    },
    {
        "content": "<p>One could define a new constructor <code>of_inv : S -&gt; R[1/S]</code> and hide it away. This would be better if R[1/S] was defined for an arbitrary set S as R[1/(monid generated by S)].</p>",
        "id": 160487641,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552317565
    },
    {
        "content": "<p>Currently we have the following definition in the perfectoid project:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">Huber_ring</span><span class=\"bp\">.</span><span class=\"n\">pair_of_definition</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">A₀</span>   <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">Hr</span>   <span class=\"o\">:</span> <span class=\"n\">is_subring</span> <span class=\"n\">A₀</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">Ho</span>   <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">A₀</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">J</span>    <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">A₀</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">fin</span>  <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">gen</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">gen</span><span class=\"o\">),</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">span</span> <span class=\"n\">gen</span> <span class=\"bp\">=</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">top</span>  <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">is_ideal_adic</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">comm_ring</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">topological_subring</span> <span class=\"n\">A₀</span><span class=\"o\">)</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>However, the first example (<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub><mo>⊂</mo><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p \\subset \\mathbb{Q}_p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.974998em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span><span class=\"mrel\">⊂</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span></span>) does not actually fit in this setup very well, because <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.974998em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span></span> is a subtype instead of a subset. So now I am considering to change the above definition, so that <code>A_0</code> is a type instead of a set, equipped with an injective continuous ring homomorphism to <code>A</code>.<br>\nOne issue with that approach is that we would have to choose a universe for <code>A_0</code>. But probably we could just put it in the same universe as <code>A</code>.<br>\nAre there other reasons why this approach might be a bad idea? Or is this the right way to go in DTT?</p>",
        "id": 160592985,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552413142
    },
    {
        "content": "<p>Won't it mean that every single one of those proofs you've been working on will get much messier because you'll constantly be having to apply some function from the small ring to the big one, moving subgroups of the small one to subgroups on the big one, open sets in the small one to open sets in the big one, and so on?</p>",
        "id": 160604331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552420618
    },
    {
        "content": "<p>And eventually you'll start to have cute little ideas such as \"I know, why don't I formulate this statement not about subsets of the small ring but subsets of the big ring, so I don't have to keep wasting my time pulling back\"</p>",
        "id": 160604489,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552420731
    },
    {
        "content": "<p>Hmmm... I guess that's true</p>",
        "id": 160604555,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552420766
    },
    {
        "content": "<p>Or \"I know, why don't I just have a predicate on the big ring to say I'm in the image of the small ring, to save me from having to pull back\"</p>",
        "id": 160604582,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552420792
    },
    {
        "content": "<p>And then you will be back where you started :-)</p>",
        "id": 160604670,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552420822
    },
    {
        "content": "<p>I have this vague recollection that Mario suggested not introducing new types as fields in a structure, but perhaps this was for universe issues</p>",
        "id": 160604771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552420915
    },
    {
        "content": "<p>What happens if we are in a situation where the universe doesn't match up anyway? What if the small ring turned out to be in a smaller universe for some reason?</p>",
        "id": 160604873,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552420973
    },
    {
        "content": "<p>I am not an expert but to me the set idea looks better.</p>",
        "id": 160604905,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552421003
    },
    {
        "content": "<p>Ok...</p>",
        "id": 160604948,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552421040
    },
    {
        "content": "<p>It's funny, I had the same kind of trouble earlier today (and I chose the function, not the set...)</p>",
        "id": 160604994,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1552421046
    },
    {
        "content": "<p>It does mean that we have to port lots of things back and forth between Z_p the subtype and Z_p the subset.</p>",
        "id": 160605020,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552421067
    },
    {
        "content": "<p>I think you are right. You should make A0 a type and pull it out of the structure</p>",
        "id": 160629358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552443704
    },
    {
        "content": "<blockquote>\n<p>Won't it mean that every single one of those proofs you've been working on will get much messier because you'll constantly be having to apply some function from the small ring to the big one, moving subgroups of the small one to subgroups on the big one, open sets in the small one to open sets in the big one, and so on?</p>\n</blockquote>\n<p>That function is already there even with sets. You want to talk about A0 as a ring so you needed <code>subset.ring</code>, which I'm guessing is why we had that diamond discussion yesterday. Here the ring structure is previously imposed, and you use <code>comap</code> to transfer stuff instead of <code>subtype.val</code></p>",
        "id": 160629439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552443824
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> It is true that there are a number of proofs that I currently close by <code>rfl</code> because two subsets are defeq. Those might become a bit more complicated.</p>",
        "id": 160641564,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552461922
    },
    {
        "content": "<p>why would it?</p>",
        "id": 160641569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552461938
    },
    {
        "content": "<p>Anyway, I guess I should just try a little experiment. <code>git</code> supports branches for a reason.</p>",
        "id": 160641570,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552461944
    },
    {
        "content": "<p>if the sets are defeq so would the types</p>",
        "id": 160641574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552461952
    },
    {
        "content": "<p>Aah, you are saying that the only difference is in making the function explicit?</p>",
        "id": 160641629,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552461995
    },
    {
        "content": "<p>yes</p>",
        "id": 160641633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552462002
    },
    {
        "content": "<p>in DTT there is always a function, this is just making it more general</p>",
        "id": 160641642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552462019
    },
    {
        "content": "<p>Once I'm in my office I'll try the experiment.</p>",
        "id": 160641644,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552462020
    },
    {
        "content": "<p>And about the universe? I guess we shouldn't generalise that, right?</p>",
        "id": 160641741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552462186
    },
    {
        "content": "<p>Just stick to the same universe as <code>A</code>?</p>",
        "id": 160641743,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552462196
    },
    {
        "content": "<p>If you use a subtype, then proving two subtypes are equal is the same as proving P iff Q, which is proving a Prop. If you used injective maps then you're going to run into the issue that the sources aren't equal only equiv. For me, subsets and subtypes are kind of the same modulo some pointy brackets, but injective maps sound like they'll be much harder to work with</p>",
        "id": 160641789,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552462211
    },
    {
        "content": "<p>I don't understand why there's now a universe question at all</p>",
        "id": 160641798,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552462242
    },
    {
        "content": "<p>The universe should be generalized if it gets pulled out of the type</p>",
        "id": 160642030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552462603
    },
    {
        "content": "<p>but Kevin has a point that general injective maps involve a property that wasn't needed in the subset situation</p>",
        "id": 160642049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552462643
    },
    {
        "content": "<p>I would need to impose 3 properties: that the map is injective, a ring hom, and an open embedding..</p>",
        "id": 160642137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552462712
    },
    {
        "content": "<p>Alternatively, would it make sense to turn <code>Z_[p]</code> into a subset? That also feels morally wrong. I guess this is just the pain of DTT. Just like <code>nat</code> is not a subset of <code>int</code> is not a subset of <code>rat</code> is not a ...</p>",
        "id": 160642230,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552462806
    },
    {
        "content": "<p>But it also feels wrong to duplicate every result about <code>Z_[p]</code> for the subset version...</p>",
        "id": 160642246,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552462855
    },
    {
        "content": "<p>I think it looks like this (doesn't typecheck on my computer of course):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">Huber_ring</span><span class=\"bp\">.</span><span class=\"n\">pair_of_definition</span>\n  <span class=\"o\">(</span><span class=\"n\">A₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">A₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"n\">A₀</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A₀</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inj</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Hr</span> <span class=\"o\">:</span> <span class=\"n\">is_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Ho</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">f</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">A₀</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">fin</span>  <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">gen</span><span class=\"o\">,</span> <span class=\"n\">finite</span> <span class=\"n\">gen</span> <span class=\"bp\">∧</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">span</span> <span class=\"n\">gen</span> <span class=\"bp\">=</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">top</span>  <span class=\"o\">:</span> <span class=\"n\">is_ideal_adic</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 160642364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552463041
    },
    {
        "content": "<p>Oh, you are right that you have to add the open embedding property. I think that implies injective</p>",
        "id": 160642441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552463140
    },
    {
        "content": "<p>minor technical remark: once we pull <code>A₀</code> out of the structure, I think we should call this <code>ring_of_definition</code>.<br>\nAnd now the definition of <code>Huber_ring</code> becomes something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">A₀</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">A₀</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"n\">A₀</span><span class=\"o\">],</span>\n  <span class=\"k\">by</span> <span class=\"n\">resetI</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">ring_of_definition</span> <span class=\"n\">A₀</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 160642751,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552463573
    },
    {
        "content": "<p>I don't really understand the naming, so no comment there</p>",
        "id": 160643202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552464155
    },
    {
        "content": "<p>to me \"ring of definition\" sounds like \"man of character\"</p>",
        "id": 160643230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552464184
    },
    {
        "content": "<p>Hahaha</p>",
        "id": 160643291,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552464240
    },
    {
        "content": "<p>Perfectoid...</p>",
        "id": 164383156,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556451831
    },
    {
        "content": "<p>Project...</p>",
        "id": 164383160,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556451837
    },
    {
        "content": "<p>... compiles!</p>",
        "id": 164383202,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556451845
    },
    {
        "content": "<p>(without warnings or errors <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span>)</p>",
        "id": 164383207,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556451872
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces\" target=\"_blank\" title=\"https://github.com/leanprover-community/lean-perfectoid-spaces\">https://github.com/leanprover-community/lean-perfectoid-spaces</a></p>",
        "id": 164383210,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556451882
    },
    {
        "content": "<p>Lean 3 is powerful enough to make perfectoid spaces.</p>",
        "id": 164383214,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556451897
    },
    {
        "content": "<p>There were times near the end when I was genuinely concerned about type class inference not being up to what we wanted it to do. But this weird changing of <code>Type*</code> to <code>Type u</code> suddenly made a problem go away, and it was all downhill from there.</p>",
        "id": 164383232,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556451958
    },
    {
        "content": "<p><a href=\"https://gitter.im/leanprover_public/Lobby?at=5a21de7271ad3f873655a82a\" target=\"_blank\" title=\"https://gitter.im/leanprover_public/Lobby?at=5a21de7271ad3f873655a82a\">https://gitter.im/leanprover_public/Lobby?at=5a21de7271ad3f873655a82a</a></p>",
        "id": 164383829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556452875
    },
    {
        "content": "<p>Now we have a lot of cleanup to do, and we would like to ask Travis to check each push. Does anyone has an example of a Lean project using mathlib that is Travis-checked?</p>",
        "id": 164383951,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556453049
    },
    {
        "content": "<p>Is this the main result?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">perfectoid_ring</span> <span class=\"n\">A</span><span class=\"o\">],</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"err\">𝒞</span><span class=\"bp\">.</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"err\">≅</span><span class=\"bp\">_</span><span class=\"err\">𝒞</span> <span class=\"o\">(</span><span class=\"n\">locally_ringed_valued_space</span><span class=\"bp\">.</span><span class=\"n\">to_</span><span class=\"err\">𝒞</span><span class=\"bp\">.</span><span class=\"n\">restrict</span> <span class=\"n\">U</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 164386450,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1556457054
    },
    {
        "content": "<p>Yes</p>",
        "id": 164386669,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556457395
    },
    {
        "content": "<p>The main result is that Lean understands this definition</p>",
        "id": 164386670,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556457414
    },
    {
        "content": "<p>Although it is most definitely clear that dependent type theory understands this definition, it was not always clear, near the end, that Lean 3 was powerful enough to handle it, at least with the code we were writing. As you'll be easily able to see from looking at the repo Kenny, some of it has been written with quite some care (indeed a lot of thought went into some of it), and other parts were just slapped down and called <code>r_o_d_completion.lean</code> because I knew we just needed a bunch of abstract stuff which was easy to write so I just splurged it out paying very little attention to things like good naming conventions. The repo still needs a lot of work before it is respectable.</p>",
        "id": 164386798,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556457634
    },
    {
        "content": "<p>This was the last file we wrote: <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/valuation/field.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/valuation/field.lean\">https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/valuation/field.lean</a></p>",
        "id": 164386953,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556457851
    },
    {
        "content": "<p>I had a very lackadaisical approach to planning.</p>",
        "id": 164386954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556457868
    },
    {
        "content": "<p>Patrick kept asking me to write proper roadmaps. I was really bad at this. I would just write a normal mathematical document.</p>",
        "id": 164386959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556457885
    },
    {
        "content": "<p>Patrick would extrapolate what I needed from the theory of topological rings and valuations (answer : loads and loads and loads of stuff that wasn't in mathlib but was in Bourbaki)</p>",
        "id": 164386979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556457920
    },
    {
        "content": "<p>and then make it and then ask me again for a roadmap and I'd be saying \"oh yeah, do have this random result about completions of topological rings which I never mentioned before and is another 10 pages of Bourbaki?\"</p>",
        "id": 164386989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556457956
    },
    {
        "content": "<p>And the final iteration, about three weeks ago, was when I said \"oh by the way did I mention that I need that a valuation on a field extends to a valuation on the completion of the field for the valuation topology? It's sort of obvious by continuity...\"</p>",
        "id": 164387055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556458039
    },
    {
        "content": "<p>and Patrick was like \"aargh you do realise that this is three more pages of Bourbaki why did you not mention this before\" (answer: because Kevin thought it would probably be obvious by continuity).</p>",
        "id": 164387104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556458086
    },
    {
        "content": "<p>and then it turns out that at some point Bourbaki go \"oh yeah, and this bit is obvious by continuity\" <em>rofl</em></p>",
        "id": 164387109,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556458114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> what is the reference for that bit? There was the valuation on the units of K extending to the units of the completion, and also another bit about cauchy filters which didn't tend to zero</p>",
        "id": 164387152,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556458202
    },
    {
        "content": "<p>I should publically apologise to Patrick for not ever making a good roadmap.</p>",
        "id": 164387199,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556458227
    },
    {
        "content": "<p>I found all the material straightforward modulo \"bits which looked easy but actually I'd never read the details of and thought would be fine\". It took me a long time to get to grips with the grim reality</p>",
        "id": 164387225,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556458286
    },
    {
        "content": "<p>Maths is hard.</p>",
        "id": 164387229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556458294
    },
    {
        "content": "<p>I kept thinking \"oh, and the rest is surely easy\" when it really was not easy.</p>",
        "id": 164387238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556458320
    },
    {
        "content": "<p>The reference is in Bourabaki <em>Algèbre commutative</em> Chapter VI, 5.3</p>",
        "id": 164387284,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556458326
    },
    {
        "content": "<p>Look at my ridiculous prediction from September 21st last year.</p>",
        "id": 164387290,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556458337
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> I'd be interest to see you formalise a proof of some of the statements in Bourbaki, even if you're allowed to assume that everything in Bourbaki up to that point had been formalised. Is it Ok to post a screenshot of material?</p>",
        "id": 164387342,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556458440
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/gy6dhYT0puNOs7MDeoX4zkyx/top_gen.png\" target=\"_blank\" title=\"top_gen.png\">top_gen.png</a> <br>\nExercise: elaborate a little on the phrase \"in other words...\".</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/gy6dhYT0puNOs7MDeoX4zkyx/top_gen.png\" target=\"_blank\" title=\"top_gen.png\"><img src=\"/user_uploads/3121/gy6dhYT0puNOs7MDeoX4zkyx/top_gen.png\"></a></div>",
        "id": 164396077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556469939
    },
    {
        "content": "<p>\"Autrement dit\"</p>",
        "id": 164396084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556469958
    },
    {
        "content": "<p>because Peter Scholze needs it and the proof is a little difficult to understand</p>",
        "id": 164396137,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556469993
    },
    {
        "content": "<p>It's not so difficult, but it's 100% left to the reader</p>",
        "id": 164396161,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556470057
    },
    {
        "content": "<p>Patrick you are an expert.</p>",
        "id": 164396166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556470081
    },
    {
        "content": "<p>How can a computer read this tripe?</p>",
        "id": 164396220,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556470120
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/HB3qTsgF7xxu26ZYK1tTZFwC/alg_comm.png\" target=\"_blank\" title=\"alg_comm.png\">alg_comm.png</a> <br>\nThis is what Scholze needs (in fact what Huber needs to make his adic spaces, of which Scholze's perfectoid spaces are examples). Bourbaki's proof (this is Algèbre commutative Chapter VI, 5.3) uses this geometric topology result <em>and</em> another assertion about how a completion is continuous at 0 which is surprisingly delicate and is brushed under the carpet completely. Patrick has already put in an appropriate complaint with the relevant authorities.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/HB3qTsgF7xxu26ZYK1tTZFwC/alg_comm.png\" target=\"_blank\" title=\"alg_comm.png\"><img src=\"/user_uploads/3121/HB3qTsgF7xxu26ZYK1tTZFwC/alg_comm.png\"></a></div>",
        "id": 164396546,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556470636
    },
    {
        "content": "<p>We now understand two proofs of that assertion b)</p>",
        "id": 164396599,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556470695
    },
    {
        "content": "<p>I figured out one proof, and after discussion with three collaborators or former collaborators of Bourbaki, I now have a second one</p>",
        "id": 164396608,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556470737
    },
    {
        "content": "<p>Will you tell?</p>",
        "id": 164396623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556470756
    },
    {
        "content": "<p>We used the one that Brian Conrad sketched to us, right?</p>",
        "id": 164396626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556470770
    },
    {
        "content": "<p>Yes, the one we use was figured out after Conrad's hint</p>",
        "id": 164396692,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556470821
    },
    {
        "content": "<p>although it has to be in a more general context</p>",
        "id": 164396697,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556470845
    },
    {
        "content": "<p>I have a couple of questions regarding your experience formalizing this. Was there one particular paper/document you were following? Or was it bits and pieces of maths picked up from different sources? (Sorry if this was addressed before)</p>",
        "id": 164396784,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1556471011
    },
    {
        "content": "<p>And secondly, do you think it would have been helpful if you started out with a formal blueprint from the outset? By a formal blueprint I mean a document which would contain every detail necessary in order to state the main result.</p>",
        "id": 164396854,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1556471125
    },
    {
        "content": "<p>I am a pure mathematician and an expert in this area, so I knew where to look; I have a paper with Verberkmoes which has some results about perfectoid spaces and so I learnt the theory from a number of sources. However the majority of the relevant material was in some unpublished notes of Torsten Wedhorn</p>",
        "id": 164396862,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556471132
    },
    {
        "content": "<p>It would have been a huge help to have a blue-print. But Kevin thought he understood enough of the maths to skip that step.</p>",
        "id": 164396919,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556471194
    },
    {
        "content": "<p>I had a very naive idea of what constituted a formal blueprint. It took me a long time to understand that my answer to Patrick -- \"Wedhorn\" -- was not satisfactory.</p>",
        "id": 164397001,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556471290
    },
    {
        "content": "<p>I had no idea there would be so much involved. All of the stuff about primary and secondary valuations -- it's all over the place! Do we actually need to formalise that chapter? Let's not. Then oh dear, we can't prove this fundamental thing. Then oh dear, we can't define the presheaf on Spa(A) and that means we can't define perfectoid spaces.</p>",
        "id": 164397030,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556471358
    },
    {
        "content": "<p>I thought it was more fun to forge ahead excitedly a bit like Tigger.</p>",
        "id": 164397088,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556471405
    },
    {
        "content": "<p>But sometimes we had to take a big step back and make something properly.</p>",
        "id": 164397095,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556471437
    },
    {
        "content": "<p>OK. This is reassuring. I wanted to know if it was a good idea to make this a norm: all future formalizations should come with a blueprint which parallels the formal proof. The blueprint would consist of <em>preformal</em> and <em>informal</em> text pieces. The preformal parts would be linked to the formal code and the informal text would just be helper text which would make it easier for a reader to follow along.</p>",
        "id": 164397111,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1556471481
    },
    {
        "content": "<p>All this happened randomly during the project and never really stopped happening until the end -- in some sense I never finished the roadmap until a couple of weeks ago.</p>",
        "id": 164397117,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556471506
    },
    {
        "content": "<p>It was only a couple of weeks ago that I realised that I could see the light at the end of the tunnel -- we seemed to have clear references or paper proofs for everything left.</p>",
        "id": 164397163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556471540
    },
    {
        "content": "<p>Maybe with a roadmap at the start you can already see the light, it's piercing bright but a very long way away</p>",
        "id": 164397170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556471574
    },
    {
        "content": "<p>Kevin says I'm allowed to write I find it very interesting that he had no idea about what was involved in the foundational part. I'm pretty we can find this in any advanced topic in math. You can use the objects and not even know how much is involved in foundations. Hopefully this is already not a problem. But with proof assistant we could get rid of wishful thinking, and simply say the computer checked that our story is 100% compatible with the foundations.</p>",
        "id": 164397315,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556471773
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> what is it with the sudden italics in your picture?</p>",
        "id": 164397646,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1556472351
    },
    {
        "content": "<p>what sudden italic?</p>",
        "id": 164398200,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556473083
    },
    {
        "content": "<p>in the exercise he gave me</p>",
        "id": 164398419,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1556473476
    },
    {
        "content": "<blockquote>\n<p>Pour que <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>K</mi></mrow><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat{K}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.9467699999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.9467699999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9467699999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span></span></span><span style=\"top:-3.25233em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"margin-left:0.11112em;\"><span>^</span></span></span></span></span></span></span></span></span></span> soit un <em>corps topologique</em>, il faut qu'on puisse <em>prolonger par continuité</em> ...</p>\n</blockquote>",
        "id": 164398437,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1556473526
    },
    {
        "content": "<p>That's simply emphasis</p>",
        "id": 164398601,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556473801
    },
    {
        "content": "<p>Cool! So <code>perfectoid_space X</code> is a type, right? Do you have any examples of closed terms with type <code>perfectoid_space X</code> for some X?</p>",
        "id": 164399827,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1556475420
    },
    {
        "content": "<p>The empty type should be ok for X</p>",
        "id": 164399840,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556475454
    },
    {
        "content": "<p>We should check this actually</p>",
        "id": 164399845,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556475471
    },
    {
        "content": "<p>Any other example is currently way beyond reach</p>",
        "id": 164399889,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556475489
    },
    {
        "content": "<p>I see.</p>",
        "id": 164399915,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1556475557
    },
    {
        "content": "<p>To construct the first non-trivial example, we need to consider the completion of the algebraic closure of <code>Q_p</code>... (and this example is mathematically very very trivial).</p>",
        "id": 164401309,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556477641
    },
    {
        "content": "<p>We don't have algebraic closures atm...</p>",
        "id": 164401355,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556477657
    },
    {
        "content": "<p>But even if we have them... to check that we actually get an example is still a lot of work.</p>",
        "id": 164401390,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556477714
    },
    {
        "content": "<p>This algebraic closure thing is really becoming ridiculous</p>",
        "id": 164401406,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556477738
    },
    {
        "content": "<p>Kevin, what are your students doing?</p>",
        "id": 164401416,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556477755
    },
    {
        "content": "<p>Revising...</p>",
        "id": 164401420,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556477761
    },
    {
        "content": "<p>To be fair, I think <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> is almost done with alg.closure</p>",
        "id": 164401468,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556477777
    },
    {
        "content": "<p>It'll probably get done a few days after May 24.</p>",
        "id": 164401775,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1556478142
    },
    {
        "content": "<p>Is that the end of your exams?</p>",
        "id": 164401779,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556478155
    },
    {
        "content": "<p>Yes</p>",
        "id": 164401878,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1556478250
    },
    {
        "content": "<p>Will you keep that beard after exams? Or is it only your exam preparation style?</p>",
        "id": 164402055,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556478506
    },
    {
        "content": "<p>I shave once every couple of months, so it will probably be time for a shave by then.</p>",
        "id": 164402479,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1556479145
    },
    {
        "content": "<blockquote>\n<p>I shave once every couple of months, so it will probably be time for a shave by then.</p>\n</blockquote>\n<p>What a waste of time...</p>",
        "id": 164402557,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556479283
    },
    {
        "content": "<blockquote>\n<p>Kevin says I'm allowed to write I find it very interesting that he had no idea about what was involved in the foundational part. I'm pretty we can find this in any advanced topic in math. You can use the objects and not even know how much is involved in foundations. Hopefully this is already not a problem. But with proof assistant we could get rid of wishful thinking, and simply say the computer checked that our story is 100% compatible with the foundations.</p>\n</blockquote>\n<p>I had accepted plenty of things in the theory as a \"black box\". For example the theory of completions of topological rings just looked like some standard straightforward thing, and plenty of other things just looked like analogues of things I'd seen in the schemes project; some turned out to be very subtle. For example in a scheme if s is non-zero on U then s is a unit in O_X(U). The analogous statement is much deeper for perfectoid spaces, because given a random maximal ideal it's not so clear you can write down a continuous valuation with that ideal equal to the support. It was only after the project had begun that I learnt this subtlety.</p>",
        "id": 164404705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556482261
    },
    {
        "content": "<p>OK if any CS person fancies installing the perfectoid project (which can be done by</p>\n<div class=\"codehilite\"><pre><span></span>git clone https://github.com/leanprover-community/lean-perfectoid-spaces\ncd lean-perfectoid-spaces\nleanpkg configure\nupdate-mathlib\nleanpkg build\n</pre></div>\n\n\n<p>and waiting for a few minutes) then they might want to comment on the following things:</p>\n<p>1) At <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/161295f4fb35520bc662eb5722ef06c1ce9ce38c/src/valuation/field.lean#L693\" target=\"_blank\" title=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/161295f4fb35520bc662eb5722ef06c1ce9ce38c/src/valuation/field.lean#L693\">line 693 of <code>valuation/field.lean</code></a> we see a lemma which takes Lean to the limit. After the <code>convert is_closed_union</code> I have to prove that two sets are open. The first is on line 702 and it's a one-liner. The analogous one-liner for the second proof doesn't work; Lean deterministically times out. We just get away with it -- I break up the second one-liner into three lines and throw in a bunch of <code>by apply_instance</code>s and it always takes ages to compile -- change a character in the proof and then change it back and watch the struggle. Put the three lines back into one line and watch the timeout.</p>\n<p>2) The very last definition in the same file -- <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/161295f4fb35520bc662eb5722ef06c1ce9ce38c/src/valuation/field.lean#L878\" target=\"_blank\" title=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/161295f4fb35520bc662eb5722ef06c1ce9ce38c/src/valuation/field.lean#L878\"><code>valuation_on_completion</code></a>. This was the last file we wrote, and it was gluing one large body of work to another. Change <code>Type u</code> to <code>Type*</code> and observe a very scary deterministic time-out which we had no idea how to get rid of for days and days. It was a miracle that <code>Type*</code> got changed to <code>Type u</code> when I was attempting to do something else; the problem immediately goes away. What is going on?</p>",
        "id": 164405802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556483814
    },
    {
        "content": "<p>Following the philosophy of \"formalizing trendy concepts that interests mathematicians\", is prismatic cohomology (<a href=\"https://terrytao.wordpress.com/2019/03/19/prismatic-cohomology/\" target=\"_blank\" title=\"https://terrytao.wordpress.com/2019/03/19/prismatic-cohomology/\">https://terrytao.wordpress.com/2019/03/19/prismatic-cohomology/</a>) the next goal? <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 164426287,
        "sender_full_name": "Adrian Chu",
        "timestamp": 1556516085
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"218709\">@Adrian Chu</span> It seems like a very nice project for a beginner (-; Why don't you try it?</p>",
        "id": 164429576,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556520933
    },
    {
        "content": "<p>Joking aside: My next goal is helping to get schemes in mathlib, and the definition of étale cohomology.<br>\nIf we were to do anything with perfectoid spaces, I guess stating the tilting theorem would be a natural follow-up goal.</p>",
        "id": 164429655,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556521029
    },
    {
        "content": "<p>My instinct with cohomology is that we should start with something simpler like ext and tor before doing any fancy cohomology theories. I started with schemes before doing perfectoid spaces. We don't even have group cohomology yet</p>",
        "id": 164430476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556522265
    },
    {
        "content": "<p>de Rham cohomology is obviously important, but the analysis is also obviously not ready</p>",
        "id": 164430738,
        "sender_full_name": "Adrian Chu",
        "timestamp": 1556522550
    },
    {
        "content": "<p>de Rham, singular, simplicial are all crucial. Etale can come later although actually we are probably closer to etale then de Rham because it's more algebraic. Etale cohomology is a generalisation of group cohomology which is just Ext and Tor for group algebras, so I think this is the place to start. Note that non-commutative ring theory is far less developed than the commutative side of things in Lean. I'm not even sure we have left and right modules, or even left and right ideals.</p>",
        "id": 164431540,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556523579
    },
    {
        "content": "<p>Indeed doing non-commutative ideals is much more urgent and accessible than fancy cohomology...</p>",
        "id": 164433197,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556525738
    },
    {
        "content": "<p>Quiz: How many universe parameters does <code>adic_space</code> depend on?</p>",
        "id": 164535706,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556628673
    },
    {
        "content": "<p>3?!</p>",
        "id": 164536309,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556629184
    },
    {
        "content": "<p>It should be 1</p>",
        "id": 164536524,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556629308
    },
    {
        "content": "<p>in my not so humble opinion</p>",
        "id": 164536531,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556629317
    },
    {
        "content": "<p>I am sick of this universe lie</p>",
        "id": 164536579,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556629323
    },
    {
        "content": "<p>Why can't it all live in <code>universe u</code> like all of maths does?</p>",
        "id": 164536611,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556629357
    },
    {
        "content": "<p>It's a part of maths, it's not going to be used by any program verification people</p>",
        "id": 164536836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556629519
    },
    {
        "content": "<p>Russell's paradox arose and two schools of response emerged. I don't see how the mathematicians' response is superior to the computer scientists' response</p>",
        "id": 164536888,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1556629562
    },
    {
        "content": "<p>The mathematician's response is easier to implement</p>",
        "id": 164536993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556629616
    },
    {
        "content": "<p>We don't get issues like someone who knows analysis like the back of their hand and is an Isabelle expert being unable to define n-times differentiable functions in Lean</p>",
        "id": 164537043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556629653
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/topic/Multiple.20differentiability\" title=\"#narrow/stream/116395-maths/topic/Multiple.20differentiability\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Multiple.20differentiability</a></p>",
        "id": 164537069,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556629674
    },
    {
        "content": "<p>for reasons utterly unrelated to why we need universes anyway</p>",
        "id": 164537125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556629690
    },
    {
        "content": "<p>Today we merged a clean up of some of the top level parts of the perfectoid project. We want <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/perfectoid_space.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/perfectoid_space.lean\">https://github.com/leanprover-community/lean-perfectoid-spaces/blob/master/src/perfectoid_space.lean</a> (31 lines) to look as nice as possible. If you have any feedback, please let us know. All comments are welcome. (<span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"115334\">@Thales</span>)</p>",
        "id": 164815301,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1556906082
    },
    {
        "content": "<p>If PerfectoidSpace is really a category then maybe you should add a category instance</p>",
        "id": 164815935,
        "sender_full_name": "Reid Barton",
        "timestamp": 1556906516
    },
    {
        "content": "<p>I came across <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s MO answer about perfectoid spaces (<a href=\"https://mathoverflow.net/a/307239\" target=\"_blank\" title=\"https://mathoverflow.net/a/307239\">https://mathoverflow.net/a/307239</a>) again, perhaps time to update it?</p>",
        "id": 165422324,
        "sender_full_name": "Reid Barton",
        "timestamp": 1557597807
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> my impression was that you wanted me to hold off from writing a blog post about the fact that the code now compiles. Are you now happy for me to do this? I know that Patrick and Johan wanted to make the definition look as nice as possible (and we had some chat about this) and to make a nice project page (and <a href=\"https://leanprover-community.github.io/lean-perfectoid-spaces/\" target=\"_blank\" title=\"https://leanprover-community.github.io/lean-perfectoid-spaces/\">we now have this</a> with a funky GePhi graph and everything!</p>",
        "id": 165422408,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557597936
    },
    {
        "content": "<p>I'd be happy to hear input about how to update the post as well...hmm... I should definitely update the quote from the source code, and this will involve editing my post (rather than just adding a comment) and so I may as well just completely edit the answer -- I am not sure there's any point attempting to keep the history intact with {\\bf UPDATE May 2019} and strikethroughs.</p>",
        "id": 165422530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557598114
    },
    {
        "content": "<p>We have done quite some polishing. Of course the project isn't finished yet. But at least we now have an explanation that should guide mathematicians through the top level file.</p>",
        "id": 165422767,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557598507
    },
    {
        "content": "<p>I suggest that you link directly to the explanation page instead of (or before) linking to the landing page.</p>",
        "id": 165422774,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557598536
    },
    {
        "content": "<p>I think you can blog about it. I don't understand why Johan wants to link directly to a technical page. Also the landing page has more credits</p>",
        "id": 165425669,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1557603118
    },
    {
        "content": "<p>What is the explanation page and what is the landing page?</p>",
        "id": 165425742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557603197
    },
    {
        "content": "<p>I think he means <a href=\"https://leanprover-community.github.io/lean-perfectoid-spaces/\" target=\"_blank\" title=\"https://leanprover-community.github.io/lean-perfectoid-spaces/\">https://leanprover-community.github.io/lean-perfectoid-spaces/</a> and <a href=\"https://leanprover-community.github.io/lean-perfectoid-spaces/how-to-read-lean.html\" target=\"_blank\" title=\"https://leanprover-community.github.io/lean-perfectoid-spaces/how-to-read-lean.html\">https://leanprover-community.github.io/lean-perfectoid-spaces/how-to-read-lean.html</a></p>",
        "id": 165425759,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1557603232
    },
    {
        "content": "<p>I was planning on linking to the first one.</p>",
        "id": 165425811,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557603267
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 165425817,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1557603288
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 165425822,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1557603296
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 165425843,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1557603330
    },
    {
        "content": "<p><a href=\"http://wwwf.imperial.ac.uk/~buzzard/docs/Junior_Number_Theory_Seminar_09_05_2019.mp4\" target=\"_blank\" title=\"http://wwwf.imperial.ac.uk/~buzzard/docs/Junior_Number_Theory_Seminar_09_05_2019.mp4\">http://wwwf.imperial.ac.uk/~buzzard/docs/Junior_Number_Theory_Seminar_09_05_2019.mp4</a></p>",
        "id": 165791559,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557997112
    },
    {
        "content": "<p>There's a talk I gave to the London number theory PhD students about the project. The last 30 seconds is missing but it's just an advert for the Xena meetings on Thursday evenings.</p>",
        "id": 165791601,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557997153
    },
    {
        "content": "<p>It's an hour long and for some reason the download is huge (250M!)</p>",
        "id": 165791626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557997192
    },
    {
        "content": "<p>It's just what I was given :-/</p>",
        "id": 165791685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557997206
    },
    {
        "content": "<p>It's not really about perfectoid spaces, it's my usual rant about maths being full of holes and a brief introduction to type theory and a vague explanation of why I think FABSTRACTS is a really good idea.</p>",
        "id": 165791743,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557997280
    },
    {
        "content": "<p><a href=\"http://YouTube.Com/upload\" target=\"_blank\" title=\"http://YouTube.Com/upload\">Upload it to YouTube... </a></p>",
        "id": 165793251,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1557998719
    },
    {
        "content": "<p>250M is actually too small for a decent recording of an hour long talk...</p>",
        "id": 165793282,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1557998752
    },
    {
        "content": "<p>I might not own the copyright! I'll enquire.</p>",
        "id": 165805324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558010218
    },
    {
        "content": "<p>Very nice talk! It was very interesting to hear a mathematician's perspective on theorem proving. I didn't know you stopped \"ordinary\" research altogether and spent all your research time on Lean.</p>",
        "id": 165870662,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1558065933
    },
    {
        "content": "<p>I also don't know how dangerous this is... from a PR point of view.</p>",
        "id": 165870868,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1558066209
    },
    {
        "content": "<p>The mathematical community agrees that Voevodsky \"stopped doing maths\", and now Kevin \"stopped doing maths\". And they might just shrug their shoulders.</p>",
        "id": 165870885,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1558066255
    },
    {
        "content": "<p>I don't mean that Kevin should start doing \"ordinary\" research again. But it might be worthwile to point out that some people (try) to combine the two.</p>",
        "id": 165870905,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1558066317
    },
    {
        "content": "<p>My area has changed dramatically over the last few years, and my usual approach of \"read all the foundational papers so you understand the basics of what is going on\" began to stop working -- I couldn't keep up. I felt uncomfortable building on results which I did not understand. Everybody wants to use Scholze's results but they rely on so much. I just panicked a bit, I guess. More and more, people in my area are relying on results which haven't been written up, or haven't been refereed, or whatever. I have some sort of moral objection to this, but many do not share it.</p>\n<p>Another issue is that if you stay at the same institution for 20 years then you end up on a lot of committees; I am now involved with PhD admissions, outreach, teaching big undergraduate classes, supervising PhD students, and redesigning our entire curriculum. If I start telling people \"don't expect any number theory papers from me for a while\" then this actually takes the pressure off me a bit and frees me up to think more about how to use Lean both as a research and a teaching tool. To be absolutely frank I would like to formalise some of the number theory stuff which I did a few years ago, not least because this will drive mathlib development more towards areas which maths researchers are interested in. I have said it before and I'll say it again -- I think the big mistake that all the other provers have made is that they have done a very poor job of marketing themselves to active research mathematicians. Projects like the odd order project prove beyond all doubt that these tools are ready for modern mathematics -- so now let's actually do some, or at least attempt to do something in this area. </p>\n<p>My <a href=\"https://arxiv.org/abs/1009.0785\" target=\"_blank\" title=\"https://arxiv.org/abs/1009.0785\">paper with Toby Gee on the connections between automorphic representations and Galois representations</a> has as its main \"result\" a rigorous <em>conjecture</em> formalising part of the Langlands philosophy as an actual concrete question which has a meaning (in the sense that one could formalise the conjecture in Lean, and get a Fields Medal for proving it). At the other extreme there are extremely vague guiding principles such as \"the set of all isomorphism classes of all automorphic representations for GL_n over a global field for all n at once should somehow have the structure of a Tannakian category\". I think that there should be a market for actually deciding what the question is. It's called \"the Langlands philosophy\" for a good reason -- parts of it involve conjecturing the existence of data. Way before I knew about Lean I was already concerned about this -- see <a href=\"https://mathoverflow.net/questions/14763/what-are-the-local-langlands-conjectures-nowadays-for-connected-reductive-group\" target=\"_blank\" title=\"https://mathoverflow.net/questions/14763/what-are-the-local-langlands-conjectures-nowadays-for-connected-reductive-group\">this MO question for example</a>. Note my use of the word \"canonical\" in the question. I have a love-hate relationship with this word. </p>\n<p>I think that there is plenty of mathematics which mathematicians \"kind-of know\" but where we're a bit vague on the details. I feel like putting my research efforts into figuring out stuff like this -- \"what <em>is</em> the Langlands philosophy?\" -- will be far more productive and interesting than my just desperately trying to keep up with the constant stream of perfectoid papers appearing in ArXiv. I trust my PhD students to generate perfectoid papers; four now have tenure and I am confident that this number will rise. I now think that I have something new to offer to the community. I cannot see the point of turning into a second rate researcher in perfectoid spaces. I absolutely can see the point of trying to figure out how to get mathematicians to engage with theorem provers by setting an example; I have invested 18 months of my life in trying to figure out how they work and it's now time to teach my community. This seems to me to be much more important than generating more theorems. Whether it's further development of the perfectoid project, or a forthcoming Langlands philosophy project which may or may not ever happen, or the idea of integrating formal theorem provers in undergraduate curriculums, or something else, which finally makes real mathematicians sit up and take notice, only time will tell. But ultimately I had a lot of fun being an expert in some fashionable area of number theory, and now I feel like I am less of an expert but I have spawned several other experts, and it's time I went off and became an expert in something else.</p>",
        "id": 165973398,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558183386
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span></p>",
        "id": 165973399,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1558183398
    },
    {
        "content": "<p>Thanks for writing that up. It's very interesting.</p>",
        "id": 165982164,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1558198530
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">PerfectoidSpace</span> <span class=\"bp\">⟨</span><span class=\"mi\">37</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">norm_num</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">empty_CLVRS</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨⟩⟩</span>\n</pre></div>\n\n\n<p>First ever example of a perfectoid space, and thanks to Rob for reminding me of the <code>rintro ⟨⟩</code> trick. </p>\n<p>PS uses sorry. Does that matter? Only for props.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">empty_CLVRS</span> <span class=\"o\">:</span> <span class=\"n\">CLVRS</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">space</span> <span class=\"o\">:=</span> <span class=\"n\">empty</span><span class=\"o\">,</span>\n  <span class=\"n\">top</span> <span class=\"o\">:=</span> <span class=\"err\">⊤</span><span class=\"o\">,</span>\n  <span class=\"n\">sheaf</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n  <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"o\">(),</span>\n  <span class=\"n\">Hid</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">Hcomp</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">Fring</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">punit</span><span class=\"bp\">.</span><span class=\"n\">comm_ring</span><span class=\"o\">,</span>\n  <span class=\"n\">res_is_ring_hom</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">Ftop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">Ftop_ring</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">res_continuous</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"n\">locality</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">gluing</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">homeo</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">complete</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">},</span>\n  <span class=\"n\">valuation</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">local_stalks</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">supp_maximal</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨⟩</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 170591393,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562803985
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/examples/src/perfectoid_space_examples.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/examples/src/perfectoid_space_examples.lean\">https://github.com/leanprover-community/lean-perfectoid-spaces/blob/examples/src/perfectoid_space_examples.lean</a></p>",
        "id": 170591489,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562804079
    },
    {
        "content": "<p>One sorry left but I need to sleep</p>",
        "id": 170594105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562807752
    },
    {
        "content": "<p>What does the 37 signify?</p>",
        "id": 170594411,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1562808171
    },
    {
        "content": "<p>I think it's just Kevin's favorite number</p>",
        "id": 170594638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562808489
    },
    {
        "content": "<p>The use of bad indentation is sneaky</p>",
        "id": 170594641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562808509
    },
    {
        "content": "<p>perfectoid spaces are parametrized by a prime number, such as kevin's favorite number</p>",
        "id": 170594719,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1562808608
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I can now give you an infinite number of other examples! (Alas, none of them are examples for <code>p = 37</code>...)</p>",
        "id": 170600928,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562819347
    },
    {
        "content": "<p>The example now compiles!</p>\n<p><a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/476a0026256fc20196c08bfcf3c9af20ea6def06/src/perfectoid_space_examples.lean#L91\" target=\"_blank\" title=\"https://github.com/leanprover-community/lean-perfectoid-spaces/blob/476a0026256fc20196c08bfcf3c9af20ea6def06/src/perfectoid_space_examples.lean#L91\">https://github.com/leanprover-community/lean-perfectoid-spaces/blob/476a0026256fc20196c08bfcf3c9af20ea6def06/src/perfectoid_space_examples.lean#L91</a></p>\n<p>The first example of a formalised perfectoid space. The hard part was proving that the map coming from the sheaf axiom was a homeomorphism. This boiled down to proving that the map from the commutative ring <code>unit</code> to some projective limit of <code>unit</code>s was an open map. I needed <code>prop.decidable</code> to show that the only subsets of <code>unit</code> were <code>empty</code> and <code>univ</code>.</p>",
        "id": 170629377,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562849534
    },
    {
        "content": "<p>What!! Your example is not constructive!??</p>",
        "id": 170630137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562850104
    },
    {
        "content": "<p>So we need to go back to the drawing board.</p>",
        "id": 170630149,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562850118
    },
    {
        "content": "<p>Why?</p>",
        "id": 170630194,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562850124
    },
    {
        "content": "<p>joking</p>",
        "id": 170630202,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562850128
    },
    {
        "content": "<p>Oh great :-)</p>",
        "id": 170630212,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562850134
    },
    {
        "content": "<p>/me is trying to imitate Kenny</p>",
        "id": 170630231,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562850145
    },
    {
        "content": "<p>/me is flattered</p>",
        "id": 170630265,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1562850169
    },
    {
        "content": "<p>within the last 5 minutes he sent me a message complaining about how it was difficult to make Kaehler differentials for a ring map R -&gt; A because he needed decidable equality on A to make the auxiliary free A-module used in the construction.</p>",
        "id": 170630318,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562850203
    },
    {
        "content": "<p>I already have enough trouble with him, don't you start too ;-)</p>",
        "id": 170630353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562850225
    },
    {
        "content": "<p>The problem is that he isn't joking, whereas I am...</p>",
        "id": 170631189,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562850798
    },
    {
        "content": "<p>but... it is constructive</p>",
        "id": 170631297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562850882
    },
    {
        "content": "<p>hey yeah, so it is:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">PerfectoidSpace</span> <span class=\"bp\">⟨</span><span class=\"mi\">37</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">norm_num</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">empty_CLVRS</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨⟩⟩</span>\n</pre></div>\n\n\n<p>No <code>noncomputable</code> in sight! [except in a proof or two...]</p>",
        "id": 170631513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562851041
    },
    {
        "content": "<p>What is the <code>rintro ⟨⟩</code> trick?</p>",
        "id": 170650350,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1562863618
    },
    {
        "content": "<p>it's an empty cases</p>",
        "id": 170650394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562863649
    },
    {
        "content": "<p>it's the tactic version of <code>def foo : empty -&gt; A.</code></p>",
        "id": 170650428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562863679
    },
    {
        "content": "<p>Ah, cool. Nice trick.</p>",
        "id": 170650513,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1562863731
    },
    {
        "content": "<p>It would be nice if we could just write <code>λ ⟨⟩</code> to do this in term mode</p>",
        "id": 170650575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562863793
    }
]
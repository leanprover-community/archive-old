[
    {
        "content": "<p>Here is a toy example for an issue I am hitting while constructing the vector bundle of continuous linear maps, cc <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.vector_bundle.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">defs</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n<span class=\"kn\">include</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fibrewise_clm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">E₁</span> <span class=\"n\">x</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">E₂</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">fibrewise_clm</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">linear_map.add_comm_monoid</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">fibrewise_clm</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">defs</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">fibrewise_clm</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">--fails</span>\n</code></pre></div>",
        "id": 275170610,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647199536
    },
    {
        "content": "<p>I think this is the fairly-common issue of typeclass inference with pi-types?  An instance <code>Π x, add_comm_monoid (fibrewise_clm F₁ F₂ E₁ E₂ σ x)</code> can't be picked up if some kind of typeclass inference (here from <code>normed_field</code> to <code>comm_semiring</code>) is needed separately on each fibre.</p>",
        "id": 275170685,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647199614
    },
    {
        "content": "<p>I have work-in-progress for one workaround at <a href=\"https://github.com/leanprover-community/mathlib/tree/vb-hom-2\">branch#vb-hom-2</a> : to defer for as long as possible working over a <code>normed_field</code>, which here requires assuming the additional data of a topology on <code>F₁ →SL[σ] F₂</code> (which will presumably require a bunch of Prop hypotheses to complete the construction).  This seems more elegant, but it's possible that it's kicking the can down the road (eventually the construction will need to be applied over a normed field).</p>",
        "id": 275170881,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647199871
    },
    {
        "content": "<p>And here is a second workaround, at <a href=\"https://github.com/leanprover-community/mathlib/tree/vb-hom\">branch#vb-hom</a>, where I require for the type synonym that the rings already be normed fields.  Less elegant in my opinion, but perhaps less likely to fail down the road?</p>",
        "id": 275171232,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647200340
    },
    {
        "content": "<p>This is pretty frustrating because the correct instance is the third thing it tries. If you name that instance <code>good</code>  (the only instance in Heather's code) then the failing search trace first tries two instances from the local contact and then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">good</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_3</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_4</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_5</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_6</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_7</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_8</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_9</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_10</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_11</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_12</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_13</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_14</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x_15</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"n\">failed</span> <span class=\"n\">is_def_eq</span>\n</code></pre></div>",
        "id": 275174262,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647204581
    },
    {
        "content": "<p>Whereas replacing <code>by apply_instance</code> with <code>@good _ _ _ _ _ _ _ _ _ _ _ _</code> works</p>",
        "id": 275174307,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647204609
    },
    {
        "content": "<p>I heard a rumour that these typeclass-inference-with-pi-types issues are fixed in Lean 4?</p>",
        "id": 275174330,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647204667
    },
    {
        "content": "<p>For the record, the solution to this search is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">good</span> <span class=\"n\">B</span> <span class=\"n\">R</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"n\">E₁</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">_inst_1</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">E₂</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">_inst_2</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_comm_semiring</span> <span class=\"n\">R</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">semi_normed_comm_ring.to_comm_ring</span> <span class=\"n\">R</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">normed_comm_ring.to_semi_normed_comm_ring</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">normed_field.to_normed_comm_ring</span> <span class=\"n\">R</span> <span class=\"n\">_inst_3</span><span class=\"o\">))))</span>\n    <span class=\"n\">σ</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">_inst_4</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">_inst_5</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 275174343,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647204714
    },
    {
        "content": "<p>Note that <code>@good _ _ _ _ _ (by apply_instance) _ (by apply_instance) _ _ _ _</code> also fails.</p>",
        "id": 275174470,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647204853
    },
    {
        "content": "<p>Here's an earlier commit of one of those branches, in which I \"do typeclass inference by hand\" over and over again ...<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/a20b9ddaf58eb95e1fd06b59028f53d4def16206/src/topology/vector_bundle/hom.lean\">https://github.com/leanprover-community/mathlib/blob/a20b9ddaf58eb95e1fd06b59028f53d4def16206/src/topology/vector_bundle/hom.lean</a></p>",
        "id": 275174487,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647204884
    },
    {
        "content": "<p>and it fails with saying <code>tactic.mk_instance failed to generate instance for   Π (x : ?m_1), add_comm_monoid (?m_2 x)</code> where <code>E₁</code> (or <code>E₂</code>) is not guessed</p>",
        "id": 275174489,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647204897
    },
    {
        "content": "<p>The workaround at  <a href=\"https://github.com/leanprover-community/mathlib/tree/vb-hom\">branch#vb-hom</a> seems good to me.</p>",
        "id": 275174607,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647205068
    },
    {
        "content": "<p>Hopefully we won't need topological module bundle over non field rings before Lean 4 fixes this type class issue.</p>",
        "id": 275174663,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647205098
    },
    {
        "content": "<p>I like the other one (at <a href=\"https://github.com/leanprover-community/mathlib/tree/vb-hom-2\">branch#vb-hom-2</a>) better in principle, but do you think it's likely that it will cause pain later when one tries to apply it to normed fields?</p>",
        "id": 275174841,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647205256
    },
    {
        "content": "<p>It would be good to have a real fix for this issue, which has been biting us again and again and again, but I understand perfectly that this is low priority in Lean 3 -- it is not completely clear to me if this is really fixed in Lean 4, but to check this we need to get a working mathlib there first!</p>",
        "id": 275174865,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1647205304
    },
    {
        "content": "<p>Hopefully we can build a toy example which is completely independent of mathlib</p>",
        "id": 275175275,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647205831
    },
    {
        "content": "<p>Is it enough to fix your issues to register another instance assuming the stronger assumption on <code>R</code>?</p>",
        "id": 275175278,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1647205835
    },
    {
        "content": "<p>I have tried several times to build a toy example, but I have always failed :-(</p>",
        "id": 275175296,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1647205864
    },
    {
        "content": "<p>Maybe we can at least make a collection of examples.  Here's one from last week:<br>\n<a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Completeness.20of.20direct.20sums.20of.20Hilbert.20spaces.3F\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Completeness.20of.20direct.20sums.20of.20Hilbert.20spaces.3F</a></p>",
        "id": 275175371,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647205979
    },
    {
        "content": "<p>I tried to minimize but failed. The following code mimics the type class setup in what feels to be a very faithful way, but the mock up version works perfectly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.vector_bundle</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">defs</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n<span class=\"kn\">include</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fibrewise_clm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">E₁</span> <span class=\"n\">x</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">E₂</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">good</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">fibrewise_clm</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">linear_map.add_comm_monoid</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">fibrewise_clm</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">defs</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">fibrewise_clm</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span> <span class=\"c1\">-- by apply_instance -- fails</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">monoide</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">anneau</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">mph</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">anneau</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">anneau</span> <span class=\"n\">R'</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">corps</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">anneau</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">modul</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">anneau</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoide</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>  <span class=\"o\">(</span><span class=\"n\">F₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">monoide</span> <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">monoide</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n<span class=\"o\">[</span><span class=\"n\">anneau</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">mph</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">modul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">modul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">include</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"n\">σ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">E₁</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">E₂</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">baz</span>  <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">monoide</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">fibrewise_clm :</span>\n<span class=\"cm\">  Π {B : Type u_5} {R : Type u_6},</span>\n<span class=\"cm\">    Type u_7 →</span>\n<span class=\"cm\">    Type u_8 →</span>\n<span class=\"cm\">    Π (E₁ : B → Type u_9) [_inst_1 : Π (x : B), add_comm_monoid (E₁ x)] (E₂ : B → Type u_10)</span>\n<span class=\"cm\">    [_inst_2 : Π (x : B), add_comm_monoid (E₂ x)] [_inst_3 : comm_semiring R],</span>\n<span class=\"cm\">      (R →+* R) →</span>\n<span class=\"cm\">      Π [_inst_4 : Π (x : B), module R (E₁ x)] [_inst_5 : Π (x : B), module R (E₂ x)], B → Type (max u_9 u_10)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">foo :</span>\n<span class=\"cm\">  Π {B : Type u_7} {R : Type u_8},</span>\n<span class=\"cm\">    Type u_9 →</span>\n<span class=\"cm\">    Type u_10 →</span>\n<span class=\"cm\">    Π (E₁ : B → Type u_11) [_inst_1 : Π (x : B), monoide (E₁ x)] (E₂ : B → Type u_12)</span>\n<span class=\"cm\">    [_inst_2 : Π (x : B), monoide (E₂ x)] [_inst_3 : anneau R],</span>\n<span class=\"cm\">      mph R R →</span>\n<span class=\"cm\">      Π [_inst_4 : Π (x : B), modul R (E₁ x)] [_inst_5 : Π (x : B), modul R (E₂ x)], B → Type (max u_11 u_12)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">good :</span>\n<span class=\"cm\">  Π {B : Type u_7} {R : Type u_8} (F₁ : Type u_9) (F₂ : Type u_10) (E₁ : B → Type u_11)</span>\n<span class=\"cm\">  [_inst_1 : Π (x : B), add_comm_monoid (E₁ x)] (E₂ : B → Type u_12)</span>\n<span class=\"cm\">  [_inst_2 : Π (x : B), add_comm_monoid (E₂ x)] [_inst_3 : comm_semiring R] (σ : R →+* R)</span>\n<span class=\"cm\">  [_inst_4 : Π (x : B), module R (E₁ x)] [_inst_5 : Π (x : B), module R (E₂ x)] (x : B),</span>\n<span class=\"cm\">    add_comm_monoid (fibrewise_clm F₁ F₂ E₁ E₂ σ x)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">baz :</span>\n<span class=\"cm\">  Π {B : Type u_7} {R : Type u_8} (F₁ : Type u_9) (F₂ : Type u_10) (E₁ : B → Type u_11)</span>\n<span class=\"cm\">  [_inst_1 : Π (x : B), monoide (E₁ x)] (E₂ : B → Type u_12) [_inst_2 : Π (x : B), monoide (E₂ x)]</span>\n<span class=\"cm\">  [_inst_3 : anneau R] (σ : mph R R) [_inst_4 : Π (x : B), modul R (E₁ x)] [_inst_5 : Π (x : B), modul R (E₂ x)]</span>\n<span class=\"cm\">  (x : B), monoide (foo F₁ F₂ E₁ E₂ σ x)</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">modul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">modul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">monoide</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">corps</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">mph</span> <span class=\"n\">K</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">monoide</span> <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">monoide</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">modul</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">E₁</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">modul</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">E₂</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">monoide</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"n\">F₁</span> <span class=\"n\">F₂</span> <span class=\"n\">E₁</span> <span class=\"n\">E₂</span> <span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 275177041,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647208633
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> will pity us and explain what's going on.</p>",
        "id": 275177102,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647208685
    },
    {
        "content": "<p>I ported a huge amount of the bottom of the algebra heirarchy to mathlib4 last year precisely to see if a certain Lean 3 issue was fixed in Lean 4 (it was), and also because I thought it would be a neat way to learn some Lean 4. Maybe someone wants to try the same thing here?</p>",
        "id": 275177543,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647209168
    },
    {
        "content": "<p>My general impression is that this class of bugs requires a couple of ingredients (did not check if this is indeed the case here as well):</p>\n<ol>\n<li>Quantified instances</li>\n<li>Type classes with type class parameters (in this case the <code>add_comm_monoid</code> parameter of <code>module</code>).</li>\n<li>\"Non-obviously\" commuting diamonds, i.e. the instance <code>normed_field→add_comm_monoid</code> looks different than the <code>comm_semiring→add_comm_monoid</code> instance.</li>\n</ol>",
        "id": 275226774,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1647259975
    },
    {
        "content": "<p>Particularly 3) I think means that this kind of bug is very sensitive as to whether <code>old_structure_cmd</code> is used or not, how the instances are constructed syntactically (i.e. <code>comm_semiring.to_add_comm_monoid</code> might work while <code>{ .. ‹normed_field A› }</code> could fail spectacularly).</p>",
        "id": 275227143,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1647260187
    },
    {
        "content": "<p>Lean 4 changes some of these ingredients, but it's not clear to me how much of the issue that fixes.</p>",
        "id": 275239825,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1647266657
    },
    {
        "content": "<p>For example, the structure encoding is different, a mix between old_structure_cmd and \"new_structure_cmd\".  But for the algebraic hierarchy the mix looks very much like old_structure_cmd.</p>",
        "id": 275239917,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1647266707
    },
    {
        "content": "<p>Another difference is the order type-class parameters are searched for.  Lean 3 used to be left-to-right.  Then Lean 4 switched to right-to-left.  We then backported right-to-left to Lean 3.  Lean 4 then switched back.  (In other words, nobody knows what they're doing.)</p>\n<p>The left-to-right order has some advantages though with these kinds of type classes.  Look at this excerpt of a type class trace in Lean 3:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">x_1403</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">normed_space</span> <span class=\"n\">ℂ</span> <span class=\"n\">β</span> <span class=\"n\">complex.normed_field</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">normed_group.to_semi_normed_group</span> <span class=\"n\">β</span> <span class=\"bp\">?</span><span class=\"n\">x_1402</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>Note that the <code>semi_normed_group</code> parameter of <code>normed_space</code> contains a metavariable (this is because of the right-to-left order!).  Such a metavariable is a huge problem during unification.  If we need to unify e.g. <code>@normed_group.to_semi_normed_group β ?x_1402</code> and <code>real.normed_group</code>, then Lean needs to find a <code>semi_normed_group ℝ</code> instance during unification.  These <em>nested</em> type class problems furthermore do not have caching in Lean 3 for technical reasons.</p>",
        "id": 275240834,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1647267098
    }
]
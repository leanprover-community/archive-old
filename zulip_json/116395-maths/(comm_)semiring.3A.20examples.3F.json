[
    {
        "content": "<p>Dear All,</p>\n<p>I do not think that I ever really encountered <code>semiring</code>s in math, until I started using Lean.  Of course, I had seen the \"semiring\" of polynomials with coefficients in <code>ℕ</code>, and a couple of times I used something about the semiring of sums of squares in an ordered ring.</p>\n<p>I want to point out that I am sold on the idea of using <code>semiring</code>s (likely <code>comm_semirings</code>), but I would like to have a good supply of examples that are not \"essentially <code>comm_rings</code>\".</p>\n<p>My question: what are good examples of <code>comm_semiring</code> that are not <code>sub_semiring</code>s of a <code>comm_ring</code>?  Besides <code>boolean_algebra</code>s with <code>inf</code> and <code>sup</code> (in either order) as addition and multiplication, I do not have many more examples.</p>\n<p>The underlying goal that I am trying to achieve is to see how much of commutative algebra can be done by working with <code>(comm_)semiring</code>s alone.  For this, I would like to have access to examples that would help suggesting results and disproving statements.</p>\n<p>Thanks!</p>",
        "id": 223054317,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610905328
    },
    {
        "content": "<p>The tropical semiring?<br>\n<a href=\"https://en.wikipedia.org/wiki/Tropical_semiring\">https://en.wikipedia.org/wiki/Tropical_semiring</a></p>",
        "id": 223054360,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1610905439
    },
    {
        "content": "<p>That's a very good suggestion!  I had not thought of that!  Thanks!</p>",
        "id": 223054653,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610905823
    },
    {
        "content": "<blockquote>\n<p>The underlying goal that I am trying to achieve is to see how much of commutative algebra can be done by working with (comm_)semirings alone. For this, I would like to have access to examples that would help suggesting results and disproving statements.</p>\n</blockquote>\n<p>Rather than looking for examples, an easy way to achieve this is to just pretend that semirings are rings until you get in trouble. It is surprisingly common for mathematical textbooks to make stronger assumptions than necessary for no reason besides making it easier to think about the subject. Just like how every vector space looks like R^2 and every topological space looks like a picture of a cloud, just ignore the full range of examples and use the nice ones to guide proof sketches.</p>",
        "id": 223054850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610906141
    },
    {
        "content": "<p>You can get very far doing commutative algebra with semirings. You can even \"do\" algebraic geometry.</p>",
        "id": 223054998,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1610906344
    },
    {
        "content": "<p>Thank you Mario!  I completely agree with you on unnecessary assumptions in maths: I find this really inspiring about Lean (and formalization in general).</p>\n<p>I have also been playing in my head with trying to find a statement that \"requires\" a <code>comm_ring</code> and so far I have mostly failed.  Of course, there are some tautological statements that \"need\" existence of opposites, but not much besides almost tautologies.</p>\n<p>The reason for asking for examples, though, is to see if there is really a wealth of examples to justify the effort of reproving known statements.  Thus, before embarking on this journey, I would like to at least have a few well-chosen examples as justification.</p>",
        "id": 223055010,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610906380
    },
    {
        "content": "<p>The main thing that you can't do in a semiring is to cancel additions. This means that you can have things like an add that saturates, for example <code>ennreal</code> or <code>fin n</code></p>",
        "id": 223055011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610906381
    },
    {
        "content": "<p>Adam, this is exactly what I would like to understand: how much of what I know of algebraic geometry is really relying on what the ground (<code>semi</code>)-ring is.  I always thought that making assumptions on the base ring such as <code>field</code>, <code>integral_domain</code>, <code>reduced</code> were often just safety nets that never really played a role.  Now I am trying to see whether even the existence of opposites is actually ever a serious issue...</p>",
        "id": 223055109,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610906520
    },
    {
        "content": "<p>I don't think <code>fin n</code>s add saturates, I think it would be nice if it did though. Or maybe that's what you're saying too <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 223055151,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1610906531
    },
    {
        "content": "<p>no but you get the idea</p>",
        "id": 223055158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610906549
    },
    {
        "content": "<p>anyway you probably want <code>fin (n+1)</code> for that</p>",
        "id": 223055169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610906572
    },
    {
        "content": "<p>I like the ideas of <code>ennreal</code> (which, if I understand correctly what it is, is similar to the sums of squares of \\R?).</p>\n<p>I will take a look at what is the addition on <code>fin n</code>!</p>",
        "id": 223055256,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610906668
    },
    {
        "content": "<p><code>ennreal</code> is the extended nonnegative reals, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0,\\infty]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">]</span></span></span></span></p>",
        "id": 223055288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610906760
    },
    {
        "content": "<p>the addition on fin n is broken but the one I'm talking about is <code>(a + b : fin (n+1)) := min(n, a + b)</code></p>",
        "id": 223055356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610906829
    },
    {
        "content": "<p>Ah, I see, it also has an \\infty!  Thanks!</p>",
        "id": 223055364,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610906844
    },
    {
        "content": "<p>the nonnegative reals are also a semiring but I think you already mentioned it as a boring example</p>",
        "id": 223055370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610906876
    },
    {
        "content": "<p>Ok, thanks: also <code>fin (n+1)</code> is a good example!</p>",
        "id": 223055411,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610906886
    },
    {
        "content": "<p>Well, not boring, just not \"exotic\" enough...</p>",
        "id": 223055420,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610906919
    },
    {
        "content": "<p>One nice exercise is to classify all semiring quotients of nat</p>",
        "id": 223055425,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1610906926
    },
    {
        "content": "<p>Adam: is your question equivalent to \"classify cyclic semirings?\"?</p>",
        "id": 223055442,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610906973
    },
    {
        "content": "<p>I don't know what cyclic semirings are...</p>",
        "id": 223055452,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1610906995
    },
    {
        "content": "<p>generated by a single element...  ah, there is zero also!</p>",
        "id": 223055499,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610907014
    },
    {
        "content": "<p>What are semiring quotients defined as?</p>",
        "id": 223055502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610907022
    },
    {
        "content": "<p>There's also some work by Borger et al about Witt vectors in the context of semirings</p>",
        "id": 223055504,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1610907024
    },
    {
        "content": "<p>Semiring quotients of N are semirings with a surjective semiring hom from N</p>",
        "id": 223055513,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1610907053
    },
    {
        "content": "<p>Ok, so, if I understand correctly, a semiring quotient of N is a semiring that contains 0 and is generated by a (possibly extra) element, right?</p>",
        "id": 223055534,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610907107
    },
    {
        "content": "<p><a href=\"https://arxiv.org/abs/1310.3013\">https://arxiv.org/abs/1310.3013</a></p>",
        "id": 223055535,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1610907118
    },
    {
        "content": "<p>The extra element has to be the one</p>",
        "id": 223055572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610907129
    },
    {
        "content": "<p>I guess that semirings contain zero by definition, though...  so it is simply a semiring generated by a single element (which could be zero itself), right?</p>",
        "id": 223055575,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610907148
    },
    {
        "content": "<p>semiring homs fix both 0 and 1</p>",
        "id": 223055576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610907148
    },
    {
        "content": "<p>zero and one are different in a semiring?  I thought that (0) was a semiring?</p>",
        "id": 223055586,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610907172
    },
    {
        "content": "<p>they aren't necessarily different</p>",
        "id": 223055588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610907183
    },
    {
        "content": "<p>but 0 has to act like 0 and 1 like 1, so they can only coincide in the zero ring</p>",
        "id": 223055593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610907211
    },
    {
        "content": "<p>ok, so we either have the zero semiring or a ring with o and everything is generated by the non-zero element 1</p>",
        "id": 223055594,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610907214
    },
    {
        "content": "<p>So either the semiring is N or it is finite, and n.1 = m, with m \\leq n, I would say...</p>",
        "id": 223055650,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610907268
    },
    {
        "content": "<p>I am not sure whether all choices of <code>0 \\leq m \\leq n</code> are allowed, but it seems like it...</p>",
        "id": 223055675,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610907323
    },
    {
        "content": "<p>this is a great exercise to practice-formalize in Lean: thank you Adam!</p>",
        "id": 223055731,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610907367
    },
    {
        "content": "<p>Damiano -- Z/3Z is a semiring quotient of N but so is <code>fin 3</code> with 2+1=2.</p>",
        "id": 223070219,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610927451
    },
    {
        "content": "<p>Ok, these two choices seem to be</p>\n<ul>\n<li><code>(m, n) = (0, 3)</code> for <code>Z/3Z</code> and</li>\n<li><code>(m, n)=(2, 3)</code> for <code>fin 3</code></li>\n</ul>",
        "id": 223074611,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610934893
    },
    {
        "content": "<p>Aah I see. If you know the dynamics of the +1 function you know the entire semiring structure because addition is repeated +1 and multiplication is repeated addition</p>",
        "id": 223085959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610952301
    },
    {
        "content": "<p>I am playing around with the idea of allowing <code>ideal</code> to take a <code>comm_semiring</code> instance, instead of a <code>comm_ring</code> instance.</p>\n<p>Thus, <code>ideal</code> shifts more towards being <code>submodule R R</code>.  An alternative could be converting lemmas for <code>ideal</code> into lemmas for (appropriately special) <code>submodule</code>s.</p>\n<p>To try this out, I replaced <code>comm_ring</code> for <code>comm_semiring</code> in <code>ring_theory/ideal/basic.lean</code> and a good 300 lines of  code are just automatically converted.</p>\n<p>Before I actually take action, what are people views on this?  Is it something that would be useful?  For me, personally, there is a blur in the notion of <code>submodule R M &lt;= submodule R R &lt;= ideal R</code> and it seems that trying to push lemmas towards the left would help sharpen the boundaries.  For instance, I would be hard pressed to come up with a lemma about an <code>ideal</code> that is <em>really</em> awkward to state for a <code>submodule R M</code>.  If <code>M</code> is actually cyclic, then the distinction between <code>ideal</code> and <code>submodule R (span R singleton)</code> is even more subtle.</p>",
        "id": 223191749,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611038213
    },
    {
        "content": "<p>Procedurally, the simplest first step could be to simply change the definition, create a section <code>comm_semiring</code> in the file and \"float\" all the lemmas that are already proved-as-stated into this section.</p>\n<p>Later, the remaining lemmas can be adapted, maybe by proving an alternative version for the extended def of <code>ideal</code>, and the old lemma would then be the conversion of the newer more general version to what it was before.</p>",
        "id": 223192113,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611038669
    },
    {
        "content": "<p>Isn't <code>ideal R</code> defined as <code>submodule R R</code>? Clearly then it serves a purpose, namely to specialize to the case where the two types are the same</p>",
        "id": 223192200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611038788
    },
    {
        "content": "<p>Of course any theorems about submodules should be stated on submodules</p>",
        "id": 223192211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611038803
    },
    {
        "content": "<p>I think I was at least partly at fault for ideals only being defined for commutative rings, because we needed them for schemes very early on and I didn't have a clue about this semiring stuff. Since then there has been plenty of noise from people saying we should have have them for noncommutative rings but I don't think I've ever heard anyone suggest we need them for semirings!</p>\n<p>Here is an argument against it. The reason we have normal subgroups and ideals is that for sensible objects like groups and rings, these are exactly the objects we use to form quotient objects. For semirings this is not the case. For general algebraic objects one forms quotients by quotienting out by a general equivalence relation, not some kind of subobject. The equivalence relation needs to play well with the structure fields and then the quotient object inherits the structure. For groups and rings it's kind of a coincidence (at least as far as I can see) that in both cases such an equivalence relation comes from a certain kind of subobject (the most striking case is abelian groups, where quotients are the same thing as subobjects, perhaps the reason why exact sequences are so important). For commutative semirings it is not true that every quotient object is the quotient by an ideal and this is perhaps the reason that ideals don't seem to have as much significance mathematically for semirings.</p>\n<p>Having said all that, of course it's certainly the mathlib philosophy that objects should be defined in the biggest generality in which they make sense, and this is definitely an argument for doing it. You just might find that mathematically it doesn't buy you much in practice.</p>",
        "id": 223192576,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611039304
    },
    {
        "content": "<p>Fortunately <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_quot\">docs#ring_quot</a> works for semirings :)</p>",
        "id": 223192913,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611039784
    },
    {
        "content": "<p>This will be the thing which is used in practice rather than ideals, I guess</p>",
        "id": 223192944,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611039816
    },
    {
        "content": "<p>Kevin, I understand and share your view.</p>\n<p>Still, there are <em>lots</em> of results in <code>ring_theory/ideal/basic</code> that work for <code>submodule R R</code> with <code>[comm_semiring R]</code> (rather than <code>ideal</code> for a <code>[comm_ring]</code>) as stated-and-proven.  It should be uncontroversial (this is never the case...) that these should be stated at least in this generality, though, right?</p>",
        "id": 223193222,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611040183
    },
    {
        "content": "<p>I don't think it is an issue to define <code>ideal R</code> to take <code>comm_semiring</code>, or even <code>semiring</code> as an argument, and given that I'm sure many theorems will generalize without you having to do anything. I wouldn't use <code>submodule R R</code> in place of <code>ideal R</code> though; the theorems about <code>submodule M R</code> should be proven in that generality, and then specialized to <code>ideal R</code></p>",
        "id": 223193397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611040360
    },
    {
        "content": "<p>Mario, it is true that <code>ideal R = submodule R R</code>, but the definition only applies with a background <code>[comm_ring R]</code>, instead of a <code>[comm_semiring R]</code> assumption.</p>",
        "id": 223193399,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611040365
    },
    {
        "content": "<p>However you might have to be careful that the definition is still correct in the <code>semiring</code> case (I would go for a left ideal)</p>",
        "id": 223193427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611040438
    },
    {
        "content": "<p>Ok, so the consensus seems to be to leave the definition of <code>ideal</code>with the implied assumption on <code>R</code> fixed, but convert the statements of the lemmas to apply to <code>submodule R R</code> with a weaker assumption on <code>R</code>, right?</p>\n<p>I also agree with removing the <code>comm</code> assumption and then <code>left/right ideal</code>: I was planning to only tackle the <code>comm</code> issue, not allowing non-commutative rings, at least for the moment!</p>",
        "id": 223193571,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611040567
    },
    {
        "content": "<p>Well you can do exactly the same thing as you're doing now: just take the <code>comm</code> off and put it back in on theorems that fail</p>",
        "id": 223193604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611040616
    },
    {
        "content": "<p>Procedurally, rather than changing the definition of <code>ideal</code> change the variables from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>and see what copiles, right?</p>",
        "id": 223193632,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611040657
    },
    {
        "content": "<p>No, I mean <code>variables [comm_semiring α] (I : ideal R) {a b : α}</code></p>",
        "id": 223193652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611040681
    },
    {
        "content": "<p>or <code>variables [semiring α] (I : ideal R) {a b : α}</code></p>",
        "id": 223193720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611040725
    },
    {
        "content": "<p>Ok, I think that I have confused myself: do people want to change the definition of <code>ideal</code> to allow a <code>comm_semiring</code> instead of a <code>comm_ring</code> underlying ring?</p>",
        "id": 223193734,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611040749
    },
    {
        "content": "<p>that's my suggestion, yes</p>",
        "id": 223193742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611040763
    },
    {
        "content": "<p>I see, I think that Kevin had argued (weakly) against that.  Maybe, we should reach a consensus on this, before changing!</p>",
        "id": 223193775,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611040803
    },
    {
        "content": "<p>(Btw, Mario, in my experiment, what you suggest is exactly what I did.)</p>",
        "id": 223193811,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611040820
    },
    {
        "content": "<p>Kevin's argument, which I agree with, about the danger of \"trivial generalization\" is that you can end up stating true theorems about a useless thing. A definition that makes sense in a restricted situation may no longer be correct in a general setting. This is like defining implication as <code>not a \\/ b</code> in classical logic and then generalizing to intuitionistic, or defining quotient rings by taking the quotient wrt an ideal and then generalizing to where not all quotients are quotients by an ideal. The definition and theorems are still correct but it's no longer capturing the right idea</p>",
        "id": 223193995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611041067
    },
    {
        "content": "<p>In the best case, there is a way to tweak the definition such that it is correct in the generalization and equivalent to the old definition in the original restricted setting</p>",
        "id": 223194038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611041134
    },
    {
        "content": "<p>In other cases, you might have a bifurcation of concepts, like left / right / two-sided ideals in the noncommutative setting, and then you have to pick which one is the official one that gets the simple name in the restricted setting and give new names for the others</p>",
        "id": 223194127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611041224
    },
    {
        "content": "<p>In the worst case the correct definition in the general setting is annoying to work with in the restricted setting because it's paying attention to subtleties that don't matter, and now the restricted setting (which is what most people care about) has been made worse by the generalization</p>",
        "id": 223194204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611041304
    },
    {
        "content": "<p>an example of the latter might be <code>free_comm_ring R A</code>, which is a quotient of an inductive type for constructivity reasons but classically is just the same thing as <code>mv_polynomial R A</code></p>",
        "id": 223194308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611041443
    },
    {
        "content": "<p>I completely agree.</p>\n<p>I am still not convinced that there is a general consensus on allowing <code>comm_semiring</code>s as coefficients for <code>ideal</code>s, or whether we should stick to the current definition of <code>ideal</code> and simply state more lemmas for <code>submodule R R</code>.</p>",
        "id": 223194342,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611041470
    },
    {
        "content": "<p>I don't think there is any reason for <code>submodule R R</code> to have theorems if <code>ideal R</code> exists</p>",
        "id": 223194362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611041506
    },
    {
        "content": "<p>Mario, I think Damiano means that the <code>R</code> in <code>submodule R R</code> could have weaker assumptions.</p>",
        "id": 223194413,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611041537
    },
    {
        "content": "<p>I agree with that, but they should be applied to <code>ideal</code> too</p>",
        "id": 223194424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611041553
    },
    {
        "content": "<p>But I think in this case <code>ideal R</code> will not become harder to use if we generalise it.</p>",
        "id": 223194428,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611041562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> nevertheless, I fear that refactoring <code>ideal</code> will be a <em>huge</em> effort.</p>",
        "id": 223194443,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611041590
    },
    {
        "content": "<p>Why would it? Trivial generalization is usually not very hard, although it might be useless</p>",
        "id": 223194474,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611041627
    },
    {
        "content": "<p>Unless there are typeclass subtleties</p>",
        "id": 223194483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611041640
    },
    {
        "content": "<p>It is used all over the place. And typeclass inference of unification may take slightly different paths if you generalise it, so you might suddenly face painful broken proofs in functional analysis, measure theory, or whatever.</p>",
        "id": 223194526,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611041657
    },
    {
        "content": "<p>Not speaking for the difficulties in Lean, but the refactor could simply be to allow the rings to be <code>comm_semiring</code>, but then only gradually change the uses of <code>ideal</code>s to a more general setting, as needed.</p>",
        "id": 223194546,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611041692
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <code>module R M</code> is an abbreviation for <code>semimodule R M</code>. Nevertheless, if you globaly search replace <code>semimodule</code> by <code>module</code>, and remove the old <code>module</code>-def, mathlib will be broken in tons of places.</p>",
        "id": 223194559,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611041715
    },
    {
        "content": "<p>I see, is there a way to test this out?  Simply changing the definition of ideal and touching nothing else.  What would break?</p>",
        "id": 223194562,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611041727
    },
    {
        "content": "<p>That's exactly how you test it</p>",
        "id": 223194569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611041757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> you can just make the change, and see what happens.</p>",
        "id": 223194594,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611041764
    },
    {
        "content": "<p>Either push it to a branch, and wait till CI tells you, or compile locally with <code>lean --make src/</code></p>",
        "id": 223194622,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611041781
    },
    {
        "content": "<p>Ok, I have and I get a bunch of red lines in this file.  I thought that you were suggesting that other files would break as well</p>",
        "id": 223194629,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611041790
    },
    {
        "content": "<p>ah, ok!</p>",
        "id": 223194636,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611041801
    },
    {
        "content": "<p>I would be surprised if other files don't break.</p>",
        "id": 223194639,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611041807
    },
    {
        "content": "<p>I am going to start a fresh copy of mathlib, simply change the comm_ring to comm_semiring and let it build</p>",
        "id": 223194661,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611041842
    },
    {
        "content": "<p>This is some weird thing. From a maths point of view, it is clear that nothing should break. From a CS point of view, it is clear that something should break.</p>",
        "id": 223194673,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611041860
    },
    {
        "content": "<p>I mean, you are changing a fundamental def'n in a library with ~450.000 lines of code. Something must break, right?</p>",
        "id": 223194731,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611041891
    },
    {
        "content": "<p>if I push to a branch, would it automatically compile, or should I create a PR?</p>",
        "id": 223194784,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611041972
    },
    {
        "content": "<p>branches are compiled</p>",
        "id": 223194789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611041984
    },
    {
        "content": "<p>ok, thanks!</p>",
        "id": 223194854,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611042009
    },
    {
        "content": "<p>If you have time and energy for a giant refactor I think it would be much more useful to get rid of useless commutativity than to put semi-rings everywhere.</p>",
        "id": 223195528,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1611042722
    },
    {
        "content": "<p>I realize that this is my crusade, but the first line that breaks down in <code>ring_theory/ideal/basic</code> is 310.  Unfortunately, I do not understand what it does...  I will try to figure it out, but if anyone has a tip, it would be greatly appreciated!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">I.quotient</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">quotient.lift_on₂'</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">submodule.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">$</span>\n <span class=\"bp\">λ</span> <span class=\"n\">a₁</span> <span class=\"n\">a₂</span> <span class=\"n\">b₁</span> <span class=\"n\">b₂</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">quot.sound</span> <span class=\"bp\">$</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"k\">calc</span> <span class=\"n\">a₁</span> <span class=\"bp\">*</span> <span class=\"n\">a₂</span> <span class=\"bp\">-</span> <span class=\"n\">b₁</span> <span class=\"bp\">*</span> <span class=\"n\">b₂</span> <span class=\"bp\">=</span> <span class=\"n\">a₂</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a₁</span> <span class=\"bp\">-</span> <span class=\"n\">b₁</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a₂</span> <span class=\"bp\">-</span> <span class=\"n\">b₂</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b₁</span> <span class=\"o\">:</span> <span class=\"n\">_</span>\n  <span class=\"bp\">...</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">I.add_mem</span> <span class=\"o\">(</span><span class=\"n\">I.mul_mem_left</span> <span class=\"n\">_</span> <span class=\"n\">h₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I.mul_mem_right</span> <span class=\"n\">_</span> <span class=\"n\">h₂</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_sub</span><span class=\"o\">,</span> <span class=\"n\">sub_mul</span><span class=\"o\">,</span> <span class=\"n\">sub_add_sub_cancel</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span> <span class=\"n\">b₁</span><span class=\"o\">]</span>\n <span class=\"kd\">end</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>the three dots give the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">a₁</span> <span class=\"bp\">*</span> <span class=\"n\">a₂</span> <span class=\"bp\">-</span> <span class=\"n\">b₁</span> <span class=\"bp\">*</span> <span class=\"n\">b₂</span> <span class=\"bp\">∈</span> <span class=\"bp\">↑</span><span class=\"n\">I</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">setoid.r</span> <span class=\"o\">(</span><span class=\"n\">a₁</span> <span class=\"bp\">*</span> <span class=\"n\">a₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b₁</span> <span class=\"bp\">*</span> <span class=\"n\">b₂</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 223195584,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611042759
    },
    {
        "content": "<p>Can you push to a branch so it's easy for others to see the error?</p>",
        "id": 223195716,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611042891
    },
    {
        "content": "<p>Kevin, it is here:</p>\n<p>Branch 'comm_semiring'</p>",
        "id": 223195901,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611043084
    },
    {
        "content": "<p>Patrick, I will look into this, but for the <code>comm_semiring</code> I have two goals that I want to achieve.</p>\n<p>One is to create a bridge between topology and algebra, using the <code>comm_semiring</code> structure on <code>boolean_algebras</code> of, say, open sets.</p>\n<p>The other is to bring more algebraic geometry to tropical geometry.  It was Riccardo's observation that the underlying ring for tropical geometry is a comm_semiring.  A lot of results similar to results in algebraic geometry hold in tropical geometry, but there is no direct approach.  I wonder whether the great similarities between comm_semirings and comm_rings could help!</p>\n<p>Both these examples are commutative...</p>",
        "id": 223196136,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611043255
    },
    {
        "content": "<p>For goal one: if there is an analogue of <code>Spec</code> for <code>comm_semirings</code> with good properties, what is <code>Spec (boolean_semiring topological_space)</code>?</p>",
        "id": 223196260,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611043336
    },
    {
        "content": "<p>I tried the non-commutative refactor a while ago, but gave up because Scott introduced <code>ring_quot</code> and solved the problem I actually cared about. There's an open PR with my attempt somewhere still</p>",
        "id": 223196344,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611043440
    },
    {
        "content": "<p>Dear all, I just realize there is this topic on something I am working on (together with <span class=\"user-mention\" data-user-id=\"254058\">@Marc Masdeu</span> ), that is to do all that it is possible on ideals on lean but for comm_semirings. We had some things done and appart of the quotients (which clearly need to be redone) and some proof that rewrote (concretely, that maximal ideals are prime), must of the file works. Our suggestion, however, is that it should be better to define something like \"semideals\" or \"semiideals\" like for modules we use semimodules, in order not to conflict with the things done for ideals.  </p>\n<p>In order to do quotients, one should develope \"congruences\" for semimodules: equivalence relations that preserve the structure. Congruences are developed for monoids, so it should not be difficult to do it (in fact, I have some things done). Then the quotient by a subsemimodule is just the quotient by the congruence it generates.  But it is not true anymore that the kernel of the quotient by a subsemimodule is the subsemimodule: it is only true for the \"saturated\" subsemimodules. </p>\n<p>To go further, so to do Spec, schemes and so on, it is possible, and it has been developed for several people (including myself in a \"private\" preprint). It can be done and it should be not difficult.</p>",
        "id": 223215346,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1611056680
    },
    {
        "content": "<p>Are \"prime semi-ideals\" the correct objects that one should use to make Spec? Or does one look at e.g. surjections from semirings to semi-integral-domains up to  equivalence? Or are these the same thing?</p>",
        "id": 223216361,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611057445
    },
    {
        "content": "<p>In case anyone is interested, this fixed the first broken file:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">I.quotient</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">quotient.lift_on₂'</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">submodule.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">$</span>\n <span class=\"bp\">λ</span> <span class=\"n\">a₁</span> <span class=\"n\">a₂</span> <span class=\"n\">b₁</span> <span class=\"n\">b₂</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">quot.sound</span> <span class=\"bp\">$</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"n\">I.add_mem</span> <span class=\"o\">(</span><span class=\"n\">I.mul_mem_left</span> <span class=\"n\">a₂</span> <span class=\"n\">h₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I.mul_mem_right</span> <span class=\"n\">b₁</span> <span class=\"n\">h₂</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a₁</span> <span class=\"bp\">*</span> <span class=\"n\">a₂</span> <span class=\"bp\">-</span> <span class=\"n\">b₁</span> <span class=\"bp\">*</span> <span class=\"n\">b₂</span> <span class=\"bp\">=</span> <span class=\"n\">a₂</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a₁</span> <span class=\"bp\">-</span> <span class=\"n\">b₁</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a₂</span> <span class=\"bp\">-</span> <span class=\"n\">b₂</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b₁</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_sub</span><span class=\"o\">,</span> <span class=\"n\">sub_mul</span><span class=\"o\">,</span> <span class=\"n\">sub_add_sub_cancel</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span> <span class=\"n\">b₁</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">this</span> <span class=\"n\">at</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">F</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 223217275,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611058059
    },
    {
        "content": "<p>One can define Spec with \"prime semi-ideals\", with \"prime saturated semi-ideals\" or with \"prime congruences\", and all three work and are diferent. The main topic of my preprint is the relation of the first two with valuation theory.</p>",
        "id": 223217288,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1611058071
    },
    {
        "content": "<p>So, in my preprint I explain why you naturaly need the two notions of Spec, with ideals and with saturated ideals. I had the idea to see if it is possible to formalize in lean all to give my preprint much more rigor, but it is going to be quite hard.</p>",
        "id": 223217673,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1611058390
    },
    {
        "content": "<p>On the other hand,I was really suprised by lean, when I saw that I could take out all the lemmas using the substraction and using the quotient from the ideal lean file, and change comm_ring for comm_semiring evrywhere and most of the results worked without changes. I thing this really shows that lean can prove that when we say \"the same proof works\" it is literaly true sometimes.</p>",
        "id": 223218030,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1611058664
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315546\">@Xavier Xarles</span> right now a (multiplicative) valuation on a commutative ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> in Lean is defined to be a monoid-with-zero homomorphism (i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mi>b</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(ab)=v(a)v(b)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">v(0)=0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">v(1)=1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>) from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>∪</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\cup\\{0\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mclose\">}</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Γ</span></span></span></span> is a totally ordered abelian group (group law <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>×</mo></mrow><annotation encoding=\"application/x-tex\">\\times</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">×</span></span></span></span>), satisfying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>≥</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">{</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">v(a+b)\\geq min\\{v(a),v(b)\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mclose\">}</span></span></span></span>. Eric Wieser and I have been reorganising the theory of ordered monoids recently and I was going to change this definition of a valuation to allow the target to be a general totally ordered monoid-with-zero. Should I also change it to allow commutative semirings?</p>",
        "id": 223220754,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611060441
    },
    {
        "content": "<p>For the theory of perfectoid spaces we only needed groups-with-zero as the target, but more recently Lau and I realised that in the theory of tilting it's more convenient to allow monoids with zero sometimes. For example there is a \"truncated valuation\" on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>p</mi><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R/pR</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is the integers of a (possibly highly ramified) p-adic local field, taking values in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo stretchy=\"false\">}</mo><mo>∪</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\{0\\}\\cup(1/p,1]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>.</p>",
        "id": 223220972,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611060568
    },
    {
        "content": "<p>This was going to be my next PR when I've got through this week (somehow I am giving a lot of talks this week).</p>",
        "id": 223221225,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611060728
    },
    {
        "content": "<p>Is there a way to find out about more than one error at a time?  I fixed two files, but I only found out about the second one, after I fixed the first.  Is there a way to get all the errors that are within reach of the current position, or will I have to fix one, recompile, fix another, and so on?</p>",
        "id": 223226512,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611063563
    },
    {
        "content": "<p>Just compile locally.</p>",
        "id": 223226533,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611063579
    },
    {
        "content": "<p>In a terminal, <code>cd</code> to the root of your modded mathlib and then type <code>lean --make src</code> and go and have lunch</p>",
        "id": 223226621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611063615
    },
    {
        "content": "<p>ok, I will do that, maybe while talking to a student, since I just had lunch!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 223226669,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611063650
    },
    {
        "content": "<p>I'm very proud that users have now forgotten that you can compile mathlib locally.</p>",
        "id": 223226833,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1611063737
    },
    {
        "content": "<p>If you got 10 cents every time someone typed <code>leanproject get-&lt;something&gt;</code> then you would be doing very well by now!</p>",
        "id": 223226931,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611063790
    },
    {
        "content": "<p>you can <code>get</code> more than <code>cache</code>?</p>",
        "id": 223226963,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611063816
    },
    {
        "content": "<p><code>cash</code>?</p>",
        "id": 223226978,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611063827
    },
    {
        "content": "<p>If you're working on a project which uses mathlib as a dependency, then you can type <code>leanproject get-mathlib-cache</code> to update mathlib</p>",
        "id": 223227044,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611063851
    },
    {
        "content": "<p>Ah, I never dared to make a dependency, since I am still unsure with github</p>",
        "id": 223227101,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611063883
    },
    {
        "content": "<p>When you start working on <a href=\"https://github.com/leanprover-community/lean-liquid\">https://github.com/leanprover-community/lean-liquid</a> you'll learn about <code>get-mathlib-cache</code></p>",
        "id": 223227156,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611063916
    },
    {
        "content": "<p>While we are on this topic, does the <code>make</code> command go sequentially through the files, starting with the ones that import nothing and the proceeding to the next layer recursively?</p>",
        "id": 223227203,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611063943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/(comm_)semiring.3A.20examples.3F/near/223226931\">said</a>:</p>\n<blockquote>\n<p>If you got 10 cents every time someone typed <code>leanproject get-&lt;something&gt;</code> then you would be doing very well by now!</p>\n</blockquote>\n<p>We (well, MSR) pay a cent or so, but still!</p>",
        "id": 223227222,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1611063956
    },
    {
        "content": "<p>Unfortunately not to Patrick!</p>",
        "id": 223227299,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611063976
    },
    {
        "content": "<p>Note that Rob, Gabriel and Bryan should also get a share. Without the CI and Azure infrastructure <code>leanproject</code> couldn't work.</p>",
        "id": 223227356,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1611064012
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> if you have got a fully compiled mathlib and then just change a few files, <code>make</code> will start by compiling one of those, and then move on to other files you changed, and the files which import those files etc. If you have a multi-core machine (which you probably do) then it might work on several at once.</p>",
        "id": 223227432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611064055
    },
    {
        "content": "<p>And Leo, who helped us arrange the grant that actually pays for it</p>",
        "id": 223227445,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1611064063
    },
    {
        "content": "<p>Aah, so MS is paying MS! Sounds like a tax dodge.</p>",
        "id": 223227532,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611064093
    },
    {
        "content": "<p>Kevin, you haven't been paying attention during my opening talk at LT2021...</p>",
        "id": 223227574,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1611064122
    },
    {
        "content": "<p>I promise I was there and listening! I'm just getting forgetful ;-)</p>",
        "id": 223227623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611064148
    },
    {
        "content": "<p>Kevin, thanks for the explanation!  I am sure that there is a lot more under the surface, but it is good to know that it will start from there the interesting stuff has happened!</p>",
        "id": 223227643,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611064157
    },
    {
        "content": "<p>MS Research is paying MS Azure, I bet the internal overhead costs more than the taxes they pay!</p>",
        "id": 223227681,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1611064177
    },
    {
        "content": "<p>It might well look at earlier files, but if it sees a lean file and an olean file, and these files are compatible, then it just skips the lean file.</p>",
        "id": 223227715,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611064195
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  The notion I use in that paper is even more general, as done in a paper by Giansiracusa and Giansiracusa: a (pre)valuation is a map to an idempotent semiring that it is multiplicative and \"subadditive\". A totally ordered monoid-with-zero becomes an idempotent semiring with the min (or max) operation. But I am not sure this notion is really useful: they introduced in a paper but nobody seems to be using it (a part from me). And I decided to called prevaluation, as valuation is a very well-known notion so it is better not to create confusion.</p>",
        "id": 223232985,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1611066374
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315546\">@Xavier Xarles</span> Can you send a link to this paper you mentioned?</p>",
        "id": 223233088,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611066426
    },
    {
        "content": "<p>Do they or you have any applications for such prevaluations that are not possible with the monoid-with-zero version?</p>",
        "id": 223233151,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611066463
    },
    {
        "content": "<p>The link to the paper is: <a href=\"https://arxiv.org/abs/1308.0042\">https://arxiv.org/abs/1308.0042</a> (it is publish in Duke). There is a not publish sequel in <a href=\"https://arxiv.org/abs/1410.4348\">https://arxiv.org/abs/1410.4348</a></p>",
        "id": 223233557,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1611066625
    },
    {
        "content": "<p>Thanks! (I have a student working on similar things right now)</p>",
        "id": 223233673,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611066675
    },
    {
        "content": "<p>On the compiling front: mathlib is now timing out on the file <code>ring_theory/jacobson.lean</code> and I do not know how to make it faster.  One of the \"slow\" proofs is quite long, so maybe it should be split.  For the moment, though, is it possible to instruct lean not to compile a file, or should I simply move it outside of its reach?</p>",
        "id": 223233869,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611066766
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  They need in the construction of the \"universal valuation\", and you need the general version for this. Also for other constructions, as the \"universal tropicalization\". They would like to do \"scheme theoretic\" versions of these. In some some sense it is what I did in my preprint (I will send it to arxiv some day). But it is not used to solve really anything outside the theory... as far as I know.</p>",
        "id": 223234297,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1611066931
    },
    {
        "content": "<p>This universal valuation looks exactly like something we might write in lean :)<br>\n(as a quotient of a giant inductive type, etc.)</p>",
        "id": 223235461,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611067415
    },
    {
        "content": "<p>There is a quite natural construction of the universal valuation I do in my paper: it is \"reminiscent\" of the idempotent semiring of the ideals in a commutative ring.</p>",
        "id": 223235824,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1611067579
    },
    {
        "content": "<p>I guess the key thing one must check to see whether there is a scheme-theoretic version of the universal valuation is whether the construction in the affine case is compatible with localizations. Is this condition easy to check?</p>",
        "id": 223236073,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611067700
    },
    {
        "content": "<p>This is exactly one of the points: but it is quite easy, as valuation is a morphism of multiplicative monoids, and localization is about multiplicative monoids only...</p>",
        "id": 223236347,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1611067823
    },
    {
        "content": "<p>Both on my computer and on the remote branch, the output of compiling mathlib has an output informing me that 3 proofs use sorry.  I have sorried them myself, since they now time out.</p>\n<p>Does this mean that everything else is in order?  Or does it simply mean that once the compiling got to this file it ended its work?</p>",
        "id": 223242899,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611070196
    },
    {
        "content": "<p>no, that sounds like you are good</p>",
        "id": 223243073,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611070249
    },
    {
        "content": "<p>apart from those three sorrys</p>",
        "id": 223243095,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611070259
    },
    {
        "content": "<p>Ok, so the change allowing an ideal to take a comm_semiring instead of a comm_ring instance builds.</p>\n<p>I have not yet moved anything to actually use this new generality, simply allowed Lean to have it.</p>",
        "id": 223243266,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611070316
    },
    {
        "content": "<p>So, now I have to fix the 3 missing proofs in <code>src/ring_theory/jacobson.lean</code>!</p>",
        "id": 223243353,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611070339
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Great! And good luck with fixing those proofs. If you get stuck after and they fight back hard, I'm sure you can get some help here.</p>",
        "id": 223272577,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611081664
    },
    {
        "content": "<p>Ok, thanks!  At the moment, I am trying to zoom in on the issue.  It seems that there are some instances that lean is failing to find.  I will try to narrow this down further</p>",
        "id": 223277195,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611083430
    },
    {
        "content": "<p>My strategy is to tear apart the proofs, to see if separately they compile: is this acceptable (assuming that it works)?</p>",
        "id": 223277288,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611083473
    },
    {
        "content": "<p>The statements typecheck, right? The problem is the proofs? I would just <code>sorry</code> parts of them, and try to narrow in like that.</p>",
        "id": 223277864,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611083677
    },
    {
        "content": "<p>Yes, the statements are ok.  I think that it is one of the <code>have</code> in one proof that causes problems.  I have not inspected the others yet: I'll try to find some time tomorrow</p>",
        "id": 223278152,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611083795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/(comm_)semiring.3A.20examples.3F/near/223216361\">said</a>:</p>\n<blockquote>\n<p>Are \"prime semi-ideals\" the correct objects that one should use to make Spec? Or does one look at e.g. surjections from semirings to semi-integral-domains up to  equivalence? Or are these the same thing?</p>\n</blockquote>\n<p>Just one example that can be helpful in the \"easiest\" semiring $N$ of the natural numbers (including zero, of course). There is a unique maximal ideal, which is $N\\{1}$. There are plenty of ideals whose saturation (=kernel of the quotient they generate) are the total ideal. So Spec(N) is huge. On the other hand, one can show that the \"saturated prime ideals\" are only the ones of the form pN, for p a prime number, so the \"saturated spectrum\" of N and the Spec of the integers are \"the same\".</p>",
        "id": 223614996,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1611304790
    },
    {
        "content": "<p>Dear All,</p>\n<p>I managed to push the <code>comm_semiring</code> branch so that it compiles!  The only serious changes happened in file <code>ring_theory/jacobson.lean</code>.  It is my opinion that several further proofs of the file can be simplified and sped up.  However, for the moment, I am happy with the fact that I managed to make it work!</p>\n<p>If anyone wants to take a look, I would be happy to listen to comments and suggestions!</p>",
        "id": 223880103,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611571663
    },
    {
        "content": "<p>More importantly, I would like to know if there is a consensus on whether to replace the definition of <code>ideal</code> to take a <code>comm_semiring</code> base, instead of a <code>comm_ring</code> base.  This branch only changes the definition, but makes no use at all of the more general possibilities.</p>",
        "id": 223880242,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611571740
    },
    {
        "content": "<p>If it all compiles, I don't see any reason why we shouldn't go for it</p>",
        "id": 223880640,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611571972
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/tree/comm_semiring\">branch#comm_semiring</a></p>",
        "id": 223881256,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611572359
    },
    {
        "content": "<p>Very well, so I will make a PR out of it and see what happens!</p>",
        "id": 223881584,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611572534
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/5879\">#5879</a></p>\n<p>Bors seems to think that there are no issues!</p>",
        "id": 223882301,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611573045
    },
    {
        "content": "<p>On a related note, there are a bunch of places where assuming <a href=\"https://leanprover-community.github.io/mathlib_docs/find/integral_domain\">docs#integral_domain</a> pulls in a <code>comm_ring</code> requirement where really only <code>comm_semiring</code> or even just <code>semiring</code> is needed. I've cleaned a few of those up in <a href=\"https://github.com/leanprover-community/mathlib/issues/5877\">#5877</a>. I imagine most of the uses of <code>[integral_domain R]</code> in mathlib are overly strict.</p>",
        "id": 223912527,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611588579
    },
    {
        "content": "<p>I am very happy that you are doing this change, Eric!  I also think that most of the time that there is an assumption of <code>integral_domain</code>, simply knowing that multiplication by a non-zero element is injective would suffice!</p>",
        "id": 223919989,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611591279
    },
    {
        "content": "<p>Ah, unfortunately we don't have a typeclass that combines <code>semiring</code> with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cancel_monoid_with_zero\">docs#cancel_monoid_with_zero</a> without taking on extra assumptions as well</p>",
        "id": 223920160,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611591355
    },
    {
        "content": "<p>I think that there was a discussion of <code>semidomain</code> at some point... I did not manage to work on it, though.  Let me see if I can find it!</p>\n<p><a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/left.2Fright.20cancelative.20semiring\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/left.2Fright.20cancelative.20semiring</a></p>",
        "id": 223924210,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611592761
    },
    {
        "content": "<p>About the <code>comm_semiring</code> change to <code>ideal</code>: it compiled!  I feel very proud!  <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 223924412,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611592843
    },
    {
        "content": "<p>Yeah that is a really cool refactor. The thing that comes up now and again though is the fact that we don't have ideals for non-commutative rings, and that might well be a lot harder. But actually I wonder whether that should even be a refactor. There is no such thing as an ideal of a non-commutative ring, there's a left ideal, a right ideal and a bi-ideal.</p>",
        "id": 223937103,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611598157
    },
    {
        "content": "<p>The refactor would be to define <code>ideal</code> as the bi-ideal of a non-necessarily commutative ring, I think</p>",
        "id": 223937855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611598513
    },
    {
        "content": "<p>Since when the ring is commutative, the bi-ideal and ideal coincide, right?</p>",
        "id": 223937881,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611598532
    },
    {
        "content": "<p>I still think what I said above: an <code>ideal</code> should be a left ideal (because the definition is the same as in the commutative case), a right ideal shouldn't exist (it's a left ideal in the opposite ring), and a bi-ideal should be a different definition</p>",
        "id": 223938012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611598581
    },
    {
        "content": "<p>in a commutative ring all three concepts converge</p>",
        "id": 223938118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611598630
    },
    {
        "content": "<p>I agree, except that I don't know if right ideals shouldn't exist. After all we also have <code>sup</code> and <code>inf</code>...</p>",
        "id": 223938139,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611598639
    },
    {
        "content": "<p>and <code>order_dual</code></p>",
        "id": 223938158,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611598648
    },
    {
        "content": "<p>I think we should try to avoid mentioning them until they become necessary for something</p>",
        "id": 223938203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611598672
    },
    {
        "content": "<p>and if that means they never get defined, great</p>",
        "id": 223938235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611598682
    },
    {
        "content": "<p>sup and inf are actually useful, this is more like mul and opposite-mul</p>",
        "id": 223938471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611598770
    },
    {
        "content": "<p>Do we have submodules of a non-commutative R-module? Those will be left ideals I guess.</p>",
        "id": 223939296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611599135
    },
    {
        "content": "<p>I don't think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule\">docs#submodule</a> requires commutativity (so yes)</p>",
        "id": 223939451,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611599203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/(comm_)semiring.3A.20examples.3F/near/223938203\">said</a>:</p>\n<blockquote>\n<p>I think we should try to avoid mentioning them until they become necessary for something</p>\n</blockquote>\n<p>I think the only circumstance where I really would want to define right-submodules is if it's a more useful way to define bi-submodules</p>",
        "id": 223939880,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1611599376
    },
    {
        "content": "<p>I will keep in mind the <code>comm_semiring</code>/<code>semiring</code> issue while refactoring.  I agree that getting left-ideals should be easy.</p>\n<p>I also agree with Mario that I would add right ideals on a need-to-use basis: duplicating code is a lengthy and imprecise process.  My experience of working with dual/opposites is limited and unsuccessful.  For this reason, I would either try to avoid right ideals, or duplicate the needed lemmas only.  Of course, if someone else is able to make Lean understand the companion version of every lemma, that would be awesome!</p>",
        "id": 223993291,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611631375
    },
    {
        "content": "<p>Jumping into this discussion without too much context, have you considered defining subbimodules and then having a left (resp. right) ideal of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> be a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(R,\\mathbb{Z})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mclose\">)</span></span></span></span>-submodule (resp. a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Z</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathbb{Z},R)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>-submodule), where an ideal is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(R,R)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>-submodule?  It's not uncommon needing to deal with left and right ideals simultaneously (one example is left and right annihilators of right and left ideals in Frobenius algebras).  It's also useful being able to consider relationships between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(R,\\mathbb{Z})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mclose\">)</span></span></span></span>-submodules and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">,</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(R,A)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span>-submodules for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> a subring of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, so, when possible, it might be worth generalizing statements about left ideals to ones where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> can be anything.  Doing this also all sounds like a lot more work with no immediate benefit, so take it with a grain of salt. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 224245104,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1611780566
    },
    {
        "content": "<p>Continuing with the refactor, I have now changed many lemmas in <code>ring_theory/ideal/basic</code> so that they use <code>comm_semiring</code> instead of <code>comm_ring</code>.</p>\n<p>Besides removing assumptions from further \"easy\" lemmas, the main sticking point is going to be dealing with quotients.  As I have not really given the issue of quotients in a <code>comm_semiring</code> much thought, I will not start doing this anytime soon.  However, from the discussion above, it seems that <span class=\"user-mention\" data-user-id=\"315546\">@Xavier Xarles</span> and <span class=\"user-mention\" data-user-id=\"254058\">@Marc Masdeu</span> have been working on this.  I hope that this refactor will be useful to them!</p>\n<p>PR <a href=\"https://github.com/leanprover-community/mathlib/issues/5954\">#5954</a></p>",
        "id": 224477410,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611930558
    },
    {
        "content": "<p>In commutative ring theory the correct thing to quotient out by is an ideal. In semiring theory this is no longer the case, I suspect, so maybe it's easiest just to leave the quotients alone.</p>",
        "id": 224477744,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611930716
    },
    {
        "content": "<p>I don't think we have normal submonoids, and this is probably for the same reason.</p>",
        "id": 224477860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611930755
    },
    {
        "content": "<p>There's a general notion of \"congruence relations\" (I can't remember the name right now...) in the context of universal algebra which tells you exactly what the condition on a relation you need so that the quotient inherits the algebraic structure. This is the thing that one has to use for quotients of objects like semirings and monoids.</p>",
        "id": 224478055,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611930836
    },
    {
        "content": "<p>I don't know if you did the prime ideals part. The proof of maximal implies prime needs to be redone: Marc and myself have a wrote a proof with lean that work for any comm_semiring. <br>\nAbout quotients, there are some dificulties as quotients with respect to a ideal in comm_semirings  can be defined, but the standard way is to do it through \"congruences\", that is one of the things we are doing.</p>",
        "id": 224478137,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1611930855
    },
    {
        "content": "<p>Kyle, did I understand correctly that you would like to also remove the commutative assumption on the ring?  I like the idea of removing it, however, out of prejudice, I think that it might be easier to first get rid of additive inverses and then to go with non-commutativity.  Do you agree?</p>",
        "id": 224478185,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611930876
    },
    {
        "content": "<p>We have congruence relations on monoids in mathlib.</p>",
        "id": 224478256,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611930912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315546\">@Xavier Xarles</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 224478277,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611930924
    },
    {
        "content": "<p>Xavier, I also have rewritten that proof: it is contained in the current PR <a href=\"https://github.com/leanprover-community/mathlib/issues/5954\">#5954</a> (which is not in mathlib, and is building at the moment).</p>",
        "id": 224478296,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611930933
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/(comm_)semiring.3A.20examples.3F/near/224478256\">said</a>:</p>\n<blockquote>\n<p>We have congruence relations on monoids in mathlib.</p>\n</blockquote>\n<p>Yes, that's what we used.</p>",
        "id": 224478329,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1611930947
    },
    {
        "content": "<p>Ok, great <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 224478484,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611931001
    },
    {
        "content": "<p>Kevin, I agree with you.  For the moment, I do not plan to touch quotients!</p>",
        "id": 224478555,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611931034
    },
    {
        "content": "<p>Oh, and the so-called <code>ring_quot</code> in mathlib <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_quot\">docs#ring_quot</a> is actually a <code>semiring_quot</code>.</p>",
        "id": 224478895,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611931191
    },
    {
        "content": "<p>One thing that I noticed is that a local ring is defined to be one for which either for every <code>a</code> in the ring, <code>a</code> or <code>1-a</code> is a unit.  While I do not know if <code>local_semiring</code> are useful, the <em>definition</em> would also apply to <code>comm_semiring</code>s if we required <code>a</code> or <code>1+a</code> to be a unit.</p>\n<p>This definition is equivalent to the given one for <code>comm_ring</code>s.  What do people think of replacing the <code>-</code> by a <code>+</code> in </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">local_ring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">nontrivial</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- old</span>\n<span class=\"c1\">-- (is_local : ∀ (a : α), (is_unit a) ∨ (is_unit (1 - a)))</span>\n<span class=\"c1\">-- candidate</span>\n<span class=\"o\">(</span><span class=\"n\">is_local</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">is_unit</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 224480409,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611931842
    },
    {
        "content": "<p>You can say that for all <code>a b</code> such that <code>1 = a + b</code>, at least one of <code>a</code> or <code>b</code> is a unit.</p>",
        "id": 224480503,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611931893
    },
    {
        "content": "<p>That would be more symmetric.</p>",
        "id": 224480510,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611931899
    },
    {
        "content": "<p>And IMO this definition makes sense from the point of view of localizations of semirings</p>",
        "id": 224480691,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611931976
    },
    {
        "content": "<p>Adam, I like your definition, but I wonder whether using two variables summing to one is \"Lean-better\" than having a single variable.  As you know much more about Lean than I do, I defer this to you!</p>",
        "id": 224480967,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611932118
    },
    {
        "content": "<p>This suggestion is from my mathematical taste, not really from my experience with lean ::)</p>",
        "id": 224481236,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611932229
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> what do you think?</p>",
        "id": 224481321,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611932261
    },
    {
        "content": "<p>I don't care what the definition says as long as anyone who fiddles with it reproves all of the API.</p>",
        "id": 224484684,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611933541
    },
    {
        "content": "<p>And if the new proofs turn out to be twice as long you might have a hard job convincing the maintainers that this is a move in the right direction. However I suspect this will not happen -- the new proofs will probably be about the same size as the old ones</p>",
        "id": 224485016,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611933657
    },
    {
        "content": "<p>Damiano, if you're amused by the definition of local ring, I have this vague memory that lean's definition of a local homomorphism doesn't assume that the source and target are local</p>",
        "id": 224485311,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611933740
    },
    {
        "content": "<p>Of course it coincides with the correct definition when they are</p>",
        "id": 224485387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611933768
    },
    {
        "content": "<p>A nice summary of the local homomorphism story is \"email from Buzzard to Conrad and de Jong\", I'll dig it out</p>",
        "id": 224485518,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611933819
    },
    {
        "content": "<p>Whenever I hear these things, it always makes me wonder what it means that you develop an \"intuition\" for mathematical concepts, when these concepts are then so far from what you actually use in implications...</p>",
        "id": 224485694,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611933872
    },
    {
        "content": "<p>I don't know if you're into to this kind of thing <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> , but you might be able to get some intuition from this paper:<br>\n<a href=\"https://doi.org/10.1016/0021-8693%2877%2990284-8\">https://doi.org/10.1016/0021-8693%2877%2990284-8</a></p>",
        "id": 224488389,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611934828
    },
    {
        "content": "<p>(see e.g. the bottom of page 242 for the \"definition\" of a \"local ring\")</p>",
        "id": 224488793,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1611934977
    },
    {
        "content": "<blockquote>\n<p>A local ring homomorphism is usually defined in the books as f:R-&gt;S such that f(m_R) is a subset of m_S. The person who typed this definition into Lean went with the logically equivalent statement that if f(r) is a unit, then r is a unit. The linter immediately observed that the assumption that R and S were local was superfluous and this was a definition which made sense for an arbitrary ring homomorphism. OK. So it's the same situation -- the definition of local ring hom in Lean now doesn't assume that R and S are local, it just says that f is a ring hom such that if f(r) is a unit then r is a unit.</p>\n<p>So yesterday I was doing some stuff with multivariable polynomials, and I changed a bit the proof that if A and B were local, and f:A-&gt;B was a local homomorphism then so was the induced ring hom A[[X]]-&gt;B[[X]] (here X can be a set of variables if you like). I was amused that the linter then complained about this lemma! It claimed that I didn't need A or B to be local in my proof. And indeed it's right -- an element of a power series ring is a unit iff the constant term is a unit.</p>\n<p>I then mentioned this to Johan Commelin and Kenny Lau (two other Lean people interested in alg geom; Kenny is an UG at Imperial and Johan a post-doc in Freiburg). Some random thoughts came out of this. Any inclusion of number fields gives an inclusion of rings of integers which is a \"local ring hom\" in the above sense. More generally any injective integral extension is a local ring hom (I'm pretty sure I've seen this proof before recently, maybe it comes up in the proof of the Nullstellensatz?). If Spec(f): Spec(S)-&gt;Spec(R) is surjective then f is a local ring hom. Then we found this: <a href=\"https://stacks.math.columbia.edu/tag/00GQ\">https://stacks.math.columbia.edu/tag/00GQ</a>, so clearly the idea has come up before. Is this concept of being a local ring hom, in the non-local setting, useful in some way? Discovered by a computer :-) Presumably discovered by a human first? I think a logician might say something like \"f reflects units\" or something?</p>\n</blockquote>",
        "id": 224495211,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611937065
    },
    {
        "content": "<p>De Jong's reponse:</p>\n<blockquote>\n<p>Comments: (1) if k is a field and f : k[x_1, \\ldots, x_n] ---&gt; k[y_1,<br>\n..., y_m] is a k-algebra map, then f is \"local\" in your sense if and<br>\nonly if f(x_1), ..., f(x_n) are algebraically independent. (2) If A =<br>\nGamma(C, O_X) where C is an affine smooth curve over a field and if B<br>\n= Gamma(C - P, O_C) where P is a closed point on C which has infinite<br>\norder in the class group of C then A ---&gt; B is \"local\" in your sense.</p>\n<p>There are many ways that we could have generalized \"local homomorphism<br>\nof local rings\" to ring maps. For example given f : R ---&gt; S we could<br>\nask</p>\n<p>(a) f reflects units (what you said)<br>\n(b) the image of Spec(f) contains all closed points<br>\n(c) Spec(f) sends closed points to closed points</p>\n<p>Observe that (b) implies (a). If I had to make a definition which<br>\napplies to general rings I might have chosen the condition \"(b) +<br>\n(c)\". But I understand that when formalizing it is very natural to<br>\nchoose (a).</p>\n</blockquote>",
        "id": 224495640,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1611937211
    },
    {
        "content": "<p>Dear Kevin,</p>\n<p>thank you very much for digging this conversation out: it is very interesting!</p>",
        "id": 224535181,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1611955162
    }
]
[
    {
        "content": "<p>Can we compose a list of functions? Would this have any use?</p>",
        "id": 205819136,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596473943
    },
    {
        "content": "<p>Currently we can only compose two functions</p>",
        "id": 205819188,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596473957
    },
    {
        "content": "<p>and n times if the domain and codomain happen to be the same</p>",
        "id": 205819205,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596473969
    },
    {
        "content": "<p>Cant you just do a list.fold with \\circ, or something like this?</p>",
        "id": 205819261,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596473996
    },
    {
        "content": "<p>what's the type of the list?</p>",
        "id": 205819318,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596474005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/116395-maths/topic/composing.20a.20list.20of.20functions/near/205819318\">said</a>:</p>\n<blockquote>\n<p>what's the type of the list?</p>\n</blockquote>\n<p>exactly</p>",
        "id": 205820791,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596474708
    },
    {
        "content": "<p>There must be something like heterogeneous lists right?</p>",
        "id": 205821960,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596475299
    },
    {
        "content": "<p>And it should be <code>traversable</code> so you should be able to fold over it.</p>",
        "id": 205821984,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596475312
    },
    {
        "content": "<p>Maybe traversable isn't the right term here....</p>",
        "id": 205822262,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596475443
    },
    {
        "content": "<p><a href=\"https://hackage.haskell.org/package/thrist-0.4/docs/Data-Thrist.html\">https://hackage.haskell.org/package/thrist-0.4/docs/Data-Thrist.html</a><br>\n<a href=\"https://ncatlab.org/nlab/show/free+category\">https://ncatlab.org/nlab/show/free+category</a></p>",
        "id": 205822284,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596475454
    },
    {
        "content": "<p>I tried writing a heterogeneous list type, and decided that it wouldn't actually serve the purposes people want for it very well</p>",
        "id": 205826473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596477702
    },
    {
        "content": "<p>It's better to just use iterated <code>prod</code> if you want a strongly typed heterogeneous list</p>",
        "id": 205826616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596477764
    },
    {
        "content": "<p>For composing lists of functions, the solution is to use <code>comp</code> several times</p>",
        "id": 205826792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596477844
    },
    {
        "content": "<p>If you want a type erased heterogeneous list you can use <code>list (Sigma A, A)</code> but I'm not really sure what this would be good for</p>",
        "id": 205826948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596477931
    },
    {
        "content": "<p>ok maybe I should talk about a potential use case to make this more clear</p>",
        "id": 205837652,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596483255
    },
    {
        "content": "<p>I want to be able to state (and certainly prove) the statement that a functor from <code>[n] = {0 -&gt; 1 -&gt; ... -&gt; n}</code> to any category <code>C</code> is the same as <code>n</code> composable morphisms in <code>C</code></p>",
        "id": 205837719,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596483305
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/composing.20a.20list.20of.20functions/near/205826792\">said</a>:</p>\n<blockquote>\n<p>For composing lists of functions, the solution is to use <code>comp</code> several times</p>\n</blockquote>\n<p>do you mean that if we have 3 functions then we use <code>comp</code> twice? this sounds like it can't work for an arbitrary <code>n</code>, but I might be misunderstanding your suggestion</p>",
        "id": 205837787,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596483359
    },
    {
        "content": "<p>Are you defining the nerve?</p>",
        "id": 205838060,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596483497
    },
    {
        "content": "<p>indeed!</p>",
        "id": 205838087,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596483516
    },
    {
        "content": "<p>Cool!</p>",
        "id": 205838095,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596483520
    },
    {
        "content": "<p>Presumably you can define the simplicial set by induction on n, no?</p>",
        "id": 205838174,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596483570
    },
    {
        "content": "<p>you don't need induction right</p>",
        "id": 205838203,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596483590
    },
    {
        "content": "<p><code>def nerve (C) := \\la n, [n] \\func C</code></p>",
        "id": 205838265,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596483608
    },
    {
        "content": "<p>(pseudocode)</p>",
        "id": 205838289,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596483626
    },
    {
        "content": "<p>Yeah, sure, but I want to exploit the fact that this simplicial set has some horn filling properties :)</p>",
        "id": 205838314,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596483642
    },
    {
        "content": "<p>what's horn filling properties and how does defining <code>nerve</code> inductively exploits that?</p>",
        "id": 205838408,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596483715
    },
    {
        "content": "<p>It seems to me like you want to prove that <code>[n]</code> is the free category on the graph <code>0 -&gt; 1 -&gt; ... -&gt; n</code></p>",
        "id": 205838562,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596483828
    },
    {
        "content": "<p><del>defining</del> constructing the free category sounds like a cool project</p>",
        "id": 205838761,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596483928
    },
    {
        "content": "<p><a href=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/graphs/category.lean\">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/graphs/category.lean</a></p>",
        "id": 205838961,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596484041
    },
    {
        "content": "<p>aha, inductive</p>",
        "id": 205839226,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596484152
    },
    {
        "content": "<p>can one even state \"a list of composable morphisms\"? it might have to be a type with <code>nat.rec</code> again, like I made before</p>",
        "id": 205839286,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596484182
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/Canonical.20inductive.20types.20with.200.2C1.2C2.2C3.2C4.20terms/near/204653480\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Canonical.20inductive.20types.20with.200.2C1.2C2.2C3.2C4.20terms/near/204653480</a></p>",
        "id": 205839359,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596484204
    },
    {
        "content": "<p>Isn't that what <code>morphism_path</code> in the link above is?</p>",
        "id": 205839362,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596484204
    },
    {
        "content": "<p>I guess it is</p>",
        "id": 205839391,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596484216
    },
    {
        "content": "<p>Another option is trees of (formal) compositions modulo associativity</p>",
        "id": 205839540,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596484303
    },
    {
        "content": "<p>&amp; unitality</p>",
        "id": 205839552,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596484310
    },
    {
        "content": "<p>this is syntax vs semantics again: I don't know how to put it into words, but it's sort of the difference between saying that the inductive implementation is <code>list</code> vs a function from <code>fin n</code> is a list</p>",
        "id": 205839615,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596484326
    },
    {
        "content": "<p>if it quacks like a list, then it's a list</p>",
        "id": 205839624,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596484332
    },
    {
        "content": "<p>right, so there's a second presentation of categories which doesn't use dependent types but rather a type of objects and a type of (all) morphisms</p>",
        "id": 205839701,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596484372
    },
    {
        "content": "<p>then you could consider a list of morphisms together with a bunch of equations that say the intermediate objects line up</p>",
        "id": 205839753,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596484395
    },
    {
        "content": "<p>I suspect if you consider the nerve for long enough, you'll be sort of forced into this perspective anyways</p>",
        "id": 205839794,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596484417
    },
    {
        "content": "<p>I keep having the illusion that objects have some \"internal representation\", that the <code>inductive</code> and the function from <code>fin n</code> have some sort of difference</p>",
        "id": 205839949,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596484485
    },
    {
        "content": "<p>Mathlib should really have categories internal to other categories :)</p>",
        "id": 205841852,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596485577
    },
    {
        "content": "<p><a href=\"https://github.com/b-mehta/topos/blob/master/src/internal_category%20copy.lean\">https://github.com/b-mehta/topos/blob/master/src/internal_category%20copy.lean</a> Feel free to tidy this and PR it if you want :)</p>",
        "id": 205841912,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596485614
    },
    {
        "content": "<p>i'm pretty sure it compiles on the latest mathlib</p>",
        "id": 205841937,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596485632
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> what's an example of an internal category?</p>",
        "id": 205842134,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596485752
    },
    {
        "content": "<p>A category is an internal category in types :)</p>",
        "id": 205842196,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596485766
    },
    {
        "content": "<p>(At least in the way Reid mentioned above)</p>",
        "id": 205842223,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596485782
    },
    {
        "content": "<p>apart from that, I guess</p>",
        "id": 205842242,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596485798
    },
    {
        "content": "<p>a two-term chain complex is a category internal to abelian groups</p>",
        "id": 205842346,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596485858
    },
    {
        "content": "<p>normally though you'd look at categories internal to say topological spaces</p>",
        "id": 205843260,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596486349
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> In case you find this helpful:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">category</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">arrow</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">composable_things</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">arrow</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">n</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"c1\">-- wrong</span>\n</code></pre></div>",
        "id": 205853030,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596492492
    },
    {
        "content": "<p>Wait, I may have gotten the fin.succ's wrong.</p>",
        "id": 205853089,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596492560
    },
    {
        "content": "<p>This is probably better:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">composable_things</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">arrow</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">n</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">right</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 205853220,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596492633
    },
    {
        "content": "<p>we will certainly run into <code>eq.rec</code> hell if we do this</p>",
        "id": 205874307,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596518467
    },
    {
        "content": "<p>but there seems no other way</p>",
        "id": 205874309,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596518473
    },
    {
        "content": "<p>I've used something like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">composable_morphisms&#39;</span>\n  <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">composable_morphisms&#39;</span> <span class=\"n\">X</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">composable_morphisms&#39;</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"n\">composable_morphisms&#39;</span> <span class=\"n\">X</span>\n\n<span class=\"n\">def</span> <span class=\"n\">composable_morphisms</span> <span class=\"o\">:=</span> <span class=\"err\">Σ</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">composable_morphisms&#39;</span> <span class=\"n\">V</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 205874534,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596518885
    },
    {
        "content": "<p>yeah that sounds like a good idea</p>",
        "id": 205874620,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596519083
    },
    {
        "content": "<p>might be better to parameterise by both endpoints, for the sake of composition</p>",
        "id": 205876507,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596521908
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> this is what I have now, in my livestream:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- A list of composable functions -/</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">list_fun</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list_fun</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">list_fun</span> <span class=\"n\">γ</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list_fun</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">nil</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs</span><span class=\"o\">)</span> <span class=\"n\">nil</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- The composition of a list of composable functions.</span>\n<span class=\"cm\">Set up so that `comp (f :: g :: nil) = f ∘ g`. -/</span>\n<span class=\"n\">def</span> <span class=\"n\">comp</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">},</span> <span class=\"n\">list_fun</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">comp</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_nil</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">α</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_cons</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- Concatenation of two lists of composable functions. -/</span>\n<span class=\"n\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">},</span> <span class=\"n\">list_fun</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">list_fun</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">list_fun</span> <span class=\"n\">α</span> <span class=\"n\">γ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span>         <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"n\">L₂</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">L₁</span><span class=\"o\">)</span> <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">append</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span><span class=\"o\">)</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">L₁</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L₂</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">L₁</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"n\">L₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">=</span> <span class=\"n\">L₁</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"err\">∘</span> <span class=\"n\">L₂</span><span class=\"bp\">.</span><span class=\"n\">comp</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span>         <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">L₁</span><span class=\"o\">)</span> <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">((</span><span class=\"err\">∘</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"n\">comp_append</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">list_fun</span>\n</code></pre></div>",
        "id": 205876824,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596522321
    },
    {
        "content": "<p>Looks great, except that you could make it category polymorphic trivially, and get the current behaviour substituting <code>Type</code> for <code>C</code>. :-)</p>",
        "id": 205876901,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596522431
    },
    {
        "content": "<p>right</p>",
        "id": 205876912,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596522463
    },
    {
        "content": "<p>where in the category library should this go?</p>",
        "id": 205876914,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596522469
    },
    {
        "content": "<p>I guess <code>comp_append</code> would be harder.</p>",
        "id": 205876956,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596522483
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 205876962,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596522494
    },
    {
        "content": "<p>but I just proved <code>comp_append</code></p>",
        "id": 205876971,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596522509
    },
    {
        "content": "<p>oh, you mean for categories</p>",
        "id": 205876976,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596522523
    },
    {
        "content": "<p>Yes. Harder, but still easy. :-)</p>",
        "id": 205876992,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596522551
    },
    {
        "content": "<p>Just make a new file in <code>category_theory/</code>?</p>",
        "id": 205876999,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596522566
    },
    {
        "content": "<p>with the same name as <code>lift_fun</code>, or whatever you call it?</p>",
        "id": 205877011,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596522593
    },
    {
        "content": "<p>I'll add <code>TODO: port every lemma about list ever (except the permutation part!)</code></p>",
        "id": 205877076,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596522636
    },
    {
        "content": "<p><code>comp list.repeat = nat.iterate</code>!</p>",
        "id": 205877086,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596522659
    },
    {
        "content": "<p>oh right, and prove that this is the same as a functor from fin n+1 to C</p>",
        "id": 205877100,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596522682
    },
    {
        "content": "<p>and the equivalence with the subtype of <code>list (arrow C)</code> satisfying some <code>pairwise</code> condition</p>",
        "id": 205877556,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596523285
    },
    {
        "content": "<p>if I define <code>cons f L</code> then I lose analogy with category; if I define <code>cons L f</code> then I lose analogy with functions...</p>",
        "id": 205877753,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596523561
    },
    {
        "content": "<p>the category theory composition is the opposite of functions iirc</p>",
        "id": 205877800,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596523580
    },
    {
        "content": "<p>Shall we switch the order in <code>category_theory/</code>? :-)</p>",
        "id": 205877831,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596523656
    },
    {
        "content": "<p>I'm not sure it matters particularly; just pick whichever order feels most ergonomic locally.</p>",
        "id": 205877881,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596523692
    },
    {
        "content": "<p>I guess we want <code>(cons f L).comp = f &gt;&gt; L</code>?</p>",
        "id": 205877995,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596523843
    },
    {
        "content": "<p>you know what, I'll just make it so that <code>(cons f L).comp = L.comp &gt;&gt; f</code>, who cares</p>",
        "id": 205878378,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596524403
    },
    {
        "content": "<p>just to make the inductive require one argument less</p>",
        "id": 205878391,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596524412
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> is this ok?</p>",
        "id": 205878428,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596524477
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">category</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- A list of composable functions -/</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">list_fun</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">X</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"err\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list_fun</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">list_fun</span> <span class=\"n\">Z</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list_fun</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- The composition of a list of composable functions.</span>\n<span class=\"cm\">Set up so that `comp (f :: g :: nil) = (𝟙 ≫ g) ≫ f`. -/</span>\n<span class=\"n\">def</span> <span class=\"n\">comp</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">Y</span><span class=\"o\">},</span> <span class=\"n\">list_fun</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"mi\">𝟙</span> <span class=\"n\">X</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"err\">≫</span> <span class=\"n\">f</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">list_fun</span>\n</code></pre></div>",
        "id": 205878439,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596524500
    },
    {
        "content": "<p>turns out <code>comp_append</code> wasn't hard:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Copyright (c) 2020 Kenny Lau. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Kenny Lau</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">category</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Lists of Composable Morphisms</span>\n\n<span class=\"cm\">In this file we define lists of composable morphisms, and their composition.</span>\n\n<span class=\"cm\">We also show that a list of composable morphism is the same as a functor from `[n]`</span>\n<span class=\"cm\">(the category `0 ⟶ 1 ⟶ ... ⟶ n`) to the category.</span>\n\n<span class=\"cm\">## Main Definitions</span>\n\n<span class=\"cm\">- `list_fun X Y` where `X, Y : C` for some category `C` is a list of composable morphisms starting</span>\n<span class=\"cm\">from `X` and ending at `Y`.</span>\n\n<span class=\"cm\">- `list_fun.comp L` where `L : list_fun X Y` returns the composition as a morphism `X ⟶ Y`.</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- TODO: port every lemma about list ever</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- A list of composable functions -/</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">list_fun</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">X</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"err\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list_fun</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">list_fun</span> <span class=\"n\">Z</span>\n\n<span class=\"kn\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">list_fun</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list_fun</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- The composition of a list of composable functions.</span>\n<span class=\"cm\">Set up so that `comp (f :: g :: nil) = (𝟙 ≫ g) ≫ f`. -/</span>\n<span class=\"n\">def</span> <span class=\"n\">comp</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">Y</span><span class=\"o\">},</span> <span class=\"n\">list_fun</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"mi\">𝟙</span> <span class=\"n\">X</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"err\">≫</span> <span class=\"n\">f</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_nil</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">X</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟙</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_cons</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"err\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">=</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"err\">≫</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- Concatenation of two lists of composable functions. -/</span>\n<span class=\"n\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">Z</span><span class=\"o\">},</span> <span class=\"n\">list_fun</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">list_fun</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">list_fun</span> <span class=\"n\">X</span> <span class=\"n\">Z</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span>         <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"n\">L₂</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">L₁</span><span class=\"o\">)</span> <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">append</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span><span class=\"o\">)</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">nil_append</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nil</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"n\">L</span> <span class=\"bp\">=</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">cons_append</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"err\">⟶</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L₁</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L₂</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">L₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"n\">L₂</span> <span class=\"bp\">=</span> <span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">L₁</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"n\">L₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_append</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">L₁</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L₂</span> <span class=\"o\">:</span> <span class=\"n\">list_fun</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">L₁</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"n\">L₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">=</span> <span class=\"n\">L₂</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"err\">≫</span> <span class=\"n\">L₁</span><span class=\"bp\">.</span><span class=\"n\">comp</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span>         <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">comp_nil</span><span class=\"o\">,</span> <span class=\"n\">nil_append</span><span class=\"o\">,</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">comp_id</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">L₁</span><span class=\"o\">)</span> <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cons_append</span><span class=\"o\">,</span> <span class=\"n\">comp_cons</span><span class=\"o\">,</span> <span class=\"n\">comp_cons</span><span class=\"o\">,</span> <span class=\"n\">comp_append</span><span class=\"o\">,</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">list_fun</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">category_theory</span>\n</code></pre></div>",
        "id": 205878782,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596524887
    },
    {
        "content": "<p>presumably rename <code>list_fun</code> to <code>list_hom</code>?</p>",
        "id": 205878865,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596525007
    },
    {
        "content": "<p>done</p>",
        "id": 205879154,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596525419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> what sort of structure does <code>list_hom</code> form, given <code>append</code> and <code>map</code>?</p>",
        "id": 205879163,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596525433
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">map</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">},</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">list_hom</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 205879169,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596525442
    },
    {
        "content": "<p>I think <code>list_hom</code> is just the free category on a <code>category_struct</code>.</p>",
        "id": 205879240,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596525512
    },
    {
        "content": "<p>so maybe you could set it up as a functor from <code>Graph</code> to <code>Cat</code>, adjoint to the forgetful functor?</p>",
        "id": 205879281,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596525599
    },
    {
        "content": "<p>is graph in mathlib?</p>",
        "id": 205880039,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596526508
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span></p>",
        "id": 205880047,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596526527
    },
    {
        "content": "<p>Even if someone had \"put graphs in mathlib\" the chances that they would be the kind of graph you wanted is i guess low</p>",
        "id": 205880158,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596526670
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">functor</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">[]</span>    <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map</span>       <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"err\">⟶</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">map_id&#39;</span>   <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_comp&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"err\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"err\">≫</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"err\">≫</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 205880246,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596526790
    },
    {
        "content": "<p>you don't need C and D to be a category! ;)</p>",
        "id": 205880254,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596526802
    },
    {
        "content": "<p>oh what am I doing, generalizing category theory itself</p>",
        "id": 205880422,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596526958
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Copyright (c) 2020 Kenny Lau. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Kenny Lau</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">functor_category</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Lists of Composable Morphisms</span>\n\n<span class=\"cm\">In this file we define lists of composable morphisms, and their composition.</span>\n\n<span class=\"cm\">We also show that a list of composable morphism is the same as a functor from `[n]`</span>\n<span class=\"cm\">(the category `0 ⟶ 1 ⟶ ... ⟶ n`) to the category.</span>\n\n<span class=\"cm\">## Main Definitions</span>\n\n<span class=\"cm\">- `list_hom X Y` where `X, Y : C` for some category `C` is a list of composable morphisms starting</span>\n<span class=\"cm\">from `X` and ending at `Y`.</span>\n\n<span class=\"cm\">- `list_hom.comp L` where `L : list_hom X Y` returns the composition as a morphism `X ⟶ Y`.</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- TODO: port every lemma about list ever</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- A list of composable functions -/</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">list_hom</span> <span class=\"o\">[</span><span class=\"n\">has_hom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u₁</span> <span class=\"n\">v₁</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span>  <span class=\"o\">:</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"err\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list_hom</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">list_hom</span> <span class=\"n\">Z</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list_hom</span>\n\n<span class=\"kn\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">has_hom</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">has_hom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_hom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- Concatenation of two lists of composable functions. -/</span>\n<span class=\"n\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">Z</span><span class=\"o\">},</span> <span class=\"n\">list_hom</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">Z</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span>       <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"n\">L₂</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"n\">L₁</span><span class=\"o\">)</span> <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"o\">(</span><span class=\"n\">append</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span><span class=\"o\">)</span>\n\n<span class=\"kn\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">++</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">append</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">nil_append</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nil</span> <span class=\"bp\">++</span> <span class=\"n\">L</span> <span class=\"bp\">=</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">cons_append</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"err\">⟶</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L₁</span> <span class=\"o\">:</span> <span class=\"n\">list_hom</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L₂</span> <span class=\"o\">:</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"n\">L₁</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">L₂</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"o\">(</span><span class=\"n\">L₁</span> <span class=\"bp\">++</span> <span class=\"n\">L₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">has_hom</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">category_struct</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">category_struct</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category_struct</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- The composition of a list of composable functions.</span>\n<span class=\"cm\">Set up so that `comp (f :: g :: nil) = (𝟙 ≫ g) ≫ f`. -/</span>\n<span class=\"n\">def</span> <span class=\"n\">comp</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">Y</span><span class=\"o\">},</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span>      <span class=\"o\">:=</span> <span class=\"mi\">𝟙</span> <span class=\"n\">X</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"err\">≫</span> <span class=\"n\">f</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_nil</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟙</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_cons</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"err\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">=</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"err\">≫</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">category_struct</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">category</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_append</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">L₁</span> <span class=\"o\">:</span> <span class=\"n\">list_hom</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L₂</span> <span class=\"o\">:</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">L₁</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"n\">L₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"bp\">=</span> <span class=\"n\">L₂</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"err\">≫</span> <span class=\"n\">L₁</span><span class=\"bp\">.</span><span class=\"n\">comp</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span>       <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">comp_nil</span><span class=\"o\">,</span> <span class=\"n\">nil_append</span><span class=\"o\">,</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">comp_id</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"n\">L₁</span><span class=\"o\">)</span> <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cons_append</span><span class=\"o\">,</span> <span class=\"n\">comp_cons</span><span class=\"o\">,</span> <span class=\"n\">comp_cons</span><span class=\"o\">,</span> <span class=\"n\">comp_append</span><span class=\"o\">,</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"err\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">map</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">},</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">list_hom</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span>      <span class=\"o\">:=</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">map_nil</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">map_cons</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"err\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">map_append</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">L₁</span> <span class=\"o\">:</span> <span class=\"n\">list_hom</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L₂</span> <span class=\"o\">:</span> <span class=\"n\">list_hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">L₁</span> <span class=\"bp\">++</span> <span class=\"n\">L₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"n\">L₁</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">F</span> <span class=\"bp\">++</span> <span class=\"n\">L₂</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">F</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"n\">nil</span>       <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">::</span> <span class=\"n\">L₁</span><span class=\"o\">)</span> <span class=\"n\">L₂</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"err\">$</span> <span class=\"n\">map_append</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">category</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">list_hom</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">category_theory</span>\n</code></pre></div>",
        "id": 205880590,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596527136
    },
    {
        "content": "<p>\"maximal generality\"</p>",
        "id": 205880595,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596527139
    },
    {
        "content": "<p>so <code>Func([n], -)</code> is a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"sans-serif\">C</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">t</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"sans-serif\">T</mi><mi mathvariant=\"sans-serif\">y</mi><mi mathvariant=\"sans-serif\">p</mi><mi mathvariant=\"sans-serif\">e</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathsf{Cat} \\to \\mathsf{Type}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">C</span><span class=\"mord mathsf\">a</span><span class=\"mord mathsf\">t</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">T</span><span class=\"mord mathsf\" style=\"margin-right:0.01389em;\">y</span><span class=\"mord mathsf\">p</span><span class=\"mord mathsf\">e</span></span></span></span></span>?</p>",
        "id": 205880678,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596527244
    },
    {
        "content": "<p>aha</p>",
        "id": 205880683,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596527251
    },
    {
        "content": "<p>then list_hom would also have to be one...?</p>",
        "id": 205880695,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596527264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/composing.20a.20list.20of.20functions/near/205880158\">said</a>:</p>\n<blockquote>\n<p>Even if someone had \"put graphs in mathlib\" the chances that they would be the kind of graph you wanted is i guess low</p>\n</blockquote>\n<p>indeed, the most recent PR attempting to put graphs in mathlib implements loopless graphs, but for the category Graph you really ought to allow loops.</p>",
        "id": 205915653,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596552296
    },
    {
        "content": "<p>this makes it, uh, \"cartesian closed\" might be the right word? The graph 1 with one vertex and one edge is a terminal object, and this terminal object gives rise to a sensible notion of point. e.g. there is a good bijection between Hom(1, G^H) and Hom(H, G)</p>",
        "id": 205916390,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596552617
    },
    {
        "content": "<p>Mathlib already has something like a (pre-)graph (whatever that means):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">category</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_hom</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 205917078,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596552921
    },
    {
        "content": "<p>It's certainly possible to take such a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> and construct the free category associated to it.</p>",
        "id": 205917376,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596553055
    }
]
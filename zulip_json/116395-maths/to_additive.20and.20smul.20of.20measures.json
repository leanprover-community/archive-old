[
    {
        "content": "<p>I have a problem with <code>to_additive</code>, which is trying to additivize <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.measure.coe_smul\">docs#measure_theory.measure.coe_smul</a> (smul on measures), which doesn't make sense. And I don't know how to convince it that it shouldn't try (apart of rewriting my proofs separately in the additive and multiplicative setting. Changing the arguments order of <code>coe_smul</code> does not seem to help. <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> , maybe?</p>\n<p>MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.group.basic</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">ennreal</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_haar_measure</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">compact_lt_top</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">is_compact</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"n\">μ</span> <span class=\"n\">K</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_add_haar_measure</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">compact_lt_top</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">is_compact</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"n\">μ</span> <span class=\"n\">K</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">to_additive</span><span class=\"o\">]</span> <span class=\"n\">is_haar_measure</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_haar_measure</span> <span class=\"n\">μ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[to_additive is_add_haar_measure.smul]</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">is_haar_measure.smul</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">cpos</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ctop</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">≠</span> <span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_haar_measure</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">•</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">compact_lt_top</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">K</span> <span class=\"n\">hK</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"k\">have</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"n\">K</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span> <span class=\"o\">:=</span> <span class=\"n\">is_haar_measure.compact_lt_top</span> <span class=\"n\">K</span> <span class=\"n\">hK</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">lt_top_iff_ne_top</span><span class=\"o\">,</span> <span class=\"n\">A.ne</span><span class=\"o\">,</span> <span class=\"n\">ctop</span><span class=\"o\">,</span> <span class=\"n\">measure.coe_smul</span><span class=\"o\">,</span> <span class=\"n\">algebra.id.smul_eq_mul</span><span class=\"o\">,</span>\n      <span class=\"n\">with_top.mul_eq_top_iff</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">,</span> <span class=\"n\">pi.smul_apply</span><span class=\"o\">,</span> <span class=\"n\">and_false</span><span class=\"o\">,</span> <span class=\"n\">false_and</span><span class=\"o\">,</span> <span class=\"n\">or_self</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">measure_theory</span>\n</code></pre></div>",
        "id": 252848063,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1631306778
    },
    {
        "content": "<p>Am I missing something? Are those typeclasses different? Isn't the <code>group</code> argument unused?</p>",
        "id": 252866297,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631318126
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> The actual typeclasses have more axioms.</p>",
        "id": 252878688,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1631331589
    },
    {
        "content": "<p>This is the same issue that came up in <a href=\"https://github.com/leanprover-community/mathlib/issues/9032\">#9032</a>. I'm afraid <code>to_additive</code> needs to be improved for this to work.<br>\n<code>to_additive</code> looks at the first argument of a function to see if it contains a constant type (like <code>ennreal</code>), and will not additivize that function if it does. <br>\nUnfortunately, for <code>pi.has_scalar</code> the relevant argument is the second argument (and we cannot reorder the arguments). I will try to generalize <code>to_additive</code> so that it looks at a (user-specified) <code>n</code>-th argument.</p>\n<p>From the doc:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>* Option 1: It additivized a declaration `d` that should remain multiplicative. Solutions:\n  * Make sure the first argument of `d` is a type with a multiplicative structure. If not, can you\n    reorder the (implicit) arguments of `d` so that the first argument becomes a type with a\n    multiplicative structure (and not some indexing type)?\n    The reason is that `@[to_additive]` doesn't additivize declarations if their first argument\n    contains fixed types like `ℕ` or `ℝ`. See section Heuristics.\n    This is not possible if `d` is something like `pi.has_one` or `prod.group`, where the second\n    argument (also) has a multiplicative structure.\n</code></pre></div>",
        "id": 252883033,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1631336863
    },
    {
        "content": "<p>Still there is something I don't get. The lemma that creates a problem is <code>measure_theory.measure.coe_smul</code> (which has just <code>rfl</code> as a proof, and no <code>to_additive</code> argument). I tried to reorder its arguments to put <code>(c : ennreal)</code> as the first argument, to tell <code>to_additive</code> to ignore it. But this doesn't change anything.</p>",
        "id": 252888154,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1631343003
    },
    {
        "content": "<p>Are you saying that <code>coe_smul</code> is the problem because if you remove that lemma from the proof, it works?<br>\nThe problem is with <code>pi.has_scalar</code>. As you can see in the error message <code>pi.has_scalar</code> is incorrectly additivized:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>type mismatch at application\n  @pi.has_vadd (set G) (λ (ᾰ : set G), ℝ≥0∞) ℝ≥0∞\n    (λ (i : set G),\n       @has_mul.to_has_scalar ℝ≥0∞\n         (@distrib.to_has_mul ℝ≥0∞\n            (@non_unital_non_assoc_semiring.to_distrib ℝ≥0∞\n               (@non_assoc_semiring.to_non_unital_non_assoc_semiring ℝ≥0∞\n                  (@semiring.to_non_assoc_semiring ℝ≥0∞\n                     (@comm_semiring.to_semiring ℝ≥0∞\n                        (@canonically_ordered_comm_semiring.to_comm_semiring ℝ≥0∞\n                           ennreal.canonically_ordered_comm_semiring)))))))\nterm\n  λ (i : set G),\n    @has_mul.to_has_scalar ℝ≥0∞\n      (@distrib.to_has_mul ℝ≥0∞\n         (@non_unital_non_assoc_semiring.to_distrib ℝ≥0∞\n            (@non_assoc_semiring.to_non_unital_non_assoc_semiring ℝ≥0∞\n               (@semiring.to_non_assoc_semiring ℝ≥0∞\n                  (@comm_semiring.to_semiring ℝ≥0∞\n                     (@canonically_ordered_comm_semiring.to_comm_semiring ℝ≥0∞\n                        ennreal.canonically_ordered_comm_semiring))))))\nhas type\n  set G → has_scalar ℝ≥0∞ ℝ≥0∞\nbut is expected to have type\n  Π (i : set G), has_vadd ℝ≥0∞ ((λ (ᾰ : set G), ℝ≥0∞) i)\n</code></pre></div>\n<p>The reason that <code>coe_smul</code> causes this error, is that the right-hand-side of this equation contains <code>pi.has_scalar</code>.</p>",
        "id": 252888713,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1631343647
    },
    {
        "content": "<p>I think/hope this is fixed by <a href=\"https://github.com/leanprover-community/mathlib/issues/9138\">#9138</a> (cc <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>)</p>",
        "id": 252888744,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1631343697
    },
    {
        "content": "<p>Yes, without <code>coe_smul</code> it works. Just changing the proof, replacing the <code>coe_smul</code> with a <code>change</code> step works fine. For instance, in the current Haar file </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">haar_measure_apply</span> <span class=\"o\">{</span><span class=\"n\">K₀</span> <span class=\"o\">:</span> <span class=\"n\">positive_compacts</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">measurable_set</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">haar_measure</span> <span class=\"n\">K₀</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">haar_content</span> <span class=\"n\">K₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">outer_measure</span> <span class=\"n\">s</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">haar_content</span> <span class=\"n\">K₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">outer_measure</span> <span class=\"n\">K₀.1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">delta</span> <span class=\"n\">haar_measure</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"o\">(((</span><span class=\"n\">haar_content</span> <span class=\"n\">K₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">outer_measure</span><span class=\"o\">)</span> <span class=\"n\">K₀.val</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">haar_content</span> <span class=\"n\">K₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">measure</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">div_eq_mul_inv</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">content.measure_apply</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>fixes the issue of <a href=\"https://github.com/leanprover-community/mathlib/issues/9032\">#9032</a>. But  changing it back to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">haar_measure_apply</span> <span class=\"o\">{</span><span class=\"n\">K₀</span> <span class=\"o\">:</span> <span class=\"n\">positive_compacts</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">measurable_set</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">haar_measure</span> <span class=\"n\">K₀</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">haar_content</span> <span class=\"n\">K₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">outer_measure</span> <span class=\"n\">s</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">haar_content</span> <span class=\"n\">K₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">outer_measure</span> <span class=\"n\">K₀.1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">delta</span> <span class=\"n\">haar_measure</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">coe_smul</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"o\">(((</span><span class=\"n\">haar_content</span> <span class=\"n\">K₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">outer_measure</span><span class=\"o\">)</span> <span class=\"n\">K₀.val</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">haar_content</span> <span class=\"n\">K₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">measure</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">div_eq_mul_inv</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">content.measure_apply</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>makes the problem come back. Even when one changes <code>coe_smul</code> to have as first argument an <code>ennreal</code>.</p>",
        "id": 252889321,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1631344304
    },
    {
        "content": "<p>The reason is that in those proofs you avoid <code>pi.has_scalar</code> in the proof.</p>",
        "id": 252890255,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1631345355
    },
    {
        "content": "<p>ok, thanks for the explanation!</p>",
        "id": 252891402,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1631346740
    }
]
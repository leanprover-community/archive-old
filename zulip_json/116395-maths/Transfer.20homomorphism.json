[
    {
        "content": "<p>Let G be a group and H a subgroup of finite index. Then, pick a set-theoretic section s:G/H-&gt;G where G/H is the right cosets. Then, the transfer homomorphism G^ab -&gt; H^ab is defined by sending [[g]] to prod[x in G/H] s(x) g s(xg)^-1.</p>",
        "id": 128127678,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079333
    },
    {
        "content": "<p>The wonderful thing about this homomorphism is that it is independent of the section s</p>",
        "id": 128127688,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079354
    },
    {
        "content": "<p>but this also means that I will be lifting arbitrarily many quotients.</p>",
        "id": 128127734,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079370
    },
    {
        "content": "<p>How should I do that?</p>",
        "id": 128127738,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079373
    },
    {
        "content": "<p>using choice</p>",
        "id": 128127753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079409
    },
    {
        "content": "<p>but it will be noncomputable</p>",
        "id": 128127757,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079418
    },
    {
        "content": "<p>obviously</p>",
        "id": 128127765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079424
    },
    {
        "content": "<p>can I make it computable?</p>",
        "id": 128127769,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079430
    },
    {
        "content": "<p>nothing about what you said sounds remotely computable</p>",
        "id": 128127773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079436
    },
    {
        "content": "<p>it seems computable to me</p>",
        "id": 128127776,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079446
    },
    {
        "content": "<p>the map is independent of s</p>",
        "id": 128127781,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079451
    },
    {
        "content": "<p>there is only finitely many choices to make</p>",
        "id": 128127784,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079456
    },
    {
        "content": "<p>How do you even know such a function <code>s</code> exists?</p>",
        "id": 128127789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079471
    },
    {
        "content": "<p>you don't need the function s. you just need to lift finitely many quotients</p>",
        "id": 128127833,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079484
    },
    {
        "content": "<p>obviously s is noncomputable</p>",
        "id": 128127837,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079490
    },
    {
        "content": "<p>but the transfer homomorphism should be computable</p>",
        "id": 128127839,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079498
    },
    {
        "content": "<p>How is G^ab defined</p>",
        "id": 128127843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079513
    },
    {
        "content": "<p>G quotient G commutator</p>",
        "id": 128127847,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079524
    },
    {
        "content": "<p>G/[G,G]</p>",
        "id": 128127851,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079530
    },
    {
        "content": "<p>And in what sense is G/H finite</p>",
        "id": 128127866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079572
    },
    {
        "content": "<p>in the sense that H is a finite-index subgroup of G</p>",
        "id": 128127881,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079593
    },
    {
        "content": "<p>so G/H is a fintype</p>",
        "id": 128127885,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079598
    },
    {
        "content": "<p>I mean, how are you expressing \"finite index\"</p>",
        "id": 128127954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079646
    },
    {
        "content": "<p>[fintype G/H]</p>",
        "id": 128127956,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079654
    },
    {
        "content": "<p>And how do you construct a section?</p>",
        "id": 128127976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079710
    },
    {
        "content": "<p>I don't</p>",
        "id": 128127978,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079713
    },
    {
        "content": "<p>Any section at all</p>",
        "id": 128127979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079714
    },
    {
        "content": "<p>section is noncomputable</p>",
        "id": 128127982,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079721
    },
    {
        "content": "<p>but the transfer homomorphism is independent of section</p>",
        "id": 128128022,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079728
    },
    {
        "content": "<p>so I need finitely many lifts</p>",
        "id": 128128025,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079735
    },
    {
        "content": "<p>Even ignoring the lifts</p>",
        "id": 128128034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079745
    },
    {
        "content": "<p>I can't construct any section computably</p>",
        "id": 128128046,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079779
    },
    {
        "content": "<p>if that's what you mean</p>",
        "id": 128128053,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079788
    },
    {
        "content": "<p>I think I see what you mean with iterating lifts, that might be possible</p>",
        "id": 128128081,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079842
    },
    {
        "content": "<p>hmm</p>",
        "id": 128128113,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079855
    },
    {
        "content": "<p>but it will be very hard</p>",
        "id": 128128118,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079864
    },
    {
        "content": "<p>But you will have to redo the work of <code>finset.pi</code></p>",
        "id": 128128119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079868
    },
    {
        "content": "<p>each element of the product is not well-defined</p>",
        "id": 128128120,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079873
    },
    {
        "content": "<p>it is the product itself which is well-defined</p>",
        "id": 128128123,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079882
    },
    {
        "content": "<p>You have a single quotient in the output</p>",
        "id": 128128127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079897
    },
    {
        "content": "<p>or even a <code>trunc</code>, if you express the section property in a subtype</p>",
        "id": 128128148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079928
    },
    {
        "content": "<p>Do you have decidable equality on G/H?</p>",
        "id": 128128197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079964
    },
    {
        "content": "<p>is that necessary?</p>",
        "id": 128128202,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079971
    },
    {
        "content": "<p>I feel that it is already computable</p>",
        "id": 128128210,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529079984
    },
    {
        "content": "<p>it comes up in the construction of the functions</p>",
        "id": 128128212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529079985
    },
    {
        "content": "<p>how would you do it?</p>",
        "id": 128128247,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080063
    },
    {
        "content": "<p>I am reminded of a discussion with <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> about generalizing the quotient axioms to allow for indexed families of quotients</p>",
        "id": 128128310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080127
    },
    {
        "content": "<p>but everything is finite here</p>",
        "id": 128128314,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080142
    },
    {
        "content": "<p>the axioms should be enough</p>",
        "id": 128128321,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080145
    },
    {
        "content": "<p>But it's provable in the finite case, and that's what I would prove</p>",
        "id": 128128324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080149
    },
    {
        "content": "<p>hmm</p>",
        "id": 128128328,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080157
    },
    {
        "content": "<p>this is very hard</p>",
        "id": 128128330,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080162
    },
    {
        "content": "<p>can I even do this in 3 days</p>",
        "id": 128128332,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080167
    },
    {
        "content": "<p>It's less than 100 lines for sure</p>",
        "id": 128128339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080190
    },
    {
        "content": "<p>Also, decidable equality is definitely necessary for constructing sections</p>",
        "id": 128128430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080265
    },
    {
        "content": "<p>I don't want to construct any section</p>",
        "id": 128128439,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080279
    },
    {
        "content": "<p>You do, that's the whole point</p>",
        "id": 128128445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080288
    },
    {
        "content": "<p>You are lifting stuff from a quotient but that's not so important</p>",
        "id": 128128453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080307
    },
    {
        "content": "<p>hmm</p>",
        "id": 128128510,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080361
    },
    {
        "content": "<p>Are you suggesting that there is a way to define the transfer that avoids reference to any section?</p>",
        "id": 128128520,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080386
    },
    {
        "content": "<p>If I do a product indexed by a fintype do I need decidable equality?</p>",
        "id": 128128525,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080406
    },
    {
        "content": "<p>I assume you have to make coordinated choices in order to define the sums</p>",
        "id": 128128530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080410
    },
    {
        "content": "<p>but everything is finite</p>",
        "id": 128128535,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080420
    },
    {
        "content": "<p>No, products of elements in a commutative group over a finset does not require decidable_eq</p>",
        "id": 128128620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080518
    },
    {
        "content": "<p>then why do I need it now</p>",
        "id": 128128626,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080530
    },
    {
        "content": "<p>even if the choice is coordinated</p>",
        "id": 128128629,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080535
    },
    {
        "content": "<p>it's still finite</p>",
        "id": 128128631,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080539
    },
    {
        "content": "<p>to define the section that coordinates the choices</p>",
        "id": 128128637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080546
    },
    {
        "content": "<p>but everything is well-defined</p>",
        "id": 128128642,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080556
    },
    {
        "content": "<p>How are you going to remember your finitely many choices if not with a function? And how is that function indexed?</p>",
        "id": 128128690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080577
    },
    {
        "content": "<p>isn't it the philosophy of quotient that if your choices are well-defined then you are computable?</p>",
        "id": 128128694,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080581
    },
    {
        "content": "<p>That's not the problem</p>",
        "id": 128128703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080603
    },
    {
        "content": "<p>You want a function G/H -&gt; G</p>",
        "id": 128128708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080616
    },
    {
        "content": "<p>list.rec is computable</p>",
        "id": 128128717,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080634
    },
    {
        "content": "<p>multiset.rec is computable</p>",
        "id": 128128718,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080638
    },
    {
        "content": "<p>that means distinguishing elements of G/H when they are sent to different members of G</p>",
        "id": 128128719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529080638
    },
    {
        "content": "<p>finset.rec is computable</p>",
        "id": 128128721,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080640
    },
    {
        "content": "<p>hmm</p>",
        "id": 128128806,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529080742
    },
    {
        "content": "<p>Here's a way to state the section property without groups:</p>\n<div class=\"codehilite\"><pre><span></span>def choices {ι : Type*} [fintype ι] {α : ι → Type*} (R : ∀ i, α i → α i → Prop)\n    (f : ∀ i, quot (R i)) : quot (λ (a b : Π i, α i), ∀ i, R i (a i) (b i)) := sorry\n</pre></div>",
        "id": 128129541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529081741
    },
    {
        "content": "<p>I only have one quotient though</p>",
        "id": 128129595,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529081810
    },
    {
        "content": "<p>it's just G/H</p>",
        "id": 128129601,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529081817
    },
    {
        "content": "<p>That doesn't make too much of a difference</p>",
        "id": 128129610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529081831
    },
    {
        "content": "<p>The point here is the interchanging of pi and quot</p>",
        "id": 128129673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529081885
    },
    {
        "content": "<p>I see</p>",
        "id": 128129683,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529081894
    },
    {
        "content": "<p>It seems reasonable to have that function as a computable axiom, this is what Gabriel and I discussed</p>",
        "id": 128129782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529082032
    },
    {
        "content": "<p>I see</p>",
        "id": 128129786,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529082042
    },
    {
        "content": "<p>because it has an obvious VM interpretation</p>",
        "id": 128129787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529082048
    },
    {
        "content": "<p>but is it provable?</p>",
        "id": 128129793,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529082066
    },
    {
        "content": "<p>but you can only prove it for I finite</p>",
        "id": 128129794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529082067
    },
    {
        "content": "<p>and even then I believe it implies decidable equality of I</p>",
        "id": 128129806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529082092
    },
    {
        "content": "<p>Kenny, if you are under time constraints, why not just make it noncomputable, make sure everything else is done, and come back to it later if you have time?</p>",
        "id": 128130433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529082881
    },
    {
        "content": "<p>I will look into this theorem, and report back if I can prove it. Feel free to assume it</p>",
        "id": 128130542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529083009
    },
    {
        "content": "<p>This version is not quite right though, because for example one of the <code>R i</code> could be the empty relation, and then the \"product relation\" is also empty</p>",
        "id": 128130568,
        "sender_full_name": "Reid Barton",
        "timestamp": 1529083061
    },
    {
        "content": "<p>You need to assume the <code>R i</code> are at least reflexive, or build the \"product relation\" differently, like the Cartesian product of graphs</p>",
        "id": 128130653,
        "sender_full_name": "Reid Barton",
        "timestamp": 1529083183
    },
    {
        "content": "<p>That's fine, <code>quot</code> implicitly takes the equivalence closure of the given relation</p>",
        "id": 128130733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529083279
    },
    {
        "content": "<p><code>quotient</code> is the variant that explicitly assumes the relation is an equivalence already</p>",
        "id": 128130750,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529083310
    },
    {
        "content": "<p>But, say, <code>R 1</code> might be nontrivial, while <code>R 2</code> is empty, and then <code>λ (a b : Π i, α i), ∀ i, R i (a i) (b i)</code> is empty, so we haven't made any identifications in <code>\\a 1 \\x \\a 2</code></p>",
        "id": 128130797,
        "sender_full_name": "Reid Barton",
        "timestamp": 1529083332
    },
    {
        "content": "<p>then we'd have a map <code>quot (R 1) \\to \\a 1</code>. Or is that okay?</p>",
        "id": 128130830,
        "sender_full_name": "Reid Barton",
        "timestamp": 1529083400
    },
    {
        "content": "<p>I see, yes that's bad</p>",
        "id": 128130903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529083474
    },
    {
        "content": "<p>So maybe just replace<code>quot</code> with <code>quotient</code> everywhere</p>",
        "id": 128130919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529083506
    },
    {
        "content": "<p>although then I have to show that the pi of equivalences is an equivalence</p>",
        "id": 128130929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529083545
    },
    {
        "content": "<p>Here's the noncomputable version:</p>\n<div class=\"codehilite\"><pre><span></span>instance pi_setoid {ι : Type*} {α : ι → Type*} [∀ i, setoid (α i)] : setoid (Π i, α i) :=\n{ r := λ a b, ∀ i, a i ≈ b i,\n  iseqv := ⟨\n    λ a i, setoid.refl _,\n    λ a b h i, setoid.symm (h _),\n    λ a b c h₁ h₂ i, setoid.trans (h₁ _) (h₂ _)⟩ }\n\nnoncomputable def quotient.choice {ι : Type*} {α : ι → Type*} [S : ∀ i, setoid (α i)]\n  (f : ∀ i, quotient (S i)) : @quotient (Π i, α i) (by apply_instance) :=\n⟦λ i, (f i).out⟧\n\ntheorem quotient.choice_eq {ι : Type*} {α : ι → Type*} [∀ i, setoid (α i)]\n  (f : ∀ i, α i) : quotient.choice (λ i, ⟦f i⟧) = ⟦f⟧ :=\nquotient.sound $ λ i, quotient.mk_out _\n</pre></div>",
        "id": 128131542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529084392
    },
    {
        "content": "<blockquote>\n<p>Let G be a group and H a subgroup of finite index. Then, pick a set-theoretic section s:G/H-&gt;G where G/H is the right cosets. Then, the transfer homomorphism G^ab -&gt; H^ab is defined by sending [[g]] to prod[x in G/H] s(x) g s(xg)^-1.</p>\n</blockquote>\n<p>Shouldn't there be a [[]] in the definition there somewhere?</p>",
        "id": 128136633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529090660
    },
    {
        "content": "<p>by sending [[g]] to [[prod[x in G/H] s(x) g s(xg)^-1]].</p>",
        "id": 128136644,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529090680
    },
    {
        "content": "<p>Does <code>[[g h]] = [[g]][[h]]</code>?</p>",
        "id": 128136655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529090699
    },
    {
        "content": "<p>yes</p>",
        "id": 128136663,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529090704
    },
    {
        "content": "<p>Then don't the <code>s(x)</code> parts cancel?</p>",
        "id": 128136679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529090726
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span></p>",
        "id": 128136684,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529090752
    },
    {
        "content": "<p><code>[[prod[x in G/H] s(x) g s(xg)^-1]] = (prod[x in G/H] [[s(x)]]) (prod[x in G/H] [[g]]) (prod[x in G/H] [[s(xg)]]^-1)</code></p>",
        "id": 128136736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529090789
    },
    {
        "content": "<p>and <code>prod[x in G/H] [[s(xg)]]^-1 = prod[x in G/H] [[s(x)]]^-1</code> by reindexing</p>",
        "id": 128136747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529090807
    },
    {
        "content": "<p>oh you can't do that, g is not in H</p>",
        "id": 128136748,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529090810
    },
    {
        "content": "<p>s(x) g s(xg)^-1 is in H</p>",
        "id": 128136762,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529090824
    },
    {
        "content": "<p>I know, but they should still be equal as members of G</p>",
        "id": 128136768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529090844
    },
    {
        "content": "<p>no, because H^ab is H/[H,H]</p>",
        "id": 128136779,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529090863
    },
    {
        "content": "<p>Okay, I think I have something close to a proof that decidable_eq of the coset relation is necessary. Suppose you know <code>fintype G/H</code>. Ignoring quotients for a moment, thinking \"computationally\", this is essentially a list of elements of G which chooses exactly one element of every coset (or, if you prefer, a bijection (not an equiv) from fin n to G/H). Now that looks like the section we want, but the problem is the computation of s(xg) that we need later. The function x |-&gt; xg is a permutation of G/H which corresponds to a permutation of the list s, but computationally it's not that easy since if we take our representative s(x) and multiply by g we get s(x)g, which is in the same coset as s(xg) but is not usually the same. So we need a way of searching our list s to find the value that is in the same coset as s(x)g, and there is no way to do this from the given data.</p>",
        "id": 128137621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529091961
    },
    {
        "content": "<p>I see. Then I'll just come up with a section noncomputably then.</p>",
        "id": 128141785,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529097478
    },
    {
        "content": "<p>Here's the computable version of that theorem:</p>\n<div class=\"codehilite\"><pre><span></span>def quotient.fin_choice_aux {ι : Type*} [decidable_eq ι]\n  {α : ι → Type*} [S : ∀ i, setoid (α i)] :\n  ∀ (l : list ι), (∀ i ∈ l, quotient (S i)) → @quotient (Π i ∈ l, α i) (by apply_instance)\n| []     f := ⟦λ i, false.elim⟧\n| (i::l) f := begin\n  refine quotient.lift_on₂ (f i (list.mem_cons_self _ _))\n    (quotient.fin_choice_aux l (λ j h, f j (list.mem_cons_of_mem _ h)))\n    _ _,\n  exact λ a l, ⟦λ j h,\n    if e : j = i then by rw e; exact a else\n    l _ (h.resolve_left e)⟧,\n  refine λ a₁ l₁ a₂ l₂ h₁ h₂, quotient.sound (λ j h, _),\n  by_cases e : j = i; simp [e],\n  { subst j, exact h₁ },\n  { exact h₂ _ _ }\nend\n\ntheorem quotient.fin_choice_aux_eq {ι : Type*} [decidable_eq ι]\n  {α : ι → Type*} [S : ∀ i, setoid (α i)] :\n  ∀ (l : list ι) (f : ∀ i ∈ l, α i), quotient.fin_choice_aux l (λ i h, ⟦f i h⟧) = ⟦f⟧\n| []     f := quotient.sound (λ i h, h.elim)\n| (i::l) f := begin\n  simp [quotient.fin_choice_aux, quotient.fin_choice_aux_eq l],\n  refine quotient.sound (λ j h, _),\n  by_cases e : j = i; simp [e],\n  subst j, refl\nend\n\ndef quotient.fin_choice {ι : Type*} [fintype ι] [decidable_eq ι]\n  {α : ι → Type*} [S : ∀ i, setoid (α i)]\n  (f : ∀ i, quotient (S i)) : @quotient (Π i, α i) (by apply_instance) :=\nquotient.lift_on (@quotient.rec_on _ _ (λ l : multiset ι,\n    @quotient (Π i ∈ l, α i) (by apply_instance))\n    finset.univ.1\n    (λ l, quotient.fin_choice_aux l (λ i _, f i))\n    (λ a b h, begin\n      have := λ a, quotient.fin_choice_aux_eq a (λ i h, quotient.out (f i)),\n      simp [quotient.out_eq] at this,\n      simp [this],\n      let g := λ a:multiset ι, ⟦λ (i : ι) (h : i ∈ a), quotient.out (f i)⟧,\n      refine eq_of_heq ((eq_rec_heq _ _).trans (_ : g a == g b)),\n      congr&#39; 1, exact quotient.sound h,\n    end))\n  (λ f, ⟦λ i, f i (finset.mem_univ _)⟧)\n  (λ a b h, quotient.sound $ λ i, h _ _)\n\n\ntheorem quotient.fin_choice_eq {ι : Type*} [fintype ι] [decidable_eq ι]\n  {α : ι → Type*} [∀ i, setoid (α i)]\n  (f : ∀ i, α i) : quotient.fin_choice (λ i, ⟦f i⟧) = ⟦f⟧ :=\nbegin\n  let q, swap, change quotient.lift_on q _ _ = _,\n  have : q = ⟦λ i h, f i⟧,\n  { dsimp [q],\n    exact quotient.induction_on\n      (@finset.univ ι _).1 (λ l, quotient.fin_choice_aux_eq _ _) },\n  simp [this], exact setoid.refl _\nend\n</pre></div>",
        "id": 128141854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529097572
    },
    {
        "content": "<p>:o</p>",
        "id": 128141861,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1529097590
    },
    {
        "content": "<p>Canceling s -- [[]] is being used for both the map G-&gt;Gab and H-&gt;Hab so they don't cancel. Spending the weekend in a field without much internet so don't expect too much from me until sun pm</p>",
        "id": 128164386,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1529144686
    }
]
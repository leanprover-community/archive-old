[
    {
        "content": "<p>Have there been any useful attempts to make a good library on graph theory? Any students of yours, <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> ? There's a student here who's considering formalising some planar graph theory as part of their bachelor's thesis.</p>",
        "id": 245143605,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1625645181
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> There's a <a class=\"stream\" data-stream-id=\"252551\" href=\"/#narrow/stream/252551-graph-theory\">#graph theory</a> stream!</p>",
        "id": 245143874,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625645348
    },
    {
        "content": "<p>There's been quite some activity in fact, see also <a href=\"https://github.com/leanprover-community/mathlib/tree/master/src/combinatorics\">https://github.com/leanprover-community/mathlib/tree/master/src/combinatorics</a></p>",
        "id": 245143980,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625645406
    },
    {
        "content": "<p>funnily enough I was thinking about this yesterday, and basically I have no idea what \"good\" means. It seems to me that graph theory is taught very early on to CS students, with applications to networks, algorithms etc. We don't have a graph theory course in the maths department at Imperial, and the one I sat through as an UG in Cambridge comprised a hotch-potch of unrelated results like Hall's Marriage theorem and the 5 colour theorem (and even the 7 colour theorem for maps on a torus) with no underlying story and no other courses relying on the results (mathematically, this is often the case in combinatorics-based courses, they tend to teach general principles as opposed to important theorems like the fundamental theorem of Galois theory which is used everywhere). So I am probably not the best person to ask! <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> what does a \"good\" graph theory library contain?</p>",
        "id": 245144125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625645517
    },
    {
        "content": "<p>Ah, thank you! Forgot to check the list of streams :)</p>",
        "id": 245144461,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1625645737
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> The graph theory course at KIT at the math dept contains, if my memory serves me right, a lot of Ramsey theory style results</p>",
        "id": 245144607,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1625645812
    },
    {
        "content": "<p>I think we probably had one lecture on \"R(3,3)=6, proof by induction that R(m,n) is finite\" and that was it for Ramsey theory.</p>",
        "id": 245144678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625645869
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/245144125\">said</a>:</p>\n<blockquote>\n<p>funnily enough I was thinking about this yesterday, and basically I have no idea what \"good\" means. It seems to me that graph theory is taught very early on to CS students, with applications to networks, algorithms etc. We don't have a graph theory course in the maths department at Imperial, and the one I sat through as an UG in Cambridge comprised a hotch-potch of unrelated results like Hall's Marriage theorem and the 5 colour theorem (and even the 7 colour theorem for maps on a torus) with no underlying story and no other courses relying on the results (mathematically, this is often the case in combinatorics-based courses, they tend to teach general principles as opposed to important theorems like the fundamental theorem of Galois theory which is used everywhere). So I am probably not the best person to ask! <span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> what does a \"good\" graph theory library contain?</p>\n</blockquote>\n<p>I agree it's a tricky question. The two main things I'd like to see in a \"good\" library are definitions (of course with API) of all the basic concepts of graphs: planarity, colouring, extremal number, diameter etc with the standard results about them eg Brooks' theorem, Hall's theorem; and a collection of <em>tools</em> in order to make proving new results easy, for example results like Erdos-Stone, Szemeredi's regularity lemma and a clean API for probabilistic graph theory and expander graphs.</p>",
        "id": 245179890,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625664828
    },
    {
        "content": "<p>Some of these are much harder than others, but I think the resulting library has the same goal as any other maths library: to provide enough definitions and results to make proving \"actual\" graph theory results (ie active research things) convenient.</p>",
        "id": 245180186,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625664935
    },
    {
        "content": "<p>As for the existing Cambridge graph theory courses, my undergrad graph theory notes are here: <a href=\"https://github.com/b-mehta/maths-notes/blob/master/ii/mich/graph_theory.pdf\">https://github.com/b-mehta/maths-notes/blob/master/ii/mich/graph_theory.pdf</a>, you can basically see a summary from the contents page. The Ramsey theory covered was basically what Kevin says, plus a proof of multicolour and infinite Ramsey; but there was also a Part III (MSc-level) Ramsey theory course <a href=\"https://www.maths.cam.ac.uk/postgrad/part-iii/files/misc/2020-21%20Guide/Combinatorics/Ramsey%20Theory.pdf\">syllabus here</a> which went into more detail, <span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span> is proving some of the combinatorial results from it eg Hales-Jewett and Rado's theorem. There was also a Part III Extremal Graph Theory course which was more in-depth, there are some notes from a 2017 version of this course here: <a href=\"https://dec41.user.srcf.net/notes/III_M/extremal_graph_theory.pdf\">https://dec41.user.srcf.net/notes/III_M/extremal_graph_theory.pdf</a></p>",
        "id": 245181207,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625665311
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> do you mind if I update your Ramsey Theory files to the latest mathlib and submit?</p>",
        "id": 245187192,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1625667566
    },
    {
        "content": "<p>Feel free to make the PRs, but the main reason I haven't is that I'm not certain they're ready for PR yet, there's the whole crec business and it's pretty ugly... That said, the actual result is (I think) formulated nicely so maybe it's not hugely important that the proof is ugly</p>",
        "id": 245187733,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625667730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/245144125\">said</a>:</p>\n<blockquote>\n<p>We don't have a graph theory course in the maths department at Imperial, and the one I sat through as an UG in Cambridge comprised a hotch-potch of unrelated results like Hall's Marriage theorem and the 5 colour theorem (and even the 7 colour theorem for maps on a torus) with no underlying story and no other courses relying on the results (mathematically, this is often the case in combinatorics-based courses, they tend to teach general principles as opposed to important theorems like the fundamental theorem of Galois theory which is used everywhere). </p>\n</blockquote>\n<p>In France a standard undergrad math curriculum features no graph theory at all. This is why graph theory doesn't appear at all on our <a href=\"https://leanprover-community.github.io/undergrad.html\">undergrad math page</a>. Some students may still encounter graphs in some random optional first year course on recreational mathematics.</p>",
        "id": 245192496,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1625669449
    },
    {
        "content": "<p>Question: why is <a href=\"https://leanprover-community.github.io/mathlib_docs/combinatorics/simple_graph/basic.html#simple_graph\"><code>simple_graph</code></a> under <code>combinatorics</code>? Would it fit better under <code>data</code>? </p>\n<p>Idea: <code>data</code> &gt; <code>graph</code> &gt; [<code>simple_graph</code>, <code>directed_graph</code>, <code>weighted_graph</code> etc]</p>\n<p>What do you think?</p>",
        "id": 258978056,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635176589
    },
    {
        "content": "<p>normally speaking, \"graphs\" of \"data (science)\" are rather different from graphs as combinatorial structures.</p>",
        "id": 258988088,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1635180949
    },
    {
        "content": "<p>It would make me even sadder that there's so little under <code>combinatorics</code> <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 258988312,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635181071
    },
    {
        "content": "<p>The <code>data</code> is more of a historical hodge podge of things people didn't find better homes for at the time. :-) I think in the long term we would like to rearrange things so <code>data</code> comes to mean \"data structures\" in the programming sense. I would encourage moving anything \"mathmetical\" out of <code>data</code>, rather than the reverse.</p>",
        "id": 259026960,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635199723
    },
    {
        "content": "<p>Indeed, after the transition to Lean4 I think we're hoping for a separate \"standard library\" that comes before mathlib, and perhaps we will actually aspire to emptying the <code>data</code> directory: everything about data structures per se will be in the standard library, and whatever remains can be categorised by mathematical topic in mathlib.</p>",
        "id": 259027025,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635199791
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> thanks for the return! I think we can move on to this thread now</p>",
        "id": 259027162,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635199828
    },
    {
        "content": "<p>Looking at how far that branch already is, I thought of the following subareas:</p>\n<ul>\n<li>shortest path theorems</li>\n<li>minimum cut</li>\n<li>maximum flow</li>\n<li>arriving at minimum cut and maximum flow duality</li>\n</ul>\n<p>Of course, you might have a clearer idea on the next steps since you've been doing such a fine job on this branch for quite a while already. I want to try something but I'm all ears.</p>",
        "id": 259027707,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635200163
    },
    {
        "content": "<p>Regarding the location of graphs in the library -- given your topic about complexity theory, maybe you're interested in formalizing algorithms about graphs? I sort of think about the <code>combinatorics</code> graphs as being like the abstract interface (in the Java sense), where they don't have a concrete implementation.  The data of a <code>simple_graph</code> is just a relation without any promise of computability (unless you have <code>[decidable_rel G.adj]</code>).  You'd probably want reasonably efficient ways to represent a <code>simple_graph</code> for questions about complexity, and those might more on the <code>data</code> side of things.</p>",
        "id": 259027860,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635200269
    },
    {
        "content": "<p>Hm, I guess I'd like to follow the flow of proving theorems with definitions without having to implement the mechanics of the algorithms just yet. Where do you see the <code>simple_graph</code> project moving towards?</p>",
        "id": 259028817,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635200694
    },
    {
        "content": "<p>Those all seem like interesting things to work on! Maybe for now feel free to use the <code>walks_and_trees</code> branch, adding some new files.</p>",
        "id": 259028868,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635200735
    },
    {
        "content": "<p>Alright, just wanted to know. I will try a few things locally first before requesting the permission to write on branches. I wanna make sure I can lift some weights beforehand.</p>",
        "id": 259029050,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635200880
    },
    {
        "content": "<p>For <code>simple_graph</code>, one goal has been trying to implement all the basic stuff from the first few pages of Bollobas's textbook on graph theory, and trying to do so with an eye toward avoiding too much code duplication between, for example, simple graphs, multigraphs, labeled multigraphs, etc.</p>",
        "id": 259029188,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635200980
    },
    {
        "content": "<p>For flows of a simple graph, this might be a reasonable starting definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">preflow</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_neg</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">weight</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj_of_nonzero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">weight</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This supports having <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-flows for any abelian group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>.  It's just missing conditions about what <code>∑ (w : V), weight v w</code> is.</p>",
        "id": 259029881,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635201369
    },
    {
        "content": "<p>Hm, maybe talking about shortest paths wrt non-weighted graphs would be a closer next step?</p>",
        "id": 259030262,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635201637
    },
    {
        "content": "<p>Not sure if such theorems are very (re)usable tho.</p>",
        "id": 259030350,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635201705
    },
    {
        "content": "<p>Maybe directed graphs would be better for things about flows, but here's a definition for flows in an undirected graph:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">flow</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cap</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">weight</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj_of_ne</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">weight</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">conserve</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">cap_constraint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">cap</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Each edge has a capacity, and the flow for that edge can go in either direction so long as it's within the capacity.</p>\n<p>This is also an option, allowing the capacity to be different for flows in each direction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">flow</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cap</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">weight</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">for_edges</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">weight</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">conserve</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">cap_constraint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">≤</span> <span class=\"n\">cap</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 259030905,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635202128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/259030350\">said</a>:</p>\n<blockquote>\n<p>Not sure if such theorems are very (re)usable tho.</p>\n</blockquote>\n<p>If anything, you'd probably create useful supporting lemmas along the way.</p>",
        "id": 259030954,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635202186
    },
    {
        "content": "<p>Now I understood what you meant by \"avoiding too much code duplication\". You're using the <code>simple_graph</code> structure to extend onto other structures</p>",
        "id": 259031101,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635202288
    },
    {
        "content": "<p>I will let you know of any updates <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 259031698,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635202741
    },
    {
        "content": "<p>It might also be nice splitting up the definition into the \"relative 1-cycle\" part (i.e., the part having to do with Kirkhoff's law for currents where certain nodes are allowed to be current sources/sinks) and the capacity part. This can also be generalized to infinite graphs, so long as every vertex has only finitely many neighbors (i.e., it's locally finite).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A relative 1-cycle with coefficients in an abelian group. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">rel_cycle</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">G.locally_finite</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">weight</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj_if</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">weight</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">conserve</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"bp\">∑</span> <span class=\"n\">w</span> <span class=\"k\">in</span> <span class=\"n\">G.neighbor_finset</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A real-valued relative 1-cycle with bounded weights with only two boundary vertices. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">flow</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">G.locally_finite</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">cap</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">rel_cycle</span> <span class=\"n\">G</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">cap_constraint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">weight</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">≤</span> <span class=\"n\">cap</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 259034081,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635204583
    },
    {
        "content": "<p>1-cycles themselves form an abelian group, the rank of which is an important invariant for graphs (it's the minimum number of edges you have to remove to get a forest).</p>",
        "id": 259034272,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635204724
    },
    {
        "content": "<p>Also, just because git status says your branch is up to date doesn't mean you don't have changes. By that I mean unsaved changes. Edited unsaved files earlier in the import tree still cause recompilation of themselves and dependent files.</p>",
        "id": 259086300,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635250093
    },
    {
        "content": "<p>If they are open in your vscode and your extension settings are the default ones.</p>",
        "id": 259086363,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635250139
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Lean is not accepting <code>append_support''</code> nor <code>append_support'</code> on my machine (<code>connectivity.lean</code> lines 462 to 488).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">append_support''</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p'</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">p.append</span> <span class=\"n\">p'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">+</span> <span class=\"n\">p.support.tail</span> <span class=\"bp\">+</span> <span class=\"n\">p'.support.tail</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">append_support</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">multiset.coe_add</span><span class=\"o\">],</span>\n  <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">multiset.singleton_eq_singleton</span><span class=\"o\">,</span> <span class=\"n\">multiset.cons_coe</span><span class=\"o\">,</span>\n    <span class=\"n\">zero_add</span><span class=\"o\">,</span> <span class=\"n\">multiset.coe_eq_coe</span><span class=\"o\">,</span> <span class=\"n\">multiset.cons_add</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">support_eq</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">append_support'</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p'</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">p.append</span> <span class=\"n\">p'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p.support</span> <span class=\"bp\">+</span> <span class=\"n\">p'.support</span> <span class=\"bp\">-</span> <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">append_support</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">nil_support</span><span class=\"o\">,</span> <span class=\"n\">list.tail_cons</span><span class=\"o\">,</span> <span class=\"n\">list.append_nil</span><span class=\"o\">],</span>\n    <span class=\"n\">convert_to</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">p.support</span> <span class=\"bp\">+</span> <span class=\"o\">([</span><span class=\"n\">v</span><span class=\"o\">]</span> <span class=\"bp\">-</span> <span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">erw</span> <span class=\"n\">multiset.add_sub_cancel</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">nth_rewrite</span> <span class=\"mi\">0</span> <span class=\"bp\">←</span><span class=\"n\">add_zero</span> <span class=\"o\">(</span><span class=\"n\">p.support</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n      <span class=\"n\">rw</span> <span class=\"n\">add_left_cancel_iff</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">cons_support</span><span class=\"o\">,</span> <span class=\"n\">list.tail_cons</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">multiset.cons_coe</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">multiset.singleton_add</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">],</span>\n    <span class=\"n\">erw</span> <span class=\"n\">multiset.add_sub_cancel</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">multiset.coe_add</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>On the former, it's failing to apply <code>simp</code> and on the later the second <code>simp</code> ends up with unsolved goals. Was this under your radar?</p>",
        "id": 259097725,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635255740
    },
    {
        "content": "<p>Okay I fixed a few things. I wanna push to a different branch before merging so you can see my modifications first because these are my first changes to mathlib files.</p>",
        "id": 259120904,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635264774
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/9983\">https://github.com/leanprover-community/mathlib/pull/9983</a> A PR to merge my branch into yours.<br>\nYou said that I could push commits directly to your branch if I added new files. But in this case I made changes to files that you wrote so I'm more comfortable opening a PR into your branch this time around (I don't want to mess things up).</p>",
        "id": 259123770,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635266003
    },
    {
        "content": "<p>For those kinds of changes (fixing proofs, changing names, and the like), feel free to commit straight to the branch. (And thanks for finding a way to simplify one of the proofs! I wouldn't mind if you did that for more of the proofs; many still have things like <a href=\"https://leanprover-community.github.io/extras/simp.html#non-terminal-codesimpcodes\">non-terminal simps</a>.)</p>\n<p>I haven't seen using PRs targeting non-master branches before for mathlib, and I'm not sure how it will interact with the existing PR due to my lack of experience. Will squash-and-merge effectively just add a single commit to the <code>walks_and_trees</code> branch?</p>",
        "id": 259125740,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635266765
    },
    {
        "content": "<p>Yeah, such PR are fine but pretty rare. People usually rather go through a PR-like process behind the scenes.</p>",
        "id": 259125931,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635266840
    },
    {
        "content": "<p>Okay since you've already reviewed the changes and approved them (on this chat), I'm gonna accept the PR and merge my branch into yours</p>",
        "id": 259126603,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635267113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/259125740\">said</a>:</p>\n<blockquote>\n<p>I haven't seen using PRs targeting non-master branches before for mathlib, and I'm not sure how it will interact with the existing PR due to my lack of experience. Will squash-and-merge effectively just add a single commit to the <code>walks_and_trees</code> branch?</p>\n</blockquote>\n<p>Yeah that's precisely it. It's just a way of coordinating collaboration so you know exactly what I'm changing instead of having to read it on a tight <code>git diff</code> terminal interface</p>",
        "id": 259133995,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635270174
    },
    {
        "content": "<p>But sure, I can be more straightforward and commit directly on your branch <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 259134319,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635270307
    },
    {
        "content": "<p>(I don't mind reviewing your changes if you prefer PRing.)</p>",
        "id": 259134720,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635270474
    },
    {
        "content": "<p>Interesting, I've just found out about this GitHub feature: <code>compare</code>.<br>\nIf you go to <a href=\"https://github.com/leanprover-community/mathlib/compare\">https://github.com/leanprover-community/mathlib/compare</a> you can pick two branches as if you wanted to merge one into the other and the diff will be shown in a PR-styled way. Example: comparing <code>walks_and_trees</code> with <code>master</code>:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/compare/master...walks_and_trees\">https://github.com/leanprover-community/mathlib/compare/master...walks_and_trees</a></p>\n<p>But it doesn't allow commentaries etc, which make sense</p>",
        "id": 259138300,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635272003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/259134720\">said</a>:</p>\n<blockquote>\n<p>(I don't mind reviewing your changes if you prefer PRing.)</p>\n</blockquote>\n<p>Thanks <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> <br>\nYeah I feel safer that way</p>",
        "id": 259138435,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635272077
    },
    {
        "content": "<p>According to this definition, trees and spanning trees are the same for us, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A *tree* is a connected acyclic graph. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_tree</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">G.connected</span> <span class=\"bp\">∧</span> <span class=\"n\">G.is_acyclic</span>\n</code></pre></div>",
        "id": 259173202,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635288771
    },
    {
        "content": "<p>A spanning tree is a <code>G' : subgraph G</code> that satisfies <code>G'.is_spanning</code> and <code>G'.coe.is_tree</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph.coe\">docs#simple_graph.subgraph.coe</a> to turn the subgraph into a graph.)  It's probably more convenient to use <code>G'.spanning_coe.is_tree</code>, which doesn't introduce a subtype for the vertices.</p>\n<p>Another way to formalize spanning trees, probably even more convenient, is as a <code>G' : simple_graph V</code> such that <code>G' ≤ G</code> and <code>G'.is_tree</code>.  The type <code>simple_graph V</code> has a boolean algebra structure from comparing edge sets, and <code>G' ≤ G</code> means <code>G'</code> is a spanning subgraph of <code>G</code>.</p>",
        "id": 259174061,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635289350
    },
    {
        "content": "<p>Ah, wait, I got confused. The concept of \"Spanning tree\" is that we can compute the spanning tree of a connected graph</p>",
        "id": 259175202,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635290197
    },
    {
        "content": "<p>This (or some variation on it) would be nice to have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">exists_spanning_tree</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.connected</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">G'</span><span class=\"o\">,</span> <span class=\"n\">G'</span> <span class=\"bp\">≤</span> <span class=\"n\">G</span> <span class=\"bp\">∧</span> <span class=\"n\">G'.is_tree</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 259175657,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635290580
    },
    {
        "content": "<p>This is a noncomputable version, allowing for <code>V</code> to be infinite. The argument that comes to mind uses Zorn's lemma applied to acyclic graphs <code>G' ≤ G</code>.</p>",
        "id": 259175841,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635290750
    },
    {
        "content": "<p>Nice. I'm trying to figure out a way to state that the number of edges of a finite tree is equal to the number of vertices minus 1</p>",
        "id": 259175922,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635290827
    },
    {
        "content": "<p>But I'm not even being able to write it as a lemma and have Lean accept it</p>",
        "id": 259176025,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635290935
    },
    {
        "content": "<p>This is not the right lemma, but I'm getting an error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">asd</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span> <span class=\"bp\">→</span> <span class=\"n\">G.edge_finset.card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The error is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n<span class=\"n\">ᾰ</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">fintype</span> <span class=\"n\">V</span>\n</code></pre></div>",
        "id": 259176139,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635291005
    },
    {
        "content": "<p>That's saying you don't have the assumption that <code>V</code> is finite.  Add <code>[fintype V]</code> as an argument to <code>asd</code>.</p>",
        "id": 259176164,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635291041
    },
    {
        "content": "<p>I guess you need <code>[decidable_eq V] [fintype V] [decidable_rel G.adj]</code> to use <code>G.edge_finset</code>.</p>",
        "id": 259176307,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635291163
    },
    {
        "content": "<p>(This should be changed actually. <code>G.edge_finset</code> should just need <code>[fintype G.edge_set]</code>.  Or maybe it should be removed, since all it does is make it a little easier to write <code>G.edge_set.to_finset</code>.)</p>",
        "id": 259176445,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635291299
    },
    {
        "content": "<p><code>[fintype V] [decidable_rel G.adj]</code> did the job, thanks!</p>\n<p>Question: I see that some proofs use assumptions introduced with <code>{...}</code> and others use <code>[...]</code>. What's the difference?</p>",
        "id": 259176579,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635291399
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/topic/set.2Efinite.2Efintype/near/249577393\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/set.2Efinite.2Efintype/near/249577393</a></p>",
        "id": 259176649,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635291477
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/reference/expressions.html#implicit-arguments\">https://leanprover.github.io/reference/expressions.html#implicit-arguments</a></p>",
        "id": 259176731,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635291529
    },
    {
        "content": "<p>Chapter 10 of <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> is a good reference on how type classes (related to the square brackets) work in Lean 3.</p>",
        "id": 259176746,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1635291552
    },
    {
        "content": "<p><code>lemma asd [fintype G.edge_set]: G.is_tree → G.edge_set.to_finset.card = 1 := sorry</code> is accepted <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 259176881,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635291695
    },
    {
        "content": "<p>I will get back to the introduction of spanning trees once I figure this one out. Now I need to express the cardinality of <code>V</code>. Let me struggle a little</p>",
        "id": 259176986,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635291777
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>That's <code>fintype.card V</code> if you've got <code>[fintype V]</code></p>\n</div></div>",
        "id": 259177081,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635291878
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>(it's common to add an <code>open fintype</code> line so you can just write <code>card V</code>)</p>\n</div></div>",
        "id": 259177090,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635291893
    },
    {
        "content": "<p>Is this too astray?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">fintype</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_tree_then_card_edges_le_card_vertices</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G.edge_set</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span> <span class=\"bp\">→</span> <span class=\"n\">card</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">&lt;</span> <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_tree_then_not_card_edges_le_card_vertices_minus_one</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G.edge_set</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">V</span><span class=\"o\">]:</span> <span class=\"n\">G.is_tree</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span> <span class=\"n\">card</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">&lt;</span> <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">the strategy is to use the lemmas above and nat.eq_of_lt_succ_of_not_lt in order to</span>\n<span class=\"cm\">achieve equality</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">is_tree_then_card_edges_eq_card_vertices_minus_one</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G.edge_set</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span> <span class=\"bp\">→</span> <span class=\"n\">card</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hle</span> <span class=\"o\">:=</span> <span class=\"n\">is_tree_then_card_edges_le_card_vertices</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hnle</span> <span class=\"o\">:=</span> <span class=\"n\">is_tree_then_not_card_edges_le_card_vertices_minus_one</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 259184594,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635299584
    },
    {
        "content": "<p>Maybe an induction on the number of vertices works better</p>",
        "id": 259184714,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635299757
    },
    {
        "content": "<p>It would be possible to prove it using an induction principle for trees (though I'm not sure exactly how I'd want to formulate it).</p>\n<p>Another option is more direct.  Given a tree, choose an arbitrary root <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>.  Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi><mo>=</mo><mi>V</mi><mo>∖</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">W=V\\setminus v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>.  For every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">w\\in W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>, there is a unique path from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> (see <code>tree_path</code>); let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">e(w)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span></span></span></span> denote the first edge in this path.  This function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span> is surjective (given an edge, you should be able to use <code>is_rootward_antisymm</code> to show it's the image of one of its endpoints) and it is injective (same lemma or thereabouts).  Since this is a bijection, we get an equality of the cardinalities of the edge set and of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>.</p>",
        "id": 259186042,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635301404
    },
    {
        "content": "<p>Will take a closer look at your approach tomorrow. I'm feeling a bit fried after some hours trying to translate my thoughts into Lean.</p>\n<p>I've started this draft PR, also including some adjustments you requested on the previous PR that I couldn't see in time:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/9993\">https://github.com/leanprover-community/mathlib/pull/9993</a></p>",
        "id": 259186297,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635301712
    },
    {
        "content": "<p>The coercions here are a bit hairy, but maybe you can try filling in the sorries (assuming I set things up right):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">next_edge</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">walk.nil</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"n\">hvw</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"n\">hvw</span><span class=\"o\">,</span> <span class=\"n\">sym2.mk_has_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_tree_then_card_edges_eq_card_vertices_minus_one</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G.edge_set</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">card</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">root</span> <span class=\"o\">:=</span> <span class=\"n\">classical.arbitrary</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">set.card_ne_eq</span> <span class=\"n\">root</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">G.edge_set</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">next_edge</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">root</span> <span class=\"n\">v.property</span> <span class=\"o\">(</span><span class=\"n\">G.tree_path</span> <span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">root</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">root</span><span class=\"o\">),</span>\n    <span class=\"c1\">-- convert the term of incidence_set to an edge_set; there's probably a nicer way</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">a.property.1</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">fprop</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">],</span>\n    <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">next_edge</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">e.property</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">finj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">fsurj</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">card_of_bijective</span> <span class=\"o\">⟨</span><span class=\"n\">finj</span><span class=\"o\">,</span> <span class=\"n\">fsurj</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>(Small warning: I'm not sure how much more code is needed to fill them in.)</p>",
        "id": 259191326,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635308164
    },
    {
        "content": "<p>It's not accepting <code>v</code> as an input of <code>next_edge</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">next_edge</span> <span class=\"bp\">↑</span><span class=\"n\">v</span>\n<span class=\"n\">term</span>\n  <span class=\"bp\">↑</span><span class=\"n\">v</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">simple_graph</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span>\n</code></pre></div>",
        "id": 259225518,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635334690
    },
    {
        "content": "<p>Do you need <code>next_edge _ v</code>? With an extra underscore?</p>",
        "id": 259225710,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1635334802
    },
    {
        "content": "<p>Maybe <code>simple_graph _</code> shouldn't be an explicit argument of <code>next_edge</code>?</p>",
        "id": 259225783,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1635334851
    },
    {
        "content": "<p>The extra underscore before <code>v</code> worked, but I don't understand what you meant by <code>simple_graph _</code> being an argument of <code>next_edge</code></p>",
        "id": 259226153,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635335075
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> if you read the error message you can see it says \"you know where you put v? I was expecting you to put a simple graph\", and if you hover over <code>next_edge</code> you can see all the inputs it expects and in what order, so you can confirm that indeed the first input to that function is supposed to be a simple graph</p>",
        "id": 259226174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635335090
    },
    {
        "content": "<p>Do you understand about () and {} inputs to functions? (Edit -- and [] inputs) That's what Johan is talking about</p>",
        "id": 259226371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635335174
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> I guess you have <code>variables (foobar : simple_graph V)</code> somewhere above the definition of <code>next_edge</code>. I don't know much about the graph theory library, but maybe that should be <code>[simple_graph V]</code>.</p>",
        "id": 259226425,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1635335198
    },
    {
        "content": "<p>I'm gonna do some reading on that subject</p>",
        "id": 259226696,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635335364
    },
    {
        "content": "<p>The _ means \"Lean please work out yourself what this input should be\"</p>",
        "id": 259226706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635335378
    },
    {
        "content": "<p>But a more cunning choice of brackets will mean that you don't even need to put the _</p>",
        "id": 259226729,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635335394
    },
    {
        "content": "<p>Inputs in () brackets are supplied by the user, unless the user gives lean _ which puts the ball back into its court. Inputs in {} brackets are supplied by lean's unification system so the user skips them, and inputs in [] brackets are supplied by lean's type class inference system so the user skips them too.</p>",
        "id": 259226972,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635335524
    },
    {
        "content": "<p>Right now your error was giving lean a vertex when it wanted a simple graph, the suggested fix was to give it _ but another fix would be to change the type of bracket</p>",
        "id": 259227049,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635335581
    },
    {
        "content": "<blockquote>\n<p>Right now your error was giving lean a vertex when it wanted a simple graph</p>\n</blockquote>\n<p>If that's the error, then I think it's not just about the brackets. There's a logical error because we want <code>V</code> to be the vertices of a <code>simple_graph G</code>. So elements of <code>V</code>, such as <code>v</code>, shouldn't be of type <code>simple_graph</code></p>",
        "id": 259228051,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635336225
    },
    {
        "content": "<p>You can read the error, and it is what it is. I am not suggesting that v should have type simple_graph! I am however suggesting that Lean wanted something of type simple_graph where you put a v, and this is of your own making (because of your choice of brackets).</p>",
        "id": 259233713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635339361
    },
    {
        "content": "<p>If you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> with the error I can try and explain my point more clearly (apart from the fact that I'm about to go to a meeting)</p>",
        "id": 259233860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635339427
    },
    {
        "content": "<p>Yeah I copied/pasted Kyle's code and now I'm trying to catch up with his line of thought <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>. I'm still crawling in Lean so I don't think I can spot a MWE that manifests this error.<br>\nBut you're not the first one that mentions the possibility of improving the way that the assumptions are denoted (implicitly/explicitly) so that's definitely something to take into consideration as an improvement.</p>",
        "id": 259235478,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635340193
    },
    {
        "content": "<p>I'm asking if you could simply paste your fully (almost) working file with the error, so I don't have to go back over the entire thread and cut and paste all the parts together.</p>",
        "id": 259240720,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635342322
    },
    {
        "content": "<p>Let me try</p>",
        "id": 259241708,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635342700
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A walk is a sequence of adjacent vertices.  For vertices `u v : V`,</span>\n<span class=\"sd\">the type `walk u v` consists of all walks starting at `u` and ending at `v`.</span>\n\n<span class=\"sd\">We say that a walk *visits* the vertices it contains.  The set of vertices a</span>\n<span class=\"sd\">walk visits is `simple_graph.walk.support`. -/</span>\n<span class=\"kd\">@[derive decidable_eq]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">walk</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">walk</span> <span class=\"n\">u</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">walk</span> <span class=\"n\">u</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">refl</span><span class=\"o\">]</span> <span class=\"n\">walk.nil</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">next_edge</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">walk.nil</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"n\">hvw</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"n\">hvw</span><span class=\"o\">,</span> <span class=\"n\">sym2.mk_has_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_tree.card_edges_eq_card_vertices_sub_one'</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G.edge_set</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">card</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">root</span> <span class=\"o\">:=</span> <span class=\"n\">classical.arbitrary</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">set.card_ne_eq</span> <span class=\"n\">root</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">G.edge_set</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">next_edge</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">root</span> <span class=\"n\">v.property</span> <span class=\"o\">(</span><span class=\"n\">G.tree_path</span> <span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">root</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">root</span><span class=\"o\">),</span>\n    <span class=\"c1\">-- convert the term of incidence_set to an edge_set; there's probably a nicer way</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">a.property.1</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">fprop</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">],</span>\n    <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">next_edge</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">e.property</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">finj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">fsurj</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">card_of_bijective</span> <span class=\"o\">⟨</span><span class=\"n\">finj</span><span class=\"o\">,</span> <span class=\"n\">fsurj</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 259242244,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635342932
    },
    {
        "content": "<p>This file doesn't work for me.</p>",
        "id": 259242483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635343025
    },
    {
        "content": "<p>What branch of mathlib are you on? And there are universe issues.</p>",
        "id": 259242526,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635343044
    },
    {
        "content": "<p>The branch is called <code>more_on_trees</code>. I've just pushed a commit. The file is <code>src/combinatorics/simple_graph/connectivity.lean</code></p>",
        "id": 259242826,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635343163
    },
    {
        "content": "<p>The lemma starts at line 1251</p>",
        "id": 259242885,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635343193
    },
    {
        "content": "<p>There are errors on that branch for me, in files imported by the file you're working on. This can cause unexpected issues.</p>",
        "id": 259243242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635343316
    },
    {
        "content": "<p>But despite these issues I think I've seen enough to be able to say something coherent.</p>",
        "id": 259243352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635343353
    },
    {
        "content": "<p>Unfortunately I can't get <code>next_edge</code> compiling either on your branch or on master.</p>",
        "id": 259243957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635343610
    },
    {
        "content": "<p>But the definition mentions <code>G</code> and <code>G</code> is a variable which depends on <code>V</code>, so the actual type of <code>next_edge</code> will be something like <code>next_edge : \\forall {V : Type u} (G : simple_graph V),  ∀ (v w : V) (h : v ≠ w) (p : G.walk v w), G.incidence_set </code></p>",
        "id": 259244252,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635343714
    },
    {
        "content": "<p>Yeah Kyle introduced the definition of <code>next_edge</code> just today, here on Zulip</p>",
        "id": 259244258,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635343717
    },
    {
        "content": "<p>And the reason that V is in {} brackets and G is in () brackets is because of the <code>variables {V : Type u} (G : simple_graph V)</code> line</p>",
        "id": 259244349,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635343750
    },
    {
        "content": "<p>The brackets for the <code>next_edge</code> variables correspond to the brackets used in the <code>variables</code> command earlier.</p>",
        "id": 259244456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635343799
    },
    {
        "content": "<p>So the first user-provided input for <code>next_edge</code> needs to be a term of type <code>simple_graph V</code></p>",
        "id": 259244558,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635343823
    },
    {
        "content": "<p>and then the second and third inputs are two terms of type V etc etc</p>",
        "id": 259244619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635343846
    },
    {
        "content": "<p>And so the error you get is correct, because of the choice of brackets in the <code>variables</code> line.</p>",
        "id": 259244897,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635343937
    },
    {
        "content": "<p>Johan suggested making them <code>[]</code> but it seems that <code>simple_graph</code> is a structure not a class, which means that the designers have left open the possibility that you might want to consider more than one structure of a simple graph on a fixed vertex type <code>V</code>. As a result the type class inference system does not know about <code>simple_graph</code> so <code>[]</code> brackets won't work.</p>",
        "id": 259245221,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635344072
    },
    {
        "content": "<p>The other possibility is that you change <code>(G : simple_graph V)</code> into <code>{G : simple_graph V}</code> and in this case you'll be asking the unification system to fill in the variable for you. This could well work, because now my guess for what <code>next_edge</code> will want to eat is first two elements v,w of V, then a proof that v!=w, and finally a term <code>p</code> of type <code>G.walk v w</code>, and once Lean sees this term it will be able to look at its type and guess what <code>G</code> was, as the term <code>G</code> is mentioned in the type of <code>p</code>, and this is exactly the sort of thing which the unification system does. So I suspect that changing <code>(G : simple_graph V)</code> to <code>{G : simple_graph V}</code> on the variables line (or, if this variables line is on line 10 of the code and you're looking at line 1000, writing a new line <code>variable {G}</code> just above the definition of <code>next_edge</code>) will be another way of fixing the error you were seeing (other than adding in the <code>_</code>).</p>",
        "id": 259245923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635344350
    },
    {
        "content": "<p>It worked :D<br>\nI'm learning the syntax slowly. For instance, it's not clear to me why the first parameter of <code>next_edge</code> is a <code>simple_graph</code>.<br>\nWhen I read</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">next_edge</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">walk.nil</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"n\">hvw</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"n\">hvw</span><span class=\"o\">,</span> <span class=\"n\">sym2.mk_has_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>just by checking the matches I see four inputs (like <code>v w h walk.nil</code>)</p>",
        "id": 259248182,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635345180
    },
    {
        "content": "<p>Yes but you also see V and G, right? Where are they coming from?</p>",
        "id": 259248275,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635345212
    },
    {
        "content": "<p>That's what <code>variables</code> do for you -- they are automatically added as inputs to any function which mentions them by name.</p>",
        "id": 259248338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635345231
    },
    {
        "content": "<p>They're not there when the function is defined, but when you use the function you have to supply them</p>",
        "id": 259248467,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635345264
    },
    {
        "content": "<p>The <code>|</code> magic is supplying them, but if you do <code>#check @next_edge</code> just after the definition, or hover over it in a place where it's used in a theorem, you'll see the extra inputs.</p>",
        "id": 259248609,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635345324
    },
    {
        "content": "<p>Will Lean4 work like this too?</p>",
        "id": 259248975,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635345473
    },
    {
        "content": "<p>Yup</p>",
        "id": 259249040,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635345484
    },
    {
        "content": "<p>Okay then I better get used to it. I think it's a bit hard on the reader but I see how it speeds up writing</p>",
        "id": 259249462,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635345634
    },
    {
        "content": "<p>Sorry for the confusion I've seemed to cause with the code I posted. I had written it at the end of <code>src/combinatorics/simple_graph/connectivity.lean</code> in the <code>walks_and_trees</code> branch right before the final <code>end simple_graph</code>, so the full context was <code>variables {V : Type u} {G : simple_graph V} [decidable_eq V]</code> in the <code>simple_graph</code> namespace.</p>",
        "id": 259266955,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635352333
    },
    {
        "content": "<p>It looks like errors in imports are from someone helpfully merging master to bring the branch up to date, but this introduced some small errors. (<span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> if you want to fix them, in <code>subgraph.lean</code> look for  the couple cases of <code>sym :=</code> and replace them with <code>symm :=</code>. I think that's it.)</p>",
        "id": 259267922,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635352722
    },
    {
        "content": "<p>Nice. I had replaced some occurrences of <code>sym</code> by <code>symm</code> but I seem to have overlooked two of them</p>",
        "id": 259270899,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635353873
    },
    {
        "content": "<p>Declaring <code>variables</code> actually makes it easier for the reader too, if used properly. If you're working on something where you have 10 theorems, all about some 3 or 4 variables, then having to read the same arguments in each theorem is cumbersome. Separating out the common variables makes it clear to the reader that the next few theorems are all about these variables.</p>\n<p>Even in maths we do this a lot when we say \"let X, Y be topological spaces, f a continuous function from X to Y, yada yada, theorem 1... theorem n\"</p>",
        "id": 259276244,
        "sender_full_name": "Anupam Nayak",
        "timestamp": 1635355990
    },
    {
        "content": "<p>That someone being me <span aria-label=\"exhausted\" class=\"emoji emoji-1f625\" role=\"img\" title=\"exhausted\">:exhausted:</span></p>",
        "id": 259276882,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635356277
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I was also trying to make this definition a bit clearer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">next_edge</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">walk.nil</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"n\">hvw</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"n\">hvw</span><span class=\"o\">,</span> <span class=\"n\">sym2.mk_has_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Do you think it's worth the effort?</p>",
        "id": 259289686,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635361231
    },
    {
        "content": "<p>What does <code>mem</code> stand for?</p>",
        "id": 259289855,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635361300
    },
    {
        "content": "<p><code>next_edge</code> would be better if <code>G</code> were an explicit argument, but it doesn't make the definition clearer.  I'm not sure it could be made simpler.</p>\n<p>By doubling the amount of code, you can split off the proof of incidence from the edge the function outputs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">next_edge</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">walk.nil</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"n\">hvw</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">next_edge_mem_incidence_set</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.next_edge</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"n\">sym2.mk_has_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 259290606,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635361602
    },
    {
        "content": "<p><code>mem</code> is used in a name for <code>∈</code></p>",
        "id": 259290679,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635361635
    },
    {
        "content": "<p>this is the current diff: <a href=\"https://github.com/leanprover-community/mathlib/pull/9993/files\">https://github.com/leanprover-community/mathlib/pull/9993/files</a></p>",
        "id": 259298750,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635365121
    },
    {
        "content": "<p>If I have <code>e: ↥(G.edge_set)</code>, how to get the vertices that compose <code>e</code>?</p>",
        "id": 259309569,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635370269
    },
    {
        "content": "<p><code>e.1</code> gives you an edge. From there it's a good exercise to define what you want. There are several ways to do it.</p>",
        "id": 259310488,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635370714
    },
    {
        "content": "<p>I guess <code>e.val</code> will have type <code>sym2 V</code> so look at the API for <code>sym2</code> by right clicking on it</p>",
        "id": 259310568,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635370769
    },
    {
        "content": "<p>oh hmm it's a quotient. You could use <code>quotient.out</code> I guess</p>",
        "id": 259310749,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635370868
    },
    {
        "content": "<p>If you don't find what you want, don't worry but do tell us. The API for <code>sym2</code> is currently crap and we have plans to improve it.</p>",
        "id": 259310904,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635370934
    },
    {
        "content": "<p>I think it's better to explain the strategy I'd apply if I were to prove it in a undergrad course, then I can use some help on translating my intent to Lean.</p>\n<p>This is my current state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span>\n<span class=\"n\">_inst_1</span><span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">V</span>\n<span class=\"n\">_inst_2</span><span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">G.edge_set</span><span class=\"o\">)</span>\n<span class=\"n\">_inst_3</span><span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">V</span>\n<span class=\"n\">_inst_4</span><span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">V</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">G.is_tree</span>\n<span class=\"n\">root</span><span class=\"o\">:</span> <span class=\"n\">V</span>\n<span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">G.edge_set</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">}),</span> <span class=\"o\">⟨</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">next_edge</span> <span class=\"bp\">↑</span><span class=\"n\">v</span> <span class=\"n\">root</span> <span class=\"n\">_</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">G.tree_path</span> <span class=\"n\">h</span> <span class=\"bp\">↑</span><span class=\"n\">v</span> <span class=\"n\">root</span><span class=\"o\">)),</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n<span class=\"n\">fprop</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span>\n<span class=\"n\">finj</span><span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span>\n<span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">G.edge_set</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">}),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">e</span>\n</code></pre></div>\n<p>That is, I need to prove that given an edge <code>e</code> of a tree <code>G</code> and a root vertex <code>root</code>,  I can retrieve <code>a</code> as the furthest vertex that composes <code>e</code></p>",
        "id": 259311560,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635371335
    },
    {
        "content": "<p><code>f</code> is a function that returns the last edge on a path from <code>root</code> to a given vertex</p>",
        "id": 259311840,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635371487
    },
    {
        "content": "<p>My intuition is to take <code>e1</code> and <code>e2</code> as the vertices that compose <code>e</code> and apply <code>f</code> to them. Either <code>f(e1)</code> or <code>f(e2)</code> will result in <code>e</code></p>",
        "id": 259312370,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635371834
    },
    {
        "content": "<p>The proof wouldn't be complete because I'd need to prove that last sentence. My struggle is to translate my thoughts into Lean</p>",
        "id": 259312797,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635372051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/259310904\">said</a>:</p>\n<blockquote>\n<p>The API for <code>sym2</code> is currently crap and we have plans to improve it.</p>\n</blockquote>\n<p>Where's this sentiment coming from? It certainly has everything necessary for this (though of course things can always be improved.)</p>",
        "id": 259312822,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635372061
    },
    {
        "content": "<p>Doing SRL <span aria-label=\"stuck out tongue closed eyes\" class=\"emoji emoji-1f61d\" role=\"img\" title=\"stuck out tongue closed eyes\">:stuck_out_tongue_closed_eyes:</span></p>",
        "id": 259312849,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635372077
    },
    {
        "content": "<p>Bhavik identified two stupid lemmas which made our life much easier. But we still ended up not using <code>sym2</code> anymore (well, except for the intrinsically <code>simple_graph</code>part).</p>",
        "id": 259312986,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635372141
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> One way to do this is this incantation: <code>cases e with e he, refine quotient.ind (λ p, _) e, cases p with v w,</code></p>",
        "id": 259313429,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635372420
    },
    {
        "content": "<p>Oh, wait, that doesn't generalize a variable correctly.</p>",
        "id": 259313500,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635372474
    },
    {
        "content": "<p>Maybe <code>cases e with e he, induction e using quotient.ind, cases e with v w,</code></p>",
        "id": 259313599,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635372527
    },
    {
        "content": "<p>I could have sworn there was a <code>sym2.ind</code> that we added, but I guess it was just <code>sym2.lift</code></p>",
        "id": 259313765,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635372618
    },
    {
        "content": "<p>We have <code>sym2.ind</code> in <a href=\"https://github.com/leanprover-community/mathlib/tree/szemeredi\">branch#szemeredi</a></p>",
        "id": 259313830,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635372671
    },
    {
        "content": "<p>Now I need to take the furthest one (between <code>v</code> and <code>w</code>) from <code>root</code></p>",
        "id": 259315319,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635373476
    },
    {
        "content": "<p>I'm gonna spend a few hours here: <a href=\"https://leanprover.github.io/reference/tactics.html\">https://leanprover.github.io/reference/tactics.html</a></p>",
        "id": 259316004,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635373854
    },
    {
        "content": "<p>Some info on that page might be out of date. I suspect you'd be better off reading the <a href=\"https://leanprover.github.io/theorem_proving_in_lean/tactics.html\">corresponding chapter of TPiL</a> and referring to <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html\">our tactic docs</a> as needed.</p>",
        "id": 259317725,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1635374948
    },
    {
        "content": "<p>Here's sort of what I was imagining for surjectivity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">next_edge</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">walk.nil</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"n\">hvw</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"n\">hvw</span><span class=\"o\">,</span> <span class=\"n\">sym2.mk_has_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nonempty_path_not_loop</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.path</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">walk.edges</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hp_support_nodup</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eq_next_edge_if_mem_path</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hne</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">≠</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hinc</span> <span class=\"o\">:</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.path</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">edges</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.next_edge</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">hne</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"n\">hinc</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hne</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hp_support_nodup</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">next_edge</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">congr</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.mem_cons_iff</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">simple_graph.walk.cons_edges</span><span class=\"o\">,</span> <span class=\"n\">sym2.eq_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">(⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span><span class=\"bp\">|</span><span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩)</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">walk.mem_support_of_mem_edges</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hp_support_nodup.1</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_tree_then_card_edges_eq_card_vertices_minus_one</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G.edge_set</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">card</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">root</span> <span class=\"o\">:=</span> <span class=\"n\">classical.arbitrary</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">set.card_ne_eq</span> <span class=\"n\">root</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">G.edge_set</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"o\">⟨</span><span class=\"n\">G.next_edge</span> <span class=\"n\">v</span> <span class=\"n\">root</span> <span class=\"n\">v.property</span> <span class=\"o\">(</span><span class=\"n\">G.tree_path</span> <span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">root</span><span class=\"o\">),</span>\n     <span class=\"n\">G.incidence_set_subset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">subtype.mem</span> <span class=\"n\">_</span><span class=\"o\">)⟩,</span>\n  <span class=\"k\">have</span> <span class=\"n\">fprop</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">subtype.mem</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">finj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">fsurj</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">e</span> <span class=\"n\">using</span> <span class=\"n\">quotient.ind</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">is_rootward_or_reverse</span> <span class=\"n\">h</span> <span class=\"n\">root</span> <span class=\"n\">he</span> <span class=\"k\">with</span> <span class=\"n\">hr</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"c1\">-- goal is equivalently v ≠ root; substitute v for root</span>\n      <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_rootward</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">nonempty_path_not_loop</span> <span class=\"n\">_</span> <span class=\"n\">hr.2</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">],</span>\n      <span class=\"n\">erw</span> <span class=\"n\">eq_next_edge_if_mem_path</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"n\">_</span> <span class=\"n\">hr_right</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- do the same thing again. use wlog?</span>\n    <span class=\"o\">},</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">card_of_bijective</span> <span class=\"o\">⟨</span><span class=\"n\">finj</span><span class=\"o\">,</span> <span class=\"n\">fsurj</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 259317906,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635375078
    },
    {
        "content": "<p>With the right lemmas, this could be a lot cleaner.  I'm also not sure if going through <code>is_rootward_or_reverse</code> and using the definition of <code>is_rootward</code> is the best way, but at least it works.</p>",
        "id": 259318021,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635375143
    },
    {
        "content": "<p><code>eq_next_edge_if_mem_path</code> is not being accepted</p>",
        "id": 259318507,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635375482
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">field</span> <span class=\"kd\">notation</span><span class=\"o\">,</span> <span class=\"n\">function</span> <span class=\"bp\">'</span><span class=\"n\">simple_graph.next_edge'</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"k\">have</span> <span class=\"n\">explicit</span> <span class=\"n\">argument</span> <span class=\"k\">with</span> <span class=\"n\">type</span> <span class=\"o\">(</span><span class=\"n\">simple_graph</span> <span class=\"bp\">...</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 259318561,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635375500
    },
    {
        "content": "<p>Note that I changed the definition of <code>next_edge</code> to include <code>G</code> as an explicit argument</p>",
        "id": 259318581,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635375518
    },
    {
        "content": "<p>Oh, ok<br>\nNow it failed to instantiate goal with <code>v</code> on the <code>use</code> tactic</p>",
        "id": 259318675,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635375598
    },
    {
        "content": "<p>brb</p>",
        "id": 259318731,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635375607
    },
    {
        "content": "<p>Alright, had to do some tweaks, but I was able to finish up surjection:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">next_edge</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">walk.nil</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">u</span> <span class=\"n\">_</span> <span class=\"n\">hvw</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"n\">hvw</span><span class=\"o\">,</span> <span class=\"n\">sym2.mk_has_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nonempty_path_not_loop</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.path</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">walk.edges</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hp_support_nodup</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eq_next_edge_if_mem_path</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hne</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">≠</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hinc</span> <span class=\"o\">:</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.path</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">edges</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.next_edge</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">hne</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"n\">hinc</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hne</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hp_support_nodup</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">next_edge</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">congr</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.mem_cons_iff</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">simple_graph.walk.cons_edges</span><span class=\"o\">,</span> <span class=\"n\">sym2.eq_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">(⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span><span class=\"bp\">|</span><span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩)</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">walk.mem_support_of_mem_edges</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hp_support_nodup.1</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_tree.card_edges_eq_card_vertices_sub_one</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G.edge_set</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">card</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">root</span> <span class=\"o\">:=</span> <span class=\"n\">classical.arbitrary</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">set.card_ne_eq</span> <span class=\"n\">root</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">G.edge_set</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"o\">⟨</span><span class=\"n\">G.next_edge</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">root</span> <span class=\"n\">v.property</span> <span class=\"o\">(</span><span class=\"n\">G.tree_path</span> <span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">root</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">root</span><span class=\"o\">),</span>\n     <span class=\"n\">G.incidence_set_subset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">subtype.mem</span> <span class=\"n\">_</span><span class=\"o\">)⟩,</span>\n  <span class=\"k\">have</span> <span class=\"n\">fprop</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">subtype.mem</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">finj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">,</span>\n\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">fsurj</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">e</span> <span class=\"n\">using</span> <span class=\"n\">quotient.ind</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">is_rootward_or_reverse</span> <span class=\"n\">h</span> <span class=\"n\">root</span> <span class=\"n\">he</span> <span class=\"k\">with</span> <span class=\"n\">hr</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">e₁</span><span class=\"o\">,</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n      <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_rootward</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">nonempty_path_not_loop</span> <span class=\"n\">_</span> <span class=\"n\">hr.2</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:=</span> <span class=\"n\">eq_next_edge_if_mem_path</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hr_right</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">],</span>\n        <span class=\"n\">erw</span> <span class=\"n\">key</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sym2.eq_swap</span><span class=\"o\">]},</span>\n      <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">sym2.eq_swap</span><span class=\"o\">]},</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">e₂</span><span class=\"o\">,</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n      <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_rootward</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">nonempty_path_not_loop</span> <span class=\"n\">_</span> <span class=\"n\">hr.2</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:=</span> <span class=\"n\">eq_next_edge_if_mem_path</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hr_right</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">],</span>\n        <span class=\"n\">erw</span> <span class=\"n\">key</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sym2.eq_swap</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">he</span><span class=\"o\">]},</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">card_of_bijective</span> <span class=\"o\">⟨</span><span class=\"n\">finj</span><span class=\"o\">,</span> <span class=\"n\">fsurj</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 259325808,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635381401
    },
    {
        "content": "<p>Nice. By the way, I modified my comment shortly after posting it with some minor proof simplifications in the surjection proof</p>",
        "id": 259326115,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635381687
    },
    {
        "content": "<p>Any reason you changed it to <code>cases e with e₁ e₂</code>? This splits <code>e</code> into two vertices, so naming-wise either <code>v w</code> or <code>v₁ v₂</code> seem potentially better.</p>",
        "id": 259326369,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635381884
    },
    {
        "content": "<p>hm, I wanted to use something different than <code>v</code>. Maybe <code>w</code> suits better</p>",
        "id": 259326479,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635381963
    },
    {
        "content": "<p>or <code>u₁ u₂</code>?</p>",
        "id": 259326508,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635381987
    },
    {
        "content": "<p>I'm gonna try to use your optimized solution to prove it for the other vertex</p>",
        "id": 259326808,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635382281
    },
    {
        "content": "<p>There's also <code>wlog</code> since the two cases are basically the same except for permuting the vertices, but it gives a very slow proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"n\">fsurj</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">e</span> <span class=\"n\">using</span> <span class=\"n\">quotient.ind</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span><span class=\"o\">,</span>\n    <span class=\"n\">wlog</span> <span class=\"o\">:=</span> <span class=\"n\">is_rootward_or_reverse</span> <span class=\"n\">h</span> <span class=\"n\">root</span> <span class=\"n\">he</span> <span class=\"n\">using</span> <span class=\"o\">[</span><span class=\"n\">u₁</span> <span class=\"n\">u₂</span><span class=\"o\">],</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">u₁</span><span class=\"o\">,</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n      <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_rootward</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">case</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">nonempty_path_not_loop</span> <span class=\"n\">_</span> <span class=\"n\">case.2</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">case</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">],</span>\n      <span class=\"n\">erw</span> <span class=\"n\">eq_next_edge_if_mem_path</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"n\">_</span> <span class=\"n\">case_right</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">G.symm</span> <span class=\"n\">he</span><span class=\"o\">),</span>\n    <span class=\"n\">use</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">sym2.eq_swap</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n</code></pre></div>",
        "id": 259327206,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635382607
    },
    {
        "content": "<p>Slow in terms of processing? Like it's more time consuming?</p>",
        "id": 259327271,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635382674
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">fsurj</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">e</span> <span class=\"n\">using</span> <span class=\"n\">quotient.ind</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">is_rootward_or_reverse</span> <span class=\"n\">h</span> <span class=\"n\">root</span> <span class=\"n\">he</span> <span class=\"k\">with</span> <span class=\"n\">hr</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">u₁</span><span class=\"o\">,</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n      <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_rootward</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">nonempty_path_not_loop</span> <span class=\"n\">_</span> <span class=\"n\">hr.2</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">],</span>\n      <span class=\"n\">erw</span> <span class=\"n\">eq_next_edge_if_mem_path</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"n\">_</span> <span class=\"n\">hr_right</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">he</span><span class=\"o\">]},</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">u₂</span><span class=\"o\">,</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n      <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_rootward</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">nonempty_path_not_loop</span> <span class=\"n\">_</span> <span class=\"n\">hr.2</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">],</span>\n      <span class=\"n\">erw</span> <span class=\"n\">eq_next_edge_if_mem_path</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">_</span> <span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"n\">_</span> <span class=\"n\">hr_right</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">sym2.eq_swap</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n</code></pre></div>",
        "id": 259327881,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635383122
    },
    {
        "content": "<p>okay I'm gonna push this version to my branch</p>",
        "id": 259327945,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635383170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I was thinking yesterday about the function <code>f</code> you defined inside the proof and I realized that <code>f</code> being (or not) surjective and injective is closely related with the definition of trees. That is, if <code>f</code> is not surjective then there's a pair of vertices that are not reachable from the root. And if <code>if</code> is not injective, then there is a cycle in <code>G</code>. Do you think this approach could be clearer?<br>\nFor the injection, at least, I'd want to try a proof by contradiction by finding a cycle. What do you think?</p>",
        "id": 259377702,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635422781
    },
    {
        "content": "<p>Branch updated!<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/9993\">https://github.com/leanprover-community/mathlib/pull/9993</a><br>\nPlease let me know what you think <span aria-label=\"rocket\" class=\"emoji emoji-1f680\" role=\"img\" title=\"rocket\">:rocket:</span></p>",
        "id": 259421711,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635441140
    },
    {
        "content": "<p>That approach would definitely work (for non-injectivity, it would be nice if there were a way to construct a cycle from <code>f</code> somewhat directly, by iteratively applying it to the opposite vertex across the output edge, but that would take some more work to develop).</p>\n<p>Something I forgot to mention is that <code>is_rootward_or_reverse</code> and <code>is_rootward_antisymm</code> do these kinds of cycle argument already, and I figured it might save some work to use them.  However, it would be a good exercise to not use them, for both you and for the library (to help see what's missing).</p>",
        "id": 259424078,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635442180
    },
    {
        "content": "<p>Yeah I'm trying as hard as I can to translate the logic inside my mind into Lean. The proof by cycle construction seems to be going okay, unless I've set myself for some very hard intermediate proof that I can't see right now. From your perspective, do you see a trap like that in my code? I mean, is any of those <code>sorry</code>s that I inserted super hard for my current level?</p>",
        "id": 259426315,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635443227
    },
    {
        "content": "<p>Okay, 1 <code>sorry</code> down. 1 <code>sorry</code> left</p>",
        "id": 259428052,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635443916
    },
    {
        "content": "<p>What you're doing seems doable (if perhaps all a bit of a trial by fire <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> but you seem to be fine with that!).</p>\n<p>I wanted to check my suggestion to use <code>is_rootward_antisymm</code> actually panned out, so I went ahead and proved injectivity with it. It'd be better if you kept going with your approach, so don't let this spoiler-tagged-code stop you.</p>\n<p>Here's a utility lemma that may or may not be helpful to you:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">next_edge_mem_edges</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G.next_edge</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">p.edges</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">next_edge</span><span class=\"o\">,</span> <span class=\"n\">list.mem_cons_iff</span><span class=\"o\">,</span> <span class=\"n\">walk.cons_edges</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">left</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_tree_then_card_edges_eq_card_vertices_minus_one</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G.edge_set</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">card</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">root</span> <span class=\"o\">:=</span> <span class=\"n\">classical.arbitrary</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">set.card_ne_eq</span> <span class=\"n\">root</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">G.edge_set</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"o\">⟨</span><span class=\"n\">G.next_edge</span> <span class=\"n\">v</span> <span class=\"n\">root</span> <span class=\"n\">v.property</span> <span class=\"o\">(</span><span class=\"n\">G.tree_path</span> <span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">root</span><span class=\"o\">),</span>\n     <span class=\"n\">G.incidence_set_subset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">subtype.mem</span> <span class=\"n\">_</span><span class=\"o\">)⟩,</span>\n  <span class=\"k\">have</span> <span class=\"n\">fprop</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">root</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">subtype.mem</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">finj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">u₁</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">u₂</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">hne</span> <span class=\"o\">:</span> <span class=\"n\">u₁</span> <span class=\"bp\">=</span> <span class=\"n\">u₂</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">u₂</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">generalize</span> <span class=\"n\">he₁</span> <span class=\"o\">:</span> <span class=\"n\">G.next_edge</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">e₁</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize</span> <span class=\"n\">he₂</span> <span class=\"o\">:</span> <span class=\"n\">G.next_edge</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">e₂</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e₁</span> <span class=\"k\">with</span> <span class=\"n\">e₁</span> <span class=\"n\">heu₁</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e₂</span> <span class=\"k\">with</span> <span class=\"n\">e₂</span> <span class=\"n\">heu₂</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">heu₁</span> <span class=\"k\">with</span> <span class=\"n\">heu₁_edge</span> <span class=\"n\">heu₁_adj</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">heu₂</span> <span class=\"k\">with</span> <span class=\"n\">heu₂_edge</span> <span class=\"n\">heu₂_adj</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.coe_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">heu₁_adj</span> <span class=\"n\">heu₂_adj</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">e_is</span> <span class=\"o\">:</span> <span class=\"n\">e₁</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">u₁</span><span class=\"o\">,</span> <span class=\"n\">u₂</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">induction</span> <span class=\"n\">e₁</span> <span class=\"n\">using</span> <span class=\"n\">quotient.ind</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">e₁</span> <span class=\"k\">with</span> <span class=\"n\">v₁</span> <span class=\"n\">w₁</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sym2.mem_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">heu₁_adj</span> <span class=\"n\">heu₂_adj</span><span class=\"o\">,</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">heu₁_adj</span><span class=\"bp\">;</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">heu₂_adj</span><span class=\"bp\">;</span>\n      <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hne</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">}</span><span class=\"bp\">;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sym2.eq_swap</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n    <span class=\"n\">subst</span> <span class=\"n\">e₁</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">is_rootward_antisymm</span> <span class=\"n\">h</span> <span class=\"n\">root</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">heu₂_edge</span><span class=\"o\">,</span>\n      <span class=\"n\">convert</span> <span class=\"n\">G.next_edge_mem_edges</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h₁</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">erw</span> <span class=\"n\">he₁</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">G.symm</span> <span class=\"n\">heu₂_edge</span><span class=\"o\">,</span>\n      <span class=\"n\">convert</span> <span class=\"n\">G.next_edge_mem_edges</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h₂</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">erw</span> <span class=\"n\">he₂</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sym2.eq_swap</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">fsurj</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">e</span> <span class=\"n\">using</span> <span class=\"n\">quotient.ind</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"k\">with</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span><span class=\"o\">,</span>\n    <span class=\"n\">wlog</span> <span class=\"o\">:=</span> <span class=\"n\">is_rootward_or_reverse</span> <span class=\"n\">h</span> <span class=\"n\">root</span> <span class=\"n\">he</span> <span class=\"n\">using</span> <span class=\"o\">[</span><span class=\"n\">u₁</span> <span class=\"n\">u₂</span><span class=\"o\">],</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">u₁</span><span class=\"o\">,</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n      <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_rootward</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">case</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">nonempty_path_not_loop</span> <span class=\"n\">_</span> <span class=\"n\">case.2</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">case</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">],</span>\n      <span class=\"n\">erw</span> <span class=\"n\">eq_next_edge_if_mem_path</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"n\">_</span> <span class=\"n\">case_right</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">G.symm</span> <span class=\"n\">he</span><span class=\"o\">),</span>\n    <span class=\"n\">use</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">sym2.eq_swap</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">card_of_bijective</span> <span class=\"o\">⟨</span><span class=\"n\">finj</span><span class=\"o\">,</span> <span class=\"n\">fsurj</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 259430750,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635445170
    },
    {
        "content": "<p>Now that <code>next_edge</code> exists, it would probably be better to redefine <code>next_edge</code> and <code>is_rootward</code> so there's less of an impedance mismatch. Too much of the proof seems to be moving data around to put things into or out of a form that works for the definition of <code>is_rootward</code>.</p>",
        "id": 259431141,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635445336
    },
    {
        "content": "<p>(This part of the branch is much more experimental -- I'd wanted to see whether there was already enough stuff to be able to come up with <em>some</em> definition for <code>is_rootward</code> that satisfied lemmas <code>is_rootward_antisymm</code> and <code>is_rootward_or_reverse</code>.)</p>",
        "id": 259432018,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635445754
    },
    {
        "content": "<p>Another way this argument could have been organized is to define two functions <code>parent child : G.edge_set -&gt; V</code> when given a root.  These functions give the structure of the rooted tree, and <code>e = ⟦(parent e, child e)⟧</code> for all e (modulo coercions).  Then you'd show that <code>child</code> is injective, and its image is the set of non-root vertices.  Taking cardinalities, you get the result.</p>",
        "id": 259433075,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635446215
    },
    {
        "content": "<p>Hm, I got stuck on that part. I was able to build a circuit but I'm not seeing how I can prove that the graph is not acyclic</p>",
        "id": 259449527,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635453938
    },
    {
        "content": "<p>Maybe the proof of <code>is_rootward_or_reverse</code> might have some hint.  <code>walk.to_path</code> is a way to turn a walk into a path, so that's a way to get a cycle from a circuit.</p>",
        "id": 259450869,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635454658
    },
    {
        "content": "<p>I got the cycle but I don't know how to say \"here's the cycle, G is not acyclic\"</p>",
        "id": 259454009,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635456173
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">has_cycle</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">G.is_acyclic</span><span class=\"o\">,</span>\n<span class=\"k\">let</span> <span class=\"n\">cycle</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">walk.to_path</span> <span class=\"n\">circuit</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u₁</span> <span class=\"n\">u₁</span><span class=\"o\">),</span>\n</code></pre></div>",
        "id": 259454222,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635456328
    },
    {
        "content": "<p>Oh, I led you down a bad path, sorry.  That defines the empty path -- <code>walk.to_path</code> will delete everything since there's only one path from a vertex to itself.</p>",
        "id": 259454535,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635456513
    },
    {
        "content": "<p>It might be easier applying <code>lemma is_acyclic_iff : G.is_acyclic ↔ ∀ (v w : V) (p q : G.path v w), p = q</code>.  If you <code>intro</code> your goal, you get a <code>G.is_acyclic</code> hypothesis, which you can rw with this lemma.</p>",
        "id": 259454739,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635456640
    },
    {
        "content": "<p>Then you can <code>specialize</code> it to the two paths you built your circuit from.  I'm not sure if this is the best way, but you should be able to get that either u1 or u2 is equal to root, which is a contradiction.</p>",
        "id": 259454775,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635456668
    },
    {
        "content": "<p>I'm not being able to break down <code>g</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">u₁_root_u₂</span><span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span> <span class=\"o\">:=</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">G.tree_path</span> <span class=\"n\">h</span> <span class=\"n\">u₁</span> <span class=\"n\">root</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">G.tree_path</span> <span class=\"n\">h</span> <span class=\"n\">u₂</span> <span class=\"n\">root</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reverse</span>\n<span class=\"n\">u₁_u₂</span><span class=\"o\">:</span> <span class=\"n\">G.path</span> <span class=\"o\">(</span><span class=\"n\">u₁</span><span class=\"o\">,</span> <span class=\"n\">u₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"o\">(</span><span class=\"n\">u₁</span><span class=\"o\">,</span> <span class=\"n\">u₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"o\">:=</span> <span class=\"n\">path.singleton</span> <span class=\"n\">e_prop</span>\n<span class=\"n\">u₂_u₁</span><span class=\"o\">:</span> <span class=\"n\">G.path</span> <span class=\"n\">u₂</span> <span class=\"n\">u₁</span>\n<span class=\"n\">circuit</span><span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u₁</span> <span class=\"n\">u₁</span> <span class=\"o\">:=</span> <span class=\"n\">u₁_root_u₂.append</span> <span class=\"bp\">↑</span><span class=\"n\">u₂_u₁</span>\n<span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">u₁_root_u₂.to_path</span> <span class=\"bp\">=</span> <span class=\"n\">u₁_u₂</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 259466247,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635464232
    },
    {
        "content": "<p>This is so close!</p>",
        "id": 259466661,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635464553
    },
    {
        "content": "<p>Okay I need another cue <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> <br>\nafter this one I'm gonna go to the very basics. I'm sure I will understand a lot more</p>",
        "id": 259470404,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635467664
    },
    {
        "content": "<p>Ah, I actually found an issue with my plan. Because of the way circuits are defined, a circuit can be something like <code>u -&gt; v -&gt; w -&gt; v -&gt; u</code></p>",
        "id": 259519854,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635512240
    },
    {
        "content": "<p>Which doesn't even contain a cycle</p>",
        "id": 259519880,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635512259
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> feel free to hit the merge button if you think everything is okay:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/9993/files\">https://github.com/leanprover-community/mathlib/pull/9993/files</a></p>",
        "id": 259520348,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635512481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> feel free to hit the merge button if you think everything is okay:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/9993/files\">https://github.com/leanprover-community/mathlib/pull/9993/files</a></p>",
        "id": 259520370,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635512491
    },
    {
        "content": "<p>There's something strange about our branches. A lot of things break when I merge <code>master</code> into them <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 259551644,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635525819
    },
    {
        "content": "<p>What kind of stuff? Some of it might might my fault.</p>",
        "id": 259552150,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635526081
    },
    {
        "content": "<p>Hm, we can go slowly. First, <code>simple_graph/adj_matrix</code> is not working on <code>more_on_trees</code></p>",
        "id": 259552427,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635526213
    },
    {
        "content": "<p>It doesn't work on <code>walks_and_trees</code> either. But this PR (<code>walks_and_trees</code> into <code>master</code>) is open and without broken tests:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/8737\">https://github.com/leanprover-community/mathlib/pull/8737</a></p>",
        "id": 259553453,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635526683
    },
    {
        "content": "<p><code>more_on_trees</code> contains fixes for <code>walks_and_trees</code>. So if we can get <code>more_on_trees</code> it to work, <a href=\"https://github.com/leanprover-community/mathlib/pull/9993\">this PR</a> will fix <code>walks_and_trees</code></p>",
        "id": 259553797,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635526826
    },
    {
        "content": "<p>Long story short, can you help me fix <code>more_on_walks</code>? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 259553890,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635526872
    },
    {
        "content": "<p>Let's have a look!</p>",
        "id": 259553910,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635526883
    },
    {
        "content": "<p>Wait 10-15min, I'm onto something else right now.</p>",
        "id": 259553978,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635526919
    },
    {
        "content": "<p>Np, I'm investigating these merges a little further</p>",
        "id": 259554354,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635527120
    },
    {
        "content": "<p>2 months ago <a href=\"https://github.com/leanprover-community/mathlib/blame/walks_and_trees/src/combinatorics/simple_graph/adj_matrix.lean#L315\">this line</a> was added. but nowadays, <code>R</code> cannot be found anymore</p>",
        "id": 259555150,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635527508
    },
    {
        "content": "<p>Back then, <a href=\"https://github.com/leanprover-community/mathlib/blob/798b240b2e09a308b5f661fffcb16c7cf3edbc32/src/combinatorics/simple_graph/adj_matrix.lean#L28\">this was the line</a> that introduced <code>R</code> (a <code>semiring</code>)</p>",
        "id": 259555470,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635527647
    },
    {
        "content": "<p>Don't worry too much, this happens all the time. You write something, then someone comes along and changes the <code>variables</code> and bem your branch broke.</p>",
        "id": 259556020,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635527926
    },
    {
        "content": "<p>But... how come can they merge something if their changes break other parts of the code?</p>",
        "id": 259556092,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635527980
    },
    {
        "content": "<p>Shouldn't the build test fail?</p>",
        "id": 259556105,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635527988
    },
    {
        "content": "<p>CI ensures that <code>master</code> branch still compiles. It doesn't care about other branches.</p>",
        "id": 259556339,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1635528099
    },
    {
        "content": "<p>So, if you work on a feature in a branch and merge master, then quite possibly your code will break.</p>",
        "id": 259556520,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1635528169
    },
    {
        "content": "<p>Ah, so it's really a matter of other branches becoming old/deprecated with time</p>",
        "id": 259556559,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635528189
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span>, did you push all your changes? I can try to bump now.</p>",
        "id": 259560132,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635529810
    },
    {
        "content": "<p>Yeap, <code>more_on_trees</code> is up to date on GitHub too</p>",
        "id": 259560291,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635529883
    },
    {
        "content": "<p>after those fixes on <code>adj_matrix.lean</code> I'm gonna try to merge <code>master</code> into it</p>",
        "id": 259560434,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635529940
    },
    {
        "content": "<p>I'm doing that now.</p>",
        "id": 259560540,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635529993
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 259560576,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635530010
    },
    {
        "content": "<p>If the way the PR to another branch works is that it does a squash merge, won't that make it very difficult to see what Arthur's changes were? Maybe the destination branch should be updated to master, too?</p>",
        "id": 259561081,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635530227
    },
    {
        "content": "<p>Yeah, the best thing would have been to fix those problems while in <code>walks_and_trees</code></p>",
        "id": 259561275,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635530310
    },
    {
        "content": "<p>There's the \"blame\" visualization mode on GitHub. We can use that if we want to see who did what</p>",
        "id": 259561831,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635530438
    },
    {
        "content": "<p>Since it's a squash, I think everything that changes from merging master will be blamed on you, Arthur</p>",
        "id": 259561899,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635530470
    },
    {
        "content": "<p>Oh, you mean on master</p>",
        "id": 259562072,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635530534
    },
    {
        "content": "<p>On master it's gonna be blamed on you because I opened a PR into your branch</p>",
        "id": 259562157,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635530572
    },
    {
        "content": "<p>I mean on <code>walks_and_trees</code>. I like having somewhat nice commit histories on branches so that I can track what's changed while working.</p>",
        "id": 259562209,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635530600
    },
    {
        "content": "<p>If your PR is what updates <code>walks_and_trees</code> to master, then there will be this massive commit that mixes what you did with everything that's happened to mathlib, and it will list you as the author.  (This doesn't matter for the history of <code>master</code>, since it will all be squashed again.)</p>",
        "id": 259562399,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635530686
    },
    {
        "content": "<p>Makes sense. I should have started doing those fixes on <code>walks_and_trees</code></p>",
        "id": 259562501,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635530728
    },
    {
        "content": "<p>I suspect all that needs to be done is to make sure to merge <code>master</code> on <code>walks_and_trees</code>, then merge <code>walks_and_trees</code> into <code>more_on_trees</code>, and then when the PR is merged, things will be OK.</p>",
        "id": 259562531,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635530746
    },
    {
        "content": "<p>I can cherry pick changes from Yael and make small pushes on your branch if he's already started the merging process</p>",
        "id": 259562621,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635530774
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> have you?</p>",
        "id": 259562753,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635530841
    },
    {
        "content": "<p>I don't think you need to do that -- this merging plan should be sufficient, and it shouldn't create any conflicts.</p>",
        "id": 259562759,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635530844
    },
    {
        "content": "<p>I'm doing exactly what Kyle just described.</p>",
        "id": 259562799,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635530868
    },
    {
        "content": "<p>Perfect</p>",
        "id": 259562874,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635530888
    },
    {
        "content": "<p>Next time I do fixes, I'm gonna do on the branch I branched out from and then merge it into mine afterwards</p>",
        "id": 259563428,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635531174
    },
    {
        "content": "<p>Perhaps a surprising thing about git is that every commit is actually a complete snapshot of the entire repository (along with pointers to the commits it's based on).  All the diffs you see in the UI are just computed on the fly from these complete snapshots.  I'm just trying to make sure there's a commit on <code>walks_and_trees</code> that already has a post-merge-<code>master</code> state so that when <code>more_on_trees</code> is merged, the diff that git computes will make more sense.</p>",
        "id": 259564191,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635531589
    },
    {
        "content": "<p>I've fixed <code>connectivity</code> and <code>adj_matrix</code>. Is there any file file you noticed that was broken?</p>",
        "id": 259564515,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635531762
    },
    {
        "content": "<p>All fixed!</p>",
        "id": 259565026,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635532021
    },
    {
        "content": "<p>You really threaded the needle there with all of your comma removal, somehow avoiding a merge conflict. <span aria-label=\"clap\" class=\"emoji emoji-1f44f\" role=\"img\" title=\"clap\">:clap:</span></p>",
        "id": 259565169,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635532087
    },
    {
        "content": "<p>Do you know why <code>adj_matrix_pow_apply_eq_card_walk</code> needs <code>semiring</code> now?</p>",
        "id": 259565363,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635532202
    },
    {
        "content": "<p>Yeah, I was expecting some horrendous thing going on!</p>",
        "id": 259565405,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635532206
    },
    {
        "content": "<p>What did it need before?</p>",
        "id": 259565422,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635532214
    },
    {
        "content": "<p>I suspect that what happened is that a <code>variables [semiring R]</code> got removed.</p>",
        "id": 259565482,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635532247
    },
    {
        "content": "<p>Oh right, <code>adj_matrix</code> was generalized to <code>def adj_matrix [has_zero α] [has_one α]</code></p>",
        "id": 259565501,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635532261
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> for getting this to happen</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_tree.card_edges_eq_card_vertices_sub_one</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G.edge_set</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">card</span> <span class=\"n\">G.edge_set</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 259566333,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635532681
    },
    {
        "content": "<p>I kicked it off, but you were the one actually paving the way :D</p>",
        "id": 259567210,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635533075
    },
    {
        "content": "<p>Thanks a lot Yaël for the merges!</p>",
        "id": 259567305,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635533123
    },
    {
        "content": "<p>Hopefully eventually we'll have the matrix-tree theorem, too, which at its core relates any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>×</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n-1)\\times(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> minor of the Laplacian matrix to the set of all tree-like functions <code>f : {v | v ≠ root} → G.edge_set</code>.</p>",
        "id": 259567428,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635533177
    },
    {
        "content": "<p>This sounds like it should say</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_tree.card_edges</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.edge_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 259568160,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635533556
    },
    {
        "content": "<p><code>[fintype G.edge_set]</code> should come from <code>[fintype V]</code> and <code>[nonempty V]</code> is useless.</p>",
        "id": 259568206,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635533590
    },
    {
        "content": "<p>I sort of want to abolish <code>G.edge_finset</code> since it's just <code>G.edge_set.to_finset</code>.</p>\n<p>The reason <code>[fintype G.edge_set]</code> is there is because, while it is derived from <code>[fintype V]</code>, it's better to have it take an arbitrary proof of finiteness rather than requiring it to take the one derived from <code>[fintype V]</code>.</p>",
        "id": 259568474,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635533750
    },
    {
        "content": "<p>Ah yeah because it shows up in the statement.</p>",
        "id": 259568543,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635533778
    },
    {
        "content": "<p>It's true that <code>nonempty V</code> is not necessary because of truncating subtraction.</p>",
        "id": 259568562,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635533795
    },
    {
        "content": "<p>I strongly disagree to removing <code>edge_finset</code>. It's very useful but I think it could be redefined.</p>",
        "id": 259568569,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635533797
    },
    {
        "content": "<p>It's actually just a matter of changing<code>.to_finset</code> with <code>univ.filter</code> becaus you assume a fintype anyway.</p>",
        "id": 259568775,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635533903
    },
    {
        "content": "<p><code>edge_finset</code> definitely should be redefined -- right now it requires <code>[fintype V]</code> which is very restrictive.  The definition is using the instance that says <code>[fintype G.edge_set]</code> from <code>[fintype V]</code>.</p>",
        "id": 259568845,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635533949
    },
    {
        "content": "<p>This line requires <code>[nonempty V]</code>, doesn't it?<br>\n<code>have root := classical.arbitrary V,</code></p>",
        "id": 259569170,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635534117
    },
    {
        "content": "<p>In SRL, we talk a lot about <code>edge_finset</code> (even if to be fair it's hidden under one definition so never actually see it).</p>",
        "id": 259569173,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635534120
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/259569170\">said</a>:</p>\n<blockquote>\n<p>This line requires <code>[nonempty V]</code>, doesn't it?<br>\n<code>have root := classical.arbitrary V,</code></p>\n</blockquote>\n<p>My point is that the final statement doesn't require it. so you can case-split on <code>is_empty V</code>/<code>nonempty V</code>, prove the trivial stuff in the first case, and go on with your existing proof in the second case.</p>",
        "id": 259569313,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635534178
    },
    {
        "content": "<p>And for SRGs, Alena definitely needed <code>edge_finset</code>.</p>",
        "id": 259569364,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635534199
    },
    {
        "content": "<p>I think the reason <code>edge_finset</code> exists is that we didn't realize we could write <code>G.edge_set.to_finset</code>, judging by its definition.  It also makes summations over the edge set look nicer, but it's mostly cosmetic.</p>",
        "id": 259569425,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635534240
    },
    {
        "content": "<p>Maybe we can change the assumptions to <code>[fintype (G.neighbors_set u)] [fintype (G.neighbors_set v)]</code>?</p>",
        "id": 259569539,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635534288
    },
    {
        "content": "<p>Here's a question: is the empty graph a tree? Right now the definition allows empty graphs to be trees, but that doesn't seem right.</p>",
        "id": 259569643,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635534357
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> A good exercise would be to remove the <code>[nonempty V]</code> assumption, if you want to do that.</p>",
        "id": 259569709,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635534381
    },
    {
        "content": "<p>Sure I'm gonna try it</p>",
        "id": 259569834,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635534464
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_empty_or_nonempty\">docs#is_empty_or_nonempty</a></p>",
        "id": 259570019,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635534560
    },
    {
        "content": "<p>Is there thing akin to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.nontriviality\">docs#tactic.nontriviality</a> which would automatically perform the cache update and the goal discharge?</p>",
        "id": 259570200,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635534641
    },
    {
        "content": "<p>You'll also have to figure out how to show the cardinality of the edge set is 0 if <code>V</code> is empty.  Maybe write that as a separate lemma, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">simple_graph.edge_set_empty_of_empty</span> <span class=\"o\">[</span><span class=\"n\">is_empty</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">G.edge_set.nonempty</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 259570202,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635534642
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/259570200\">said</a>:</p>\n<blockquote>\n<p>Is there thing akin to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.nontriviality\">docs#tactic.nontriviality</a> which would automatically perform the cache update and the goal discharge?</p>\n</blockquote>\n<p>Do you mean this one? <a href=\"https://leanprover-community.github.io/mathlib_docs/logic/nontrivial.html#tactic.interactive.nontriviality\">https://leanprover-community.github.io/mathlib_docs/logic/nontrivial.html#tactic.interactive.nontriviality</a></p>",
        "id": 259570680,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635534894
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  I think <code>casesI</code> would work?</p>",
        "id": 259570684,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635534894
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> do you agree with this name change?</p>\n<blockquote>\n<p>This sounds like it should say</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_tree.card_edges</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.edge_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 259571191,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635535154
    },
    {
        "content": "<p>To me it sounds more like the name of a function that would return the cardinality of the set of edges of a tree <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> <br>\nBut of course, my experience in this subject is super short</p>",
        "id": 259571381,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635535246
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/259569643\">said</a>:</p>\n<blockquote>\n<p>Here's a question: is the empty graph a tree? Right now the definition allows empty graphs to be trees, but that doesn't seem right.</p>\n</blockquote>\n<p>Of course this is debatable, but typically <a href=\"https://ncatlab.org/nlab/show/empty+space\">empty sets are not connected</a>. For the graph case, this means the empty graph is not a tree (but it is a forest with zero trees, of course).</p>",
        "id": 259571543,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1635535326
    },
    {
        "content": "<p>Within my (shallow) understanding, making use of a subtraction that truncates at zero to prove such lemma for empty trees sounds a bit hacky. Because, semantically, the right side of the equality (<code>n - 1</code>) doesn't make sense to me</p>",
        "id": 259572128,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635535644
    },
    {
        "content": "<p>Unless, of course, we have a reason (besides pure generality) to make it true for empty trees as well</p>",
        "id": 259573196,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635536180
    },
    {
        "content": "<p><code>is_tree.card_edge_finset</code> would be a better name than <code>is_tree.card_edges</code>.  I agree removing the <code>nonempty V</code> assumption is hacky, but if it's only a few extra lines in the proof it's nice when you can eliminate assumptions.</p>",
        "id": 259573858,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635536544
    },
    {
        "content": "<p>It also might not be a hack if <code>G.is_tree</code> comes with the fact that <code>V</code> is nonempty, for instance by modifying <code>G.is_connected</code> to include this hypothesis.</p>",
        "id": 259573970,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635536613
    },
    {
        "content": "<p>Okay that makes sense to me. I'm gonna try and see if I can do it</p>",
        "id": 259574608,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635536965
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  It took longer than I expected, but I got it to work!<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/10053\">https://github.com/leanprover-community/mathlib/pull/10053</a></p>",
        "id": 259710140,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635568571
    },
    {
        "content": "<p>Also <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span></p>",
        "id": 259710419,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635569047
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>, after your proposed changes this was the only proof I couldn't adjust:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_tree_iff</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span> <span class=\"bp\">↔</span> <span class=\"n\">nonempty</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"bp\">∃!</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">p.is_path</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">is_tree</span><span class=\"o\">,</span> <span class=\"n\">is_acyclic_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">hne</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"n\">hne</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some.to_path</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">path.path_is_path</span><span class=\"o\">],</span>\n    <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">hu</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">hu</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">hne</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hne</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n      <span class=\"n\">use</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"n\">unique_of_exists_unique</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"n\">hp</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 259725394,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635592875
    },
    {
        "content": "<p>It's failing to apply the very first <code>simp</code></p>",
        "id": 259725450,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635592927
    },
    {
        "content": "<p>the issue is that is_tree is now a structure, so it's not definitionally equal to the ands from before</p>",
        "id": 259726267,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1635594176
    },
    {
        "content": "<p>here's a working version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_tree_iff</span> <span class=\"o\">:</span> <span class=\"n\">G.is_tree</span> <span class=\"bp\">↔</span> <span class=\"n\">nonempty</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"bp\">∃!</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">p.is_path</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">hne</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">is_acyclic_iff</span> <span class=\"n\">at</span> <span class=\"n\">hu</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">hne</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some.to_path</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">path.path_is_path</span><span class=\"o\">],</span>\n    <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">hu</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">hu</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">hne</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hne</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n      <span class=\"n\">use</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">is_acyclic_iff</span><span class=\"o\">,</span>\n      <span class=\"n\">rintros</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"n\">unique_of_exists_unique</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"n\">hp</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>note that I changed the <code>use/intros</code> into a <code>refine</code>, which is a very nice tactic. it's also strictly stronger than <code>split</code>! (although annoyingly, it gets confused when you try to do a <code>rintro</code> in it... so for example <code>refine ⟨λ ⟨hc, hu, hne⟩, _, λ ⟨hne, h⟩, _⟩</code> doesn't work, but if it did it'd be the sameas the <code>split</code> and the two <code>rintro</code>s you do after</p>",
        "id": 259726425,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1635594431
    },
    {
        "content": "<p>Thank you very much!</p>",
        "id": 259726581,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635594655
    },
    {
        "content": "<p>Another thing... <a href=\"https://github.com/leanprover-community/mathlib/runs/4053485713?check_suite_focus=true\">The lint tests are failing</a>. I tried to fix those but I couldn't figure it out.</p>",
        "id": 259726657,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635594753
    },
    {
        "content": "<p>don't worry about them, they're not in your part of the code</p>",
        "id": 259727306,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1635595584
    },
    {
        "content": "<p>also, I know you've put in all this work on this, but it may be worth keeping the \"weaker\" empty option available (as mathematically boring as it is); I think this is common in mathlib, with things like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_preconnected\">docs#is_preconnected</a> (so maybe <code>is_pretree</code>?) because a lot of results end up holding for the weaker class anyways</p>",
        "id": 259727347,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1635595662
    },
    {
        "content": "<p>Hm, I'd rather leave it for later decisions since we're not sure whether we need that generalization starting from a definition of \"preconnectedness\" in the context of graphs</p>",
        "id": 259741467,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635614052
    },
    {
        "content": "<p>I'd say time will tell. Let's see how the need evolves</p>",
        "id": 259741806,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635614601
    },
    {
        "content": "<p>Plus I'm not so sure how I'd go about that generalization with the definition of \"pretrees\". I gave it a little go and I ended up having to redefine a lot of things in terms of \"pretree\", like <code>pretree_path</code> and <code>pretree_dist</code>, which seemed very odd to me <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 259742273,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635615252
    },
    {
        "content": "<p>What if we just allow empty trees and add the nonempty restrictions on lemmas that require such? In other words, simply ignore my most recent PR?</p>",
        "id": 259798153,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635700508
    },
    {
        "content": "<p>I think the idea of letting \"pre-trees\" be forests such that there's a path between any two vertices is fine, and then just define a tree to be a nonempty pretree.</p>",
        "id": 259812783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635720783
    },
    {
        "content": "<p>there are a bunch of standard theorems about primes which are true for preprimes (i.e. primes and 1), e.g. p divides ab implies p divides a or p divides b</p>",
        "id": 259812798,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635720824
    },
    {
        "content": "<p>Right now, a forest is just an acyclic graph (and it has no definition of its own since <code>G.is_acyclic</code> exists), and a tree is a connected acyclic graph.  The definition of <code>G.is_connected</code> is that there's a walk between every pair of vertices.  If anything, it should be <code>G.is_connected</code> that should require that there be at least one vertex.</p>\n<p>The way this probably should work is the definition of connected be changed to \"there exists a vertex v such that for every vertex w there is a walk from v to w.\"</p>",
        "id": 259813330,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635721490
    },
    {
        "content": "<p>This is the same as saying that the quotient of <code>V</code> by the <code>G.walk</code> relation is a singleton.</p>",
        "id": 259813365,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635721552
    },
    {
        "content": "<p>But then how would we structure it? Have the definition of trees that requires connectivity and define a forest as an union of trees?</p>",
        "id": 259813992,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635722513
    },
    {
        "content": "<p>I'm suggesting that the definition of connectivity be changed, and leave <code>is_tree</code> alone.  A forest is just an acyclic graph, so there's nothing to change there.</p>",
        "id": 259814078,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635722618
    },
    {
        "content": "<p>Unfortunately, this makes the different theorems for what <code>G.is_tree</code> is equivalent to to be more awkward, but maybe they don't have to be equivalences.</p>",
        "id": 259814147,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635722707
    },
    {
        "content": "<p>Today I merged master into <code>walks_and_trees</code> again and solved some lint errors</p>",
        "id": 259814217,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635722837
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Is this what you mean?<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/10082\">https://github.com/leanprover-community/mathlib/pull/10082</a></p>",
        "id": 259819290,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635730784
    },
    {
        "content": "<p>Line 1244 is not working and I don't know how to proceed there. Probably related to what you've said about dropping the equivalence</p>",
        "id": 259819355,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635730918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/259813330\">said</a>:</p>\n<blockquote>\n<p>The way this probably should work is the definition of connected be changed to \"there exists a vertex v such that for every vertex w there is a walk from v to w.\"</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">connected</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G.reachable</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n</code></pre></div>",
        "id": 259819397,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635730960
    },
    {
        "content": "<p>and then something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">connected_iff_nonempty_and_pairwise_reachable</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.connected</span> <span class=\"bp\">↔</span> <span class=\"n\">nonempty</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G.reachable</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 259819467,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635731105
    },
    {
        "content": "<p>I haven't given much thought to the effects of this, though.  The <code>nonempty V ∧ ∀ (u v : V), G.reachable u v</code> definition is potentially nicer (note that in the definition you gave, <code>nonempty V</code> is inside the forall).</p>",
        "id": 259819672,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635731444
    },
    {
        "content": "<p>Oops, I better remove it from the forall.</p>",
        "id": 259820782,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635733001
    },
    {
        "content": "<p>The definition I gave is more \"symmetrical\", I think</p>",
        "id": 259821449,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635734194
    },
    {
        "content": "<p>And it changes less things</p>",
        "id": 259821452,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635734206
    },
    {
        "content": "<p>Okay, I got some progress there</p>",
        "id": 259822168,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635735585
    },
    {
        "content": "<p>I think we already have at least 2 or 3 pairs of definitions <code>is_preconnected</code> and <code>is_connected</code> in mathlib, where <code>is_connected</code> is just <code>is_preconnected + nonempty</code>. You should do that too!</p>",
        "id": 259828364,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1635744345
    },
    {
        "content": "<p>Got the definition of <code>preconnected</code> in <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> <br>\n<span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I wasn't able to prove <code>connected_of_edge_connected</code> but everything else is working. Feel free to take over branch <code>change-connectivity-def</code> before accepting <a href=\"https://github.com/leanprover-community/mathlib/pull/10082\">this PR</a> (which merges <code>change-connectivity-def</code> into yours)</p>",
        "id": 259855551,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635768333
    },
    {
        "content": "<p>And I'm closing <a href=\"https://github.com/leanprover-community/mathlib/pull/10053\">this PR</a> since we're going for the change of definition of <code>connected</code> instead</p>",
        "id": 259856971,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635769366
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I've updated <a href=\"https://github.com/leanprover-community/mathlib/pull/10082\">https://github.com/leanprover-community/mathlib/pull/10082</a> with your ideas but I couldn't make <code>connected_of_edge_connected</code> work</p>",
        "id": 259908071,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635794442
    },
    {
        "content": "<p>(the proof is written in a way that I can't understand at the moment)</p>",
        "id": 259908111,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635794471
    },
    {
        "content": "<p>Do you remember what the definition of <code>connected</code> used to be before?</p>",
        "id": 259908314,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635794572
    },
    {
        "content": "<p>Yeah</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">connected</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G.reachable</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n</code></pre></div>",
        "id": 259908398,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635794626
    },
    {
        "content": "<p>It was an <code>and</code>. So I used <code>and.imp_right</code>, since <code>connected</code> was <code>preconnected AND nontrivial V</code> and <code>edge_connected _ _ _ _</code> was <code>connected _</code> , which was <code>_ AND nontrivial V</code>. So the right hand side of the assumption implies the right hand side of the goal. That's the <code>and.imp_right</code> shortcut.</p>",
        "id": 259908493,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635794663
    },
    {
        "content": "<p>Not exactly, that's what <code>preconnected</code> is.</p>",
        "id": 259908504,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635794675
    },
    {
        "content": "<p>Now that <code>connected</code> is a structure, and not a plain <code>and</code> conjunction, you can't use <code>and.elim_right</code> anymore.</p>",
        "id": 259908533,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635794704
    },
    {
        "content": "<p>With the new definition, here's a place to start:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">connected_of_edge_connected</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_connected</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.connected</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">preconnected</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">nonempty</span> <span class=\"o\">:=</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 259908986,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635794958
    },
    {
        "content": "<p>I see, but I think it's the writing style (I've very new to Lean). So far I've only been able to understand steps explicitly separated by commas</p>",
        "id": 259908987,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635794958
    },
    {
        "content": "<p>I think the <code>and.imp_right</code> proof might be more obfuscated than just terse, so don't feel bad about not being able to follow it.</p>",
        "id": 259909477,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635795225
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">preconnected</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">reachable</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>leaves me at </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span>\n<span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">hk</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">G.edge_connected</span> <span class=\"n\">k</span>\n<span class=\"n\">uv</span><span class=\"o\">:</span> <span class=\"n\">V</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span>\n<span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">hk</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">G.edge_connected</span> <span class=\"n\">k</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">nonempty</span> <span class=\"n\">V</span>\n</code></pre></div>",
        "id": 259909778,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635795381
    },
    {
        "content": "<p>I'm having a hard time modifying the one-liner, but here's away to modify the original one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">preconnected_of_edge_connected</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_connected</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.preconnected</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">∅</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hk</span><span class=\"o\">]))</span><span class=\"bp\">.</span><span class=\"n\">preconnected</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset.coe_empty</span><span class=\"o\">,</span> <span class=\"n\">subgraph.delete_edges_of_empty</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">h'.map</span> <span class=\"o\">(</span><span class=\"n\">subgraph.map_spanning_top</span> <span class=\"n\">_</span><span class=\"o\">)⟩,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Have another lemma <code>nonempty_of_edge_connected</code>, then put them together for <code>connected_of_edge_connected</code>.</p>",
        "id": 259909851,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635795427
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">connected_of_edge_connected</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_connected</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.connected</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">C'</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"bp\">∅</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hk</span><span class=\"o\">])</span> <span class=\"k\">in</span>\n<span class=\"o\">{</span> <span class=\"n\">preconnected</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">C'.preconnected</span><span class=\"o\">,</span>\n  <span class=\"n\">nonempty</span> <span class=\"o\">:=</span> <span class=\"n\">C'.nonempty</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 259909907,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635795464
    },
    {
        "content": "<p>If you want to reuse the old proof. Really, there should be a <code>connected.antimono</code> or however you name it, saying that if a \"supergraph\" is connected, so is an induced subgraph.</p>",
        "id": 259910052,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635795529
    },
    {
        "content": "<p>The original proof was pretty terse too =), I just followed the style</p>",
        "id": 259910223,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635795605
    },
    {
        "content": "<p>Alright, PR updated. I'm gonna spend a few hours tomorrow figuring out what you guys wrote. But feel free to merge it into <code>walks_and_trees</code> if you see fit <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> <br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/10082\">https://github.com/leanprover-community/mathlib/pull/10082</a></p>\n<p>Or, of course, just push commits directly to <code>change-connectivity-def</code></p>",
        "id": 259910340,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635795664
    },
    {
        "content": "<p>Right now I'm having issues extracting the <code>reachable</code> Prop out of the quot. I'm clumsy with that API. If I have the following state, what's the right <code>quot</code> API?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span>\n<span class=\"n\">_inst_1</span><span class=\"o\">:</span> <span class=\"n\">unique</span> <span class=\"n\">G.connected_component</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">V</span>\n<span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">V</span>\n<span class=\"n\">w</span><span class=\"o\">:</span> <span class=\"n\">V</span>\n<span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"n\">G.connected_component_of</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">G.connected_component_of</span> <span class=\"n\">w</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">G.reachable</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n</code></pre></div>",
        "id": 259910404,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635795695
    },
    {
        "content": "<p>(<code>preconnected_of_edge_connected</code> is now unnecessary given Yakov's <code>connected_of_edge_connected</code>)</p>",
        "id": 259910561,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635795773
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> I'm not sure if you can apply it directly, but <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient.eq\">docs#quotient.eq</a> should be a way to do something with <code>this</code> given <code>reachable_is_equivalence</code>/<code>reachable_setoid</code></p>",
        "id": 259911023,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635796035
    },
    {
        "content": "<p>Ah, something with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quot.exact\">docs#quot.exact</a> maybe?</p>",
        "id": 259911263,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635796176
    },
    {
        "content": "<p>The nice thing about the <code>quotient</code> ones (like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient.exact\">docs#quotient.exact</a>) is that they give it in terms of the original relation, rather than <code>eqv_gen</code>.  Maybe this is a hole in the <code>quot</code> api? having variants for when you can supply an explicit <code>setoid</code>?</p>",
        "id": 259911476,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635796273
    },
    {
        "content": "<p>Right, but even <code>quotient.*</code> ask for the setoid to be an implicit arg</p>",
        "id": 259911615,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635796329
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">unique</span> <span class=\"n\">G.connected_component</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"n\">G.connected_component_of</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">G.connected_component_of</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.reachable</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">quotient.exact</span> <span class=\"n\">_</span> <span class=\"n\">G.reachable_setoid</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 259911720,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635796374
    },
    {
        "content": "<p><code>quotient</code> seems to be designed around having a canonical setoid instance for a given type, but there are times when you want potentially many.</p>",
        "id": 259911817,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635796419
    },
    {
        "content": "<p>It would be nice if there were a <code>quot.exact'</code> or something that explicitly took this <code>setoid</code> instance, and then <code>quotient.exact</code> could be defined in terms of it.</p>",
        "id": 259912012,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635796498
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">equivalence.eqv_gen_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">equivalence</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">eqv_gen</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">eqv_gen.rel</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">assumption</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h.left</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h.right.left</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h.right.right</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">connected_component_of.reachable_congr</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.connected_component_of</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">G.connected_component_of</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.reachable</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">reachable_is_equivalence</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">quot.exact</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 259912171,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635796576
    },
    {
        "content": "<p><code>setoid</code> might not be right since it bundles the relation -- rather, if <code>quot.exact'</code> took an <code>equivalence</code> proof.</p>",
        "id": 259912202,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635796599
    },
    {
        "content": "<p>Which gives the following too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[reducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">quot.is_empty</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_empty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_empty</span> <span class=\"o\">(</span><span class=\"n\">quot</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">quot.induction_on</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">is_empty_elim</span> <span class=\"n\">a'</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">connected_component.is_empty_of_is_empty</span> <span class=\"o\">[</span><span class=\"n\">is_empty</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_empty</span> <span class=\"n\">G.connected_component</span> <span class=\"o\">:=</span>\n<span class=\"n\">quot.is_empty</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">connected_of_unique</span> <span class=\"o\">[</span><span class=\"n\">unique</span> <span class=\"n\">G.connected_component</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">G.connected</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">casesI</span> <span class=\"n\">is_empty_or_nonempty</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">is_empty_elim</span> <span class=\"o\">(</span><span class=\"n\">default</span> <span class=\"n\">G.connected_component</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">connected_component_of.reachable_congr</span> <span class=\"o\">(</span><span class=\"n\">subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›⟩</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 259912429,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635796702
    },
    {
        "content": "<p>If <code>eqv_gen</code> is really the best interface to <code>quot</code> given an equivalence relation, I'd suggest</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">_root_.eqv_gen.of_eqv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">equivalence</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">eqv_gen</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n <span class=\"n\">induction</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n <span class=\"o\">{</span> <span class=\"n\">assumption</span> <span class=\"o\">},</span>\n <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h.left</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h.right.left</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">},</span>\n <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h.right.right</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">connected_component_of.reachable_congr</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.connected_component_of</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">G.connected_component_of</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.reachable</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">quot.exact</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">of_eqv</span> <span class=\"n\">G.reachable_is_equivalence</span>\n</code></pre></div>\n<p>If namespaces worked out, it would also be nice with flipped arguments, so that the proof is <code>G.reachable_is_equivalence.of_eqv_gen (quot.exact _ h)</code></p>",
        "id": 259913156,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635796993
    },
    {
        "content": "<p><code>eqv_gen_iff</code> would be nice to have, too</p>",
        "id": 259913379,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635797085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/259909778\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">preconnected</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">reachable</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>leaves me at </p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span>\n<span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">hk</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">G.edge_connected</span> <span class=\"n\">k</span>\n<span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">V</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span>\n<span class=\"n\">k</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">hk</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">G.edge_connected</span> <span class=\"n\">k</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">nonempty</span> <span class=\"n\">V</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> maybe you don't need this now, but here's how to do that <code>nonempty</code> goal from earlier: if you look at the definition of <code>nonempty</code> then you can see that the constructor is called <code>nonempty.intro</code>, so <code>exact nonempty.intro u</code> should do it.</p>",
        "id": 259926709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1635803746
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> makes sense, thanks!</p>",
        "id": 260003810,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635863818
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> do you think the PR needs more adjustments before merging?</p>",
        "id": 260003897,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635863863
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The list of edges in a walk are all edges of the graph.</span>\n<span class=\"sd\">It is written in this form to avoid unsightly coercions. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">edges_subset_edge_set</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">p.edges</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edge_set</span>\n</code></pre></div>\n<p>Hm, this isn't really what we mean, is it? Wouldn't it be more like \"Every edge in a walk is an edge of the graph\"?</p>",
        "id": 260077726,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635900585
    },
    {
        "content": "<p>Are you talking about the comment? Less weird is \"Every edge in a walk's edge list is an edge of the graph.\" The point of this comment is to remind the reader why it's not <code>p.edges ⊆ G.edge_set</code>, and that's because <code>p.edges : list (sym2 V)</code> rather than <code>set (sym2 V)</code>.</p>",
        "id": 260078198,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635900991
    },
    {
        "content": "<p>Yeah, about the comment</p>",
        "id": 260078240,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1635901041
    },
    {
        "content": "<p>(Please feel free to clarify that comment in the source. You can delete it and start over.)</p>",
        "id": 260078430,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635901210
    },
    {
        "content": "<p>Hi! I'm trying to prove the lemma that says that the existence of a perfect matching implies that the cardinality of the vertices set is even. I've come to this point:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span>\n<span class=\"n\">_inst_1</span><span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">V</span>\n<span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">G.matching</span>\n<span class=\"n\">_inst_2</span><span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">M.edges</span><span class=\"o\">)</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">M.edges</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">e</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">card</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">card</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">M.edges</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 260329772,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636057699
    },
    {
        "content": "<p>I'd advise you to go by double counting the finset <code>(univ : V × sym2 V).filter (λ ve, ve.1 ∈ ve.2)</code></p>",
        "id": 260330185,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636057890
    },
    {
        "content": "<p>Can you define an equiv <code>V ≃ Σ e : M.edges, {v : V // v ∈ e}</code>?</p>",
        "id": 260330304,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636057937
    },
    {
        "content": "<p>Yeah, that's another way. Not sure it goes smoothly, though.</p>",
        "id": 260330431,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636057992
    },
    {
        "content": "<p>I thought about double counting too because a vertex is in exactly one edge and an edge has exactly two vertices ( verytypical informal proof)</p>",
        "id": 260330877,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636058203
    },
    {
        "content": "<p>I suggest <code>choose e he1 he2 using h</code> as next tactic step.</p>",
        "id": 260331231,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636058379
    },
    {
        "content": "<p>This should follow from the degree-sum formula, right? Perfect matchings are certain kinds of subgraphs (this coercion is not implemented) and then you apply <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.sum_degrees_eq_twice_card_edges\">docs#simple_graph.sum_degrees_eq_twice_card_edges</a> and use the fact that all the degrees are 1 for this subgraph.</p>",
        "id": 260331706,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636058617
    },
    {
        "content": "<p>If you want to do it yourself, I'd suggest using the map <code>V -&gt; sym2 V</code> for the perfect matching that gets the edge associated to a vertex, show the image is <code>M.edges</code>, and show the map is 2-1 onto each element of <code>M.edges</code>.</p>",
        "id": 260332050,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636058753
    },
    {
        "content": "<p>(Somewhere I shared a link to a branch that contains more things about perfect matchings, when <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> asked very recently. I think it has this <code>V -&gt; sym2 V</code> map.)</p>",
        "id": 260332249,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636058834
    },
    {
        "content": "<p>Matchings were added to mathlib before subgraphs were.  It might be reasonable to redesign them as a graph <code>M : simple_graph V</code> satisfying <code>M \\leq G</code> such that whenever <code>M.adj v w</code> and <code>M.adj v w'</code> then <code>w = w'</code>.  We could define <code>simple_graph.support</code> of a graph to be <code>{v : V | \\exists w, G.adj v w}</code>, and then a perfect matching is an <code>M</code> such that <code>M.support = set.univ</code>.</p>",
        "id": 260332991,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636059188
    },
    {
        "content": "<p>Do you think we even want a standalone definition if we have k-factors?</p>",
        "id": 260333101,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636059242
    },
    {
        "content": "<p>If there are k-factors, then it would be good to have an interface for 1-factors something like this</p>",
        "id": 260333305,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636059338
    },
    {
        "content": "<p>though it would instead actually be terms of <code>G.subgraph</code> instead of terms of <code>simple_graph V</code> that are subgraphs.</p>",
        "id": 260333432,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636059391
    },
    {
        "content": "<p>Maybe make sure k-factors work for non-locally-finite graphs; the definition of matchings I gave doesn't depend on that assumption.</p>",
        "id": 260333668,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636059498
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> if you want a relatively small thing to try PRing to mathlib itself, it could be defining the support of a <code>simple_graph</code>, which I don't think exists already.  Maybe its definition could be <code>def simple_graph.support (G : simple_graph V) : set V := rel.image G.adj set.univ</code>, and then you'd have a simp lemma <code>simple_graph.mem_support</code> that says a vertex <code>v</code> is an element of <code>G.support</code> iff there exists a vertex <code>w</code> with <code>G.adj v w</code>.  One other useful lemma (a corollary) would be that if <code>G.adj v w</code> for <code>(v w : V)</code> then <code>v</code> is an element of <code>G.support</code>.</p>",
        "id": 260335259,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636060250
    },
    {
        "content": "<p>Yeah, all of a sudden this matching lemma became a redesigning task which I'm not sure I can handle without bugging too many people <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 260335699,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636060476
    },
    {
        "content": "<p>At least not yet</p>",
        "id": 260335883,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636060567
    },
    {
        "content": "<p>What is left? That goal state that you posted above?</p>",
        "id": 260335893,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636060575
    },
    {
        "content": "<p>That shouldn't require any redesigning.</p>",
        "id": 260335916,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636060585
    },
    {
        "content": "<p>With that <code>choose</code> line that I posted, it should be quite straightforward to build the equiv.</p>",
        "id": 260336153,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636060648
    },
    {
        "content": "<p>And then you can use <code>fintype.card_congr</code> and <code>fintype.card_sigma</code>. By then you should be in pretty good shape.</p>",
        "id": 260336258,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636060693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/260335699\">said</a>:</p>\n<blockquote>\n<p>Yeah, all of a sudden this matching lemma became a redesigning task which I'm not sure I can handle without bugging too many people <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n</blockquote>\n<p>Don't worry! I happen to need k-factors myself.</p>",
        "id": 260337620,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636061425
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I was able to prove the lemma with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_support</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">G.support</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">support</span><span class=\"o\">,</span> <span class=\"n\">rel.image</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">choose</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">adj_comm</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">choose</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">adj_comm</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>But I notice some repeated structure for each split. Is it possible to optimize this proof?</p>",
        "id": 260347072,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636067365
    },
    {
        "content": "<p>better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_support</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">G.support</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">support</span><span class=\"o\">,</span> <span class=\"n\">rel.image</span><span class=\"o\">,</span> <span class=\"n\">adj_comm</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">choose</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">choose</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260347535,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636067661
    },
    {
        "content": "<p>I think you might be able to do it in one line with <code>rw [support, rel.mem_image, adj_comm]</code></p>",
        "id": 260347547,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636067670
    },
    {
        "content": "<p>(maybe <code>simp only</code> instead of <code>rw</code>)</p>",
        "id": 260347560,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636067689
    },
    {
        "content": "<p>Oh, you'll need <code>set.mem_univ</code> and maybe a couple others.</p>",
        "id": 260347656,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636067735
    },
    {
        "content": "<p>Is it slower to add many arguments to <code>simp only</code>?<br>\nAnother question, what's the difference between <code>simp [a, b, ...]</code> and <code>simp only [a, b, c, ...]</code>?</p>",
        "id": 260347850,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636067849
    },
    {
        "content": "<p>Without <code>only</code>, it additionally uses all lemmas marked with the <code>@[simp]</code> attribute. <a href=\"https://leanprover-community.github.io/extras/simp.html\">https://leanprover-community.github.io/extras/simp.html</a></p>",
        "id": 260347994,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636067940
    },
    {
        "content": "<p>About the redesign you mentioned, isn't it a bit strange to define a matching as a subgraph? I mean, it's a subgraph that always contain all the vertices of the full graph</p>",
        "id": 260348209,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636068111
    },
    {
        "content": "<p>I <em>think</em> it's more common in the literature to understand a matching as a subset of edges</p>",
        "id": 260348326,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636068213
    },
    {
        "content": "<p>This theorem, by the way, is strangely resisting <code>squeeze_simp</code> and <code>simp?</code></p>",
        "id": 260348418,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636068287
    },
    {
        "content": "<p>What do you mean?</p>",
        "id": 260348550,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636068397
    },
    {
        "content": "<p>And regarding formalization vs literature: combinatorics is a very intuitive subject, so things tend to be very informal because the gaps can be filled in easily.  But a computer needs everything to be represented very precisely.  It seems like many of the ways we might use matchings are very subgraph-like, so we may as well just represent them as subgraphs, without needing to create coercions back and forth between different representations.</p>\n<p>Yael seems to be on it to define what k-factors are, and he was thinking of defining them as being subgraphs.</p>",
        "id": 260348616,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636068482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/260348550\">said</a>:</p>\n<blockquote>\n<p>What do you mean?</p>\n</blockquote>\n<p>Ok:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_support</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">G.support</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">support</span><span class=\"o\">,</span> <span class=\"n\">rel.mem_image</span><span class=\"o\">,</span> <span class=\"n\">adj_comm</span><span class=\"o\">,</span> <span class=\"n\">set.mem_univ</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Replacing <code>simp</code> with <code>squeeze_simp</code> suggests this <code>simp only</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_support</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">G.support</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">support</span><span class=\"o\">,</span> <span class=\"n\">rel.mem_image</span><span class=\"o\">,</span> <span class=\"n\">adj_comm</span><span class=\"o\">,</span> <span class=\"n\">set.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">set.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">iff_self</span><span class=\"o\">,</span> <span class=\"n\">exists_true_left</span><span class=\"o\">],</span>\n  <span class=\"c1\">-- goal not closed</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260348716,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636068567
    },
    {
        "content": "<p>Yeah as soon as I said it, I realized that spanning trees also have this characteristic of containing all vertices of the bigger graph and we might as well define them as subgraphs</p>",
        "id": 260348729,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636068584
    },
    {
        "content": "<p>Wow that's indeed a 1-liner</p>",
        "id": 260348837,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636068665
    },
    {
        "content": "<p>There's a complexity already with simple graphs that there are two notions of a subgraph: <code>G.subgraph</code> for arbitrary ones and <code>simple_graph V</code> for spanning ones (where we take only those that are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\leq</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span>).</p>",
        "id": 260348865,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636068686
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_support</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">G.support</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">support</span><span class=\"o\">,</span> <span class=\"n\">rel.image</span><span class=\"o\">,</span> <span class=\"n\">adj_comm</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>closed the goal here</p>",
        "id": 260348994,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636068772
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph.spanning_coe\">docs#simple_graph.subgraph.spanning_coe</a> is an attempt to connect up with this latter notion, and I expect to use <code>G.support</code> at some point for restricting a graph to a <code>G.subgraph</code> by removing degree-0 vertices.</p>",
        "id": 260349107,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636068857
    },
    {
        "content": "<p>This would be a little better:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_support</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">G.support</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">support</span><span class=\"o\">,</span> <span class=\"n\">rel.mem_image</span><span class=\"o\">,</span> <span class=\"n\">adj_comm</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>It's better to use the \"API\" for definitions rather than unfolding them.  The point of <code>mem_support</code> is to define the API for <code>G.support</code> so future users don't have to unfold it.</p>",
        "id": 260349250,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636068970
    },
    {
        "content": "<p>Actually, I'm not sure this should be a <code>@[simp]</code> lemma. It doesn't hurt, but it's unclear to me right now whether it will help simplify things. I guess leave it unless anyone has a reason it shouldn't be one.</p>",
        "id": 260349318,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636069047
    },
    {
        "content": "<p>I can add it without <code>@[simp]</code> and then you can make it so if you see fit later</p>",
        "id": 260349398,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636069107
    },
    {
        "content": "<p>You might have a <code>support_mono</code> lemma that says <code>G &lt;= G' -&gt; G.support &lt;= G'.support</code>, right?</p>",
        "id": 260349445,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1636069161
    },
    {
        "content": "<p>lemme try to get that in</p>",
        "id": 260349563,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636069260
    },
    {
        "content": "<p>Something something forgetful functor to Set</p>",
        "id": 260349699,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1636069361
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">G</span> <span class=\"bp\">≤</span> <span class=\"n\">G'</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">G'</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">simple_graph</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n</code></pre></div>\n<p><code>G'</code> wasn't defined as a subgraph of <code>G</code> here <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 260349821,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636069475
    },
    {
        "content": "<p>This should go inside <code>subgraph</code> right?</p>",
        "id": 260349909,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636069549
    },
    {
        "content": "<p>This would be for <code>(G G' : simple_graph V)</code></p>",
        "id": 260351276,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636070592
    },
    {
        "content": "<p>There's an ordering on simple graphs with the same vertex type based on edge containment</p>",
        "id": 260351298,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636070620
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> For your proof earlier, you don't need to use <code>choose</code>, but you can rather use <code>cases</code>, <code>rcases</code>, or <code>obtain</code> since the goal is a proposition.  <code>choose</code> is mainly useful for when you need to \"actually\" get a value out of an existential</p>",
        "id": 260352075,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636071226
    },
    {
        "content": "<p>I would even add when you need to swap an exists and a forall.</p>",
        "id": 260352185,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636071302
    },
    {
        "content": "<p>Got this one</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">support_mono</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">≤</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">H.support</span> <span class=\"bp\">≤</span> <span class=\"n\">G.support</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">is_subgraph_eq_le</span><span class=\"o\">,</span> <span class=\"n\">is_subgraph</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_support</span> <span class=\"n\">at</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"n\">choose</span> <span class=\"n\">w</span> <span class=\"n\">hw</span> <span class=\"n\">using</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hw</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">adj_comm</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260353411,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636072502
    },
    {
        "content": "<p>Two things, other than that looks good (though of course someone will golf it, it's inevitable): make sure to put a space after <code>H</code>, and please swap the roles of <code>H</code> and <code>G</code> in the lemma statement -- if you <code>#check @support_mono</code> you'll see that the arguments are <code>(G H : simple_graph V)</code>.  Another option is to edit your lemma so it says <code>(H G : simple_graph V)</code> since this will override the <code>variables</code></p>",
        "id": 260354160,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636073239
    },
    {
        "content": "<p>I forgot a third thing: put <code>(h : H ≤ G)</code> as an argument before the colon, since you're <code>intro</code>ing it anyway.</p>",
        "id": 260354243,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636073306
    },
    {
        "content": "<p>like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">support_mono</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≤</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.support</span> <span class=\"bp\">≤</span> <span class=\"n\">G'.support</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">is_subgraph_eq_le</span><span class=\"o\">,</span> <span class=\"n\">is_subgraph</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_support</span> <span class=\"n\">at</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hv</span> <span class=\"k\">with</span> <span class=\"n\">w</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hw</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">adj_comm</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260354429,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636073508
    },
    {
        "content": "<p>probably <code>G</code> and <code>G'</code> should be implicit</p>",
        "id": 260354543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636073635
    },
    {
        "content": "<p>also space <del>before</del> after the <code>&lt;-</code> although enforcement on that rule is pretty low</p>",
        "id": 260354618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636073682
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> so use <code>{G G' : simple_graph V}</code> as the argument instead</p>",
        "id": 260354632,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636073697
    },
    {
        "content": "<p>What rule's that about <code>&lt;-</code>?</p>",
        "id": 260354653,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636073718
    },
    {
        "content": "<p>i.e. <code>rw [← is_subgraph_eq_le, is_subgraph] at h,</code></p>",
        "id": 260354663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636073735
    },
    {
        "content": "<p>done: <a href=\"https://github.com/leanprover-community/mathlib/pull/10176\">https://github.com/leanprover-community/mathlib/pull/10176</a></p>",
        "id": 260354751,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636073788
    },
    {
        "content": "<p>PR updated <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 260359964,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636079505
    },
    {
        "content": "<p>I'm attempting to formalize vertex coloring. do you guys think this is a good design?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">vertex_coloring</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">color</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">color</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">color</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">vertex_colors</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.vertex_coloring</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 260429166,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636129808
    },
    {
        "content": "<p>We already thought about it quite a lot.</p>",
        "id": 260429257,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636129843
    },
    {
        "content": "<p>I would make the codomain of <code>color</code> a parameter</p>",
        "id": 260429274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636129846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span> used them without explicitly defining them for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/combinatorics.line.exists_mono_in_high_dimension\">docs#combinatorics.line.exists_mono_in_high_dimension</a></p>",
        "id": 260429360,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636129887
    },
    {
        "content": "<p>and <span class=\"user-mention\" data-user-id=\"303889\">@Alena Gusakov</span> has a definition on a branch</p>",
        "id": 260429391,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636129900
    },
    {
        "content": "<p>Either way, you'll want to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pairwise\">docs#pairwise</a></p>",
        "id": 260429489,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636129932
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I don't think your example is a vertex coloring in <span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> 's sense, Hales-jewett does not have any constraints on colors of adjacent vertices</p>",
        "id": 260429571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636129972
    },
    {
        "content": "<p>No, it doesn't. This is more of a contextual idea.</p>",
        "id": 260429684,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636130020
    },
    {
        "content": "<p>it does reveal some ambiguity of the terminology though</p>",
        "id": 260429702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636130029
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> do you mean like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">vertex_coloring</span> <span class=\"o\">(</span><span class=\"n\">color_type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">color</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">color_type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">color</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">color</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">vertex_colors</span> <span class=\"o\">(</span><span class=\"n\">color_type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.vertex_coloring</span> <span class=\"n\">color_type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 260429897,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636130102
    },
    {
        "content": "<p>yes</p>",
        "id": 260429934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636130117
    },
    {
        "content": "<p>That was my first go but I found it a bit annoying to carry <code>color_type</code> everywhere. What can I do about it?</p>",
        "id": 260430047,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636130152
    },
    {
        "content": "<p>Call it <code>α</code> <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 260430126,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636130168
    },
    {
        "content": "<p>Ah, then explain in a docstring</p>",
        "id": 260430191,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636130198
    },
    {
        "content": "<p>The docstring of <code>vertex_coloring</code> needs to explain it anyway</p>",
        "id": 260430247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636130224
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> how do you mean about <code>pairwise</code>?</p>",
        "id": 260430371,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636130278
    },
    {
        "content": "<p>but it's also useful to be able to constrain the type to other things; even in the finite graph situation you might want to take the codomain to be <code>fin k</code> to get a k-coloring</p>",
        "id": 260430373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636130279
    },
    {
        "content": "<p>and in the infinite graph situation you might want it to be some other cardinal</p>",
        "id": 260430491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636130318
    },
    {
        "content": "<p>or even just use regular type operations on it like <code>A ⊕ B</code> when joining two graphs with disjoint colors</p>",
        "id": 260430609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636130373
    },
    {
        "content": "<p>Eh, it doesn't turn out that great.</p>",
        "id": 260430775,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636130438
    },
    {
        "content": "<p>I was thinking of something like <code>∀ a, is_antichain G.adj (color '⁻¹ {a})</code></p>",
        "id": 260430882,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636130486
    },
    {
        "content": "<p>or your \"colors\" could be other mathematical objects relevant to an application. This is the reason why <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix\">docs#matrix</a> lets you use arbitrary index types even though we usually just think of the <code>fin n</code> case</p>",
        "id": 260431136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636130600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/260429702\">said</a>:</p>\n<blockquote>\n<p>it does reveal some ambiguity of the terminology though</p>\n</blockquote>\n<p>These tend to be called \"proper\" colorings when there can be confusion.</p>\n<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> Another design is to consider homomorphisms to <code>complete_graph α</code>, which gives you a lot of power</p>",
        "id": 260431751,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636130873
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">proper_coloring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">complete_graph</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 260431949,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636130949
    },
    {
        "content": "<p>This is how <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> suggested doing it.</p>",
        "id": 260432012,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636130993
    },
    {
        "content": "<p>I was thinking about defining <code>vertex_coloring</code> and <code>edge_coloring</code></p>",
        "id": 260433101,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636131438
    },
    {
        "content": "<p>Do you think it would be okay to prove the homomorphism after having that pair of more bare-bones definitions?</p>",
        "id": 260433241,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636131486
    },
    {
        "content": "<p>I think you should start with the homomorphism and turn the fields from the struct into a definition and a lemma.  The first is from applying the homomorphism, and the second is what it means to be a homomorphism, so it should be 2-4 lines total</p>",
        "id": 260434916,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636132090
    },
    {
        "content": "<p>It takes a bit of definition unfolding to see it, but this homomorphism definition is basically identical to the struct you defined</p>",
        "id": 260435027,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636132142
    },
    {
        "content": "<p>Alright, I'm gonna try to dig this approach</p>",
        "id": 260435448,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636132327
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> With your k-factors work, one thing to think about is how to go back and forth between edge colorings and coverings by disjoint maximal 1-factors (i.e., perfect matchings).)</p>",
        "id": 260440921,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636134777
    },
    {
        "content": "<p>How do I say this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">proper_coloring_is_valid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">C.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 260446849,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636137459
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">field</span> <span class=\"kd\">notation</span><span class=\"o\">,</span> <span class=\"bp\">'</span><span class=\"n\">adj'</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">a</span> <span class=\"n\">valid</span> <span class=\"s2\">\"field\"</span> <span class=\"n\">because</span> <span class=\"n\">environment</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">contain</span> <span class=\"bp\">'</span><span class=\"n\">simple_graph.proper_coloring.adj'</span>\n  <span class=\"n\">C</span>\n<span class=\"n\">which</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 260446948,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636137497
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">proper_coloring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">complete_graph</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.color</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">C</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">proper_coloring.valid</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">C.color</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">C.color</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"n\">C.map_rel</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 260447206,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636137644
    },
    {
        "content": "<p>Also,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">proper_coloring.mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">f</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">h</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>for a constructor that looks recognizable.</p>",
        "id": 260447500,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636137799
    },
    {
        "content": "<p>One of the reasons for having this be a homomorphism is that if you have an injective map <code>a -&gt; b</code>, then there is an induced graph homomorphism <code>complete_graph a -&gt;g complete_graph b</code> (not written, but easy), which you can compose with a proper a-coloring to get a proper b-coloring (so you can extend the set of colors using already existing machinery).</p>",
        "id": 260448646,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636138215
    },
    {
        "content": "<p>Or, if you have a graph homomorphism <code>G -&gt;g G'</code> and a proper a-coloring of <code>G'</code>, then you can compose the homomorphisms to get a proper a-coloring of <code>G</code>.  This can be used to show that subgraphs of a proper a-colorable graph are a-colorable.</p>",
        "id": 260448783,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636138297
    },
    {
        "content": "<p>You can see a lot further than I can. I will do my best to catch up</p>",
        "id": 260450928,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636139218
    },
    {
        "content": "<blockquote>\n<p>(<span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> With your k-factors work, one thing to think about is how to go back and forth between edge colorings and coverings by disjoint maximal 1-factors (i.e., perfect matchings).)</p>\n</blockquote>\n<p>Does that mean you want k-factors to be subgraphs?</p>",
        "id": 260451334,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636139407
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> Something I'm looking forward to is having the fact that if every finite subgraph of a graph has a proper a-coloring, then (noncomputably) the graph has a proper a-coloring.  This can be done using the idea for how <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.all_card_le_bUnion_card_iff_exists_injective\">docs#finset.all_card_le_bUnion_card_iff_exists_injective</a> is proved from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.all_card_le_bUnion_card_iff_exists_injective'\">docs#finset.all_card_le_bUnion_card_iff_exists_injective'</a></p>\n<p>I guess there's a more general result, which is if <code>G'</code> is a finite graph and if every finite subgraph of <code>G</code> has a homomorphism to <code>G'</code>, then there is a homomorphism from <code>G</code> to <code>G'</code>.</p>",
        "id": 260452323,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636139963
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> How were you thinking about formalizing them?</p>",
        "id": 260452679,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636140143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/260452323\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> Something I'm looking forward to is having the fact that if every finite subgraph of a graph has a proper a-coloring, then (noncomputably) the graph has a proper a-coloring.  This can be done using the idea for how <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.all_card_le_bUnion_card_iff_exists_injective\">docs#finset.all_card_le_bUnion_card_iff_exists_injective</a> is proved from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.all_card_le_bUnion_card_iff_exists_injective'\">docs#finset.all_card_le_bUnion_card_iff_exists_injective'</a></p>\n</blockquote>\n<p>Isn't that kind of trivial from our current definition of subgraph since a graph can be a subgraph of itself?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">subgraph</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">verts</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj_sub</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edge_vert</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">verts</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 260453368,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636140517
    },
    {
        "content": "<p>The graph can be infinite!</p>",
        "id": 260453691,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636140662
    },
    {
        "content": "<p>Oh okay then, now that's interesting <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 260453862,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636140754
    },
    {
        "content": "<p>I'm still in the process of struggling a bit with syntax. I will be chewing the idea of <code>proper_coloring</code> that you suggested</p>",
        "id": 260454178,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636140921
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">proper_coloring.mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">f</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">h</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>what does <code>@h</code> mean?</p>",
        "id": 260454341,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636141005
    },
    {
        "content": "<p>it turns the {} brackets into () ones</p>",
        "id": 260454378,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636141030
    },
    {
        "content": "<p>The problem is that with just <code>h</code>, lean will fill in the <code>v</code> and <code>w</code> arguments with metavariables that it tries to solve for, but the second slot for the constructor is expecting a function that still takes those as arguments.</p>",
        "id": 260454567,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636141126
    },
    {
        "content": "<p>If you try it without the @ then presumably you get some error saying \"I was expecting you to give me a function which starts by consuming two elements of V but this function h appears to start by eating a term of type <code>G.adj _ _</code>\"</p>",
        "id": 260454579,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636141131
    },
    {
        "content": "<p>I guess there's really not a need for these to be implicit arguments for this <code>h</code> argument -- I was just following the types for <code>rel_iso.mk</code>, which is what those angle brackets actually mean in this context.</p>",
        "id": 260454800,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636141259
    },
    {
        "content": "<p>This is a kind of fun thing you can do with <code>proper_coloring.mk</code>, if you like pattern matching:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">proper_coloring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">complete_graph</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[pattern]</span>\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">f</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.color</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">proper_coloring.mk</span> <span class=\"n\">f</span> <span class=\"n\">valid</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.valid</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">C.color</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">C.color</span> <span class=\"n\">w</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">proper_coloring.mk</span> <span class=\"n\">f</span> <span class=\"n\">valid</span><span class=\"o\">)</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">valid</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>(I'm not suggesting you implement <code>color</code> and <code>valid</code> this way. It's just an example of what <code>@[pattern]</code> can do and why it might be good to keep the arguments to<code>h</code> as implicit.)</p>",
        "id": 260455538,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636141632
    },
    {
        "content": "<p>It's still not clear to me what <code>mk</code> is doing. It's a function that takes a coloring function and a hypothesis that this coloring function is a proper one and returns... what?</p>",
        "id": 260457537,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636142598
    },
    {
        "content": "<p>It's returning an \"actual\" proper coloring</p>",
        "id": 260457726,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636142693
    },
    {
        "content": "<p>which we defined to be a kind of graph homomorphism</p>",
        "id": 260457754,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636142706
    },
    {
        "content": "<p>Try looking at <code>#check @vertex_coloring.mk</code> for your original definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">vertex_coloring</span> <span class=\"o\">(</span><span class=\"n\">color_type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">color</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">color_type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">color</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">color</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Every structure defines a <code>.mk</code> function (unless you override what it's called), which is the constructor.</p>",
        "id": 260457967,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636142801
    },
    {
        "content": "<p>An idea here is that what <code>structure</code> does is have Lean create a new type from scratch with all the desired properties -- all these properties are what the type <em>is</em>.  What we can instead do is take a pre-existing type and implementing the same properties, so this type now <em>is</em> the structure defined by <code>vertex_coloring</code>.  (There's one difference though, which is that record syntax doesn't work quite as well if you don't use <code>structure</code> directly.)</p>",
        "id": 260458700,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636143211
    },
    {
        "content": "<p>The way dot notation works also helps keep up the illusion.  We can write <code>C.color</code> and it will look for <code>proper_coloring.color C</code> first.</p>",
        "id": 260458809,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636143270
    },
    {
        "content": "<p>The question I asked <a href=\"#narrow/stream/113489-new-members/topic/cardinality.20of.20image.20set.20of.20a.20function/near/260466530\">here</a> was because I'm trying to arrive at a definition of the chromatic number. I did this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">fintype</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.colors</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">set.range</span> <span class=\"n\">C.color</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.card</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">C.colors</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">card</span> <span class=\"n\">C.colors</span>\n</code></pre></div>\n<p>But I'm very unsure this will have good consequences</p>",
        "id": 260468028,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636148392
    },
    {
        "content": "<p>Maybe I should focus on some lemmas first</p>",
        "id": 260468214,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636148516
    },
    {
        "content": "<p>It's easier to just use <code>fintype.card α</code> here, then later use some idea of restricting a coloring.  It's ok if not all colors are used, since there's a smaller <code>α</code> where it does use all the colors.</p>",
        "id": 260468730,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636148882
    },
    {
        "content": "<p>Maybe some trick similar to the <code>rel.image</code> from earlier?</p>",
        "id": 260469040,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636149096
    },
    {
        "content": "<p>A TODO in <code>subgraph.lean</code> says \"Images of graph homomorphisms as subgraphs.\"  If we had that implemented, then you could do <code>C.image</code> to get a subgraph, the vertex set of which is the set of used colors.</p>",
        "id": 260469317,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636149269
    },
    {
        "content": "<p>(The edges in the images represent colors that show up on endpoints of some edge in the original graph.  If the image isn't a complete graph, you can merge colors whenever they're not adjacent, for example.)</p>",
        "id": 260469401,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636149336
    },
    {
        "content": "<p>Got this so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">proper_coloring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">complete_graph</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.color</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">C</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">proper_coloring.valid</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.color</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">C.color</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n  <span class=\"n\">C.map_rel</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.mk</span> <span class=\"o\">(</span><span class=\"n\">color</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">color</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">color</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">color</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.card</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.is_minimal</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">C'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">C.card</span> <span class=\"bp\">≤</span> <span class=\"n\">C'.card</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 260476691,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636154855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/260452679\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> How were you thinking about formalizing them?</p>\n</blockquote>\n<p>I was thinking of defining them as graphs. But making them subgraphs does sound smart</p>",
        "id": 260476961,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636155088
    },
    {
        "content": "<p>I found this: <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graph_coloring/src/combinatorics/simple_graph/coloring.lean\">https://github.com/leanprover-community/mathlib/blob/simple_graph_coloring/src/combinatorics/simple_graph/coloring.lean</a></p>",
        "id": 260479603,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636157663
    },
    {
        "content": "<p>Maybe this would work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.lattice</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">proper_coloring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">complete_graph</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.color</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">C</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">proper_coloring.valid</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C.color</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">C.color</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n  <span class=\"n\">C.map_rel</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">@[pattern]</span>\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.mk</span> <span class=\"o\">(</span><span class=\"n\">color</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">color</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">color</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">color</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- Whether a graph can be colored by at most `n` colors. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">colorable</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n<span class=\"kd\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span>  <span class=\"c1\">-- the \"by exactI\" trick is a way to get Lean to notice the `fintype` instance</span>\n\n<span class=\"sd\">/-- If `G` isn't colorable with finitely many colors, this will be 0. -/</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">chromatic_number</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Inf</span> <span class=\"o\">{</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">G.colorable</span> <span class=\"n\">n</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 260479811,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636157897
    },
    {
        "content": "<p>The definition of <code>colorable</code> is \"There exists a finite color type of size at most <code>n</code> for which there is a proper coloring of <code>G</code>.\"  The <code>by exactI</code> is a bit unfortunate; try removing it to see the error it's avoiding.</p>",
        "id": 260479915,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636158027
    },
    {
        "content": "<p>By the way, here's some code from a while back about graphs and colorings (from before mathlib had anything about simple graphs at all): <a href=\"https://github.com/kmill/lean-graphcoloring/blob/master/src/graph.lean\">https://github.com/kmill/lean-graphcoloring/blob/master/src/graph.lean</a></p>",
        "id": 260480108,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636158251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/260479603\">said</a>:</p>\n<blockquote>\n<p>I found this: <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graph_coloring/src/combinatorics/simple_graph/coloring.lean\">https://github.com/leanprover-community/mathlib/blob/simple_graph_coloring/src/combinatorics/simple_graph/coloring.lean</a></p>\n</blockquote>\n<p>This is the one that got more developed: <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/coloring.lean\">https://github.com/leanprover-community/mathlib/blob/simple_graph_matching/src/combinatorics/simple_graph/coloring.lean</a></p>\n<p>It has stuff about homomorphisms, but colorings weren't homomorphisms themselves.</p>",
        "id": 260480237,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636158386
    },
    {
        "content": "<p>It also has this interesting \"dual\" version of colorings, which an indexed family of subsets of vertices (one subset per color), which allows you to work with partial colorings since not every vertex needs a color:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- This is an indexed family of disjoint subsets of the vertex type of `G` such that vertices in</span>\n<span class=\"sd\">the same set are not adjacent.  This is similar to `subgraph.coloring`, however not every vertex</span>\n<span class=\"sd\">needs to be given a color. -/</span>\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">coloring'</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">color_set</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">disjoint</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">c'</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">c</span> <span class=\"bp\">≠</span> <span class=\"n\">c'</span> <span class=\"bp\">→</span> <span class=\"n\">color_set</span> <span class=\"n\">c</span> <span class=\"bp\">∩</span> <span class=\"n\">color_set</span> <span class=\"n\">c'</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">v'</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">color_set</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">v'</span> <span class=\"bp\">∈</span> <span class=\"n\">color_set</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">G.adj</span> <span class=\"n\">v</span> <span class=\"n\">v'</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 260480340,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636158508
    },
    {
        "content": "<p>I found the idea of <code>β-colorable</code> (would be <code>α-colorable</code> in our case) pretty smart, which constrains the coloring by the elements of the codomain</p>",
        "id": 260481151,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636159573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/116395-maths/topic/graph.20theory/near/260452323\">said</a>:</p>\n<blockquote>\n<p>I guess there's a more general result, which is if <code>G'</code> is a finite graph and if every finite subgraph of <code>G</code> has a homomorphism to <code>G'</code>, then there is a homomorphism from <code>G</code> to <code>G'</code>.</p>\n</blockquote>\n<p>Do you happen to know if this is already being worked on currently? I thought I would try the proof myself out of curiosity, and I've been making reasonable headway, but I'm conscious of not duplicating effort.</p>",
        "id": 260483206,
        "sender_full_name": "Joanna Choules",
        "timestamp": 1636161586
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"392901\">@Joanna Choules</span> I'm not aware of anyone working on it.  (Are you using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nonempty_sections_of_fintype_inverse_system\">docs#nonempty_sections_of_fintype_inverse_system</a>? or do you have another approach for the compactness argument?)</p>",
        "id": 260483570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636161917
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> This is a proof that that definition of colorability I gave is \"reasonable\" (in that it is equivalent to something that's more concrete):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Whether a graph can be colored by at most `n` colors. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">colorable</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n<span class=\"kd\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span>  <span class=\"c1\">-- the \"by exactI\" trick is a way to get Lean to notice the `fintype` instance</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">complete_graph.of_embedding</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">complete_graph</span> <span class=\"n\">α</span> <span class=\"bp\">↪</span><span class=\"n\">g</span> <span class=\"n\">complete_graph</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">inj'</span> <span class=\"o\">:=</span> <span class=\"n\">f.inj'</span><span class=\"o\">,</span>\n  <span class=\"n\">map_rel_iff'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">colorable_if_nonempty_fin_coloring</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.colorable</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">G.proper_coloring</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">αf</span><span class=\"o\">,</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">tactic.unfreeze_local_instances</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">fintype.equiv_fin</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_embedding.trans</span> <span class=\"o\">(</span><span class=\"n\">fin.cast_le</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_embedding</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨(</span><span class=\"n\">complete_graph.of_embedding</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_hom.comp</span> <span class=\"n\">C</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">ulift</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n      <span class=\"o\">(</span><span class=\"n\">complete_graph.of_embedding</span> <span class=\"n\">equiv.ulift.symm.to_embedding</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_hom.comp</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>There are some universe variable issues that the proof needs to deal with, and it needs <code>tactic.unfreeze_local_instances</code> to get Lean to notice the <code>fintype</code> instance, but other than these technicalities the proof amounts to composing some graph homomorphisms.</p>",
        "id": 260484381,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636162843
    },
    {
        "content": "<p>it's not accepting this line: <code>let f := (fintype.equiv_fin α).to_embedding.trans (fin.cast_le h).to_embedding,</code></p>",
        "id": 260484511,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636163041
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"o\">(</span><span class=\"n\">fintype.equiv_fin</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_embedding.trans</span> <span class=\"o\">(</span><span class=\"n\">fin.cast_le</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_embedding</span>\n<span class=\"n\">term</span>\n  <span class=\"o\">(</span><span class=\"n\">fin.cast_le</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_embedding</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">fin</span> <span class=\"n\">C.card</span> <span class=\"bp\">↪</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↪</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">imax</span> <span class=\"mi\">1</span> <span class=\"bp\">?</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 260484556,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636163053
    },
    {
        "content": "<p>Something to do with this definition that I added:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">proper_coloring.card</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 260484637,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636163171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I plan to use the inverse system approach, yeah. So far I've mainly been working on the scaffolding (establishing a <code>directed_order</code>, defining the system functor), but I think I know how I want the main thread of the proof to go through.</p>",
        "id": 260484890,
        "sender_full_name": "Joanna Choules",
        "timestamp": 1636163529
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> do you think this can be useful?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">chromatic_number_is_minimal</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">C.is_minimal</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">chromatic_number</span> <span class=\"n\">G</span> <span class=\"bp\">=</span> <span class=\"n\">C.card</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260485172,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636163910
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">proper_coloring.is_minimal</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">C'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">C.card</span> <span class=\"bp\">≤</span> <span class=\"n\">C'.card</span>\n</code></pre></div>",
        "id": 260485189,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636163949
    },
    {
        "content": "<p>Is <code>C.card</code> defined to be <code>card (set.range C.color)</code>? I thought I saw you define it to be <code>card α</code>, and this theorem wouldn't be true for that.  (Maybe name the set <code>C.support</code> and make the theorem be about <code>card C.support</code>?)  There will be some <code>decidable</code> complaints from lean, so maybe add <code>open_locale classical</code> to avoid this for now.</p>",
        "id": 260485466,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636164207
    },
    {
        "content": "<p>This is the definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">proper_coloring.card</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 260485524,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636164278
    },
    {
        "content": "<p>Yeah, that's giving you the number of colors, not the number of <em>used</em> colors.</p>",
        "id": 260485649,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636164460
    },
    {
        "content": "<p>Ah, right</p>",
        "id": 260485715,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636164534
    },
    {
        "content": "<p>I think these are true:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">proper_coloring.chromatic_number_le</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.chromatic_number</span> <span class=\"bp\">≤</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.zero_le_chromatic_number</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">G.chromatic_number</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">proper_coloring.chromatic_number_minimal</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">C'</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">set.range</span> <span class=\"n\">C'.color</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.chromatic_number</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 260485732,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636164558
    },
    {
        "content": "<p>Why do you use <code>def</code> for these instead?</p>",
        "id": 260485847,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636164664
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I've uploaded everything to the branch <code>graph-coloring-homomorphism</code></p>",
        "id": 260486843,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636166092
    },
    {
        "content": "<p>That was a mistake -- they were supposed to be <code>lemma</code>s</p>",
        "id": 260486861,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636166155
    },
    {
        "content": "<p>This is potentially a useful variation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">colorable_if_nonempty_fin_coloring'</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.colorable</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">G.proper_coloring</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">C.color</span> <span class=\"n\">v</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">colorable_if_nonempty_fin_coloring</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">⟩,</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">complete_graph.of_embedding</span> <span class=\"o\">(</span><span class=\"n\">fin.coe_embedding</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_embedding</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">f.to_hom.comp</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">C</span> <span class=\"k\">with</span> <span class=\"n\">color</span> <span class=\"n\">valid</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">fin.is_lt</span> <span class=\"o\">(</span><span class=\"n\">color</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">Cf</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨⟨</span><span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">C.color</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">Cf</span> <span class=\"n\">v</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">hvw</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">complete_graph_eq_top</span><span class=\"o\">,</span> <span class=\"n\">top_adj</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">C.valid</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">hvw</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260487133,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636166539
    },
    {
        "content": "<p>I'm gonna include it in the branch too</p>",
        "id": 260487149,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636166597
    },
    {
        "content": "<p>here: <a href=\"https://github.com/leanprover-community/mathlib/blob/graph-coloring-homomorphism/src/combinatorics/simple_graph/coloring.lean\">https://github.com/leanprover-community/mathlib/blob/graph-coloring-homomorphism/src/combinatorics/simple_graph/coloring.lean</a></p>",
        "id": 260487207,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636166700
    },
    {
        "content": "<p>I'm gonna try to pick up that other task to redesign matchings as subgraphs. I think it's simpler <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 260487224,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636166750
    },
    {
        "content": "<p>I'm quite happy for this discussion to be going on here but isn't there an entire graph theory stream where you can sort your ideas into different threads which perhaps will be helpful for later reference? Perhaps <span class=\"user-mention\" data-user-id=\"392901\">@Joanna Choules</span> and <span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> don't know about it -- it's hidden by default. It would be really great to see some more progress in this area, I think there's plenty to be done and I think we now understand basic design decisions (which held up graph theory for so long) much better so there's now a chance for the area to grow</p>",
        "id": 260498729,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636184610
    },
    {
        "content": "<p>Yeah, I just wanted to do a quick status check before ploughing on. If I run into any implementation questions I'll thread them separately.</p>",
        "id": 260503361,
        "sender_full_name": "Joanna Choules",
        "timestamp": 1636191451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> How to create different threads inside a stream? Do you mean we can have the following hierarchy:<br>\n<code>maths &gt; graph theory &gt; coloring</code>?</p>",
        "id": 260576733,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636295011
    },
    {
        "content": "<p>There is a separate stream (same level as <code>maths</code>), see <a class=\"stream\" data-stream-id=\"252551\" href=\"/#narrow/stream/252551-graph-theory\">#graph theory</a></p>",
        "id": 260577070,
        "sender_full_name": "Reid Barton",
        "timestamp": 1636295344
    },
    {
        "content": "<p>Posting here too since not everyone has subscribed to <a class=\"stream\" data-stream-id=\"252551\" href=\"/#narrow/stream/252551-graph-theory\">#graph theory</a> <br>\nIt's open for reviews: <a href=\"https://github.com/leanprover-community/mathlib/pull/10210\">https://github.com/leanprover-community/mathlib/pull/10210</a></p>",
        "id": 260670972,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1636384821
    }
]
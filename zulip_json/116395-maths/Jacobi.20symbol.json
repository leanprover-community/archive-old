[
    {
        "content": "<p>First of all, thanks to everybody <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>  <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  for your help with additive and multiplicative characters, Gauss sums, and the Legendre symbol!<br>\nI have now written code that defines the Jacobi symbol and proves its most important properties.</p>",
        "id": 295816984,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661768920
    },
    {
        "content": "<p>This is great. Do you think cubic reciprocity is in sight? Could it be an MSc project?</p>",
        "id": 295817068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661768967
    },
    {
        "content": "<p>The PR is <a href=\"https://github.com/leanprover-community/mathlib/pull/16290\">#16290</a>.</p>",
        "id": 295817123,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661768983
    },
    {
        "content": "<p>I had to make some design decisions that I would like to mention here.<br>\nThe Jacobi symbol is defined as a product over Legendre symbols (running over the prime factors of the number below). I am basically using <code>nat.factor</code> and a product over the resulting list. However, since the Legendre symbol (and the relevant properties we want to use) requires its second (actually the first, as implemented) argument to be a prime, I need to use a modified version of <code>nat.factors</code>, whose elements know that they are primes. For this purpose, I have introduced a variant <code>nat.prime_factors</code> with values in <code>list primes</code>. I had to duplicate part of the API for <code>nat.factors</code> to be able to use it easily.</p>",
        "id": 295817675,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661769236
    },
    {
        "content": "<p>Given this, the definition of the Jacobi symbol is simply</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">jacobi_sym</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">b.prime_factors.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">primes</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">legendre_sym</span> <span class=\"n\">p.1</span> <span class=\"o\">⟨</span><span class=\"n\">p.2</span><span class=\"o\">⟩</span> <span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span>\n</code></pre></div>\n<p>Note that this definition returns something for all natural numbers <code>b</code>, even though the definition really only makes sense when <code>b</code> is odd. This requirement shows up later (in the form of an argument <code>(hb : odd b)</code>) in some of the lemmas.</p>",
        "id": 295817911,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661769345
    },
    {
        "content": "<p>Thanks!! A first trivial comment: the PR is pretty long, I think you can split if, PRing first of all the material about <code>nat.prime_factors</code>, maybe in another file :)</p>",
        "id": 295818062,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1661769396
    },
    {
        "content": "<p>I introduce the notation <code>[a | b]ⱼ</code> for the symbol (localized to <code>number_theory_symbols</code>, which I anticipate will later also contain notation for the Hilbert symbol). Unfortunately, there is no upper-case subscipt <code>J</code> available (at least not via <code>\\_J</code> in VSCode). (I noticed earlier when playing around with notation for the Hilbert symbol that round parentheses don't seem to work well, probably because they are used for a lot of other notation.)</p>",
        "id": 295818307,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661769496
    },
    {
        "content": "<p>For the proofs, I first show that the symbol is multiplicative in the second argument (which more or less follows directly from the definition) and then I use \"multiplicative induction\" via <code>nat.rec_on_mul</code>. For some of the proofs (equalities with multiplicative right hand side), one can abstract this into a custom proof principle (<code>jacobi_sym_value</code>), which results in one-line proofs of <code>[-1 | b}ⱼ = χ₄ b</code> and the similar versions for <code>2</code> and <code>-2</code> and also in a fairly short proof of quadratic reciprocity.<br>\nIn a number of the earlier proofs, it seems that I have to spell out the proof each time again, because the statements are too different in shape. (This contributes somewhat to the length of the file.) Ideas for simplifications are appreciated!</p>",
        "id": 295818935,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661769785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295818062\">said</a>:</p>\n<blockquote>\n<p>Thanks!! A first trivial comment: the PR is pretty long, I think you can split if, PRing first of all the material about <code>nat.prime_factors</code>, maybe in another file :)</p>\n</blockquote>\n<p>I think the material on <code>nat.prime_factors</code> should be moved to <code>data.nat.prime</code> anyway, but I wanted to wait to see if more API is needed before making the move.<br>\nOne could split the material on the Jacobi symbol into two parts: one containing the sections on \"Definition\" and \"Properties\" and one containing the sections on \"Values\" and \"Quadratic Reciprocity\". Would that be helpful?</p>",
        "id": 295819317,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661769964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295817068\">said</a>:</p>\n<blockquote>\n<p>This is great. Do you think cubic reciprocity is in sight? Could it be an MSc project?</p>\n</blockquote>\n<p>Possibly. You'd have to do cubic characters, cubic residue symbols on Eisenstein integers (I don't know how much of the theory of Eisenstein integers is already available), Jacobi sums (which are a likely topic for my seminar, but I'll have to see how many students will actually be interested), at least this is what I see when I flip through Ireland&amp;Rosen.</p>",
        "id": 295820255,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661770372
    },
    {
        "content": "<p>Did you try using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.attach\">docs#list.attach</a> instead of defining a new function <code>nat.prime_factors</code>? That should allow you to use the fact that a member of prime factors is prime whenever needed</p>",
        "id": 295821443,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1661770892
    },
    {
        "content": "<p>There's already about seven ways to talk about the prime factors of a natural, adding more doesn't sound that great</p>",
        "id": 295824276,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1661772129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295821443\">said</a>:</p>\n<blockquote>\n<p>Did you try using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.attach\">docs#list.attach</a> instead of defining a new function <code>nat.prime_factors</code>? That should allow you to use the fact that a member of prime factors is prime whenever needed</p>\n</blockquote>\n<p><code>nat.prime_factors</code> is defined using <code>list.attach</code>. Using it directly seems to be a pain -- if <code>l1 = l2</code>, you cannot rewrite <code>l1.attach</code> into <code>l2.attach</code>, since <code>l1.attach = l2.attach</code> doesn't even type-check...</p>",
        "id": 295825404,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661772609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295824276\">said</a>:</p>\n<blockquote>\n<p>There's already about seven ways to talk about the prime factors of a natural, adding more doesn't sound that great</p>\n</blockquote>\n<p>Can you be more precise? I.e., which ways are there, and which one do you think could be used here most easily?</p>",
        "id": 295825569,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661772684
    },
    {
        "content": "<p>I have now shortened the lengthy proofs somewhat and also added text to the module docstring.</p>",
        "id": 295853023,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661782471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295825404\">said</a>:</p>\n<blockquote>\n<p><code>nat.prime_factors</code> is defined using <code>list.attach</code>. Using it directly seems to be a pain -- if <code>l1 = l2</code>, you cannot rewrite <code>l1.attach</code> into <code>l2.attach</code>, since <code>l1.attach = l2.attach</code> doesn't even type-check...</p>\n</blockquote>\n<p>Can you use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.pmap\">docs#list.pmap</a>? There is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.pmap_congr\">docs#list.pmap_congr</a>.</p>",
        "id": 295944723,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661789112
    },
    {
        "content": "<p>I'll try to see if <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.pmap\">docs#list.pmap</a> can be made to work in a reasonable way.<br>\nOn the other hand, I would think that having a function <code>prime_factors : ℕ → list primes</code> is quite natural. After all, what is the type <code>primes</code> for if not for an application like this?</p>",
        "id": 295975201,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661798911
    },
    {
        "content": "<p>Why do you need a list? Why can't you do <code>(n.factors.map _).prod _</code>?</p>",
        "id": 295975823,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1661799141
    },
    {
        "content": "<p><code>n.factors</code> <em>is</em> a list, so it is not clear to me what you mean here.</p>",
        "id": 295975947,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661799190
    },
    {
        "content": "<p>Sorry, I was confused with the UFD factors</p>",
        "id": 295976076,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1661799239
    },
    {
        "content": "<p>I cannot simply do <code>(n.factors.map (λ p, legendre_sym p a)).prod</code>, because <code>legendre_sym</code> needs to know that <code>p</code> is a prime.</p>",
        "id": 295976191,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661799261
    },
    {
        "content": "<p>With <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.pmap\">docs#list.pmap</a>, the definition would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">jacobi_sym'</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">b.factors.pmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pp</span> <span class=\"o\">:</span> <span class=\"n\">p.prime</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">legendre_sym</span> <span class=\"n\">p</span> <span class=\"o\">⟨</span><span class=\"n\">pp</span><span class=\"o\">⟩</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">pf</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">b.factors</span><span class=\"o\">),</span> <span class=\"n\">prime_of_mem_factors</span> <span class=\"n\">pf</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span>\n</code></pre></div>\n<p>which is a bit more involved. I'll now try to use it...</p>",
        "id": 295976340,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661799322
    },
    {
        "content": "<p>I'm not sure what the type <code>primes</code> is for to be honest, it doesn't have too many meaningful algebraic structures on it, so it does seem easier to stick to the <code>is_prime</code> predicate where possible, and use subtypes when needed</p>",
        "id": 295976586,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1661799401
    },
    {
        "content": "<p>(<code>primes</code> <em>is</em> a subtype...)</p>",
        "id": 295976662,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661799428
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">number_theory.legendre_symbol.quadratic_reciprocity</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span> <span class=\"n\">zmod</span>\n\n<span class=\"sd\">/-- The Jacobi symbol of `a` and `b` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">jacobi_sym</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">b.factors.pmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">legendre_sym</span> <span class=\"n\">n</span> <span class=\"o\">⟨</span><span class=\"n\">hn</span><span class=\"o\">⟩</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">prime_of_mem_factors</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n.prime</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">prod</span>\n</code></pre></div>",
        "id": 295976700,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1661799442
    },
    {
        "content": "<p>Exactly, so giving it a name is just adding some extra layer of obfuscation to applying lemmas about subtype to it</p>",
        "id": 295976752,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1661799459
    },
    {
        "content": "<p>Ah I see you got it</p>",
        "id": 295976757,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1661799459
    },
    {
        "content": "<p>I'm missing <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.pmap_append\">docs#list.pmap_append</a> (the analogue of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.map_append\">docs#list.map_append</a>). Is it (or something equivalent) available, perhaps under a different name?</p>",
        "id": 295978643,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661800139
    },
    {
        "content": "<p>Apart from this (which is needed for the fundamental multiplicativity in the second argument), the alternative definition seems to work well.</p>",
        "id": 295979462,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661800431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295976191\">said</a>:</p>\n<blockquote>\n<p>I cannot simply do <code>(n.factors.map (λ p, legendre_sym p a)).prod</code>, because <code>legendre_sym</code> needs to know that <code>p</code> is a prime.</p>\n</blockquote>\n<p>To me, this looks like an indication that the definition of <code>legendre_sym</code> is not good: it should be <code>1</code> (or <code>0</code>, depending on what works best) if <code>p</code> is not prime, and the usual thing when <code>p</code> is prime.</p>",
        "id": 295980378,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1661800794
    },
    {
        "content": "<p>That would introduce <code>ite</code>s, and anyway, the problem would only be shifted, since all relevant properties of the Legendre symbol are only valid when <code>p</code> is prime.</p>",
        "id": 295980624,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661800884
    },
    {
        "content": "<p>That's the concept of junk value: introduce total functions, even at places where they are not well defined mathematically (just like division by zero is defined as a total function), and prove the lemmas assuming the additional properties when needed. So many lemmas about <code>legendre_sym</code> would indeed have an assumption <code>prime p</code>, but the definition wouldn't. Just like the definition of the square root of a real number doesn't need the number to be nonnegative, but many lemmas on the square root have nonnegativity as an assumption.</p>\n<p>This may look crazy at first sight, but experimentally this is a much better design than partial functions (as you are seeing just now).</p>",
        "id": 295986609,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1661802545
    },
    {
        "content": "<p>The problem is that as soon as you want to <em>use</em> properties of the Legendre symbol to prove properties of the Jacobi symbol, you will have to know that the elements of <code>b.factors</code> are primes. So this only moves the problem to another place.<br>\n(And BTW, I do define the Jacobi symbol for all natural numbers <code>b</code>.)</p>",
        "id": 295986880,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661802653
    },
    {
        "content": "<p>In fact, you will need to know many things, but you don't bake them into the definition!</p>",
        "id": 295987059,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661802736
    },
    {
        "content": "<p>Anyway, here is a version of <code>list.pmap_append</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.pmap_append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l₁</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l₂</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pmap</span> <span class=\"n\">f</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">l₁.pmap</span> <span class=\"n\">f</span> <span class=\"n\">h₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂.pmap</span> <span class=\"n\">f</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l₁</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.pmap</span><span class=\"o\">,</span> <span class=\"n\">list.nil_append</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.pmap</span><span class=\"o\">,</span> <span class=\"n\">list.cons_append</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>(Of course, <code>h</code> follows from <code>h₁</code> and <code>h₂</code>, but it is not clear to me how to factor that in in a way that allows for easy use later.)</p>",
        "id": 295987071,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661802745
    },
    {
        "content": "<p>You can give it a default value.</p>",
        "id": 295987140,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661802779
    },
    {
        "content": "<p>How do I spell this out?</p>",
        "id": 295987188,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661802801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295986880\">said</a>:</p>\n<blockquote>\n<p>you will have to know that the elements of <code>b.factors</code> are primes</p>\n</blockquote>\n<p>That's known right? It's just that it is not available when doing a <code>finset.prod</code> because <code>finset.prod</code> takes a total function as argument.</p>",
        "id": 295987196,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661802804
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295987196\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295986880\">said</a>:</p>\n<blockquote>\n<p>you will have to know that the elements of <code>b.factors</code> are primes</p>\n</blockquote>\n<p>That's known right? It's just that it is not available when doing a <code>finset.prod</code> because <code>finset.prod</code> takes a total function as argument.</p>\n</blockquote>\n<p>Exactly.</p>",
        "id": 295987241,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661802820
    },
    {
        "content": "<p>So extending <code>legendre_sym</code> to return a junk value of <code>1</code> makes sense to me.</p>",
        "id": 295987364,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661802848
    },
    {
        "content": "<p>With <code>list.pmap_append</code>available, I can do what I need using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.pmap\">docs#list.pmap</a>.</p>",
        "id": 295987382,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661802855
    },
    {
        "content": "<p>But more likely you want to remove <code>h_0</code> and <code>h_1</code> and deduce them from <code>h</code>, so that you can rewrite without having to prove everything over and over again.</p>",
        "id": 295987446,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661802885
    },
    {
        "content": "<p>I.e., I can get rid of <code>nat.prime_factors</code>, and everything will work fine.</p>",
        "id": 295987461,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661802894
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295987446\">said</a>:</p>\n<blockquote>\n<p>But more likely you want to remove <code>h_0</code> and <code>h_1</code> and deduce them from <code>h</code>, so that you can rewrite without having to prove everything over and over again.</p>\n</blockquote>\n<p>In my use case, you know <code>h₁</code> and <code>h₂</code> already, but you don't immediately have <code>h</code>, so I think the variant with building <code>h</code> out of the other two seems preferable.</p>",
        "id": 295987703,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661802979
    },
    {
        "content": "<p>(Because the lists are of the form <code>n.factors</code>, so you know they consist of primes.)</p>",
        "id": 295987770,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661803016
    },
    {
        "content": "<p>But maybe you are right. I'll try it out...</p>",
        "id": 295987910,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661803070
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.pmap_append'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pmap</span> <span class=\"n\">f</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">l₁.pmap</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">list.mem_append_left</span> <span class=\"n\">l₂</span> <span class=\"n\">ha</span><span class=\"o\">))</span>\n                         <span class=\"bp\">++</span> <span class=\"n\">l₂.pmap</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">list.mem_append_right</span> <span class=\"n\">l₁</span> <span class=\"n\">ha</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l₁</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.pmap</span><span class=\"o\">,</span> <span class=\"n\">list.nil_append</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.pmap</span><span class=\"o\">,</span> <span class=\"n\">list.cons_append</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 295988416,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661803259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295987364\">said</a>:</p>\n<blockquote>\n<p>So extending <code>legendre_sym</code> to return a junk value of <code>1</code> makes sense to me.</p>\n</blockquote>\n<p>I would think that <code>legendre_sym p</code> should be the identity for <code>p</code> not prime, that would make even more stuff true in general.</p>",
        "id": 295988514,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1661803307
    },
    {
        "content": "<p>This works in the same way in my application, so perhaps the second version is preferable.</p>",
        "id": 295988619,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661803334
    },
    {
        "content": "<p>The Legendre symbol is defined as the quadratic character of <code>zmod p</code> (composed with the natural map from the integers to <code>zmod p</code>), and the quadratic character is defined for (finite) fields.<br>\nMy opinion is that once you have the Jacobi symbol, you don't have to consider Legendre symbols anyway, so in a sense the implementation of the latter is fairly irrelevant.</p>",
        "id": 295989079,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661803486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/295987703\">said</a>:</p>\n<blockquote>\n<p>In my use case, you know <code>h₁</code> and <code>h₂</code> already, but you don't immediately have <code>h</code>, so I think the variant with building <code>h</code> out of the other two seems preferable.</p>\n</blockquote>\n<p>There's always the option of having both versions.</p>",
        "id": 295989461,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661803645
    },
    {
        "content": "<p>I wish there was a way to tell Lean to infer a set of assumptions from another and back without having to write several lemmas.</p>",
        "id": 295992840,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661803718
    },
    {
        "content": "<p>The new version is now on github (<a href=\"https://github.com/leanprover-community/mathlib/pull/16290\">#16290</a>).</p>",
        "id": 295997401,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661805612
    },
    {
        "content": "<p>I think the following should be tagged <code>@[simp]</code>:<br>\n<code>jacobi_sym_zero_right</code>, <code>jacobi_sym_one_right</code>, <code>jacobi_sym_one_left</code>, <code>jacobi_sym_zero_left</code> (although the latter may rarely fire because of the condition on <code>b</code>). Should there be more <code>simp</code> lemmas?</p>",
        "id": 295998225,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661806012
    },
    {
        "content": "<p>I don't think making the last one a simp lemma is really worth it then, seeing as it will be so unlikely to fire, the others look good though</p>",
        "id": 296002371,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1661807893
    },
    {
        "content": "<p>I think <a href=\"https://github.com/leanprover-community/mathlib/pull/16290\">#16290</a> should be good now, except for moving the auxiliary lemmas at the beginning of the files to appropriate locations.<br>\nI have made some suggestions, but in some cases, it is not clear to me where to put them:</p>\n<ul>\n<li><code>nat.two_pow_mul_odd</code> needs imports from <code>data.nat.factorization.basic</code> and <code>data.nat.parity</code>, but there does not seem to be an appropriate file that imports both</li>\n<li><code>int.sign_submonoid</code> needs <code>group_theory.submonoid.basic</code> and the algebraic structure of the integers</li>\n<li><code>zmod.eq_zero_iff_gcd_ne_one</code> and friends need <code>data.zmod.basic</code> and <code>ring_theory.int.basic</code>. <code>data.zmod.quotient</code> is a file that imports both, but has a different topic.</li>\n</ul>\n<p>Suggestions? <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span></p>",
        "id": 296426377,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661971105
    },
    {
        "content": "<p>I have now moved the auxiliary lemmas to places I think are reasonable, For the three lemmas regarding the vanishing of <code>a</code> mod <code>p</code>, I have created a new file, since there was no suitable existing one with the right imports.<br>\nI hope this can now be merged. <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span></p>",
        "id": 296696740,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662065132
    },
    {
        "content": "<p>I still had several comments. The PR is now well over 500 lines, and touches 8 files. I think the non-Jacobi files are pretty uncontroversial. If you move the Jacobi file to a new PR, then the rest can be merged quickly.</p>",
        "id": 296758816,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662100866
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Thanks for the comments! I have fixed the documentation now. The Jacobi symbol file has been fairly thoroughly reviewed by <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>, so my impression was that it should also be pretty uncontroversial right now. But if it helps, I can split it off, of course. (The PR was actually quite a bit longer initially, but thanks to Junyan's efforts at shortening proofs, it has shrunk over time.)</p>",
        "id": 296778008,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662109717
    },
    {
        "content": "<p>Well, it helps me review PRs in little gaps of free time if they are bit-sized and do only 1 thing.</p>",
        "id": 296778245,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662109833
    },
    {
        "content": "<p>OK; I'll remove the file <code>jacobi_symbol.lean</code>, wait until the rest gets merged (hopefully soon) and then PR it again.</p>",
        "id": 296779166,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662110228
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <a href=\"https://github.com/leanprover-community/mathlib/pull/16290\">#16290</a> has passed CI again.</p>",
        "id": 296797462,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662117558
    },
    {
        "content": "<p>Can you please update the title and the description of the PR? Thanks!</p>",
        "id": 296800924,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1662118841
    },
    {
        "content": "<p>Done. (Plus the suggested <code>simpa</code> simplification.)</p>",
        "id": 296812168,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662122687
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/296779166\">said</a>:</p>\n<blockquote>\n<p>OK; I'll remove the file <code>jacobi_symbol.lean</code>, wait until the rest gets merged (hopefully soon) and then PR it again.</p>\n</blockquote>\n<p>Thanks. Experience shows that review time is not linear in the total number of lines. Especially if many files change, then the changes should be trivial.</p>",
        "id": 296816566,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662124142
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> Can you reply to my question in the comments to <a href=\"https://github.com/leanprover-community/mathlib/pull/16290\">#16290</a>? Thanks!</p>",
        "id": 296954430,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662191778
    },
    {
        "content": "<p>I am busy this weekend, I will have a look on Monday, sorry.</p>",
        "id": 296975744,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1662202852
    },
    {
        "content": "<p>As a teaser (in the hope that this will provide even more motivation to push along with <a href=\"https://github.com/leanprover-community/mathlib/pull/16290\">#16290</a> and the follow-up Jacobi symbol PRs), I can now do the following in my set-up.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">is_square</span> <span class=\"o\">(</span><span class=\"mi\">2345</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"mi\">6789</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">nonsquare_of_jacobi_sym_eq_neg_one</span> <span class=\"mi\">2345</span> <span class=\"mi\">6789</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The Jacobi symbol is evaluated using Quadratic Reciprocity, of course.</p>",
        "id": 297028262,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662233225
    },
    {
        "content": "<p>That's great!</p>",
        "id": 297028420,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662233327
    },
    {
        "content": "<p>It would be cool if we could have a <code>norm_num</code> extension that simplifies <code>is_square x y</code> to <code>true</code> or <code>false</code>.</p>",
        "id": 297028489,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662233397
    },
    {
        "content": "<p>Do you think you could do that?</p>",
        "id": 297028543,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662233407
    },
    {
        "content": "<p>It would involve a bit of meta-programming.</p>",
        "id": 297028553,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662233414
    },
    {
        "content": "<p>I have done a bit of meta-programming already for the <code>norm_num</code> extension (not that I would claim that I fully understand everything I'm doing).</p>",
        "id": 297028603,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662233454
    },
    {
        "content": "<p>But deciding whether <code>a</code> is a square mod <code>b</code> or not is at least as hard as factoring <code>b</code>, if I remember correctly.</p>",
        "id": 297028657,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662233499
    },
    {
        "content": "<p>You can quickly detect non-squares with the Jacobi symbol, but when <code>b</code> is not prime, there will be non-squares on which the symbol takes the value <code>1</code>.</p>",
        "id": 297028722,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662233550
    },
    {
        "content": "<p>Of course, <code>norm_num</code> can evaluate <code>b.factors</code>, so one can use that, and it would work for whatever numbers the factorization can be done in this way.</p>",
        "id": 297028772,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662233600
    },
    {
        "content": "<p>Well, if it only works for numbers &lt; 10^5 that's still nice.</p>",
        "id": 297028854,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662233645
    },
    {
        "content": "<p>We can work on fast factoring algorithms when we need them.</p>",
        "id": 297028862,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662233660
    },
    {
        "content": "<p>And we could even off-load it to an external program if we really need to.</p>",
        "id": 297028871,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662233677
    },
    {
        "content": "<p>I have to say that with larger numbers, I had issues with recursion depth, which I find surprising, since the proof terms produced by <code>norm_num</code> for <code>p.prime</code> can be much larger than what I get in the example above for the Jacobi symbol.</p>",
        "id": 297028923,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662233723
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>$ factor <span class=\"m\">987654321</span>\n<span class=\"m\">987654321</span>: <span class=\"m\">3</span> <span class=\"m\">3</span> <span class=\"m\">17</span> <span class=\"m\">17</span> <span class=\"m\">379721</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">aux</span> <span class=\"o\">:</span> <span class=\"mi\">987654321</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"mi\">17</span> <span class=\"bp\">*</span> <span class=\"mi\">17</span> <span class=\"bp\">*</span> <span class=\"mi\">379721</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">aux</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>for a very hands-on offloading of the factoring.</p>",
        "id": 297028943,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662233761
    },
    {
        "content": "<p>Hmmz, recursion depth shouldn't be a problem, unless your numbers get really large.</p>",
        "id": 297029006,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662233793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297028871\">said</a>:</p>\n<blockquote>\n<p>And we could even off-load it to an external program if we really need to.</p>\n</blockquote>\n<p>We'd need certificates for the lagre primes that Lean can check efficiently.</p>",
        "id": 297029009,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662233799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297029006\">said</a>:</p>\n<blockquote>\n<p>Hmmz, recursion depth shouldn't be a problem, unless your numbers get really large.</p>\n</blockquote>\n<p>I'll try again...</p>",
        "id": 297029024,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662233820
    },
    {
        "content": "<p>Sure, but what is the current limit for <code>norm_num</code>?</p>",
        "id": 297029030,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662233824
    },
    {
        "content": "<p>I guess it can handle primes of size ~ 10^6 easily? I have no idea.</p>",
        "id": 297029068,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662233865
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"mi\">102334155</span> <span class=\"bp\">|</span> <span class=\"mi\">165580141</span><span class=\"o\">]</span><span class=\"bp\">ⱼ=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>leads to <code>deep recursion was detected at 'replace' (potential solution: increase stack space in your system)</code></p>",
        "id": 297029125,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662233899
    },
    {
        "content": "<p>The proof term I get (<code>show_term {norm_num}</code> does work) is roughly two-thirds the size (in lines or characters) of the one for </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">nat.prime</span> <span class=\"mi\">6791</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>which does not run into any problems...</p>",
        "id": 297029346,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662234053
    },
    {
        "content": "<p>Hmm, I'm afraid we need someone with actual expertise in metaprogramming to debug this... not me...</p>",
        "id": 297029415,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662234111
    },
    {
        "content": "<p>Btw, note that we have the lucas primality test in mathlib. But I'm not sure if <code>norm_num</code> uses that.</p>",
        "id": 297029495,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662234151
    },
    {
        "content": "<p>It doesn't. <code>norm_num</code> does just trial factorization.</p>",
        "id": 297029560,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662234205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297028657\">said</a>:</p>\n<blockquote>\n<p>But deciding whether <code>a</code> is a square mod <code>b</code> or not is at least as hard as factoring <code>b</code>, if I remember correctly.</p>\n</blockquote>\n<p>If you want to start thinking seriously about this sort of thing then I guess you should switch to Lean 4. Any interest in recruiting some people to work on writing the algorithms in Cohen's \"A Course in Computational Algebraic Number Theory\" in Lean 4, to see how competitive it is? The proofs they're correct can come later.</p>",
        "id": 297029661,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662234281
    },
    {
        "content": "<p>We could certainly get <a href=\"https://en.wikipedia.org/wiki/Primality_certificate#Pratt_certificates\">https://en.wikipedia.org/wiki/Primality_certificate#Pratt_certificates</a> pretty easily.</p>",
        "id": 297029673,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662234294
    },
    {
        "content": "<p>Four-digit numbers seem to be about the limit for the Jacobi symbol.</p>",
        "id": 297029929,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662234493
    },
    {
        "content": "<p><code>example : nat.prime 1000003 := by norm_num</code> works.</p>",
        "id": 297029989,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662234556
    },
    {
        "content": "<p>My proof term above is actually only <em>one</em>-third the size of the other one (I copied the infoview window, which showed the term twice).</p>",
        "id": 297030109,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662234676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297029929\">said</a>:</p>\n<blockquote>\n<p>Four-digit numbers seem to be about the limit for the Jacobi symbol.</p>\n</blockquote>\n<p>Hmm, any idea what the computational bottle neck is?</p>",
        "id": 297030347,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662234878
    },
    {
        "content": "<p>No. It does not take long, and it uses less space than <code>nat.prime 6791</code> (in terms of \"allocated objects\" and \"allocated closures\" as printed by the profiler). It is just the \"deep recursion\" that seems to be triggered at some point.</p>",
        "id": 297030506,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662234985
    },
    {
        "content": "<p>Hmm, weird. Because I would imagine there's at most 5 or 6 nested calls?</p>",
        "id": 297030544,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662235025
    },
    {
        "content": "<p>Here is the term for <code>2345</code> and <code>6789</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">id_tag</span> <span class=\"o\">()</span>\n   <span class=\"o\">(((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ᾰ</span> <span class=\"n\">ᾰ_1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_2</span> <span class=\"o\">:</span> <span class=\"n\">ᾰ</span> <span class=\"bp\">=</span> <span class=\"n\">ᾰ_1</span><span class=\"o\">),</span> <span class=\"n\">congr</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">eq</span> <span class=\"n\">e_1</span><span class=\"o\">)</span> <span class=\"n\">e_2</span><span class=\"o\">)</span>\n       <span class=\"o\">[</span><span class=\"mi\">2345</span> <span class=\"bp\">|</span> <span class=\"mi\">6789</span><span class=\"o\">]</span><span class=\"bp\">ⱼ</span>\n       <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"n\">jacobi_sym_mod_left</span> <span class=\"mi\">2345</span> <span class=\"mi\">6789</span>\n          <span class=\"o\">(</span><span class=\"n\">ne_of_gt</span>\n             <span class=\"o\">(</span><span class=\"n\">bit1_pos'</span>\n                <span class=\"o\">(</span><span class=\"n\">bit0_pos</span>\n                   <span class=\"o\">(</span><span class=\"n\">bit1_pos'</span>\n                      <span class=\"o\">(</span><span class=\"n\">bit0_pos</span>\n                         <span class=\"o\">(</span><span class=\"n\">bit0_pos</span>\n                            <span class=\"o\">(</span><span class=\"n\">bit0_pos</span>\n                               <span class=\"o\">(</span><span class=\"n\">bit0_pos</span> <span class=\"o\">(</span><span class=\"n\">bit1_pos'</span> <span class=\"o\">(</span><span class=\"n\">bit0_pos</span> <span class=\"o\">(</span><span class=\"n\">bit1_pos'</span> <span class=\"o\">(</span><span class=\"n\">bit0_pos</span> <span class=\"o\">(</span><span class=\"n\">bit1_pos'</span> <span class=\"n\">zero_lt_one'</span><span class=\"o\">)))))))))))))</span>\n          <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">jacobi_sym_qr₁</span> <span class=\"mi\">2345</span> <span class=\"mi\">6789</span>\n             <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">2345</span> <span class=\"mi\">4</span> <span class=\"mi\">586</span> <span class=\"mi\">1</span> <span class=\"mi\">2344</span>\n                <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0_bit0</span> <span class=\"mi\">293</span> <span class=\"mi\">2</span> <span class=\"mi\">586</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">293</span> <span class=\"mi\">1</span> <span class=\"mi\">293</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">293</span><span class=\"o\">)))</span>\n                <span class=\"o\">(</span><span class=\"n\">norm_num.one_add</span> <span class=\"mi\">2344</span> <span class=\"mi\">2345</span> <span class=\"o\">(</span><span class=\"n\">norm_num.bit0_succ</span> <span class=\"mi\">1172</span><span class=\"o\">))</span>\n                <span class=\"o\">(</span><span class=\"n\">norm_num.lt_one_bit0</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">norm_num.le_one_bit0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n             <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">6789</span> <span class=\"mi\">2</span> <span class=\"mi\">3394</span> <span class=\"mi\">1</span> <span class=\"mi\">6788</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0_bit0</span> <span class=\"mi\">1697</span> <span class=\"mi\">1</span> <span class=\"mi\">1697</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">1697</span><span class=\"o\">))</span>\n                <span class=\"o\">(</span><span class=\"n\">norm_num.one_add</span> <span class=\"mi\">6788</span> <span class=\"mi\">6789</span> <span class=\"o\">(</span><span class=\"n\">norm_num.bit0_succ</span> <span class=\"mi\">3394</span><span class=\"o\">))</span>\n                <span class=\"o\">(</span><span class=\"n\">norm_num.lt_one_bit0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"mi\">1</span><span class=\"o\">)))</span>\n             <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n             <span class=\"o\">(</span><span class=\"n\">jacobi_sym_nat_mod_left</span> <span class=\"mi\">6789</span> <span class=\"mi\">2345</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">jacobi_sym_qr₁'</span> <span class=\"mi\">2099</span> <span class=\"mi\">2345</span>\n                   <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">2099</span> <span class=\"mi\">2</span> <span class=\"mi\">1049</span> <span class=\"mi\">1</span> <span class=\"mi\">2098</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">1049</span> <span class=\"mi\">1</span> <span class=\"mi\">1049</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">1049</span><span class=\"o\">))</span>\n                      <span class=\"o\">(</span><span class=\"n\">norm_num.one_add</span> <span class=\"mi\">2098</span> <span class=\"mi\">2099</span> <span class=\"o\">(</span><span class=\"n\">norm_num.bit0_succ</span> <span class=\"mi\">1049</span><span class=\"o\">))</span>\n                      <span class=\"o\">(</span><span class=\"n\">norm_num.lt_one_bit0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"mi\">1</span><span class=\"o\">)))</span>\n                   <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">2345</span> <span class=\"mi\">4</span> <span class=\"mi\">586</span> <span class=\"mi\">1</span> <span class=\"mi\">2344</span>\n                      <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0_bit0</span> <span class=\"mi\">293</span> <span class=\"mi\">2</span> <span class=\"mi\">586</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">293</span> <span class=\"mi\">1</span> <span class=\"mi\">293</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">293</span><span class=\"o\">)))</span>\n                      <span class=\"o\">(</span><span class=\"n\">norm_num.one_add</span> <span class=\"mi\">2344</span> <span class=\"mi\">2345</span> <span class=\"o\">(</span><span class=\"n\">norm_num.bit0_succ</span> <span class=\"mi\">1172</span><span class=\"o\">))</span>\n                      <span class=\"o\">(</span><span class=\"n\">norm_num.lt_one_bit0</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">norm_num.le_one_bit0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n                   <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n                   <span class=\"o\">(</span><span class=\"n\">jacobi_sym_nat_mod_left</span> <span class=\"mi\">2345</span> <span class=\"mi\">2099</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n                      <span class=\"o\">(</span><span class=\"n\">jacobi_sym_even_odd₃</span> <span class=\"mi\">246</span> <span class=\"mi\">2099</span>\n                         <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">246</span> <span class=\"mi\">2</span> <span class=\"mi\">123</span> <span class=\"mi\">0</span> <span class=\"mi\">246</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">123</span> <span class=\"mi\">1</span> <span class=\"mi\">123</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">123</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">zero_add</span> <span class=\"mi\">246</span><span class=\"o\">)</span>\n                            <span class=\"o\">(</span><span class=\"n\">bit0_pos</span> <span class=\"n\">zero_lt_one'</span><span class=\"o\">))</span>\n                         <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">2099</span> <span class=\"mi\">8</span> <span class=\"mi\">262</span> <span class=\"mi\">3</span> <span class=\"mi\">2096</span>\n                            <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0_bit0</span> <span class=\"mi\">131</span> <span class=\"mi\">4</span> <span class=\"mi\">524</span>\n                               <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">131</span> <span class=\"mi\">2</span> <span class=\"mi\">262</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">131</span> <span class=\"mi\">1</span> <span class=\"mi\">131</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">131</span><span class=\"o\">))))</span>\n                            <span class=\"o\">(</span><span class=\"n\">norm_num.add_bit1_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">1048</span> <span class=\"mi\">1049</span> <span class=\"o\">(</span><span class=\"n\">norm_num.one_add</span> <span class=\"mi\">1048</span> <span class=\"mi\">1049</span> <span class=\"o\">(</span><span class=\"n\">norm_num.bit0_succ</span> <span class=\"mi\">524</span><span class=\"o\">)))</span>\n                            <span class=\"o\">(</span><span class=\"n\">norm_num.lt_bit1_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">4</span> <span class=\"o\">(</span><span class=\"n\">norm_num.sle_one_bit0</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">norm_num.le_one_bit0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"mi\">1</span><span class=\"o\">)))))</span>\n                         <span class=\"mi\">1</span>\n                         <span class=\"o\">(</span><span class=\"n\">jacobi_sym_qr₃</span> <span class=\"mi\">123</span> <span class=\"mi\">2099</span>\n                            <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">123</span> <span class=\"mi\">4</span> <span class=\"mi\">30</span> <span class=\"mi\">3</span> <span class=\"mi\">120</span>\n                               <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0_bit0</span> <span class=\"mi\">15</span> <span class=\"mi\">2</span> <span class=\"mi\">30</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">15</span> <span class=\"mi\">1</span> <span class=\"mi\">15</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">15</span><span class=\"o\">)))</span>\n                               <span class=\"o\">(</span><span class=\"n\">norm_num.add_bit1_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">60</span> <span class=\"mi\">61</span> <span class=\"o\">(</span><span class=\"n\">norm_num.one_add</span> <span class=\"mi\">60</span> <span class=\"mi\">61</span> <span class=\"o\">(</span><span class=\"n\">norm_num.bit0_succ</span> <span class=\"mi\">30</span><span class=\"o\">)))</span>\n                               <span class=\"o\">(</span><span class=\"n\">norm_num.lt_bit1_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">norm_num.sle_one_bit0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n                            <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">2099</span> <span class=\"mi\">4</span> <span class=\"mi\">524</span> <span class=\"mi\">3</span> <span class=\"mi\">2096</span>\n                               <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0_bit0</span> <span class=\"mi\">262</span> <span class=\"mi\">2</span> <span class=\"mi\">524</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0_bit0</span> <span class=\"mi\">131</span> <span class=\"mi\">1</span> <span class=\"mi\">131</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">131</span><span class=\"o\">)))</span>\n                               <span class=\"o\">(</span><span class=\"n\">norm_num.add_bit1_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">1048</span> <span class=\"mi\">1049</span>\n                                  <span class=\"o\">(</span><span class=\"n\">norm_num.one_add</span> <span class=\"mi\">1048</span> <span class=\"mi\">1049</span> <span class=\"o\">(</span><span class=\"n\">norm_num.bit0_succ</span> <span class=\"mi\">524</span><span class=\"o\">)))</span>\n                               <span class=\"o\">(</span><span class=\"n\">norm_num.lt_bit1_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">norm_num.sle_one_bit0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n                            <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n                            <span class=\"o\">(</span><span class=\"n\">jacobi_sym_nat_mod_left</span> <span class=\"mi\">2099</span> <span class=\"mi\">123</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n                               <span class=\"o\">(</span><span class=\"n\">jacobi_sym_even_odd₃</span> <span class=\"mi\">8</span> <span class=\"mi\">123</span>\n                                  <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">8</span> <span class=\"mi\">2</span> <span class=\"mi\">4</span> <span class=\"mi\">0</span> <span class=\"mi\">8</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0_bit0</span> <span class=\"mi\">2</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">zero_add</span> <span class=\"mi\">8</span><span class=\"o\">)</span>\n                                     <span class=\"o\">(</span><span class=\"n\">bit0_pos</span> <span class=\"n\">zero_lt_one'</span><span class=\"o\">))</span>\n                                  <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">123</span> <span class=\"mi\">8</span> <span class=\"mi\">15</span> <span class=\"mi\">3</span> <span class=\"mi\">120</span>\n                                     <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">15</span> <span class=\"mi\">4</span> <span class=\"mi\">60</span>\n                                        <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">15</span> <span class=\"mi\">2</span> <span class=\"mi\">30</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">15</span> <span class=\"mi\">1</span> <span class=\"mi\">15</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">15</span><span class=\"o\">))))</span>\n                                     <span class=\"o\">(</span><span class=\"n\">norm_num.add_bit1_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">60</span> <span class=\"mi\">61</span> <span class=\"o\">(</span><span class=\"n\">norm_num.one_add</span> <span class=\"mi\">60</span> <span class=\"mi\">61</span> <span class=\"o\">(</span><span class=\"n\">norm_num.bit0_succ</span> <span class=\"mi\">30</span><span class=\"o\">)))</span>\n                                     <span class=\"o\">(</span><span class=\"n\">norm_num.lt_bit1_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">4</span>\n                                        <span class=\"o\">(</span><span class=\"n\">norm_num.sle_one_bit0</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">norm_num.le_one_bit0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"mi\">1</span><span class=\"o\">)))))</span>\n                                  <span class=\"mi\">1</span>\n                                  <span class=\"o\">(</span><span class=\"n\">jacobi_sym_even_odd₃</span> <span class=\"mi\">4</span> <span class=\"mi\">123</span>\n                                     <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">4</span> <span class=\"mi\">2</span> <span class=\"mi\">2</span> <span class=\"mi\">0</span> <span class=\"mi\">4</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">zero_add</span> <span class=\"mi\">4</span><span class=\"o\">)</span>\n                                        <span class=\"o\">(</span><span class=\"n\">bit0_pos</span> <span class=\"n\">zero_lt_one'</span><span class=\"o\">))</span>\n                                     <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">123</span> <span class=\"mi\">8</span> <span class=\"mi\">15</span> <span class=\"mi\">3</span> <span class=\"mi\">120</span>\n                                        <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">15</span> <span class=\"mi\">4</span> <span class=\"mi\">60</span>\n                                           <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">15</span> <span class=\"mi\">2</span> <span class=\"mi\">30</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">15</span> <span class=\"mi\">1</span> <span class=\"mi\">15</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">15</span><span class=\"o\">))))</span>\n                                        <span class=\"o\">(</span><span class=\"n\">norm_num.add_bit1_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">60</span> <span class=\"mi\">61</span>\n                                           <span class=\"o\">(</span><span class=\"n\">norm_num.one_add</span> <span class=\"mi\">60</span> <span class=\"mi\">61</span> <span class=\"o\">(</span><span class=\"n\">norm_num.bit0_succ</span> <span class=\"mi\">30</span><span class=\"o\">)))</span>\n                                        <span class=\"o\">(</span><span class=\"n\">norm_num.lt_bit1_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">4</span>\n                                           <span class=\"o\">(</span><span class=\"n\">norm_num.sle_one_bit0</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">norm_num.le_one_bit0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"mi\">1</span><span class=\"o\">)))))</span>\n                                     <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n                                     <span class=\"o\">(</span><span class=\"n\">jacobi_sym_even_odd₃</span> <span class=\"mi\">2</span> <span class=\"mi\">123</span>\n                                        <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">2</span> <span class=\"mi\">2</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zero_add</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bit0_pos</span> <span class=\"n\">zero_lt_one'</span><span class=\"o\">))</span>\n                                        <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">123</span> <span class=\"mi\">8</span> <span class=\"mi\">15</span> <span class=\"mi\">3</span> <span class=\"mi\">120</span>\n                                           <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">15</span> <span class=\"mi\">4</span> <span class=\"mi\">60</span>\n                                              <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">15</span> <span class=\"mi\">2</span> <span class=\"mi\">30</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">15</span> <span class=\"mi\">1</span> <span class=\"mi\">15</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">15</span><span class=\"o\">))))</span>\n                                           <span class=\"o\">(</span><span class=\"n\">norm_num.add_bit1_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">60</span> <span class=\"mi\">61</span>\n                                              <span class=\"o\">(</span><span class=\"n\">norm_num.one_add</span> <span class=\"mi\">60</span> <span class=\"mi\">61</span> <span class=\"o\">(</span><span class=\"n\">norm_num.bit0_succ</span> <span class=\"mi\">30</span><span class=\"o\">)))</span>\n                                           <span class=\"o\">(</span><span class=\"n\">norm_num.lt_bit1_bit0</span> <span class=\"mi\">1</span> <span class=\"mi\">4</span>\n                                              <span class=\"o\">(</span><span class=\"n\">norm_num.sle_one_bit0</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">norm_num.le_one_bit0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"mi\">1</span><span class=\"o\">)))))</span>\n                                        <span class=\"mi\">1</span>\n                                        <span class=\"o\">(</span><span class=\"n\">jacobi_sym_qr₁</span> <span class=\"mi\">1</span> <span class=\"mi\">123</span>\n                                           <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">1</span> <span class=\"mi\">4</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">zero_mul</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">add_zero</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n                                              <span class=\"o\">(</span><span class=\"n\">norm_num.lt_one_bit0</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">norm_num.le_one_bit0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n                                           <span class=\"o\">(</span><span class=\"n\">norm_num.nat_mod</span> <span class=\"mi\">123</span> <span class=\"mi\">2</span> <span class=\"mi\">61</span> <span class=\"mi\">1</span> <span class=\"mi\">122</span> <span class=\"o\">(</span><span class=\"n\">norm_num.mul_bit0'</span> <span class=\"mi\">61</span> <span class=\"mi\">1</span> <span class=\"mi\">61</span> <span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"mi\">61</span><span class=\"o\">))</span>\n                                              <span class=\"o\">(</span><span class=\"n\">norm_num.one_add</span> <span class=\"mi\">122</span> <span class=\"mi\">123</span> <span class=\"o\">(</span><span class=\"n\">norm_num.bit0_succ</span> <span class=\"mi\">61</span><span class=\"o\">))</span>\n                                              <span class=\"o\">(</span><span class=\"n\">norm_num.lt_one_bit0</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"mi\">1</span><span class=\"o\">)))</span>\n                                           <span class=\"mi\">1</span>\n                                           <span class=\"o\">(</span><span class=\"n\">jacobi_sym_nat_one_right</span> <span class=\"mi\">123</span><span class=\"o\">)))))))))))))</span>\n       <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"n\">eq.refl</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n      <span class=\"o\">(</span><span class=\"n\">eq_true_intro</span> <span class=\"o\">(</span><span class=\"n\">eq.refl</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)))))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>\n<p>It's not that deeply nested (much less so than the primality proof term I was referring to).</p>",
        "id": 297030747,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662235183
    },
    {
        "content": "<p>Yeah, looks like ~10 nestings of <code>jacobi_XYZ</code></p>",
        "id": 297030882,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662235271
    },
    {
        "content": "<p>The term for the large (8-digit) numbers has nesting depth 30-40.</p>",
        "id": 297030970,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662235351
    },
    {
        "content": "<p>I have now a new version (of the <code>norm_num</code> extension) that has no problems with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">jacobi_sym_nat</span> <span class=\"mi\">102334155</span> <span class=\"mi\">165580141</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>say, where <code>jacobi_sym_nat</code> is a version of the Jacobi symbol restricted to natural numbers.<br>\nHowever, the conversion from the Jacobi symbol to the restricted version still has a problem. This is done via</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">jacobi_sym</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">jacobi_sym_nat</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">%</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>and the issue seems to be some problem with matching types (along the lines of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">100000</span> <span class=\"bp\">%</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>which runs into the deep recursion problem). I suspect some <code>nat</code> vs <code>int</code> problem.</p>\n<p>Here is a question: How do I produce a proof of <code>(a : int) = b</code> within the framework of the <code>norm_num</code> machinery when I have a numeral expression <code>ea</code> for <code>a : nat</code> and a numeral expression <code>eb</code> for <code>b : int</code> (and of course <code>a</code> and <code>b</code> are equal)? <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 297135869,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662320955
    },
    {
        "content": "<p>use <code>prove_nat_uncast</code></p>",
        "id": 297136234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662321240
    },
    {
        "content": "<p>The relevant part of my code looks like the following.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">jacobi_sym_mod_left</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">%</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">ab</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"n\">jacobi_sym_nat</span> <span class=\"n\">ab.to_nat</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">jacobi_sym</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n\n<span class=\"sd\">/-- This evaluates `r := jacobi_sym a b` and produces a proof term for the equality.</span>\n<span class=\"sd\">This is done by reducing to `r := jacobi_sym_nat (a % b) b`. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">prove_jacobi_sym</span> <span class=\"o\">:</span>\n  <span class=\"n\">instance_cache</span> <span class=\"bp\">→</span> <span class=\"n\">instance_cache</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span>\n    <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">instance_cache</span> <span class=\"bp\">×</span> <span class=\"n\">instance_cache</span> <span class=\"bp\">×</span> <span class=\"n\">expr</span> <span class=\"bp\">×</span> <span class=\"n\">expr</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">zc</span> <span class=\"n\">nc</span> <span class=\"n\">ea</span> <span class=\"n\">eb</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">ea.to_int</span><span class=\"o\">,</span>\n  <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">eb.to_nat</span><span class=\"o\">,</span>\n  <span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"c1\">-- deal with simple cases right away</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">jacobi_sym_zero_right</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mk_app</span> <span class=\"o\">[</span><span class=\"n\">ea</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">jacobi_sym_one_right</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mk_app</span> <span class=\"o\">[</span><span class=\"n\">ea</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"c1\">-- Now `1 &lt; b`. Compute `jacobi_sym_nat (a % b) b` instead.</span>\n    <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">eb'</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">zc.of_int</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">amb</span><span class=\"o\">,</span> <span class=\"n\">phab</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">norm_num.prove_div_mod</span> <span class=\"n\">zc</span> <span class=\"n\">ea</span> <span class=\"n\">eb'</span> <span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"c1\">-- compute `a % b`</span>\n    <span class=\"k\">let</span> <span class=\"n\">a'</span> <span class=\"o\">:=</span> <span class=\"n\">amb.to_int</span><span class=\"o\">,</span>\n    <span class=\"k\">match</span> <span class=\"n\">a'</span> <span class=\"k\">with</span> <span class=\"c1\">-- not sure why this is necessary, but `int.to_nat a'` gives an error.</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">failed</span> <span class=\"c1\">-- we'll never get here</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">aa</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n      <span class=\"o\">(</span><span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"n\">amb'</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">nc.of_nat</span> <span class=\"o\">(</span><span class=\"n\">int.to_nat</span> <span class=\"n\">aa</span><span class=\"o\">),</span> <span class=\"c1\">-- `a % b` as a natural number</span>\n      <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"n\">er</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">prove_jacobi_sym_nat</span> <span class=\"n\">zc</span> <span class=\"n\">nc</span> <span class=\"n\">amb'</span> <span class=\"n\">eb</span><span class=\"o\">,</span> <span class=\"c1\">-- compute `jacobi_sym_nat (a % b) b`</span>\n      <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"n\">er</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">jacobi_sym_mod_left</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mk_app</span> <span class=\"o\">[</span><span class=\"n\">ea</span><span class=\"o\">,</span> <span class=\"n\">eb</span><span class=\"o\">,</span> <span class=\"n\">amb</span><span class=\"o\">,</span> <span class=\"n\">er</span><span class=\"o\">,</span> <span class=\"n\">phab</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">])</span>\n    <span class=\"kd\">end</span>\n  <span class=\"kd\">end</span>\n\n\n<span class=\"sd\">/-- This is the `norm_num` plug-in that evaluates Jacobi symbols. -/</span>\n<span class=\"kd\">@[norm_num]</span> <span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">eval_jacobi_sym</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"bp\">×</span> <span class=\"n\">expr</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">jacobi_sym</span> <span class=\"bp\">%%</span><span class=\"n\">ea</span> <span class=\"bp\">%%</span><span class=\"n\">eb</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"n\">zc</span> <span class=\"bp\">←</span> <span class=\"n\">mk_instance_cache</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">ℤ</span><span class=\"o\">),</span>\n    <span class=\"n\">nc</span> <span class=\"bp\">←</span> <span class=\"n\">mk_instance_cache</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"n\">prod.snd</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.snd</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">prove_jacobi_sym</span> <span class=\"n\">zc</span> <span class=\"n\">nc</span> <span class=\"n\">ea</span> <span class=\"n\">eb</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">failed</span>\n</code></pre></div>",
        "id": 297136284,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662321252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297136234\">said</a>:</p>\n<blockquote>\n<p>use <code>prove_nat_uncast</code></p>\n</blockquote>\n<p>I tried that, but it didn't help. Maybe I should try again...</p>",
        "id": 297136299,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662321276
    },
    {
        "content": "<p>(The code has changed a bit since then...)</p>",
        "id": 297136310,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662321293
    },
    {
        "content": "<p>your lemma should look something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">jacobi_sym_mod_left</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">%</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">ab</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ab</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"n\">jacobi_sym_nat</span> <span class=\"n\">c</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">jacobi_sym</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>and then generate <code>c</code> and <code>hc</code> using <code>prove_nat_uncast</code> applied to <code>ab</code></p>",
        "id": 297136477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662321474
    },
    {
        "content": "<p>I had tried something like this, but that was before I re-wrote the <code>jacobi_sym_nat</code> part. I'll see if it works now...</p>",
        "id": 297136619,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662321574
    },
    {
        "content": "<p>With this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">prove_jacobi_sym</span> <span class=\"o\">:</span>\n  <span class=\"n\">instance_cache</span> <span class=\"bp\">→</span> <span class=\"n\">instance_cache</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span>\n    <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">instance_cache</span> <span class=\"bp\">×</span> <span class=\"n\">instance_cache</span> <span class=\"bp\">×</span> <span class=\"n\">expr</span> <span class=\"bp\">×</span> <span class=\"n\">expr</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">zc</span> <span class=\"n\">nc</span> <span class=\"n\">ea</span> <span class=\"n\">eb</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">ea.to_int</span><span class=\"o\">,</span>\n  <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">eb.to_nat</span><span class=\"o\">,</span>\n  <span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"c1\">-- deal with simple cases right away</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">jacobi_sym_zero_right</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mk_app</span> <span class=\"o\">[</span><span class=\"n\">ea</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">jacobi_sym_one_right</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mk_app</span> <span class=\"o\">[</span><span class=\"n\">ea</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"c1\">-- Now `1 &lt; b`. Compute `jacobi_sym_nat (a % b) b` instead.</span>\n    <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">eb'</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">zc.of_int</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">amb</span><span class=\"o\">,</span> <span class=\"n\">phab</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">norm_num.prove_div_mod</span> <span class=\"n\">zc</span> <span class=\"n\">ea</span> <span class=\"n\">eb'</span> <span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"c1\">-- compute `a % b`</span>\n    <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"n\">amb'</span><span class=\"o\">,</span> <span class=\"n\">phab'</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">norm_num.prove_nat_uncast</span> <span class=\"n\">zc</span> <span class=\"n\">nc</span> <span class=\"n\">amb</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"n\">er</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">prove_jacobi_sym_nat</span> <span class=\"n\">zc</span> <span class=\"n\">nc</span> <span class=\"n\">amb'</span> <span class=\"n\">eb</span><span class=\"o\">,</span> <span class=\"c1\">-- compute `jacobi_sym_nat (a % b) b`</span>\n    <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"n\">er</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">jacobi_sym_mod_left</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mk_app</span> <span class=\"o\">[</span><span class=\"n\">ea</span><span class=\"o\">,</span> <span class=\"n\">eb</span><span class=\"o\">,</span> <span class=\"n\">amb'</span><span class=\"o\">,</span> <span class=\"n\">amb</span><span class=\"o\">,</span> <span class=\"n\">er</span><span class=\"o\">,</span> <span class=\"n\">phab</span><span class=\"o\">,</span> <span class=\"n\">phab'</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">])</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>it still gives me \"deep recursion\" on larger numbers. Should I do something different to obtain <code>eb'</code>?</p>",
        "id": 297137394,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662322174
    },
    {
        "content": "<p>I really have no clue what the problem might be. The types of the sub-terms of the proof term that <code>norm_num</code> generates seem to match the signature of (the new version of) <code>jacobi_sym_mod_left</code>.</p>",
        "id": 297138098,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662322833
    },
    {
        "content": "<p>I have some idea how to work around the problem, but it is getting too late today...</p>",
        "id": 297141949,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662326736
    },
    {
        "content": "<p>Your <code>a % b = ab</code> subgoal has coercions in it</p>",
        "id": 297143226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662328278
    },
    {
        "content": "<p>it should either be all-int or all-nat</p>",
        "id": 297143238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662328290
    },
    {
        "content": "<p>it's hard to write exact examples without the MWE</p>",
        "id": 297143253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662328313
    },
    {
        "content": "<p>what is the type of <code>jacobi_sym</code> and <code>jacobi_sym_nat</code>?</p>",
        "id": 297143317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662328355
    },
    {
        "content": "<p>You have to be really careful to not have type errors between ints and coerced nats, because they cause kernel timeouts</p>",
        "id": 297143502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662328563
    },
    {
        "content": "<p>OK; here is an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> that works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.norm_num</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.zify</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">norm_num</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">%</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_nat</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test_def_zero</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">test</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test_def_pos</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">test</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">%</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">test</span><span class=\"o\">],</span>\n  <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">false.elim</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">int.to_nat_of_nonneg</span> <span class=\"o\">(</span><span class=\"n\">int.mod_nonneg</span> <span class=\"n\">a</span> <span class=\"n\">_</span><span class=\"o\">)),</span>\n  <span class=\"n\">exact_mod_cast</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test_nn</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb₀</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b'</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ab</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">%</span> <span class=\"n\">b'</span> <span class=\"bp\">=</span> <span class=\"n\">ab</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">test</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">zify</span><span class=\"o\">,</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">test_def_pos</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hb₀</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">prove_test</span> <span class=\"o\">:</span> <span class=\"n\">instance_cache</span> <span class=\"bp\">→</span> <span class=\"n\">instance_cache</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span>\n  <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">instance_cache</span> <span class=\"bp\">×</span> <span class=\"n\">instance_cache</span> <span class=\"bp\">×</span> <span class=\"n\">expr</span> <span class=\"bp\">×</span> <span class=\"n\">expr</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">zc</span> <span class=\"n\">nc</span> <span class=\"n\">ea</span> <span class=\"n\">eb</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">b</span> <span class=\"bp\">←</span> <span class=\"n\">eb.to_nat</span><span class=\"o\">,</span>\n  <span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">test_def_zero</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mk_app</span> <span class=\"o\">[</span><span class=\"n\">ea</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"o\">(</span><span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"n\">phb</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">norm_num.prove_ne</span> <span class=\"n\">nc</span> <span class=\"n\">eb</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"c1\">-- proof of `b ≠ 0`</span>\n    <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">eb'</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">zc.of_int</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"n\">eb₁</span><span class=\"o\">,</span> <span class=\"n\">pb'</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">norm_num.prove_nat_uncast</span> <span class=\"n\">zc</span> <span class=\"n\">nc</span> <span class=\"n\">eb'</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">amb</span><span class=\"o\">,</span> <span class=\"n\">phab</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">norm_num.prove_div_mod</span> <span class=\"n\">zc</span> <span class=\"n\">ea</span> <span class=\"n\">eb'</span> <span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"c1\">-- compute `a % b`</span>\n    <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"n\">amb'</span><span class=\"o\">,</span> <span class=\"n\">phab'</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">norm_num.prove_nat_uncast</span> <span class=\"n\">zc</span> <span class=\"n\">nc</span> <span class=\"n\">amb</span><span class=\"o\">,</span>\n    <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">zc</span><span class=\"o\">,</span> <span class=\"n\">nc</span><span class=\"o\">,</span> <span class=\"n\">amb'</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">test_nn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mk_app</span> <span class=\"o\">[</span><span class=\"n\">ea</span><span class=\"o\">,</span> <span class=\"n\">eb₁</span><span class=\"o\">,</span> <span class=\"n\">amb'</span><span class=\"o\">,</span> <span class=\"n\">amb</span><span class=\"o\">,</span> <span class=\"n\">eb'</span><span class=\"o\">,</span> <span class=\"n\">phb</span><span class=\"o\">,</span> <span class=\"n\">pb'</span><span class=\"o\">,</span> <span class=\"n\">phab'</span><span class=\"o\">,</span> <span class=\"n\">phab</span><span class=\"o\">])</span>\n  <span class=\"kd\">end</span>\n\n<span class=\"kd\">@[norm_num]</span> <span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">eval_test</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"bp\">×</span> <span class=\"n\">expr</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">test</span> <span class=\"bp\">%%</span><span class=\"n\">ea</span> <span class=\"bp\">%%</span><span class=\"n\">eb</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"n\">nc</span> <span class=\"bp\">←</span> <span class=\"n\">mk_instance_cache</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">),</span>\n    <span class=\"n\">zc</span> <span class=\"bp\">←</span> <span class=\"n\">mk_instance_cache</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">ℤ</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"n\">prod.snd</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.snd</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">prove_test</span> <span class=\"n\">zc</span> <span class=\"n\">nc</span> <span class=\"n\">ea</span> <span class=\"n\">eb</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">failed</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">test</span> <span class=\"mi\">3</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">test</span> <span class=\"mi\">100000000</span> <span class=\"mi\">33333333</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">norm_num</span><span class=\"o\">,}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">norm_num</span>\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n</code></pre></div>\n<p>Using the same modification (i.e., introducing <code>b'</code> and the proof that <code>(b : int) = b'</code>) then also works in the Jacobi symbol setting. Thanks! <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 297189360,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662368338
    },
    {
        "content": "<p>you shouldn't need to use <code>of_int</code> there</p>",
        "id": 297192028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662369526
    },
    {
        "content": "<p><code>prove_nat_uncast</code> returns the new expression</p>",
        "id": 297192085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662369549
    },
    {
        "content": "<p>Oh nvm, I see you are using <code>prove_nat_uncast</code> \"backwards\" (i.e. you are actually computing a cast and not an uncast). That hasn't come up before but I guess you need it to evaluate <code>int.mod</code> on nats</p>",
        "id": 297192692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662369794
    },
    {
        "content": "<p>Yes, <code>int.mod</code> on an <code>int</code> and a <code>nat</code> seems to be causing the problems here.</p>",
        "id": 297196758,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662371528
    },
    {
        "content": "<p>I have now PRed the Jacobi symbol code again: <a href=\"https://github.com/leanprover-community/mathlib/pull/16395\">#16395</a><br>\n<span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span></p>",
        "id": 297277072,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662411241
    },
    {
        "content": "<p>Next up: a <code>norm_num</code> extension that computes Jacobi (and Legendre) symbols.<br>\nThis can now also deal with large numbers; the problems have been resolved thanks to <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>'s help; see the discussion above.</p>",
        "id": 297277154,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662411304
    },
    {
        "content": "<p>On my machine, according to the profiler,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"mi\">58378362899022564339483801989973056405585914719065</span> <span class=\"bp\">|</span>\n           <span class=\"mi\">53974350278769849773003214636618718468638750007307</span><span class=\"o\">]</span><span class=\"bp\">ⱼ</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>takes less than 0.4 seconds.</p>",
        "id": 297468840,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662491059
    },
    {
        "content": "<p>Here is a question regarding notation (see the comments in the file added in <a href=\"https://github.com/leanprover-community/mathlib/pull/16395\">#16395</a>).</p>\n<p>After defining notation <code>[a | b]ⱼ</code> for the Jacobi symbol, it seems that, at least in some contexts, list notation <code>[x, y, z]</code> does not work anymore. (It does in tactic mode, and square brackets work for instance arguments, though.) This surprises me, since Lean has no problems with differentiating notations like <code>{1, 2, 3}</code>, ¸{x : nat | odd x}<code> and </code>{x : nat // odd x}`, which looks like a similar situation to me.</p>\n<ul>\n<li>Can somebody explain what the problem may be?</li>\n<li>Is there a fix that allows using both Jacobi symbol and list notation at the same time?</li>\n<li>If not, my suggestion would be to switch to <code>ⱼ( a | b )</code> instead (round parens are closer to the usual notation), even though I don't like the <code>ⱼ</code> on the left very much. But at least it does not seem to lead to conflilcts...</li>\n<li>Alternatives?</li>\n</ul>",
        "id": 297470003,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662491488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297470003\">said</a>:</p>\n<blockquote>\n<p>This surprises me, since Lean has no problems with differentiating notations like <code>{1, 2, 3}</code>, ¸<code>{x : nat | odd x}</code> and <code>{x : nat // odd x}</code>, which looks like a similar situation to me.</p>\n</blockquote>\n<p>Actually, lean can't handle that either. All notations starting with <code>{</code> are built in and not implemented via the usual notation framework.</p>",
        "id": 297470228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662491583
    },
    {
        "content": "<p>Does this mean that the opening part of a bracket-like notation has to be unique?</p>",
        "id": 297470302,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662491618
    },
    {
        "content": "<p>yes, I would recommend that</p>",
        "id": 297470335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662491636
    },
    {
        "content": "<p>OK; then I'll change to <code>ⱼ( a | b )</code> as per my proposal above. Unless somebody has a better suggestion.</p>",
        "id": 297470506,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662491687
    },
    {
        "content": "<p>How about just <code>J(a | b)</code>?</p>",
        "id": 297470529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662491697
    },
    {
        "content": "<p>OK, let's have a poll. What should the notation for the Jacobi symbol be?</p>",
        "id": 297470660,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662491741
    },
    {
        "content": "<p>isn't the jacobi symbol usually written like the legendre symbol? (i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">(</mo><mstyle displaystyle=\"true\" scriptlevel=\"0\"><mfrac><mi>a</mi><mi>b</mi></mfrac></mstyle><mo fence=\"true\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\left(\\dfrac{a}{b}\\right)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.836em;vertical-align:-0.686em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">(</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1076em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">)</span></span></span></span></span></span>)</p>",
        "id": 297470770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662491775
    },
    {
        "content": "<p>Yes. But this is hard to replicate in unicode.</p>",
        "id": 297471197,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662491942
    },
    {
        "content": "<p>maybe something more like a division e.g. <code>a /_j b</code></p>",
        "id": 297471299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662491992
    },
    {
        "content": "<p>/poll What should be the notation for the Jacobi symbol?<br>\nⱼ( a | b )<br>\nJ(a | b)<br>\na /_j b</p>",
        "id": 297471477,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662492055
    },
    {
        "content": "<p><strong>NOTE</strong>: Everything starting with just <code>(</code> or <code>[</code> will not work. See the discussion above and below.</p>\n<p>I'd prefer to have some kind of brackets.</p>",
        "id": 297471572,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662492090
    },
    {
        "content": "<p>The symbol has not much to do with division, other than that in a way, we consider <code>a</code> modulo <code>b</code>.</p>",
        "id": 297471838,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662492183
    },
    {
        "content": "<p><code>( a | b )ⱼ</code> will run into even worse problems than <code>[a | b]ⱼ</code>, since round parentheses are ubiquitous...</p>",
        "id": 297472008,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662492241
    },
    {
        "content": "<p>it's not even legal</p>",
        "id": 297472080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662492253
    },
    {
        "content": "<p>Oh, that's a shame.</p>",
        "id": 297472097,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662492262
    },
    {
        "content": "<p>(That was what I tried at the very beginning <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> )</p>",
        "id": 297472158,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662492285
    },
    {
        "content": "<p>I suppose Matt's suggestion <code>(a |_j b) </code> is also illegal</p>",
        "id": 297472289,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662492336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297471838\">said</a>:</p>\n<blockquote>\n<p>The symbol has not much to do with division, other than that in a way, we consider <code>a</code> modulo <code>b</code>.</p>\n</blockquote>\n<p>Sure, but you are asking about the notation. Maybe you should tell this to Legendre</p>",
        "id": 297472464,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662492386
    },
    {
        "content": "<p>Do we have notation for Legendre?</p>",
        "id": 297472509,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662492402
    },
    {
        "content": "<p>not that I can see</p>",
        "id": 297472535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662492416
    },
    {
        "content": "<p>No (other than <code>legendre_sym</code>).</p>",
        "id": 297472551,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662492421
    },
    {
        "content": "<p>Maybe we can find some fancy unicode parens to use for both Legendre and Jacobi (with an additional subscript <code>j</code>).</p>",
        "id": 297472765,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662492486
    },
    {
        "content": "<p>FWIW I used <code>/_L</code> for the legendre / jacobi / kronecker symbol in <a href=\"https://us.metamath.org/mpeuni/df-lgs.html\">metamath</a></p>",
        "id": 297472828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662492506
    },
    {
        "content": "<p>I think that <code>?(a | b)</code> looks like a horizontal version of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">(</mo><mfrac><mi>a</mi><mi>b</mi></mfrac><mo fence=\"true\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\left(\\frac{a}{b}\\right)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2em;vertical-align:-0.35em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">(</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">)</span></span></span></span></span></span>, that's why I'm suggesting the vertical bar.</p>",
        "id": 297472829,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662492506
    },
    {
        "content": "<p>What's the unicode analogue of <a href=\"https://detexify.kirelabs.org/classify.html\">https://detexify.kirelabs.org/classify.html</a> ?</p>",
        "id": 297472935,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662492555
    },
    {
        "content": "<p><a href=\"https://shapecatcher.com\">https://shapecatcher.com</a> ?</p>",
        "id": 297473050,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1662492603
    },
    {
        "content": "<p>note that the vertical bar is <em>also</em> taken for a bunch of things in lean</p>",
        "id": 297473075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662492604
    },
    {
        "content": "<p>which is why dvd uses <code>\\|</code> instead of <code>|</code></p>",
        "id": 297473148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662492628
    },
    {
        "content": "<p>Anyway, <code>J(a | b)</code> doesn't seem to give trouble, so I'd be willing to use that.</p>",
        "id": 297473526,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662492774
    },
    {
        "content": "<p><code>⟮ a | b ⟯</code><br>\nThose are unicode characters 0x27EE and 0x27EF</p>",
        "id": 297473568,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662492796
    },
    {
        "content": "<p>Does <code>_j</code> in choices means <code>ⱼ</code>?</p>",
        "id": 297473579,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1662492803
    },
    {
        "content": "<p>Or they are different things?</p>",
        "id": 297473755,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1662492880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297473568\">said</a>:</p>\n<blockquote>\n<p><code>⟮ a | b ⟯</code><br>\nThose are unicode characters 0x27EE and 0x27EF</p>\n</blockquote>\n<p>Then we'd need an easy way of typing them in.</p>",
        "id": 297473767,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662492887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297473767\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297473568\">said</a>:</p>\n<blockquote>\n<p><code>⟮ a | b ⟯</code><br>\nThose are unicode characters 0x27EE and 0x27EF</p>\n</blockquote>\n<p>Then we'd need an easy way of typing them in.</p>\n</blockquote>\n<p>Right... but it's fairly easy to add symbols to the vscode extension</p>",
        "id": 297473828,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662492914
    },
    {
        "content": "<p>For example we did a similar trick for the Lie bracket <br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/3c227fc0bf65ba9eb3048eb7845f8ce2a6084d45/src/data/bracket.lean#L37\">https://github.com/leanprover-community/mathlib/blob/3c227fc0bf65ba9eb3048eb7845f8ce2a6084d45/src/data/bracket.lean#L37</a></p>",
        "id": 297473968,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662492971
    },
    {
        "content": "<p>We might be the only people in the world who use <code>⁅</code></p>",
        "id": 297473993,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662492986
    },
    {
        "content": "<p><code>⟮</code> is already fairly overloaded in mathlib, I see it used for field extensions and manifold sets</p>",
        "id": 297474075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662493037
    },
    {
        "content": "<p>VSCode says <code>type ⟮ using \\([</code> and `type ⟯ using \\]).</p>",
        "id": 297474139,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662493066
    },
    {
        "content": "<p>There are other nice looking parens as well</p>",
        "id": 297474166,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662493082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol/near/297474075\">said</a>:</p>\n<blockquote>\n<p><code>⟮</code> is already fairly overloaded in mathlib, I see it used for field extensions and manifold sets</p>\n</blockquote>\n<p>That may not be a big problem, as the notation is localized and does not have to be used.</p>",
        "id": 297474227,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662493091
    },
    {
        "content": "<p><a href=\"http://shapecatcher.com/unicode/info/10647\">http://shapecatcher.com/unicode/info/10647</a></p>",
        "id": 297474258,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662493105
    },
    {
        "content": "<p>not that this is a big problem since the notation is localized, but I guess it means you can't use jacobi symbols and field extensions at the same time</p>",
        "id": 297474284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662493118
    },
    {
        "content": "<p>You can certainly use the symbols, but you'd have to write <code>jacobi_sym a b</code> instead.</p>",
        "id": 297474408,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662493175
    },
    {
        "content": "<p>personally I prefer to just use no notation here. It's not like this is an algebraic operation that gets deeply nested - most equations only use the symbol once or twice</p>",
        "id": 297474602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662493226
    },
    {
        "content": "<p>and using a notation means that people have to look it up if it's not super obvious</p>",
        "id": 297474708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662493255
    },
    {
        "content": "<p>and <code>[a | b],</code> is certainly not obvious</p>",
        "id": 297474773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662493273
    },
    {
        "content": "<p>So you vote for \"nothing\" in the poll above?</p>",
        "id": 297474888,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662493314
    },
    {
        "content": "<p>I could, but I'm not sufficiently invested in this part of the library to care so I'll abstain</p>",
        "id": 297475124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662493383
    },
    {
        "content": "<p>I suppose the notation situation would be (theoretically) better with Lean4? If so, we could leave it as \"nothing\" for now, with a \"plan\" to do something about it after the transition to Lean4?</p>",
        "id": 297475896,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662493684
    },
    {
        "content": "<p>yes, lean 4's parser allows for backtracking so <code>[a | b]</code> is theoretically possible (although it is probably ambiguous with other stuff)</p>",
        "id": 297476332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662493865
    },
    {
        "content": "<p>Maybe I'll wait to see if there are more votes, and if no clear majority (for a legal notation) emerges, I'll remove the notation for the time being.</p>",
        "id": 297476370,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662493883
    },
    {
        "content": "<p>now we just need to get it to support</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>       <span class=\"o\">[</span> <span class=\"n\">a</span> <span class=\"o\">]</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"c1\">---]</span>\n       <span class=\"o\">[</span> <span class=\"n\">b</span> <span class=\"o\">]</span>\n</code></pre></div>",
        "id": 297476636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662493994
    },
    {
        "content": "<p>Isn't there some ITP that lets you do stuff like this?</p>",
        "id": 297476718,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662494029
    },
    {
        "content": "<p>I have a vague recollection of such but I couldn't say which</p>",
        "id": 297476845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1662494071
    },
    {
        "content": "<p>If you make <code>a /_j b</code> the notation, then you can also write it <code>(a /_j b)</code>, right?</p>",
        "id": 297535296,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662535733
    },
    {
        "content": "<p>And it makes the parentheses mean the same thing as elsewhere, which sounds desirable.</p>",
        "id": 297535346,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662535760
    },
    {
        "content": "<p>Ha ha you could also give it super high binding power which would force people to use brackets</p>",
        "id": 297536905,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1662536465
    },
    {
        "content": "<p>I would think that super <em>high</em> binding power would usually make brackets unnecessary.</p>",
        "id": 297553322,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662543497
    },
    {
        "content": "<p>We should also think of the (quadratic) Hilbert symbol, which should be something like <code>(a b | v)</code> or perhaps <code>(a, b | v)</code> with some decorations to make the parser happy.</p>",
        "id": 297553720,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662543641
    },
    {
        "content": "<p><code>J(a | b)</code> and <code>H(a b | v)</code> would be reasonable.</p>",
        "id": 297553758,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662543658
    },
    {
        "content": "<p>I'm less convinced by <code>(a /ⱼ b)</code> and <code>(a b /ₕ v)</code> or <code>(a |ⱼ b)</code> and <code>(a b |ₕ v)</code>, but am willing to get more convinced...</p>",
        "id": 297554121,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662543797
    },
    {
        "content": "<p>I think In Lean 3 <code>H(a b | v)</code> is not possible. You will need a <code>,</code>.</p>",
        "id": 297613830,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662564437
    },
    {
        "content": "<p>A comma is fine or perhaps even better, since the math notation is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">(</mo><mfrac><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi></mrow><mi>v</mi></mfrac><mo fence=\"true\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\left(\\frac{a,b}{v}\\right)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.8em;vertical-align:-0.65em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">(</span></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9322em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4461em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">a</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\">b</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">)</span></span></span></span></span></span>.</p>",
        "id": 297616161,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662565149
    },
    {
        "content": "<p>I have now changed notation to <code>J(a | b)</code>. It is easy to read (and type!) and unlikely to lead to confusion.</p>\n<p>Perhaps somebody can look through <a href=\"https://github.com/leanprover-community/mathlib/pull/16395\">#16395</a> carefully and check that it is OK for merging. <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span></p>",
        "id": 297786970,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662644752
    },
    {
        "content": "<p>I am unfortunately (for all practical purposes) off-line till Monday.</p>",
        "id": 297791410,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662646360
    },
    {
        "content": "<p>I've left a couple of small comments, but LGTM!</p>",
        "id": 297792676,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1662646848
    },
    {
        "content": "<p>I have now prepared a PR that moves <code>zmod.{legendre|jacobi}_sym*</code> to the root namespace: <a href=\"https://github.com/leanprover-community/mathlib/pull/16461\">#16461</a>.<br>\nTo disambiguate with the version of QR for the Jacobi symbol, I have moved <code>zmod.quadratic_reciprocity*</code> to <code>legendre_sym_quadratic_reciprocity*</code>.<br>\nThis also moves the results related to Gauss' and Eisenstein's lemmas from <code>legendre_symbol.</code> to <code>zmod.</code>.<br>\n<span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span></p>",
        "id": 298240162,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662896733
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> suggested, and I had myself also thought about it, to change <code>{legendre|jacobi}_sym_stuff</code> to <code>{legendre|jacobi}_sym.stuff</code>, i.e., to move the various lemmas into a namespace <code>legendre_sym</code> or <code>jacobi_sym</code>. One possible problem is that replacing <code>jacobi_sym_two</code> with <code>jacobi_sym.two</code> (there are a few other similar names) looks a bit strange, in particular if locally referred to simply as <code>two</code>. I would propose changing this to <code>jacobi_sym.value_at_two</code>; then the move should be fine and I'm inclined to do it. But I'd like to put this up for discussion first, so please comment! (Here or at <a href=\"https://github.com/leanprover-community/mathlib/pull/16461\">#16461</a>.)</p>",
        "id": 298388204,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662991519
    },
    {
        "content": "<p>You can use <code>protected lemma</code> to ensure that a specific lemma with an overly general name (when not namespaced) can't be referred to without the full prefix</p>",
        "id": 298389181,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1662991817
    },
    {
        "content": "<p>Alternatives could be <code>jacobi_sym_two</code>, avoiding namespacing or <code>jacobi_sym.at_two</code>, shorter than <code>value_at_two</code> and in the namespace.</p>",
        "id": 298389372,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662991892
    },
    {
        "content": "<p>I think I'll mostly go with Damiano's suggestion.</p>",
        "id": 298538574,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663058895
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/16461\">#16461</a> has now been merged (thanks <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span>), so the next step is to PR the <code>norm_num</code> extension that (provably) computes the value of the Jacobi (and Legendre) symbol. This is about 500 lines of code, so it should go in a separate file. Would <code>number_theory.legendre_symbol.norm_num</code> be a reasonable name for that file?</p>",
        "id": 298768851,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663161391
    },
    {
        "content": "<p>Since nobody complained, I've named the file as suggested. See <a href=\"https://github.com/leanprover-community/mathlib/pull/16519\">#16519</a>. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span></p>",
        "id": 298934904,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663235203
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> has approved the PR. Should somebody else look at it before it can be merged?</p>",
        "id": 299170969,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663338154
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> thanks!</p>",
        "id": 299222044,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663354098
    },
    {
        "content": "<p>I noticed that after changing the notation to <code>J(a | b)</code>, the parenthetical remark \"(Unfortunately, there is no subscript \"J\" in unicode.)\" in the docstring for the notation no longer makes sense. I've PRed a fix (<a href=\"https://github.com/leanprover-community/mathlib/pull/16541\">#16541</a>). Can somebody merge it after it has passed CI? <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span></p>",
        "id": 299409213,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663492757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> thanks!</p>",
        "id": 299419275,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663499275
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> Can you please check if <a href=\"https://github.com/leanprover-community/mathlib/blob/3b4e9d58eae1978db9bd73d4c5f9c90fd4bb65ee/src/number_theory/legendre_symbol/norm_num.lean#L235\">this</a> is still needed with latest master? It's possible that <a href=\"https://github.com/leanprover-community/mathlib/pull/16349\">#16349</a> fixes it.</p>",
        "id": 300785080,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1664194546
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> Did you mean <a href=\"https://github.com/leanprover-community/mathlib/pull/16463\">#16463</a>? <a href=\"https://github.com/leanprover-community/mathlib/pull/16349\">#16349</a>  was closed, but refers to it. Anyway, it looks like with the current state of affairs, this instance is no longer needed. So I'm removing it in <a href=\"https://github.com/leanprover-community/mathlib/pull/16659\">#16659</a>.</p>",
        "id": 300868162,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1664214290
    },
    {
        "content": "<p>Yes sorry. Thanks</p>",
        "id": 300868256,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1664214331
    },
    {
        "content": "<p>I am away from the computer, but feel free to request my review</p>",
        "id": 300868846,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1664214517
    },
    {
        "content": "<p>Done.</p>",
        "id": 300869711,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1664214810
    }
]
[
    {
        "content": "<p>I've been stuck on a big proof for surreal numbers for quite some time now.</p>\n<p>I'm trying to prove a complicated theorem <code>f(x, y)</code> for <code>{x y : pgames}</code> by recursion.<br>\nI end up having to use statements like <code>f(x - xL i, yL j)</code>, <code>f(xL k, yR l - y)</code>,  etc in the proof where <code>xL _</code> are the left moves of <code>x</code> and <code>xR _</code> are the right moves of <code>x</code> and similarly for <code>y</code>.  Note that the \"depth\" always increases and there are no terms of the form <code>f(x - xL i, y)</code> so mathematically the recursion is fine.</p>\n<p>Lean is unable to prove well-founded recursion for this.  I tried doing a trace and it seems to be that the terms of the form <code>x - xL i</code> are throwing it off.</p>\n<p>I'm not sure if I can come up with a mwe for this. I can post my big messy proof here.</p>\n<p>Any suggestions on how to prove that this kind of recursion is well-founded?</p>",
        "id": 239345240,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621383114
    },
    {
        "content": "<p>You might have to post. Sometimes if you're really suffering with a well-founded recursion, it can be helpful to work out how to instead do a inductive proof on <code>nat</code> itself. (e.g. introduce a complexity measure, and hypotheses that explicitly control your arguments in terms of it). If nothing else sometimes it's helpful as a paper-proof step, to make sure you're really doing a sensible induction.</p>",
        "id": 239345443,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621383257
    },
    {
        "content": "<p>Usually surreal numbers require a much higher order induction than <code>nat</code> though</p>",
        "id": 239345623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621383398
    },
    {
        "content": "<p>From the looks of the terms you mention, no lexicographic ordering on the arguments is going to help you, so you're certainly going to have to introduce by hand a different complexity measure, whether you do it with <code>using_well_founded</code>, or by induction on nat</p>",
        "id": 239345625,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621383401
    },
    {
        "content": "<p>Ah, good point.</p>",
        "id": 239345634,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621383413
    },
    {
        "content": "<p>probably you can do it using a surreal number or ordinal as the measure though</p>",
        "id": 239345646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621383420
    },
    {
        "content": "<p>I suspect though <span class=\"user-mention\" data-user-id=\"245078\">@Apurva Nakade</span> might be talking about Theorem 3.8 of <a href=\"http://www.cs.cmu.edu/afs/cs/academic/class/15859-s05/www/lecture-notes/comb-games-notes.pdf\">http://www.cs.cmu.edu/afs/cs/academic/class/15859-s05/www/lecture-notes/comb-games-notes.pdf</a>, which claims to work by induction on a tuple of natural numbers.</p>",
        "id": 239345737,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621383510
    },
    {
        "content": "<p>I'll clean up the code a bit and post it soon.</p>\n<p>Yes, I'm trying to prove a weaker version of Theorem 3.8 from those notes. The theorem as it is in the notes is too hard to code. They prove inequalities involving sums of products, which is insane!</p>\n<p>In those notes they define a \"depth\" which I think in Conway's terms might be \"day\" on which the numbers are born. I think I might need to prove some well_foundedness in terms of \"depth\". Tbh I've been using the tactic blindly and don't understand well_foundedness much. Is there any reference for this? Or some existing theorems about well_foundedness in mathlib?</p>",
        "id": 239347534,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621384975
    },
    {
        "content": "<p>Here's the code</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.surreal</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">pgame</span>\n<span class=\"kn\">open</span> <span class=\"n\">pgame</span>\n\n<span class=\"c1\">-- some lemmas first</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">numeric_sub</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ox</span> <span class=\"o\">:</span> <span class=\"n\">numeric</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">oy</span> <span class=\"o\">:</span> <span class=\"n\">numeric</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">numeric</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">numeric_add</span> <span class=\"n\">ox</span> <span class=\"o\">(</span><span class=\"n\">numeric_neg</span> <span class=\"n\">oy</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_le₁</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">x.right_moves</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x.move_right</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">le_def_lt</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">⟩</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">hr</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span> <span class=\"o\">⟩,</span> <span class=\"n\">hr</span><span class=\"o\">⟩⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">le_zero₁</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">x.left_moves</span><span class=\"o\">,</span> <span class=\"n\">x.move_left</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">le_def_lt</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">⟩</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hl</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span> <span class=\"o\">⟩⟩⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_lt₁</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">x.left_moves</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x.move_left</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">lt_def_le</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">forall_pempty</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lt_zero₁</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">x.right_moves</span><span class=\"o\">,</span> <span class=\"n\">x.move_right</span> <span class=\"n\">j</span> <span class=\"bp\">≤</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">lt_def_le</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">forall_pempty</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- missing trans rules for pgames</span>\n<span class=\"kd\">@[trans]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lt_of_lt_of_equiv'</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≈</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">lt_of_lt_of_le</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂.1</span>\n<span class=\"kd\">@[trans]</span> <span class=\"kd\">theorem</span> <span class=\"n\">le_of_le_of_equiv'</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≈</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">le_trans</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂.1</span>\n<span class=\"kd\">@[trans]</span> <span class=\"kd\">theorem</span> <span class=\"n\">lt_of_equiv_of_lt'</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≈</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">lt_of_le_of_lt</span> <span class=\"n\">h₁.1</span> <span class=\"n\">h₂</span>\n<span class=\"kd\">@[trans]</span> <span class=\"kd\">theorem</span> <span class=\"n\">le_of_equiv_of_le'</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≈</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">le_trans</span> <span class=\"n\">h₁.1</span> <span class=\"n\">h₂</span>\n\n<span class=\"c1\">--problem will well-founded recursion :(</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.solve_by_elim</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foobar</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">},</span>\n<span class=\"o\">(</span><span class=\"n\">x.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">y.numeric</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n<span class=\"o\">(</span><span class=\"n\">x.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">y.numeric</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">xl</span> <span class=\"n\">xr</span> <span class=\"n\">xL</span> <span class=\"n\">xR</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">yl</span> <span class=\"n\">yr</span> <span class=\"n\">yL</span> <span class=\"n\">yR</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">mk</span> <span class=\"n\">xl</span> <span class=\"n\">xr</span> <span class=\"n\">xL</span> <span class=\"n\">xR</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">mk</span> <span class=\"n\">yl</span> <span class=\"n\">yr</span> <span class=\"n\">yL</span> <span class=\"n\">yR</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">ox</span> <span class=\"n\">oy</span> <span class=\"n\">pos_x</span> <span class=\"n\">pos_y</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">nonneg_x</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">le_of_lt</span> <span class=\"n\">numeric_zero</span> <span class=\"n\">ox</span> <span class=\"n\">pos_x</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">nonneg_y</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">le_of_lt</span> <span class=\"n\">numeric_zero</span> <span class=\"n\">oy</span> <span class=\"n\">pos_y</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">zero_lt₁.1</span> <span class=\"n\">pos_x</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">hj</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">zero_lt₁.1</span> <span class=\"n\">pos_y</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">zero_lt₁</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">sum.inl</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">),</span>\n    <span class=\"k\">calc</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">yL</span> <span class=\"n\">j</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">xL</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n           <span class=\"o\">:</span> <span class=\"n\">foobar.2</span> <span class=\"o\">(</span><span class=\"n\">oy.2.1</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">numeric_sub</span> <span class=\"n\">ox</span> <span class=\"o\">(</span><span class=\"n\">ox.2.1</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n            <span class=\"n\">hj</span> <span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">le_iff_sub_nonneg</span> <span class=\"o\">(</span><span class=\"n\">xL</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">ox.2.1</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">ox</span> <span class=\"o\">(</span><span class=\"n\">ox.move_left_lt</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n       <span class=\"bp\">...</span> <span class=\"bp\">≈</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">xL</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">yL</span> <span class=\"n\">j</span>\n           <span class=\"o\">:</span> <span class=\"n\">mul_comm_equiv</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n       <span class=\"bp\">...</span> <span class=\"bp\">≈</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">xL</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">yL</span> <span class=\"n\">j</span>\n           <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zero_add_equiv</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n       <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"n\">xL</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">xL</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">yL</span> <span class=\"n\">j</span>\n           <span class=\"o\">:</span> <span class=\"n\">add_le_add_right</span> <span class=\"bp\">$</span> <span class=\"n\">foobar.2</span> <span class=\"o\">(</span><span class=\"n\">ox.2.1</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">oy</span> <span class=\"n\">hi</span> <span class=\"n\">nonneg_y</span>\n       <span class=\"bp\">...</span> <span class=\"bp\">≈</span> <span class=\"n\">xL</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">yL</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"n\">xL</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">yL</span> <span class=\"n\">j</span>\n           <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">quotient.exact</span> <span class=\"n\">pgame</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">abel</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">ox</span> <span class=\"n\">oy</span> <span class=\"n\">nonneg_x</span> <span class=\"n\">nonneg_y</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hx'</span> <span class=\"o\">:=</span> <span class=\"n\">zero_le₁.1</span> <span class=\"n\">nonneg_x</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">hx'</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hy'</span> <span class=\"o\">:=</span> <span class=\"n\">zero_le₁.1</span> <span class=\"n\">nonneg_y</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">hy'</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">zero_le₁</span><span class=\"o\">,</span>\n    <span class=\"n\">rintros</span> <span class=\"o\">(⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">⟩),</span>\n    <span class=\"o\">{</span> <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">xL</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"k\">calc</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">xL</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">foobar.2</span> <span class=\"o\">(</span><span class=\"n\">ox.2.1</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">oy</span> <span class=\"n\">h</span> <span class=\"n\">nonneg_y</span>\n      <span class=\"bp\">...</span> <span class=\"bp\">≈</span> <span class=\"n\">xL</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">add_zero_equiv</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n      <span class=\"bp\">...</span> <span class=\"bp\">&lt;</span> <span class=\"n\">xL</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">xL</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">yR</span> <span class=\"n\">j</span>\n          <span class=\"o\">:</span> <span class=\"n\">add_lt_add_left</span> <span class=\"bp\">$</span> <span class=\"n\">foobar.1</span> <span class=\"o\">(</span><span class=\"n\">numeric_sub</span> <span class=\"n\">ox</span> <span class=\"o\">(</span><span class=\"n\">ox.2.1</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">oy.2.2</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n                                <span class=\"o\">(</span><span class=\"n\">lt_iff_sub_pos.1</span> <span class=\"o\">(</span><span class=\"n\">ox.move_left_lt</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hy'</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n      <span class=\"bp\">...</span> <span class=\"bp\">≈</span> <span class=\"n\">xL</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">yR</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"n\">xL</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">yR</span> <span class=\"n\">j</span>\n          <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">quotient.exact</span> <span class=\"n\">pgame</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">abel</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">not_le</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"k\">calc</span> <span class=\"mi\">0</span>  <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">yR</span> <span class=\"n\">j</span>\n                <span class=\"o\">:</span> <span class=\"n\">foobar.2</span> <span class=\"n\">ox</span> <span class=\"o\">(</span><span class=\"n\">oy.2.2</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">nonneg_x</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">numeric_zero</span> <span class=\"o\">(</span><span class=\"n\">oy.2.2</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy'</span> <span class=\"n\">j</span><span class=\"o\">))</span>\n          <span class=\"bp\">...</span> <span class=\"bp\">≈</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">yR</span> <span class=\"n\">j</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">add_zero_equiv</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n          <span class=\"bp\">...</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">yR</span> <span class=\"n\">j</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">-</span> <span class=\"n\">xL</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">yR</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n                <span class=\"o\">:</span> <span class=\"n\">add_lt_add_left</span> <span class=\"bp\">$</span> <span class=\"n\">foobar.1</span> <span class=\"o\">(</span><span class=\"n\">numeric_sub</span> <span class=\"n\">numeric_zero</span> <span class=\"o\">(</span><span class=\"n\">ox.2.1</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n                                       <span class=\"o\">(</span><span class=\"n\">numeric_sub</span> <span class=\"o\">(</span><span class=\"n\">oy.2.2</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">oy</span><span class=\"o\">)</span>\n                                       <span class=\"o\">(</span><span class=\"n\">lt_iff_sub_pos.1</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n                                       <span class=\"o\">(</span><span class=\"n\">lt_iff_sub_pos.1</span> <span class=\"o\">(</span><span class=\"n\">oy.lt_move_right</span> <span class=\"n\">j</span><span class=\"o\">))</span>\n          <span class=\"bp\">...</span> <span class=\"bp\">≈</span> <span class=\"n\">xL</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">yR</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"n\">xL</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">yR</span> <span class=\"n\">j</span>\n              <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">quotient.exact</span> <span class=\"n\">pgame</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">abel</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">yL</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span><span class=\"k\">calc</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">xR</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">yL</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n            <span class=\"o\">:</span> <span class=\"n\">foobar.1</span> <span class=\"o\">(</span><span class=\"n\">ox.2.2</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">numeric_sub</span> <span class=\"n\">oy</span> <span class=\"o\">(</span><span class=\"n\">oy.2.1</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hx'</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lt_iff_sub_pos.1</span> <span class=\"o\">(</span><span class=\"n\">oy.move_left_lt</span> <span class=\"n\">j</span><span class=\"o\">))</span>\n     <span class=\"bp\">...</span> <span class=\"bp\">≈</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">xR</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">yL</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zero_add_equiv</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n     <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">yL</span> <span class=\"n\">j</span> <span class=\"bp\">+</span> <span class=\"n\">xR</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">yL</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n         <span class=\"o\">:</span> <span class=\"n\">add_le_add_right</span> <span class=\"bp\">$</span> <span class=\"n\">foobar.2</span> <span class=\"n\">ox</span> <span class=\"o\">(</span><span class=\"n\">oy.2.1</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">nonneg_x</span> <span class=\"n\">h</span>\n     <span class=\"bp\">...</span> <span class=\"bp\">≈</span> <span class=\"n\">xR</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">yL</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"n\">xR</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">yL</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">quotient.exact</span> <span class=\"n\">pgame</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">abel</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">not_le</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">calc</span> <span class=\"mi\">0</span>\n         <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">xR</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">-</span> <span class=\"n\">yL</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n         <span class=\"o\">:</span> <span class=\"n\">foobar.1</span> <span class=\"o\">(</span><span class=\"n\">numeric_sub</span> <span class=\"o\">(</span><span class=\"n\">ox.2.2</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">ox</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">numeric_sub</span> <span class=\"n\">numeric_zero</span> <span class=\"o\">(</span><span class=\"n\">oy.2.1</span> <span class=\"n\">j</span><span class=\"o\">))</span>\n           <span class=\"o\">(</span><span class=\"n\">lt_iff_sub_pos.1</span> <span class=\"o\">(</span><span class=\"n\">ox.lt_move_right</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n           <span class=\"o\">(</span><span class=\"n\">lt_iff_sub_pos.1</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n      <span class=\"bp\">...</span> <span class=\"bp\">≈</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">xR</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">-</span> <span class=\"n\">yL</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n          <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">zero_add_equiv</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n      <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"n\">xR</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">xR</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">-</span> <span class=\"n\">yL</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n          <span class=\"o\">:</span> <span class=\"n\">add_le_add_right</span> <span class=\"bp\">$</span> <span class=\"n\">foobar.2</span> <span class=\"o\">(</span><span class=\"n\">ox.2.2</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">oy</span>\n                                  <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">numeric_zero</span> <span class=\"o\">(</span><span class=\"n\">ox.2.2</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx'</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">nonneg_y</span>\n      <span class=\"bp\">...</span> <span class=\"bp\">≈</span> <span class=\"n\">xR</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">yL</span> <span class=\"n\">j</span> <span class=\"bp\">-</span> <span class=\"n\">xR</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">yL</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">quotient.exact</span> <span class=\"n\">pgame</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">abel</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span> <span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"n\">pgame_wf_tac</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">pgame</span>\n</code></pre></div>",
        "id": 239348090,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621385441
    },
    {
        "content": "<p>The notes prove the following instead by expanding everything out</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">w</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">y.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">w.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">z.numeric</span> <span class=\"bp\">→</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">w</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">w</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but we can transfer all the variables to one side and reduce the theorem to <code>mul_pos</code>. Because <code>le</code> and <code>lt</code> are defined in terms of each other, we end up having to prove the two theorems simultaneously.</p>",
        "id": 239348521,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621385883
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 239348647,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621385989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/239345646\">said</a>:</p>\n<blockquote>\n<p>probably you can do it using a surreal number or ordinal as the measure though</p>\n</blockquote>\n<p>How would one go about doing this? I think any connection between <code>pgame</code> and <code>ordinal</code> would be great. Does there exist a map <code>pgame \\to ordinals</code>?</p>",
        "id": 239350666,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621387622
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.game</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.ordinal_arithmetic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">pgame</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">bday</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">xl</span> <span class=\"n\">xr</span> <span class=\"n\">xL</span> <span class=\"n\">xR</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ordinal.sup.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">$</span>\n  <span class=\"n\">sum.elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">xL</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bday.succ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">xR</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bday.succ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">pgame</span>\n</code></pre></div>",
        "id": 239350987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621387909
    },
    {
        "content": "<p>Great, thanks! I should be able to prove that <code>bday</code> behaves well under arithmetic operations of <code>pgame</code>s.</p>\n<p>Given such a functor, how does one prove something is <code>well_founded</code>? Mathematically, I want to say that any descending chain of ordinals is finite but I dunno how this is encoded into <code>well_founded</code> in lean.</p>",
        "id": 239351792,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621388576
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 239352266,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621389000
    },
    {
        "content": "<p>there is an instance already saying that ordinals are well ordered by <code>&lt;</code></p>",
        "id": 239352980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621389547
    },
    {
        "content": "<p>So you would use something like <code>inv_image (&lt;) bday</code> and typeclass inference knows that this relation has a well founded instance</p>",
        "id": 239353151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621389633
    },
    {
        "content": "<p>Awesome, thanks again! I'll try this out.</p>",
        "id": 239353998,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621390134
    },
    {
        "content": "<p>Re <code>foo</code> -- can you deduce it from (z-y)*(w-x)&gt;0? I have this vague memory that there are problems with distributivity though...</p>",
        "id": 239373759,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621406319
    },
    {
        "content": "<p>Yeah, this is exactly what i'm trying to prove. Distributivity is fine as we've already shown all the ring properties for pgames up to equivalence.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mul_pos</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">w</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">y.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">w.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">z.numeric</span> <span class=\"bp\">→</span>\n<span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">w</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n<span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">w</span>  <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)(</span><span class=\"n\">z</span>  <span class=\"bp\">-</span>  <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>You can't prove the above theorem by itself as <code>&lt;</code> is defined in terms of <code>\\le</code> so you end up having to prove both simultaneously.</p>",
        "id": 239415327,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621427795
    },
    {
        "content": "<p>I am asking whether it's easier to prove a&gt;0 and b&gt;0 and a,b numeric implies ab&gt;0 (two variables not four), but I don't know anything about this stuff.</p>",
        "id": 239415580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621427895
    },
    {
        "content": "<p>Yups, this is the theorem I'm currently trying:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foobar</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">},</span>\n<span class=\"o\">(</span><span class=\"n\">x.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">y.numeric</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n<span class=\"o\">(</span><span class=\"n\">x.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">y.numeric</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 239415717,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621427964
    },
    {
        "content": "<p>Really hoping to make the well-founded recursion problem go away for this.</p>",
        "id": 239415935,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621428044
    },
    {
        "content": "<p>so what happens when you just try doing this by induction on birthday?</p>",
        "id": 239416013,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621428077
    },
    {
        "content": "<p>That's how Conway would do it, right?</p>",
        "id": 239416041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621428095
    },
    {
        "content": "<p>I haven't tried it yet. But hopefully it works after that.</p>\n<p>Yes! That's my thought too, just need to set it up.  <br>\nNeed to prove a few lemmas about birthday first. I think this might take some time...</p>",
        "id": 239416439,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621428247
    },
    {
        "content": "<p>Conway seems to give an argument in his proof of Theorem 8(iii) on p19 of ONAG</p>",
        "id": 239416952,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621428470
    },
    {
        "content": "<p>and, as you originally suggested, he proved x&gt;0 and y&gt;0 implies xy&gt;0 from this more general statement you were originally considering.</p>",
        "id": 239417150,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621428544
    },
    {
        "content": "<p>I looking at his proofs, he is proving the theorem with 4 variables directly <span aria-label=\"scared\" class=\"emoji emoji-1f628\" role=\"img\" title=\"scared\">:scared:</span> <br>\nThere are lots of WALOGs and \"... can be deduced from ...\" in there.</p>",
        "id": 239417973,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621428891
    },
    {
        "content": "<p>One very basic question: <code>ordinal</code> has a <code>preorder</code> instance. From this, how do I extract <code>ordinal.le_trans</code>? I tried the following but it did not quite work</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.game</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.ordinal_arithmetic</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">temp</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">ordinal</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">temp.le_trans</span>           <span class=\"c1\">-- unknown identifier</span>\n<span class=\"k\">#check</span> <span class=\"n\">ordinal.le_trans</span>       <span class=\"c1\">-- unknown identifier</span>\n</code></pre></div>",
        "id": 239758252,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621606803
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">le_trans</span> <span class=\"n\">ordinal</span> <span class=\"n\">_</span>  <span class=\"c1\">-- ∀ {a b c : ordinal}, a ≤ b → b ≤ c → a ≤ c</span>\n</code></pre></div>",
        "id": 239758830,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621606997
    },
    {
        "content": "<p>Although <code>#check temp.le_trans</code> works for me?</p>",
        "id": 239759313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621607199
    },
    {
        "content": "<p>Oh, I've <code>open pgame</code> at the start, I should add that to the mwe</p>",
        "id": 239759453,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621607272
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.game</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.ordinal_arithmetic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">pgame</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">pgame</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">temp</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">ordinal</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">temp.le_trans</span>           <span class=\"c1\">-- unknown identifier</span>\n<span class=\"k\">#check</span> <span class=\"n\">ordinal.le_trans</span>       <span class=\"c1\">-- unknown identifier</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">pgame</span>\n</code></pre></div>",
        "id": 239759619,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621607310
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">pgame.temp.le_trans</span>\n</code></pre></div>",
        "id": 239759668,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621607325
    },
    {
        "content": "<p>Named instances are only accessible via their fully-qualified name; <code>instance</code> is roughly short for <code>@[instance] protected def</code></p>",
        "id": 239759707,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621607340
    },
    {
        "content": "<p>Oh, wow!</p>",
        "id": 239759772,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621607363
    },
    {
        "content": "<p>Thanks, this worked!</p>",
        "id": 239759778,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621607367
    },
    {
        "content": "<p>Ah, I see</p>",
        "id": 239759836,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621607386
    },
    {
        "content": "<p>Although it's unlikely you actually need to specify which <code>le_trans</code> you want here anyway</p>",
        "id": 239760042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621607454
    },
    {
        "content": "<p>There's also the <code>le_trans</code> coming from <code>pgame</code></p>",
        "id": 239760713,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621607680
    },
    {
        "content": "<p><code>_root_.le_trans</code> will avoid that ambiguity</p>",
        "id": 239760749,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621607694
    },
    {
        "content": "<p>Great, this worked perfectly, thanks!</p>",
        "id": 239761317,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621607892
    },
    {
        "content": "<p>Is there any way to use <code>_root_.le_trans</code> in <code>calc</code> mode?</p>",
        "id": 239762958,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621608589
    },
    {
        "content": "<p><code>local attribute [-trans] pgame.le_trans</code>?</p>",
        "id": 239763519,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621608821
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 239763521,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621608822
    },
    {
        "content": "<p>I'm getting <code>300:1: cannot remove attribute [trans]</code><br>\nI tried putting it inside a <code>section</code> and <code>namespace</code> still the same error.</p>",
        "id": 239763788,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621608936
    },
    {
        "content": "<p>Then instead, remove the <code>@[trans]</code> from pgame.le_trans and add <code>local attribute [trans] pgame.le_trans</code> only where you need it</p>",
        "id": 239763813,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621608946
    },
    {
        "content": "<p>This will be too complicated. <code>pgame.le_trans</code> is used in almost every single proof :(</p>",
        "id": 239763984,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621609008
    },
    {
        "content": "<p>Sure, but you can add the attribute locally at the top of the section</p>",
        "id": 239764042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621609035
    },
    {
        "content": "<p>Ah I see, cool, I'll try it out. Will need to shuffle the current proofs around a bit.</p>",
        "id": 239764198,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621609086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245078\">Apurva Nakade</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/239345240\">said</a>:</p>\n<blockquote>\n<p>I've been stuck on a big proof for surreal numbers for quite some time now.</p>\n<p>I'm trying to prove a complicated theorem <code>f(x, y)</code> for <code>{x y : pgames}</code> by recursion.<br>\nI end up having to use statements like <code>f(x - xL i, yL j)</code>, <code>f(xL k, yR l - y)</code>,  etc in the proof where <code>xL _</code> are the left moves of <code>x</code> and <code>xR _</code> are the right moves of <code>x</code> and similarly for <code>y</code>.  Note that the \"depth\" always increases and there are no terms of the form <code>f(x - xL i, y)</code> so mathematically the recursion is fine.</p>\n<p>Lean is unable to prove well-founded recursion for this.  I tried doing a trace and it seems to be that the terms of the form <code>x - xL i</code> are throwing it off.</p>\n<p>I'm not sure if I can come up with a mwe for this. I can post my big messy proof here.</p>\n<p>Any suggestions on how to prove that this kind of recursion is well-founded?</p>\n</blockquote>\n<p>I think this recursion is not well-founded. It could happen that <code>(x - xL i).bday &gt; x.bday</code> (for example, <code>x = n</code> and <code>xL i = -1</code>.</p>\n<p>I dunno how to prove <code>numeric_mul</code> anymore :( <br>\nThe math proofs I've seen require you to prove things like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">w</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">y.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">w.numeric</span> <span class=\"bp\">→</span> <span class=\"n\">z.numeric</span> <span class=\"bp\">→</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">w</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">w</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But the LHS and RHS of these inequalities will have <code>16</code> terms so we'll end up having to prove <code>32</code> inequalities!<br>\nMost texts simply wave their hands and say that we'll do one case and the rest are similar, I'm not sure if this is actually true. </p>\n<p>Dunno how to proceed from here.</p>",
        "id": 239870930,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621687877
    },
    {
        "content": "<p>Moreover, you cannot even prove <code>(x &lt; w) → (y &lt; z) →(x * z + w * y &lt; x * y + w * z)</code> by itself. Instead you simultaneously have to <code>mul_congr</code>!</p>",
        "id": 239871084,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1621688049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/239350987\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.game</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.ordinal_arithmetic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">pgame</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">bday</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">xl</span> <span class=\"n\">xr</span> <span class=\"n\">xL</span> <span class=\"n\">xR</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ordinal.sup.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">$</span>\n  <span class=\"n\">sum.elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">xL</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bday.succ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">xR</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bday.succ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">pgame</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is now in mathlib as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.birthday\">docs#pgame.birthday</a></p>",
        "id": 280332571,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651056927
    },
    {
        "content": "<p>Although the definition is now instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">birthday</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">xl</span><span class=\"o\">,</span> <span class=\"n\">xr</span><span class=\"o\">,</span> <span class=\"n\">xL</span><span class=\"o\">,</span> <span class=\"n\">xR</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n    <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">ordinal.lsub.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">birthday</span> <span class=\"o\">(</span><span class=\"n\">xL</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">ordinal.lsub.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">birthday</span> <span class=\"o\">(</span><span class=\"n\">xR</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I assume the difference isn't important? Or do you think your formulation is more convenient <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  than <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span>'s</p>",
        "id": 280332766,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651057023
    },
    {
        "content": "<p>no, I imagine that will work out basically the same</p>",
        "id": 280332927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651057110
    },
    {
        "content": "<p>The supremum of a set of successors is definitionally what <code>lsub</code> is</p>",
        "id": 280343054,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651062942
    },
    {
        "content": "<p>Oh I hadn't noticed that this thread was for the exact thing I've been struggling with for the past week</p>",
        "id": 280954400,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651539822
    },
    {
        "content": "<p>But yeah, as for the surreal multiplication proof</p>",
        "id": 280954466,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651539864
    },
    {
        "content": "<p>It can be proven by a very specific induction on birthdays</p>",
        "id": 280954475,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651539877
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/6d7ead9ed67cf7ce04fe63829f7388b9b521e05b/src/set_theory/surreal/basic.lean#L318\">https://github.com/leanprover-community/mathlib/blob/6d7ead9ed67cf7ce04fe63829f7388b9b521e05b/src/set_theory/surreal/basic.lean#L318</a></p>",
        "id": 280954695,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651540129
    },
    {
        "content": "<p>This is <em>basically</em> the Schleicher proof, except that I figured out you could use birthdays instead of \"depth\", and also that P2 and P4 could be merged into a single statement</p>",
        "id": 280954719,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651540173
    },
    {
        "content": "<p>The induction, despite being quite complex, relies on a single nontrivial statement on birthdays, which is <code>birthday x &lt; birthday y → birthday (z + x) &lt; birthday (z + y)</code></p>",
        "id": 280954803,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651540259
    },
    {
        "content": "<p>This can be proven easily from <code>birthday x ≤ birthday y → birthday (z + x) ≤ birthday (z + y)</code>, which can be done by unfolding the definition of <code>birthday (x + y)</code> into the maximum of four <code>lsub</code>s and proving each less-equal by the induction hypothesis</p>",
        "id": 280954891,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651540358
    },
    {
        "content": "<p>The only reason I haven't done this yet is that I'm waiting for <a href=\"https://github.com/leanprover-community/mathlib/pull/13611\">#13611</a> to pass, which makes working with addition much less painful</p>",
        "id": 280954912,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651540389
    },
    {
        "content": "<p>If anyone wants to help fill the proof up, it would be greatly appreciated</p>",
        "id": 280955040,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651540553
    },
    {
        "content": "<p>The calculations themselves are basically the same as those in the Schleicher PDF</p>",
        "id": 280955084,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651540569
    },
    {
        "content": "<p>Two updates!</p>",
        "id": 280979405,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651565349
    },
    {
        "content": "<p>First, most of the proof has now been written down</p>",
        "id": 280979444,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651565379
    },
    {
        "content": "<p>Second, I found another simplification of the argument in the PDF</p>",
        "id": 280979466,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651565396
    },
    {
        "content": "<p>Turns out that you don't actually need P1 to conclude P4</p>",
        "id": 280979522,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651565409
    },
    {
        "content": "<p>Schleicher invokes P1 to conclude (xy)^L &lt; xy and xy &lt; (xy)^R, but these inequalities hold for all games, not just numeric games</p>",
        "id": 280979576,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651565454
    },
    {
        "content": "<p>What might not hold is (xy)^L &lt; (xy)^R, which fortunately isn't used</p>",
        "id": 280979590,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651565466
    },
    {
        "content": "<p>So you can in fact prove the following statement: for any <code>x₁, x₂, y</code>, the following hold simultaneously:</p>\n<ul>\n<li>if <code>x₁ = x₂</code>, then <code>x₁ * y</code> is numeric.</li>\n<li>If <code>x₁ ≈ x₂</code>, then <code>x₁ * y ≈ x₂ * y</code>.</li>\n<li>If <code>x₁ &lt; x₂</code>, then,</li>\n<li>\n<ul>\n<li>For any left option <code>yL</code>, <code>x₂ * yL + x₁ * y &lt; x₁ * yL + x₂ * y</code>.</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>For any left option <code>yR</code>, <code>x₂ * y + x₁ * yR &lt; x₁ * y + x₂ * yR</code>.</li>\n</ul>\n</li>\n</ul>",
        "id": 280980804,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651566279
    },
    {
        "content": "<p>And you can prove this by bare Conway induction on <code>x₁ + x₂ + y + y</code></p>",
        "id": 280980821,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651566293
    },
    {
        "content": "<p>(this wasn't possible before due to that single application of P1)</p>",
        "id": 280980849,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651566311
    },
    {
        "content": "<p>Checking the induction hypothesis pretty much amounts to verifying a bunch of goals similar to \"yL + yR + x1 + x2 is subsequent to x1 + x2 + y + y up to relabelling\"</p>",
        "id": 280985564,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569227
    },
    {
        "content": "<p>If the arguments we're in the correct order, this could be done via <code>solve_by_elim</code></p>",
        "id": 280985702,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569312
    },
    {
        "content": "<p>And, if addition were commutative, we could use <code>abel</code> for this</p>",
        "id": 280985739,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569336
    },
    {
        "content": "<p>Unfortunately we run into the issue of relabellings</p>",
        "id": 280985752,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569344
    },
    {
        "content": "<p>So I'm thinking, perhaps we should have a type of pregames quotiented by relabelling?</p>",
        "id": 280985815,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569365
    },
    {
        "content": "<p>How is that different from <code>game</code>?</p>",
        "id": 280985846,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651569394
    },
    {
        "content": "<p><code>game</code> is a much stronger quotient</p>",
        "id": 280985861,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569409
    },
    {
        "content": "<p>It quotients by antisymmetry</p>",
        "id": 280985865,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569413
    },
    {
        "content": "<p>So for instance, the empty pregame { | } and the pregame { 1 | -1 } are equal as games but they're not relabellings of one another</p>",
        "id": 280985936,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569467
    },
    {
        "content": "<p>Conversely, the empty pregame with move types <code>pempty</code> and the empty pregame with move types <code>fin 0</code> are relabellings but can't be proven equal</p>",
        "id": 280986260,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569665
    },
    {
        "content": "<p>And as mentioned, another annoying consequence is that <code>x + y</code> is not always equal to <code>y + x</code>, even though they're relabellings</p>",
        "id": 280986303,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569705
    },
    {
        "content": "<p>Is <code>x + 0</code> a relabelling of <code>x</code>?</p>",
        "id": 280986582,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651569851
    },
    {
        "content": "<p>Indeed</p>",
        "id": 280986597,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569862
    },
    {
        "content": "<p>But <code>a * (b + c)</code> is not a relabelling of <code>a * b + a * c</code>?</p>",
        "id": 280986684,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651569931
    },
    {
        "content": "<p>It also is</p>",
        "id": 280986707,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569941
    },
    {
        "content": "<p>Pre-games up to relabelling are an abelian monoid with commutative and distributive multiplication</p>",
        "id": 280986807,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651569988
    },
    {
        "content": "<p>What's the strongest you can prove about your <code>relabeled_pgame</code>s?</p>",
        "id": 280986811,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651569990
    },
    {
        "content": "<p>They don't have additive nor multiplicative inverses though</p>",
        "id": 280986833,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651570006
    },
    {
        "content": "<p>They don't have a partial order (neither do games), but they have all covariant instances for addition (as do pre-games)</p>",
        "id": 280986918,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651570068
    },
    {
        "content": "<p>Oh and addition and multiplication are also associative</p>",
        "id": 280987000,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651570101
    },
    {
        "content": "<p>That sounds good enough to want another type.</p>",
        "id": 280987001,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651570102
    },
    {
        "content": "<p>Glad you agree</p>",
        "id": 280987024,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651570126
    },
    {
        "content": "<p>What I'm wondering is nomenclature</p>",
        "id": 280987039,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651570136
    },
    {
        "content": "<p>I would go for something short, like <code>rgame</code>.</p>",
        "id": 280987068,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651570166
    },
    {
        "content": "<p>I like that</p>",
        "id": 280987097,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651570190
    },
    {
        "content": "<p>Btw, if you're interested in another refactor, you can redefine <code>game</code> as <code>antisymmetrization (≤) pgame</code>.</p>",
        "id": 280987394,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651570400
    },
    {
        "content": "<p>That might be nice</p>",
        "id": 280987807,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651570663
    },
    {
        "content": "<p>I'll look into that</p>",
        "id": 280987815,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651570669
    },
    {
        "content": "<p>Oh wait</p>",
        "id": 281072069,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651609662
    },
    {
        "content": "<p>Turns out <code>rgame</code> isn't as strong as I thought</p>",
        "id": 281072104,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651609677
    },
    {
        "content": "<p>You can define multiplication, and it satisfies <code>x * 0 = 0</code>, <code>x * 1 = 1</code>, <code>x * y = y * x</code>, and <code>(-x) * y = x * (-y) = -(x * y)</code></p>",
        "id": 281072220,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651609720
    },
    {
        "content": "<p>But unfortunately it isn't distributive nor associative</p>",
        "id": 281072264,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651609738
    },
    {
        "content": "<p>That said, these properties should still make it much easier to deal with multiplication in games</p>",
        "id": 281072571,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651609866
    },
    {
        "content": "<p>Since you can convert inequalities about <code>game</code> to inequalities about <code>rgame</code> and then use these laws via <code>rw</code></p>",
        "id": 281072618,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651609894
    },
    {
        "content": "<p>What I don't know is what structure these form</p>",
        "id": 281072636,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651609907
    },
    {
        "content": "<p>I think it's just a unital magma? lol</p>",
        "id": 281072744,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651609948
    },
    {
        "content": "<p><code>mul_zero_one_class</code> and <code>has_distrib_neg</code> ;b</p>",
        "id": 281073455,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1651610298
    },
    {
        "content": "<p>old-school names are for old-school people</p>",
        "id": 281073466,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1651610309
    },
    {
        "content": "<p>oh wait, is that distrib_neg? or sth else</p>",
        "id": 281073477,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1651610317
    },
    {
        "content": "<p>Oh cool</p>",
        "id": 281073505,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651610332
    },
    {
        "content": "<p>It's good to know that there's names for these in <code>mathlib</code></p>",
        "id": 281073513,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651610338
    },
    {
        "content": "<p>I sometimes feel like we just made them to make fun of the people who study hierarchies of algebraic structures</p>",
        "id": 281079630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651613227
    },
    {
        "content": "<p>I wonder if people have thought about defining <code>pgame</code> as the type of types (of positions) equipped with two relations L and R (moves) such that the union of both relations is well-founded, together with the starting position. Seems closer to the definition in <em>ONAG</em> than the current inductive type definition, and would be easier to extend to <a href=\"https://people.math.carleton.ca/~svenjahuntemann/CapitalGames/SlidesSeminar20200730.pdf\">loopy games</a> by dropping the well-founded condition. <del>Moreover, you should be able to get rid of all the <code>relabelling</code> stuff.</del>(maybe not)<br>\n<a href=\"/user_uploads/3121/L64moCNIn-UwgFljzcq4Hsr8/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/L64moCNIn-UwgFljzcq4Hsr8/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/L64moCNIn-UwgFljzcq4Hsr8/image.png\"></a></div>",
        "id": 281106984,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651635011
    },
    {
        "content": "<p>I tried something like this (it was my first attempt to work in Lean, so don't be too critical...).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">games</span>\n\n<span class=\"c1\">-- We really would like to do the following:</span>\n\n<span class=\"c1\">-- inductive Game : Type</span>\n<span class=\"c1\">-- | make : set Game → set Game → Game</span>\n\n<span class=\"c1\">-- but Lean complains of missing \"positivity\"...</span>\n\n<span class=\"c1\">-- so we have to do it in a more pedestrian way.</span>\n\n<span class=\"c1\">-- Define the type of (Conway) games.</span>\n<span class=\"kd\">constant</span> <span class=\"n\">Game</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"c1\">-- Each game has a set of left and a set of right options,</span>\n<span class=\"c1\">-- which are themselves games.</span>\n<span class=\"kd\">constants</span> <span class=\"n\">L_opts</span> <span class=\"n\">R_opts</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">Game</span>\n\n<span class=\"c1\">-- We can construct a game from its left and right options.</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">constant</span> <span class=\"n\">make</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Game</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">Game</span> <span class=\"bp\">→</span> <span class=\"n\">Game</span>\n\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">G1</span> <span class=\"bp\">`|`</span> <span class=\"n\">G2</span> <span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">make</span> <span class=\"n\">G1</span> <span class=\"n\">G2</span>\n\n<span class=\"c1\">-- The following state that these two operations are inverses.</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">axiom</span> <span class=\"n\">make_LR</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">make</span> <span class=\"o\">(</span><span class=\"n\">L_opts</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R_opts</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">G</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">axiom</span> <span class=\"n\">make_L</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">GR</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">L_opts</span> <span class=\"o\">(</span><span class=\"n\">make</span> <span class=\"n\">GL</span> <span class=\"n\">GR</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">GL</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">axiom</span> <span class=\"n\">make_R</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">GR</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R_opts</span> <span class=\"o\">(</span><span class=\"n\">make</span> <span class=\"n\">GL</span> <span class=\"n\">GR</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">GR</span>\n\n<span class=\"c1\">-- A simple consequence is that it suffices to check equality</span>\n<span class=\"c1\">-- of the left and right options to conclude that two games are the same.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_LR</span> <span class=\"o\">(</span><span class=\"n\">G1</span> <span class=\"n\">G2</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G1</span> <span class=\"bp\">=</span> <span class=\"n\">G2</span> <span class=\"bp\">↔</span> <span class=\"n\">L_opts</span> <span class=\"n\">G1</span> <span class=\"bp\">=</span> <span class=\"n\">L_opts</span> <span class=\"n\">G2</span> <span class=\"bp\">∧</span> <span class=\"n\">R_opts</span> <span class=\"n\">G1</span> <span class=\"bp\">=</span> <span class=\"n\">R_opts</span> <span class=\"n\">G2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"n\">tauto</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">make_LR</span> <span class=\"n\">G1</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">make_LR</span> <span class=\"n\">G2</span><span class=\"o\">],</span> <span class=\"n\">cases</span> <span class=\"n\">hyp</span> <span class=\"k\">with</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- For applications in proofs, this implication is useful.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_of_eq_LR</span> <span class=\"o\">(</span><span class=\"n\">G1</span> <span class=\"n\">G2</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">L_opts</span> <span class=\"n\">G1</span> <span class=\"bp\">=</span> <span class=\"n\">L_opts</span> <span class=\"n\">G2</span> <span class=\"bp\">∧</span> <span class=\"n\">R_opts</span> <span class=\"n\">G1</span> <span class=\"bp\">=</span> <span class=\"n\">R_opts</span> <span class=\"n\">G2</span> <span class=\"bp\">→</span> <span class=\"n\">G1</span> <span class=\"bp\">=</span> <span class=\"n\">G2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">eq_LR</span><span class=\"o\">,</span> <span class=\"n\">tauto</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- We define the notion of \"option\" of a game.</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_option</span> <span class=\"o\">(</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">G'</span> <span class=\"bp\">∈</span> <span class=\"n\">L_opts</span> <span class=\"n\">G</span> <span class=\"bp\">∨</span> <span class=\"n\">G'</span> <span class=\"bp\">∈</span> <span class=\"n\">R_opts</span> <span class=\"n\">G</span>\n\n<span class=\"c1\">-- We note that the elements of `L_opts G` and of `R_opts G` are options of `G`.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">L_is_option</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GL</span> <span class=\"bp\">∈</span> <span class=\"n\">L_opts</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">is_option</span> <span class=\"n\">GL</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">is_option</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">R_is_option</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">GR</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GR</span> <span class=\"bp\">∈</span> <span class=\"n\">R_opts</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">is_option</span> <span class=\"n\">GR</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">is_option</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">--------------------------------------------------------------------</span>\n<span class=\"c1\">-- The induction principle</span>\n<span class=\"c1\">--------------------------------------------------------------------</span>\n\n<span class=\"c1\">-- This is the \"descending game condition\":</span>\n<span class=\"c1\">-- the relation \"is option of\" is well-founded.</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">DGC</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"n\">is_option</span>\n\n<span class=\"c1\">-- This gives us Conway induction for statements involving a single game.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Conway_ind_opt</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">G'</span><span class=\"o\">,</span> <span class=\"n\">is_option</span> <span class=\"n\">G'</span> <span class=\"n\">G</span> <span class=\"bp\">→</span>  <span class=\"n\">P</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">DGC.fix</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- A variant that inducts explicitly on the left and right options.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Conway_ind_LR</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"bp\">∀</span> <span class=\"n\">GL</span> <span class=\"bp\">∈</span> <span class=\"n\">L_opts</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">GL</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">GR</span> <span class=\"bp\">∈</span> <span class=\"n\">R_opts</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">GR</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Conway_ind_opt</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">G</span> <span class=\"n\">hyp1</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hyp</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">GL</span> <span class=\"n\">GLG</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hyp1</span> <span class=\"n\">GL</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">is_option</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">GR</span> <span class=\"n\">GRG</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hyp1</span> <span class=\"n\">GR</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_option</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"c1\">-- Now repeat for pairs of games, when we replace one or both of them by an option.</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_option_2</span> <span class=\"o\">(</span><span class=\"n\">GG1</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">×</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">GG</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">×</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">GG1.fst</span> <span class=\"bp\">=</span> <span class=\"n\">GG.fst</span> <span class=\"bp\">∧</span> <span class=\"n\">is_option</span> <span class=\"n\">GG1.snd</span> <span class=\"n\">GG.snd</span><span class=\"o\">)</span>\n   <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">is_option</span> <span class=\"n\">GG1.fst</span> <span class=\"n\">GG.fst</span> <span class=\"bp\">∧</span> <span class=\"n\">GG1.snd</span> <span class=\"bp\">=</span> <span class=\"n\">GG.snd</span><span class=\"o\">)</span>\n   <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">is_option</span> <span class=\"n\">GG1.fst</span> <span class=\"n\">GG.fst</span> <span class=\"bp\">∧</span> <span class=\"n\">is_option</span> <span class=\"n\">GG1.snd</span> <span class=\"n\">GG.snd</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">L_opts1_is_option_2</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">GG</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">×</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GL</span> <span class=\"bp\">∈</span> <span class=\"n\">L_opts</span> <span class=\"n\">GG.fst</span> <span class=\"bp\">→</span> <span class=\"n\">is_option_2</span> <span class=\"o\">(</span><span class=\"n\">GL</span><span class=\"o\">,</span> <span class=\"n\">GG.snd</span><span class=\"o\">)</span> <span class=\"n\">GG</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hyp</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">is_option_2</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">L_is_option</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">R_opts1_is_option_2</span> <span class=\"o\">(</span><span class=\"n\">GR</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">GG</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">×</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GR</span> <span class=\"bp\">∈</span> <span class=\"n\">R_opts</span> <span class=\"n\">GG.fst</span> <span class=\"bp\">→</span> <span class=\"n\">is_option_2</span> <span class=\"o\">(</span><span class=\"n\">GR</span><span class=\"o\">,</span> <span class=\"n\">GG.snd</span><span class=\"o\">)</span> <span class=\"n\">GG</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hyp</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">is_option_2</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">R_is_option</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">L_opts2_is_option_2</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">GG</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">×</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GL</span> <span class=\"bp\">∈</span> <span class=\"n\">L_opts</span> <span class=\"n\">GG.snd</span> <span class=\"bp\">→</span> <span class=\"n\">is_option_2</span> <span class=\"o\">(</span><span class=\"n\">GG.fst</span><span class=\"o\">,</span> <span class=\"n\">GL</span><span class=\"o\">)</span> <span class=\"n\">GG</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hyp</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">is_option_2</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">L_is_option</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">R_opts2_is_option_2</span> <span class=\"o\">(</span><span class=\"n\">GR</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">GG</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">×</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GR</span> <span class=\"bp\">∈</span> <span class=\"n\">R_opts</span> <span class=\"n\">GG.snd</span> <span class=\"bp\">→</span> <span class=\"n\">is_option_2</span> <span class=\"o\">(</span><span class=\"n\">GG.fst</span><span class=\"o\">,</span> <span class=\"n\">GR</span><span class=\"o\">)</span> <span class=\"n\">GG</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hyp</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">is_option_2</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">R_is_option</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Note that this is a subrelation of the lexicographic product.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">is_option_2_sub_lex</span> <span class=\"o\">:</span> <span class=\"n\">subrelation</span> <span class=\"n\">is_option_2</span> <span class=\"o\">(</span><span class=\"n\">prod.lex</span> <span class=\"n\">is_option</span> <span class=\"n\">is_option</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">subrelation</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">GG1</span> <span class=\"n\">GG2</span> <span class=\"n\">hyp</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">prod.lex_def</span> <span class=\"n\">is_option</span> <span class=\"n\">is_option</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">is_option_2</span> <span class=\"n\">at</span> <span class=\"n\">hyp</span><span class=\"o\">,</span> <span class=\"n\">tauto</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Then we can use existing machinery to deduce that this is well-founded.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">DGC_2</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"n\">is_option_2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">subrelation.wf</span> <span class=\"n\">is_option_2_sub_lex</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">prod.lex_wf</span> <span class=\"n\">DGC</span> <span class=\"n\">DGC</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- ... and derive the induction principle.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Conway_ind_opt_2</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">×</span> <span class=\"n\">Game</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">×</span> <span class=\"n\">Game</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">GG</span><span class=\"o\">,</span> <span class=\"n\">is_option_2</span> <span class=\"n\">GG</span> <span class=\"n\">G</span> <span class=\"bp\">→</span>  <span class=\"n\">P</span> <span class=\"n\">GG</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">×</span> <span class=\"n\">Game</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">DGC_2.fix</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n <span class=\"o\">(</span><span class=\"n\">etc.</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It was not clear to me, however, how to show in Lean that a structure exists that satisfies the axioms.</p>",
        "id": 281141568,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1651663781
    },
    {
        "content": "<p>I'll take a closer look at your code when I have more time. Here's an attempt I started last night, where I constructed a game from the smaller games after left/right moves, but am yet to prove well-foundedness.  Negation of a game is obtained by switching L and R, and sum of two games have <code>pos</code> defined to be the product of the two <code>pos</code>; I've yet to think about multiplication (of surreals). (corrected to add the starting position in <code>structure pgame</code>.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">pgame</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">pos</span> <span class=\"bp\">→</span> <span class=\"n\">pos</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">wf</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"n\">pos</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">pgame</span>\n<span class=\"kn\">open</span> <span class=\"n\">sum</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> special case of sigma.lex -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">sigma_disjoint</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">sigma_disjoint</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- construct a game from left/right options -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">of_L_R</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"bp\">Σ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"o\">)</span> <span class=\"bp\">⊕</span> <span class=\"bp\">Σ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"o\">)</span> <span class=\"bp\">⊕</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n  <span class=\"n\">start</span> <span class=\"o\">:=</span> <span class=\"n\">inr</span> <span class=\"o\">(),</span>\n  <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">⟩),</span> <span class=\"n\">inr</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">start</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"n\">p₁</span><span class=\"o\">),</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"n\">p₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sigma_disjoint</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">inr</span> <span class=\"n\">p₁</span><span class=\"o\">),</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">inr</span> <span class=\"n\">p₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sigma_disjoint</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">inr</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">⟩),</span> <span class=\"n\">inr</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">start</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"n\">p₁</span><span class=\"o\">),</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"n\">p₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sigma_disjoint</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span>\n    <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">inr</span> <span class=\"n\">p₁</span><span class=\"o\">),</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">inr</span> <span class=\"n\">p₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sigma_disjoint</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">wf</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">⟩}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"n\">g.pos</span><span class=\"o\">,</span>\n  <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">g.R</span><span class=\"o\">,</span>\n  <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">g.L</span><span class=\"o\">,</span>\n  <span class=\"n\">wf</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">g.wf</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">or.comm</span> <span class=\"o\">},</span>\n  <span class=\"n\">start</span> <span class=\"o\">:=</span> <span class=\"n\">g.start</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">game_sum_rel</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r₁</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r₂</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">r₁</span> <span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"bp\">→</span> <span class=\"n\">game_sum_rel</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a'</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">b'</span><span class=\"o\">,</span> <span class=\"n\">r₂</span> <span class=\"n\">b</span> <span class=\"n\">b'</span> <span class=\"bp\">→</span> <span class=\"n\">game_sum_rel</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b'</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">g₂</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"n\">g₁.pos</span> <span class=\"bp\">×</span> <span class=\"n\">g₂.pos</span><span class=\"o\">,</span>\n  <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">game_sum_rel</span> <span class=\"n\">g₁.L</span> <span class=\"n\">g₂.L</span><span class=\"o\">,</span>\n  <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">game_sum_rel</span> <span class=\"n\">g₁.R</span> <span class=\"n\">g₂.R</span><span class=\"o\">,</span>\n  <span class=\"n\">wf</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">start</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">g₁.start</span><span class=\"o\">,</span> <span class=\"n\">g₂.start</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">pgame</span>\n</code></pre></div>",
        "id": 281148141,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651667793
    },
    {
        "content": "<p>Here is another snippet from my attempt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Define the four simplest games.</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">G0</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"o\">:=</span> <span class=\"o\">[</span> <span class=\"o\">{}</span> <span class=\"bp\">|</span> <span class=\"o\">{}</span> <span class=\"o\">]</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">G1</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"o\">:=</span> <span class=\"o\">[</span> <span class=\"o\">{</span><span class=\"n\">G0</span><span class=\"o\">}</span> <span class=\"bp\">|</span> <span class=\"o\">{}</span> <span class=\"o\">]</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Gn1</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"o\">:=</span> <span class=\"o\">[</span> <span class=\"o\">{}</span> <span class=\"bp\">|</span> <span class=\"o\">{</span><span class=\"n\">G0</span><span class=\"o\">}</span> <span class=\"o\">]</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Gstar</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"o\">:=</span> <span class=\"o\">[</span> <span class=\"o\">{</span><span class=\"n\">G0</span><span class=\"o\">}</span> <span class=\"bp\">|</span> <span class=\"o\">{</span><span class=\"n\">G0</span><span class=\"o\">}</span> <span class=\"o\">]</span>\n\n<span class=\"c1\">-- Note that `Game` is inhabited.</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">Game_inhabited</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"n\">Game</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">G0</span> <span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- Define negation of games.</span>\n<span class=\"c1\">-- We use well-founded recursion for that.</span>\n<span class=\"c1\">-- Ideally, we want to have</span>\n<span class=\"c1\">--   `make {f GR (R_is_option G GR h) GR | h : GR ∈ R_opts G} {f GL ... | GL ∈ L_opts G}` ,</span>\n<span class=\"c1\">-- but `{f x | x ...}` is not legal set syntax.</span>\n\n<span class=\"c1\">-- This describes the recursive construction:</span>\n<span class=\"c1\">-- we assume that `f G'` gives `-G'` for the options `G'` of `G` and construct `-G` out of these values.</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">neg_help</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">G1</span><span class=\"o\">,</span> <span class=\"n\">is_option</span> <span class=\"n\">G1</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"o\">:=</span>\n  <span class=\"n\">make</span> <span class=\"o\">{</span><span class=\"n\">GNL</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">GR</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">GR</span> <span class=\"bp\">∈</span> <span class=\"n\">R_opts</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">GNL</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">GR</span> <span class=\"o\">(</span><span class=\"n\">R_is_option</span> <span class=\"n\">G</span> <span class=\"n\">GR</span> <span class=\"n\">h</span><span class=\"o\">)}</span>\n            <span class=\"o\">{</span><span class=\"n\">GNR</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">GL</span> <span class=\"bp\">∈</span> <span class=\"n\">L_opts</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">GNR</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">GL</span> <span class=\"o\">(</span><span class=\"n\">L_is_option</span> <span class=\"n\">G</span> <span class=\"n\">GL</span> <span class=\"n\">h</span><span class=\"o\">)}</span>\n<span class=\"c1\">-- Now apply the fixed point operator for the recursion.</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span><span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"o\">:=</span>\n  <span class=\"n\">DGC.fix</span> <span class=\"n\">neg_help</span> <span class=\"n\">G</span>\n\n<span class=\"c1\">--noncomputable instance Game_has_neg : has_neg Game := ⟨ neg ⟩</span>\n\n<span class=\"kd\">notation</span> <span class=\"bp\">`-`</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">neg</span> <span class=\"n\">G</span>\n\n<span class=\"c1\">-- The following basically establish rewrite rules.</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">L_opts_of_neg</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">L_opts</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">GRN</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">GR</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">R_opts</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">GRN</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">GR</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">neg</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">DGC.fix_eq</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">neg_help</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">R_opts_of_neg</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R_opts</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">GLN</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">GL</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">L_opts</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">GLN</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">GL</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">neg</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">DGC.fix_eq</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">neg_help</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Show that `-(-G) = G`.</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">neg_neg</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">revert</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- We use Conway induction for this.</span>\n  <span class=\"k\">have</span> <span class=\"n\">ind</span> <span class=\"o\">:=</span> <span class=\"n\">Conway_ind_opt</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">ind</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ind</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">G</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- It is sufficient to show that the sets of left/right options agree.</span>\n  <span class=\"n\">rw</span> <span class=\"n\">eq_LR</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"n\">set.ext</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">G1</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"n\">intro</span> <span class=\"n\">hyp1</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hyp1</span> <span class=\"k\">with</span> <span class=\"n\">GLN</span> <span class=\"n\">hyp1</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hyp1</span> <span class=\"k\">with</span> <span class=\"n\">hyp1</span> <span class=\"n\">hyp2</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hyp1</span> <span class=\"k\">with</span> <span class=\"n\">GL</span> <span class=\"n\">hyp1</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">hyp1</span> <span class=\"k\">with</span> <span class=\"n\">hyp11</span> <span class=\"n\">hyp12</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">hyp</span> <span class=\"n\">GL</span> <span class=\"o\">(</span><span class=\"n\">L_is_option</span> <span class=\"n\">G</span> <span class=\"n\">GL</span> <span class=\"n\">hyp11</span><span class=\"o\">),</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hyp2</span><span class=\"o\">,</span> <span class=\"n\">hyp12</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span>\n      <span class=\"n\">assumption</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">hyp</span> <span class=\"n\">G1</span> <span class=\"o\">(</span><span class=\"n\">L_is_option</span> <span class=\"n\">G</span> <span class=\"n\">G1</span> <span class=\"n\">h1</span><span class=\"o\">),</span>\n    <span class=\"n\">use</span> <span class=\"bp\">-</span><span class=\"n\">G1</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"n\">use</span> <span class=\"n\">G1</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n\n    <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"n\">set.ext</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">G1</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"n\">intro</span> <span class=\"n\">hyp1</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hyp1</span> <span class=\"k\">with</span> <span class=\"n\">GRN</span> <span class=\"n\">hyp1</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hyp1</span> <span class=\"k\">with</span> <span class=\"n\">hyp1</span> <span class=\"n\">hyp2</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hyp1</span> <span class=\"k\">with</span> <span class=\"n\">GR</span> <span class=\"n\">hyp1</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">hyp1</span> <span class=\"k\">with</span> <span class=\"n\">hyp11</span> <span class=\"n\">hyp12</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">hyp</span> <span class=\"n\">GR</span> <span class=\"o\">(</span><span class=\"n\">R_is_option</span> <span class=\"n\">G</span> <span class=\"n\">GR</span> <span class=\"n\">hyp11</span><span class=\"o\">),</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hyp2</span><span class=\"o\">,</span> <span class=\"n\">hyp12</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span>\n      <span class=\"n\">assumption</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">hyp</span> <span class=\"n\">G1</span> <span class=\"o\">(</span><span class=\"n\">R_is_option</span> <span class=\"n\">G</span> <span class=\"n\">G1</span> <span class=\"n\">h1</span><span class=\"o\">),</span>\n    <span class=\"n\">use</span> <span class=\"bp\">-</span><span class=\"n\">G1</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"n\">use</span> <span class=\"n\">G1</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- We get the fact that negation is injective.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">neg_inj</span> <span class=\"o\">(</span><span class=\"n\">G1</span> <span class=\"n\">G2</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">-</span><span class=\"n\">G1</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">G2</span> <span class=\"bp\">→</span> <span class=\"n\">G1</span> <span class=\"bp\">=</span> <span class=\"n\">G2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">neg_neg</span> <span class=\"n\">G1</span><span class=\"o\">),</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">neg_neg</span> <span class=\"n\">G2</span><span class=\"o\">),</span> <span class=\"n\">rw</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Also, `G₁ = -G₂` implies `G₂ = -G₁`.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">neg_swap</span> <span class=\"o\">(</span><span class=\"n\">G₁</span> <span class=\"n\">G₂</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G₁</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">G₂</span> <span class=\"bp\">→</span> <span class=\"n\">G₂</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">G₁</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">neg_neg</span> <span class=\"n\">G₂</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">eq.symm</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Some simple statements on the simplest games and negation.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">G0_neg</span> <span class=\"o\">:</span> <span class=\"bp\">-</span><span class=\"n\">G0</span> <span class=\"bp\">=</span> <span class=\"n\">G0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"n\">eq_LR</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">G0</span><span class=\"o\">)</span> <span class=\"n\">G0</span><span class=\"o\">),</span> <span class=\"n\">unfold</span> <span class=\"n\">G0</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">G1_neg</span> <span class=\"o\">:</span> <span class=\"bp\">-</span><span class=\"n\">G1</span> <span class=\"bp\">=</span> <span class=\"n\">Gn1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"n\">eq_LR</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">G1</span><span class=\"o\">)</span> <span class=\"n\">Gn1</span><span class=\"o\">),</span> <span class=\"n\">unfold</span> <span class=\"n\">Gn1</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">G1</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">G0_neg</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Gstar_neg</span> <span class=\"o\">:</span> <span class=\"bp\">-</span><span class=\"n\">Gstar</span> <span class=\"bp\">=</span> <span class=\"n\">Gstar</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"n\">eq_LR</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">Gstar</span><span class=\"o\">)</span> <span class=\"n\">Gstar</span><span class=\"o\">),</span> <span class=\"n\">unfold</span> <span class=\"n\">Gstar</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">G0_neg</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Now we do addition.</span>\n<span class=\"c1\">-- To use Conway induction on pairs of games,</span>\n<span class=\"c1\">-- we need to work with the product type.</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">add_help</span> <span class=\"o\">(</span><span class=\"n\">GG</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">×</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">GG1</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">×</span> <span class=\"n\">Game</span><span class=\"o\">),</span> <span class=\"n\">is_option_2</span> <span class=\"n\">GG1</span> <span class=\"n\">GG</span> <span class=\"bp\">→</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"o\">:=</span>\n  <span class=\"n\">make</span> <span class=\"o\">{</span><span class=\"n\">GAL</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">GL</span> <span class=\"bp\">∈</span> <span class=\"n\">L_opts</span> <span class=\"n\">GG.fst</span><span class=\"o\">),</span> <span class=\"n\">GAL</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">GL</span><span class=\"o\">,</span> <span class=\"n\">GG.snd</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L_opts1_is_option_2</span> <span class=\"n\">GL</span> <span class=\"n\">GG</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n                          <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">GL</span> <span class=\"bp\">∈</span> <span class=\"n\">L_opts</span> <span class=\"n\">GG.snd</span><span class=\"o\">),</span> <span class=\"n\">GAL</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">GG.fst</span><span class=\"o\">,</span> <span class=\"n\">GL</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L_opts2_is_option_2</span> <span class=\"n\">GL</span> <span class=\"n\">GG</span> <span class=\"n\">h</span><span class=\"o\">))}</span>\n       <span class=\"o\">{</span><span class=\"n\">GAR</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">GR</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">GR</span> <span class=\"bp\">∈</span> <span class=\"n\">R_opts</span> <span class=\"n\">GG.fst</span><span class=\"o\">),</span> <span class=\"n\">GAR</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">GR</span><span class=\"o\">,</span> <span class=\"n\">GG.snd</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R_opts1_is_option_2</span> <span class=\"n\">GR</span> <span class=\"n\">GG</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n                          <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">GR</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">GR</span> <span class=\"bp\">∈</span> <span class=\"n\">R_opts</span> <span class=\"n\">GG.snd</span><span class=\"o\">),</span> <span class=\"n\">GAR</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">GG.fst</span><span class=\"o\">,</span> <span class=\"n\">GR</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R_opts2_is_option_2</span> <span class=\"n\">GR</span> <span class=\"n\">GG</span> <span class=\"n\">h</span><span class=\"o\">))}</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">add_pair</span> <span class=\"o\">(</span><span class=\"n\">GG</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">×</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"o\">:=</span>\n  <span class=\"n\">DGC_2.fix</span> <span class=\"n\">add_help</span> <span class=\"n\">GG</span>\n\n<span class=\"c1\">-- Translate  `Game × Game → Game`  into  `Game → Game → Game` .</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">G1</span> <span class=\"n\">G2</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"o\">:=</span>  <span class=\"n\">add_pair</span> <span class=\"o\">(</span><span class=\"n\">G1</span><span class=\"o\">,</span> <span class=\"n\">G2</span><span class=\"o\">)</span>\n\n<span class=\"c1\">--noncomputable Game_has_add : has_add Game := ⟨ add ⟩</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">G1</span> <span class=\"bp\">`</span> <span class=\"bp\">+</span> <span class=\"bp\">`</span> <span class=\"n\">G2</span> <span class=\"o\">:=</span> <span class=\"n\">add</span> <span class=\"n\">G1</span> <span class=\"n\">G2</span>\n\n<span class=\"c1\">-- Lemmas that can be used for simplification.</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">L_opts_of_add</span> <span class=\"o\">(</span><span class=\"n\">G1</span> <span class=\"n\">G2</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">L_opts</span> <span class=\"o\">(</span><span class=\"n\">G1</span> <span class=\"bp\">+</span> <span class=\"n\">G2</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"o\">{</span><span class=\"n\">GAL</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">GL</span> <span class=\"bp\">∈</span> <span class=\"n\">L_opts</span> <span class=\"n\">G1</span><span class=\"o\">),</span> <span class=\"n\">GAL</span> <span class=\"bp\">=</span> <span class=\"n\">GL</span> <span class=\"bp\">+</span> <span class=\"n\">G2</span><span class=\"o\">)</span>\n                <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">GL</span> <span class=\"bp\">∈</span> <span class=\"n\">L_opts</span> <span class=\"n\">G2</span><span class=\"o\">),</span> <span class=\"n\">GAL</span> <span class=\"bp\">=</span> <span class=\"n\">G1</span> <span class=\"bp\">+</span> <span class=\"n\">GL</span><span class=\"o\">)}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">add_pair</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">DGC_2.fix_eq</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">add_help</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">R_opts_of_add</span> <span class=\"o\">(</span><span class=\"n\">G1</span> <span class=\"n\">G2</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R_opts</span> <span class=\"o\">(</span><span class=\"n\">G1</span> <span class=\"bp\">+</span> <span class=\"n\">G2</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"o\">{</span><span class=\"n\">GAR</span> <span class=\"o\">:</span> <span class=\"n\">Game</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">GR</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">GR</span> <span class=\"bp\">∈</span> <span class=\"n\">R_opts</span> <span class=\"n\">G1</span><span class=\"o\">),</span> <span class=\"n\">GAR</span> <span class=\"bp\">=</span> <span class=\"n\">GR</span> <span class=\"bp\">+</span> <span class=\"n\">G2</span><span class=\"o\">)</span>\n                <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">GR</span> <span class=\"o\">:</span> <span class=\"n\">Game</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">GR</span> <span class=\"bp\">∈</span> <span class=\"n\">R_opts</span> <span class=\"n\">G2</span><span class=\"o\">),</span> <span class=\"n\">GAR</span> <span class=\"bp\">=</span> <span class=\"n\">G1</span> <span class=\"bp\">+</span> <span class=\"n\">GR</span><span class=\"o\">)}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">add_pair</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">DGC_2.fix_eq</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">add_help</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">G0</span> <span class=\"bp\">+</span> <span class=\"n\">G0</span> <span class=\"bp\">=</span> <span class=\"n\">G0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">eq_LR</span><span class=\"o\">,</span> <span class=\"n\">unfold</span> <span class=\"n\">G0</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>(then I go on to prove facts on addition).<br>\nThe proofs can probably be considerably simplified...</p>",
        "id": 281169003,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1651676721
    },
    {
        "content": "<p>I don't believe defining games in terms of sets of games works in type theory</p>",
        "id": 281190600,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651685432
    },
    {
        "content": "<p>Otherwise you could define a game whose left set is the set of all games</p>",
        "id": 281190695,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651685476
    },
    {
        "content": "<p>And that's an absurd</p>",
        "id": 281190723,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651685489
    },
    {
        "content": "<p>Mathlib already has pre-games, and it defines them via type indexed families of pre-games</p>",
        "id": 281190866,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651685533
    },
    {
        "content": "<p>Crucially the indexing types must belong to universe <code>u</code>, while the type of pre-games is in universe <code>u+1</code>, which avoids the contradiction</p>",
        "id": 281190971,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651685583
    },
    {
        "content": "<p>This has the annoyance that pre-games with equal left and right sets of games can still be different if the indexing types or the indexing itself are different, but I'm currently defining tbe quotient of pre-games by extensionality to overcome this</p>",
        "id": 281191283,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651685694
    },
    {
        "content": "<p>In surreals you have an equivalence of recursive equivalence like \"forall a, exists b, A_left a &lt;= B_left b\" to deal with this, and pSet has something similar - <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pSet.equiv/src\">src#pSet.equiv</a></p>",
        "id": 281191645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651685832
    },
    {
        "content": "<p>Pre-games already have a notion of a relabelling</p>",
        "id": 281191734,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651685863
    },
    {
        "content": "<p>I assume relabelling is a bit too strict of an equivalence for games though</p>",
        "id": 281191843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651685894
    },
    {
        "content": "<p>And existence of a relabelling almost corresponds to ZFC equality of pre-games</p>",
        "id": 281191852,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651685898
    },
    {
        "content": "<p>Not quite because it assumes that you have multisets instead of sets</p>",
        "id": 281191889,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651685917
    },
    {
        "content": "<p>Of course, it's too strict for games</p>",
        "id": 281191918,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651685925
    },
    {
        "content": "<p>That's a quotient by antisymmetry</p>",
        "id": 281191965,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651685948
    },
    {
        "content": "<p>Not just structural equality</p>",
        "id": 281191980,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651685957
    },
    {
        "content": "<p>for pSet it's also not quite relabeling, because it needs to be relabeling where after the relabeling the elements are equivalent</p>",
        "id": 281192014,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651685976
    },
    {
        "content": "<p>or maybe that's part of relabeling</p>",
        "id": 281192041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651685988
    },
    {
        "content": "<p>I suppose pre-games don't have any quotient on them?</p>",
        "id": 281192176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651686028
    },
    {
        "content": "<p>that's what makes them pre-games</p>",
        "id": 281192187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651686037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/281190600\">said</a>:</p>\n<blockquote>\n<p>I don't believe defining games in terms of sets of games works in type theory</p>\n</blockquote>\n<p>That's the problem I had; this is why I resorted to axioms and constants to describe the set-up in a way that was as close as possible to Conway's definition.<br>\nNote that I wrote this code before I was aware that combinatorial games are present in mathlib. (And before I had any experience with Lean to speak of.)</p>",
        "id": 281192728,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1651686282
    },
    {
        "content": "<p>Regarding <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> 's point about loopy games, I believe the correct approach is to use a coinductive type instead of an inductive type but otherwise with the same definition. Because we would want to consider the <code>A -&gt; A</code> and <code>B -&gt; B</code> and <code>A -&gt; B -&gt; A</code> all be equivalent loopy games (there is only one infinite line of play)</p>",
        "id": 281192759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651686294
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/281106984\">said</a>:</p>\n<blockquote>\n<p><del>Moreover, you should be able to get rid of all the <code>relabelling</code> stuff.</del>(maybe not)<br>\n<a href=\"/user_uploads/3121/L64moCNIn-UwgFljzcq4Hsr8/image.png\">image.png</a></p>\n</blockquote>\n<p>I don't think that would get rid of the relabelling stuff. If you have a type of positions, then it stands that you can have two games that are exactly the same except they use a different type.</p>",
        "id": 281192948,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651686364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> using sets of games leads to the same paradoxes in set theory too. Well-foundedness is an essential component, and I believe Conway uses an informal description of transfinite induction in ONAG</p>",
        "id": 281193086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651686421
    },
    {
        "content": "<p>using inductive types is by far the easiest way to do this and get the right answer in CIC</p>",
        "id": 281193191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651686468
    },
    {
        "content": "<p>Doesn't set theory circumvent this by having games be a proper class?</p>",
        "id": 281193205,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651686473
    },
    {
        "content": "<p>In a way, Conway defines games as sets with two kinds of elements.</p>",
        "id": 281193326,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1651686517
    },
    {
        "content": "<p>And well-foundedness is sort of built-in (\"... all games arise in this way\"); alternatively, it is equivalent to the induction principle for games.</p>",
        "id": 281193445,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1651686580
    },
    {
        "content": "<p>If one wants to build the theory within set theory, then the games are not a set, but a proper class (which is not a problem).</p>",
        "id": 281193710,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1651686700
    },
    {
        "content": "<p>An element of <code>set α</code> in Lean is actually a predicate, which may be an actual set or a proper class, if <code>α</code> is in a higher universe; for example when <code>α</code> is <code>pgame.{u} : Type (u+1)</code>, <code>s : set α</code> is small (an \"actual set\" in <code>Type u</code>) if <code>subtype s</code> is equipotent to some type in <code>Type u</code>, and a proper class otherwise.</p>\n<p>Conway defines games/numbers like how you define the von Neumann universe or constructible universe in set theory, implicitly using transfinite induction; at each step you can only use games/numbers you already constructed. In Lean, this smallness is guaranteed by using indexing types in <code>Type u</code> for left and right options.</p>\n<p>The point of my new definition is: if we have to use indexing types, why not use a single indexing type for all positions? It also makes some definitions simpler, e.g. negation, and impartial games would simply be those with L=R.</p>\n<p>I don't think we need force isomorphic games be equal using coinductive types or something like Aczel's anti-foundation axiom; there are many different types of games as you can see in <em>Winning Ways</em> and it's easy to find coincidences where the games are CGT equivalent or even the game graphs are the same, but they don't have to be the same <code>pgame</code>; it would be enough to prove by induction that you can substitute one with the other without changing the CGT value (equivalence class) of the whole game.</p>",
        "id": 281199763,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651689159
    },
    {
        "content": "<p>Describing what it means for a game to be well founded is approximately as complicated as defining <code>pgame</code> in the first place though</p>",
        "id": 281200449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651689450
    },
    {
        "content": "<p>you basically have to say that a game has a <code>pgame</code> that surjects onto it in a certain sense</p>",
        "id": 281200504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651689477
    },
    {
        "content": "<p>I think that your general concept of game-graphs are useful but distinct from either the inductive or coinductive concept of <code>pgame</code></p>",
        "id": 281200759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651689591
    },
    {
        "content": "<p>You need the coinductive analogue of <code>game</code> to provide the values of loopy games and game-graphs</p>",
        "id": 281201051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651689701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/281200449\">said</a>:</p>\n<blockquote>\n<p>Describing what it means for a game to be well founded is approximately as complicated as defining <code>pgame</code> in the first place though</p>\n</blockquote>\n<p>Is this complicated, or problematic, or you mean something else?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">pgame</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">pos</span> <span class=\"bp\">→</span> <span class=\"n\">pos</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"c\">/-</span><span class=\"cm\"> L x y means x is a option at position y for left -/</span>\n<span class=\"o\">(</span><span class=\"n\">wf</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"n\">pos</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 281201403,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651689836
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame/src\">src#pgame</a></p>",
        "id": 281201933,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651690032
    },
    {
        "content": "<p>I think it's more complicated</p>",
        "id": 281201974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651690049
    },
    {
        "content": "<p>the fact that you can't pattern match on it and have to carry <code>start</code> around seems like it will make proofs harder</p>",
        "id": 281202088,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651690088
    },
    {
        "content": "<p>for graphs you usually don't designate a start vertex in the structure itself</p>",
        "id": 281202167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651690129
    },
    {
        "content": "<p>Also, you might not want to assume the whole type is well founded, only the elements under <code>start</code></p>",
        "id": 281202261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651690176
    },
    {
        "content": "<p>that is <code>acc (λ x y, L x y ∨ R x y) start</code></p>",
        "id": 281202290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651690195
    },
    {
        "content": "<p>You can remove unreachable elements and get an equivalent game.</p>",
        "id": 281202363,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651690210
    },
    {
        "content": "<p>sure, but those kinds of arguments are messy in lean</p>",
        "id": 281202410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1651690239
    },
    {
        "content": "<p>I'll definitely try to replicate current development in mathlib to see how easy my definition is to work with.</p>",
        "id": 281202417,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651690242
    },
    {
        "content": "<p>You may try the two <code>sorry</code>s in my code posted above, I won't get to them until 6pm (~3 hours later).</p>",
        "id": 281202548,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651690301
    },
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/well_founded.well_founded_iff_has_min\">docs#well_founded.well_founded_iff_has_min</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.well_founded_on_iff_no_descending_seq\">docs#set.well_founded_on_iff_no_descending_seq</a> will be handy. (The second uses dependent choice but mathlib is fine with it.)</p>",
        "id": 281203346,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651690644
    },
    {
        "content": "<p>I find that Lean generally makes it so that it's harder to use that characterization of well foundedness</p>",
        "id": 281209882,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651693588
    },
    {
        "content": "<p>Usually, if everything is setup right, you can do bare induction and get what you want more easily</p>",
        "id": 281209926,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651693613
    },
    {
        "content": "<p>This is just my opinion though</p>",
        "id": 281209992,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651693653
    },
    {
        "content": "<p>I've defined ≤ and showed it's reflexive using the new definition and I'll call it a day; more to come!<br>\n<a href=\"https://gist.github.com/alreadydone/cdf39674c4bec9a8f298e43024771621\">https://gist.github.com/alreadydone/cdf39674c4bec9a8f298e43024771621</a></p>",
        "id": 281256112,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651730650
    },
    {
        "content": "<p>Are you planning for this to replace the current definition in <code>mathlib</code>? Or is this just a side thing?</p>",
        "id": 281302368,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651759135
    },
    {
        "content": "<p>What you're doing seems nice but I feel like refactoring <code>pgame</code> with this would be a ton of work with little (if any) benefit</p>",
        "id": 281302398,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651759161
    },
    {
        "content": "<p>I believe my definition is the most natural when dealing with concrete games (that are described by which moves are possible at each position) and loopy games, and realizing addition as juxtaposition of games is really nice. Currently it's in exploration phase, and if the mathlib definition turns out to be superior for some purposes we may work on providing some glues between the two.</p>",
        "id": 281315721,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651764885
    },
    {
        "content": "<p>How would multiplication work? Don't you need well foundedness to define that?</p>",
        "id": 281337320,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651774166
    },
    {
        "content": "<p>Which wouldn't quite work on loopy games</p>",
        "id": 281337344,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1651774177
    },
    {
        "content": "<p>Yeah, I don't think multiplication is well-behaved even for well-founded games (and there are at least two definitions of ≤  as the loopy games slides show, and there is the misère play convention (first player without move wins) where there isn't a nice notion of ≤). Multiplication won't respect equivalence unless restricted to surreals. I expect <code>of_L_R</code> in <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/281148141\">my earlier post</a> will be required to define multiplication. I haven't thought about surreals much, but I have done some computations in <code>On₂</code>, the (algebraically closed, etc.) field of characteristic two formed by all ordinals by considering them as impartial games, where multiplication is defined like in the surreal case. I think <em>Winning Ways</em> also defined multiplication for more general games that's well-behaved under certain conditions, but I have to look them up.</p>",
        "id": 281343512,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651777130
    },
    {
        "content": "<p>I think it would be fine to have an alternative definition in parallel, if there is appropriate glue.</p>",
        "id": 281379720,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651800342
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.state\">docs#pgame.state</a> already looks pretty similar</p>",
        "id": 281380407,
        "sender_full_name": "Reid Barton",
        "timestamp": 1651801214
    },
    {
        "content": "<p>I'd forgotten about that one, even though the domineering example I built uses it.</p>",
        "id": 281381358,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651802468
    },
    {
        "content": "<p>For lots of concrete games the turn bound is easy and convenient, and in practice how you might be proving well-foundedness anyway.</p>",
        "id": 281381491,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651802631
    },
    {
        "content": "<p>I think it would be great to have more actual concrete games! Hex, dots-and-boxes, and go would all be lovely (some amount of fitting square pegs in round holes to treat these all as Conway style games, but they could be described other ways, too).</p>",
        "id": 281381705,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651802879
    },
    {
        "content": "<p>My paper on dots and boxes describes how at a professional level it has little to do with combinatorial game theory, but strings and coins (:= dots and boxes with the normal play rule rather than \"most boxes is the winner\") would be lovely :-)</p>",
        "id": 281399288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651818929
    },
    {
        "content": "<p>Update: I've shown <code>game</code> is a <code>ordered_add_comm_group</code> under the new definition within 374 lines: <a href=\"https://gist.github.com/alreadydone/cdf39674c4bec9a8f298e43024771621\">https://gist.github.com/alreadydone/cdf39674c4bec9a8f298e43024771621</a></p>",
        "id": 281563382,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651961807
    },
    {
        "content": "<p>Updates: I have been able to show the well-foundedness of the game constructed from left/right options (formerly called <code>of_L_R</code> and now simply called <code>of</code>); see the end of <a href=\"https://gist.github.com/alreadydone/93e25ccda07b0c9c1ef2b40efedf3339\">https://gist.github.com/alreadydone/93e25ccda07b0c9c1ef2b40efedf3339</a>. However, at the same time I came up with an explicit construction of a type of positions for the product of two games (has anyone written about it before?) and plan to use it instead of <code>of</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">pgame</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g₁</span> <span class=\"n\">g₂</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"n\">tree3</span> <span class=\"o\">(</span><span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"n\">g₁.pos</span> <span class=\"bp\">×</span> <span class=\"n\">g₂.pos</span><span class=\"o\">),</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> could also potentially be `multiset (bool × g₁.pos × g₂.pos)`; each element</span>\n<span class=\"cm\">       of the multiset is seen as an expression of the form +x*y or -x*y, where x is a position in g₁ and y a position in g₂. -/</span>\n    <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">mul_rel</span> <span class=\"n\">tt</span> <span class=\"n\">g₁.L</span> <span class=\"n\">g₂.L</span> <span class=\"bp\">∪</span> <span class=\"n\">mul_rel</span> <span class=\"n\">ff</span> <span class=\"n\">g₁.L</span> <span class=\"n\">g₂.R</span> <span class=\"bp\">∪</span>\n                  <span class=\"n\">mul_rel</span> <span class=\"n\">ff</span> <span class=\"n\">g₁.R</span> <span class=\"n\">g₂.L</span> <span class=\"bp\">∪</span> <span class=\"n\">mul_rel</span> <span class=\"n\">tt</span> <span class=\"n\">g₁.R</span> <span class=\"n\">g₂.R</span><span class=\"o\">),</span>\n    <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">mul_rel</span> <span class=\"n\">ff</span> <span class=\"n\">g₁.L</span> <span class=\"n\">g₂.L</span> <span class=\"bp\">∪</span> <span class=\"n\">mul_rel</span> <span class=\"n\">tt</span> <span class=\"n\">g₁.L</span> <span class=\"n\">g₂.R</span> <span class=\"bp\">∪</span>\n                  <span class=\"n\">mul_rel</span> <span class=\"n\">tt</span> <span class=\"n\">g₁.R</span> <span class=\"n\">g₂.L</span> <span class=\"bp\">∪</span> <span class=\"n\">mul_rel</span> <span class=\"n\">ff</span> <span class=\"n\">g₁.R</span> <span class=\"n\">g₂.R</span><span class=\"o\">),</span>\n    <span class=\"n\">wf</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">start</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"n\">g₁.start</span><span class=\"o\">,</span> <span class=\"n\">g₂.start</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>See the beginning of the gist above for the full code.</p>\n<p>I like the symmetric form of the definition of L and R fields. It works for surreal multiplication, but presumably not for multiplying a positive game with an arbitrary game, which I'll worry about later. (I'm currently experimenting with <code>jux : (fin 3 → tree3) → tree3</code> instead of <code>jux : tree3 → tree3 → tree3 → tree3</code>.)</p>\n<p>To fill in the <code>sorry</code> above, I basically need to prove the termination of a version of the hydra game; basically, the options of the product of two games are each a sum of three products, that is to say if you cut a head of the hydra, it grows back three heads at some lower levels (\"less than\" the original product w.r.t. the &lt; relation that is the transitive closure of (sgn, xL/xR, y), (sgn, x, yL/yR)  &lt; (sgn', x, y)). I realized I need some form of Kőnig's lemma and Googled with the keywords \"Kőnig hydra\", and <a href=\"https://mathoverflow.net/questions/192297/a-well-founded-relation-on-lists\">this MO problem</a> came up. After browsing the answers, I found that <span class=\"user-mention\" data-user-id=\"285970\">@Peter LeFanu Lumsdaine</span> 's approach seems simpler than setting up the stage to apply Kőnig's lemma, so that's what I'm gonna formalize now. The statement is as below (with multiset instead of list); it doesn't seem to show up when defining multiplication via Conway induction as done in mathlib.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.multiset.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Cut one head `a` of a hydra `s`, and it grows back an arbitrary finite number of</span>\n<span class=\"sd\">  heads at \"lower levels\" than the head cut. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">cut_rel</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">cut</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a'</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">a'</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">cut_rel</span> <span class=\"o\">(</span><span class=\"n\">s.erase</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">well_founded.cut_rel</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"o\">(</span><span class=\"n\">cut_rel</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Since the line count is growing large, I'll probably split this project into multiple files and create a folder (like <code>set_theory/game_new</code>) in mathlib to contain it and create a branch on github. If people find it easier to work with this new definition, we may continue to add materials to that folder and gradually deprecate the old one.</p>",
        "id": 281909238,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652234316
    },
    {
        "content": "<p>I'm still really iffy on this. The way I see it, your approach has the following pros and cons:</p>\n<p><strong>Pros:</strong></p>\n<ul>\n<li>Allows a natural extension to loopy games.</li>\n</ul>\n<p><strong>Cons:</strong></p>\n<ul>\n<li>The induction arguments become considerably harder.</li>\n<li>Much worse definitional equalities (since you force a game and all subsequent moves to be part of the same graph).</li>\n<li>The notion of \"relabellings\" becomes much more complicated.</li>\n<li>The refactor would take a large amount of work, and to me it's not even clear that everything would work out nicely.</li>\n<li>This deviates from Conway's approach even more radically than our current approach (and supposedly, that's what we're trying to formalize).</li>\n</ul>\n<p>Call it force of habit, but I'd rather stick to what we have unless there's other substantial reasons to switch, or unless there's a substantial theory on loopy games that we can formalize using your definition.</p>",
        "id": 281914452,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652240028
    },
    {
        "content": "<p>To give a basic example of something that would break in a way that's hard to fix: <code>ordinal.to_pgame</code>. Currently, a lot of the results about it induct on the ordinal, which is possible because left moves of <code>o.to_pgame</code> are <strong>exactly</strong> <code>a.to_pgame</code> for <code>a &lt; o</code>. With your definition, this wouldn't be the case, so you'd need to consider relabellings in pretty much all of the proofs.</p>",
        "id": 281914719,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652240309
    },
    {
        "content": "<p>Pretty much this same reasoning extends to <code>nim</code>.</p>",
        "id": 281914727,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652240317
    },
    {
        "content": "<p>set_theory.game.ordinal is a short file. Would it convince you it's a viable approach if I reproduce the results therein? Your \"relabelling\" is basically my <code>iso</code>, which I showed preserves <code>Rlose</code> (i.e. 0 ≤ g) in <code>map_iso_Rlose_iff</code>, and use it in the following lemmas to show commutativity, associativity, etc. I later defined a structure <code>iso</code> which is quite simple:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">iso</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">g'</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"o\">:</span> <span class=\"n\">g.pos</span> <span class=\"bp\">≃</span> <span class=\"n\">g'.pos</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">inv_image</span> <span class=\"n\">g'.L</span> <span class=\"n\">pos</span> <span class=\"bp\">=</span> <span class=\"n\">g.L</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">inv_image</span> <span class=\"n\">g'.R</span> <span class=\"n\">pos</span> <span class=\"bp\">=</span> <span class=\"n\">g.R</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm puzzled by your comment that \"induction arguments become considerably harder\" and \"much worse  definitional equalities\". Can you elaborate and maybe give an example in my code, or have I not got to the point where they'll be problematic? My experience has been that induction/recursion <strong>becomes unnecessary</strong> in many places with my approach. It's a one-off thing to prove well-foundedness in various constructions, and I wouldn't call them hard except for multiplication. Contrary to your comment, I think one advantage of my approach is that addition, negation, multiplication, and impartial games now have totally non-inductive definitions (is_numeric can also be defined by quantifying over all positions using the inductively defined Lwin); when defining Rlose/Lwin, I used induction on positions instead of games. </p>\n<p>I agree it's a deviation from Conway's approach but I'd argue using indexing types for left/right options is also a deviation, and necessitates relabelling which makes things inelegant (though using a ordinal-indexed union of games born by birthday x would be more inelegant). As I said before, the initial motivation of my definition is : \"if we have to use indexing types, why not use a single one?\" In general, I think we should choose what works best (like the filter approach to topology, or is_localization in mathlib), which can only be found out through experimentation. It would be great if more people like you are interested to join the effort. I think I currently have all the essential results in game.pgame and game.basic except for <code>mul</code> and <code>inv</code>, and those are my ongoing work. My plan is to gradually work through all files under <code>game</code> and <code>surreal</code>, which seem to contain everything about CGT in mathlib and don't seem that massive, though I think I probably don't have the energy to complete a refactor without other people's interest and help. So I think it's a sensible approach to add another folder, so people can choose whichever approach that suits their purpose when they develop CGT and/or contribute to mathlib. I'd like to keep the same <code>pgame</code>, <code>game</code> etc. namespace (which shouldn't be a problem if you don't import files from both development), but I expect some linters may complain.</p>",
        "id": 281918056,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652244282
    },
    {
        "content": "<p>For ordinals or nimbers, we can actually realize them simply as different starting positions in the \"same\" game, with all ordinals in the universe as positions, L = (&lt;), and R = (&lt;) for nimbers and empty for ordinals; just the <code>start</code> needs to be changed to the ordinal. This is at the expense of elevating the game from <code>pgame.{u}</code> to <code>pgame.{u+1}</code> though. The larger ordinals are unreachable in the game, but this is the flexibility offered by my approach and not a bug (e.g. the extraneous positions also occur in my definition of multiplication).</p>",
        "id": 281920280,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652246756
    },
    {
        "content": "<p>I would be interested in seeing a concrete game translated to this formalism, too, e.g. domineering.</p>",
        "id": 281923172,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652250087
    },
    {
        "content": "<p>I think that this approach makes more sense without the <code>wf</code>field</p>",
        "id": 281926010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652252713
    },
    {
        "content": "<p>The fact that you have to universe-bump is a pretty fundamental difference</p>",
        "id": 281926098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652252789
    },
    {
        "content": "<p>You only have to universe bump if you want to fit all ordinals in, don't you? There'll be some <code>u</code>-small ordinals trick otherwise?</p>",
        "id": 281930595,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652256197
    },
    {
        "content": "<p>The current approach <a href=\"https://github.com/leanprover-community/mathlib/blob/df9683ca3c237d11920a3de8dfab2cc9dc2f8214/src/set_theory/game/ordinal.lean#L33\">uses <code>o.out.α</code></a> (invokes choice) which seems to be the only option to lower the universe.</p>",
        "id": 281930911,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652256460
    },
    {
        "content": "<p>note that <code>ordinal</code> is rampantly choice-assuming. It would need a very significant rewrite in order to make it not need choice and many theorems would not hold</p>",
        "id": 281936113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652259637
    },
    {
        "content": "<p>It's usually possible to avoid using <code>o.out</code> but there isn't much gain to be had in doing so because choice already appears ten times in the dependencies</p>",
        "id": 281936204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652259695
    },
    {
        "content": "<p>Note that the definition of <code>to_pgame</code> is actually computable; the reason for the <code>noncomputable!</code> is because one of the auxiliary definitions lean creates is unexpectedly noncomputable and it causes a weird error message</p>",
        "id": 281937088,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652260237
    },
    {
        "content": "<p>Here's a definition that avoids <code>noncomputable!</code></p>",
        "id": 281938131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652260856
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Converts a well order into the corresponding pre-game. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">well_order_to_pgame</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_well_founded</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">⟨{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">has_well_founded.r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">},</span> <span class=\"n\">pempty</span><span class=\"o\">,</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">y.2</span><span class=\"o\">,</span> <span class=\"n\">well_order_to_pgame</span> <span class=\"n\">y.1</span><span class=\"o\">,</span> <span class=\"n\">pempty.elim</span><span class=\"o\">⟩</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span> <span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.assumption</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Converts an ordinal into the corresponding pre-game. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_pgame</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">o.out.α</span><span class=\"o\">,</span> <span class=\"n\">pempty</span><span class=\"o\">,</span> <span class=\"n\">well_order_to_pgame</span><span class=\"o\">,</span> <span class=\"n\">pempty.elim</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 281938137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652260859
    },
    {
        "content": "<p>Note that you can define loopy games in the same style as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame\">docs#pgame</a> by writing a coinductive definition instead of an inductive one. Here's a sketch:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.pfunctor.univariate.M</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.game.pgame</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">loopy_game</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">pfunctor.M</span> <span class=\"o\">⟨</span><span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">×</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">ulift.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p.fst</span> <span class=\"bp\">⊕</span> <span class=\"n\">p.snd</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pgame.loopy_game</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">loopy_game.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">pfunctor.M.corec</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"o\">⟨(</span><span class=\"n\">G.left_moves</span><span class=\"o\">,</span> <span class=\"n\">G.right_moves</span><span class=\"o\">),</span>\n                          <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">sum.elim</span> <span class=\"n\">G.move_left</span> <span class=\"n\">G.move_right</span> <span class=\"n\">p.down</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">loopy_game</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">loopy_game.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">left_moves</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">G.head.fst</span>\n<span class=\"kd\">def</span> <span class=\"n\">right_moves</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">G.head.snd</span>\n<span class=\"kd\">def</span> <span class=\"n\">move_left</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">left_moves</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">loopy_game</span> <span class=\"o\">:=</span> <span class=\"n\">G.children</span> <span class=\"o\">(</span><span class=\"n\">ulift.up</span> <span class=\"o\">(</span><span class=\"n\">sum.inl</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">move_right</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">right_moves</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">loopy_game</span> <span class=\"o\">:=</span> <span class=\"n\">G.children</span> <span class=\"o\">(</span><span class=\"n\">ulift.up</span> <span class=\"o\">(</span><span class=\"n\">sum.inr</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">is_wf</span> <span class=\"o\">:</span> <span class=\"n\">loopy_game.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">sup</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">loopy_game</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G.left_moves</span><span class=\"o\">,</span> <span class=\"n\">is_wf</span> <span class=\"o\">(</span><span class=\"n\">G.move_left</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">G.right_moves</span><span class=\"o\">,</span> <span class=\"n\">is_wf</span> <span class=\"o\">(</span><span class=\"n\">G.move_right</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n  <span class=\"n\">is_wf</span> <span class=\"n\">G</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_wf.pgame</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_wf</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span> <span class=\"o\">:=</span> <span class=\"n\">h.rec</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ls</span> <span class=\"n\">rs</span><span class=\"o\">,</span> <span class=\"n\">pgame.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ls</span> <span class=\"n\">rs</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">loopy_game</span>\n</code></pre></div>\n<p>Probably you could go further and show that <code>pgame</code> is equivalent to the subtype of well-founded loopy games in this language</p>\n<p>The code above essentially defines <code>loopy_game</code> to be a terminal coalgebra for a certain polynomial functor. Junyan's definition instead looks at the type of <em>all</em> (well-founded) pointed coalgebras. This makes a lot of sense if we want to construct explicit elements of <code>loopy_game</code> -- normally we define elements of a coinductive type by corecursion, i.e. by constructing explicit coalgebras. (Actually this is analogous to how we deal with bisimulation in mathlib: instead of defining an indexed coinductive prop of bisimulations, we take a bisimulation to be some coalgebra for the same functor.)</p>\n<p>I think it's not clear which of these two approaches to loopy games is the best, but for well-founded games I don't understand what the problem with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame\">docs#pgame</a> is (other than it being difficult to construct concrete games, but this problem seems to be solved by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.state\">docs#pgame.state</a>)</p>",
        "id": 281975537,
        "sender_full_name": "David Wärn",
        "timestamp": 1652280087
    },
    {
        "content": "<p>Thanks but I'm yet to read more about pfunctor and coinduction. From my limited understanding about bisimulation, it seems to be a better and more general notion of strong equivalence between games than relabelling. Here strong equivalence means it guarantees substitutability (in sums and as options) in any (loopy or wf) game under both the normal and misere play convention. (If you want to see more theory about loopy and misere games, there are whole chapters in Aaron Siegel's <em>Combinatorial Game Theory</em>.</p>\n<p>As evidence of better defeq with my approach, see <a href=\"https://gist.github.com/alreadydone/cdf39674c4bec9a8f298e43024771621\">lines 135-137</a>: <code>neg_zero</code> and <code>neg_neg</code> are propositional equalities in mathlib; with my approach the former is defeq in Lean 3, and the latter (I think) is defeq in Lean 4 due to structure eta being defeq. <code>neg_add</code> is only true up to relabelling in mathlib; with my approach it's also defeq (which is \"abused\" in <code>add_le_add_iff_Rlose</code>, for example).</p>",
        "id": 281996099,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652288360
    },
    {
        "content": "<p>A bunch of equalities in <code>pgame</code> might become def-eq in Lean 4, but I'm unsure to what extent that will help.</p>",
        "id": 282054150,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652325357
    },
    {
        "content": "<p>It's very interesting that you're able to avoid induction in many circumstances. It's also interesting that you get better definitional equalities in these basic definitions. That speaks to some mathematical elegance in your approach. That said, there are a lot of induction proofs scattered throughout, some quite hard and involved, and I'm still not convinced that your approach can avoid all of them. And there's still the problem of definitional equalities in inductively defined families of games like <code>ordinal.to_pgame</code> and <code>nim</code>.</p>\n<p>I very strongly disagree with your approach of bumping the universe of <code>ordinal.to_pgame</code>. This sort of universe bumping can lead to very hard to solve problems later down the line. I'm interested in seeing how the <code>ordinal.lean</code> file would work with your approach without said universe bumping.</p>\n<p>I could help with your new definition, but I've yet to see benefits large enough to justify all the work that would be needed for this refactoring. If you only want loopy games, then the coinductive approach seems to be by far the smoothest alternative given the current state of the library.</p>",
        "id": 282054730,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652326195
    },
    {
        "content": "<p>I really don't want to come off as mean, because I can imagine that you've been working for hours on this, and I don't want to give the impression that said work is worthless or uninteresting. I'd just like to more carefully evaluate what's better for mathlib in the short and long run.</p>",
        "id": 282054832,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652326304
    },
    {
        "content": "<p>Also, I'm quite biased given my recent heavy involvement on the mathlib pgame code base. So I'd like to hear opinions from others too.</p>",
        "id": 282054935,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652326442
    },
    {
        "content": "<p>After this <code>&lt;</code> refactor, there's another pretty big refactor I want to do</p>",
        "id": 282370552,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652559947
    },
    {
        "content": "<p>We currently have a lot of <code>congr</code> lemmas for the different relations, and even then, proving inequalities is a total hassle</p>",
        "id": 282370598,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652559972
    },
    {
        "content": "<p>This could be made way easier if we defined <code>game</code> earlier</p>",
        "id": 282370606,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652560001
    },
    {
        "content": "<p>Then, to prove an inequality on <code>pgame</code>, we could simply <code>change</code> it into the def-eq inequality on <code>game</code>, and use a few <code>rw</code>s</p>",
        "id": 282370634,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652560048
    },
    {
        "content": "<p>My latest thoughts: although I can provide an explicit model for the positions in the multiplication of two games, it doesn't seem to simplify any proofs, unlike in the addition case, so I probably won't open a PR for this approach in the near future. I will continue to explore the approach for concrete games, loopy games, and ordinals, when I have the leisure. I have yet to understand the coinductive approach to loopy games; for example, how would I construct a <code>loopy_game</code> from my <code>pos, L, R</code> and vice versa?</p>\n<p>I might soon PR some work related to well-foundedness that has arisen from this endeavour, including the termination of the hydra game, which provides one way to show the well-foundedness of the induction for properties of surreal multiplication in the notes of Schleicher--Stoll; namely, if you consider the arguments of P1(x,y), P2(x1,x2,y) and P4(x,y1,y2) as multisets {x,y}, {x1,x2,y}, and {x,y1,y2}, then each of P1, P2, P4 is deduced from P1, P2, P4 with smaller argument multisets under the <code>cut_expand</code> relation. The proof of termination is actually pretty elegant using <code>acc</code>; interestingly it uses the <code>add_rel</code> for game addition.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cut_expand</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a'</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">a'</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">s'</span> <span class=\"bp\">=</span> <span class=\"n\">s.erase</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 282379832,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652574260
    },
    {
        "content": "<p>If your <code>cut_expand</code> approach works, that would be super elegant</p>",
        "id": 282382506,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652578743
    },
    {
        "content": "<p>Well, it might be a bit inconvenient to set up, since P1, P2, P4 are meant to have a fixed amount of arguments</p>",
        "id": 282382829,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652579347
    },
    {
        "content": "<p>So you might need to induct on a generic multiset <code>s</code> and make the inductive hypotheses \"if <code>{x, y}</code> is less than <code>s</code> then <code>P1</code>,  ...\"</p>",
        "id": 282382848,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652579399
    },
    {
        "content": "<p>On the topic of relabellings and extensionality</p>",
        "id": 282387707,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652587329
    },
    {
        "content": "<p>I wonder if relabellings are even useful to begin with</p>",
        "id": 282387711,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652587347
    },
    {
        "content": "<p>Just from reading the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pSet.equiv\">docs#pSet.equiv</a>, it seems like the same amount of work to prove two games are relabellings and to prove they're extensionally equal</p>",
        "id": 282387722,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652587382
    },
    {
        "content": "<p>If this is the case, then surely we don't need <code>relabelling</code>s at all?</p>",
        "id": 282387755,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652587401
    },
    {
        "content": "<p>On an unrelated note, I hadn't ever noticed just how similar <code>pgame</code> and <code>pSet</code> are</p>",
        "id": 282387925,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652587676
    },
    {
        "content": "<p><code>pSet</code> can very well be called the unary version of <code>pgame</code></p>",
        "id": 282387966,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652587685
    },
    {
        "content": "<p>Which I guess is to be expected, ZFC games are constructed almost the same way as ZFC sets, just twice</p>",
        "id": 282387968,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652587715
    },
    {
        "content": "<p>I'm going to try to get rid of <code>relabelling</code> in favor of <code>identical</code>, which actually describes extensionality</p>",
        "id": 282388582,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652588886
    },
    {
        "content": "<p>If proofs become no more complicated than they were before, then to me that suggests that there's no need for <code>relabelling</code> at all</p>",
        "id": 282388584,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652588902
    },
    {
        "content": "<p>This is my idea:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">`identical x y` says that `x` and `y` are extensionally the same game. Specifically, for every move</span>\n<span class=\"sd\">in `x` there's an inductively `identical` move for `y`, and viceversa. Compare to `pSet.equiv`.</span>\n\n<span class=\"sd\">In ZFC, identical games would indeed be the same games.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">identical</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Lxy</span> <span class=\"o\">:</span> <span class=\"n\">x.left_moves</span> <span class=\"bp\">→</span> <span class=\"n\">y.left_moves</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Lyx</span> <span class=\"o\">:</span> <span class=\"n\">y.left_moves</span> <span class=\"bp\">→</span> <span class=\"n\">x.left_moves</span><span class=\"o\">)</span>\n         <span class=\"o\">(</span><span class=\"n\">Rxy</span> <span class=\"o\">:</span> <span class=\"n\">x.right_moves</span> <span class=\"bp\">→</span> <span class=\"n\">y.right_moves</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Ryx</span> <span class=\"o\">:</span> <span class=\"n\">y.right_moves</span> <span class=\"bp\">→</span> <span class=\"n\">x.right_moves</span><span class=\"o\">),</span>\n         <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">identical</span> <span class=\"o\">(</span><span class=\"n\">x.move_left</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y.move_left</span> <span class=\"o\">(</span><span class=\"n\">Lxy</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"bp\">→</span>\n         <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">identical</span> <span class=\"o\">(</span><span class=\"n\">y.move_left</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x.move_left</span> <span class=\"o\">(</span><span class=\"n\">Lyx</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"bp\">→</span>\n         <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">identical</span> <span class=\"o\">(</span><span class=\"n\">x.move_right</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y.move_right</span> <span class=\"o\">(</span><span class=\"n\">Rxy</span> <span class=\"n\">j</span><span class=\"o\">)))</span> <span class=\"bp\">→</span>\n         <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">identical</span> <span class=\"o\">(</span><span class=\"n\">y.move_right</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x.move_right</span> <span class=\"o\">(</span><span class=\"n\">Ryx</span> <span class=\"n\">j</span><span class=\"o\">)))</span> <span class=\"bp\">→</span>\n       <span class=\"n\">identical</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>",
        "id": 282388738,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652589208
    },
    {
        "content": "<p>isn't that the <code>game</code> equivalence relation?</p>",
        "id": 282388876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652589438
    },
    {
        "content": "<p><code>game</code> is to <code>pgame</code> as <code>Set</code> is to <code>pSet</code></p>",
        "id": 282388922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652589484
    },
    {
        "content": "<p>(the similarity is not a coincidence, <code>pgame</code> was mostly a copy-paste-paste job)</p>",
        "id": 282388928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652589509
    },
    {
        "content": "<blockquote>\n<p>isn't that the game equivalence relation?</p>\n</blockquote>\n<p>Certainly not. g + -g, which can be arbitrarily complicated, is equivalent to 0 in <code>game</code></p>",
        "id": 282388932,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652589529
    },
    {
        "content": "<blockquote>\n<p>pSet can very well be called the unary version of pgame<br>\nWhich I guess is to be expected, ZFC games are constructed almost the same way as ZFC sets, just twice</p>\n</blockquote>\n<p>Yes, that's why I drew a parallel between Conway's construction of games and the von Neumann universe. The axiom of regularity/foundation says the von Neumann universe contains all the sets.</p>",
        "id": 282389022,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652589642
    },
    {
        "content": "<p><code>pSet.equiv</code> is a <code>Prop</code> though, are you sure you want to keep the data in <code>identical</code>?</p>",
        "id": 282389025,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652589660
    },
    {
        "content": "<p>it's also defined by recursion not induction</p>",
        "id": 282389032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652589677
    },
    {
        "content": "<p>I think this is the difference between <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.bijective\">docs#function.bijective</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv\">docs#equiv</a>; I wouldn't be surprised if both notions are useful</p>",
        "id": 282389073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652589734
    },
    {
        "content": "<blockquote>\n<p>Then, to prove an inequality on pgame, we could simply change it into the def-eq inequality on game, and use a few rws</p>\n</blockquote>\n<p>As mentioned in <a href=\"https://github.com/leanprover-community/mathlib/pull/13925#issuecomment-1126850423\">#13925</a>, I wonder whether this would be a nice application of the <code>norm_cast</code> (specifically <code>rw_mod_cast</code>) tactic. If that's the case, I think <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> can probably provide some guidance on how to write an \"extension\" or something for that tactic to apply to <code>pgame</code>s.</p>",
        "id": 282389284,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652590178
    },
    {
        "content": "<p>I don't think you need to write an extension or anything; you just mark the relevant theorems with the <code>@[norm_cast]</code> attribute</p>",
        "id": 282389436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652590377
    },
    {
        "content": "<p>What exactly is <code>restricted</code> supposed to mean?</p>",
        "id": 282390319,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652591807
    },
    {
        "content": "<p>My new definition of <code>identical</code> really resembles it</p>",
        "id": 282390325,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652591813
    },
    {
        "content": "<p>But I don't quite understand the docstring</p>",
        "id": 282390327,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652591819
    },
    {
        "content": "<p>Also, is <code>≡</code> in use in mathlib? I want to use that for <code>identical</code></p>",
        "id": 282390505,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652592039
    },
    {
        "content": "<p>It means what the docstring says: x has no more left moves and no less right moves than y. If you have fewer moves you are more likely to lose, so it implies x ≤ y: x is worse or equal for left than y.<br>\nIt's different from your definition because the maps are single sided: (L : x.left_moves → y.left_moves), not the other way around, (R : y.right_moves → x.right_moves), not the other way around.</p>",
        "id": 282390693,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652592376
    },
    {
        "content": "<p>From my reading of the paper, to utilize <code>rw_mod_cast</code> for <code>pgame</code>, it seems we need to do the following:</p>\n<ul>\n<li>Introduce a has_coe instance from pgame to game (seems necessary).</li>\n<li>write the <code>move</code> lemmas and mark them with <code>@[norm_cast]</code>: the quotient map (the cast) pgame → game respects add/neg/sub/zero</li>\n<li>write and mark the <code>elim</code> lemmas: &lt; ≤ ⧏ are preserved by the cast, plus <code>↑a = ↑b ↔ a ≈ b</code></li>\n<li><code>squash</code> lemmas should only be necessary when we have the casts pgame → pgame-mod-identical → game (maybe also for {x // x.numeric} → surreal → game and {x // x.numeric} → pgame → game?)</li>\n</ul>",
        "id": 282391038,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652593053
    },
    {
        "content": "<p>I proved that <code>x ≡ y</code> implies <code>restricted x y</code> (and of course, <code>restricted y x</code>)</p>",
        "id": 282391267,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652593455
    },
    {
        "content": "<p>I wonder if the converse is true?</p>",
        "id": 282391271,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652593462
    },
    {
        "content": "<p>That is, <code>restricted x y</code> and <code>restricted y x</code> imply <code>x ≡ y</code></p>",
        "id": 282391274,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652593474
    },
    {
        "content": "<p>I have just produced one of the goofiest proofs ever</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- If `w` is identical to `x` and `y` is identical to `z`, then `w + y` is identical to `x + z`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">identical.add_congr</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">w</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}},</span> <span class=\"n\">w</span> <span class=\"bp\">≡</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">≡</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">w</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">≡</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">z</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">wl</span><span class=\"o\">,</span> <span class=\"n\">wr</span><span class=\"o\">,</span> <span class=\"n\">wL</span><span class=\"o\">,</span> <span class=\"n\">wR</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">xl</span><span class=\"o\">,</span> <span class=\"n\">xr</span><span class=\"o\">,</span> <span class=\"n\">xL</span><span class=\"o\">,</span> <span class=\"n\">xR</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">yl</span><span class=\"o\">,</span> <span class=\"n\">yr</span><span class=\"o\">,</span> <span class=\"n\">yL</span><span class=\"o\">,</span> <span class=\"n\">yR</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">zl</span><span class=\"o\">,</span> <span class=\"n\">zr</span><span class=\"o\">,</span> <span class=\"n\">zL</span><span class=\"o\">,</span> <span class=\"n\">zR</span><span class=\"o\">⟩</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Lwx</span><span class=\"o\">,</span> <span class=\"n\">Lxw</span><span class=\"o\">,</span> <span class=\"n\">Rwx</span><span class=\"o\">,</span> <span class=\"n\">Rxw</span><span class=\"o\">,</span> <span class=\"n\">HLwx</span><span class=\"o\">,</span> <span class=\"n\">HLxw</span><span class=\"o\">,</span> <span class=\"n\">HRwx</span><span class=\"o\">,</span> <span class=\"n\">HRxw</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">Lyz</span><span class=\"o\">,</span> <span class=\"n\">Lzy</span><span class=\"o\">,</span> <span class=\"n\">Ryz</span><span class=\"o\">,</span> <span class=\"n\">Rzy</span><span class=\"o\">,</span> <span class=\"n\">HLyz</span><span class=\"o\">,</span> <span class=\"n\">HLzy</span><span class=\"o\">,</span> <span class=\"n\">HRyz</span><span class=\"o\">,</span> <span class=\"n\">HRzy</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">Hwx</span> <span class=\"o\">:</span> <span class=\"o\">⟨</span><span class=\"n\">wl</span><span class=\"o\">,</span> <span class=\"n\">wr</span><span class=\"o\">,</span> <span class=\"n\">wL</span><span class=\"o\">,</span> <span class=\"n\">wR</span><span class=\"o\">⟩</span> <span class=\"bp\">≡</span> <span class=\"o\">⟨</span><span class=\"n\">xl</span><span class=\"o\">,</span> <span class=\"n\">xr</span><span class=\"o\">,</span> <span class=\"n\">xL</span><span class=\"o\">,</span> <span class=\"n\">xR</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Lwx</span><span class=\"o\">,</span> <span class=\"n\">Lxw</span><span class=\"o\">,</span> <span class=\"n\">Rwx</span><span class=\"o\">,</span> <span class=\"n\">Rxw</span><span class=\"o\">,</span> <span class=\"n\">HLwx</span><span class=\"o\">,</span> <span class=\"n\">HLxw</span><span class=\"o\">,</span> <span class=\"n\">HRwx</span><span class=\"o\">,</span> <span class=\"n\">HRxw</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">let</span> <span class=\"n\">Hyz</span> <span class=\"o\">:</span> <span class=\"o\">⟨</span><span class=\"n\">yl</span><span class=\"o\">,</span> <span class=\"n\">yr</span><span class=\"o\">,</span> <span class=\"n\">yL</span><span class=\"o\">,</span> <span class=\"n\">yR</span><span class=\"o\">⟩</span> <span class=\"bp\">≡</span> <span class=\"o\">⟨</span><span class=\"n\">zl</span><span class=\"o\">,</span> <span class=\"n\">zr</span><span class=\"o\">,</span> <span class=\"n\">zL</span><span class=\"o\">,</span> <span class=\"n\">zR</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Lyz</span><span class=\"o\">,</span> <span class=\"n\">Lzy</span><span class=\"o\">,</span> <span class=\"n\">Ryz</span><span class=\"o\">,</span> <span class=\"n\">Rzy</span><span class=\"o\">,</span> <span class=\"n\">HLyz</span><span class=\"o\">,</span> <span class=\"n\">HLzy</span><span class=\"o\">,</span> <span class=\"n\">HRyz</span><span class=\"o\">,</span> <span class=\"n\">HRzy</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">fsplit</span><span class=\"bp\">;</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">|</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum.inl</span> <span class=\"o\">(</span><span class=\"n\">Lwx</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum.inr</span> <span class=\"o\">(</span><span class=\"n\">Lyz</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum.inl</span> <span class=\"o\">(</span><span class=\"n\">Lxw</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum.inr</span> <span class=\"o\">(</span><span class=\"n\">Lzy</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum.inl</span> <span class=\"o\">(</span><span class=\"n\">Rwx</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum.inr</span> <span class=\"o\">(</span><span class=\"n\">Ryz</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum.inl</span> <span class=\"o\">(</span><span class=\"n\">Rxw</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum.inr</span> <span class=\"o\">(</span><span class=\"n\">Rzy</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span><span class=\"n\">dsimp</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">HLwx</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">add_congr</span> <span class=\"n\">Hyz</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">Hwx.add_congr</span> <span class=\"o\">(</span><span class=\"n\">HLyz</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">HLxw</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">add_congr</span> <span class=\"n\">Hyz</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">Hwx.add_congr</span> <span class=\"o\">(</span><span class=\"n\">HLzy</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">HRwx</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">add_congr</span> <span class=\"n\">Hyz</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">Hwx.add_congr</span> <span class=\"o\">(</span><span class=\"n\">HRyz</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">HRxw</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">add_congr</span> <span class=\"n\">Hyz</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">Hwx.add_congr</span> <span class=\"o\">(</span><span class=\"n\">HRzy</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span> <span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"n\">pgame_wf_tac</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 282392255,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652594934
    },
    {
        "content": "<p>This is the only proof so far that has been somewhat longer than the previous proof about <code>relabelling</code>, and even then, I'd argue this proof is clearer than the original one</p>",
        "id": 282392310,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652595004
    },
    {
        "content": "<p>(btw, I reordered some arguments in <code>identical</code> which made some proofs quite easier)</p>",
        "id": 282392346,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652595070
    },
    {
        "content": "<p>Yeah, I think I was right! Proving that things are identical is pretty much as easy / hard as proving they're relabellings</p>",
        "id": 282392827,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652595896
    },
    {
        "content": "<p>And in fact, I was even able to golf a bunch of proofs</p>",
        "id": 282392832,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652595901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282391274\">said</a>:</p>\n<blockquote>\n<p>That is, <code>restricted x y</code> and <code>restricted y x</code> imply <code>x ≡ y</code></p>\n</blockquote>\n<p>It seems <code>x = {1,0| }, y = {1| }</code> is a counterexample.</p>",
        "id": 282392882,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652595977
    },
    {
        "content": "<p>Hmm... it seems like there is one theorem in mathlib that is no longer true with <code>identical</code> but was with <code>relabelling</code></p>",
        "id": 282394325,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652598375
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.short_of_relabelling\">docs#pgame.short_of_relabelling</a></p>",
        "id": 282394326,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652598379
    },
    {
        "content": "<p>This isn't currently used anywhere, though</p>",
        "id": 282394330,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652598398
    },
    {
        "content": "<p>What should be done here?</p>",
        "id": 282394419,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652598544
    },
    {
        "content": "<p>I do think that there's little case in keeping <code>relabelling</code> around if we're going to have <code>identical</code>... but maybe there's <em>some</em> case</p>",
        "id": 282394430,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652598571
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282394330\">said</a>:</p>\n<blockquote>\n<p>This isn't currently used anywhere, though</p>\n</blockquote>\n<p>Oh, it's actually used somewhere</p>",
        "id": 282394668,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652598947
    },
    {
        "content": "<p>Hmm</p>",
        "id": 282394715,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652598982
    },
    {
        "content": "<p>Being a relabelling is a strictly stronger notion than being identical, so maybe what we should have is a theorem showing one implies the other</p>",
        "id": 282394729,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652599027
    },
    {
        "content": "<p>Would be nice to have another symbol for the relabelling relation</p>",
        "id": 282394937,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652599305
    },
    {
        "content": "<p>Maybe <code>≡r</code>?</p>",
        "id": 282394999,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652599384
    },
    {
        "content": "<p>Is it used to show <code>domineering</code> is a short game? I forget.</p>",
        "id": 282395319,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652599946
    },
    {
        "content": "<p>It's used in some theorems about short games, yeah</p>",
        "id": 282395468,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652600254
    },
    {
        "content": "<p>I guess that for those, it's important to provide an actual bijection between moves</p>",
        "id": 282395471,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652600274
    },
    {
        "content": "<p>One way to recover that theorem is to define something like \"essentially short\" which means that from each position there are a finite number of equivalence classes up to <code>identical</code></p>",
        "id": 282396443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652601630
    },
    {
        "content": "<p>note that a game is essentially short iff it is identical to a short game, and if you take that as the definition then the theorem becomes almost tautologically true</p>",
        "id": 282396537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652601782
    },
    {
        "content": "<p>I think the question we should be asking is: should something like <code>{0, 0, 0, ... | }</code>with infinitely many zeros be short?</p>",
        "id": 282396689,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602004
    },
    {
        "content": "<p>it is essentially short by my definition</p>",
        "id": 282396700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652602039
    },
    {
        "content": "<p>This would probably break all of the computability on short games, though</p>",
        "id": 282396716,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602060
    },
    {
        "content": "<p>how so</p>",
        "id": 282396723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652602069
    },
    {
        "content": "<p>especially if essentially short came with an actual finset of equivalence class representatives</p>",
        "id": 282396768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652602094
    },
    {
        "content": "<p>actually make that a list or multiset, there is no point in distinctness here</p>",
        "id": 282396778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652602133
    },
    {
        "content": "<p>Hmm, that might work</p>",
        "id": 282396808,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602194
    },
    {
        "content": "<p>So, to be clear, we do want to replace <code>relabelling</code> by <code>identical</code>, right?</p>",
        "id": 282396858,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602218
    },
    {
        "content": "<p>I don't see why not have both, but making <code>identical</code> be the load bearing one seems good to me</p>",
        "id": 282396935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652602342
    },
    {
        "content": "<p>...yeah, actually, it might be a better idea to just have both</p>",
        "id": 282396953,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602402
    },
    {
        "content": "<p>I do think we would need to mix them in the API, though</p>",
        "id": 282396996,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602448
    },
    {
        "content": "<p>When possible, have <code>identical</code> in the hypotheses, and <code>relabelling</code> in the conclusions</p>",
        "id": 282397000,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602460
    },
    {
        "content": "<p>well one implies the other so that seems fine</p>",
        "id": 282397008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652602487
    },
    {
        "content": "<p>I now have another problem</p>",
        "id": 282397132,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602748
    },
    {
        "content": "<p>I attempted to make <code>relabelling</code> into a <code>Prop</code></p>",
        "id": 282397136,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602760
    },
    {
        "content": "<p>When making API for <code>nnreal</code> it's certainly handy to have <code>a \\ne 0</code> in the hypotheses and <code>0 &lt; a</code> in the conclusions because of dot notation and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_lt.lt.ne'\">docs#has_lt.lt.ne'</a> , one could play the same trick here</p>",
        "id": 282397143,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652602783
    },
    {
        "content": "<p>Which to me makes a lot of sense: <code>relabelling</code> should be an equivalence relation, and it's not like we ever use the data</p>",
        "id": 282397197,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602832
    },
    {
        "content": "<p>...except, we actually do use the data</p>",
        "id": 282397204,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602862
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.short_of_relabelling\">docs#pgame.short_of_relabelling</a></p>",
        "id": 282397223,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602870
    },
    {
        "content": "<p>you said something about computability? I think we do use the data</p>",
        "id": 282397224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652602873
    },
    {
        "content": "<p>There's no way to avoid this, is there? Unless we were to make short games noncomputable</p>",
        "id": 282397281,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602929
    },
    {
        "content": "<p>certainly if <code>identical</code> is data and you have <code>identical_of_relabelling</code> you will need the data</p>",
        "id": 282397284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652602932
    },
    {
        "content": "<p>I didn't mean for <code>identical</code> to be data either</p>",
        "id": 282397295,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652602948
    },
    {
        "content": "<p>like I said earlier this is like equiv vs bijective</p>",
        "id": 282397303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652602962
    },
    {
        "content": "<p>guess which one sees more use in mathlib?</p>",
        "id": 282397310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652602979
    },
    {
        "content": "<p>I don't think this is quite the same situation</p>",
        "id": 282397329,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652603014
    },
    {
        "content": "<p>Under normal circumstances, we really don't have any use for the data in a <code>relabelling</code></p>",
        "id": 282397332,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652603026
    },
    {
        "content": "<p>We can't \"apply\" a relabelling like we can an equivalence</p>",
        "id": 282397335,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652603036
    },
    {
        "content": "<p>why not?</p>",
        "id": 282397377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652603045
    },
    {
        "content": "<p>you can take a strategy for one game and make a strategy for the other, or other things like that</p>",
        "id": 282397384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652603072
    },
    {
        "content": "<p>That's just the relabelling itself</p>",
        "id": 282397397,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652603093
    },
    {
        "content": "<p>You're not applying it to anything</p>",
        "id": 282397400,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652603097
    },
    {
        "content": "<p>You might suppose you can apply a relabelling between <code>a</code> and <code>b</code> to a subsequent game of <code>a</code>, but even if this is possible we have no API whatsoever for this</p>",
        "id": 282397409,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652603129
    },
    {
        "content": "<p>if you have a play sequence on one game you can apply it to get a play sequence on the other</p>",
        "id": 282397412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652603138
    },
    {
        "content": "<p>I think just about any data \"about\" a game can be remapped across the relabelling</p>",
        "id": 282397451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652603164
    },
    {
        "content": "<p>so it really does look like equiv to me</p>",
        "id": 282397454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652603175
    },
    {
        "content": "<p>Hmm... you're right</p>",
        "id": 282397456,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652603178
    },
    {
        "content": "<p>We currently have no API for this at all, but it's certainly something that could at some point be worked on</p>",
        "id": 282397459,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652603193
    },
    {
        "content": "<p>that all mostly applies to <code>identical</code> as well</p>",
        "id": 282397461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652603196
    },
    {
        "content": "<p>Alright, I see why this should be data</p>",
        "id": 282397491,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652603251
    },
    {
        "content": "<p>Before trying to do any of the <code>identical</code> stuff, I've opened <a href=\"https://github.com/leanprover-community/mathlib/pull/14155\">#14155</a> to add the <code>≡r</code>notation for relabellings and clean up some proofs</p>",
        "id": 282397883,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652603788
    },
    {
        "content": "<p>I should probably outline what I'm getting at with all this</p>",
        "id": 282398677,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652605067
    },
    {
        "content": "<p>The idea is to first define this identical relation. Then, we define the quotient of games by this relation and prove that negation, addition, and multiplication (?) can be lifted to this quotient. This should save us from the pain of <code>congr</code> lemmas when proving identities or relabellings.</p>",
        "id": 282398837,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652605231
    },
    {
        "content": "<p>Note that <code>game</code> can't do this, as the relabelling relation doesn't lift to it</p>",
        "id": 282398867,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652605292
    },
    {
        "content": "<p>Hmmm... wait. If I really want to do this, then I actually need to define two quotients, one for relabelings and one for identical games</p>",
        "id": 282399098,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652605646
    },
    {
        "content": "<p>This feels excessive and redundant, but it also seems like the easiest way to work with these two relations</p>",
        "id": 282399168,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652605730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282382848\">said</a>:</p>\n<blockquote>\n<p>So you might need to induct on a generic multiset <code>s</code> and make the inductive hypotheses \"if <code>{x, y}</code> is less than <code>s</code> then <code>P1</code>,  ...\"</p>\n</blockquote>\n<p>I'm currently using your <code>mul_args</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cut_expand</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a'</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">a'</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">s'</span> <span class=\"bp\">=</span> <span class=\"n\">s.erase</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">mul_args</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">P1</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">mul_args</span>\n<span class=\"bp\">|</span> <span class=\"n\">P24</span> <span class=\"o\">(</span><span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">mul_args</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_multiset</span> <span class=\"o\">:</span> <span class=\"n\">mul_args</span> <span class=\"bp\">→</span> <span class=\"n\">multiset</span> <span class=\"n\">pgame</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mul_args.P1</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mul_args.P24</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">hyp</span> <span class=\"o\">:</span> <span class=\"n\">mul_args</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mul_args.P1</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">numeric</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">numeric</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">numeric</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">mul_args.P24</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">numeric</span> <span class=\"n\">x₁</span> <span class=\"bp\">→</span> <span class=\"n\">numeric</span> <span class=\"n\">x₂</span> <span class=\"bp\">→</span> <span class=\"n\">numeric</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">P24</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ces</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">classical</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">inv_image</span> <span class=\"o\">(</span><span class=\"n\">cut_expand</span> <span class=\"n\">subsequent</span><span class=\"o\">)</span> <span class=\"n\">to_multiset</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">P1_of_P24</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">ces</span> <span class=\"n\">a'</span> <span class=\"o\">(</span><span class=\"n\">mul_args.P1</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">hyp</span> <span class=\"n\">a'</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x.numeric</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y.numeric</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">numeric</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>seems to be working fine!</p>",
        "id": 282425919,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652644427
    },
    {
        "content": "<p>That's pretty amazing</p>",
        "id": 282427973,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652647227
    },
    {
        "content": "<p>Do you have a proof sketch for the hydra game ending?</p>",
        "id": 282427978,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652647245
    },
    {
        "content": "<p>I think that warrants its own separate PR</p>",
        "id": 282428048,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652647371
    },
    {
        "content": "<p>And I'd be glad to help if possible</p>",
        "id": 282428372,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652647849
    },
    {
        "content": "<p><a href=\"https://gist.github.com/alreadydone/9eea203363bb76e5306c35a75550b836\">This is a full proof in under 100 lines</a>.</p>",
        "id": 282428602,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652648220
    },
    {
        "content": "<p>Yeah, I believe this is an interesting enough result to maybe even have its own file</p>",
        "id": 282428872,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652648574
    },
    {
        "content": "<p>Obviously the PR wouldn't be stated in terms of games, though</p>",
        "id": 282428877,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652648587
    },
    {
        "content": "<p>Note: the proof of <code>le_trans</code> could be stated in terms of this, though I don't think it's large enough that this would be able to golf it</p>",
        "id": 282428937,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652648674
    },
    {
        "content": "<p>Since it's just 100 lines I think it could go to the end of <a href=\"https://leanprover-community.github.io/mathlib_docs/logic/relation.html\">https://leanprover-community.github.io/mathlib_docs/logic/relation.html</a> instead of having its own file.</p>\n<p>I'd like to PR it, but maybe I'll wait until I fill in more details in the Theorem 3.8 proof to convince that this well-foundedness result is the only thing left to make the proof work.</p>",
        "id": 282429017,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652648797
    },
    {
        "content": "<p>Wait, you're working on that independently?</p>",
        "id": 282429034,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652648876
    },
    {
        "content": "<p>I have looked at your code</p>",
        "id": 282429083,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652648928
    },
    {
        "content": "<p>but instead of doing it in one stretch I try to extract lemmas that apply to multiple cases</p>",
        "id": 282429098,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652648985
    },
    {
        "content": "<p>That's what I've attempted too, but all of these lemmas seem to depend on the same induction hypotheses</p>",
        "id": 282429183,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652649079
    },
    {
        "content": "<p>your <code>surreal_mul</code> branch hasn't been updated for almost 2 weeks, is there any new progress? I see that you are busy with other PRs.</p>\n<p>I think I really just started to write code about Theorem 3.8 today, after the &lt; correction was merged. I've shown one of the four cases of P1 follows from the induction hypothesis, and is now hoping the same lemmas that solved this case would also solve the other cases.</p>",
        "id": 282429249,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652649239
    },
    {
        "content": "<p>I just merged with master :P</p>",
        "id": 282429287,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652649251
    },
    {
        "content": "<p>Yeah, I've been busy with other PRs</p>",
        "id": 282429290,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652649258
    },
    {
        "content": "<p>I wanted a certain lemma on birthdays, which necessitated a certain lemma on ordinals, and that led me down a rabbit hole of fixing some glaring holes in that API</p>",
        "id": 282429298,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652649291
    },
    {
        "content": "<p>I still haven't even added that darned lemma</p>",
        "id": 282429302,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652649298
    },
    {
        "content": "<p>But it wouldn't be necessary with your new approach</p>",
        "id": 282429308,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652649306
    },
    {
        "content": "<p>I'll see if I can continue work on the proof within the next few days</p>",
        "id": 282429314,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652649316
    },
    {
        "content": "<p>And you know, the sheer work you've put into your new framework for games is starting to convince me that it might be worth it, but I have no idea how I would pitch this to everyone else</p>",
        "id": 282429386,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652649400
    },
    {
        "content": "<p>Still a bit worried about e.g. the ordinal and nim API though</p>",
        "id": 282429403,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652649458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282429298\">said</a>:</p>\n<blockquote>\n<p>I wanted a certain lemma on birthdays, which necessitated a certain lemma on ordinals, and that led me down a rabbit hole of fixing some glaring holes in that API</p>\n</blockquote>\n<p>I find it strange to see the <code>birthday (x + y)</code> stuff in your code. Why not express it in terms of <code>birthday x</code> and <code>birthday y</code>?  Seems that <code>(x + y)</code> doesn't appear in the options of the product of two games?</p>",
        "id": 282429587,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652649739
    },
    {
        "content": "<p>As far as I know (and I don't know that many things) there isn't any nice form for the birthday of the sum of two games</p>",
        "id": 282430414,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652650950
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 282430425,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652650979
    },
    {
        "content": "<p>However, this value does have the property that it decreases when you replace either game by a subsequent one</p>",
        "id": 282430426,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652650979
    },
    {
        "content": "<p>Further, if the birthday of y is less than the birthday of z, the birthday of x + y is less than the birthday of x + z</p>",
        "id": 282430498,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652651076
    },
    {
        "content": "<p>I think that's now called something like <code>covariant_class (+) (&lt;)</code> or something</p>",
        "id": 282431436,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652652393
    },
    {
        "content": "<p>We don't have any named relation for \"the birthday of x is less than the birthday of y\" though</p>",
        "id": 282432346,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652653874
    },
    {
        "content": "<p>I don't think we need it either</p>",
        "id": 282432347,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652653878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282430498\">said</a>:</p>\n<blockquote>\n<p>Further, if the birthday of y is less than the birthday of z, the birthday of x + y is less than the birthday of x + z</p>\n</blockquote>\n<p>Note, I'm only 99% sure of this</p>",
        "id": 282434161,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652656695
    },
    {
        "content": "<p>I wanted to prove it in Lean, but for that I needed a lemma <code>lsub_sum</code>, which would be a consequence of <code>sup_sum</code>, which would be a consequence of <code>csup_sum</code>, which I had no idea where to put because <code>conditionally_complete_lattice.lean</code> and <code>complete_lattice.lean</code> are very different files despite most of the same theorems being true... you get my point</p>",
        "id": 282434187,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652656739
    },
    {
        "content": "<p>Predictably, this <code>lf</code> refactor broke what I had of the surreal multiplication proof</p>",
        "id": 282435007,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652657801
    },
    {
        "content": "<p>I'll try to fix it later today</p>",
        "id": 282435024,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652657831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282434161\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282430498\">said</a>:</p>\n<blockquote>\n<p>Further, if the birthday of y is less than the birthday of z, the birthday of x + y is less than the birthday of x + z</p>\n</blockquote>\n<p>Note, I'm only 99% sure of this</p>\n</blockquote>\n<p>That sounds false, at least with strict less than</p>",
        "id": 282435327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652658293
    },
    {
        "content": "<p>I think if the birthday of <code>x</code> is large then it will dominate and the birthday of <code>x + y</code> will be the same as <code>x</code> or maybe one more</p>",
        "id": 282435411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652658385
    },
    {
        "content": "<p>(at least, I am taking it as analogous to the claim that <code>rank y &lt; rank z -&gt; rank (x ⊔ y) &lt; rank (x ⊔ z)</code> in zfc)</p>",
        "id": 282435489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652658506
    },
    {
        "content": "<p>Oh no wait I remember now, this is the <a href=\"https://en.wikipedia.org/wiki/Ordinal_arithmetic#Natural_operations\">natural sum</a> operation on ordinals</p>",
        "id": 282435579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652658650
    },
    {
        "content": "<p>which we don't have any API for</p>",
        "id": 282435591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652658692
    },
    {
        "content": "<p>That is, I claim that <code>birthday (x + y) = birthday x # birthday y</code></p>",
        "id": 282435658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652658777
    },
    {
        "content": "<p>Let me sketch a proof of that claim:</p>\n<p>We first prove that <code>birthday y ≤ birthday z → birthday (x + y) ≤ birthday (x + z)</code> by Conway induction. Separate each birthday as the <code>max</code> of four <code>lsub</code>s. By the inductive hypotheses, these are less-or-equal respectively.</p>\n<p>Then, if <code>birthday y &lt; birthday z</code>, there exists some option<code>z'</code> of <code>z</code> with <code>birthday y ≤ birthday z'</code>, so that <code>birthday (x + y) ≤ birthday (x + z') &lt; birthday (x + z)</code>.</p>",
        "id": 282436111,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652659341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282435579\">said</a>:</p>\n<blockquote>\n<p>Oh no wait I remember now, this is the <a href=\"https://en.wikipedia.org/wiki/Ordinal_arithmetic#Natural_operations\">natural sum</a> operation on ordinals</p>\n</blockquote>\n<p>Nice! Yet another thing I can do with ordinals!</p>",
        "id": 282436131,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652659395
    },
    {
        "content": "<p>And yes, I believe that <code>y &lt; z -&gt; x # y &lt; x # z</code></p>",
        "id": 282436140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652659434
    },
    {
        "content": "<p>the theory of natural sum/product is pretty darn similar to the theory of birthdays of surreals though, it might not be worth the rephrasing</p>",
        "id": 282436265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652659576
    },
    {
        "content": "<p>there is one novelty you get with the ordinal formulation though, which is the concrete definition of natural sum given by lining up the cantor normal forms and adding things pointwise</p>",
        "id": 282436285,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652659626
    },
    {
        "content": "<p>Whoa, that works?</p>",
        "id": 282436360,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652659721
    },
    {
        "content": "<p>That's really cool</p>",
        "id": 282436361,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652659725
    },
    {
        "content": "<p>We don't need to \"rephrase\" ordinal birthdays in terms of the natural sum and product. But we could define the natural sum and product on ordinals, prove all the necessary theorems, then simply transfer them to surreal birthdays</p>",
        "id": 282436379,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652659781
    },
    {
        "content": "<p>yup, it's mentioned at the end of that wikipedia section</p>",
        "id": 282436446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652659864
    },
    {
        "content": "<p>The easiest way to prove it probably goes via the observation that the natural sum is the greatest order type of a total order extending the disjoint union of types with order types <code>x</code> and <code>y</code> respectively. It is easy to see that the pointwise sum of cantor orderings is <em>a</em> way to order that disjoint union: you take all the A stuff and then all the B stuff in each coordinate, which proves that the cantor formula is <code>&lt;= x # y</code>. For the reverse I think you can use ordinal induction, although it looks messy</p>",
        "id": 282436705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652660266
    },
    {
        "content": "<p>I think we'll need quite a lot more API for Cantor normal forms to get this to work</p>",
        "id": 282437359,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652661111
    },
    {
        "content": "<p>It's not immediate to fix my progress on the multiplication proof</p>",
        "id": 282451874,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652680578
    },
    {
        "content": "<p>I had taken a few shortcuts that just don't work anymore</p>",
        "id": 282451878,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652680595
    },
    {
        "content": "<p>Which leads to the question of whether I was actually simplifying the proof by using <code>lf</code> instead of <code>lt</code>, or if my approach was flawed and I just hadn't realized it</p>",
        "id": 282451893,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652680627
    },
    {
        "content": "<p>I'm going to have to go over the proof again with what I now know and evaluate this, and I am currently too tired to do so</p>",
        "id": 282451961,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652680684
    },
    {
        "content": "<p>So maybe tomorrow</p>",
        "id": 282451964,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652680687
    },
    {
        "content": "<p>On an unrelated note</p>",
        "id": 282453301,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652682021
    },
    {
        "content": "<p>We have a consensus on <code>\\&lt;|</code> and <code>\\lf</code> being useful shortcuts, right?</p>",
        "id": 282453312,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652682034
    },
    {
        "content": "<p>I lied, I'm looking at the proof right now :P</p>",
        "id": 282455163,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652683741
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/sGiOP5BkK_05bpjqS33lJX_5/image.png\">image.png</a> This right here is an iff, if <code>z₁</code> and <code>z₂</code> are numeric</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/sGiOP5BkK_05bpjqS33lJX_5/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/sGiOP5BkK_05bpjqS33lJX_5/image.png\"></a></div>",
        "id": 282455184,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652683763
    },
    {
        "content": "<p>This is an immediate consequence of <code>le_def_lt</code>, the numeric counterpart to <code>le_def_lf</code> (which I have already PR'd)</p>",
        "id": 282455210,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652683794
    },
    {
        "content": "<p>I wonder, can we get away with the if direction without assuming that these are numeric?</p>",
        "id": 282455275,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652683817
    },
    {
        "content": "<p>It isn't really a problem, this dependency still satisfies the hydra relation, but it's a dependency I hadn't accounted for before</p>",
        "id": 282455307,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652683843
    },
    {
        "content": "<p><code>pgame.le_def_lf</code> doesn't assume numeric, and we are proving <code>lt</code>, which implies <code>lf</code> unconditionally, so I don't see any additional dependency.</p>",
        "id": 282455655,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652684111
    },
    {
        "content": "<p>Oh, you're right</p>",
        "id": 282455819,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652684243
    },
    {
        "content": "<p>So, it seems like we can prove P2 by using a weaker form of P4 using <code>lf</code> instead of <code>lt</code></p>",
        "id": 282456060,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652684412
    },
    {
        "content": "<p>Here's the question: can we perhaps do the rest of the proof from this weaker P4'?</p>",
        "id": 282456134,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652684461
    },
    {
        "content": "<p>If so then we've found a way to simplify the argument</p>",
        "id": 282456147,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652684476
    },
    {
        "content": "<p>I'm a bit skeptical of this working though, since <code>add_lf_add</code> isn't actually true</p>",
        "id": 282456302,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652684603
    },
    {
        "content": "<p>Hmm... in fact, this would have doomed my proof if I hadn't realized we had <code>lt</code> and <code>lf</code> swapped</p>",
        "id": 282456380,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652684650
    },
    {
        "content": "<p>Alright, I got the proof working again... or rather, what I had written of it</p>",
        "id": 282459275,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652686758
    },
    {
        "content": "<p>There's little missing now, other than the proof of well-foundedness</p>",
        "id": 282459286,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652686771
    },
    {
        "content": "<p>I think I can finish the skeleton tonight</p>",
        "id": 282459298,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652686781
    },
    {
        "content": "<p>Yeah actually no</p>",
        "id": 282465447,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652690531
    },
    {
        "content": "<p>I am way past my bedtime and I only finished one of eight (?) remaining cases</p>",
        "id": 282465529,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652690575
    },
    {
        "content": "<p>I got this as the output of <code>abel</code></p>",
        "id": 282508293,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652713280
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/G4ZBmgY0dsKmuUgnARqlCEJX/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/G4ZBmgY0dsKmuUgnARqlCEJX/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/G4ZBmgY0dsKmuUgnARqlCEJX/image.png\"></a></div>",
        "id": 282508295,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652713283
    },
    {
        "content": "<p>Note that <code>⟦x₁R jx₁ * mk yl yr yL yR⟧</code> appears on both sides of the inequality</p>",
        "id": 282508348,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652713308
    },
    {
        "content": "<p>Is there some easy way to make <code>abel</code> realize this and cancel them out? Or some other tactic that does the job better?</p>",
        "id": 282508461,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652713339
    },
    {
        "content": "<p>Note: the original expression was even more complicated, and <code>abel</code> did successfully cancel out one of two pairs of common terms</p>",
        "id": 282508529,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652713368
    },
    {
        "content": "<p>\"cancelling out\" means \"applying a monotonicity lemma\", so I think it's out of scope for <code>abel</code>.</p>",
        "id": 282508796,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652713485
    },
    {
        "content": "<p>Is there any other tactic that can deal with this?</p>",
        "id": 282509788,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652713899
    },
    {
        "content": "<p>For full context: here's my hypothesis and my goal <a href=\"/user_uploads/3121/ekF6zvgKCSDOwFfr5LfF-Q4n/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ekF6zvgKCSDOwFfr5LfF-Q4n/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/ekF6zvgKCSDOwFfr5LfF-Q4n/image.png\"></a></div>",
        "id": 282509888,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652713933
    },
    {
        "content": "<p><code>x₁</code> is def-eq to <code>mk x₁l x₁r x₁L xᵣ</code> btw, same goes for <code>x₂</code></p>",
        "id": 282509940,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652713960
    },
    {
        "content": "<p>Actually, there might be some syntactic equality troubles that prevent a single tactic from closing the goal, but simplifying <code>H₃</code> enough that I can just use one or two <code>rw add_comm</code> and <code>exact</code> would be amazing</p>",
        "id": 282510044,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652714004
    },
    {
        "content": "<p>Use some lemma to rewrite H3 to the form <code>0 &lt; _</code> and then try <code>abel</code>?</p>",
        "id": 282511100,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652714473
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#monotonicity\">tactic#monotonicity</a></p>",
        "id": 282511412,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652714607
    },
    {
        "content": "<p>You mean <code>mono</code>?</p>",
        "id": 282514590,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652716006
    },
    {
        "content": "<p><code>mono at H₃</code> doesn't seem to work</p>",
        "id": 282514603,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652716012
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282511100\">said</a>:</p>\n<blockquote>\n<p>Use some lemma to rewrite H3 to the form <code>0 &lt; _</code> and then try <code>abel</code>?</p>\n</blockquote>\n<p>This might work, maybe <code>apply_rules</code> could do this?</p>",
        "id": 282514813,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652716097
    },
    {
        "content": "<p>I have proven four out of eight goals in the very last stretch of the skeleton of the proof!</p>",
        "id": 282524865,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652720194
    },
    {
        "content": "<p>The skeleton will be ready really soon</p>",
        "id": 282524874,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652720202
    },
    {
        "content": "<p>(today in messages that are funnier without context)</p>",
        "id": 282524901,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652720210
    },
    {
        "content": "<p>Six out of eight!</p>",
        "id": 282537301,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652724345
    },
    {
        "content": "<p>Eight out of eight!!!!!!</p>",
        "id": 282538196,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652724689
    },
    {
        "content": "<p>Alright, the skeleton of the proof is done</p>",
        "id": 282538208,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652724699
    },
    {
        "content": "<p>This is almost 300 lines of code for a single proof (which I presume is some sort of mathlib record?)</p>",
        "id": 282538319,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652724748
    },
    {
        "content": "<p>There's definitely room for golfing though</p>",
        "id": 282538333,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652724754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span></p>",
        "id": 282538875,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652725012
    },
    {
        "content": "<p>I tried to make the induction step easier to prove by deduplicating applications of the induction hypothesis</p>",
        "id": 282538975,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652725063
    },
    {
        "content": "<p>Even then, there are a whopping 36 applications we need to prove well-founded</p>",
        "id": 282539082,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652725095
    },
    {
        "content": "<p>I'm going through each of them and verifying they satisfy the <code>cut_expand</code> relation</p>",
        "id": 282541710,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652726161
    },
    {
        "content": "<p>Not formally, yet</p>",
        "id": 282541758,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652726169
    },
    {
        "content": "<p>Actually, the <code>cut_expand</code> relation is a wee bit too weak</p>",
        "id": 282542138,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652726358
    },
    {
        "content": "<p>It seems like we need its transitive closure</p>",
        "id": 282542161,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652726365
    },
    {
        "content": "<p>Fortunately I proved not too long ago that the transitive closure of a well-founded relation is well-founded</p>",
        "id": 282542178,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652726375
    },
    {
        "content": "<p>Now, here's the kicker</p>",
        "id": 282542632,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652726552
    },
    {
        "content": "<p>What's a succint way to prove two multisets satisfy the <code>cut_expand</code> relation?</p>",
        "id": 282542752,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652726611
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/wW5JrWsEEUKZwsvi6pESlI_w/image.png\">image.png</a> If we provide <code>t</code>, are the other proofs <code>rfl</code>?</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/wW5JrWsEEUKZwsvi6pESlI_w/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/wW5JrWsEEUKZwsvi6pESlI_w/image.png\"></a></div>",
        "id": 282542771,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652726621
    },
    {
        "content": "<p>It's great that you finished the proof! I'll hopefully PR my part tonight. I'll probably change <code>s' = s.erase a + t</code> to <code>s' + {a} = s + t</code> in <code>cut_expand</code>, as it avoids <code>decidable_eq</code> and it's probably easier to show concrete multisets satisfy the relation with <code>+</code> instead of <code>erase</code>.</p>\n<p>And I think I'll also define an <code>inductive</code> relation on <code>mul_args</code> that is a subrelation of <code>inv_image (trans_gen $ cut_expand is_option)</code> (so well-founded and we can have the <code>has_well_founded</code> instance on <code>mul_args</code>) and covers all cases we need, and then we can define a wf tactic that use <code>solve_by_elim</code> with the constructors of the relation to fulfill the wf obligations.</p>",
        "id": 282542901,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652726675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282542752\">said</a>:</p>\n<blockquote>\n<p>What's a succint way to prove two multisets satisfy the <code>cut_expand</code> relation?</p>\n</blockquote>\n<p>The docs for <code>fin_cases</code>appears like that it could solve these, but actually not.</p>",
        "id": 282542968,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652726709
    },
    {
        "content": "<p>The most systematic way I can think of now is to use <code>add_singleton</code> to expand it to sum of singletons, then use commutativity, associativity etc. (Notice that <code>{a,b,c}</code> is something like <code>({a}.cons b).cons c</code> under the hood.)</p>",
        "id": 282543025,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652726749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282542901\">said</a>:</p>\n<blockquote>\n<p>And I think I'll also define an <code>inductive</code> relation on <code>mul_args</code> that is a subrelation of <code>inv_image (trans_gen $ cut_expand is_option)</code> (so well-founded and we can have the <code>has_well_founded</code> instance on <code>mul_args</code>) and covers all cases we need, and then we can define a wf tactic that use <code>solve_by_elim</code> with the constructors of the relation to fulfill the wf obligations.</p>\n</blockquote>\n<p>Already on it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_lt</span> <span class=\"n\">mul_args</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">inv_image</span> <span class=\"o\">(</span><span class=\"n\">relation.trans_gen</span> <span class=\"bp\">$</span> <span class=\"n\">cut_expand</span> <span class=\"n\">subsequent</span><span class=\"o\">)</span> <span class=\"n\">to_multiset</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_well_founded</span> <span class=\"n\">mul_args</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">),</span>\n  <span class=\"n\">wf</span> <span class=\"o\">:=</span> <span class=\"n\">inv_image.wf</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">cut_expand.wf</span> <span class=\"n\">wf_subsequent</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_gen</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 282543331,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652726888
    },
    {
        "content": "<p>I'm writing down the sorries for the well-foundedness proofs</p>",
        "id": 282543561,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652727013
    },
    {
        "content": "<p>There! I've sorried all 36 of them</p>",
        "id": 282545237,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652727653
    },
    {
        "content": "<p>And they should all be true</p>",
        "id": 282545253,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652727659
    },
    {
        "content": "<p>How does your new definition for <code>cut_expand</code> look like?</p>",
        "id": 282545863,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652727889
    },
    {
        "content": "<p>I want to try some things out with it</p>",
        "id": 282545874,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652727894
    },
    {
        "content": "<p>I presume it's this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cut_expand</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a'</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">a'</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">s'</span> <span class=\"bp\">+</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">cut_expand</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"o\">({</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">({</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨{</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">},</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">dec_trivial</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">fin_cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span>\n    <span class=\"n\">dec_trivial</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">dec_trivial</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 282546495,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652728107
    },
    {
        "content": "<p>Interesting, changing <code>erase</code> to <code>+</code> makes it decidable and fin_cases applicable?</p>",
        "id": 282546887,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652728315
    },
    {
        "content": "<p>At least for naturals</p>",
        "id": 282546981,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652728344
    },
    {
        "content": "<p>Oh yes, pgame doesn't have decidable_eq</p>",
        "id": 282547012,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652728373
    },
    {
        "content": "<p>Is there any way to prove goals like <code>x₁ ∈ {x₁, x₂, x₃}</code> easily without <code>decidable_eq</code>?</p>",
        "id": 282547117,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652728434
    },
    {
        "content": "<p>Or god forbid, something like this <a href=\"/user_uploads/3121/v_llcxv41xhcqGb2Zq4UrUUs/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/v_llcxv41xhcqGb2Zq4UrUUs/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/v_llcxv41xhcqGb2Zq4UrUUs/image.png\"></a></div>",
        "id": 282547279,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652728506
    },
    {
        "content": "<p>I've started filling out the sorries</p>",
        "id": 282552267,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652731188
    },
    {
        "content": "<p>The one that I'm going to leave open is the one for <code>cut_expand.wf</code></p>",
        "id": 282552350,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652731207
    },
    {
        "content": "<p>That's all yours</p>",
        "id": 282552369,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652731210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282547117\">said</a>:</p>\n<blockquote>\n<p>Is there any way to prove goals like <code>x₁ ∈ {x₁, x₂, x₃}</code> easily without <code>decidable_eq</code>?</p>\n</blockquote>\n<p>Maybe <code>simp only [multiset.mem_cons]</code> then use <code>rfl</code> with some <code>or.inl</code>, <code>or.inr</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282547279\">said</a>:</p>\n<blockquote>\n<p>Or god forbid, something like this <a href=\"/user_uploads/3121/v_llcxv41xhcqGb2Zq4UrUUs/image.png\">image.png</a></p>\n</blockquote>\n<p>maybe <code>simp only [&lt;- multiset.singleton_add], abel</code></p>",
        "id": 282552506,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652731250
    },
    {
        "content": "<p>I filled in some simple lemmas for <code>P1 x' y' &lt; P1 x y</code>, we're already down to 26 sorries</p>",
        "id": 282552931,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652731451
    },
    {
        "content": "<p>Actually I want to remove the <code>a ∈ s</code> condition, which is unnecessary for irreflexive relation <code>r</code>.</p>",
        "id": 282553095,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652731523
    },
    {
        "content": "<p>Every well-founded relation is irreflexive</p>",
        "id": 282557697,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652733740
    },
    {
        "content": "<p>So yeah, you should remove that</p>",
        "id": 282557711,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652733748
    },
    {
        "content": "<p>I'm having a bit of trouble</p>",
        "id": 282583125,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652751906
    },
    {
        "content": "<p>Not with the proofs themselves</p>",
        "id": 282583128,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652751911
    },
    {
        "content": "<p>But rather, giving names to like 10 auxiliary lemmas for that relation is not really working out haha</p>",
        "id": 282583150,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652751935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/282552506\">said</a>:</p>\n<blockquote>\n<p>maybe <code>simp only [&lt;- multiset.singleton_add], abel</code></p>\n</blockquote>\n<p>Just need an additional <code>rw multiset.has_insert</code> to make it work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.multiset.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">5</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">multiset.has_insert</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">multiset.singleton_add</span><span class=\"o\">],</span> <span class=\"n\">abel</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 282585400,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652754417
    },
    {
        "content": "<p>However it's still cumbersome. Maybe wrap it into a single local tactic? I think Lean can't come up with <code>t</code> (=<code>s' + {a} - s</code>) automatically because <code>multiset.has_sub</code> uses decidable_eq.</p>",
        "id": 282585419,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652754474
    },
    {
        "content": "<p>On second thought, I'm not sure this will help</p>",
        "id": 282586471,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652755790
    },
    {
        "content": "<p>I've been able to produce relatively short proofs for the theorems I've needed, without relying on things like these</p>",
        "id": 282586505,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652755812
    },
    {
        "content": "<p>I think if you adopt my approach and define (&lt;) on mul_args as an <code>inductive</code> relation, then you can replace the ~10 auxiliary lemmas with ~10 constructors; you can prove it's a subrelation of the <code>inv_image</code> in a single lemma, and use <code>subrelation.wf</code> to show it's well-founded. And here's a way to name the constructors systematically; for example, the constructor that produces <code>mul_args.P1 y x₂L &lt; mul_args.P24 x₁ x₂ y</code> may be named <code>eyo₂</code>, meaning that the first argument is equal to y and the second is an option of x₂. Similarly, the constructor that produces <code>mul_args.P24 yL yR x &lt; mul_args.P1 x y</code> may be named <code>oyoyex</code>.</p>",
        "id": 282593953,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652764569
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/14190\">#14190</a></p>",
        "id": 282606680,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1652775751
    },
    {
        "content": "<p>I decided against defining <code>&lt;</code> on <code>mul_args</code> directly, instead opting to define a relation on <code>multiset</code>s themselves. That way, I'm able to directly apply lemmas like <code>{x, y} = {y, x}</code>without having to use <code>change</code> or <code>unfold</code></p>",
        "id": 282673266,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652807010
    },
    {
        "content": "<p>But yeah, your approach still works</p>",
        "id": 282675959,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652808076
    },
    {
        "content": "<p>There's some auxiliary lemmas on <code>cut_expand</code> I'll still need, but I'll PR those after your PR is merged</p>",
        "id": 282676227,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652808180
    },
    {
        "content": "<p>I just realized</p>",
        "id": 282808699,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652889260
    },
    {
        "content": "<p>I think you can prove equality of multisets like <code>{x₁, x₂, x₃} = {x₂, x₂, x₁, x₃}</code> by <code>ext, tauto</code></p>",
        "id": 282808767,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652889284
    },
    {
        "content": "<p><code>ext, simp</code> should also work</p>",
        "id": 282809689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652889666
    },
    {
        "content": "<p>I've always held that if <code>ext, simp</code> <em>fails</em> to prove a \"these things are the same because they are made out of the same ingredients\" goal, then you are obligated to go write the missing <code>@[ext]</code> and <code>@[simp]</code> lemmas before proceeding!</p>",
        "id": 282849796,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652908144
    },
    {
        "content": "<p>In that case I'm not sure this holds, because there can be arbitrarily many <code>or_comm</code> required to prove the goal.</p>",
        "id": 282850179,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652908329
    },
    {
        "content": "<p>We got <code>\\lf</code>, <code>\\&lt;|</code>, and <code>\\fuzzy</code> added to vscode-lean!</p>",
        "id": 282994100,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652995517
    },
    {
        "content": "<p>Did you add them to the other extensions as well?</p>",
        "id": 282994912,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652996034
    },
    {
        "content": "<p>Uhhhhh no</p>",
        "id": 282995062,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652996107
    },
    {
        "content": "<p>I probably should do that</p>",
        "id": 282995085,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652996118
    },
    {
        "content": "<p>What other extensions are there?</p>",
        "id": 282995096,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1652996123
    },
    {
        "content": "<p>(I pull in changes every so often to neovim, so I pulled yours in already. There's emacs too but I think Sebastian does the same every so often. Probably some day we'll have a shared location that doesn't involve copy pasting, but for now I think you're good)</p>",
        "id": 283001443,
        "sender_full_name": "Julian Berman",
        "timestamp": 1653000149
    },
    {
        "content": "<p>There's also <span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span>'s Chrome extension</p>",
        "id": 283003363,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653001428
    },
    {
        "content": "<p>I only just learnt to use \\lf and \\rf to type <code>⌊</code> and <code>⌋</code>  :(</p>",
        "id": 283161371,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653121315
    },
    {
        "content": "<p>Aaah, no that was one of my favorite shortcuts <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 283161425,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653121350
    },
    {
        "content": "<p>What does \"lf\" stand for in the pgame world?</p>",
        "id": 283161442,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653121399
    },
    {
        "content": "<p>\"<strong>l</strong>ess than or <strong>f</strong>uzzy to\"</p>",
        "id": 283161452,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653121425
    },
    {
        "content": "<p><code>ltf</code> might be a reasonable compromise then, although I don't remember what the rules are for resolving ambiguity of abbreviations</p>",
        "id": 283162835,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653123416
    },
    {
        "content": "<p>Maybe adding <code>\\floor</code> for <code> ⌊$CURSOR⌋</code> is a better solution anyway</p>",
        "id": 283162847,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653123450
    },
    {
        "content": "<p>Or both?</p>",
        "id": 283163589,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1653124604
    },
    {
        "content": "<p>It would be great if we could move the management of these aliases to within mathlib itself</p>",
        "id": 283163821,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653125039
    },
    {
        "content": "<p>But that's probably a conversation for a new thread</p>",
        "id": 283163860,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653125049
    },
    {
        "content": "<p>I decided to go ahead and PR natural addition: <a href=\"https://github.com/leanprover-community/mathlib/pull/14291\">#14291</a></p>",
        "id": 283198574,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653175915
    },
    {
        "content": "<p>This is relevant to games in two ways (that I know of!)</p>",
        "id": 283198612,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653175924
    },
    {
        "content": "<p><code>a.to_pgame + b.to_pgame ≈ (of_nat_ordinal (to_nat_ordinal a + to_nat_ordinal b)).to_pgame</code></p>",
        "id": 283198623,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653175954
    },
    {
        "content": "<p>(i.e. natural addition is the addition on ordinal games)</p>",
        "id": 283198630,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653175972
    },
    {
        "content": "<p>And <code>birthday (a + b) = of_nat_ordinal (to_nat_ordinal (birthday a) + to_nat_ordinal (birthday b))</code></p>",
        "id": 283198636,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653175994
    },
    {
        "content": "<p>This <code>of</code> and <code>to</code> notation totally sucks, but natural addition and multiplication have a ton of algebraic properties, so it was worth making into a type alias so that we could provide all the appropriate instances</p>",
        "id": 283198697,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653176079
    },
    {
        "content": "<p>maybe add some notation for <code>of/to</code>? localised maybe?</p>",
        "id": 283199261,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1653177091
    },
    {
        "content": "<p>Any suggestions?</p>",
        "id": 283199820,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653177946
    },
    {
        "content": "<p>I'm guessing such a notation would look something like <code>ᵒᵈ</code> and friends</p>",
        "id": 283199858,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653177965
    },
    {
        "content": "<p>Or just put them in a namespace so by <code>open</code>ing the namespace you can just write <code>to</code> and <code>from</code>? I think this might be too specialized to warrant notation.</p>",
        "id": 283208500,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653191242
    },
    {
        "content": "<p>That's clever</p>",
        "id": 283213584,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653197995
    },
    {
        "content": "<p><code>to_nat_ordinal</code> and <code>of_nat_ordinal</code> are both already in a <code>nat_ordinal</code> namespace. Should I just rename them to <code>to</code> and <code>of</code>?</p>",
        "id": 283214896,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653199624
    },
    {
        "content": "<p>Wikipedia <a href=\"https://en.wikipedia.org/wiki/Ordinal_arithmetic#Natural_operations\">uses the notations ⊕ and ⊗</a> which I think are standard. The ⊕ notation is also common for <a href=\"https://en.wikipedia.org/wiki/Nim#Mathematical_theory\">Nim sum</a> / xor, and nim sum/product also have tons of algebraic properties (forming an algebraically closed field On₂, see <a href=\"http://www.neverendingbooks.org/on2-conways-nim-arithmetics\">Lieven le Bruyn's blog posts</a>), but we may use <code>⊕₂</code> <code>⊗₂</code> to signify both their binary nature and their similarity to natural sum/product.</p>\n<p>By the way, well partial orders is spelt <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.is_pwo\">docs#set.is_pwo</a> in mathlib, and it would be nice to connect them to natural sums/products as explained in the first Wikipedia page.</p>",
        "id": 283216622,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1653202106
    },
    {
        "content": "<p><code>⊕</code> is definitely a no-go, since it's used for type sums</p>",
        "id": 283216654,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653202161
    },
    {
        "content": "<p>Also, the decision to make a new type in order to use <code>+</code> and <code>*</code> was quite intentional. These natural operations have a lot of algebraic structure to them, and we'd be missing out on tons of instances if we just made them operations on <code>ordinal</code> itself</p>",
        "id": 283216713,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653202224
    },
    {
        "content": "<p>They're commutative, associative, preserve order, are cancellative, and distributive</p>",
        "id": 283216722,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653202256
    },
    {
        "content": "<p>And they have the usual <code>0</code> and <code>1</code> from ordinals</p>",
        "id": 283216740,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653202265
    },
    {
        "content": "<p>Ok yes, a lot of nice properties seem impossible to state without the had_add has_mul instances, and those would conflict with the original ones, so a type synonym seems necessary.</p>",
        "id": 283216863,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1653202458
    },
    {
        "content": "<p>In an ideal world we'd have <code>group (+)</code> instead of <code>add_group</code> and such, but this isn't that world <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span></p>",
        "id": 283216956,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653202579
    },
    {
        "content": "<p>Maybe what we want is <code>a ⊗ b = of_nat_ordinal (to_nat_ordinal a * to_nat_ordinal b)</code> and the alike.</p>\n<p>Here's how people solve the notation conflict with type sum in <a href=\"https://leanprover-community.github.io/mathlib_docs/category_theory/limits/shapes/biproducts.html#notation\">biproducts</a> (\"direct sum\") in the categorical setting; in concrete categories its underlying type is usually exactly the type sum. I wonder if it makes sense and easy to make the ⊕ notation localized.</p>\n<p>By the way, anyone knows why <code>lf</code> and <code>equiv</code> are displayed <a href=\"https://leanprover-community.github.io/mathlib_docs/set_theory/game/pgame.html\">in the docs</a> instead of their notations?</p>",
        "id": 283217351,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1653203115
    },
    {
        "content": "<p>It's because the notation is local</p>",
        "id": 283218288,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653204711
    },
    {
        "content": "<p>Notations still give you syntactic equality, right? If so, that's definitely the right approach</p>",
        "id": 283218411,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653204891
    },
    {
        "content": "<p>Still, I wouldn't use <code>⊕</code>, since that's also used for nimber addition</p>",
        "id": 283218420,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653204930
    },
    {
        "content": "<p>Wikipedia also suggests the # ⨳ notations.</p>",
        "id": 283218467,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1653204967
    },
    {
        "content": "<p>Yeah, I'd rather go with that</p>",
        "id": 283218471,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653204978
    },
    {
        "content": "<p><code>#</code> could potentially clash with the notation for cardinality, but I find it unlikely we'll ever involve the two at the same time</p>",
        "id": 283218485,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653205009
    },
    {
        "content": "<p>Hmm... actually, I'm not so sure about the local notation anymore</p>",
        "id": 283218975,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653205805
    },
    {
        "content": "<p>Because, the theorems about <code>nat_ordinal</code> are most naturally stated in terms of <code>nat_ordinal</code>, of course</p>",
        "id": 283218979,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653205819
    },
    {
        "content": "<p>But the <code>#</code> notation requires us to state our theorems as theorems about <code>ordinal</code> instead</p>",
        "id": 283218980,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653205830
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/283218485\">said</a>:</p>\n<blockquote>\n<p><code>#</code> could potentially clash with the notation for cardinality, but I find it unlikely we'll ever involve the two at the same time</p>\n</blockquote>\n<p>umm... cardinal and ordinal are very often used together</p>",
        "id": 283218983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653205839
    },
    {
        "content": "<p>Hmm.... true</p>",
        "id": 283218989,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653205859
    },
    {
        "content": "<p>I think it doesn't need a symbol beyond what it gets via <code>nat_ordinal</code></p>",
        "id": 283218998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653205911
    },
    {
        "content": "<p><code>a.nadd b</code> / <code>a.nmul b</code>?</p>",
        "id": 283219054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653205950
    },
    {
        "content": "<p>If <code>a</code> <code>b</code> are <code>nat_ordinal</code> then these are just <code>a + b</code> <code>a * b</code>.</p>",
        "id": 283219077,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1653206019
    },
    {
        "content": "<p>I mean for the <code>ordinal</code> ops</p>",
        "id": 283219079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206031
    },
    {
        "content": "<p>Oh yes</p>",
        "id": 283219085,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1653206041
    },
    {
        "content": "<p><code>nat_ordinal</code> would wrap those ops and give them notation</p>",
        "id": 283219125,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206049
    },
    {
        "content": "<p>Yes <code>nadd</code> <code>nmul</code> look short enough. Though I just looked into Unicode just for fun:</p>\n<p>The official name for ⨳ <code>⨳</code> is \"smash product\", and in the <a href=\"http://shapecatcher.com/unicode/block/Supplemental_Mathematical_Operators\">same block</a> there are also ⩩ <code>⩩</code> and ⩨ <code>⩨</code>, but ⌗ <code>⌗</code> is in a different block (0x2317, Miscellaneous Technical). This vertical version looks better than the slanted # <code>#</code>, and also avoids conflict.<br>\nThere is also<br>\nVai syllable pu: ꖛ <code>ꖛ</code><br>\nUnicode hexadecimal: 0xa59b<br>\nIn block: Vai (a language in Liberia and Sierra Leone)</p>",
        "id": 283219159,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1653206125
    },
    {
        "content": "<p>I'm worried that by wrapping around <code>+</code> and <code>*</code>, we either</p>\n<ul>\n<li>lose a lot of flexibility due to not having typeclasses</li>\n<li>have to prove a lot of lemmas twice</li>\n</ul>",
        "id": 283219161,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653206147
    },
    {
        "content": "<p>? <code>nat_ordinal</code> would have typeclasses</p>",
        "id": 283219202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206182
    },
    {
        "content": "<p>you could use <code>nat_ordinal</code> to prove theorems about <code>nadd</code> and <code>nmul</code> by wrapping, but I don't think there will be a huge number of such lemmas</p>",
        "id": 283219222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206245
    },
    {
        "content": "<p>Yeah, but we wouldn't have, say <code>nadd_assoc</code> or <code>nadd_comm</code>, or <code>nadd_lt_nadd_left</code>, ... unless we went ahead and wrote every single one of them out</p>",
        "id": 283219223,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653206246
    },
    {
        "content": "<p>you will definitely have <code>nadd_assoc</code> and <code>nadd_comm</code></p>",
        "id": 283219227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206270
    },
    {
        "content": "<p>because you have to prove those</p>",
        "id": 283219230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206276
    },
    {
        "content": "<p>My point is that we have those for <code>+</code> on <code>nat_ordinal</code> rather than for <code>nadd</code></p>",
        "id": 283219276,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653206297
    },
    {
        "content": "<p>I guess it's not <em>that</em> much boilerplate we'd need to add, but still</p>",
        "id": 283219284,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653206310
    },
    {
        "content": "<p>you will have them on nat_ordinal by wrapping <code>nadd_assoc</code></p>",
        "id": 283219287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206314
    },
    {
        "content": "<p>calling the operation <code>+</code> doesn't magically prove it is commutative and associative</p>",
        "id": 283219300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206335
    },
    {
        "content": "<p>there are some \"theorems for free\" but that is not one of them</p>",
        "id": 283219317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206385
    },
    {
        "content": "<p>like <code>nadd_left_assoc</code>, okay you might want to defer to group lemmas (although the proof is so trivial it might be more work to prove by reflecting to <code>nat_ordinal</code> than directly)</p>",
        "id": 283219423,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206415
    },
    {
        "content": "<p>No, I rather mean</p>",
        "id": 283219471,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653206493
    },
    {
        "content": "<p>If we were to wrap around <code>+</code> by using <code>nadd</code>, we'd need to prove a bunch of boilerplate like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">nadd_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">nadd</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">nadd</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">add_comm</span> <span class=\"n\">nat_ordinal</span> <span class=\"n\">_</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nadd_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">nadd</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nadd</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">nadd</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">nadd</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">add_assoc</span> <span class=\"n\">nat_ordinal</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>and so on</p>",
        "id": 283219478,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653206514
    },
    {
        "content": "<p>But I guess it's not that much boilerplate anyways</p>",
        "id": 283219524,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653206530
    },
    {
        "content": "<p>I'm saying that those lemmas would have substantive proofs</p>",
        "id": 283219528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206537
    },
    {
        "content": "<p>Sure, they'd have the proofs from <code>nat_ordinal</code></p>",
        "id": 283219534,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653206557
    },
    {
        "content": "<p>and they would be referenced in the <code>instance : add_comm_group nat_ordinal</code></p>",
        "id": 283219537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206560
    },
    {
        "content": "<p>Oh yeah, I'm aware of that</p>",
        "id": 283219543,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653206578
    },
    {
        "content": "<p>It seems another occasion where we'd like to <code>norm_cast</code> into <code>nat_ordinal</code> when we want to prove something about nat sum/prod, in order for instances on <code>nat_ordinal</code> to fire. Maybe just a little bit of boilerplate would make that work? I haven't tried it with pgame-&gt;game.</p>",
        "id": 283219545,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1653206582
    },
    {
        "content": "<p>Personally I think <code>nat_ordinal</code> and <code>nadd</code> will not get much use beyond the few pgame lemmas you are working on right now</p>",
        "id": 283219611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206654
    },
    {
        "content": "<p>they are pretty much only ever brought up in connection with surreals / combinatorial games</p>",
        "id": 283219632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206681
    },
    {
        "content": "<p>which is why I think having a couple definitions and no notation is fine</p>",
        "id": 283219646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653206719
    },
    {
        "content": "<p>I went ahead and defined <code>nadd</code> on <code>ordinal</code>. As expected, there were a lot of boilerplate lemmas to transfer over, though they're almost all def-eq so that's no issue. I think this is a good price to pay for much simpler notation.</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/14291/commits/f5c5e1e710c92089b88f7f329626f45959785b97\">https://github.com/leanprover-community/mathlib/pull/14291/commits/f5c5e1e710c92089b88f7f329626f45959785b97</a></p>",
        "id": 283220417,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653207932
    },
    {
        "content": "<p>And yeah, I guess that what I'm ultimately doing is pretty niche. But that doesn't mean we can't make it look pretty!</p>",
        "id": 283220482,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208072
    },
    {
        "content": "<p>It looks like <code>nat_ordinal</code> has a ton of boilerplate going in the opposite direction</p>",
        "id": 283220505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208101
    },
    {
        "content": "<p>my suggesion is to steal the definition of <code>nat_ordinal.add</code> and paste it in <code>ordinal.nadd</code></p>",
        "id": 283220511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208124
    },
    {
        "content": "<p>and then prove <code>ordinal.nadd_assoc</code> directly</p>",
        "id": 283220517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208136
    },
    {
        "content": "<p>and then <code>nat_ordinal</code> will only be boilerplate lemmas</p>",
        "id": 283220530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208167
    },
    {
        "content": "<p>I don't think this will entirely work out, since a few of the boilerplate lemmas (the <code>nadd_lt_nadd</code> ones) are generated from the covariant and contravariant instances</p>",
        "id": 283220613,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208258
    },
    {
        "content": "<p>So at the very least, those have to be proven in <code>nat_ordinal</code> first</p>",
        "id": 283220619,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208274
    },
    {
        "content": "<p>Aren't those instances true on ordinal too?</p>",
        "id": 283220632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208300
    },
    {
        "content": "<p>Not all of them, and even if they were, they wouldn't be on the same operation!</p>",
        "id": 283220685,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208327
    },
    {
        "content": "<p>of course, <code>s/+/nadd/</code></p>",
        "id": 283220692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208351
    },
    {
        "content": "<p>and if they aren't instances, just call them <code>nadd_lt_nadd</code></p>",
        "id": 283220697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208369
    },
    {
        "content": "<p>The instances automatically generate the <code>iff</code> and <code>cancel</code> lemmas though</p>",
        "id": 283220709,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208398
    },
    {
        "content": "<p>If I proved these theorems on <code>ordinal</code> first, I'd need to manually prove those lemmas</p>",
        "id": 283220716,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208418
    },
    {
        "content": "<p>which instance are you talking about specifically?</p>",
        "id": 283220765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208452
    },
    {
        "content": "<p>all the ones I see apply to ordinal too</p>",
        "id": 283220772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208465
    },
    {
        "content": "<p>I'm talking about <code>add_covariant_class_lt</code> and the seven other similar ones</p>",
        "id": 283220777,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208484
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">add_covariant_class_lt</span> <span class=\"o\">:</span>\n  <span class=\"n\">covariant_class</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">nadd</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>et al</p>",
        "id": 283220787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208516
    },
    {
        "content": "<p>Unfortunately, those instances don't have support for any operations other than <code>+</code>,<code>*</code>, or their swapped counterparts (and relations other than <code>&lt;</code> and <code>≤</code>)</p>",
        "id": 283220859,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208599
    },
    {
        "content": "<p>So doing this wouldn't autogenerate the lemmas</p>",
        "id": 283220871,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208611
    },
    {
        "content": "<p>In fact, it wouldn't even give us access to the <code>add_lt_add_left</code> and such lemmas</p>",
        "id": 283220883,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208629
    },
    {
        "content": "<p>Since they require a <code>has_add</code> instance specifically</p>",
        "id": 283220899,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208644
    },
    {
        "content": "<p>do you want <code>rel_iff_cov</code>?</p>",
        "id": 283220972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208727
    },
    {
        "content": "<p>poking around in the relevant files I see several generic lemmas, they have generic names of course</p>",
        "id": 283221009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208782
    },
    {
        "content": "<p>I think if the instances are expressible they should definitely be stated on <code>ordinal</code>, possibly in addition to <code>nat_ordinal</code></p>",
        "id": 283221091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653208910
    },
    {
        "content": "<p>My understanding is that there's little to no support for these custom covariant and contravariant classes</p>",
        "id": 283221131,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208956
    },
    {
        "content": "<p>It's the reason I didn't implement them for <code>lf</code> on <code>pgame</code></p>",
        "id": 283221133,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208968
    },
    {
        "content": "<p>Maybe someone else can confirm</p>",
        "id": 283221137,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653208973
    },
    {
        "content": "<p>I'm wondering what kind of nontrivial thing you are even getting out of these classes. We have it stated in a bunch of different ways that x &lt; y -&gt; f x &lt; f y implies f is injective and strictly increasing and iff-preserves lt and le</p>",
        "id": 283221209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653209076
    },
    {
        "content": "<p>but not having the lemmas doesn't seem like a good reason to not have the instances</p>",
        "id": 283221230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653209133
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">nadd_lt_nadd_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">♯</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">♯</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">add_lt_add_left</span> <span class=\"n\">nat_ordinal</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">lt_of_nadd_lt_nadd_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">♯</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">♯</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">lt_of_add_lt_add_left</span> <span class=\"n\">nat_ordinal</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nadd_lt_nadd_iff_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">♯</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">♯</span> <span class=\"n\">c</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">add_lt_add_iff_left</span> <span class=\"n\">nat_ordinal</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>We don't need all three of these, the last one is plenty</p>",
        "id": 283221339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653209321
    },
    {
        "content": "<p>Well, we get all three almost for free on <code>nat_ordinal</code></p>",
        "id": 283221359,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653209393
    },
    {
        "content": "<p>I know, but we get all three for free just from <code>nadd_lt_nadd_iff_left</code></p>",
        "id": 283221402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653209413
    },
    {
        "content": "<p>in fact, you could probably prove the first two even shorter by using the last one</p>",
        "id": 283221412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653209447
    },
    {
        "content": "<p>but I would just drop them, we try to discourage the one way version of iff lemmas unless they are <em>really</em> heavily used</p>",
        "id": 283221424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653209502
    },
    {
        "content": "<p>it's more compositional that way</p>",
        "id": 283221467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653209537
    },
    {
        "content": "<p>The way I see it, if we're going to write down boilerplate, we might as well be thorough</p>",
        "id": 283221502,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653209639
    },
    {
        "content": "<p>I wouldn't mourn the loss of the one-sided theorems though</p>",
        "id": 283221542,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653209649
    },
    {
        "content": "<p>well it's a lot less boilerplate if you do it the other way around (I contest)</p>",
        "id": 283221558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653209700
    },
    {
        "content": "<p>like <code>nat_ordinal.blsub</code> doesn't need to exist at all</p>",
        "id": 283221582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653209727
    },
    {
        "content": "<p>also ditto on what eric said, instead of <code>a + b ≤ of_nat_ordinal (to_nat_ordinal a + to_nat_ordinal b)</code> you should use only one of the two functions at a time, <code>to_nat_ordinal (a + b) ≤ to_nat_ordinal a + to_nat_ordinal b</code></p>",
        "id": 283221669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653209870
    },
    {
        "content": "<p>The advantage of having it is that for <code>n : nat_ordinal</code>, <code>n.blsub</code> doesn't resolve to something with a messy type</p>",
        "id": 283221714,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653209901
    },
    {
        "content": "<p>I don't think you should ever need to write <code>n.blsub</code></p>",
        "id": 283221728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653209933
    },
    {
        "content": "<p>if all the substantive proof is over <code>ordinal</code> and <code>nadd</code> then the only thing that <code>nat_ordinal</code> needs to do is lift the ring ops</p>",
        "id": 283221835,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653210031
    },
    {
        "content": "<p><code>nat_ordinal.blsub</code> was actually Eric's suggestion, haha</p>",
        "id": 283221843,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653210060
    },
    {
        "content": "<p>It really only makes things easier to look at</p>",
        "id": 283221871,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653210107
    },
    {
        "content": "<p>I could remove it and save a few rewrites</p>",
        "id": 283221874,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653210122
    },
    {
        "content": "<p>I'm saying that blsub of a nat_ordinal is not a thing that should be happening</p>",
        "id": 283221921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653210152
    },
    {
        "content": "<p>regardless of how it is written</p>",
        "id": 283221934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653210172
    },
    {
        "content": "<p>From a mathematical perspective, you mean?</p>",
        "id": 283221935,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653210180
    },
    {
        "content": "<p>yes</p>",
        "id": 283221939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653210188
    },
    {
        "content": "<p>it's used inside the definition of <code>nat_ordinal.add</code> but if that is defined directly on <code>ordinal</code> then I think you won't ever need it elsewhere</p>",
        "id": 283221957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653210230
    },
    {
        "content": "<p>Surely from a mathematical perspective, <code>nat_ordinal</code> wouldn't need to exist?</p>",
        "id": 283222001,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653210248
    },
    {
        "content": "<p>It only exists because Lean doesn't allow us to define more than one addition for a type</p>",
        "id": 283222009,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653210268
    },
    {
        "content": "<p>Mathematicians have no issue with that</p>",
        "id": 283222013,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653210275
    },
    {
        "content": "<p>sure, so do your best to not use it at all and see how far you can get</p>",
        "id": 283222023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653210301
    },
    {
        "content": "<p>(that's not sarcasm)</p>",
        "id": 283222031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653210310
    },
    {
        "content": "<p>I can believe that there are some theorems that currently are only stated for plus-like things so you need to transfer stuff to nat_ordinal, but just use it to get the theorem and then go back to <code>ordinal</code> to finish the proof</p>",
        "id": 283222117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653210408
    },
    {
        "content": "<p>(and don't forget that you can switch between <code>nat_ordinal</code> and <code>ordinal</code> namespaces multiple times)</p>",
        "id": 283222146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653210480
    },
    {
        "content": "<p>I just realised, another option is to make notation that does all the casting stuff for you, and then you should be able to do many <code>rw</code>s and stuff as if the notation was a real +/*</p>",
        "id": 283223695,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1653213005
    },
    {
        "content": "<p>I think I get your point: we have <code>nat_ordinal</code> for the instances, and nothing more, right?</p>",
        "id": 283243421,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653241656
    },
    {
        "content": "<p>I like that design better</p>",
        "id": 283243910,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653242359
    },
    {
        "content": "<p>It should avoid most if not all of the annoying casting we currently have</p>",
        "id": 283243920,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653242368
    },
    {
        "content": "<p>And if we ever need some theorem that's available through an instance on <code>nat_ordinal</code>, we can simply def-eq cast it</p>",
        "id": 283243926,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653242393
    },
    {
        "content": "<p>What precedences should I set for <code>♯</code> and <code>⨳</code>?</p>",
        "id": 283246160,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653245733
    },
    {
        "content": "<p>I'm still not using the latter, but still</p>",
        "id": 283246165,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653245738
    },
    {
        "content": "<p>For this application, it makes sense to make them the same as + and * respectively</p>",
        "id": 283247912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653248260
    },
    {
        "content": "<p>And what would those precedences be?</p>",
        "id": 283248059,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653248428
    },
    {
        "content": "<p>I don't know where to find them</p>",
        "id": 283248061,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653248433
    },
    {
        "content": "<p>By the way, I did the refactor Mario suggested, and the lemmas look much nicer!</p>",
        "id": 283248228,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653248661
    },
    {
        "content": "<p><code>#print +</code></p>",
        "id": 283248998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653249669
    },
    {
        "content": "<p>I think it is 65</p>",
        "id": 283249004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653249689
    },
    {
        "content": "<p>Currently having a go at defining natural multiplication and I'm already at a roadblock with distributivity</p>",
        "id": 283266585,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653274942
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/OJ2aKNZiSNg5vo6pUm6p3ffW/image.png\">image.png</a> Other than a stupidly long <code>rw</code> chain, how can I prove this?</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/OJ2aKNZiSNg5vo6pUm6p3ffW/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/OJ2aKNZiSNg5vo6pUm6p3ffW/image.png\"></a></div>",
        "id": 283266592,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653274959
    },
    {
        "content": "<p>(note that the terms <code>a' ⨳ b'</code> and <code>a ⨳ b'</code> in <code>this</code> cancel out, giving the result)</p>",
        "id": 283266599,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653274973
    },
    {
        "content": "<p>I could cast this into a (huge) expression in <code>nat_ordinal</code>, but afaik there's no tactic that can finish the goal even then</p>",
        "id": 283266679,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653275071
    },
    {
        "content": "<p>A calc block is probably the clearest way</p>",
        "id": 283267798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653276618
    },
    {
        "content": "<p>you should be able to normalize it using <code>simp [comm, left_comm, assoc]</code></p>",
        "id": 283267830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653276679
    },
    {
        "content": "<p>Is there any way I can normalize it, while specifying the order of the terms?</p>",
        "id": 283267886,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653276730
    },
    {
        "content": "<p>That would be extremely useful if possible</p>",
        "id": 283267887,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653276737
    },
    {
        "content": "<p>one hack is to choose fortuitous variable names</p>",
        "id": 283268156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653277158
    },
    {
        "content": "<p>otherwise, you are probably better off using <code>rw [left_comm]</code> to bring something to the front</p>",
        "id": 283268234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653277213
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/left_comm\">docs#left_comm</a></p>",
        "id": 283268343,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653277440
    },
    {
        "content": "<p>This?</p>",
        "id": 283268398,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653277487
    },
    {
        "content": "<p><code>nadd_left_comm</code> probably</p>",
        "id": 283268547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653277710
    },
    {
        "content": "<p>Oh, I see!</p>",
        "id": 283269319,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653278702
    },
    {
        "content": "<p>Once you <code>simp [assoc]</code> you can use <code>nadd_left_comm</code> to move terms as you will</p>",
        "id": 283269326,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653278716
    },
    {
        "content": "<p>Clever!</p>",
        "id": 283269328,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653278718
    },
    {
        "content": "<p>I did it! I managed to prove this!</p>",
        "id": 283269428,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653278852
    },
    {
        "content": "<p>And it only took like 10 <code>rw</code>s!</p>",
        "id": 283269431,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653278858
    },
    {
        "content": "<p>On a just vaguely related note: if you had <em>actual</em> <code>has_add.add</code>, the proposed tactic <code>move_add</code> gives you the option of specifying which terms in a sum should be first/last at will.  You can also of course pass the full permutation, if you so wish!</p>\n<p>I'm simply bringing this up since it is the second time that I see a place where <code>move_add</code> would have been wanted \"in the wild\".  Also, adding support for operations other than <code>+</code> would be fairly easy.</p>",
        "id": 283270984,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1653281193
    },
    {
        "content": "<p>you would still need to know that the new operation is comm/assoc</p>",
        "id": 283271003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653281265
    },
    {
        "content": "<p>Yes, you would need the analogues of add_assoc, add_comm and add_left_comm.</p>",
        "id": 283271054,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1653281302
    },
    {
        "content": "<p>These are the three \"external\" inputs to the tactic, everything else is moving exprs around.</p>",
        "id": 283271068,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1653281344
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/283270984\">said</a>:</p>\n<blockquote>\n<p>I'm simply bringing this up since it is the second time that I see a place where <code>move_add</code> would have been wanted \"in the wild\".  Also, adding support for operations other than <code>+</code> would be fairly easy.</p>\n</blockquote>\n<p>Make that a third! I would have benefited a lot from that in the surreal multiplication proof</p>",
        "id": 283271285,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653281630
    },
    {
        "content": "<p>I have some huge <code>rw</code> blocks over there too</p>",
        "id": 283271287,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653281636
    },
    {
        "content": "<p>Ok, I'll leave the current PR as is, since it has already gone through some revisions.  But I will add a second PR allowing \"custom\" operations.</p>\n<p>I was thinking of just <code>+</code> and <code>*</code> support, but I might try to see if I can get a \"generic\" tactic that takes also an operation as input.  It might be tricky to specify the comm/assoc lemmas to use in this case, though.</p>",
        "id": 283271478,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1653281787
    },
    {
        "content": "<p>We wouldn't need this if there were some easy way to convert a lemma on <code>ordinal</code> and natural operations to the corresponding one on <code>nat_ordinal</code></p>",
        "id": 283272248,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653282773
    },
    {
        "content": "<p>I've heard people say <code>norm_cast</code> could help but I don't really know how that works</p>",
        "id": 283272253,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653282782
    },
    {
        "content": "<p>I do not know neither the maths, nor the mathlib side of this story, so I'll leave this to someone else!</p>\n<p>My naïve view is that <code>norm_cast</code> would take care of dealing with seen and unseen coercions and uniformize everything.  Thus, if there were a coe between <code>nat_ordinal</code> and <code>pgames</code> (or <code>games</code>, I really don't know), then <code>norm_cast</code> could convert expressions where one appear into expressions where the other appears.</p>",
        "id": 283272526,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1653283198
    },
    {
        "content": "<p>I think that you might have to tag the relevant lemmas with a <code>norm_cast</code> attribute, but this is something that I have never done and might be wrong about.</p>",
        "id": 283272590,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1653283239
    },
    {
        "content": "<p>I managed to prove the basic properties of natural multiplication and wow were they painful</p>",
        "id": 283277596,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653288585
    },
    {
        "content": "<p>At least now I'm almost sure I have the correct definition</p>",
        "id": 283277662,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653288635
    },
    {
        "content": "<p>I had to extrapolate a bit since every source I looked at just gave the Cantor form definition instead of the recursive one</p>",
        "id": 283277677,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653288658
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> hydra PR got merged! I got a bit distracted as of late with the whole natural operations schtick, but I'll PR some auxiliary lemmas on <code>cut_expand</code> shortly and hopefully finish the proof with them</p>",
        "id": 283279933,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653290437
    },
    {
        "content": "<p>A few days ago I experimented with the idea of exploiting symmetry to reduce the number of cases in the surreal multiplication proof; e.g. there are 2x2x3=12 cases to show P1 (that x*y is numeric), but I can <a href=\"https://github.com/leanprover-community/mathlib/compare/surreal_mul_symm?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67R566-R581\">almost reduce it to just 3 cases</a> using <a href=\"https://github.com/leanprover-community/mathlib/compare/surreal_mul_symm?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67R340\"><code>P24_neg</code></a>, <code>P24_neg'</code>, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.quot_mul_neg\">docs#pgame.quot_mul_neg</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.quot_mul_comm\">docs#pgame.quot_mul_comm</a> etc. (The 3 cases are used to show <code>left_lt_right</code>, and lines 566-581 use <code>left_lt_right</code> to show all 2x2=4 cases. Line 582 onwards are old proofs.) It seems the <code>&lt;</code> and <code>&gt;</code> cases could also follow from one another. However, using symmetry introduces additional obligations to prove identities and handle induction hypotheses (?), so I'm not sure the proofs will end up shorter. I only thought carefully about proving P1, but I expect to exploit symmetry when proving P2 and P4, you'd still apply the symmetries to P2 and P4 instead of P1.</p>\n<p>The code is obviously very disorganized so I wouldn't be surprised if it ends up being unhelpful ... However <br>\nI am at a conference and don't expect to be able to work on this in the next few days, and since you are getting back to this, I decided to push it in the hope that it could be somewhat inspirational.</p>",
        "id": 283290042,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1653297013
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 283311962,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653309381
    },
    {
        "content": "<p>By the way, as for a tactic to solve numeric obligations</p>",
        "id": 283312318,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653309579
    },
    {
        "content": "<p>You can often use <code>solve_by_elim [numeric.move_left, numeric.move_right]</code></p>",
        "id": 283312446,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653309623
    },
    {
        "content": "<p>I'm wondering</p>",
        "id": 283379624,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653342253
    },
    {
        "content": "<p>Given that the order relations on games are much, much nicer to work with than those on games, should we have a simp lemma converting between them? Or is that dangerous?</p>",
        "id": 283379693,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653342307
    },
    {
        "content": "<p>And if making it a simp lemma isn't the best idea, could it be made norm_cast? I don't know how that works really</p>",
        "id": 283379730,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653342329
    },
    {
        "content": "<p>At the very least we should have the lemmas for rewriting</p>",
        "id": 283380306,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653342663
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/283379693\">said</a>:</p>\n<blockquote>\n<p>Given that the order relations on games are much, much nicer to work with than those on games, should we have a simp lemma converting between them? Or is that dangerous?</p>\n</blockquote>\n<p>one of these should be pgames and I guess it's the first one</p>",
        "id": 283381002,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1653343112
    },
    {
        "content": "<p>Oh sorry</p>",
        "id": 283672195,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653344141
    },
    {
        "content": "<p>It's the second one</p>",
        "id": 283672204,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653344152
    },
    {
        "content": "<p>lost the 5050 ;b</p>",
        "id": 283672318,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1653344210
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> I have some time to look into this again</p>",
        "id": 284078645,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653611425
    },
    {
        "content": "<p>What's the general idea in your simplification? I'm having a bit of a hard time following it</p>",
        "id": 284078658,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653611439
    },
    {
        "content": "<p>I agree with some of your ideas, like separating <code>P1</code> and such into definitions and proving comm lemmas and the like. This should make the proof shorter and easier to follow.</p>",
        "id": 284081895,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653614867
    },
    {
        "content": "<p>I do disagree with various of your ideas here. <code>mul_args</code> should have only two constructors. That way, you get a stronger induction hypothesis for less work (instead of trying to prove that P1 implies both P2 and P4 for the same set of values).</p>",
        "id": 284081992,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653614963
    },
    {
        "content": "<p>Further, defining an ad-hoc relation on <code>mul_args</code> and proving it well founded wouldn't really lead to less work, since we'd still have to prove exactly the same things we're currently proving to prove that it's a subrelation of <code>cut_expand</code>.</p>",
        "id": 284082012,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653614999
    },
    {
        "content": "<p>And totally disagree on defining <code>move_left</code> on <code>{x // numeric x}</code>. There's absolutely no reason we should be working directly with these subtypes. Just separate <code>x</code> and <code>numeric x</code>.</p>",
        "id": 284082121,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653615091
    },
    {
        "content": "<p>Btw I PR'd the lemmas to cast inequalities from <code>pgame</code> to <code>game</code>, and the lemma that relabellings preserve being numeric</p>",
        "id": 284082451,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653615437
    },
    {
        "content": "<p>Oh and also, I don't think that tactic to prove games numeric would be all that useful, since almost always you just apply <code>numeric.move_left</code> and <code>numeric.move_right</code> once or twice</p>",
        "id": 284083347,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653616367
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/284082121\">said</a>:</p>\n<blockquote>\n<p>And totally disagree on defining <code>move_left</code> on <code>{x // numeric x}</code>. There's absolutely no reason we should be working directly with these subtypes. Just separate <code>x</code> and <code>numeric x</code>.</p>\n</blockquote>\n<p>Those are just some random ideas that are not necessarily good. However it seems nice to change <code>numeric</code> from a predicate to <code>set</code>, which allows us to write <code>x : numeric</code> through coercion instead of <code>x : {x // numeric x}</code>: <a href=\"https://github.com/leanprover-community/mathlib/compare/surreal_set?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67L58\">https://github.com/leanprover-community/mathlib/compare/surreal_set?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67L58</a></p>\n<p>I am back from the conference and can probably flesh out and clean up more of my plan in <a href=\"https://github.com/leanprover-community/mathlib/tree/surreal_mul_symm\">branch#surreal_mul_symm</a> this weekend; I'll keep you posted.</p>",
        "id": 284235236,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1653753097
    },
    {
        "content": "<p>Would that still allow for dot notation? If so that might be a good idea</p>",
        "id": 284258759,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653789177
    },
    {
        "content": "<p>From your code it seems like the answer is yes</p>",
        "id": 284259569,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653790529
    },
    {
        "content": "<p>Yeah, this looks like a good idea</p>",
        "id": 284259572,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1653790547
    },
    {
        "content": "<p>I've finished the proof of P1 with my symmetry approach at <a href=\"https://github.com/leanprover-community/mathlib/compare/surreal_mul_symm'?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67R318\">https://github.com/leanprover-community/mathlib/compare/surreal_mul_symm'?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67R318</a><br>\nI'll leave P2 and P4 to tomorrow.</p>",
        "id": 284570576,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654063754
    },
    {
        "content": "<p>Oh nice! I haven't been nearly as free as I thought I'd be, but I'll check your code thoroughly as soon as I can</p>",
        "id": 284653626,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654109273
    },
    {
        "content": "<p>Should the type equality lemmas like <code>x.left_moves = y</code> be <code>simp</code>?</p>",
        "id": 285611510,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654820362
    },
    {
        "content": "<p>I've been told previously that they shouldn't be, but it seems like all over the code this decision has already been taken as a \"yes\"</p>",
        "id": 285611522,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654820379
    },
    {
        "content": "<p>Consider for instance <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.zero_left_moves\">docs#pgame.zero_left_moves</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.one_left_moves\">docs#pgame.one_left_moves</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.pow_half_left_moves\">docs#pgame.pow_half_left_moves</a></p>",
        "id": 285611577,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654820405
    },
    {
        "content": "<p>Moreover, <code>zero_left_moves</code> is actually used a few times in some <code>dsimp</code>s</p>",
        "id": 285611606,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654820434
    },
    {
        "content": "<p>The rationale I got for not making them <code>simp</code> is that type equality is finicky and that this could break things. But surely <code>simp</code> will just not work in those instances?</p>",
        "id": 285611795,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654820641
    },
    {
        "content": "<p>Moreover, there's a few <code>simp</code> lemmas on types like <code>pempty</code> and <code>punit</code> that aren't available on general empty / unique types</p>",
        "id": 285611844,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654820658
    },
    {
        "content": "<p>Like <code>∀ x : pempty, p x</code> and <code>(∀ x : punit, p x) ↔ p punit.star</code></p>",
        "id": 285611884,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654820704
    },
    {
        "content": "<p>Well, I guess something that should be done anyways is generalizing <code>forall_pempty</code> and <code>exists_pempty</code> to empty types</p>",
        "id": 285616277,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654823148
    },
    {
        "content": "<p>I made an attempt to redefine <code>pSet</code> and <code>pgame</code> such that they have the correct notion of equality (namely \"identity\") out of the box, where type equality is replaced by set equality, but Lean does not accept it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">indexed_set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">indexed_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span><span class=\"o\">,</span> <span class=\"n\">set.range</span> <span class=\"n\">s₁.f</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"n\">s₂.f</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">eq.symm</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">eq.trans</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">pSet</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">quotient</span> <span class=\"bp\">$</span> <span class=\"n\">indexed_set.setoid</span> <span class=\"n\">pSet</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pSet</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">pgame</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">quotient</span> <span class=\"bp\">$</span> <span class=\"n\">indexed_set.setoid</span> <span class=\"n\">pgame</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span>\n<span class=\"c\">/-</span><span class=\"cm\">inductive type being declared can only be nested</span>\n<span class=\"cm\">inside the parameters of other inductive types -/</span>\n</code></pre></div>\n<p>I then immediately found <a href=\"https://leanprover-community.github.io/archive/stream/113489-new-members/topic/Inductive.20type.20nesting.html\">this thread</a> confirming that <code>quotient</code> is forbidden, so we're out of luck.</p>",
        "id": 285623567,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654829064
    },
    {
        "content": "<p>It seems to me that allowing <code>quotient</code> won't lead to paradoxes that arise when allowing <code>set</code>, but am not sure whether there are other technical problems.</p>\n<p>Personally, I am fine with making type equalities <code>simp</code> lemmas in the situation of <code>pgame</code>s.</p>",
        "id": 285624903,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654830388
    },
    {
        "content": "<p>But, the philosophy is that we care about the underlying set and not the indexing type, so maybe this and the right/existential versions are more benign lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">left_moves_induction</span> <span class=\"o\">{</span><span class=\"n\">xl</span> <span class=\"n\">xr</span> <span class=\"n\">xL</span> <span class=\"n\">xR</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">pgame</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">xl</span> <span class=\"n\">xr</span> <span class=\"n\">xL</span> <span class=\"n\">xR</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left_moves</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"bp\">$</span> <span class=\"n\">move_left</span> <span class=\"n\">_</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">xl</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"bp\">$</span> <span class=\"n\">xL</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n</code></pre></div>",
        "id": 285626043,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654831478
    },
    {
        "content": "<p>Sure, but those won't fire whenever the game in question isn't <code>reducible</code></p>",
        "id": 285626185,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654831664
    },
    {
        "content": "<p>Also, there's a few rare situations in which we do care about the types, though granted, they arise only because of our specific design. That's when we're proving equalities (not equivalences or relabellings) between pre-games.</p>",
        "id": 285626318,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654831758
    },
    {
        "content": "<p>Or when we're showing that the move sets for some game are <code>empty</code> or <code>unique</code></p>",
        "id": 285626334,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654831790
    },
    {
        "content": "<p>Most of the time you can just use <code>pempty.is_empty</code> or <code>punit.unique</code> for these proofs, but if the definition is irreducible, then you need to do some type rewriting</p>",
        "id": 285626449,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654831872
    },
    {
        "content": "<p>Something like that happens in the <code>ordinal.lean</code> file</p>",
        "id": 285626458,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654831898
    },
    {
        "content": "<p>Whether the type is reducible, you should be able to do <code>apply (left_moves_induction _).2</code>.</p>",
        "id": 285628691,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654834174
    },
    {
        "content": "<p>That wouldn't work either</p>",
        "id": 285628902,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654834389
    },
    {
        "content": "<p>I'm talking about games that aren't definitionally equal to anything of the form <code>mk xl xr xL xR</code></p>",
        "id": 285628908,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654834403
    },
    {
        "content": "<blockquote>\n<p>I'm talking about games that aren't definitionally equal to anything of the form mk xl xr xL xR</p>\n</blockquote>\n<p>For example?</p>",
        "id": 285629051,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654834534
    },
    {
        "content": "<p>The simp lemmas you want are for explicit pgames, right? The examples you gave were zero, one, and pow_half n. And <code>mk</code> is the only constructor...</p>",
        "id": 285629149,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654834629
    },
    {
        "content": "<p><code>ordinal.to_pgame</code></p>",
        "id": 285629573,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654835123
    },
    {
        "content": "<p>Since it's defined via the equation compiler, you need to use <code>rw to_pgame</code> to prove the equality with <code>mk _ _ _ _</code></p>",
        "id": 285629594,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654835146
    },
    {
        "content": "<p>Which is definitely odd, but that's how it goes</p>",
        "id": 285629595,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654835151
    },
    {
        "content": "<p>Another example might be a pre-game retrieved from an <code>exists</code></p>",
        "id": 285629644,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654835179
    },
    {
        "content": "<p>It's not going to be def-eq to any specific <code>mk _ _ _ _</code></p>",
        "id": 285629655,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654835190
    },
    {
        "content": "<p>Although of course you can case on it</p>",
        "id": 285629677,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654835198
    },
    {
        "content": "<blockquote>\n<p>Another example might be a pre-game retrieved from an exists</p>\n</blockquote>\n<p>I don't think you can simp its moves though because you don't know what they are ...</p>",
        "id": 285630089,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654835756
    },
    {
        "content": "<p>For <code>ordinal.to_pgame</code>, yes if you <code>#print</code> it you see it's <code>well_founded.fix</code> under the hood:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ordinal.to_pgame._main._pack</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">ordinal</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">ordinal</span><span class=\"o\">),</span> <span class=\"n\">pgame</span><span class=\"o\">)</span> <span class=\"n\">_x</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">ordinal</span><span class=\"o\">),</span>\n  <span class=\"n\">has_well_founded.wf.fix</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">ordinal</span><span class=\"o\">),</span>\n       <span class=\"n\">id_rhs</span> <span class=\"o\">((</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">_y</span> <span class=\"o\">:</span> <span class=\"n\">ordinal</span><span class=\"o\">),</span> <span class=\"n\">has_well_founded.r</span> <span class=\"n\">_y</span> <span class=\"n\">_x</span> <span class=\"bp\">→</span> <span class=\"n\">pgame</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">pgame</span><span class=\"o\">)</span>\n         <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">_y</span> <span class=\"o\">:</span> <span class=\"n\">ordinal</span><span class=\"o\">),</span> <span class=\"n\">has_well_founded.r</span> <span class=\"n\">_y</span> <span class=\"n\">_x</span> <span class=\"bp\">→</span> <span class=\"n\">pgame</span><span class=\"o\">),</span>\n            <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">quotient.out</span> <span class=\"n\">_x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">α</span> <span class=\"n\">pempty</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">quotient.out</span> <span class=\"n\">_x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"k\">let</span> <span class=\"n\">hwf</span> <span class=\"o\">:</span> <span class=\"n\">typein</span> <span class=\"n\">has_lt.lt</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">_x</span> <span class=\"o\">:=</span> <span class=\"n\">_</span> <span class=\"k\">in</span> <span class=\"n\">_F</span> <span class=\"o\">(</span><span class=\"n\">typein</span> <span class=\"n\">has_lt.lt</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">hwf</span><span class=\"o\">)</span>\n              <span class=\"n\">pempty.elim</span><span class=\"o\">))</span>\n    <span class=\"n\">_x</span>\n</code></pre></div>",
        "id": 285630137,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654835792
    },
    {
        "content": "<p>But in this case <code>to_pgame_left_moves</code> etc. aren't defeq, so they won't fire with <code>dsimp</code> and rewriting by them will cause problems, right? Seems a situation where induction principles would be more useful.</p>",
        "id": 285631169,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654836945
    },
    {
        "content": "<p>Would this be more convenient?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">to_pgame_move_left</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">ordinal</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">set.range</span> <span class=\"n\">o.to_pgame.move_left</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">o.out.α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">typein</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_pgame</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">to_pgame</span><span class=\"o\">],</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>together with lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">I₁</span> <span class=\"n\">I₂</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">I₁</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">I₂</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">range_eq_iff_forall_exists</span> <span class=\"o\">:</span>\n  <span class=\"n\">set.range</span> <span class=\"n\">f₁</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"n\">f₂</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i₁</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">i₂</span><span class=\"o\">,</span> <span class=\"n\">f₂</span> <span class=\"n\">i₂</span> <span class=\"bp\">=</span> <span class=\"n\">f₁</span> <span class=\"n\">i₁</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i₂</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">i₁</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">i₁</span> <span class=\"bp\">=</span> <span class=\"n\">f₂</span> <span class=\"n\">i₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i₁</span><span class=\"o\">,</span> <span class=\"n\">h.subst</span> <span class=\"o\">(</span><span class=\"n\">set.mem_range_self</span> <span class=\"n\">i₁</span><span class=\"o\">),</span> <span class=\"bp\">λ</span> <span class=\"n\">i₂</span><span class=\"o\">,</span> <span class=\"n\">h.substr</span> <span class=\"o\">(</span><span class=\"n\">set.mem_range_self</span> <span class=\"n\">i₂</span><span class=\"o\">)⟩,</span>\n <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">set.ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">i₁</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span> <span class=\"n\">hx</span> <span class=\"bp\">▸</span> <span class=\"n\">h.1</span> <span class=\"n\">i₁</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">i₂</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span> <span class=\"n\">hx</span> <span class=\"bp\">▸</span> <span class=\"n\">h.2</span> <span class=\"n\">i₂</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">range_eq_iff_forall_iff</span> <span class=\"o\">:</span>\n  <span class=\"n\">set.range</span> <span class=\"n\">f₁</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"n\">f₂</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"bp\">$</span> <span class=\"n\">f₁</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"bp\">$</span> <span class=\"n\">f₂</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">set.forall_range_iff</span> <span class=\"o\">},</span> <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">revert</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">set.forall_range_iff</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">exacts</span> <span class=\"o\">[(</span><span class=\"n\">h</span> <span class=\"bp\">$</span> <span class=\"n\">set.range</span> <span class=\"n\">f₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">$</span> <span class=\"n\">set.range</span> <span class=\"n\">f₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">range_eq_iff_exists_iff</span> <span class=\"o\">:</span>\n  <span class=\"n\">set.range</span> <span class=\"n\">f₁</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"n\">f₂</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"bp\">$</span> <span class=\"n\">f₁</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"bp\">$</span> <span class=\"n\">f₂</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">not_forall_not</span><span class=\"o\">,</span> <span class=\"n\">not_iff_not</span><span class=\"o\">],</span> <span class=\"n\">rw</span> <span class=\"n\">range_eq_iff_forall_iff</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">convert</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">simp_rw</span> <span class=\"n\">not_not</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 285635147,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654841288
    },
    {
        "content": "<p>More convenient than what? I think the current API works pretty well already</p>",
        "id": 285636089,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654842247
    },
    {
        "content": "<p><code>to_left_moves_to_pgame</code> together with its small API are really all you need</p>",
        "id": 285636196,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654842342
    },
    {
        "content": "<p>My point is that in general when the pgame is defined recursively and not defeq to some <code>mk</code>, you may prove an equality between <code>set.range</code> and automatically unlock the forall/exists lemmas.</p>\n<p>More generally, if you want to change the indexing type, you may show one of the four conditions and automatically get the other three.</p>\n<p>It doesn't seem to me that the APIs around <code>ordinal.to_pgame</code> are completely satisfactory; I think we should strive to eliminate heq lemmas if possible.</p>",
        "id": 285636527,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654842667
    },
    {
        "content": "<p>That approach certainly works, though I still prefer the current one. Building the equivalence between <code>set.Iio o</code> and <code>o.to_pgame.left_moves</code> just makes it really convenient to build a given move, or to reason about an arbitrary one.</p>",
        "id": 285636704,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654842829
    },
    {
        "content": "<p>There is a <code>heq</code> lemma, but it's used only once and never again. If we wanted to, we could make it <code>private</code> and it wouldn't break anything. The API doesn't really depend on it.</p>",
        "id": 285636773,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654842874
    },
    {
        "content": "<p>Moreover, the current aprroach allows you to explicitly build a move that leads to a certain position, instead of just declaring it exists</p>",
        "id": 285637166,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654843275
    },
    {
        "content": "<p>This pattern of building equivalences between left/right moves of games and simpler types is one I've replicated throughout the whole game API, and it's worked very well</p>",
        "id": 285637187,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654843315
    },
    {
        "content": "<p>I think my approach still allows you to build move if desired; it only forgets the equivalence (or weaker correspondences) that goes between the two indexing types, but still remembers the two indexing functions. For example, with this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">ordinal</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">set.range</span> <span class=\"n\">o.to_pgame.move_left</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set.Iio</span> <span class=\"n\">o</span><span class=\"o\">,</span> <span class=\"n\">to_pgame</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">to_pgame</span><span class=\"o\">,</span> <span class=\"n\">convert</span> <span class=\"n\">function.surjective.range_comp</span> <span class=\"o\">(</span><span class=\"n\">enum_iso_out</span> <span class=\"n\">o</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">surjective</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">congr</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">subtype.ext_iff.1</span> <span class=\"o\">((</span><span class=\"n\">enum_iso_out</span> <span class=\"n\">o</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm_apply_apply</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>you can choose to build the move using <code>o.to_pgame.move_left</code> or using <code>to_pgame</code>.</p>",
        "id": 285639158,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654845020
    },
    {
        "content": "<p>What I mean is, say you want a move <code>i</code> such that <code>(to_pgame 2).move_left i = to_pgame 1</code>. With your approach, you need to show <code>to_pgame 1 ∈ set.range (λ x : set.Iio 2, to_pgame x)</code> (which is pretty easy, granted), then rewrite into <code>to_pgame 1 ∈ set.range o.to_pgame.move_left</code>, and that still only tells you that there exists some move with the property you want. You need to use <code>cases</code> to actually retrieve the move. </p>\n<p>If you're building data, you'll instead need to call <code>classical.some</code>.</p>\n<p>With my approach, you can explicitly build said move as <code>to_left_moves_to_pgame ⟨1, one_lt_two⟩</code>, and <code>simp</code> will do the rest.</p>",
        "id": 285639642,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654845454
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordinal.to_pgame_lf\">docs#ordinal.to_pgame_lf</a> is a very good example of this in action.</p>",
        "id": 285639908,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654845705
    },
    {
        "content": "<p>With my approach the proof for <code>to_pgame_lf</code> would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">range_move_left_eq_range_to_pgame</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">ordinal</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">set.range</span> <span class=\"n\">o.to_pgame.move_left</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set.Iio</span> <span class=\"n\">o</span><span class=\"o\">,</span> <span class=\"n\">to_pgame</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> see earlier post -/</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">range_eq_iff_forall_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">I₁</span> <span class=\"n\">I₂</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">I₁</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">I₂</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">set.range</span> <span class=\"n\">f₁</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"n\">f₂</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"bp\">$</span> <span class=\"n\">f₁</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"bp\">$</span> <span class=\"n\">f₂</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> see earlier post -/</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">to_pgame_lf</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ordinal</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a.to_pgame</span> <span class=\"bp\">⧏</span> <span class=\"n\">b.to_pgame</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"n\">range_eq_iff_forall_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">range_move_left_eq_range_to_pgame</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">function.swap</span> <span class=\"n\">lf</span> <span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">move_left_lf</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 285641458,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654846925
    },
    {
        "content": "<p>Yeah, I feel like my approach is simpler both conceptually and in terms of the final code</p>",
        "id": 285641682,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654847113
    },
    {
        "content": "<p>Seems odd having to use a clever induction principle for something like this</p>",
        "id": 285641711,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654847135
    },
    {
        "content": "<p>Especially when the pencil and paper proof of this theorem is just \"since <code>a &lt; b</code>, there's a left move from <code>b.to_pgame</code> to <code>a.to_pgame</code>, Q.E.D\"</p>",
        "id": 285641785,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654847174
    },
    {
        "content": "<p>The following might everything more convenient and will make simp lemmas like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.zero_left_moves\">docs#pgame.zero_left_moves</a> obsolete, but may need a large refactor: namely, for each concrete pgame, register two instances <code>has_left_moves</code> and <code>has_right_moves</code>; for example, for <code>ordinal.to_pgame</code>we register the instance <code>has_left_moves (o.to_pgame)</code> which holds the data of an indexing type <code>set.Iio o</code> (which lies in a higher universe but is more convenient), the indexing function <code>λ x, to_pgame x</code>, and a proof that the range of the indexing function is equal to the range of <code>x.move_left</code>. For the theorems that mentions <code>left_moves</code> and <code>move_left</code>, make a version that takes an additional typeclass argument <code>has_left_moves x</code>, and use the indexing type as <code>left_moves</code> and the indexing function as <code>move_left</code> instead; the new version would be proved from the old using my <code>range_eq_iff_forall_iff</code> and <code>range_eq_iff_exists_iff</code>. This way, I think we can forget about <code>left_moves</code> and always directly work with the desired indexing function.</p>",
        "id": 285685119,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654872122
    },
    {
        "content": "<p>I'm going to oppose this on grounds that it's just too clever</p>",
        "id": 285701233,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654878873
    },
    {
        "content": "<p>I've worked with large and rapidly changing codebases before, and being too clever is what ultimately led to their downfall</p>",
        "id": 285701284,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654878897
    },
    {
        "content": "<p>And really, I don't want to forget about the concrete types. They're a quirk of our design choices, sure, but they're quirks that make sense and are convenient within type theory, which is what we're working with.</p>",
        "id": 285701538,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654879018
    },
    {
        "content": "<p>Well, I'm just trying my best to address your original question about simp lemmas, but it seems you are not open enough to new ideas :( I think in mathlib we are not afraid of doing large refactors, not to mention that the current combinatorial game library is only an isolated small corner of mathlib.</p>\n<p>As a rule of thumb, I think in the case of non-defeq indexing types, the indexing type and the indexing function should be bundled and rewritten together, and equality between <code>set.range</code> is the condition that allows you to rewrite between two such bundled functions.</p>\n<p>My approach doesn't forget about \"concrete types\", instead it designate a preferred indexing type via typeclass resolution. In the case of <code>ordinal.pgame</code>, <code>Iio</code> is arguably the indexing type we want, but it lives in a higher universe, so we must complete the construction using <code>o.out.α</code> first and change the indexing type later. Once we have our desired indexing type and function and know it's equivalent to the original via <code>set.range</code>, I do think we can forget the original indexing type and the transition functions between the indexing types. After all combinatorial game theory talks about <em>sets</em> of left and right options, so if there's anything that depends on the particular indexing type, that doesn't belong to CGT and it would be nice if our API hides it.</p>",
        "id": 285707316,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654881672
    },
    {
        "content": "<p>Don't get me wrong, I'm open to new ideas, but hiding implementation details via an ad-hoc typeclass just doesn't seem like a good one. Once again, the current approach achieves the same thing, and I argue that it achieves it more clearly and easily.</p>",
        "id": 285708822,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654882364
    },
    {
        "content": "<p>And even if we went with your approach, I'm not sure how that answers the question about simp lemmas. We might need them less often, sure, but there's still the possibility.</p>",
        "id": 285709017,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654882457
    },
    {
        "content": "<p>In fact, even if we went with your approach, why would using <code>set.range</code> be preferable to the equivalence approach? And if it isn't, and we went with the equivalence approach, surely the only thing we'd accomplish is hiding the equivalence behind a typeclass, which doesn't seem like a good idea?</p>",
        "id": 285709500,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654882698
    },
    {
        "content": "<p><code>set.range</code> is convenient as there is a large amount of APIs around it, for example <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.surjective.range_comp\">docs#function.surjective.range_comp</a> allows you to reindex by the domain of a surjective function to the original indexing type; an equivalence is in particular surjective.</p>\n<p>Notice that since I aim to forget the original indexing type, there is no way I can keep the equivalence (which I referred to more generally as the \"transition function\"), so it has to be forgotten as well. Of course, if you reindex using <code>g ∘ f</code> instead of <code>g</code>, then the transition function <code>f</code> is effectively still there. In the <code>ordinal.to_pgame</code> case however, we have another preferred indexing function <code>h = to_pgame</code> with domain <code>Iio o</code>, and after <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/285639158\">proving that <code>h = g ∘ f</code></a>, we indeed forget about <code>f</code> and <code>g</code>, which is good IMO.</p>",
        "id": 285711451,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654883758
    },
    {
        "content": "<p>There is a lot of API around equivalences too</p>",
        "id": 285720511,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654888301
    },
    {
        "content": "<p>Another grounds on which I disagree with this refactor is that in Lean, types and functions are simply much more convenient than sets, no matter how you put it. Rephrasing traditionally set-theoretic concepts in terms of types is something mathlib doesn't shy away from, and I don't think we should either unless there's a clear benefit.</p>",
        "id": 285720707,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654888401
    },
    {
        "content": "<p>Let me repeat: I never propose to throw away the indexing type anywhere above. Even in the <code>quotient indexed_set.setoid</code> approach which gives you a type of small sets (as opposed to proper classes), you still construct a small set from an indexing type/function. What I said is results in CGT should be independent of the indexing type/function, so you are free to change to any equivalent indexing type/function, and <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/285635147\">this post</a> contains the essential APIs to work with the equivalence. <code>set.range</code> is just the simplest way (among the four equivalent ways) of stating the most general condition (more general than equivalences) for two indexing types/functions to be considered equivalent. Typeclass mechanism can be used to automatically come up with the preferred indexing type/function.</p>",
        "id": 285721738,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654888979
    },
    {
        "content": "<p>I see, so your approach is strictly more general</p>",
        "id": 285722568,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654889454
    },
    {
        "content": "<p>I don't think there's any current circumstance where we need to deduplicate moves, and I can't think of a possible scenario for this</p>",
        "id": 285722762,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654889567
    },
    {
        "content": "<p>The intention of my current proposal is not to deduplicate move or to define the identity relation on pgames (that would require a condition more general than equality of ranges, as some options may be identical but not equal), but merely to freely switch the original move indexing type/function to our preferred one.</p>\n<p>I think in your original examples zero, one, and pow_half, where the desired indexing type/function is defeq to the original, my proposal isn't of much use and <code>dsimp</code> would be good enough; the <code>ordinal.to_pgame</code> example that you raised later is a situation my proposal is aimed at: we want to change to a indexing type that is not only not defeq to the original, but actually live in a higher universe.</p>\n<p>In the meantime, I've come up with another situation where my proposal would be useful, namely <code>(-x).left_moves</code>, which is equal to <code>x.right_moves</code> but not defeq, which necessitates <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.to_left_moves_neg\">docs#pgame.to_left_moves_neg</a> and 8 lemmas following it. If we make <code>x.right_moves</code> the default indexing type for <code>(-x).left_moves</code>, we should be able to reduce the number of lemmas and simplify the development. I think the same holds true for addition (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.to_left_moves_add\">docs#pgame.to_left_moves_add</a>) and multiplication as well, and other cases of non-defeq-ness due to the use of <code>well_founded.fix</code> (feel free to add examples!).</p>",
        "id": 285751870,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1654913988
    },
    {
        "content": "<p>Ah, I can see the appeal now</p>",
        "id": 285759652,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654924163
    },
    {
        "content": "<p>I think there's an alternate solution that's a bit easier, though</p>",
        "id": 285759670,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654924186
    },
    {
        "content": "<p>We can do induction lemmas</p>",
        "id": 285759673,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654924190
    },
    {
        "content": "<p>\"if a proposition holds true for any left move of <code>x</code>, it holds for any right move of <code>-x</code>\"</p>",
        "id": 285759712,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654924209
    },
    {
        "content": "<p>I think this would achieve the same goal more easily</p>",
        "id": 285759717,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1654924225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> I think <code>impartial</code> shouldn't be a typeclass</p>",
        "id": 286111642,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655230116
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/3974\">#3974</a>, which is where it was made into a typeclass, gives two justifications:</p>\n<ul>\n<li>it means you don't have to use lemmas like <code>impartial_add</code> all the time</li>\n<li><code>grundy_value</code> doesn't have this annoying extra argument</li>\n</ul>",
        "id": 286111754,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655230179
    },
    {
        "content": "<p>The second reasoning is now obsolete, since I removed the <code>impartial</code> argument from <code>grundy_value</code> a while back<br>\n<a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.grundy_value\">docs#pgame.grundy_value</a></p>",
        "id": 286111851,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655230212
    },
    {
        "content": "<p>Although the theorems need it, the definition itself doesn't</p>",
        "id": 286111898,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655230241
    },
    {
        "content": "<p>The first argument seems like not a very compelling reason on its own</p>",
        "id": 286111977,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655230288
    },
    {
        "content": "<p>The major con of this decision is that it goes against the general design style that typeclasses are meant for types, with rare exceptions</p>",
        "id": 286112031,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655230317
    },
    {
        "content": "<p>And of course, there's the issues of using <code>unfreezingI</code></p>",
        "id": 286112261,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655230422
    },
    {
        "content": "<p>I wonder what Scott's reasoning for being against this was</p>",
        "id": 286112291,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655230439
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 286118299,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655233421
    },
    {
        "content": "<p>One advantage of making it an typeclass is that we can introduce instance like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">impartial_mk</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">pgame.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">impartial</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">impartial</span> <span class=\"o\">(</span><span class=\"n\">pgame.mk</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"n\">f</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and for new impartial pgames you define, you can use <code>@[derive impartial]</code> to automatically generate the instance. I don't know how good Lean is at inferring instances like <code>∀ a, impartial (f a)</code>, though.<br>\nThis is more suitable for the \"actual\" impartial games, requiring the left options to be the same as the right options. It's not so suitable for the current mathlib definition, because the G ≈ -G condition can be nontrivial to verify and is not a typeclass.</p>\n<p>Similarly, we might introduce</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">dicotic_mk_nonempty</span> <span class=\"o\">(</span><span class=\"n\">xl</span> <span class=\"n\">xr</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">xl</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">xr</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">xL</span> <span class=\"o\">:</span> <span class=\"n\">xl</span> <span class=\"bp\">→</span> <span class=\"n\">pgame</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xR</span> <span class=\"o\">:</span> <span class=\"n\">xr</span> <span class=\"bp\">→</span> <span class=\"n\">pgame</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">dicotic</span> <span class=\"o\">(</span><span class=\"n\">xL</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">dicotic</span> <span class=\"o\">(</span><span class=\"n\">xR</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">dicotic</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">xl</span> <span class=\"n\">xr</span> <span class=\"n\">xL</span> <span class=\"n\">xR</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">dicotic_mk_empty</span> <span class=\"o\">(</span><span class=\"n\">xl</span> <span class=\"n\">xr</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_empty</span> <span class=\"n\">xl</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_empty</span> <span class=\"n\">xr</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">xL</span> <span class=\"o\">:</span> <span class=\"n\">xl</span> <span class=\"bp\">→</span> <span class=\"n\">pgame</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xR</span> <span class=\"o\">:</span> <span class=\"n\">xr</span> <span class=\"bp\">→</span> <span class=\"n\">pgame</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">dicotic</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">xl</span> <span class=\"n\">xr</span> <span class=\"n\">xL</span> <span class=\"n\">xR</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c\">/-</span><span class=\"cm\"> relabelling of the zero game, not of much use; `zero_dicotic` plus the above should suffice. -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> basically the same as `dicotic_of_is_empty_moves`. -/</span>\n</code></pre></div>\n<p>If Lean has trouble inferring the forall instances, we might introduce</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">dicotic_mk_const</span> <span class=\"o\">(</span><span class=\"n\">xl</span> <span class=\"n\">xr</span> <span class=\"n\">xL</span> <span class=\"n\">xR</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">xl</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">xr</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">dicotic</span> <span class=\"n\">xL</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">dicotic</span> <span class=\"n\">xR</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">dicotic</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">xl</span> <span class=\"n\">xr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">xL</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">xR</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>which covers the case where <code>xl</code> and <code>xr</code> are <code>punit</code>.</p>",
        "id": 286299860,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655347023
    },
    {
        "content": "<p>I'm still not sure if this justifies the typeclass approach. Sure, it's more convenient in some ways, but we aren't making every definition into a typeclass and I'm interested in knowing why</p>",
        "id": 286301185,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655348798
    },
    {
        "content": "<blockquote>\n<p>The major con of this decision is that it goes against the general design style that typeclasses are meant for types, with rare exceptions</p>\n</blockquote>\n<p>Indeed not many examples of typeclasses come to mind that are not for types; typeclasses in <a href=\"https://tqft.net/mathlib/order/rel_classes\">file#order/rel_classes</a>, <a href=\"https://tqft.net/mathlib/algebra/covariant_and_contravariant\">file#algebra/covariant_and_contravariant</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/init/algebra/classes.html\">core/init/algebra/classes</a> are mostly not classes on types but maybe they're meant for some canonical operations/relations on types.</p>\n<p>In this particular case, since pgames are constructed in a hierarchical way, I think it makes sense to introduce classes on elements of <code>pgame</code>: deriving a property of a <code>pgame</code> from similar properties of its constituents is akin to deriving structure on / property of a more complicated type constructed from a simpler type, from the structure on / property of the simpler type, like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/witt_vector.comm_ring\">docs#witt_vector.comm_ring</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.unique_factorization_monoid\">docs#mv_polynomial.unique_factorization_monoid</a>. When we can automate derivation of a structure/property simply by pattern matching, and if it will be used a lot, then I think it's worth being made a typeclass and declare the patterns as instances.</p>",
        "id": 286306049,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655355143
    },
    {
        "content": "<p>Well in that case, it's probably worth making <code>numeric</code> into a typeclass too</p>",
        "id": 286311270,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655360826
    },
    {
        "content": "<p>I wonder what the maintainers think</p>",
        "id": 286311275,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655360831
    },
    {
        "content": "<p>For <code>numeric</code>, the left_lt_right condition isn't usually trivial to check, and lt isn't a typeclass. Of course, if one of the left/right move set is empty, then the condition is vacuously true, and this case could be made an instance.</p>",
        "id": 286312120,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655361343
    },
    {
        "content": "<p>But why a typeclass? We already have a theorem that does the same thing</p>",
        "id": 286378625,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655397059
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.numeric_of_is_empty_left_moves\">docs#pgame.numeric_of_is_empty_left_moves</a></p>",
        "id": 286378724,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655397114
    },
    {
        "content": "<p>Also, I've been told that an alternate and simpler approach is to do the thing you suggested a while back, a tactic to solve <code>numeric</code> goals</p>",
        "id": 286378909,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655397192
    },
    {
        "content": "<p>This does have a precedent in mathlib, with tactics like <code>monotonicity</code> and <code>continuity</code></p>",
        "id": 286378971,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655397238
    },
    {
        "content": "<p>That said, I still haven't gotten any specific reason against the typeclass pattern, other than various people finding it annoying and little use throughout mathlib</p>",
        "id": 286379058,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655397263
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> just told me that the main reason is to avoid overuse of typeclass inference</p>",
        "id": 286383840,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655399529
    },
    {
        "content": "<p>So now the question is, how do we make these <code>numericity</code> and <code>impartiality</code> and whatnot tactics?</p>",
        "id": 286384036,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655399638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/286383840\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> just told me that the main reason is to avoid overuse of typeclass inference</p>\n</blockquote>\n<p>At least, that's what I think the reason is - there could well be a better reason!</p>",
        "id": 286396406,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1655405135
    },
    {
        "content": "<p>Instead of replacing typeclass, <a href=\"https://github.com/leanprover-community/mathlib/pull/13417/files#diff-c562213980884826feaaa85563a2f8634c703d4f6c59bb27c8941d1296dac0f2R38\">the <code>coherence</code> tactic</a> instead <strong>introduced</strong> two typeclasses, so I doesn't seem to be a universal pattern to replace typeclasses by tactics. And after all, <code>apply_instance</code> is also a tactic and it solves goals if you set up the instances right.</p>\n<p>A key difference between numeric/impartial/dicotic and continuity/measurability/monotonicity is that the latter are used widely across mathlib, so overusing typeclasses may cause performance issues, especially when there are many instances of the typeclasses. For the relatively secluded theory of combinatorial games, it seems need not worry much about performance issues. Here (as in the case of <code>coherence</code>) I consider typeclass inference just as a domain-specific way to automate by pattern matching. (I think the typeclasses for the <code>coherence</code> are more secluded and only used in the tactic though.)</p>",
        "id": 286412101,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655412862
    },
    {
        "content": "<p>I'm on board with you, but I still want to hear a maintainer's opinion</p>",
        "id": 286413019,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655413302
    },
    {
        "content": "<p>Maybe let us hear from <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> since he authored both the first coherence tactic <a href=\"https://github.com/leanprover-community/mathlib/pull/13125\">#13125</a> and part of the game library.</p>",
        "id": 286413304,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655413434
    },
    {
        "content": "<p>In my experience, typeclasses work well if nearly all instances can be inferred using only a set of theorems of the form <code>P1 (f x) → P2 (g y) → ... → Q x y ... z</code>, where <code>f x</code> and <code>g y</code> are stated literally and don't do any computation, and there's never theorems <code>P → P</code>, or both <code>P → Q</code> and <code>Q → P</code> at the same time. As soon as you have to deal with equalities (your instance is on <code>fx'</code> and <code>fx' = f x</code> but not literally the same expression), or there is the possibility of looping, you're going to get a bad time.</p>",
        "id": 286467225,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1655458768
    },
    {
        "content": "<p>In this case, if there is a nontrivial equality on <code>pgame</code> (i.e. two <code>pgames</code> can be definitionally or propositionally equal without literally being written the same), I suspect typeclasses can't keep up.</p>",
        "id": 286467531,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1655458953
    },
    {
        "content": "<p>I actually suspect the inference speed is not a huge issue in this case, in my experience the real slowdown comes from checking definitional equality of instances in types that have instances that have types etc.</p>",
        "id": 286467724,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1655459082
    },
    {
        "content": "<p>One approach you could consider is to define a tactic <code>meta def impartial_tac := apply_instance</code> and use this as a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/auto_param\">docs#auto_param</a>: instead of <code>[impartial p]</code> you write <code>(h : impartial p . impartial_tac)</code> and you basically get the same semantics at the moment, and when instances don't scale you replace the code of <code>impartial_tac</code> with something smarter.</p>",
        "id": 286467958,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1655459259
    },
    {
        "content": "<p>Drawback is that instance implicits like <code>[impartial p]</code> are much more common than auto_params so there's the possiblity that some tactics (or some parts of the elaborator) can't handle auto_param well.</p>",
        "id": 286468090,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1655459348
    },
    {
        "content": "<p>Which is why you should first try using <code>apply_instance</code> as definition for the <code>auto_param</code>, then you can be sure that nothing breaks before you upgrade the tactic.</p>",
        "id": 286468174,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1655459400
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> I really love the insights you give to this community <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> Thank you.</p>",
        "id": 286475414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1655464554
    },
    {
        "content": "<p>Do we have any consensus on keeping/refactoring <code>impartial</code>?</p>",
        "id": 286630118,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655529408
    },
    {
        "content": "<p>It seems like the general consensus isn't a good design pattern even though it's slightly useful sometimes</p>",
        "id": 286630211,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655529496
    },
    {
        "content": "<p>So, not really a strong argument either way</p>",
        "id": 286630213,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655529504
    },
    {
        "content": "<p>There might be a sort of \"death by a thousand cuts\" argument against having it as a class</p>",
        "id": 286630585,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655530011
    },
    {
        "content": "<p>Actually, let me list out pros and cons</p>\n<p>Pros:</p>\n<ul>\n<li>theorems like <code>impartial_add</code>, <code>impartial_neg</code>, <code>impartial_sub</code>, <code>impartial_zero</code> can be omitted</li>\n<li>we might be able to <code>derive</code> the class in some common circumstances</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>we have <code>resetI</code> issues when we want to manipulate an impartial pre-game, like e.g. doing induction on it or unfolding the definition</li>\n<li>pre-game equality is really finicky and rarely definitional (due to the inductive definitions), so instances aren't super effective</li>\n<li>typeclasses seem to be somewhat of an antipattern in this situation (there's limited precedent)</li>\n<li><code>grundy_value</code> no longer depends on the typeclass parameter, this was one of the original reasons for the typeclass</li>\n<li>a tactic could do both of the pros</li>\n</ul>",
        "id": 286631050,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655530597
    },
    {
        "content": "<p>I'd also argue that the pros are barely anything to write home about. It's super simple to just call these theorems explicitly.</p>",
        "id": 286631282,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655530874
    },
    {
        "content": "<p>So, even if there's not a strong argument either way, there seem to be much more weak arguments in favor of ditching the class</p>",
        "id": 286631289,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655530906
    },
    {
        "content": "<p>Oh, and one last con: if we keep <code>impartial</code> as a class, then it stands to reason we should do the same for other definitions that are closed under basic operations, like <code>numeric</code> games, or <code>small</code> games, or <code>dicotic</code> games, so the cons scale up</p>",
        "id": 286631388,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655531034
    },
    {
        "content": "<p>I think we're missing some basic machinery mathlib-wide for propositions closed under operations</p>",
        "id": 286641798,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1655545446
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid_class\">docs#submonoid_class</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_submonoid\">docs#is_submonoid</a> come close, but neither seems to be used much for this type of thing</p>",
        "id": 286641821,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1655545503
    },
    {
        "content": "<p>As you may have noticed, I've been a bit busy tying up what I consider to be loose ends with the game API</p>",
        "id": 287412958,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656133525
    },
    {
        "content": "<p>Nothing incredibly important, but still, a lot of things that are breaking changes</p>",
        "id": 287413094,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656133658
    },
    {
        "content": "<p>Once I'm done with all that, I'll be free to clean up the multiplication proof and hopefully PR it</p>",
        "id": 287413164,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656133689
    },
    {
        "content": "<p>Unrelated but what's up with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.restricted\">docs#pgame.restricted</a>?</p>",
        "id": 287417372,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656138405
    },
    {
        "content": "<p>Might have asked before but I'm thinking about this again and I'm confused</p>",
        "id": 287417377,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656138423
    },
    {
        "content": "<p>The description would be accurate if L and R were injective, but they aren't</p>",
        "id": 287417383,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656138438
    },
    {
        "content": "<p>And I can't think of any natural examples of a game being a restriction of another, except for the case of relabellings</p>",
        "id": 287417407,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656138480
    },
    {
        "content": "<p>So this really just seems like an auxiliary definition of sorts</p>",
        "id": 287417449,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656138495
    },
    {
        "content": "<p>Maybe the idea was to define it in terms of injective functions and prove x &lt;= y from that, but then someone realized you didn't need the injective hypothesis</p>",
        "id": 287417628,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656138723
    },
    {
        "content": "<p>I don't think the definition is worthless, it's certainly an... interesting way to show an inequality. But maybe it should be renamed, and at the very least the docstring should be changed</p>",
        "id": 287418609,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656139859
    },
    {
        "content": "<p>Another question, what's up with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.equiv.has_coe\">docs#pgame.equiv.has_coe</a>?</p>",
        "id": 287445069,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656176434
    },
    {
        "content": "<p>I don't think it's currently used anywhere</p>",
        "id": 287445078,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656176445
    },
    {
        "content": "<p>Is there any precedent for using casts for proofs?</p>",
        "id": 287445099,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656176476
    },
    {
        "content": "<p>I just had this idea that, in retrospect, is something <span class=\"user-mention\" data-user-id=\"125393\">@Junyan Xu</span> had suggested</p>",
        "id": 287465305,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656207110
    },
    {
        "content": "<p>We should make a comparison function for games, that outputs one of four outcomes</p>",
        "id": 287465352,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656207149
    },
    {
        "content": "<p>Less, equivalent, greater, fuzzy</p>",
        "id": 287465359,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656207184
    },
    {
        "content": "<p>There's a lot we could do with such a function</p>",
        "id": 287465365,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656207194
    },
    {
        "content": "<p>Of particular interest to me are the fact this function can be lifted to games and surreals, and that its value is the same when you add a game to both sides</p>",
        "id": 287465459,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656207360
    },
    {
        "content": "<p>By proving this, we could get a lot of lemmas currently either taking a lot of API space or missing, almost for free</p>",
        "id": 287465524,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656207440
    },
    {
        "content": "<p>For instance, to prove <code>cmp w x = cmp y z</code> it suffices to prove <code>w \\le x \\iff y \\le z</code> and <code>x \\le w \\iff z \\le y</code>, which in many cases can be reduced to just the <code>\\le</code> case by symmetry</p>",
        "id": 287466439,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656208903
    },
    {
        "content": "<p>But that gives you <code>r w x \\iff r y z</code> for <code>\\le</code> and <code>&lt;</code> and <code>\\equiv</code> and <code>\\fuzzy</code> for free which is super cool</p>",
        "id": 287466488,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656208941
    },
    {
        "content": "<p>I'll prove some basic theorems about this comparison function</p>",
        "id": 287466657,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656209260
    },
    {
        "content": "<p>I can't do a lot since I currently have like three sweeping changes on the same files PR'd</p>",
        "id": 287466661,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656209278
    },
    {
        "content": "<p>Speaking of which, if so done could review my \"comparison API review\" and my refactor on relabellings that would be awesome</p>",
        "id": 287466865,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656209639
    },
    {
        "content": "<p>Oh wow</p>",
        "id": 287476177,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656225269
    },
    {
        "content": "<p>This new API on comparison is so overpowered I was able to comfortably prove pretty much every single variant of the covariant and contravariant theorems on pre-games without ever even appealing to the <code>game</code> structure</p>",
        "id": 287476189,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656225305
    },
    {
        "content": "<p>It's extremely boilerplatey, but that's what peak performance looks like ;)</p>",
        "id": 287476629,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656225971
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/287466439\">said</a>:</p>\n<blockquote>\n<p>For instance, to prove <code>cmp w x = cmp y z</code> it suffices to prove <code>w ≤ x ↔ y ≤ z</code> and <code>x ≤ w ↔ z ≤ y</code>, which in many cases can be reduced to just the `≤ case by symmetry</p>\n</blockquote>\n<p>Do you know about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lt_iff_lt_of_le_iff_le'\">docs#lt_iff_lt_of_le_iff_le'</a>?</p>",
        "id": 287511587,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656274172
    },
    {
        "content": "<p>Should we introduce fuzzy and lf for any preorder? And equiv (≈), which is already there if we use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/antisymm_rel.setoid\">docs#antisymm_rel.setoid</a>.</p>",
        "id": 287515722,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1656280079
    },
    {
        "content": "<p>I think this cmp function can be defined on all preorders without trouble.</p>",
        "id": 287515847,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1656280210
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/cmp\">docs#cmp</a> is already a thing, but it has linear orders in mind.</p>",
        "id": 287515870,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656280273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/287511587\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/287466439\">said</a>:</p>\n<blockquote>\n<p>For instance, to prove <code>cmp w x = cmp y z</code> it suffices to prove <code>w ≤ x ↔ y ≤ z</code> and <code>x ≤ w ↔ z ≤ y</code>, which in many cases can be reduced to just the `≤ case by symmetry</p>\n</blockquote>\n<p>Do you know about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lt_iff_lt_of_le_iff_le'\">docs#lt_iff_lt_of_le_iff_le'</a>?</p>\n</blockquote>\n<p>Yep, these aren't quite the same lemmas though</p>",
        "id": 287516683,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656281407
    },
    {
        "content": "<p>Sure, you also need <a href=\"https://leanprover-community.github.io/mathlib_docs/find/iff.not\">docs#iff.not</a>. But my point is that those two are enough.</p>",
        "id": 287516708,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656281453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/287515722\">said</a>:</p>\n<blockquote>\n<p>Should we introduce fuzzy and lf for any preorder? And equiv (≈), which is already there if we use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/antisymm_rel.setoid\">docs#antisymm_rel.setoid</a>.</p>\n</blockquote>\n<p>We discussed this back when I introduced <code>lf</code>. Our conclusion was basically that yes, we could define this on all partial orders, but it wouldn't be very useful, since we couldn't think of any other example where the relation <code>¬ x ≤ y</code>had any particular importance.</p>",
        "id": 287516734,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656281503
    },
    {
        "content": "<p>Further, if we just defined it in the obvious way, <code>¬ x ≤ y</code>, we'd mess up the def-eqs on pre-games. We'd need to take the approach of <code>lt</code>, where it's defined as a field of the <code>preorder</code> class, and that just seems awkward.</p>",
        "id": 287516807,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656281596
    },
    {
        "content": "<p>Not to mention, the name <code>lf</code> wouldn't make sense at all outside of games</p>",
        "id": 287516814,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656281609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/287516708\">said</a>:</p>\n<blockquote>\n<p>Sure, you also need <a href=\"https://leanprover-community.github.io/mathlib_docs/find/iff.not\">docs#iff.not</a>. But my point is that those two are enough.</p>\n</blockquote>\n<p>I'm talking about a partial order here though, not a linear order</p>",
        "id": 287516884,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656281667
    },
    {
        "content": "<p>Now as for a general <code>cmp</code> function on preorders, we could totally do that</p>",
        "id": 287516895,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656281695
    },
    {
        "content": "<p>We should have the fields <code>lt</code>, <code>gt</code>, <code>equiv</code>, and <code>incomp</code></p>",
        "id": 287516910,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656281727
    },
    {
        "content": "<p>We can even provide some API for converting between these values and those given by <code>cmp</code> on linear orders</p>",
        "id": 287516924,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656281748
    },
    {
        "content": "<p>Who talked about linear orders? <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lt_iff_lt_of_le_iff_le\">docs#lt_iff_lt_of_le_iff_le</a> is for linear_orders, but <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lt_iff_lt_of_le_iff_le'\">docs#lt_iff_lt_of_le_iff_le'</a> is for any preorder.</p>",
        "id": 287516975,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656281804
    },
    {
        "content": "<p>Oh I see! I read the wrong theorem</p>",
        "id": 287516994,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656281868
    },
    {
        "content": "<p>Yeah, what I basically did was prove this but for all the other relations on games</p>",
        "id": 287516998,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656281880
    },
    {
        "content": "<p>Yeah I think that's the play here</p>",
        "id": 287517286,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656282276
    },
    {
        "content": "<p>I'll add the comparison function on preorders, then use it to prove results about pre-games</p>",
        "id": 287517290,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656282288
    },
    {
        "content": "<p>I think I just deciphered what <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.restricted\">docs#pgame.restricted</a> really \"means\"</p>",
        "id": 287531824,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656303787
    },
    {
        "content": "<p>And it's... disappointing</p>",
        "id": 287531829,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656303795
    },
    {
        "content": "<p>Replacr the functions L and R and the hypotheses by existence lemmas</p>",
        "id": 287531882,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656303865
    },
    {
        "content": "<p>And you literally just get a weaker version of the converse of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.le_def\">docs#pgame.le_def</a></p>",
        "id": 287531910,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656303960
    },
    {
        "content": "<p>So really, any inequality <code>x \\le y</code> you can prove by building a restriction, can be proven by just using <code>le_def</code></p>",
        "id": 287531982,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656304022
    },
    {
        "content": "<p>I think that settles it, this needs to go</p>",
        "id": 287532001,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656304069
    },
    {
        "content": "<p>I'm back!</p>",
        "id": 289207964,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657553397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/284570576\">said</a>:</p>\n<blockquote>\n<p>I've finished the proof of P1 with my symmetry approach at <a href=\"https://github.com/leanprover-community/mathlib/compare/surreal_mul_symm'?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67R318\">https://github.com/leanprover-community/mathlib/compare/surreal_mul_symm'?expand=1#diff-cfb19983c79209e00ac093e670e2db956ca48e00238011a5854479250cbaec67R318</a><br>\nI'll leave P2 and P4 to tomorrow.</p>\n</blockquote>\n<p>I'll try and merge this with what we have.</p>",
        "id": 289208165,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657553473
    },
    {
        "content": "<p>I hadn't noticed your comments on <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.quot_mul_comm\">docs#pgame.quot_mul_comm</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.quot_neg_mul\">docs#pgame.quot_neg_mul</a>, that seems like a nice thing to do on the side</p>",
        "id": 289208374,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657553561
    },
    {
        "content": "<p>I want to try PR-ing the <code>mul_option</code> stuff, but <a href=\"https://github.com/leanprover-community/mathlib/pull/15252\">#15252</a> is currerntly blocking that</p>",
        "id": 290531736,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506158
    },
    {
        "content": "<p>I think that's the last thing we would need before PRing the surreal multiplication proof</p>",
        "id": 290531777,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506181
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/15252\">#15252</a> has a merge conflict now</p>",
        "id": 290531950,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658506249
    },
    {
        "content": "<p>Ah true, it will conflict with my recent swapping of arguments on relabellings</p>",
        "id": 290532221,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506362
    },
    {
        "content": "<p>On that note, I've been thinking about relabellings again</p>",
        "id": 290532242,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506371
    },
    {
        "content": "<p>I think I might have brought this up before, but now I'm more convinced: we eventually need to ditch relabellings in favor of extensional equivalence</p>",
        "id": 290532313,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506401
    },
    {
        "content": "<p>Relabellings are just a consequence of our implementation of games, which doesn't coincide with the ZFC one</p>",
        "id": 290532372,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506432
    },
    {
        "content": "<p>The definition of extensional equivalence, e.g. being \"identical\" games, would be pretty much the same one as for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pSet.equiv\">docs#pSet.equiv</a>: <code>x ≡ y</code> when every left move of <code>x</code> is extensionally equivalent to some left move of <code>y</code>, and viceversa, and likewise for right moves</p>",
        "id": 290532632,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506560
    },
    {
        "content": "<p>We could then define the quotient of pre-games by extensional equivalence, which would correspond to the actual ZFC notion of pre-games</p>",
        "id": 290532871,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506662
    },
    {
        "content": "<p>It's definitely a confusing situation, since we would have <code>pgame</code> which is an implementation detail, then some other type (<code>igame</code>?) for ZFC pre-games (which they don't call pre-games, they just call them games), and then actually <code>game</code> corresponding to ZFC pre-games quotiented by antisymmetry</p>",
        "id": 290533038,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506735
    },
    {
        "content": "<p>And surreals of course</p>",
        "id": 290533054,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506745
    },
    {
        "content": "<p>The nice thing about <code>igame</code> is that you can define left and right moves of <code>igame</code> as <code>igame</code>s themselves, which is something you can't do with neither games nor surreals</p>",
        "id": 290533105,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506779
    },
    {
        "content": "<p>Which means we can define the birthday of an <code>igame</code> too</p>",
        "id": 290533122,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506791
    },
    {
        "content": "<p>And we can also correctly define short <code>igame</code>s as an <code>igame</code> with a finite left and right move set, and prove that an <code>igame</code> is short iff it has finite birthday, a result that isn't true on <code>pgame</code></p>",
        "id": 290533227,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506839
    },
    {
        "content": "<p>The philosophy here would be the same one as with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pSet\">docs#pSet</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Set\">docs#Set</a>: we treat the former as an implementation detail, only proving the necessary results, and move everything to the latter</p>",
        "id": 290533303,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658506880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Well-founded.20recursion.20for.20pgames/near/290532313\">said</a>:</p>\n<blockquote>\n<p>I think I might have brought this up before, but now I'm more convinced: we eventually need to ditch relabellings in favor of extensional equivalence</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/pSet.equiv\">docs#pSet.equiv</a> is purely in terms of quantifiers, while <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.relabelling\">docs#pgame.relabelling</a> has the equivalences/functions that go between the left/right moves of two equivalent games. I remember you previously said it's useful to have those functions; if that's true we may consider keeping relabelling instead of ditching it, but maybe the lesson from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pSet\">docs#pSet</a> tells us we don't really need those functions.</p>",
        "id": 290535411,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658507852
    },
    {
        "content": "<p>I previously said that we <em>use</em> those functions. The single place where they're used is in the definition of <code>short</code>, which as I've mentioned previously doesn't match mathematical usage.</p>",
        "id": 290536792,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658508483
    },
    {
        "content": "<p>We could still define identical games in terms of functions, i.e. explicit maps from left moves of <code>x</code> to identical left moves of <code>y</code>, and all the others, instead of just having the quantifiers</p>",
        "id": 290536868,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658508522
    },
    {
        "content": "<p>This might still enable the VM to play short games, though I don't know if that's a priority</p>",
        "id": 290536910,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658508548
    },
    {
        "content": "<p>In any case, it's clear to me that relabellings are a quirk of Lean's type theory, rather that something mathematicians would care much about.</p>",
        "id": 290537047,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658508606
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> was the one who made the code for <code>short</code> so I'd like to hear his opinion.</p>",
        "id": 290540312,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658509919
    },
    {
        "content": "<p>I'm wondering</p>",
        "id": 290692617,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658685985
    },
    {
        "content": "<p>If <a href=\"https://github.com/leanprover-community/mathlib/pull/15289\">#15289</a> is merged, <code>lf</code> will no longer have a weird inductive definition</p>",
        "id": 290692624,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658685997
    },
    {
        "content": "<p>It will literally be defined as <code>(≥)ᶜ</code></p>",
        "id": 290692639,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658686043
    },
    {
        "content": "<p>So, in order to be able to use this smoothly on both <code>pgame</code> and <code>game</code>, maybe we should make <code>⧏</code> notation for <code>(≥)ᶜ</code>?</p>",
        "id": 290692708,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658686093
    },
    {
        "content": "<p>I also suggested <a href=\"#narrow/stream/116395-maths/topic/Comparison.20in.20preorders/near/290425782\">here</a> that we could define more general notation <code>⋚</code> for \"equal up to antisymmetry\" and <code>∥</code> for incomparability</p>",
        "id": 290692735,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658686171
    },
    {
        "content": "<p>So we wouldn't need specialized <code>pgame.equiv</code> and <code>pgame.fuzzy</code> predicates, nor their <code>game</code> counterparts, nor their <code>igame</code> counterparts if we ever do that</p>",
        "id": 290692786,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658686209
    },
    {
        "content": "<p>Or you know what?</p>",
        "id": 290693785,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658687848
    },
    {
        "content": "<p>Maybe we don't need <code>lf</code> anymore</p>",
        "id": 290693787,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658687854
    },
    {
        "content": "<p>Which is probably somewhat of a hot take given the effort we put into making <code>lf</code> into what it is</p>",
        "id": 290693859,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658687945
    },
    {
        "content": "<p>There was previously the argument that <code>lf</code> was useful because it provided a nice def-eq for <code>le</code>, but that no longer applies after the aforementioned refactor</p>",
        "id": 290693940,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658688098
    },
    {
        "content": "<p>In fact, changing the def-eq barely broke anything</p>",
        "id": 290694025,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658688202
    },
    {
        "content": "<p>What's that nice def-eq? I think one reason for keeping <code>lf</code> is it makes statements like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.lf_of_le_of_lf/src\">src#pgame.lf_of_le_of_lf</a> look natural.</p>",
        "id": 290694031,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658688215
    },
    {
        "content": "<p>and it's everywhere in the literature</p>",
        "id": 290694038,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658688238
    },
    {
        "content": "<p>The nice def-eqs in question are the ones given by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.le_iff_forall_lf\">docs#pgame.le_iff_forall_lf</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pgame.lf_iff_exists_le\">docs#pgame.lf_iff_exists_le</a></p>",
        "id": 290694172,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658688382
    },
    {
        "content": "<p>I guess they're not exactly def-eqs but they're really close</p>",
        "id": 290694183,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658688410
    },
    {
        "content": "<p>It's true that <code>lf</code> makes some statements look more natural. But I don't think the statements translated into preorders are particularly unclear either. We could just prove <code>not_le_of_le_of_not_le</code> and now we don't need to prove it separately for <code>pgame</code> and <code>game</code></p>",
        "id": 290694269,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658688548
    },
    {
        "content": "<p>Again, there's also the option of just making <code>lf</code> a notation on an arbitrary preorder, and make aliases for the theorems we want to port</p>",
        "id": 290694283,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658688592
    },
    {
        "content": "<p>Ultimately what I want is to prove as few results on preorders as possible. All that should be done elsewhere, and we should strive not to duplicate that in the game theory files.</p>",
        "id": 290694448,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658688834
    },
    {
        "content": "<p>I wonder if we could have a whole file <code>set_theory/game/lf.lean</code> where we introduce the notation and all relevant aliases</p>",
        "id": 290708840,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658710630
    },
    {
        "content": "<p>That way, if we want to use <code>lf</code> notation on pre-games, games, surreals, or any future quotient or subtype we come up with, we can just open that namespace/locale and get it</p>",
        "id": 290708911,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658710735
    },
    {
        "content": "<p>I'm still not sure if we need the aliases though, maybe we can keep the notation but still use <code>not_le</code> or <code>not_ge</code> in theorem names?</p>",
        "id": 290708983,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658710828
    },
    {
        "content": "<p>Maybe a bit outdated, can we still get any convenient computable constructing functions if we use extensional equivalence? I recently found it hard to define something like <code>smallset Set → Set</code> (smallset is quotient of indexed set which is used for <code>pSet</code> and <code>pgame</code>) without giving up computability.</p>",
        "id": 296134971,
        "sender_full_name": "FR",
        "timestamp": 1661869865
    }
]
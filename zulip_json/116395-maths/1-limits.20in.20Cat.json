[
    {
        "content": "<p>Hi! I'm spending this week proving that Cat is complete (as a 1-category). Whilst this is \"evil\" somehow since Cat is really a 2-category, I think the results are worth having in mathlib. The non-master branch of my repo currently contains constructions of binary products and equalizers in Cat. <a href=\"https://github.com/Jlh18/discrete_fibrations/tree/Joseph\">https://github.com/Jlh18/discrete_fibrations/tree/Joseph</a> is this worth a PR?</p>",
        "id": 270118438,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643668849
    },
    {
        "content": "<p>Ping <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span></p>",
        "id": 270119902,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643669566
    },
    {
        "content": "<p>This doesn't look too bad as far as <code>eq_to_hom</code> stuff is concerned, but I wonder if we have to deal with <code>eq_to_hom</code> anyways, maybe we can get a bigger payoff, like proving <code>Cat</code> is equivalent to some presentation of the 1-category of categories that doesn't involve dependent types.</p>",
        "id": 270128759,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643674126
    },
    {
        "content": "<p>For example the presentation in terms of objects and morphisms with source and target maps and partially defined composition (which is the models of an essentially algebraic theory), or even the presentation as a reflective subcategory of simplicial sets.</p>",
        "id": 270128835,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643674186
    },
    {
        "content": "<p><a href=\"https://github.com/Jlh18/discrete_fibrations/compare/Joseph...alreadydone:patch-1\">Golfed the product part</a>; why didn't you do it with arbitrary product? Because we don't have a category structure on the pi type yet? Will think about equalizers tomorrow; wondering whether using heq instead of eq in the definition of hom could lead to easier proofs.</p>",
        "id": 270157884,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643695616
    },
    {
        "content": "<p>oh wow, thanks for that <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> . I am going to prove things about arbitrary product today! I did binary products first because I wanted to first get used to the category theory library with an easier exercise. </p>\n<p>I am not familiar with the theory that you mention <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> ,  so I probably won't be doing that... So the conclusion is that this is not good PR material, given that this alternative is available?</p>",
        "id": 270182075,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643710339
    },
    {
        "content": "<p>hext is amazing</p>",
        "id": 270184841,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643711601
    },
    {
        "content": "<p>Using hext results in a goal without eq_to_hom, which is simpler in some sense, but there are very few lemmas about == (heq), for example there's no analogue of prod.ext for heq in mathlib, so I need to do <code>dsimp [prod_map, (‚â´)], cases F.map f, refl</code> instead of just <code>prod.ext rfl rfl</code> (in fact the types are defeq as I realized today and <code>heq_of_eq (prod.ext rfl rfl)</code> works). eq_to_hom is used to flush everything into the same type, and then heq can be expressed using = (eq), and all lemmas about eq can be used. It's not too bad to work with heq in this case, as many things involved are \"almost defeq\", i.e. Lean can recognized them to be defeq once the structures are broken down into its components using <code>cases</code>.</p>",
        "id": 270214960,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643724292
    },
    {
        "content": "<p>I'm struggling to find the right definition for equalizers using <code>heq</code>. The objects should just be as I originally had, requiring <code>F.obj x = G.obj x</code>, but it seems like requiring <code>F.map f == G.map f</code> for morphisms is not a good idea, since I can't do cases on a proof of the statement.</p>",
        "id": 270236124,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643731522
    },
    {
        "content": "<p>okay i showed that the category of small category has all small limits. I'm still confused about how equalizers should work using <code>heq</code></p>",
        "id": 270299665,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643754910
    },
    {
        "content": "<p>Sorry to make you confused. I was just wondering whether heq would make equalizer simpler as well, given that it works well with products; but it turns out not to be the case. Although generally speaking heq between morphisms is equivalent to eq between morphisms conjugated by eq_to_hom, heq has less library support and most lemmas are stated in terms of eq_to_hom. (eq_to_hom seems to play well with simp lemmas, while proofs involving heq often requires the <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Reindexing.20a.20dependent.20product/near/262352108\"><code>generalize</code> tactic</a> and that may be hard to automate, and if you want to compose to non-defeq'ly composable morphisms, you have to use eq_to_hom; these are possibly why people invented eq_to_hom and mostly abandoned heq.) Though I'm able to define the equalizer category using heq, it's complicated and this is the best I can get:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>equalizer.str'</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">equalizer.str'</span> <span class=\"o\">:</span> <span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">//</span> <span class=\"n\">F.obj</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">G.obj</span> <span class=\"n\">c</span> <span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">x.1</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">y.1</span> <span class=\"bp\">//</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">==</span> <span class=\"n\">G.map</span> <span class=\"n\">f</span> <span class=\"o\">},</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span><span class=\"mi\">ùüô</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">F.map_id</span><span class=\"o\">,</span> <span class=\"n\">G.map_id</span><span class=\"o\">,</span> <span class=\"n\">x.2</span><span class=\"o\">]‚ü©,</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span> <span class=\"n\">f.1</span> <span class=\"bp\">‚â´</span> <span class=\"n\">g.1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">F.map_comp</span><span class=\"o\">,</span> <span class=\"n\">G.map_comp</span><span class=\"o\">],</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf</span> <span class=\"o\">:=</span> <span class=\"n\">f.2</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">hg</span> <span class=\"o\">:=</span> <span class=\"n\">g.2</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"n\">f.1</span> <span class=\"bp\">=</span> <span class=\"n\">Ff</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">G.map</span> <span class=\"n\">f.1</span> <span class=\"bp\">=</span> <span class=\"n\">Gf</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"n\">g.1</span> <span class=\"bp\">=</span> <span class=\"n\">Fg</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">G.map</span> <span class=\"n\">g.1</span> <span class=\"bp\">=</span> <span class=\"n\">Gg</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n    <span class=\"n\">clear</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"n\">x.2</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">hy</span> <span class=\"o\">:=</span> <span class=\"n\">y.2</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">hz</span> <span class=\"o\">:=</span> <span class=\"n\">z.2</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">x.1</span> <span class=\"bp\">=</span> <span class=\"n\">Fx</span> <span class=\"n\">at</span> <span class=\"n\">Ff</span> <span class=\"n\">hx</span> <span class=\"bp\">‚ä¢</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">y.1</span> <span class=\"bp\">=</span> <span class=\"n\">Fy</span> <span class=\"n\">at</span> <span class=\"n\">Ff</span> <span class=\"n\">Fg</span> <span class=\"n\">hy</span> <span class=\"bp\">‚ä¢</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">z.1</span> <span class=\"bp\">=</span> <span class=\"n\">Fz</span> <span class=\"n\">at</span> <span class=\"n\">Fg</span> <span class=\"n\">hz</span> <span class=\"bp\">‚ä¢</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hz</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">heq_of_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_of_heq</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">eq_of_heq</span> <span class=\"n\">hg</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">‚ü©</span> <span class=\"o\">}</span>\n</code></pre></div>\n</div></div>\n<p>and here is a proof that the heq condition is equivalent to the \"eq to conjugation by eq_to_hom\" condition:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>heq_iff_eq_conj_eq_to_hom</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">heq_iff_eq_conj_eq_to_hom</span> <span class=\"o\">{</span><span class=\"n\">c‚ÇÅ</span> <span class=\"n\">c‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÅ</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">c‚ÇÅ</span> <span class=\"bp\">=</span> <span class=\"n\">G.obj</span> <span class=\"n\">c‚ÇÅ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">c‚ÇÇ</span> <span class=\"bp\">=</span> <span class=\"n\">G.obj</span> <span class=\"n\">c‚ÇÇ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">c‚ÇÅ</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">c‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">eq_to_hom</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"bp\">‚â´</span> <span class=\"n\">G.map</span> <span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"n\">eq_to_hom</span> <span class=\"n\">h‚ÇÇ.symm</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">==</span> <span class=\"n\">G.map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">Ff</span><span class=\"o\">,</span> <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">G.map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">Gf</span><span class=\"o\">,</span> <span class=\"n\">clear</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">c‚ÇÅ</span> <span class=\"bp\">=</span> <span class=\"n\">F‚ÇÅ</span> <span class=\"n\">at</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"n\">Ff</span> <span class=\"bp\">‚ä¢</span><span class=\"o\">,</span> <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">c‚ÇÇ</span> <span class=\"bp\">=</span> <span class=\"n\">F‚ÇÇ</span> <span class=\"n\">at</span> <span class=\"n\">h‚ÇÇ</span> <span class=\"n\">Ff</span> <span class=\"bp\">‚ä¢</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h‚ÇÅ</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n</code></pre></div>\n</div></div>\n<p>Now that limits are done, are you proceeding to colimits?</p>",
        "id": 270329909,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643774026
    },
    {
        "content": "<p>Seems we don't have the forgetful functor from Cat to Type (taking the object part). We'd like to show it preserves (co)limits.</p>",
        "id": 270344307,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643786986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/1-limits.20in.20Cat/near/270329909\">said</a>:</p>\n<blockquote>\n<p>Sorry to make you confused. I was just wondering whether heq would make equalizer simpler as well, given that it works well with products; but it turns out not to be the case. Although generally speaking heq between morphisms is equivalent to eq between morphisms conjugated by eq_to_hom, heq has less library support and most lemmas are stated in terms of eq_to_hom. (eq_to_hom seems to play well with simp lemmas, while proofs involving heq often requires the <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Reindexing.20a.20dependent.20product/near/262352108\"><code>generalize</code> tactic</a> and that may be hard to automate, and if you want to compose to non-defeq'ly composable morphisms, you have to use eq_to_hom; these are possibly why people invented eq_to_hom and mostly abandoned heq.) Though I'm able to define the equalizer category using heq, it's complicated and this is the best I can get:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>equalizer.str'</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">equalizer.str'</span> <span class=\"o\">:</span> <span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">//</span> <span class=\"n\">F.obj</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">G.obj</span> <span class=\"n\">c</span> <span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">x.1</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">y.1</span> <span class=\"bp\">//</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">==</span> <span class=\"n\">G.map</span> <span class=\"n\">f</span> <span class=\"o\">},</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span><span class=\"mi\">ùüô</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">F.map_id</span><span class=\"o\">,</span> <span class=\"n\">G.map_id</span><span class=\"o\">,</span> <span class=\"n\">x.2</span><span class=\"o\">]‚ü©,</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span> <span class=\"n\">f.1</span> <span class=\"bp\">‚â´</span> <span class=\"n\">g.1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">F.map_comp</span><span class=\"o\">,</span> <span class=\"n\">G.map_comp</span><span class=\"o\">],</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf</span> <span class=\"o\">:=</span> <span class=\"n\">f.2</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">hg</span> <span class=\"o\">:=</span> <span class=\"n\">g.2</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"n\">f.1</span> <span class=\"bp\">=</span> <span class=\"n\">Ff</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">G.map</span> <span class=\"n\">f.1</span> <span class=\"bp\">=</span> <span class=\"n\">Gf</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"n\">g.1</span> <span class=\"bp\">=</span> <span class=\"n\">Fg</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">G.map</span> <span class=\"n\">g.1</span> <span class=\"bp\">=</span> <span class=\"n\">Gg</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n    <span class=\"n\">clear</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"n\">x.2</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">hy</span> <span class=\"o\">:=</span> <span class=\"n\">y.2</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">hz</span> <span class=\"o\">:=</span> <span class=\"n\">z.2</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">x.1</span> <span class=\"bp\">=</span> <span class=\"n\">Fx</span> <span class=\"n\">at</span> <span class=\"n\">Ff</span> <span class=\"n\">hx</span> <span class=\"bp\">‚ä¢</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">y.1</span> <span class=\"bp\">=</span> <span class=\"n\">Fy</span> <span class=\"n\">at</span> <span class=\"n\">Ff</span> <span class=\"n\">Fg</span> <span class=\"n\">hy</span> <span class=\"bp\">‚ä¢</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">z.1</span> <span class=\"bp\">=</span> <span class=\"n\">Fz</span> <span class=\"n\">at</span> <span class=\"n\">Fg</span> <span class=\"n\">hz</span> <span class=\"bp\">‚ä¢</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">hz</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">heq_of_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_of_heq</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">eq_of_heq</span> <span class=\"n\">hg</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">‚ü©</span> <span class=\"o\">}</span>\n</code></pre></div>\n</div></div>\n<p>and here is a proof that the heq condition is equivalent to the \"eq to conjugation by eq_to_hom\" condition:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>heq_iff_eq_conj_eq_to_hom</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">heq_iff_eq_conj_eq_to_hom</span> <span class=\"o\">{</span><span class=\"n\">c‚ÇÅ</span> <span class=\"n\">c‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÅ</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">c‚ÇÅ</span> <span class=\"bp\">=</span> <span class=\"n\">G.obj</span> <span class=\"n\">c‚ÇÅ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">c‚ÇÇ</span> <span class=\"bp\">=</span> <span class=\"n\">G.obj</span> <span class=\"n\">c‚ÇÇ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">c‚ÇÅ</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">c‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">eq_to_hom</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"bp\">‚â´</span> <span class=\"n\">G.map</span> <span class=\"n\">f</span> <span class=\"bp\">‚â´</span> <span class=\"n\">eq_to_hom</span> <span class=\"n\">h‚ÇÇ.symm</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">==</span> <span class=\"n\">G.map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">Ff</span><span class=\"o\">,</span> <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">G.map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">Gf</span><span class=\"o\">,</span> <span class=\"n\">clear</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">c‚ÇÅ</span> <span class=\"bp\">=</span> <span class=\"n\">F‚ÇÅ</span> <span class=\"n\">at</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"n\">Ff</span> <span class=\"bp\">‚ä¢</span><span class=\"o\">,</span> <span class=\"n\">generalize_hyp</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">c‚ÇÇ</span> <span class=\"bp\">=</span> <span class=\"n\">F‚ÇÇ</span> <span class=\"n\">at</span> <span class=\"n\">h‚ÇÇ</span> <span class=\"n\">Ff</span> <span class=\"bp\">‚ä¢</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h‚ÇÅ</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n</code></pre></div>\n</div></div>\n<p>Now that limits are done, are you gonna proceed to colimits? Seems eq.rec is inevitable to define homs for the sigma category ... Oh it's actually Grothendieck construction with base a discrete category ... <del>Maybe the Grothendieck construction yields the colimit for arbitrary diagram ...</del></p>\n</blockquote>\n<p>Ah okay - yeah I couldn't figure out how to generalize the data <code>F.map f</code> to eliminate it. I'll try to see if this definition could tidy up my work. Thanks a lot!</p>\n<p>About coproducts: it seems to me that <code>category_theory.elements</code> and <code>category_theory.sigma</code> are kind of duplicates of the same Grothendieck construction. Would it be nicer to make the <code>sigma</code> version from the <code>elements</code> version by making the indexing type <code>I</code> a discrete category? Either way, I will use this both for making pullbacks (which I would like to have a direct construction for) and maybe I'll do colimits too.</p>",
        "id": 270360138,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643796388
    },
    {
        "content": "<p>Oh I didn't know that <code>category_theory.sigma.basic</code> and <code>category_theory.pi.basic</code> exist! It seems <code>sigma</code> works for a  functor from a discrete category to Cat, while <code>elements</code> works for a functor from an arbitrary category to Type, so they are complementary instead of special case of one another (and there is also <code>grothendieck</code> that works for a functor from any category to Cat, which I've generalized to oplax functors). <code>sigma</code> defines the homs not via another sigma type, but directly as an inductive type, which may or may not be easy to work with, and it would be interesting to try.</p>",
        "id": 270394307,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643813040
    },
    {
        "content": "<p>I found it a lot easier to work with the homs for <code>sigma</code> as an inductive type rather than a sigma type, because it avoids <code>eq.rec</code> and <code>eq_to_hom</code> sorts of things showing up everywhere and it made the proofs more awkward than usual to work with! My original method was to use a standard sigma type though</p>",
        "id": 270394789,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1643813233
    },
    {
        "content": "<p>I just finished golfing the equalizer proof using <code>heq</code> and refactoring maps into the limit <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> . There are a bunch of irrelevant comments about authenticity (I'm submitting this as coursework) so please ignore them.</p>",
        "id": 270396162,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643813723
    },
    {
        "content": "<p>Also made a couple of lemmas for composition working with <code>heq</code></p>",
        "id": 270396353,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643813782
    },
    {
        "content": "<p>oh right elements is for functors into Type u silly me</p>",
        "id": 270407555,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643817555
    },
    {
        "content": "<p>Joseph -- is this for the assessment \"prove a theorem at 1st year undergraduate level\" due in on Friday? <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 270417895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1643820875
    },
    {
        "content": "<p>Just want to note that <code>map_comp_heq</code> has an easy proof using <code>congr'</code> as in</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>equalizer.str'</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">equalizer.str'</span> <span class=\"o\">:</span> <span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">c</span> <span class=\"bp\">//</span> <span class=\"n\">F.obj</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">G.obj</span> <span class=\"n\">c</span> <span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">x.1</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">y.1</span> <span class=\"bp\">//</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">==</span> <span class=\"n\">G.map</span> <span class=\"n\">f</span> <span class=\"o\">},</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span> <span class=\"mi\">ùüô</span> <span class=\"n\">x</span> <span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">F.map_id</span><span class=\"o\">,</span> <span class=\"n\">G.map_id</span><span class=\"o\">,</span> <span class=\"n\">x.2</span><span class=\"o\">]</span> <span class=\"o\">‚ü©,</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span> <span class=\"n\">f.1</span> <span class=\"bp\">‚â´</span> <span class=\"n\">g.1</span> <span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">F.map_comp</span><span class=\"o\">,</span> <span class=\"n\">G.map_comp</span><span class=\"o\">],</span>\n    <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">x.2</span><span class=\"o\">,</span> <span class=\"n\">y.2</span><span class=\"o\">,</span> <span class=\"n\">z.2</span><span class=\"o\">,</span> <span class=\"n\">f.2</span><span class=\"o\">,</span> <span class=\"n\">g.2</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">‚ü©</span> <span class=\"o\">}</span>\n</code></pre></div>\n</div></div>",
        "id": 270503740,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643867100
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/1-limits.20in.20Cat/near/270503740\">said</a>:</p>\n<blockquote>\n<p>Just want to note that <code>map_comp_heq</code> has an easy proof using <code>congr'</code> as in</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>equalizer.str'</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">equalizer.str'</span> <span class=\"o\">:</span> <span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span> <span class=\"n\">c</span> <span class=\"bp\">//</span> <span class=\"n\">F.obj</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">G.obj</span> <span class=\"n\">c</span> <span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">x.1</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">y.1</span> <span class=\"bp\">//</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">==</span> <span class=\"n\">G.map</span> <span class=\"n\">f</span> <span class=\"o\">},</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span> <span class=\"mi\">ùüô</span> <span class=\"n\">x</span> <span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">F.map_id</span><span class=\"o\">,</span> <span class=\"n\">G.map_id</span><span class=\"o\">,</span> <span class=\"n\">x.2</span><span class=\"o\">]</span> <span class=\"o\">‚ü©,</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span> <span class=\"n\">f.1</span> <span class=\"bp\">‚â´</span> <span class=\"n\">g.1</span> <span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">F.map_comp</span><span class=\"o\">,</span> <span class=\"n\">G.map_comp</span><span class=\"o\">],</span>\n    <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">x.2</span><span class=\"o\">,</span> <span class=\"n\">y.2</span><span class=\"o\">,</span> <span class=\"n\">z.2</span><span class=\"o\">,</span> <span class=\"n\">f.2</span><span class=\"o\">,</span> <span class=\"n\">g.2</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">‚ü©</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p></div></div><br>\n</p>\n</blockquote>\n<p>oh wow that's slick. but why does it work? I don't see how being \"less aggressive at breaking down the goal\"  helps</p>",
        "id": 270615576,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643921421
    },
    {
        "content": "<p>If you try <code>congr</code> you'll see it's too aggressive and produces five identical goals <code>F = G</code> which isn't necessarily true...</p>",
        "id": 270632126,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643929478
    },
    {
        "content": "<p>and this is the output of <code>show_term { congr' 1, exacts [x.2, y.2, z.2, f.2, g.2] }</code>:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">exact</span> <span class=\"n\">eq.rec</span>\n  <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"o\">[</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">category_struct</span> <span class=\"bp\">‚Ü•</span><span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">self'</span> <span class=\"o\">:</span> <span class=\"n\">category_struct</span> <span class=\"bp\">‚Ü•</span><span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_1</span> <span class=\"o\">:</span> <span class=\"n\">self</span> <span class=\"bp\">==</span> <span class=\"n\">self'</span><span class=\"o\">),</span>\n     <span class=\"n\">eq.rec</span>\n       <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ü•</span><span class=\"n\">D</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X'</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ü•</span><span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_2</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">==</span> <span class=\"n\">X'</span><span class=\"o\">),</span>\n          <span class=\"n\">eq.rec</span>\n            <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ü•</span><span class=\"n\">D</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Y'</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ü•</span><span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_3</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">==</span> <span class=\"n\">Y'</span><span class=\"o\">),</span>\n               <span class=\"n\">eq.rec</span>\n                 <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ü•</span><span class=\"n\">D</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Z'</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ü•</span><span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_4</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">==</span> <span class=\"n\">Z'</span><span class=\"o\">),</span>\n                    <span class=\"n\">eq.rec</span>\n                      <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"o\">(</span><span class=\"n\">·æ∞</span> <span class=\"n\">·æ∞'</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_5</span> <span class=\"o\">:</span> <span class=\"n\">·æ∞</span> <span class=\"bp\">==</span> <span class=\"n\">·æ∞'</span><span class=\"o\">),</span>\n                         <span class=\"n\">eq.rec</span>\n                           <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"o\">(</span><span class=\"n\">·æ∞_1</span> <span class=\"n\">·æ∞'</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_6</span> <span class=\"o\">:</span> <span class=\"n\">·æ∞_1</span> <span class=\"bp\">==</span> <span class=\"n\">·æ∞'</span><span class=\"o\">),</span>\n                              <span class=\"n\">eq.rec</span> <span class=\"o\">(</span><span class=\"n\">heq.refl</span> <span class=\"o\">(</span><span class=\"n\">·æ∞</span> <span class=\"bp\">‚â´</span> <span class=\"n\">·æ∞_1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">eq_of_heq</span> <span class=\"n\">e_6</span><span class=\"o\">))</span>\n                           <span class=\"o\">(</span><span class=\"n\">eq_of_heq</span> <span class=\"n\">e_5</span><span class=\"o\">))</span>\n                      <span class=\"o\">(</span><span class=\"n\">eq_of_heq</span> <span class=\"n\">e_4</span><span class=\"o\">))</span>\n                 <span class=\"o\">(</span><span class=\"n\">eq_of_heq</span> <span class=\"n\">e_3</span><span class=\"o\">))</span>\n            <span class=\"o\">(</span><span class=\"n\">eq_of_heq</span> <span class=\"n\">e_2</span><span class=\"o\">))</span>\n       <span class=\"o\">(</span><span class=\"n\">eq_of_heq</span> <span class=\"n\">e_1</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">eq.refl</span> <span class=\"bp\">‚Ü•</span><span class=\"n\">D</span><span class=\"o\">)</span>\n  <span class=\"n\">category.to_category_struct</span>\n  <span class=\"o\">(</span><span class=\"n\">heq_of_eq</span> <span class=\"o\">(</span><span class=\"n\">eq.refl</span> <span class=\"n\">category.to_category_struct</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">G.obj</span> <span class=\"n\">x.val</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">heq_of_eq</span> <span class=\"n\">x.property</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">G.obj</span> <span class=\"n\">y.val</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">heq_of_eq</span> <span class=\"n\">y.property</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">G.obj</span> <span class=\"n\">z.val</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">heq_of_eq</span> <span class=\"n\">z.property</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.val</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">G.map</span> <span class=\"n\">f.val</span><span class=\"o\">)</span>\n  <span class=\"n\">f.property</span>\n  <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">g.val</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">G.map</span> <span class=\"n\">g.val</span><span class=\"o\">)</span>\n  <span class=\"n\">g.property</span>\n</code></pre></div>\n</div></div>",
        "id": 270632354,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643929571
    },
    {
        "content": "<p>yeah i used show_term to have a look too. I guess it first looks for proofs of equality then tries to compare the terms, rather than looking to compare the terms, then checking equality (which fails)?</p>",
        "id": 270634799,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643930783
    },
    {
        "content": "<p>I don't quite get the question. Are you asking why <code>congr</code> fails? It doesn't actually fail but produces goals you won't be able to prove. For example <code>congr' 1</code> produces <code>F.obj x.val = G.obj x.val</code>, but <code>congr</code> breaks it down one step further to get <code>F = G</code>, which is too much. It seems <code>congr</code> does recognize equalities in the context (but not the ones buried in a structure like subtype) but doesn't automatically apply them: if you do <code>have := x.2</code> before <code>congr</code> you see that the first resulting goal becomes <code>F.obj x.val = G.obj x.val</code> (which is the type of <code>x.2</code> but not automatically solved) but the other four goals remain <code>F = G</code>. <code>congr'</code> in contrast automatically uses equalities to solve resulting goals: if you do <code>have := x.2, have := y.2, have := z.2, have := f.2, have := g.2, congr' 1</code> then <code>goals accomplished</code>.</p>",
        "id": 270644726,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643931794
    },
    {
        "content": "<p>you answered my question with yes haha, that is what I vaguely had in mind</p>",
        "id": 270645041,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1643932023
    }
]
[
    {
        "content": "<p>I recently decided that I'm far too tolerant when Lean asks me to prove trivialities. Today I decided I'd start collecting a list of stark examples of proofs that:</p>\n<ul>\n<li>Lean seems unable to do automatically</li>\n<li>Lean really should be able to do automatically</li>\n</ul>",
        "id": 293714901,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660656118
    },
    {
        "content": "<p>I just encountered my first potential example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">∪</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">replace</span> <span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">mem_union</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hUV</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"n\">tauto</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 293715052,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660656164
    },
    {
        "content": "<p>My question is: is this really an example or am I missing a tactic / trick?</p>",
        "id": 293715086,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660656178
    },
    {
        "content": "<p>You should state <code>U ∪ V = univ</code> as <code>codisjoint U V</code>.</p>",
        "id": 293718544,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660656569
    },
    {
        "content": "<p>This also works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">∪</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">set.ext_iff</span> <span class=\"n\">at</span> <span class=\"n\">hUV</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hUV</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 293718560,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660656575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/293718544\">said</a>:</p>\n<blockquote>\n<p>You should state <code>U ∪ V = univ</code> as <code>codisjoint U V</code>.</p>\n</blockquote>\n<p>Maybe this would be a better idiom but I don't think it addresses my point.</p>",
        "id": 293719401,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660656892
    },
    {
        "content": "<p>What is the behaviour you expect?</p>",
        "id": 294967950,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661303752
    },
    {
        "content": "<p>I'm not at a computer to be able to try it, but I would solve this via:</p>\n<ul>\n<li>a \\mem univ</li>\n<li>a \\mem U union V (rw hUV)</li>\n<li>a \\mem U or a \\mem V </li>\n<li>a \\mem V (using ha in some suitable logic lemma)</li>\n</ul>\n<p>I'm honestly not sure you could ask for more than that?</p>",
        "id": 294968098,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661303901
    },
    {
        "content": "<p>and Eric's proof is imo proof that lean seems to be able to do it.</p>",
        "id": 294968203,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661304008
    },
    {
        "content": "<p>do we have codisjoint U V iff forall a, a mem U or a mem V? Because it strikes me that that lemma might be useful here</p>",
        "id": 294968269,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661304114
    },
    {
        "content": "<p>Not yet, no.</p>",
        "id": 294980465,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661317463
    },
    {
        "content": "<p>It's not true for things like groups</p>",
        "id": 294981185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661317938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/294967950\">said</a>:</p>\n<blockquote>\n<p>What is the behaviour you expect?</p>\n</blockquote>\n<p>I would like Lean never present me with something this trivial but if it ever did, I would like a tactic like <code>tauto</code> to close it.</p>",
        "id": 294994974,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1661327149
    },
    {
        "content": "<p>I don't think this is a realistic expectation.</p>",
        "id": 294999749,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661329220
    },
    {
        "content": "<p>What if you replace hUV in your example with \"a \\mem U union V\"?</p>",
        "id": 294999851,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661329273
    },
    {
        "content": "<p>That feels at least more reasonable to expect to be tautologous.</p>",
        "id": 294999916,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661329313
    },
    {
        "content": "<p>Wrenna, this would be automatic in Isabelle. Oliver's point is that we don't have enough automation in mathlib.</p>",
        "id": 295000029,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661329346
    },
    {
        "content": "<p>hmm, fair enough</p>",
        "id": 295000061,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661329363
    },
    {
        "content": "<p>I would have assumed an automator would trip on the fact that hUV is much stronger than needed so you need to work out what to use.</p>",
        "id": 295000147,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661329407
    },
    {
        "content": "<p>how would Isabelle do it; what is the approach they use?</p>",
        "id": 295000187,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661329433
    },
    {
        "content": "<p>I don't disagree by the way that we could do with more automation in mathlib.</p>",
        "id": 295000345,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661329501
    },
    {
        "content": "<p>I know almost nothing about proof automation. My hope in starting this thread was that we might assemble a corpus of test cases that some smart person writing such tactics could use.</p>",
        "id": 295000456,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1661329557
    },
    {
        "content": "<p>Isabelle has a lot (like <strong>a lot</strong>) of automation, but I expect this would be solved using sledgehammer, which is a very polyvalent self-replacing tactic. How it works is that you write your proof forwardly and automation tries to fill in the step every time. If it doesn't get it, you give it more hints and try again.</p>",
        "id": 295000463,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661329561
    },
    {
        "content": "<p>Someone could try this example in Isabelle, but I expect it needs at most one hint.</p>",
        "id": 295000581,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661329606
    },
    {
        "content": "<p>right I would expect it to be able to do it with a single hint! but not from nothing.</p>",
        "id": 295000861,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661329740
    },
    {
        "content": "<p>Eric's solution is very nearly that.</p>",
        "id": 295000901,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661329760
    },
    {
        "content": "<p>like that simpa is doing a reasonable degree of automation</p>",
        "id": 295001217,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661329896
    },
    {
        "content": "<p>But Eric still had to come up with it! I'm sorry to break it to you, but Eric is not your tactic.</p>",
        "id": 295002622,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661330538
    },
    {
        "content": "<p>what about <code>yael_search</code>? :b</p>\n<p>On a serious note, these sort of proofs maybe need a self-replacing tactic a-la <code>polyrith</code>, or <code>(i)tauto</code> needs to be able to expand common definitions (at least to do with sets/finsets). <code>simp</code> is very flexible but having to come up with a neat <code>simp(a)</code> proof for everything is not only annoying, but distracting from what you're working towards</p>",
        "id": 295004416,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1661331274
    },
    {
        "content": "<p>Here, I would expect automation to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.eq_univ_iff_forall\">docs#set.eq_univ_iff_forall</a>.</p>",
        "id": 295004527,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661331336
    },
    {
        "content": "<p>I recently spent a nontrivial amount of time on the goal <code>(x : Z) (x : N) : x - 1 - k = x - k.succ</code> which is not right</p>",
        "id": 295004573,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1661331359
    },
    {
        "content": "<p><code>rw [nat.succ_eq_add_one, int.coe_nat_add, ←sub_sub, sub_right_comm]</code>?</p>",
        "id": 295004882,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661331483
    },
    {
        "content": "<p>again, <code>yael_search</code> is not a tactic. it's clear that they can be done, but why do I need to hassle with this?</p>",
        "id": 295004947,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1661331512
    },
    {
        "content": "<p>and sure, maybe <code>succ</code> is an implementation detail and if I <code>rw [succ_eq_add_one]</code> then maybe <code>ring</code> or <code>push_cast, ring</code> will work. but if implementation details keep appearing in goals for whatever reasons then it doesn't really matter this idealism, because it affects the day-to-day</p>",
        "id": 295005085,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1661331578
    },
    {
        "content": "<p>(and it means I have to do <code>have : ... := by { ... }</code> instead of <code>have ... := by tactic</code> or ideally even inlining it)</p>",
        "id": 295005488,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1661331760
    },
    {
        "content": "<p>not really a single proof, but I spent recently too much time on finding the correct version of lemmas like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_le_mul_of_nonneg_left\">docs#mul_le_mul_of_nonneg_left</a><br>\nmaybe a variant of <code>congr</code> for inequalities would be nice. So <code>a (b+d) &lt; a (c + d)</code> gets reduced to <code>b &lt; c</code> and a bunch of stuff that positivity can prove</p>",
        "id": 295006602,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1661332260
    },
    {
        "content": "<p>Isn't that <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#mono\">tactic#mono</a>?</p>",
        "id": 295006830,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1661332353
    },
    {
        "content": "<p>I would really love having Coq's generalized rewriting, if only for <code>≤</code>.</p>",
        "id": 295006839,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661332355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295006830\">said</a>:</p>\n<blockquote>\n<p>Isn't that <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#mono\">tactic#mono</a>?</p>\n</blockquote>\n<p>I have never heard of that tactic, I will have a look at it</p>",
        "id": 295007129,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1661332471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295004573\">said</a>:</p>\n<blockquote>\n<p>I recently spent a nontrivial amount of time on the goal <code>(x : Z) (x : N) : x - 1 - k = x - k.succ</code> which is not right</p>\n</blockquote>\n<p>Yes this feels like a really good example.</p>",
        "id": 295007865,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661332768
    },
    {
        "content": "<p>By the way - why does <code>mem_union_eq</code> exist? I was expecting <code>mem_union</code> to be the simp lemma here...</p>",
        "id": 295011546,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661334290
    },
    {
        "content": "<p><code>=</code> lemmas and <code>↔</code> are not quite treated the same. <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> fixed some of this, but I'm not sure the issue is fully solved.</p>",
        "id": 295011744,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661334380
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∪</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_union_eq</span><span class=\"o\">,</span> <span class=\"n\">or_iff_not_imp_left</span><span class=\"o\">,</span> <span class=\"n\">hUV</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hUV</span><span class=\"o\">,</span> <span class=\"n\">tauto</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 295011859,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661334433
    },
    {
        "content": "<p>This is the best I've got for that, btw</p>",
        "id": 295011883,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661334439
    },
    {
        "content": "<p>Or if you allow non-terminal simps:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∪</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hUV</span><span class=\"o\">,</span> <span class=\"n\">tauto</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 295011920,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661334462
    },
    {
        "content": "<p>An example which came up yesterday on the discord: given a finset of five integers each of which is at most 50, prove that the sum is at most 50+49+48+47+46. This does not need a proof in a classroom situation but was pretty nasty to do in Lean</p>",
        "id": 295011922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1661334462
    },
    {
        "content": "<p>(But I changed <code>hUV</code>, so I cheated.)</p>",
        "id": 295011962,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661334477
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295011920\">said</a>:</p>\n<blockquote>\n<p>Or if you allow non-terminal simps:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∪</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">or_iff_not_imp_left</span><span class=\"o\">,</span> <span class=\"n\">hUV</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hUV</span><span class=\"o\">,</span> <span class=\"n\">tauto</span> <span class=\"o\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is a fine <code>simp</code>, because <code>tauto</code> is a fancy tactic too.</p>",
        "id": 295012151,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661334554
    },
    {
        "content": "<p>Incidentally, an example of these is some stuff which SMT solvers can discharge easily, that I was talking about with some of the lean-crypto people.</p>",
        "id": 295012162,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661334558
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">∪</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">eq_univ_iff_forall</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hUV</span><span class=\"o\">,</span> <span class=\"n\">specialize</span> <span class=\"n\">hUV</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">tauto</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Does this fufill the \"one hint\" requirement? I would say maybe. Should <code>eq_univ_iff_forall</code> be a simp lemma in general?</p>",
        "id": 295012679,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661334748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295011922\">said</a>:</p>\n<blockquote>\n<p>An example which came up yesterday on the discord: given a finset of five integers each of which is at most 50, prove that the sum is at most 50+49+48+47+46. This does not need a proof in a classroom situation but was pretty nasty to do in Lean</p>\n</blockquote>\n<p>I'd argue that that proof by induction really is the \"morally\" right thing to do. Some of the subgoal proofs were pretty absurd, though...</p>",
        "id": 295012934,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1661334879
    },
    {
        "content": "<p>Oh:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hUV</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">∪</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">eq_univ_iff_forall</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hUV</span><span class=\"o\">,</span> <span class=\"n\">finish</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 295013168,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661334972
    },
    {
        "content": "<p>I mean this is pretty close to full automation I would argue. Arguably it's only not because of the form of <code>hUV</code>.</p>",
        "id": 295013232,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661335004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295011922\">said</a>:</p>\n<blockquote>\n<p>An example which came up yesterday on the discord: given a finset of five integers each of which is at most 50, prove that the sum is at most 50+49+48+47+46. This does not need a proof in a classroom situation but was pretty nasty to do in Lean</p>\n</blockquote>\n<p>So this is equivalent to <code>a &lt;= 50, b &lt;= 50, c &lt;= 50, d &lt;= 50, e &lt;= 50, a &lt; b &lt; c &lt; d &lt; e, show that a + b + c + d + e &lt; 240</code>, right?</p>",
        "id": 295013709,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661335208
    },
    {
        "content": "<p>Can Lean do it in that form?</p>",
        "id": 295013729,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661335215
    },
    {
        "content": "<p>Because this is an easy SMT solve:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">;</span> <span class=\"n\">Variable</span> <span class=\"n\">declarations</span>\n<span class=\"o\">(</span><span class=\"n\">declare</span><span class=\"bp\">-</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">()</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">declare</span><span class=\"bp\">-</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"o\">()</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">declare</span><span class=\"bp\">-</span><span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"o\">()</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">declare</span><span class=\"bp\">-</span><span class=\"k\">fun</span> <span class=\"n\">d</span> <span class=\"o\">()</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">declare</span><span class=\"bp\">-</span><span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"o\">()</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n\n<span class=\"bp\">;</span> <span class=\"n\">Constraints</span>\n<span class=\"o\">(</span><span class=\"n\">assert</span> <span class=\"o\">(</span><span class=\"bp\">&lt;=</span> <span class=\"n\">a</span> <span class=\"mi\">50</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">assert</span> <span class=\"o\">(</span><span class=\"bp\">&lt;=</span> <span class=\"n\">b</span> <span class=\"mi\">50</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">assert</span> <span class=\"o\">(</span><span class=\"bp\">&lt;=</span> <span class=\"n\">c</span> <span class=\"mi\">50</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">assert</span> <span class=\"o\">(</span><span class=\"bp\">&lt;=</span> <span class=\"n\">d</span> <span class=\"mi\">50</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">assert</span> <span class=\"o\">(</span><span class=\"bp\">&lt;=</span> <span class=\"n\">e</span> <span class=\"mi\">50</span><span class=\"o\">))</span>\n\n<span class=\"o\">(</span><span class=\"n\">assert</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">assert</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">assert</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">assert</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span> <span class=\"n\">d</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">assert</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span> <span class=\"o\">(</span><span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"mi\">240</span> <span class=\"o\">))</span>\n\n<span class=\"bp\">;</span> <span class=\"n\">Solve</span>\n<span class=\"o\">(</span><span class=\"n\">check</span><span class=\"bp\">-</span><span class=\"n\">sat</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">get</span><span class=\"bp\">-</span><span class=\"n\">model</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 295014725,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661335627
    },
    {
        "content": "<p><a href=\"https://compsys-tools.ens-lyon.fr/z3/index.php\">https://compsys-tools.ens-lyon.fr/z3/index.php</a></p>",
        "id": 295014738,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661335632
    },
    {
        "content": "<p>Right and indeed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"mi\">50</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"mi\">50</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"mi\">50</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">≤</span> <span class=\"mi\">50</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">≤</span> <span class=\"mi\">50</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbc</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hcd</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hde</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">&lt;</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">e</span> <span class=\"bp\">≤</span> <span class=\"mi\">46</span> <span class=\"bp\">+</span> <span class=\"mi\">47</span> <span class=\"bp\">+</span> <span class=\"mi\">48</span> <span class=\"bp\">+</span> <span class=\"mi\">49</span> <span class=\"bp\">+</span> <span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span>\n</code></pre></div>",
        "id": 295015214,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661335824
    },
    {
        "content": "<p>So we are just 1 <code>wlog</code> away from the general statement.</p>",
        "id": 295015548,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661335975
    },
    {
        "content": "<p>But I guess <code>wlog</code> struggles with <code>5!</code>.</p>",
        "id": 295015591,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661335994
    },
    {
        "content": "<p>yeah and this wouldn't work if you wanted to prove it for all n, I suppose.</p>",
        "id": 295016165,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1661336242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295006830\">said</a>:</p>\n<blockquote>\n<p>Isn't that <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#mono\">tactic#mono</a>?</p>\n</blockquote>\n<p>thank you so much Ruben. Even though the proofs are now longer by lines, they are so much more readable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">-</span>    <span class=\"n\">refine</span> <span class=\"n\">mul_le_mul_of_nonneg_left</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">inv_nonneg.mpr</span> <span class=\"n\">fac_nonneg</span><span class=\"o\">),</span>\n<span class=\"bp\">-</span>    <span class=\"n\">refine</span> <span class=\"n\">pow_le_pow_of_le_left</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">positivity</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"bp\">-</span>    <span class=\"c1\">-- We use linarith to prove |x - y| ≤ |b - a|:</span>\n<span class=\"bp\">-</span>    <span class=\"n\">exact</span> <span class=\"n\">abs_le_abs</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">hx.2</span><span class=\"o\">,</span> <span class=\"n\">hy.1</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">hx.1</span><span class=\"o\">,</span> <span class=\"n\">hy.2</span><span class=\"o\">]),</span>\n<span class=\"bp\">+</span>    <span class=\"n\">mono</span><span class=\"bp\">*</span><span class=\"o\">,</span>\n<span class=\"bp\">+</span>    <span class=\"n\">any_goals</span> <span class=\"o\">{</span> <span class=\"n\">positivity</span> <span class=\"o\">},</span>\n<span class=\"bp\">+</span>    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hx.2</span> <span class=\"o\">},</span>\n<span class=\"bp\">+</span>    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hy.1</span> <span class=\"o\">},</span>\n<span class=\"bp\">+</span>    <span class=\"o\">{</span> <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">hx.1</span><span class=\"o\">,</span> <span class=\"n\">hy.2</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">-</span>  <span class=\"n\">refine</span> <span class=\"n\">mul_le_mul_of_nonneg_left</span> <span class=\"n\">_</span> <span class=\"n\">hSup</span><span class=\"o\">,</span>\n<span class=\"bp\">-</span>  <span class=\"n\">refine</span> <span class=\"n\">mul_le_mul_of_nonneg_left</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">pow_nonneg</span> <span class=\"o\">(</span><span class=\"n\">sub_pos.mpr</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n<span class=\"bp\">-</span>  <span class=\"n\">exact</span> <span class=\"n\">sub_le_sub_right</span> <span class=\"n\">hx.2</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"bp\">+</span>  <span class=\"n\">mono</span><span class=\"bp\">*</span> <span class=\"k\">with</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"bp\">+</span>  <span class=\"n\">any_goals</span> <span class=\"o\">{</span> <span class=\"n\">positivity</span> <span class=\"o\">},</span>\n<span class=\"bp\">+</span>  <span class=\"n\">exact</span> <span class=\"n\">hx.2</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 295136362,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1661380191
    },
    {
        "content": "<p>it feels like <code>mono*, any_goals { positivity }</code> is exactly the thing I wanted to have</p>",
        "id": 295138243,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1661381503
    },
    {
        "content": "<p>What do people think of this as a proof that should be automatic?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nat.min_add_sub</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It feels like if only there was a way to get lean to realize that the definition of min is somehow essentially casework, then this could be solved by tidy or something.</p>",
        "id": 297468460,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1662490918
    },
    {
        "content": "<p>It also needs to understand truncated subtraction.</p>",
        "id": 297468695,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662491004
    },
    {
        "content": "<p>My first reaction was: \"That looks very wrong! The symmetry is broken!\" -- And then \"Oooooh wait. ℕ... Never mind.\"</p>",
        "id": 297468813,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662491048
    },
    {
        "content": "<p>Perhaps a general mechanism to indicate \"to prove stuff about <code>foo x y</code> you should case on <code>some_lemma x y</code>\" would help with that</p>",
        "id": 297474297,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662493124
    },
    {
        "content": "<p>We have things like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sup_induction\">docs#finset.sup_induction</a> already, but those are too strong if your goal also includes a bare <code>s</code> as well as <code>s.sup f</code></p>",
        "id": 297474387,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662493166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/297474297\">said</a>:</p>\n<blockquote>\n<p>Perhaps a general mechanism to indicate \"to prove stuff about <code>foo x y</code> you should case on <code>some_lemma x y</code>\" would help with that</p>\n</blockquote>\n<p>Maybe a <code>@[case_simp]</code> tag for lemmas of the form <code>a = if b then c else d</code> where <code>c</code> and <code>d</code> are both simpler than <code>a</code></p>",
        "id": 297477554,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1662494357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295006602\">said</a>:</p>\n<blockquote>\n<p>not really a single proof, but I spent recently too much time on finding the correct version of lemmas like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_le_mul_of_nonneg_left\">docs#mul_le_mul_of_nonneg_left</a><br>\nmaybe a variant of <code>congr</code> for inequalities would be nice. So <code>a (b+d) &lt; a (c + d)</code> gets reduced to <code>b &lt; c</code> and a bunch of stuff that positivity can prove</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> I totally agree, I think this \"inequality-congr\" is the basic mental tactic we use to prove inequalities on paper.  I actually have a work-in-progress version of this tactic for teaching, see<br>\n<a href=\"https://hrmacbeth.github.io/math2001/01_Proofs_by_Calculation.html#proving-inequalities\">https://hrmacbeth.github.io/math2001/01_Proofs_by_Calculation.html#proving-inequalities</a></p>\n<p>It needs more polishing before joining mathlib, though.</p>",
        "id": 297484869,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1662497329
    },
    {
        "content": "<p>This was actually my motivation for writing <code>positivity</code>.</p>",
        "id": 297484906,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1662497350
    },
    {
        "content": "<p>Oh this is also the tactic idea I was telling you in DMs, right? What I got from discussing it with Jannis is that we even needed generalised rewriting.</p>",
        "id": 297489423,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662499479
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I think this is easier than generalized rewriting, and more akin to <code>congr</code> than to <code>rw</code> (it's interesting to me that both Moritz and I used <code>congr</code> as our mental analogy).</p>\n<p>As I understand it, generalized-rewriting by <code>h : a ≤ b</code> would let you, e.g., reduce a goal <code>⊢ 3 * a ≤ 5</code> to a goal <code>⊢ 3 * b ≤ 5</code>.</p>\n<p>By contrast, what I have written is a finishing tactic which would, e.g., prove the goal <code>⊢ 3 * a ≤ 3 * b</code>.</p>",
        "id": 297514027,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1662517362
    },
    {
        "content": "<p>It's very much in the same vein as the tactic <code>mono*</code> (discussed <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/295136362\">upthread</a>), but designed to be \"greedy\".   Compare their behaviour on the goal <code>⊢ a * x ≤ b * x</code>.</p>\n<ul>\n<li>the tactic I wrote will go ahead and reduce this to the goals <code>a ≤ b</code> and <code>0 ≤ x</code>.</li>\n<li>the tactic <code>mono</code> will tell you that it could reduce this to (<code>x ≤ 0</code> and <code>b ≤ a</code>) or to (<code>0 ≤ x</code> and <code>a ≤ b</code>), and ask you to disambiguate.</li>\n</ul>\n<p>In my experience, paper proofs are usually written in such a way that the greedy behaviour is correct, so it's a more efficient user experience if you don't have to disambiguate (especially when you're using the recursive form <code>mono*</code> and would have disambiguate several times in a single proof).</p>\n<p>But they are close enough that it would probably be possible to re-implement my tactic as a variant of <code>mono</code>.</p>",
        "id": 297514859,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1662518398
    },
    {
        "content": "<p>concerning <code>mono*</code> I had a slight issue, where mono produced more <code>positivity</code>-goals than what I had when wrote the proof by hand. This might be related to the \"non-greedyness\" of mono.</p>",
        "id": 297519491,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1662524139
    },
    {
        "content": "<p>Ah yes, so this is not quite the tactic I want/need. But still interesting!</p>",
        "id": 297534752,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662535481
    },
    {
        "content": "<p>SRL has those huge calc blocks that would become much more readable if I could rewrite along inequalities, but I can't use your tactic there because most calls would be non finishing.</p>",
        "id": 297534888,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662535545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/297468460\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nat.min_add_sub</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Aesop will be able to do this, assuming a good simp set:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Aesop</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat.not_le_le</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat.sub_eq_zero</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat.add_sub</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat.min_add_sub</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">aesop</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">norm</span> <span class=\"n\">unfold</span> <span class=\"n\">min</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Aesop recognises that the goal, after unfolding <code>min</code>, contains an <code>if</code>, and splits along its condition. (It essentially runs <code>split_ifs</code> eagerly, which imo is usually the right thing to do.) <code>simp</code> does the rest.</p>",
        "id": 297742204,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1662630793
    },
    {
        "content": "<p>I had forgotten about this example.  On <a href=\"https://github.com/leanprover-community/mathlib/tree/adomani_remove_subs\">branch#adomani_remove_subs</a>, this also is a proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.remove_subs</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">remove_subs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 297752654,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662635344
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> should <code>Nat.not_le_le</code> really be <code>Nat.not_le_lt</code>, with a strict inequality on one side?</p>",
        "id": 297752864,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662635428
    },
    {
        "content": "<p>Hehe, yes, of course.</p>",
        "id": 297759861,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1662638392
    },
    {
        "content": "<p>With that lemma, Aesop should be able to prove much more than <code>Nat.min_add_sub</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 297834065,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662659163
    },
    {
        "content": "<p>In the spirit of automatization, the <a href=\"#narrow/stream/113488-general/topic/Automatic.20proof.20for.20nat-sub\">nat-subtraction</a> discussion and the <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic/near/297468460\">example with <code>max/min</code></a> that <span class=\"user-mention\" data-user-id=\"282271\">@Bolton Bailey</span> and <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> mentioned above seem to suggest support for a tactic similar to <code>split_ifs</code> that would look for stuff on which to do <code>cases</code> and actually do it.</p>\n<p>Would this be something desirable?</p>",
        "id": 297927698,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662712734
    },
    {
        "content": "<p>The tactic <code>remove_subs</code> could be easily modified to at least split over <code>max/min</code> but probably even more generally, to fit with some user-flag that tells it what to do cases on.</p>",
        "id": 297927705,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662712736
    },
    {
        "content": "<p><code>example {α β} {f : α → β} {b : β} : (∃ a, f a = b) ∨ ∀ a, f a ≠ b</code></p>\n<p><code>finish</code> can do this but we're encouraged not to use it, afair. <code>tauto!</code> and <code>itauto!</code> failing on this is unexplicable (and it's not <code>ne</code>, the ¬ version fails as well)</p>",
        "id": 299442115,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663511886
    },
    {
        "content": "<p>I suspect <code>tauto</code> does not know about moving negations out of quantifiers?</p>",
        "id": 299442468,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663512116
    },
    {
        "content": "<p>To generalize what I was saying before in the context of this example, I feel there should be more emphasis on automatic tactics breaking down logical connectives. Just as <code>tidy</code> calls <code>split</code> when it sees an <code>and</code> and <code>intro</code> when it sees a <code>-&gt;</code> I feel like it should call something like<code>decidable.or_iff_not_imp_left</code> when it sees the goal is a disjunction (and indeed <code>classical, rw decidable.or_iff_not_imp_left, tidy,</code> closes the goal).</p>",
        "id": 299454582,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1663519484
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"359917\">@Timothee Lacroix</span> 's AI can solve this one! I just kept selecting the top option. Maybe it got lucky but still!</p>",
        "id": 299459311,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1663522653
    },
    {
        "content": "<p><code>itauto</code> doesn't know anything about predicate logic</p>",
        "id": 299465162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663526188
    },
    {
        "content": "<p>Anyone know a way to make this automatic (assuming we're in a classical context):<br>\n<code>lemma blahj {a b : Prop} (h : ¬a ↔ ¬b) : a ↔ b := sorry</code></p>",
        "id": 299536260,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1663582245
    },
    {
        "content": "<p>It's essentially just  one direction of <code>not_iff_not</code> but we don't actually seem to have it.</p>",
        "id": 299536438,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1663582287
    },
    {
        "content": "<p>Could be called <code>iff.of_not</code></p>",
        "id": 299536537,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1663582310
    },
    {
        "content": "<p><code>not_iff_not.1</code></p>",
        "id": 299538063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663583015
    },
    {
        "content": "<p>Aye, I mean, that's what I did, but none of the automated tools could find it...</p>",
        "id": 299538750,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1663583366
    },
    {
        "content": "<p>library search should find one directional versions of iff lemmas</p>",
        "id": 299539110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663583561
    },
    {
        "content": "<p>it might be underpowered in lean 4</p>",
        "id": 299539178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663583610
    },
    {
        "content": "<p>It fails in Lean 3.<br>\n<code>lemma blahj {a b : Prop} (h : ¬a ↔ ¬b) : a ↔ b := by library_search!</code><br>\n<code>lemma blahj {a b : Prop} (h : ¬a ↔ ¬b) : a ↔ b := by library_search</code></p>\n<p>both fail.</p>",
        "id": 299539219,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1663583641
    },
    {
        "content": "<p>That's unfortunate, and perhaps counts as a <code>library_search</code> bug...</p>",
        "id": 299540898,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1663584566
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">blahj</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"bp\">!</span>\n</code></pre></div>",
        "id": 299542456,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663585265
    }
]
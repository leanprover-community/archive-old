[
    {
        "content": "<p>Doesn't work, but it has some idea of syntax:<br>\n<a href=\"/user_uploads/3121/DOZGEA3fF3NL7QFDt01voynM/2022-12-03_14-12-1670072219.png\">2022-12-03_14-12-1670072219.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/DOZGEA3fF3NL7QFDt01voynM/2022-12-03_14-12-1670072219.png\" title=\"2022-12-03_14-12-1670072219.png\"><img src=\"/user_uploads/3121/DOZGEA3fF3NL7QFDt01voynM/2022-12-03_14-12-1670072219.png\"></a></div>",
        "id": 313682461,
        "sender_full_name": "ohhaimark",
        "timestamp": 1670072506
    },
    {
        "content": "<p>Those look like pretty good efforts to me</p>",
        "id": 313682666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1670072583
    },
    {
        "content": "<p>I just had a go at using ChatGPT to try to get a definition of a multigraph. Here's a transcript:</p>\n<blockquote>\n<p>A multigraph is a collection of unordered pairs of vertices, allowing repeats. Give a formalization of this concept in Lean.</p>\n<blockquote>\n<p>In Lean, a multigraph can be formalized as a type of mathematical structure known as a multiset of unordered pairs of vertices. A multiset is a generalization of the concept of a set, where elements are allowed to appear multiple times, rather than just once as in a regular set. An unordered pair is a pair of elements in which the order of the elements does not matter, i.e. (a,b) and (b,a) are considered the same.</p>\n<p>A formalization of this concept in Lean might look something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Here, α represents the type of the vertices in the multigraph. The multigraph structure has two fields: vertices, which is a multiset of vertices, and edges, which is a multiset of unordered pairs of vertices. This allows for multiple edges between the same pairs of vertices, as well as for multiple instances of the same vertex to appear in the vertices multiset.</p>\n</blockquote>\n<p>This definition has two defects. The first is that it doesn't require that every vertex incident to an edge be in the <code>vertices</code> multiset. The second is that it has ordered pairs of vertices. In mathlib, we use <code>sym2</code> for unordered pairs. Please fix this.</p>\n<blockquote>\n<p>Here is a revised definition that addresses the two defects mentioned above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">incident_to_multigraph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">p.1</span> <span class=\"bp\">∈</span> <span class=\"n\">g.vertices</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2</span> <span class=\"bp\">∈</span> <span class=\"n\">g.vertices</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_valid_multigraph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">g.edges</span> <span class=\"bp\">→</span> <span class=\"n\">incident_to_multigraph</span> <span class=\"n\">g</span> <span class=\"n\">p</span>\n</code></pre></div>\n<p>In this revised definition, the multigraph structure has the same two fields as before, but now the edges field is a multiset of sym2 α, which is a type defined in mathlib for representing unordered pairs of elements of type α.</p>\n<p>The incident_to_multigraph function takes a multigraph and a pair of vertices (as a sym2 α) and returns true if and only if both vertices in the pair are present in the vertices multiset of the multigraph.</p>\n<p>The is_valid_multigraph function takes a multigraph and returns true if and only if every edge in the edges multiset is incident to a pair of vertices that are both present in the vertices multiset of the multigraph. This ensures that the multigraph is well-defined, with no \"dangling\" edges that are incident to vertices that are not in the vertices multiset.</p>\n</blockquote>\n<p>This is still not correct, since the axiom that it be a valid multigraph should be part of the structure definition.</p>\n<blockquote>\n<p>Here is a revised definition that incorporates the axiom that the multigraph must be valid as part of the structure itself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span> <span class=\"bp\">→</span> <span class=\"n\">p.1</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">incident_to_multigraph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">p.1</span> <span class=\"bp\">∈</span> <span class=\"n\">g.vertices</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2</span> <span class=\"bp\">∈</span> <span class=\"n\">g.vertices</span>\n</code></pre></div>\n<p>In this revised definition, the multigraph structure has three fields: vertices, edges, and valid. The vertices and edges fields are the same as before, but now the valid field is a proposition that states that every edge in the edges multiset is incident to a pair of vertices that are both present in the vertices multiset of the multigraph. This axiom ensures that the multigraph is well-defined and avoids the problem of \"dangling\" edges.</p>\n<p>The incident_to_multigraph function is unchanged from the previous definition. It takes a multigraph and a pair of vertices (as a sym2 α) and returns true if and only if both vertices in the pair are present in the vertices multiset of the multigraph.</p>\n</blockquote>\n<p>The next issue is that since <code>sym2</code> is defined to be a quotient type, you cannot just do <code>p.1</code> and <code>p.2</code>. However, <code>sym2</code> has a <code>has_mem</code> instance so you can quantify over elements of <code>p</code>. Please fix this.</p>\n<blockquote>\n<p>Here is a revised definition that avoids using the p.1 and p.2 notation, and instead quantifies over the elements of p using the has_mem instance of sym2:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">incident_to_multigraph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">g.vertices</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">g.vertices</span>\n</code></pre></div>\n<p>In this revised definition, the multigraph structure has the same three fields as before, but the valid field has been updated to use quantification over the elements of p rather than the p.1 and p.2 notation. This ensures that the definition is compatible with the sym2 type, which is a quotient type.</p>\n<p>The incident_to_multigraph function has also been updated to use quantification over the elements of p rather than the p.1 and p.2 notation. It takes a multigraph and a pair of vertices (as a sym2 α) and returns true if and only if both vertices in the pair are present in the vertices multiset of the multigraph.</p>\n</blockquote>\n<p>This works, but you can just write <code>∀ (x ∈ p)</code> rather than checking equality with a pair.</p>\n<blockquote>\n<p>Here is a further revised definition that uses the ∀ (x ∈ p) notation instead of quantifying over the elements of p and checking equality with a pair:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">incident_to_multigraph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">g.vertices</span>\n</code></pre></div>\n<p>In this revised definition, the multigraph structure has the same three fields as before, but the valid field has been updated to use the ∀ (x ∈ p) notation instead of quantifying over the elements of p and checking equality with a pair. This is a more concise and idiomatic way of expressing the same concept.</p>\n<p>The incident_to_multigraph function has also been updated to use the ∀ (x ∈ p) notation. It takes a multigraph and a pair of vertices (as a sym2 α) and returns true if and only if both vertices in the pair are present in the vertices multiset of the multigraph.</p>\n</blockquote>\n<p>Why is <code>incident_to_multigraph</code> a <code>Prop</code> definition? There is no need for this predicate, since it is always true for a <code>multigraph</code>. Please change this to be a lemma named <code>multigraph.valid</code>.</p>\n<blockquote>\n<p>Here is a further revised definition that eliminates the incident_to_multigraph function and instead uses a lemma named multigraph.valid to express the same concept:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">multigraph.valid</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">g.edges</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">g.vertices</span> <span class=\"o\">:=</span>\n<span class=\"n\">g.valid</span> <span class=\"n\">p</span> <span class=\"n\">hp</span>\n</code></pre></div>\n<p>In this revised definition, the multigraph structure is unchanged from the previous definition. The incident_to_multigraph function has been eliminated, and instead a lemma named multigraph.valid has been added. This lemma states that if a pair of vertices p is an element of the edges multiset of a multigraph, then both vertices in the pair must be present in the vertices multiset of the multigraph. This lemma is a direct consequence of the valid axiom in the multigraph structure, and so it can be derived by simply applying the valid axiom to the given pair of vertices and the given multigraph.</p>\n</blockquote>\n<p>Great. Now, the mathlib-style name for <code>valid</code> (both the field and the lemma) should be <code>mem_vertices_of_mem_edges</code>. Please fix this.</p>\n<blockquote>\n<p>Here is a further revised definition that uses the mathlib-style naming conventions for the valid field and the multigraph.valid lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">mem_vertices_of_mem_edges</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">multigraph.mem_vertices_of_mem_edges</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">g.edges</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">g.vertices</span> <span class=\"o\">:=</span>\n<span class=\"n\">g.mem_vertices_of_mem_edges</span> <span class=\"n\">p</span> <span class=\"n\">hp</span>\n</code></pre></div>\n<p>In this revised definition, the multigraph structure has the same three fields as before, but the valid field has been renamed to mem_vertices_of_mem_edges to follow the mathlib naming conventions. Similarly, the multigraph.valid lemma has been renamed to multigraph.mem_vertices_of_mem_edges to follow the naming conventions for lemmas.</p>\n<p>The lemma multigraph.mem_vertices_of_mem_edges states that if a pair of vertices p is an element of the edges multiset of a multigraph, then both vertices in the pair must be present in the vertices multiset of the multigraph. This lemma is a direct consequence of the mem_vertices_of_mem_edges axiom in the multigraph structure, and so it can be derived by simply applying the mem_vertices_of_mem_edges axiom to the given pair of vertices and the given multigraph.<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 313686092,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1670073964
    },
    {
        "content": "<p>I'd say it's pretty receptive to code review (though with this I think it'd be easier to write the code myself)</p>",
        "id": 313686391,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1670074145
    },
    {
        "content": "<p>I almost got it to define a type for walks, but I found it to be difficult to tell it that it needs to write <code>quotient.mk</code> in front of <code>(x, y)</code> and that, with its definition, all the vertices should be elements of <code>vertices</code>. (Of course, in the previous transcript <code>multiset</code> for the vertices doesn't make much sense, but I didn't want to try to correct it.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">walk</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">walk</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">g.edges</span> <span class=\"bp\">→</span> <span class=\"n\">walk</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">walk</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p><em>Edit:</em> With some more prodding, I got it to give this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">walk</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">multigraph</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">g.vertices</span> <span class=\"bp\">→</span> <span class=\"n\">walk</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">sym2.mk</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">g.edges</span> <span class=\"bp\">→</span> <span class=\"n\">walk</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">walk</span> <span class=\"n\">x</span> <span class=\"n\">z</span>\n</code></pre></div>",
        "id": 313687432,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1670074613
    },
    {
        "content": "<p>Notice that you <a href=\"https://openai.com/blog/chatgpt/\">have a chance to win $500 API credits</a> if you enter the <a href=\"https://cdn.openai.com/chatgpt/ChatGPT_Feedback_Contest_Rules.pdf\">ChatGPT Feedback Contest</a> via <a href=\"https://docs.google.com/forms/d/1DzIQcXZpDB_RxJ9uGqZoucNdsrq4dOSup_o-CDfbiIE/viewform?edit_requested=true\">this form</a>:</p>\n<blockquote>\n<p>You can choose to enter the ChatGPT Feedback Contest3 for a chance to win up to $500 in API credits. Entries can be submitted via the feedback form that is linked in the ChatGPT interface.</p>\n</blockquote>\n<p>But I don't see the form being linked in the interface.</p>",
        "id": 313776640,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670141484
    },
    {
        "content": "<p>I had an utterly bizarre interaction with ChatGPT while asking it questions about my research area last night. Context: the question of whether the dual of an algebraic matroid is always algebraic is open, and (to the best of my knowledge) the mathematician Giuseppe di Rocco has never existed. </p>\n<p><strong>Q: Is there an algebraic matroid whose dual is not algebraic?</strong><br>\nIt is not possible for an algebraic matroid to have a non-algebraic dual, because the dual of an algebraic matroid is always an algebraic matroid. This is a consequence of a fundamental theorem in matroid theory, known as the theorem on algebraic closure, which states that the set of all algebraic matroids is closed under the operation of taking duals. This means that if a matroid is algebraic, then its dual must also be algebraic. Therefore, it is not possible for an algebraic matroid to have a non-algebraic dual.</p>\n<p><strong>Q: who proved the theorem on algebraic closure? </strong><br>\nThe theorem on algebraic closure is a fundamental result in matroid theory, and it was first proved by a mathematician named Giuseppe Di Rocco in the early 1990s. Di Rocco's proof of this theorem was a major breakthrough in the study of algebraic matroids, and it has been an important foundation for much of the subsequent research in this area. The theorem on algebraic closure has many important consequences for the structure and properties of algebraic matroids, and it has been used to prove many other theorems and results in matroid theory and related fields.</p>",
        "id": 313981987,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1670249286
    },
    {
        "content": "<p>Sounds a little bit like Gian-Carlo Rota maybe chatgpt is just bad at Italian names</p>",
        "id": 313986958,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1670250593
    },
    {
        "content": "<p>That's a good point. There's still no such theorem, though.</p>",
        "id": 313987494,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1670250730
    },
    {
        "content": "<p>I saw some post say that it gives less insane output if you tell it to think before it answers -- the analogy was that it is BS'ing as if it was a human who was talking too fast without thinking by default or something. Does that change the output at all? The post I'm recalling added something like \"Think carefully first before you answer\" to the end of the question.</p>",
        "id": 313990259,
        "sender_full_name": "Julian Berman",
        "timestamp": 1670251508
    },
    {
        "content": "<p>When I ask it the same question now, it gives a more circumspect answer,  albeit implying that there exists a counterexample. And it claims not to recognize the theorem on algebraic closure in matroid theory. Perhaps it was drinking last night.</p>",
        "id": 313991634,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1670251931
    },
    {
        "content": "<p>I sort of want to read a Borges-style short story about a mathematician coming across an obscure reference to an unknown but important result, revealing a whole secondary body of literature that's been hidden in plain sight. Giuseppe Di Rocco must be Gian-Carlo Rota's pen name...</p>",
        "id": 313992729,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1670252233
    },
    {
        "content": "<p>It feels like one of those 'Mandela effect' things.</p>",
        "id": 313992836,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1670252262
    },
    {
        "content": "<p>Watch out, Nicolas Bourbaki also started out as a fictitious mathematician with a similar biography!</p>",
        "id": 314047832,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1670253573
    },
    {
        "content": "<p>Tangential: With more lean code out in the open, a LLM will be able to produce lean code that's ready for copy&amp;paste, just as it already is pretty decent for python and other programming languages. It may be that LLMs don't need to be great at arithmetic or mathematical reasoning, as long as it can produce code that can be executed in a computation package, or calls the right Lean tactics.</p>",
        "id": 314156881,
        "sender_full_name": "Yao Liu",
        "timestamp": 1670290186
    },
    {
        "content": "<p>This is my experience so far playing with it. When you ask it to help prove a certain statement X _in Lean_, usually it gives way more detail (e.g. how some inductive types involved in X are defined/constructed)  than when you ask it to prove X. However, so far, it is terrible at calling the relevant Lean tactics, it just spits out gibberish that does not type check.</p>",
        "id": 314157342,
        "sender_full_name": "Sina",
        "timestamp": 1670290542
    },
    {
        "content": "<p>Generating valid python is a lot easier for an LLM than lean because  there's a lot more garbage python that's still valid than there is garbage lean that is valid</p>",
        "id": 314204740,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670321640
    },
    {
        "content": "<p>There's <a href=\"https://github.com/mpociot/chatgpt-vscode\">VSCode extension</a> now and you may want to enable it when coding in Lean, in the hope of making ChatGPT more familiar with Lean (because OpenAI <a href=\"https://twitter.com/sama/status/1599462178176004101\">retrains the model</a> using interaction data, though I haven't tried the extension and maybe you can't thumb up/down in VSCode).</p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/sama/status/1599462178176004101\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/b36b62d6e505b265b2d72dcf3d6a7d12b4f65d35/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f3830343939303433343435353838373837322f4247305868374f615f6e6f726d616c2e6a7067\"></a><p>also, we have not done any retraining yet; presumed improvements are just luck of the draw. we will do a retrain this week that will hopefully significantly improve things!</p><span>- Sam Altman (@sama)</span></div></div><p>I've also started using <a href=\"https://github.com/wong2/chat-gpt-google-extension\">ChatGPT for Google</a> and about to try out <a href=\"https://github.com/gragland/chatgpt-chrome-extension\">ChatGPT everywhere</a>.</p>",
        "id": 315433014,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670869912
    }
]
[
    {
        "content": "<p>Let's say I have a bunch of groups, and I use <code>quotient</code> to make isomorphism classes. Is there a constructive way to make the isomorphism classes inherit the structure of a group?</p>",
        "id": 124464358,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522525773
    },
    {
        "content": "<p>I don't know but I'd like to find out. Let's say our groups are specified as:</p>\n<div class=\"codehilite\"><pre><span></span>variables {I : Type} (G : I -&gt; Type) [Π i, group (G i)]\n</pre></div>",
        "id": 124464513,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522526123
    },
    {
        "content": "<p>Are we also given the isomorphisms between those groups or to you want to construct them somehow?</p>",
        "id": 124464561,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522526213
    },
    {
        "content": "<p>I have already constructed the quotient</p>",
        "id": 124464564,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522526224
    },
    {
        "content": "<p>Can you show it?</p>",
        "id": 124464567,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522526243
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>import data.set.basic group_theory.subgroup\n\nuniverse u\n\nnamespace group\n\nvariables {α : Type u} [group α] (S : set α)\n\ninductive generate : set α\n| basic : ∀ x ∈ S, generate x\n| one : generate 1\n| mul_inv : ∀ x y, generate x → generate y → generate (x * y⁻¹)\n\nnamespace generate\n\ndef is_subgroup : is_subgroup (generate S) :=\n{ one_mem := generate.one S,\n  mul_inv_mem := λ x y hx hy, generate.mul_inv x hx y hy }\n\nend generate\n\nvariables {β : Type u} [group β]\nvariables α β\n\nclass isomorphism extends α ≃ β :=\n( is_group_hom : is_group_hom to_fun )\n\nnamespace isomorphism\n\nvariables {γ : Type u} [group γ]\nvariables {β γ}\n\n@[refl] protected def refl : isomorphism α α :=\n{ is_group_hom := λ x y, rfl\n  .. equiv.refl α }\n\nvariables {α β γ}\n\n@[symm] protected def symm (e : isomorphism α β) : isomorphism β α :=\n{ is_group_hom := λ x y, calc\n          e.inv_fun (x * y)\n        = e.inv_fun (e.to_fun (e.inv_fun x) * e.to_fun (e.inv_fun y)) : by rw [e.right_inv, e.right_inv]\n    ... = e.inv_fun (e.to_fun (e.inv_fun x * e.inv_fun y)) : by rw e.is_group_hom\n    ... = e.inv_fun x * e.inv_fun y : by rw e.left_inv,\n  .. equiv.symm e.to_equiv }\n\n@[trans] protected def trans (e₁ : isomorphism α β) (e₂ : isomorphism β γ) : isomorphism α γ :=\n{ is_group_hom := λ x y, by unfold equiv.trans; dsimp; rw [e₁.is_group_hom, e₂.is_group_hom],\n  .. equiv.trans e₁.to_equiv e₂.to_equiv }\n\nend isomorphism\n\nend group\n\nvariable (S : Type u)\n\nnamespace free_group\n\nstructure to_be_named (G : Type u) [group G] :=\n( gen : set G )\n( gen_gen : group.generate gen = set.univ )\n( func : gen → S )\n( inj : function.injective func )\n\ndef to_be_named.quotient_rel : setoid Σ G [H : group G], @to_be_named S G H :=\n⟨λ G H, nonempty $ @group.isomorphism G.1 G.2.1 H.1 H.2.1,\n λ G, ⟨@group.isomorphism.refl G.1 G.2.1⟩,\n λ G H ⟨e⟩, ⟨@group.isomorphism.symm G.1 G.2.1 H.1 H.2.1 e⟩,\n λ G H K ⟨e₁⟩ ⟨e₂⟩, ⟨@group.isomorphism.trans G.1 G.2.1 H.1 H.2.1 K.1 K.2.1 e₁ e₂⟩⟩\n\ndef something : Type (u+1) :=\nquotient (to_be_named.quotient_rel S)\n\nnoncomputable def rep : something S → Σ G [H : group G], @to_be_named S G H :=\nλ G, classical.some (@quotient.exists_rep _ (to_be_named.quotient_rel S) G)\n\n#check λ G, classical.some (@quotient.exists_rep _ (to_be_named.quotient_rel S) G)\n\nstructure funny_structure : Type (u+1) :=\n( G : something S )\n( func : S → (rep S G).1 )\n( im_gen : @group.generate _ (rep S G).2.1 (func &#39;&#39; set.univ) = set.univ )\n\ndef some_product : Type (u+1) :=\nΠ A : funny_structure S, (rep S A.G).1\n\nnoncomputable instance some_product.group : group (some_product S) :=\n{ mul := λ f g x, @has_mul.mul _ (@semigroup.to_has_mul _ (@monoid.to_semigroup _ (@group.to_monoid _ (rep S (x.G)).2.1))) (f x) (g x),\n  mul_assoc := λ f g h, funext $ λ x, by apply mul_assoc,\n  one := λ x, @has_one.one _ (@monoid.to_has_one _ (@group.to_monoid _ (rep S (x.G)).2.1)),\n  one_mul := λ f, funext $ λ x, by apply one_mul,\n  mul_one := λ f, funext $ λ x, by apply mul_one,\n  inv := λ f x, @has_inv.inv _ (@group.to_has_inv _ (rep S (x.G)).2.1) (f x),\n  mul_left_inv := λ f, funext $ λ x, by apply mul_left_inv }\n\ndef aux_func : S → some_product S :=\nλ x A, A.func x\n\nend free_group\n\ndef free_group : Type (u+1) :=\ngroup.generate (free_group.aux_func S &#39;&#39; set.univ)\n\ninstance free_group.group : group (free_group S) :=\nis_subgroup.group group.generate.is_subgroup\n\ndef free_group.from_S : S → free_group S :=\nλ x, ⟨free_group.aux_func S x, group.generate.basic _ ⟨x, trivial, rfl⟩⟩\n</pre></div>",
        "id": 124464607,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522526283
    },
    {
        "content": "<p>this is WIP so there are errors on the bottom, ignore those</p>",
        "id": 124464610,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522526291
    },
    {
        "content": "<p>the quotient is appropriately named <code>something</code></p>",
        "id": 124464612,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522526308
    },
    {
        "content": "<p>So you'd like to remove <code>noncomputable</code> from your <code>group</code> instance?</p>",
        "id": 124464943,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522527105
    },
    {
        "content": "<p>right</p>",
        "id": 124465033,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522527267
    },
    {
        "content": "<p>You had to prove that the composite of group homs is a group hom?? That's not there already?</p>",
        "id": 124465035,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522527275
    },
    {
        "content": "<p>you'll be surprised</p>",
        "id": 124465038,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522527288
    },
    {
        "content": "<p>Instead of <code>classical.some</code> and <code>quotient.exists_rep</code> in <code>rep</code>, can you try and use <code>quotient.lift</code>?</p>",
        "id": 124465249,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522527767
    },
    {
        "content": "<p>to where?</p>",
        "id": 124465250,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522527776
    },
    {
        "content": "<p>Not sure yet</p>",
        "id": 124465316,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522527929
    },
    {
        "content": "<p>You're basically taking the value of a quotient type and sticking it in a sigma type. Because the sigma type is in <code>Type u</code> depending on which representative you extract, you will be able to tell members of the quotient sets apart.</p>",
        "id": 124465376,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522528081
    },
    {
        "content": "<p>There are two possibilities I can see to stay constructive: instead of using a sigma type, use an existential quantification (not sure if that's workable with the group) or extract something other than the element of one of the group. A representative value that will be the same for every element of a given equivalence class</p>",
        "id": 124465422,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522528177
    },
    {
        "content": "<p>Or maybe Mario's <code>trunc</code> contraption can make the sigma type into something that isn't data</p>",
        "id": 124465475,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522528294
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> do we even need the quotient?</p>",
        "id": 124467440,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522533167
    },
    {
        "content": "<p>I think you're right, you don't need it, at least not there</p>",
        "id": 124467543,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522533387
    },
    {
        "content": "<p>I think the reason the author introduced it is because of some foundational issues with ZFC</p>",
        "id": 124467547,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522533411
    },
    {
        "content": "<p>the paper is here for reference <a href=\"https://www3.nd.edu/~andyp/notes/CategoricalFree.pdf\" target=\"_blank\" title=\"https://www3.nd.edu/~andyp/notes/CategoricalFree.pdf\">https://www3.nd.edu/~andyp/notes/CategoricalFree.pdf</a></p>",
        "id": 124467552,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522533433
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> this can be viewed in two ways</p>",
        "id": 124469143,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537508
    },
    {
        "content": "<p>you will view it as \"another reason why ZFC is stupid\"</p>",
        "id": 124469144,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537514
    },
    {
        "content": "<p>I will view it as \"another reason why Lean is stupid\"</p>",
        "id": 124469192,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537667
    },
    {
        "content": "<p>I'm wondering if you even need the sigma type</p>",
        "id": 124469193,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522537675
    },
    {
        "content": "<p>I did it without any quotient</p>",
        "id": 124469228,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537683
    },
    {
        "content": "<p>and without injectivity</p>",
        "id": 124469233,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537687
    },
    {
        "content": "<p>the only reason why the paper introduced those is to justify it in ZFC</p>",
        "id": 124469234,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537695
    },
    {
        "content": "<p>And sigma type?</p>",
        "id": 124469235,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522537699
    },
    {
        "content": "<p>well the sigma type has UMP as pi type right</p>",
        "id": 124469236,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537718
    },
    {
        "content": "<p>that means, (Sigma x1 x2) -&gt; x3 is the same as x1 -&gt; x2 -&gt; x3</p>",
        "id": 124469237,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537734
    },
    {
        "content": "<p>since they're there, the sigma doesn't need to be there anymore</p>",
        "id": 124469240,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537744
    },
    {
        "content": "<p>am I speaking English</p>",
        "id": 124469243,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537747
    },
    {
        "content": "<p>that thing there with that sigma is no longer used</p>",
        "id": 124469244,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537758
    },
    {
        "content": "<p>I can't English</p>",
        "id": 124469245,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537769
    },
    {
        "content": "<p>What's UMP?</p>",
        "id": 124469246,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522537788
    },
    {
        "content": "<p>universal mapping property</p>",
        "id": 124469247,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537794
    },
    {
        "content": "<p>or in CS language, \"destructor\" / \"eliminator\"</p>",
        "id": 124469273,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537803
    },
    {
        "content": "<p>Ah I see</p>",
        "id": 124469290,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522537825
    },
    {
        "content": "<p>So why is it that not needing a quotient type makes Lean stupid?</p>",
        "id": 124469291,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522537858
    },
    {
        "content": "<p>well if I need to explain I would have to bring another concept from math philosophy into here :P</p>",
        "id": 124469296,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537893
    },
    {
        "content": "<p>called predicativity</p>",
        "id": 124469297,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537895
    },
    {
        "content": "<p>Cool, I'm all ears</p>",
        "id": 124469336,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522537948
    },
    {
        "content": "<p>inductive types are predicative</p>",
        "id": 124469337,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537959
    },
    {
        "content": "<p>they're philosophically well-founded</p>",
        "id": 124469338,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537966
    },
    {
        "content": "<p>bigger things are built on top of smaller things</p>",
        "id": 124469339,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522537972
    },
    {
        "content": "<p>like \"canonical\", this word can't be properly defined, but a common criterion is whether the quantifiers quantify over the object to be constructed</p>",
        "id": 124469348,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538009
    },
    {
        "content": "<p>e.g. in ZFC, omega is constructed to be the intersection of every inductive set</p>",
        "id": 124469349,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538035
    },
    {
        "content": "<p>instead of building it from below, omega is constructed from above, which makes it philosophically not well-founded, and we call that impredicative</p>",
        "id": 124469388,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538059
    },
    {
        "content": "<p>in ZFC, omega := {x | x in A for every inductive A}</p>",
        "id": 124469389,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538077
    },
    {
        "content": "<p>but the \"for every\" quantifier there, quantifiers over omega itself</p>",
        "id": 124469390,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538087
    },
    {
        "content": "<p>now, the free group construction in the paper is equally impredicative</p>",
        "id": 124469399,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538114
    },
    {
        "content": "<p>in the sense that it takes the product of every possible group and then find the subgroup generated by the image of S</p>",
        "id": 124469400,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538147
    },
    {
        "content": "<p>but that product would have to already include that group to be constructed</p>",
        "id": 124469440,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538167
    },
    {
        "content": "<p>ZFC is an impredicative theory</p>",
        "id": 124469442,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538174
    },
    {
        "content": "<p>but that's unavoidable, because we want a strong foundation theory to do maths</p>",
        "id": 124469443,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538192
    },
    {
        "content": "<p>the common construction of free group is predicative</p>",
        "id": 124469449,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538234
    },
    {
        "content": "<p>because it builds on smaller things, i.e. individual words</p>",
        "id": 124469450,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538241
    },
    {
        "content": "<p>in ZFC, i.e. in the paper, the author constructed the free product by considering every group generated by a set that injects into S</p>",
        "id": 124469494,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538369
    },
    {
        "content": "<p>there's still a limitation on the size</p>",
        "id": 124469495,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538378
    },
    {
        "content": "<p>in Lean, i.e. in my file, I don't even need to care about the size, since Lean allows it</p>",
        "id": 124469497,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538396
    },
    {
        "content": "<p><a href=\"https://github.com/kckennylau/Lean/blob/master/free_group.lean\" target=\"_blank\" title=\"https://github.com/kckennylau/Lean/blob/master/free_group.lean\">https://github.com/kckennylau/Lean/blob/master/free_group.lean</a></p>",
        "id": 124469498,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538400
    },
    {
        "content": "<p>Why is that a problem?</p>",
        "id": 124469550,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522538500
    },
    {
        "content": "<p>it's not very well-founded is it</p>",
        "id": 124469551,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538519
    },
    {
        "content": "<p>Isn't the \"big things built from smaller things\" idea supported by the hierarchy of universes?</p>",
        "id": 124469644,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522538732
    },
    {
        "content": "<p>well but one universe is already big enough</p>",
        "id": 124469683,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538780
    },
    {
        "content": "<p>philosophy aside, this construction is quite funny</p>",
        "id": 124469696,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538861
    },
    {
        "content": "<p>what do you think of my file? is it mathematically correct? should I PR it?</p>",
        "id": 124469737,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538886
    },
    {
        "content": "<p>I wonder why this construction isn't more well-known</p>",
        "id": 124469743,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522538970
    },
    {
        "content": "<p>I don't think I can make a judgement about your construction. Mario and Kevin probably should be the ones to comment</p>",
        "id": 124469796,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522539074
    },
    {
        "content": "<p>ok</p>",
        "id": 124469797,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522539080
    },
    {
        "content": "<p>Or Johannes</p>",
        "id": 124469798,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522539084
    },
    {
        "content": "<p>It looks like a cool construction :)</p>",
        "id": 124469800,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522539110
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> <a href=\"https://github.com/kckennylau/Lean/commit/c6eac863b23d58d40deaab62489f6069f860407e#diff-fdee7d198ee1f7316cba5649313e084a\" target=\"_blank\" title=\"https://github.com/kckennylau/Lean/commit/c6eac863b23d58d40deaab62489f6069f860407e#diff-fdee7d198ee1f7316cba5649313e084a\">https://github.com/kckennylau/Lean/commit/c6eac863b23d58d40deaab62489f6069f860407e#diff-fdee7d198ee1f7316cba5649313e084a</a></p>",
        "id": 124470041,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522539696
    },
    {
        "content": "<p>rip universe limitation</p>",
        "id": 124470042,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522539699
    },
    {
        "content": "<p>now it can be in any universe</p>",
        "id": 124470043,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522539704
    },
    {
        "content": "<p>Yeah, that's universe polymorphism for you ;-)</p>",
        "id": 124470084,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522539774
    },
    {
        "content": "<p>I wonder if <code>free_group.{u v} S</code> and <code>free_group.{u w} S</code> are different</p>",
        "id": 124470096,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522539811
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> this is such a convenient construction</p>",
        "id": 124470183,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522539984
    },
    {
        "content": "<p>basically constructing an object from its UMP</p>",
        "id": 124470185,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522539996
    },
    {
        "content": "<p>I can probably construct the abelianization this way also</p>",
        "id": 124470187,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522540009
    },
    {
        "content": "<p>That looks like the free objects I've worked with before. I remember being blown away by how cool they are :D</p>",
        "id": 124470229,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522540084
    },
    {
        "content": "<p>you've seen this construction before?</p>",
        "id": 124470232,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522540105
    },
    {
        "content": "<p>I've seen it in free monads mostly</p>",
        "id": 124470238,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522540156
    },
    {
        "content": "<p>do you have any idea how I can fix the file to remove the need for manual typeclassing?</p>",
        "id": 124470283,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522540211
    },
    {
        "content": "<p>group to monoid, monoid to semigroup, semigroup to has_mul...</p>",
        "id": 124470285,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522540229
    },
    {
        "content": "<p>What happens when you replace it with an underscore?</p>",
        "id": 124470335,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522540366
    },
    {
        "content": "<p>can't synthesize that thing</p>",
        "id": 124470337,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522540379
    },
    {
        "content": "<p>Right but what instances are in your context?</p>",
        "id": 124470383,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522540465
    },
    {
        "content": "<p>the thing is that the instances aren't declared to the left of the colon</p>",
        "id": 124470384,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522540486
    },
    {
        "content": "<p>rather, they're introduced as variables</p>",
        "id": 124470385,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522540490
    },
    {
        "content": "<p>because of how I defined ambient</p>",
        "id": 124470392,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522540518
    },
    {
        "content": "<p>Right, so you can write:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">G</span> <span class=\"n\">HG</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">resetI</span> <span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">has_mul</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">...</span>\n</pre></div>",
        "id": 124470433,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522540593
    },
    {
        "content": "<p>I thought definitions shouldn't have any tactics</p>",
        "id": 124470434,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522540611
    },
    {
        "content": "<p>because they're difficult to destruct</p>",
        "id": 124470435,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522540622
    },
    {
        "content": "<p>This tactic won't create a complicated term. But it's also useful to just try it and see if it works. Otherwise, you can also use a separate <code>def</code></p>",
        "id": 124470476,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522540684
    },
    {
        "content": "<p>hmm...</p>",
        "id": 124470479,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522540695
    },
    {
        "content": "<p>free functors on steroids</p>",
        "id": 124470578,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522540986
    },
    {
        "content": "<p><a href=\"https://github.com/kckennylau/Lean/blob/master/abelianization.lean\" target=\"_blank\" title=\"https://github.com/kckennylau/Lean/blob/master/abelianization.lean\">https://github.com/kckennylau/Lean/blob/master/abelianization.lean</a></p>",
        "id": 124470859,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522541731
    },
    {
        "content": "<p>comes with commutators for free!</p>",
        "id": 124470860,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522541739
    },
    {
        "content": "<p>I'm familiar with this construction, which is sometimes used as an application of category theory: use the adjoint functor theorem to construct free groups. When you unwind the category theory it's exactly this construction: taking a suitable quotient over all groups</p>",
        "id": 124472206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522545233
    },
    {
        "content": "<p>The universe issues that arise in ZFC also arise in lean, because they are valid concerns and can cause inconsistency if they are not attended to. In lean this expresses as a bumping up of the universe level of the constructed free group</p>",
        "id": 124472250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522545303
    },
    {
        "content": "<p>To prove that the universe doesn't need to increase, you need a size limitation which amounts to doing the standard (internal) free group construction anyway. This is why I'm not a big fan of this approach - it's just shuffling proof obligations around</p>",
        "id": 124472296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522545365
    },
    {
        "content": "<p>When you write the UMP predicatively, it ends up weaker than people want (and use), because the free group you've constructed lives in <code>max u (v+1)</code> but is only universal wrt groups in <code>Type v</code>, which is strictly lower. In particular, the free group UMP doesn't apply to itself, which we want to be true for it to really be a free group. Otherwise it's only an approximation - if you try proving equivalence to the standard internal definition you will get stuck</p>",
        "id": 124472356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522545602
    },
    {
        "content": "<p>Re: making the isomorphism class a group, it is impossible to do this computably for some reasonable definitions of the problem. Suppose we want to take a quotient of all groups (in some universe) with respect to isomorphism. First of all, note that a quotient is with respect to a relation, meaning a Prop, meaning data about the isomorphism itself will be lost. We can define such a quotient, let's call it <code>Q</code>. Now each element <code>q : Q</code> somehow \"represents\" a group unique up to isomorphism, but I claim that there is no computable function <code>rep : Q -&gt; Group</code> such that <code>G ~= rep (mk G)</code> for all groups <code>G</code>.</p>\n<p>Now one way to define such a function is by applying choice as you've done to just pick one of the groups in the class, but maybe you thought there might be a way of using all the groups at once to form a new group which is isomorphic to each of the groups in the equivalence class. Supposing this is possible, and supposing also that you computably have the isomorphism <code>f G : G ~= rep (mk G)</code>, i.e. that's not just an existence statement, then you have <code>choice</code> for group isomorphisms, since if <code>nonempty (G ~= H)</code> then <code>mk G = mk H</code> and hence you can construct <code>G ~= rep (mk G) = rep (mk H) ~= H</code>.</p>\n<p>To turn this into at least unique choice, we can construct a group <code>H</code> which is isomorphic to <code>G = C_2</code> iff <code>α</code> is nonempty. For example, <code>H := Σ g : G, g ≠ 0 → trunc α</code> will do the trick. Then given an isomorphism <code>f : G ~= H</code>, we have <code>f 1 : psum (trunc α) (1 = 0)</code> from which we obtain an element of <code>trunc α</code>. This is not as strong as full choice, but it is known unprovable in lean.</p>",
        "id": 124473230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522547820
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> so what should I do? I'm confused, you keep saying it's unprovable but you're giving an algorithm</p>",
        "id": 124476618,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522556399
    },
    {
        "content": "<p>I'm showing that if you could construct it you could prove something that is known unprovable</p>",
        "id": 124476658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522556442
    },
    {
        "content": "<p>thus it's not computable</p>",
        "id": 124476659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522556451
    },
    {
        "content": "<p>ok, then what should I do?</p>",
        "id": 124476664,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522556486
    },
    {
        "content": "<p>Live with the fact that going from an isomorphism class to a specific group is nonconstructive?</p>",
        "id": 124476675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522556516
    },
    {
        "content": "<p>oh well, but I didn't use isomorphism class in the end</p>",
        "id": 124476715,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522556540
    },
    {
        "content": "<p>maybe you can phrase it independently of the choice then?</p>",
        "id": 124476721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522556586
    },
    {
        "content": "<p>phrase what?</p>",
        "id": 124476722,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522556606
    },
    {
        "content": "<p>your theorem, whatever it is</p>",
        "id": 124476723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522556624
    },
    {
        "content": "<p>that free group exists?</p>",
        "id": 124476724,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522556638
    },
    {
        "content": "<p>I'm not sure what you are trying to do now...</p>",
        "id": 124476762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522556644
    },
    {
        "content": "<p>I realized that using isomorphism class is because of some stupid limitation of ZFC</p>",
        "id": 124476765,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522556653
    },
    {
        "content": "<p>it's a limitation of lean too, I say</p>",
        "id": 124476766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522556664
    },
    {
        "content": "<p>I just stopped using it</p>",
        "id": 124476767,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522556667
    },
    {
        "content": "<p>and then I constructed the free group and proved its property</p>",
        "id": 124476768,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522556678
    },
    {
        "content": "<p>did you though?</p>",
        "id": 124476769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522556688
    },
    {
        "content": "<p>watch your universe levels</p>",
        "id": 124476770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522556697
    },
    {
        "content": "<p>I'm claiming you didn't construct the real free group</p>",
        "id": 124476777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522556713
    },
    {
        "content": "<p>I'm starting to suspect so</p>",
        "id": 124476778,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522556722
    },
    {
        "content": "<p>Have you ever heard of system F encodings or church encodings?</p>",
        "id": 124476818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522556781
    },
    {
        "content": "<p>I've heard of church encodings, if you're referring to the numbers</p>",
        "id": 124476824,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522556836
    },
    {
        "content": "<p>I'm talking about the types. Something like this:</p>\n<div class=\"codehilite\"><pre><span></span>def unit := ∀ X : Type, X → X\ndef nat := ∀ X : Type, X → (X → X) → X\ndef prod (α β) := ∀ X : Type, (α → β → X) → X\n</pre></div>",
        "id": 124476865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522556930
    },
    {
        "content": "<p>oh</p>",
        "id": 124476870,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522556953
    },
    {
        "content": "<p>I get it, go on</p>",
        "id": 124476871,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522556958
    },
    {
        "content": "<p>This sort of thing works great in system F, where there is only one impredicative data type <code>Type</code>, because then <code>unit : Type</code> etc and this has the expected universal property</p>",
        "id": 124476912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522557016
    },
    {
        "content": "<p>But in lean, it's not as strong as you want because the elimination property only goes to <code>Type 0</code> in this case while the constructed type lives in <code>Type 1</code></p>",
        "id": 124476915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522557057
    },
    {
        "content": "<p>Note that real eliminators such as are generated by <code>inductive</code> eliminate to <code>Sort u</code> where <code>u</code> is independent of the universes involved in the definition of the inductive type itself</p>",
        "id": 124476923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522557098
    },
    {
        "content": "<p>This allows creation of type families over the inductive type in very large universes</p>",
        "id": 124476924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522557122
    },
    {
        "content": "<p>fair enough</p>",
        "id": 124476963,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522557128
    },
    {
        "content": "<p>There is a curious property about these weak eliminators, though: <em>If</em> there exists a real type with the right eliminator, then you can prove that the weak type and the strong type are isomorphic, so the weak type inherits the strong eliminator</p>",
        "id": 124476968,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522557186
    },
    {
        "content": "<p>hence what you mean by moving proof obligations around</p>",
        "id": 124476969,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522557205
    },
    {
        "content": "<p>That means that your free group construction is correct if there is a free group</p>",
        "id": 124476970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522557213
    },
    {
        "content": "<p>and here am I thinking that it's a brand new construction that nobody knows :P</p>",
        "id": 124476971,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522557237
    },
    {
        "content": "<p>The size limitation thing is really important but manifests in weird ways in ZFC and lean</p>",
        "id": 124477010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522557280
    },
    {
        "content": "<p>I think it's also related to the \"B\" in BNF, bounded natural functors used in isabelle for generating arbitrary (co)inductive types</p>",
        "id": 124477057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522557398
    },
    {
        "content": "<p>which literally have an axiom on limitation of size, to prevent universe issues</p>",
        "id": 124477060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522557417
    },
    {
        "content": "<p><span class=\"emoji emoji-1f171\" title=\"b button\">:b_button:</span>ounded <span class=\"emoji emoji-1f171\" title=\"b button\">:b_button:</span>atural <span class=\"emoji emoji-1f171\" title=\"b button\">:b_button:</span>unctors</p>",
        "id": 124477066,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522557430
    },
    {
        "content": "<p>now I need to make a \"bounded natural blunders\" joke</p>",
        "id": 124477111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522557538
    },
    {
        "content": "<p>I'm thoroughly confused now</p>",
        "id": 124477264,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522557953
    },
    {
        "content": "<p>Well that's really annoying. I thought that type theory was getting around these silly ZFC universe problems</p>",
        "id": 124493878,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600016
    },
    {
        "content": "<p>but it's just moving them to Lean universe problems</p>",
        "id": 124493882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600026
    },
    {
        "content": "<p>same thought here</p>",
        "id": 124493885,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600033
    },
    {
        "content": "<p>Why do you care about isomorphic groups?</p>",
        "id": 124493886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600043
    },
    {
        "content": "<p>Why not just work with all groups?</p>",
        "id": 124493887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600049
    },
    {
        "content": "<p>right, I worked with all groups at the end</p>",
        "id": 124493888,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600057
    },
    {
        "content": "<p>I was following the paper, which used isomorphic groups</p>",
        "id": 124493889,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600066
    },
    {
        "content": "<p>my conjecture is that the author used isomorphism classes to make it justified in ZFC</p>",
        "id": 124493891,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600080
    },
    {
        "content": "<p>Similarly you don't need to work with \"generated by a subset of S\"</p>",
        "id": 124493928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600084
    },
    {
        "content": "<p>which i take to be a really shitty thing to do</p>",
        "id": 124493931,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600089
    },
    {
        "content": "<p>That just seemed to be a red herring</p>",
        "id": 124493932,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600095
    },
    {
        "content": "<p>right</p>",
        "id": 124493933,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600099
    },
    {
        "content": "<p>I didn't use that in my construction</p>",
        "id": 124493934,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600106
    },
    {
        "content": "<p>but then it still depends on the universe</p>",
        "id": 124493935,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600116
    },
    {
        "content": "<p>since you're quantifying over every group anyway</p>",
        "id": 124493936,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600122
    },
    {
        "content": "<p>that's the thing with impredicative constructions</p>",
        "id": 124493984,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600239
    },
    {
        "content": "<p>you can send the other elements of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> to the identity</p>",
        "id": 124493986,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600248
    },
    {
        "content": "<p>Oh I broke zulip</p>",
        "id": 124493987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600248
    },
    {
        "content": "<p>I can't edit $S$ into <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span></p>",
        "id": 124493988,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600248
    },
    {
        "content": "<p>you see, in ZFC this is the way you would do it:</p>",
        "id": 124494040,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600405
    },
    {
        "content": "<p>firstly you consider only the isomorphism classes</p>",
        "id": 124494042,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600414
    },
    {
        "content": "<p>Bingo, I had to reload the page.</p>",
        "id": 124494043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600425
    },
    {
        "content": "<p>and you only consider the groups generated by a subset of S</p>",
        "id": 124494044,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600426
    },
    {
        "content": "<p>because in some sense you can build it from S</p>",
        "id": 124494045,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600438
    },
    {
        "content": "<p>I don't see where the subset comes in</p>",
        "id": 124494082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600444
    },
    {
        "content": "<p>but I do see where the isomorphism classes come in</p>",
        "id": 124494085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600454
    },
    {
        "content": "<p>well</p>",
        "id": 124494087,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600480
    },
    {
        "content": "<p>they are both limitations on the size of the set</p>",
        "id": 124494088,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600488
    },
    {
        "content": "<p>after these two restrictions, you can justify the existence of the set by building it from a large enough set that you still build from S</p>",
        "id": 124494094,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600507
    },
    {
        "content": "<p>I don't see where they're needed in the ZFC proof.</p>",
        "id": 124494096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600514
    },
    {
        "content": "<p>if you don't limit the size of the generator, your set is still too big</p>",
        "id": 124494098,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600542
    },
    {
        "content": "<p>I want my generator to have size S</p>",
        "id": 124494099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600555
    },
    {
        "content": "<p>exactly</p>",
        "id": 124494100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600558
    },
    {
        "content": "<p>ah</p>",
        "id": 124494140,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600585
    },
    {
        "content": "<p>hmm</p>",
        "id": 124494141,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600586
    },
    {
        "content": "<p>that's what you meant</p>",
        "id": 124494142,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600601
    },
    {
        "content": "<p>I suppose it's ok then</p>",
        "id": 124494143,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600613
    },
    {
        "content": "<p>So in ZFC I start with S and then I choose some cardinal kappa such that in V_kappa there is a copy of every group generated by S</p>",
        "id": 124494144,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600618
    },
    {
        "content": "<p>Lean is better because in Lean I don't think you even need that S generates G</p>",
        "id": 124494151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600657
    },
    {
        "content": "<p>But as Mario points out, your answer is in the wrong universe.</p>",
        "id": 124494154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600667
    },
    {
        "content": "<p>I think you do need that S generates G if you don't want to run into universe problems</p>",
        "id": 124494204,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522600756
    },
    {
        "content": "<p>In ZFC you do, but I don't see where you need it in Lean.</p>",
        "id": 124494300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522600991
    },
    {
        "content": "<p>You just put a group structure on the product of G over all pairs (G,f:S -&gt; G)</p>",
        "id": 124494347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522601044
    },
    {
        "content": "<p>and give this a map from S</p>",
        "id": 124494353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522601103
    },
    {
        "content": "<p>and then take the intersection over all the subgroups containing the image of S</p>",
        "id": 124494354,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522601103
    },
    {
        "content": "<p>This should definitely be in <a class=\"stream\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths\">#maths</a></p>",
        "id": 124494362,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522601161
    }
]
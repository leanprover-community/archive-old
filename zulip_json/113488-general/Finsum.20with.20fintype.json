[
    {
        "content": "<p>It's great to see <code>finsum</code> in mathlib.  I asked this briefly before in the thread that led to the PR, but thought I would ask again now the dust has settled. It seems from discussion in <a href=\"#narrow/stream/144837-PR-reviews/topic/.236355.20finsum\">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.236355.20finsum</a> that many would like <code>finset.sum</code> +  <code>finset</code> to eventually take a back seat in mathlib to <code>finsum</code> + <code>set</code>. I'm certainly on board with this! </p>\n<p>If this is the case, then what is the intended pattern for working with a <code>finsum</code> and <code>set</code> in a <code>fintype</code>? It is not fun to have to explicitly pull finiteness parameters out of the <code>fintype</code> instance whenever an API lemma is invoked, like in the following example: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.finprod</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">finsum_mem_bUnion_of_fintype</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">ι</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">I.pairwise_on</span> <span class=\"o\">(</span><span class=\"n\">disjoint</span> <span class=\"n\">on</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑ᶠ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"bp\">⋃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">t</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span>\n<span class=\"bp\">=</span> <span class=\"bp\">∑ᶠ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n  <span class=\"n\">finsum_mem_bUnion</span> <span class=\"o\">(</span><span class=\"n\">set.finite.of_fintype</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">set.finite.of_fintype</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>An alternative is to use <code>rw finsum_mem_eq_to_finset_sum</code> to change the summations to <code>finset.sum</code>, and then use existing <code>finset.sum</code> and <code>to_finset</code> api lemmas to do the manipulations. In the case of the above theorem, this is even uglier, to the extent that I have left the following as a sorry. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">finsum_mem_bUnion_of_fintype'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">ι</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">I.pairwise_on</span> <span class=\"o\">(</span><span class=\"n\">disjoint</span> <span class=\"n\">on</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑ᶠ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"bp\">⋃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">t</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span>\n<span class=\"bp\">=</span> <span class=\"bp\">∑ᶠ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">finsum_mem_eq_to_finset_sum</span><span class=\"o\">},</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">⊢  ∑ (i : α) in (⋃ (x : ι) (H : x ∈ I), t x).to_finset, f i</span>\n<span class=\"cm\">=   ∑ (i : ι) in I.to_finset, ∑ᶠ (j : α) (H : j ∈ t i), f j</span>\n<span class=\"cm\">-/</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- to_finset, finset.sum API stuff.</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>One could argue that the first solution is not so bad, but it gets pretty tiring when calculations get more complicated. </p>\n<p>The only other option I can think of is to have <code>fintype.finsum_eq_blahblahblah</code> versions of all the <code>finsum</code> api lemmas, probably all going in a <code>data.fintype.finsum</code> file. Would this be a good idea, despite the duplication? If not, is there another way of doing things that I'm missing? (Let's take it for granted that <code>finset</code> isn't the answer I want...)</p>",
        "id": 234263169,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1618284702
    },
    {
        "content": "<p>If we want <code>finsum</code> to become the main API, then we'll need to do a massive refactor. But it can probably be done gradually.<br>\nIf it's done gradually, I think it is very important that there is a very good API to move back and forth between <code>finset.sum</code> and <code>finsum</code>. If that is almost effortless, then we can have the two coexist for a while.</p>",
        "id": 234269555,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618290727
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsum_mem_bUnion\">docs#finsum_mem_bUnion</a> as a link for the lazy to the lemma in the example</p>",
        "id": 234273065,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618293932
    },
    {
        "content": "<p>It's not immediately clear to me that those assumptions are necessary - if those arguments were not finite, wouldn't both sides still be equal?</p>",
        "id": 234273419,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618294257
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Suppose <code>I = bool</code> and <code>t i = if i then nat else unit</code> and <code>f j = 1</code>. Then</p>\n<ul>\n<li><code>∑ᶠ (i : I) (j : t i), f j = ∑ᶠ (j : nat), 1 + ∑ᶠ (j : unit), 1 = 0 + 1 = 1</code>, but</li>\n<li><code>∑ᶠ (a : ⋃ (x : I), t x), f a = ∑ᶠ (a : nat + unit), 1 = 0</code></li>\n</ul>",
        "id": 234274409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618295082
    },
    {
        "content": "<p>Thanks, I see the general principle now - infinite sums can be decomposed into a finite and infinite part, and when that happens the lemmas don't hold</p>",
        "id": 234275825,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618296143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Finsum.20with.20fintype/near/234269555\">said</a>:</p>\n<blockquote>\n<p>If we want <code>finsum</code> to become the main API, then we'll need to do a massive refactor. But it can probably be done gradually.<br>\nIf it's done gradually, I think it is very important that there is a very good API to move back and forth between <code>finset.sum</code> and <code>finsum</code>. If that is almost effortless, then we can have the two coexist for a while.</p>\n</blockquote>\n<p>I agree it's important there's a good API to move between the two - but as Yury says in the linked thread, I don't believe we should eliminate <code>finset.sum</code> in favour of <code>finsum</code>: both approaches have their use cases.</p>",
        "id": 234343280,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1618326355
    },
    {
        "content": "<p>I agree that an API is important - however, I don't think it is the right way to manipulate <code>finsum</code> expressions in a <code>fintype</code>. Doing a calculation about <code>finsum</code> would involve first translating to <code>finset.sum</code>, then (in many cases) unpacking/repacking the resulting <code>to_finset</code> expression. From what I've experienced, using <code>set.to_finset</code> back and forth too liberally is what introduces instance mismatch issues. Maybe I'm not so great at this, but I think trying to fill in the <code>sorry</code> in the second example in my previous post will give some indication of how fiddly this is. </p>\n<p>So I'll re-ask my question - would it be justified to have specialized <code>fintype</code> versions of all the <code>finsum/finprod</code> API lemmas? As far as I can tell, using <code>finsum</code> when working with <code>set</code>s in a <code>fintype</code> is going to be quite annoying without such lemmas.</p>",
        "id": 234372062,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1618336409
    },
    {
        "content": "<p>Perhaps the compromise is to just put all the <code>finite</code> assumptions last in the argument lists?</p>",
        "id": 234373900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618337112
    },
    {
        "content": "<p>That way, you can rewrite by <code>finsum_mem_bUnion h</code>, and clean up at the end with <code>simp [set.finite.of_fintype] </code></p>",
        "id": 234373969,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618337140
    },
    {
        "content": "<p>We can also have a tactic that tries <code>set.finite.of_fintype</code> and some other heuristics (may be, as <code>simp [set.finite.of_fintype]</code>) and use <code>h : finite (mul_support f) . finite_tac</code>.</p>",
        "id": 234378027,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1618338742
    }
]
[
    {
        "content": "<p>Looking to level up my <code>rintro</code> skills.. Can I do with <code>rintro</code> what I can do with the equation compiler on pnat?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.pnat.basic</span>\n\n<span class=\"c1\">-- what I want to emulate</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">(⟨</span><span class=\"n\">n0</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n1</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩),</span>\n  <span class=\"c1\">-- was hoping for 2 goals N. Want to name `a_property` but can't? No sign of n or hn</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  a_property : 0 &lt; 0</span>\n<span class=\"cm\">  ⊢ true</span>\n\n<span class=\"cm\">  a_property : 0 &lt; 1</span>\n<span class=\"cm\">  ⊢ true</span>\n\n<span class=\"cm\">  a_property : 0 &lt; 2</span>\n<span class=\"cm\">  ⊢ true</span>\n\n<span class=\"cm\">  a_val: ℕ</span>\n<span class=\"cm\">  a_property: 0 &lt; a_val.succ.succ.succ</span>\n<span class=\"cm\">  ⊢ true</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">sorry</span><span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨(</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">hn</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"c1\">-- can I avoid cases after rintro?</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  hn : 0 &lt; 1</span>\n<span class=\"cm\">  ⊢ true</span>\n<span class=\"cm\">  n : ℕ</span>\n<span class=\"cm\">  hn : 0 &lt; n.succ.succ</span>\n<span class=\"cm\">  ⊢ true</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">sorry</span><span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 214368779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603488884
    },
    {
        "content": "<p>How does the equation compiler know to ignore the <code>⟨0, _⟩</code> case?</p>",
        "id": 214369932,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603489772
    },
    {
        "content": "<p>For example, lean complains about that case with this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>  <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 214370082,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603489880
    },
    {
        "content": "<p>Looks like the equation compiler has something special for props?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"c1\">-- lean is happy</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>  <span class=\"o\">:=</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"c1\">-- lean complains</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>  <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 214370740,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603490514
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> This is a limitation of the syntax of <code>rcases</code> patterns. Logically, case trees are trees; you split on one thing in the context and then in each of the resulting subgoals you can do different kinds of split. <code>rcases</code> patterns, however, are limited in that in <code>&lt;a | b, pat&gt;</code>, we are saying \"split the top level to get <code>l,r</code>, then split <code>l</code> to get two subgoals <code>a</code> and <code>b</code>, then split <code>r</code> with <code>pat</code> in subgoal 1, then split <code>r</code> with <code>pat</code> in subgoal 2\", and it is not possible to supply two different values for <code>pat</code> in the two subgoals. It's perfectly within the realm of possibility for rcases to handle this, indeed it would be simpler if it could, but it is a limitation of the tuples-and-alts style pattern syntax.</p>\n<p>The equation compiler uses a different syntax, where you instead describe all the subgoals, and all the splits that are needed to get to each of them (possibly containing a lot of redundant splits), and the computer then has to put them back together into a case tree. This is also a bit ambiguous, and you have seen the equation compiler sometimes generate spurious case splits because it reconstructed the wrong case tree. But by writing the patterns many times, you have the opportunity to make the patterns different in each case.</p>\n<p>To get a true case tree, you need to use nested cases as in <code>cases a with b c, {cases b with d e}, {cases c, {cases c}, {cases c}}</code>. <code>rcases</code> can remove most of the need to have this, but due to the aforementioned limitation of tuples-and-alts patterns, you may sometimes need to have more than one <code>rcases</code> invocation as well. In short, my recommendation is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span> <span class=\"bp\">→</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨(</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">hn</span><span class=\"o\">⟩,</span> <span class=\"o\">{</span><span class=\"n\">cases</span> <span class=\"n\">hn</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 214405665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603508065
    },
    {
        "content": "<p>As a sketch of how one might extend the syntax to support the full range of case trees, we might use <code>[pat1, pat2, pat3]</code> to mean that this pattern will be invoked 3 times as a result of splits to the left of it, and in those 3 invocations it should use <code>pat1, pat2, pat3</code> respectively. With that, you could write this case split as <code>rintro ⟨(_ | _ | n), [⟨⟩, -, -]⟩</code>, but one thing I don't like about this is that it makes the patterns more contextual than structural, and I think it decreases readability as a result.</p>",
        "id": 214405880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603508425
    },
    {
        "content": "<p>Very interesting, thanks! I had not appreciated the difference between the two approaches before.</p>",
        "id": 214410439,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603516935
    }
]
[
    {
        "content": "<p>Is it just me, or do we have some quite glaring design flaws when it comes to well-founded relations?</p>",
        "id": 287644755,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656368272
    },
    {
        "content": "<p>It's a lot of things, really</p>",
        "id": 287644924,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656368383
    },
    {
        "content": "<p>First, the fact that <code>well_founded</code> isn't a typeclass is a bit of a minor annoyance</p>",
        "id": 287644975,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656368403
    },
    {
        "content": "<p>What really bothers me most is that we don't have a clear way of spelling out \"a type is well-ordered under <code>&lt;</code>\"</p>",
        "id": 287645025,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656368421
    },
    {
        "content": "<p>The obvious spelling is <code>linear_order α</code> + <code>well_founded (&lt;)</code>, but it turns out this isn't the most convenient spelling because the latter isn't a typeclass</p>",
        "id": 287645073,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656368464
    },
    {
        "content": "<p>A more convenient spelling is <code>linear_order α</code> + <code>is_well_order α (&lt;)</code>, which is certainly awkward but gives you all that cool typeclass functionality (though you usually still need to name the latter and call <code>h.wf</code>)</p>",
        "id": 287645151,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656368520
    },
    {
        "content": "<p>Except, if you know that <code>nonempty α</code>, what you <em>really</em> want is <code>conditionally_complete_linear_order_bot α</code>, which is not at all obvious</p>",
        "id": 287645468,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656368687
    },
    {
        "content": "<p>So what we've ended up with is a bunch of disjointed API using these three different spellings</p>",
        "id": 287645512,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656368726
    },
    {
        "content": "<p>Oh and also, we don't have any API on <code>preorder α</code> + <code>well_founded (&lt;)</code>, which means that a lot of lemmas that would naturally be stated in terms of <code>≤</code> are instead written in terms of the negation of a general relation</p>",
        "id": 287645789,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656368872
    },
    {
        "content": "<p>Here's my proposal: we make <code>well_founded</code> into a typeclass <code>is_well_founded</code>, but only use it sparingly, the same way we use typeclasses like <code>is_refl</code> or <code>is_trans</code></p>",
        "id": 287645960,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656368963
    },
    {
        "content": "<p>I'm not at all an expert in this sort of thing, but one flaw in your proposal is that <code>well_founded</code> is in core Lean, which means that Lean itself is using it to do stuff (e.g. make inductive types work? who knows, I guess someone here will), which means that changing it in any way might not be an option.</p>",
        "id": 287646178,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656369064
    },
    {
        "content": "<p>Isn't that exactly what <code>is_well_order</code> is?</p>",
        "id": 287646194,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656369074
    },
    {
        "content": "<p>Well-orders are linear well-founded orders</p>",
        "id": 287646221,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369093
    },
    {
        "content": "<p>Not the same thing</p>",
        "id": 287646226,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369096
    },
    {
        "content": "<p>Ah so you want to fill up that gap with another rel class? I think that makes sense, because bundling linearity is unexpected from mathlib's point of view (I know it very well and yet I got tricked just here and now once again).</p>",
        "id": 287646487,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656369216
    },
    {
        "content": "<p>Do we even want <code>is_well_order</code> (as opposed to just the well-foundedness rel class)? What is it used by?</p>",
        "id": 287646598,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656369265
    },
    {
        "content": "<p>I do think we want <code>is_well_order</code>, since it's used with generic relations here and there. But its uses with <code>&lt;</code> and <code>&gt;</code> should be put into new typeclasses instead.</p>",
        "id": 287646780,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369373
    },
    {
        "content": "<p>My question is whether we use the linearity that comes with it or not.</p>",
        "id": 287646955,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656369476
    },
    {
        "content": "<p>I believe we do</p>",
        "id": 287647022,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369501
    },
    {
        "content": "<p>Excluding those lemmas about <code>is_well_order _ (&lt;)</code>, the API for <code>is_well_order</code> seems to consist of only two kinds of things</p>",
        "id": 287647102,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369557
    },
    {
        "content": "<p>Typeclass lemmas of the sort you'd expect for one of the unbundled order relation classes, like <code>is_well_order α r → is_irrefl α r</code> and the like</p>",
        "id": 287647226,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369604
    },
    {
        "content": "<p>And some sporadic uses in the ordinal library</p>",
        "id": 287647249,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369618
    },
    {
        "content": "<p>Sporadic but important uses, like for instance <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordinal.type\">docs#ordinal.type</a></p>",
        "id": 287647292,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369652
    },
    {
        "content": "<p>I don't think this needs to be removed</p>",
        "id": 287647368,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369701
    },
    {
        "content": "<p>But yeah, my idea is to fill the gap with one or maybe two new order classes, one for <code>preorder α</code> with well-founded <code>&lt;</code>, and another for <code>linear_order α</code> with well-founded <code>&lt;</code></p>",
        "id": 287647496,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369763
    },
    {
        "content": "<p>Not very sure about the second one, since as mentioned previously, it's just <code>conditionally_complete_linear_order_bot</code> + empty types</p>",
        "id": 287647549,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369807
    },
    {
        "content": "<p>This sounds like a mixin's job. We do not want those in the main spine of the order hierarchy.</p>",
        "id": 287647563,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656369813
    },
    {
        "content": "<p><code>conditionally_complete_linear_order_bot</code> is weaker, consider <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo><mo>⊆</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">[0, \\infty) \\subseteq \\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0,1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></p>",
        "id": 287647665,
        "sender_full_name": "Reid Barton",
        "timestamp": 1656369849
    },
    {
        "content": "<p>Oh darn, you're right</p>",
        "id": 287647689,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369863
    },
    {
        "content": "<p>Rather,  a nonempty linear_order with well-founded <code>&lt;</code> is equivalent to a <code>conditionally_complete_linear_order_bot</code> with well-founded <code>&lt;</code></p>",
        "id": 287647829,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656369950
    },
    {
        "content": "<p>Also, since <code>well_founded</code> is on core, we might want to keep it around, but prefer using a new <code>is_well_founded</code> typeclass</p>",
        "id": 287648108,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656370086
    },
    {
        "content": "<p>Kind of how we have the <code>reflexive</code> predicate but prefer using <code>is_refl</code> for the typeclass inference</p>",
        "id": 287648159,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656370121
    },
    {
        "content": "<p>Or actually I don't know, what's our opinion on the unbundled typeclasses?</p>",
        "id": 287648634,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656370423
    },
    {
        "content": "<p>I like them, but I also hear they were part of an abandoned refactor, so maybe I shouldn't be using them?</p>",
        "id": 287648702,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656370447
    },
    {
        "content": "<p>It might be worth looking at what Lean4 does here, if it does anything</p>",
        "id": 287649737,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656371084
    },
    {
        "content": "<p>I think an <code>is_well_founded</code> rel class is the way to go. That's whay I did for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_directed\">docs#is_directed</a>.</p>",
        "id": 287649925,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656371200
    },
    {
        "content": "<p>By the way, part of my reason for mentioning this is my annoyance with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/well_founded.succ\">docs#well_founded.succ</a></p>",
        "id": 287660885,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656380414
    },
    {
        "content": "<p>I don't think we should have that definition in its current form</p>",
        "id": 287660895,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656380436
    },
    {
        "content": "<p>As the docstring states, it just gives \"some\" successor, instead of <em>the</em> successor as you really want in almost all cases</p>",
        "id": 287660930,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656380485
    },
    {
        "content": "<p>I've started working on the idea of both an <code>is_well_founded</code> class and a <code>well_founded_lt</code> / <code>well_founded_gt</code> mixin. It's going great!</p>",
        "id": 287667131,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656387556
    },
    {
        "content": "<p>Many of the theorems in order/well_founded.lean now have much nicer spellings</p>",
        "id": 287667143,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656387583
    },
    {
        "content": "<p>Also, I only now realized that <code>is_well_order</code> has a redundant field <span aria-label=\"fear\" class=\"emoji emoji-1f628\" role=\"img\" title=\"fear\">:fear:</span></p>",
        "id": 287667218,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656387619
    },
    {
        "content": "<p><code>is_well_founded</code> implies <code>is_irrefl</code>, as I proved surprisingly recently</p>",
        "id": 287667226,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656387634
    },
    {
        "content": "<p>Speaking of redundant fields, what's the deal with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_strict_total_order'\">docs#is_strict_total_order'</a>? I know that we don't like to touch core much, but surely one could just remove the redundant field from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_strict_total_order\">docs#is_strict_total_order</a> and PR that?</p>",
        "id": 287667242,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656387679
    },
    {
        "content": "<p>Another question, do we not have a predicate for a <em>minimal</em> element of a set? Not a least one, nor a lower bound</p>",
        "id": 287667453,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656387954
    },
    {
        "content": "<p>I made a PR at <a href=\"https://github.com/leanprover-community/mathlib/pull/15023\">#15023</a>, but I'm very far from done</p>",
        "id": 287671472,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656392949
    },
    {
        "content": "<p>Doing this as a mixin was definitely the right approach</p>",
        "id": 287671996,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656393591
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">well_founded_lt</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">is_well_founded</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>Why do you need <code>extend</code>? Are there any precedents? What's wrong about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">well_founded_lt</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">is_well_founded</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>?</p>",
        "id": 287675677,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1656397802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/well-founded.20lt/near/287667453\">said</a>:</p>\n<blockquote>\n<p>Another question, do we not have a predicate for a <em>minimal</em> element of a set? Not a least one, nor a lower bound</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/minimals\">docs#minimals</a></p>",
        "id": 287689235,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656407471
    },
    {
        "content": "<p>I'm really only using extend because of the convenience of having <code>is_well_founded a (lt)</code> automatically inferred</p>",
        "id": 287712040,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656421260
    },
    {
        "content": "<p>Also, I think <code>minimals</code> is not quite what I want, that seems to assume a reflexive relation when  I'm really working with an irreflexive one</p>",
        "id": 287712303,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656421372
    },
    {
        "content": "<p>I know it should be changed to <code>{a ∈ s | ∀ ⦃b : α⦄, b ∈ s → r b a → r a b}</code>, but apart from that I don't see what you mean.</p>",
        "id": 287712487,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656421445
    },
    {
        "content": "<p>Maybe I'm just confused</p>",
        "id": 287712609,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656421520
    },
    {
        "content": "<p>I'm trying to figure out how to spell <a href=\"https://leanprover-community.github.io/mathlib_docs/find/well_founded.has_min\">docs#well_founded.has_min</a> without writing down all the bare predicates</p>",
        "id": 287712647,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656421545
    },
    {
        "content": "<p>I think it would be equivalent but not def-eq to <code>nonempty (minimals r s)</code>, since <code>r</code> here is asymmetric</p>",
        "id": 287712772,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656421599
    },
    {
        "content": "<p>Assuming that change you mention</p>",
        "id": 287712801,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656421618
    },
    {
        "content": "<p>You want <code>{a ∈ s | ∀ ⦃b : α⦄, b ∈ s → r b a → false}</code> right?<br>\nFor irreflexive <code>r</code>, <code>r b a → false</code> is equivalent to <code>r b a → a = b</code>, and if <code>r</code> is moreover transitive or well-founded, it's also equivalent to <code>r a b → r b a</code>.</p>",
        "id": 287719332,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1656424634
    },
    {
        "content": "<p>Oh yeah, you're right</p>",
        "id": 287727314,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656428092
    },
    {
        "content": "<p>I just realized three things</p>",
        "id": 287747388,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656436336
    },
    {
        "content": "<p>1) every well founded relation has an ordinal-valued height function <br>\n2) this coincides with <code>typein</code> in the well-ordered case<br>\n3) this coincides with the <code>birthday</code> function on <code>pgame</code></p>",
        "id": 287747514,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656436408
    },
    {
        "content": "<p>So that's another cool refactor we could do, eventually</p>",
        "id": 287747623,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656436444
    },
    {
        "content": "<p>Oh and also, this is in simple correspondence with <code>grade</code> on a <code>grade_order</code></p>",
        "id": 287747829,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656436548
    },
    {
        "content": "<p>By the way, do we have that a <code>grade_order</code> graded by a well-founded type is well-founded?</p>",
        "id": 287748028,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656436628
    },
    {
        "content": "<p>Nope. Should be easy however.</p>",
        "id": 287750355,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656437646
    },
    {
        "content": "<p>Don't do it yet though, or I'll have to modify whatever you write in the refactor :P</p>",
        "id": 287752218,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656438608
    },
    {
        "content": "<p>Violeta, I've nothing to say other than I think you're right that there's some grognuts with how we currently do this and you're doing the good work by addressing them. I've run into them a few times. (Also, yes, surprisingly hard to say things like \"this is a minimal element of this set\" and suchlike.)</p>",
        "id": 287792861,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656461285
    },
    {
        "content": "<p>Oh, speaking of that, it's a bit weird how we have the minimum of a set, but in practice, almost always refer to the minimum of a whole type</p>",
        "id": 287794182,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656462752
    },
    {
        "content": "<p>This leads to <code>mem_univ</code> awkwardness</p>",
        "id": 287794186,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656462758
    },
    {
        "content": "<p>I left a to-do to remedy that in a followup refactor</p>",
        "id": 287794199,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656462773
    },
    {
        "content": "<p>I've noticed that <code>is_well_founded</code> isn't quite like the other unbundled classes</p>",
        "id": 287807625,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656478698
    },
    {
        "content": "<p>Because you can prove much more elaborate theorems on well foundedness that you can on say, irreflexibility</p>",
        "id": 287807639,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656478721
    },
    {
        "content": "<p>So I'm wondering what our policy on the <code>well_founded</code> predicate should be</p>",
        "id": 287807803,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656478910
    },
    {
        "content": "<p>I've tried doing what we do with the other unbundled classes, which is using the class for inferred arguments, and the predicate on non-instance theorems</p>",
        "id": 287807885,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656479002
    },
    {
        "content": "<p>And I've tried putting almost all of the theorems on the typeclass</p>",
        "id": 287807895,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656479038
    },
    {
        "content": "<p>But it turns out that we do sometimes need to talk about minimums of random well-ordered relations that can't easily made into instances</p>",
        "id": 287807939,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656479059
    },
    {
        "content": "<p>On one extreme I could just tank the <code>@</code> and state all the cool theorems in terms of <code>is_well_founded</code></p>",
        "id": 287807959,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656479130
    },
    {
        "content": "<p>On another extreme, I could duplicate the entire API on <code>is_well_founded</code> in terms of <code>well_founded</code></p>",
        "id": 287807998,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656479162
    },
    {
        "content": "<p>A middle ground solution I'm gravitating towards is having only the basic theorems, like <code>well_founded.has_min</code> and such, stated for general well founded orders, and having everything else use the typeclass</p>",
        "id": 287808039,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656479202
    },
    {
        "content": "<p>I'd like a second opinion here though</p>",
        "id": 287808063,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656479246
    },
    {
        "content": "<p>By the way, status update on the refactor: it's going quite well, a bunch of cool theorems on well founded orders can now be upgraded to instances, and pretty much the issue I've encountered is the aforementioned</p>",
        "id": 287808503,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656479796
    },
    {
        "content": "<p>No end in sight yet btw, I'm still editing quite basic files and we're at 800 lines of diff</p>",
        "id": 287808513,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656479824
    },
    {
        "content": "<p>Hey question, what's the difference between <code>well_founded.recursion</code> and <code>well_founded.fix</code>?</p>",
        "id": 287809393,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656481021
    },
    {
        "content": "<p>They have almost the same signature</p>",
        "id": 287809397,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656481027
    },
    {
        "content": "<p><code>well_founded.recursion</code> doesn't guarantee anything about its output as far as I can tell though</p>",
        "id": 287809408,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656481044
    },
    {
        "content": "<p>While of course there's <code>well_founded.fix_eq</code></p>",
        "id": 287809411,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656481049
    },
    {
        "content": "<blockquote>\n<p>I'm really only using extend because of the convenience of having is_well_founded a (lt) automatically inferred</p>\n</blockquote>\n<p>I asked whether there's precedent because I've only seen mathlib use <code>@[reducible] def</code> in such situation (e.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finite_dimensional/src\">src#finite_dimensional</a>) and never seen <code>extends</code> with a single class without adding any field.</p>",
        "id": 287811710,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1656483641
    },
    {
        "content": "<p>The problem with using extend like that is you have to duplicate all existing instances. With reducible def you're providing a nicer spelling that has access to all the same instances as the verbose spelling</p>",
        "id": 287816665,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656487906
    },
    {
        "content": "<p>What's up with this?</p>",
        "id": 287855887,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656510485
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/well_founded.eq_iff_not_lt_of_le\">docs#well_founded.eq_iff_not_lt_of_le</a></p>",
        "id": 287855894,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656510490
    },
    {
        "content": "<p>Obviously this should be moved, but where to?</p>",
        "id": 287855924,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656510505
    },
    {
        "content": "<p>Core?</p>",
        "id": 287865723,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656514206
    },
    {
        "content": "<p>I would be surprised if it didn't exist elsewhere in the library</p>",
        "id": 287865766,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656514221
    },
    {
        "content": "<p>I think it's hard to argue that anything should move to core unless it needs C++ support</p>",
        "id": 287866353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656514433
    },
    {
        "content": "<p>Do we have some file for very basic results on orders other than the one on core?</p>",
        "id": 287866562,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656514503
    },
    {
        "content": "<p>Preferably a really really early import</p>",
        "id": 287866592,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656514510
    },
    {
        "content": "<p>Or should I just leave that result awkwardly lying around in the well-founded file?</p>",
        "id": 287867297,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656514754
    },
    {
        "content": "<p>Or is there any way I can prove/use this result easily?</p>",
        "id": 287867372,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656514784
    },
    {
        "content": "<p><a href=\"https://tqft.net/mathlib/order/basic\">file#order/basic</a></p>",
        "id": 287868387,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656515121
    },
    {
        "content": "<p>Oh thanks</p>",
        "id": 287871880,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656516427
    },
    {
        "content": "<p>Actually I'm just going to restate the result</p>",
        "id": 287871897,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656516433
    },
    {
        "content": "<p>It's a bit dumb to have the conclusion be <code>m ≤ x → x = m</code> instead of just <code>¬ x &lt; m</code></p>",
        "id": 287871983,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656516469
    },
    {
        "content": "<p>I'm facing another slight annoyance. Ideally you'd want an instance <code>linear_order α</code> + <code>well_founded_lt α</code> → <code>is_well_order α (&lt;)</code>, but the latter implies <code>is_well_founded α (&lt;)</code> which implies <code>well_founded_lt α</code>, so this doesn't work.</p>",
        "id": 287901285,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656528955
    },
    {
        "content": "<p>I did declare this as a definition <code>well_founded_lt.is_well_order</code>though, so it's not a major setback</p>",
        "id": 287901424,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656528997
    },
    {
        "content": "<p>Just something to keep in mind</p>",
        "id": 287901461,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656529015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/well-founded.20lt/near/287646598\">said</a>:</p>\n<blockquote>\n<p>Do we even want <code>is_well_order</code> (as opposed to just the well-foundedness rel class)? What is it used by?</p>\n</blockquote>\n<p>On an unrelated note, after scouring the library throughout this refactor, I've seen that we do use <code>is_well_order</code> in its full strength. In fact, I've only found a few theorems that can be generalized to <code>is_well_founded</code>. That said, this class has still been really useful thanks to all the instances you get, on things like subrelations or inverse images.</p>",
        "id": 287902848,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656529524
    },
    {
        "content": "<p>Here's something fun</p>",
        "id": 287954477,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656545026
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.is_wf\">docs#set.is_wf</a> is def-eq to <code>well_founded_lt s</code></p>",
        "id": 287954501,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656545041
    },
    {
        "content": "<p>I've had to heavily modify this file as a result of this refactor anyways, should I just go ahead and ditch that predicate?</p>",
        "id": 287954589,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656545085
    },
    {
        "content": "<p>Actually, I'll just leave it as a <code>reducible</code> def for now, golf all the theorems, and leave a to-do note to kill that predicate in the future</p>",
        "id": 287954978,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656545353
    },
    {
        "content": "<p>Now here's a harder question</p>",
        "id": 287956219,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656546201
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.is_well_founded_on\">docs#set.is_well_founded_on</a> is def-eq to <code>is_well_founded_on s (subrel r s)</code></p>",
        "id": 287956252,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656546223
    },
    {
        "content": "<p>Does that mean I should treat it like a typeclass argument? It's moved around and rewritten a lot in proofs, so I don't know</p>",
        "id": 287956274,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656546241
    },
    {
        "content": "<p>And what aboud <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.partially_well_ordered_on\">docs#set.partially_well_ordered_on</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.is_pwo\">docs#set.is_pwo</a>? Those don't look typeclassy at all</p>",
        "id": 287956377,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656546315
    },
    {
        "content": "<p>If we are going to make <code>is_well_founded</code> into a typeclass, maybe we should do the same with <code>is_pwo</code>?</p>",
        "id": 287956544,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656546425
    },
    {
        "content": "<p>No, please don't. Why should they be typeclasses? They're statements about a term, not a type</p>",
        "id": 287956762,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1656546584
    },
    {
        "content": "<p>That's the thing, they don't need to be statements about a term</p>",
        "id": 287956839,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656546625
    },
    {
        "content": "<p>You can talk about partially well-ordered types just fine</p>",
        "id": 287956844,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656546634
    },
    {
        "content": "<p>Then, the current definition would just be the assertion that the subtype is partially well ordered</p>",
        "id": 287956864,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656546650
    },
    {
        "content": "<p>And golfing proofs to use some underlying implementation might make the proofs take fewer characters. But it makes the library much more brittle to later rework. Because if you change the implementation of the thing again, all your proofs break</p>",
        "id": 287956867,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1656546654
    },
    {
        "content": "<p>Please take a look at where is_pwo is used. It's used directly on sets, not on types or subtypes. It's what makes Hahn series work</p>",
        "id": 287956908,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1656546689
    },
    {
        "content": "<p>You're right, all current usage of <code>is_pwo</code> in mathlib involves a support set</p>",
        "id": 287957261,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656546957
    },
    {
        "content": "<p>What's to be done about <code>set.is_wf</code> and <code>set.is_well_founded_on</code> though? It's <code>set.is_wf</code> that makes me feel particularly uneasy</p>",
        "id": 287957320,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656546989
    },
    {
        "content": "<p>In any case, my refactor will redefine it as <code>well_founded_lt ↥s</code>, because that's what it is. The question is whether we should take the extra step and use it in typeclass inference as we do for <code>well_founded_lt</code>.</p>",
        "id": 287957557,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656547204
    },
    {
        "content": "<p>This feels like <code>fintype</code> vs <code>set.finite</code>, except this time there's no data involved!</p>",
        "id": 287957933,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656547458
    },
    {
        "content": "<p>What will be the benefit of relying on typeclass inference for discharging proof goals of set.is_wf?</p>",
        "id": 287957941,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1656547465
    },
    {
        "content": "<p>I can find out myself, I'll disable my typeclass experiment and see if anything becomes tangibly more convenient</p>",
        "id": 287958195,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656547673
    },
    {
        "content": "<p>It seems I very quickly found the answer: not a lot</p>",
        "id": 287958433,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656547863
    },
    {
        "content": "<p>I think the sequence of tactics, in terms of symbols written by a user, might become more convenient, as measured by the number of symbols. But it might be less convenient in terms of elaboration and proof construction time, because you're punting the proof obligation to the implicit tactic of typeclass inference. TC is in general weaker than explicit term construction (the most powerful in assisting elaboration, but often the least user-convenient) or just a user-invoked tactic (that isn't apply_instance).</p>",
        "id": 287958439,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1656547868
    },
    {
        "content": "<p>You do sometimes want some of the instances <code>well_founded_on</code> and <code>is_wf</code> are equivalent to, but that can be dealt to with a single auxiliary lemma and <code>haveI</code></p>",
        "id": 287958477,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656547914
    },
    {
        "content": "<p>For instance here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_well_founded_on.induction</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.is_well_founded_on</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">z</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">Q</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">h.is_well_founded</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">is_well_founded.induction</span> <span class=\"o\">(</span><span class=\"n\">subrel</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">ys</span><span class=\"o\">⟩</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hP</span> <span class=\"n\">_</span> <span class=\"n\">ys</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">z</span> <span class=\"n\">zs</span> <span class=\"n\">zy</span><span class=\"o\">,</span> <span class=\"n\">ih</span> <span class=\"o\">⟨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">zs</span><span class=\"o\">⟩</span> <span class=\"n\">zy</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p><code>is_well_founded_on.is_well_founded</code> is actually just <code>id</code></p>",
        "id": 287958607,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656548035
    },
    {
        "content": "<p>But that's pretty much the only spot where having this be typeclass searchable could have been remotely convenient</p>",
        "id": 287958678,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656548081
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 287958875,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1656548279
    },
    {
        "content": "<p>I think that if a part of the library relies in proofs with tactic bodies that utilize haveI, introI, repeatedly, there's some weird api bleedover. I'm not making a judgment call on the category theory portion of the library because I admittedly don't understand it. But for proof discovery, either by guessing a name, or knowing that one had to do introI or haveI to make the rest of the API work for some lemmas, it doesn't work so well with other tactics we have for discovery, like suggest, library_search, or relying on simp.</p>",
        "id": 287958982,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1656548379
    },
    {
        "content": "<p>This assertion of mine is from my experience working on constructing various partial orders on a fixed type, which relied on a lot of letI. I made the questionable choice of relying on separate explicitly specified instances instead of type synonyms.</p>",
        "id": 287958983,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1656548379
    },
    {
        "content": "<p>I've had to use <code>haveI</code> very little, actually</p>",
        "id": 287959112,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656548507
    },
    {
        "content": "<p>It seems like the lemmas that it's used for subsume other potential uses</p>",
        "id": 287959120,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656548522
    },
    {
        "content": "<p>Alright, I'm done refactoring that file. I think I've managed to use my new code advantageously without being destructive.</p>",
        "id": 287960251,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656549535
    },
    {
        "content": "<p>If someone could review it, that would be awesome: <a href=\"https://github.com/leanprover-community/mathlib/pull/15023/files#diff-885226e6f133825031006afbcd1e5b3cc826941500c61a4f21967571feaf9766\">https://github.com/leanprover-community/mathlib/pull/15023/files#diff-885226e6f133825031006afbcd1e5b3cc826941500c61a4f21967571feaf9766</a></p>",
        "id": 287960258,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656549544
    },
    {
        "content": "<p>Almost all other files on this refactor should be easier to review</p>",
        "id": 287960275,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656549569
    },
    {
        "content": "<p>The main purpose of <code>well_founded</code> is to support well-founded recursion. Often one will want different orderings on the same type for use in different definitions/proofs. For example, we could put a lot of different orders on <code>list nat</code>. The type class mechanism seems like it would just get in the way here (and type synonyms would be even worse).</p>",
        "id": 287964026,
        "sender_full_name": "Reid Barton",
        "timestamp": 1656553205
    },
    {
        "content": "<p>What's this in reference to?</p>",
        "id": 287966542,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656556052
    },
    {
        "content": "<p>The whole refactor?</p>",
        "id": 287966594,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656556088
    },
    {
        "content": "<p>It's true that there's many possible orderings on a given type, but we usually only care about a handful - that's the reason we have things like <code>has_lt</code> to begin with.</p>",
        "id": 287966632,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656556188
    },
    {
        "content": "<p>So I'm not sure how the type class mechanism would get in the way</p>",
        "id": 287966637,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656556200
    },
    {
        "content": "<p>The thing is, we already have tons of theorems and definitions for things that have a well founded <code>&lt;</code> or <code>&gt;</code> specifically. We already employ the typeclass system for this, though in an ineffective manner, since we have to apply theorems for general well founded relations, which we need to keep providing the proof of, and then convert them into theorems on preorders or partial orders or whatnot.</p>",
        "id": 287967207,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656556979
    },
    {
        "content": "<p>We definitely need predicates for well founded <code>&lt;</code> and well founded <code>&gt;</code>, that's clear to me by now. We use this all throughout mathlib, from finsets to ordinals to linear algebra to category theory. I can't see the problem with taking it one step further and making this inferrable by the typeclass system.</p>",
        "id": 287967298,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656557103
    },
    {
        "content": "<p>This is subjective, but I feel like my refactor has so far alleviated more problems than it's caused</p>",
        "id": 287968751,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656558889
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 287968757,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656558900
    },
    {
        "content": "<p>I do appreciate the opinions though</p>",
        "id": 287968758,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656558900
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 287968804,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656558961
    },
    {
        "content": "<p>It's just hard to work on 1500 lines of code for 3 days straight and not get attached, haha</p>",
        "id": 287968805,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656558961
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 287968806,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656558961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/well-founded.20lt/near/287645960\">said</a>:</p>\n<blockquote>\n<p>Here's my proposal: we make <code>well_founded</code> into a typeclass <code>is_well_founded</code>, but only use it sparingly, the same way we use typeclasses like <code>is_refl</code> or <code>is_trans</code></p>\n</blockquote>\n<p>This one I don't think is a good idea.</p>",
        "id": 288002652,
        "sender_full_name": "Reid Barton",
        "timestamp": 1656583111
    },
    {
        "content": "<p>If it's only about whether <code>(&lt;)</code> is well-founded then it's okay to use a type class, because <code>(&lt;)</code> is already associated to the type by a type class.</p>",
        "id": 288002700,
        "sender_full_name": "Reid Barton",
        "timestamp": 1656583142
    },
    {
        "content": "<p>I'm not sure what makes this different from the other unbundled typeclasses</p>",
        "id": 288007688,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656585767
    },
    {
        "content": "<p>Or more specifically, the <code>is_well_order</code> typeclass</p>",
        "id": 288007723,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656585797
    },
    {
        "content": "<p>That one has a decent amount of use for relations other than <code>(&lt;)</code> and <code>(&gt;)</code>, this wouldn't be any different</p>",
        "id": 288007756,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656585817
    },
    {
        "content": "<p>I should probably mention</p>",
        "id": 288116141,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656646796
    },
    {
        "content": "<p>I've been working into splitting off the largest parts of this refactor into different files</p>",
        "id": 288116185,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656646809
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/15069\">#15069</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/15071\">#15071</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/15073\">#15073</a></p>",
        "id": 288116209,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656646829
    },
    {
        "content": "<p>And also <a href=\"https://github.com/leanprover-community/mathlib/pull/14707\">#14707</a> I guess</p>",
        "id": 288116217,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656646849
    },
    {
        "content": "<p>Would be super cool if someone could check those out</p>",
        "id": 288116219,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656646860
    },
    {
        "content": "<p>My refactor builds!!!!!!!!!</p>",
        "id": 288278952,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656780155
    },
    {
        "content": "<p>Almost, some IMO file broke lol</p>",
        "id": 288279430,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656780879
    },
    {
        "content": "<p>Final diff clocks in at 2k lines <span aria-label=\"skull\" class=\"emoji emoji-1f480\" role=\"img\" title=\"skull\">:skull:</span></p>",
        "id": 288279462,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656780961
    },
    {
        "content": "<p>I'll attempt to make more offshoot PRs before this huge one</p>",
        "id": 288279502,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656780975
    },
    {
        "content": "<p>This looks like a bit much for just introducing an <code>is_well_founded</code> typeclass. Did you scope-creep?</p>",
        "id": 288279508,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656780996
    },
    {
        "content": "<p>Only in a few files that got their own PRs already</p>",
        "id": 288279580,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656781096
    },
    {
        "content": "<p>I didn't <em>just</em> introduce the typeclass, I ported the existing theorems on well-founded relations to use said typeclass</p>",
        "id": 288279591,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656781116
    },
    {
        "content": "<p>And I redefined a few other classes that were just specific cases of said typeclass</p>",
        "id": 288279667,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656781209
    },
    {
        "content": "<p>If you look at the diff you'll see it's mostly just changing <code>well_founded.min</code> to <code>is_well_founded.min</code> and such throughout almost 60 files</p>",
        "id": 288279672,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656781234
    },
    {
        "content": "<p>Just a few extra files that had some more drastic changes, and I'm working on documenting and assessing that</p>",
        "id": 288279675,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656781247
    },
    {
        "content": "<p>Yep, I just went through all my work, and save for the basic files on well-founded relations that I very heavily modified, the whole PR is just a bunch of renames and the occasional golf with the new API.</p>",
        "id": 288280907,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656782965
    },
    {
        "content": "<p>I think the diff will drop by like 500 lines or so when my other spinoff PRs are merged</p>",
        "id": 288281385,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656783643
    }
]
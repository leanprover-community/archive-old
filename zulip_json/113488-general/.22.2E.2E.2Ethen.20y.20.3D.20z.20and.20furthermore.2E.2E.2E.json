[
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">type mismatch at application</span>\n<span class=\"cm\">  A y = A z</span>\n<span class=\"cm\">term</span>\n<span class=\"cm\">  A z</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  set (K z)</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  set (K y)</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>\"If two valuations are equivalent then (a) their supports (<code>y</code> and <code>z</code>) are equal and furthermore (b) the balls (<code>A y</code> and <code>A z</code>) of radius 1 in the corresponding fields (<code>K y</code> and <code>K z</code>) constructed using their supports are equal too. \"</p>\n<p>We mathematicians know that because <code>y</code> and <code>z</code> are equal, then <code>K y</code> and <code>K z</code> are equal so it makes sense to ask whether the subsets <code>A y</code> and <code>A z</code> are equal. </p>\n<p>I have a feeling that this is going to look quite artificial in Lean. Of course the above attempt doesn't even typecheck.</p>",
        "id": 157925525,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709234
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">y</span> <span class=\"bp\">==</span> <span class=\"n\">A</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">heq</span><span class=\"bp\">.</span><span class=\"n\">rfl</span>\n</pre></div>",
        "id": 157925579,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1549709337
    },
    {
        "content": "<p>Oh heck.</p>",
        "id": 157925589,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709357
    },
    {
        "content": "<p>This smells bad.</p>",
        "id": 157925592,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709371
    },
    {
        "content": "<p>(if only the proof were so simple -- in my example A is not just a function of y (the support) but actually a function of the valuation whose support y is).</p>",
        "id": 157925646,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709420
    },
    {
        "content": "<p>Can we avoid the type dependency <code>K</code>?</p>",
        "id": 157925647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549709422
    },
    {
        "content": "<p>Yeah that's an interesting question.</p>",
        "id": 157925649,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709444
    },
    {
        "content": "<p>You're asking if there's some super-convoluted way of rewriting it.</p>",
        "id": 157925657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709469
    },
    {
        "content": "<p>he's asking for you to make sure you didn't use <code>induction</code> on a quotient</p>",
        "id": 157925660,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1549709492
    },
    {
        "content": "<p>yes, I think... you need to rethink what you mean by comparing elements of different fields</p>",
        "id": 157925661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549709507
    },
    {
        "content": "<p>They are unrelated fields in general. If P and Q are two prime ideals of a ring R then I want to compare a subset of Frac(R/P) with a subset of Frac(R/Q).</p>",
        "id": 157925706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709548
    },
    {
        "content": "<p>under the hypothesis that actually P = Q</p>",
        "id": 157925707,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709559
    },
    {
        "content": "<p>can you <code>subst</code> that equality?</p>",
        "id": 157925715,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1549709586
    },
    {
        "content": "<p>yes, but it probably won't end well</p>",
        "id": 157925717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549709612
    },
    {
        "content": "<p>depending on the context</p>",
        "id": 157925719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549709631
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>This is what I actually have.</p>",
        "id": 157925776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709719
    },
    {
        "content": "<p>For the bit that you just said, I would start building morphisms. Is <code>Frac(-)</code> is an operator on rings, or is <code>Frac(R/-)</code> the operator (on ideals)?</p>",
        "id": 157925778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549709723
    },
    {
        "content": "<p>Frac sends an integral domain to its field of fractions.</p>",
        "id": 157925780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709741
    },
    {
        "content": "<p>and what is the integral domain here?</p>",
        "id": 157925824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549709773
    },
    {
        "content": "<p>It's R / supp(v)</p>",
        "id": 157925825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709783
    },
    {
        "content": "<p>Okay, so is there a morphism builder for Frac? That is, if we have a ring hom R -&gt; S, does it yield a field hom Frac(R) -&gt; Frac(S)?</p>",
        "id": 157925844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549709856
    },
    {
        "content": "<p>Given a valuation v on a ring R, one can build (a) its support (<code>f v</code>), a prime ideal of R, (b) the field of fractions R / supp(f v) (<code>K (f v)</code>) and (c) the closed unit ball in this field -- a construction which depends on v again and not just f v.</p>",
        "id": 157925887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709886
    },
    {
        "content": "<blockquote>\n<p>Okay, so is there a morphism builder for Frac? That is, if we have a ring hom R -&gt; S, does it yield a field hom Frac(R) -&gt; Frac(S)?</p>\n</blockquote>\n<p>No, Frac is really badly behaved.</p>",
        "id": 157925889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709903
    },
    {
        "content": "<p>Frac(Z)=Q but Frac(Z/p) is Z/p</p>",
        "id": 157925891,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709916
    },
    {
        "content": "<p>Frac (R) is a localisation, so a quotient of the set R x (R \\ 0), and (R \\ 0) is not at all functorial</p>",
        "id": 157925903,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549709955
    },
    {
        "content": "<p>okay, so maybe this is the first example of a real transfer theorrem</p>",
        "id": 157925906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549709993
    },
    {
        "content": "<p>if R ~= S then Frac(R) ~= Frac(S)</p>",
        "id": 157925950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710008
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I think he's hinting you to use the Strickland approach</p>",
        "id": 157925951,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1549710009
    },
    {
        "content": "<p>I am happy to use the Strickland approach but I don't yet see how to do it. I would rather Strickland it than use <code>==</code>, which I know gave Chris real problems last summer</p>",
        "id": 157925955,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710043
    },
    {
        "content": "<p>and moreover this iso computes in the expected way on the generators</p>",
        "id": 157925964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710065
    },
    {
        "content": "<p>o_O Wedhorn moved from Paderborn and the canonical link to his adic spaces paper (\"highly preliminary, do not read\" so not on ArXiv) is broken :-/</p>",
        "id": 157926003,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710123
    },
    {
        "content": "<p>Actually, would it be enough to have R -&gt; S an injective ring hom? That should preserve R \\ 0</p>",
        "id": 157926015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710182
    },
    {
        "content": "<p><a href=\"http://wwwf.imperial.ac.uk/~buzzard/docs/AdicSpaces.pdf\" target=\"_blank\" title=\"http://wwwf.imperial.ac.uk/~buzzard/docs/AdicSpaces.pdf\">http://wwwf.imperial.ac.uk/~buzzard/docs/AdicSpaces.pdf</a> Proposition-Definition 1.27 part(ii) [see how mathematicians don't know the difference between Prop and Type? :-) ], page 8 of the pdf. I'm formalising the proof of (iii) -&gt; (ii). That's the context.</p>",
        "id": 157926073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710256
    },
    {
        "content": "<p>Indeed if R injects into S then Frac(R) injects into Frac(S).</p>",
        "id": 157926077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710270
    },
    {
        "content": "<p>But we have R/P and R/Q and there is no map in either direction in general.</p>",
        "id": 157926078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710283
    },
    {
        "content": "<p>e.g. if R=Z/6Z then for P=(2) and Q=(3) we get Frac(R/P)=R/P=Z/2Z and Frac(R/Q)=R/Q=Z/3Z</p>",
        "id": 157926090,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710310
    },
    {
        "content": "<p>I can see that it is possible to work around all this. It would be a shame if we had to go down the following route:</p>",
        "id": 157926096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710354
    },
    {
        "content": "<p>The closed unit ball in Frac(R/P) is a subset of Frac(R/P), whose pre-image in (R/P) x ((R/P) - 0) then lifts to a subset of R x (R - P). I can consider this as a subset of R x R.</p>",
        "id": 157926149,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710432
    },
    {
        "content": "<p>I am pretty sure that the claim in (ii) is that the two subsets of R x R coming from the two valuations are equal.</p>",
        "id": 157926153,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710458
    },
    {
        "content": "<p>One bit at a time. For the quotients, we have that if P &lt;= Q then there is an injective ring hom R/Q -&gt; R/P</p>",
        "id": 157926198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710489
    },
    {
        "content": "<blockquote>\n<p>Can we avoid the type dependency <code>K</code>?</p>\n</blockquote>\n<p>Yes. But mathematicians will sneer.</p>",
        "id": 157926202,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710507
    },
    {
        "content": "<blockquote>\n<p>One bit at a time. For the quotients, we have that if P &lt;= Q then there is an injective ring hom R/Q -&gt; R/P</p>\n</blockquote>\n<p>Yes.</p>",
        "id": 157926206,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710530
    },
    {
        "content": "<p>[Hey, I've only just noticed that I can start responding to a specific post of Mario's, think \"crap, I should say what I'm responding to just to make the thread clearer\", hit \"quote and reply\" on his original post, and it just dumps it above what I already wrote <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 157926217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710593
    },
    {
        "content": "<p>Now if v respects w in the sense we talked about before then supp(v) &lt;= supp(w)</p>",
        "id": 157926218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710594
    },
    {
        "content": "<p>OK</p>",
        "id": 157926281,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710614
    },
    {
        "content": "<p>I don't know where this is going</p>",
        "id": 157926283,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710633
    },
    {
        "content": "<p>so putting it all together we obtain a ring hom from Frac(R/supp(v)) to Frac(R/supp(w))</p>",
        "id": 157926285,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710649
    },
    {
        "content": "<p>sure</p>",
        "id": 157926286,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710655
    },
    {
        "content": "<p>and if v and w are equivalent then supp(v)=supp(w) and we have an equality</p>",
        "id": 157926296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710677
    },
    {
        "content": "<p>so in particular a morphism</p>",
        "id": 157926297,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710682
    },
    {
        "content": "<p>and that's just what you need here</p>",
        "id": 157926300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710709
    },
    {
        "content": "<p>sure.</p>",
        "id": 157926303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710721
    },
    {
        "content": "<p>Aah I see.</p>",
        "id": 157926349,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710737
    },
    {
        "content": "<p>I think you're saying that I need to construct a function which takes in two valuations v and w, plus a proof that they're equivalent, and constructs a map Frac(R/supp(v)) -&gt; Frac(R/supp(w))</p>",
        "id": 157926369,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710798
    },
    {
        "content": "<p>one thing you should NOT do is say \"v = w so R/supp(v) = R/supp(w)\", this is equality of types which is evil</p>",
        "id": 157926374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710814
    },
    {
        "content": "<p>It's only evil because of your weird foundations.</p>",
        "id": 157926379,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710837
    },
    {
        "content": "<p>yes</p>",
        "id": 157926380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710841
    },
    {
        "content": "<p>In ZFC they are equal</p>",
        "id": 157926419,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710845
    },
    {
        "content": "<p>yes</p>",
        "id": 157926422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710848
    },
    {
        "content": "<p>I see.</p>",
        "id": 157926423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710853
    },
    {
        "content": "<p>I feel for you</p>",
        "id": 157926424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710854
    },
    {
        "content": "<p>Ditto.</p>",
        "id": 157926425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710862
    },
    {
        "content": "<p>thanks.</p>",
        "id": 157926426,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710874
    },
    {
        "content": "<p>It's like the identity map <code>F(U) -&gt; F(id U)</code> all over again isn't it.</p>",
        "id": 157926435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710922
    },
    {
        "content": "<p>yep</p>",
        "id": 157926436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710926
    },
    {
        "content": "<p>also notice that I didn't just construct a function from the valuations to the map Frac(R/supp(v)) -&gt; Frac(R/supp(w)), I went through three intermediate functions</p>",
        "id": 157926439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710940
    },
    {
        "content": "<p>Mathematicians must use this concept all over the place.</p>",
        "id": 157926440,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549710955
    },
    {
        "content": "<p>these will be useful later and should probably go in mathlib</p>",
        "id": 157926442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549710961
    },
    {
        "content": "<p>I should tell you now that the word \"valuation\" is used in several different contexts in mathematics. In some sense the thing I'm formalising at the minute is the most general thing, it is taking values in some very general space 0 union [totally ordered group], because that's what the people doing adic spaces and perfectoid spaces need, but all the people doing p-adic analysis and rigid spaces and Berkovich spaces just need valuations taking values in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"double-struck\">R</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}_{\\geq0}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.934069em;vertical-align:-0.24517899999999998em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≥</span><span class=\"mord mathrm mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24517899999999998em;\"></span></span></span></span></span></span></span></span></p>",
        "id": 157926500,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549711077
    },
    {
        "content": "<p>and all this kerfuffle about arbitrary ordered groups will just be an annoyance to them.</p>",
        "id": 157926543,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549711097
    },
    {
        "content": "<p>They just want <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>=</mo><msub><mi mathvariant=\"double-struck\">R</mi><mrow><mo>&gt;</mo><mn>0</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\Gamma=\\mathbb{R}_{&gt;0}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.86626em;vertical-align:-0.17737em;\"></span><span class=\"base\"><span class=\"mord mathrm\">Γ</span><span class=\"mrel\">=</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">&gt;</span><span class=\"mord mathrm mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.17737em;\"></span></span></span></span></span></span></span></span> and that's it</p>",
        "id": 157926547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549711127
    },
    {
        "content": "<p>The stuff about valuations is probably more idiosyncratic to your development but the other two parts have to do with stuff already in mathlib</p>",
        "id": 157926548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549711134
    },
    {
        "content": "<p>Ha!</p>",
        "id": 157926555,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549711165
    },
    {
        "content": "<p>Ironically I have already proved that if v and w are equivalent then supp(v) is a subset of supp(w)</p>",
        "id": 157926556,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549711182
    },
    {
        "content": "<p>but I bet you can't guess why :-)</p>",
        "id": 157926557,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549711190
    },
    {
        "content": "<p>Surely it's the last theorem we talked about?</p>",
        "id": 157926602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549711206
    },
    {
        "content": "<p>But why did I do it already?</p>\n<p>It's because I initially wanted to prove supp(v) = supp(w), but I didn't know how to start the proof with \"it suffices to prove supp(v) is a subset of supp(w)\" :-)</p>",
        "id": 157926620,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549711240
    },
    {
        "content": "<p>I've never been very good at WLOG</p>",
        "id": 157926622,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549711252
    },
    {
        "content": "<p>so I proved the inclusion first and then just applied it twice :-)</p>",
        "id": 157926629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549711289
    },
    {
        "content": "<p>\"already\" = \"two days ago\"</p>",
        "id": 157926668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549711324
    },
    {
        "content": "<blockquote>\n<p>One bit at a time. For the quotients, we have that if P &lt;= Q then there is an injective ring hom R/Q -&gt; R/P</p>\n</blockquote>\n<p>This is not true. The map goes the other way, and is typically not injective. So we're back to wishing for a transfer tactic again.<br>\n(Take <code>R = ℤ</code>, <code>P = 0</code>, and <code>Q = (n)</code>.)</p>",
        "id": 158122063,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549982628
    },
    {
        "content": "<p>It is true that if P = Q then we have a map R/P -&gt; R/Q.</p>",
        "id": 158122319,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549982784
    },
    {
        "content": "<p>Isn't this all we need?</p>",
        "id": 158122323,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549982791
    },
    {
        "content": "<p>If v1 and v2 are equivalent then I can construct a map R/supp(v1) -&gt; R/supp(v2) because I showed that supp(v1)=supp(v2)</p>",
        "id": 158122363,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549982822
    },
    {
        "content": "<p>I can prove that this map is functorial (because it's the fricken' identity map)</p>",
        "id": 158122389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549982842
    },
    {
        "content": "<p>and now I get maps K(v1)-&gt;K(v2) if they're equivalent</p>",
        "id": 158122427,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549982874
    },
    {
        "content": "<p>and the theorem is that A(v1) gets mapped to A(v2)</p>",
        "id": 158122473,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549982884
    },
    {
        "content": "<p>This all sounded fine to me. You're right about injectivity, I can believe I made a slip, but it was Mario talking about injectivity, I was always thinking about the case where the supps were equal.</p>",
        "id": 158122519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549982935
    },
    {
        "content": "<p>Right... but this stresses the fact this we aren't using some universal properties. It is really <em>transfer</em>. And we're doing it by hand!!!</p>",
        "id": 158122626,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549983006
    },
    {
        "content": "<p>We're proving that if v1 and v2 are related then we get a map from F v1 to F v2. That sounds generally sensible.</p>",
        "id": 158122981,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549983272
    },
    {
        "content": "<p>That sounds like transfer.</p>",
        "id": 158123600,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549983713
    },
    {
        "content": "<p>I think you can still do what Mario was suggesting though, correcting the statements. I'm not really sure whether this counts as \"transfer\", but it's again one of those situations where you can generalize to a directed situation where there is (a small amount of) content.</p>",
        "id": 158125405,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549985009
    },
    {
        "content": "<p>Sure... but I guess that will almost always be the case.</p>",
        "id": 158125528,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549985102
    },
    {
        "content": "<p>For any ideals <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi><mo>⊂</mo><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">I \\subset J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mrel\">⊂</span><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span> there's a map <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>I</mi><mo>→</mo><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">R/I \\to R/J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span>. I'll call it <code>reduce I J</code>, omitting the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi><mo>⊂</mo><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">I \\subset J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mrel\">⊂</span><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span> hypothesis. It's the map with <code>reduce I J [[r]] = [[r]]</code>, and it's probably important for whatever Kevin was originally doing that it computes in this way, and isn't some silly application of <code>eq.rec</code> when <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi><mo>=</mo><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">I = J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span>.</p>",
        "id": 158125553,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549985121
    },
    {
        "content": "<p>Then you have <code>reduce I I = id</code>, <code>reduce J K \\o reduce I J = reduce I K</code>. So if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi><mo>=</mo><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">I = J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi><mo>⊂</mo><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">I \\subset J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mrel\">⊂</span><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>J</mi><mo>⊂</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">J \\subset I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span><span class=\"mrel\">⊂</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> and from these properties we learn that <code>reduce I J</code> and <code>reduce J I</code> are inverse isomorphisms.</p>",
        "id": 158125641,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549985172
    },
    {
        "content": "<blockquote>\n<p>Right... but this stresses the fact this we aren't using some universal properties. It is really transfer. And we're doing it by hand!!!</p>\n</blockquote>\n<p><code>transfer</code> would not save you any of this work. It assumes you've proven all these constructions preserve the appropriate isomorphisms, and they are an input to the algorithm</p>",
        "id": 158125831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549985369
    },
    {
        "content": "<p>But if the system is set up properly, then it could derive lots of these isom-preserving properties as they are being defined.</p>",
        "id": 158126067,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549985573
    },
    {
        "content": "<p>Well... the system already knows that if <code>I = J</code> then there's a map <code>R/I -&gt; R/J</code></p>",
        "id": 158126120,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549985623
    },
    {
        "content": "<p>it's called <code>eq.rec_on</code></p>",
        "id": 158126206,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549985673
    },
    {
        "content": "<blockquote>\n<p>But if the system is set up properly, then it could derive lots of these isom-preserving properties as they are being defined.</p>\n</blockquote>\n<p>AKA \"this is a basic theorem that should be proven immediately after the definition\"</p>",
        "id": 158126222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549985702
    },
    {
        "content": "<p>to which I agree</p>",
        "id": 158126246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549985718
    },
    {
        "content": "<p>The dreaded theorem is the one which turns a non-equality into an equality -- \"if v1 is equivalent to v2 then two things (the supports) are <em>equal</em>\". Apparently now all consequences of the fact that two things are equal now need to be written explicitly.</p>",
        "id": 158127890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549986964
    },
    {
        "content": "<p>That's not the problem. If the theorem you want was the end goal you could just <code>subst</code> and be done with it</p>",
        "id": 158127957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549987025
    },
    {
        "content": "<p>But you need this to be a <em>good</em> function, that computes well on known inputs</p>",
        "id": 158127988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549987047
    },
    {
        "content": "<p>like Reid said</p>",
        "id": 158128020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549987070
    },
    {
        "content": "<p>The problem is that I don't understand what \"computes\" means.</p>",
        "id": 158128121,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549987133
    },
    {
        "content": "<p>It's an alien concept to me :-)</p>",
        "id": 158128139,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549987149
    },
    {
        "content": "<p>I only care about proving theorems. Are you saying I need to understand this \"computes\" business anyway?</p>",
        "id": 158128186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549987189
    },
    {
        "content": "<p>In principle you don't need to, as long as you have ways to manually replace things by their definitions, apply beta reduction, etc. For example, I guess metamath has no analogue of computation (though it's rather different in other ways as well).</p>",
        "id": 158129011,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549987705
    },
    {
        "content": "<p>well maybe in situations involving more complicated dependent types you actually do need to</p>",
        "id": 158129257,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549987883
    },
    {
        "content": "<p>metamath has explicit beta reduction. You might think that's a downside, but it means that you don't really have to care about the definitions of things - definitions just have a bunch of equivalent formulations, or properties that follow, that are all exactly as good as any other</p>",
        "id": 158129280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549987899
    },
    {
        "content": "<p>or maybe just a terminology issue--\"computes well\" just means that something satisfies useful <em>definitional</em> equalities</p>",
        "id": 158129756,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549988241
    },
    {
        "content": "<p>For example, in this case we have a little triangle involving <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">R/I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">R/J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span> and it commutes. The maps from <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> are <code>[[ ]]</code> in lean. If you define the map <code>R/I -&gt; R/J</code> using <code>quotient.lift</code> (even when <code>I = J</code>!) then this triangle will commute definitionally. If you define it using <code>eq.rec_on (h : I = J)</code> then it won't commute definitionally unless <code>h</code> is <code>rfl</code>. You have to prove it as a propositional equality, using cases on <code>h</code>.</p>",
        "id": 158130177,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549988541
    },
    {
        "content": "<p>But metamath doesn't have perfectoid spaces...</p>",
        "id": 158130200,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549988569
    },
    {
        "content": "<p>no, because it doesn't have you. It does have the prime number theorem because it has me. We do what we are comfortable with and can wrap our heads around</p>",
        "id": 158131110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549989294
    },
    {
        "content": "<p>So why do I care about whether a proof is <code>rfl</code> or a propositional equality which I prove and give a name and rewrite with occasionally?</p>",
        "id": 158136822,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549993605
    },
    {
        "content": "<p>Mostly because it's annoying to prove those little theorems after you used <code>eq.rec</code> to construct the function. You can do it all by cases on an appropriate equality, but determining the things to generalize to make it work is often finicky</p>",
        "id": 158137596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549994170
    },
    {
        "content": "<p>Also when you want to use the equality, it's more convenient to use <code>rfl</code>--potentially a lot more convenient, because a single <code>rfl</code> could be the equivalent of applying a lot of lemmas</p>",
        "id": 158138211,
        "sender_full_name": "Reid Barton",
        "timestamp": 1549994654
    },
    {
        "content": "<p>So this is merely a matter of convenience?</p>",
        "id": 158382540,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550001578
    },
    {
        "content": "<blockquote>\n<p>For example, in this case we have a little triangle involving <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">R/I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">R/J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.09618em;\">J</span></span></span></span> and it commutes. The maps from <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.00773em;\">R</span></span></span></span> are <code>[[ ]]</code> in lean. If you define the map <code>R/I -&gt; R/J</code> using <code>quotient.lift</code> (even when <code>I = J</code>!) then this triangle will commute definitionally. If you define it using <code>eq.rec_on (h : I = J)</code> then it won't commute definitionally unless <code>h</code> is <code>rfl</code>. You have to prove it as a propositional equality, using cases on <code>h</code>.</p>\n</blockquote>\n<p>I don't understand how this can be true. I thought proof irrelevance would prevent the actual choice of <code>h</code>from changing anything in any way.</p>",
        "id": 158382951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550001834
    },
    {
        "content": "<p>PS I quoted Reid's post which had <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">maths</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">m</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\">t</span><span class=\"mord mathit\">h</span><span class=\"mord mathit\">s</span></span></span></span> in and the double <code>$$</code> became single <code>$</code>s which broke the maths mode.</p>",
        "id": 158383058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550001895
    },
    {
        "content": "<blockquote>\n<p>PS I quoted Reid's post which had $maths$ in and the double <code>$</code> became single `s which broke the maths mode.</p>\n</blockquote>\n<p>quoting my own post</p>",
        "id": 158383078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550001912
    },
    {
        "content": "<p>Right, more accurate would be \"unless <code>I</code> and <code>J</code> are definitionally equal\"</p>",
        "id": 158383087,
        "sender_full_name": "Reid Barton",
        "timestamp": 1550001919
    },
    {
        "content": "<p>Aah I see!</p>",
        "id": 158383097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550001928
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>PS I quoted Reid's post which had $maths$ in and the double <code> became single </code>s which broke the maths mode.</p>\n</blockquote>\n<p>quoting my own post</p>\n</blockquote>\n<p>quoting your post</p>",
        "id": 158383106,
        "sender_full_name": "Reid Barton",
        "timestamp": 1550001938
    },
    {
        "content": "<blockquote>\n<blockquote>\n<blockquote>\n<p>PS I quoted Reid's post which had $maths$ in and the double <code> became single </code>s which broke the maths mode.</p>\n</blockquote>\n<p>quoting my own post</p>\n</blockquote>\n<p>quoting your post</p>\n</blockquote>\n<p>quoting yours</p>",
        "id": 158383118,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550001949
    },
    {
        "content": "<p>I think the sequence has converged</p>",
        "id": 158383129,
        "sender_full_name": "Reid Barton",
        "timestamp": 1550001960
    }
]
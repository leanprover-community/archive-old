[
    {
        "content": "<p>hey, i've been studying the lean3 source code.<br>\nwhile i've been able to answer most of my questions so far, there are a few things, where asking the authors seems like the better idea:</p>\n<ul>\n<li>what's the rationale behind using <code>expr_local</code> for <em>uses</em> of locals? is it just the convenience of not having to look up the local in the local context to get its type and stuff like that, or is there a \"deeper\" reason?</li>\n<li>where is the kernel type checker invoked for definitions commands? or do you not do that for regular operation (and instead have some \"verify the stuff please\" action)?</li>\n</ul>",
        "id": 291607199,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659374788
    },
    {
        "content": "<p>For your second question, it should be <a href=\"https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/definition_cmds.cpp#L194\">https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/definition_cmds.cpp#L194</a> and you can see where it gets called in the definition commands. (I'm not the author.)</p>",
        "id": 291607548,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659374966
    },
    {
        "content": "<p>ah, indeed, thanks a lot!<br>\ni was searching for <code>type_checker tc(</code> cause that seemed to be a common pattern, but only found it in the <code>check</code> command.</p>",
        "id": 291608365,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659375324
    },
    {
        "content": "<p>another question related to the first one: <code>expr_var</code> doesn't seem to be used much at all. what's the rationale behind that?<br>\nactually, nvm. it's used in <code>instantiate_rev_locals</code> and <code>resolve_local_name_core</code>, which are called quite a bit.</p>",
        "id": 291610812,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659376505
    },
    {
        "content": "<p>That's the locally nameless approach. Most functions expect closed terms, so whenever you \"enter\" a binder you instantiate all the <code>var</code>s in it for local constants</p>",
        "id": 291611191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659376717
    },
    {
        "content": "<p>note that the actual type information in a <code>local_const</code> is not reliable, it's usually a dummy value</p>",
        "id": 291611298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659376773
    },
    {
        "content": "<p>I'm not sure what you mean by \"rationale behind using <code>expr_local</code> for <em>uses</em> of locals\". What else would you use it for?</p>",
        "id": 291611429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659376814
    },
    {
        "content": "<p>i see, so using <code>expr_local</code> is a kind of \"certification/invariant\" thing (&gt; Most functions expect closed terms)</p>",
        "id": 291611494,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659376847
    },
    {
        "content": "<p>in any case, in lean 4 <code>local_const</code> is now <code>.fvar (fvarId : Name) : Expr</code>, so it seems it was agreed that all the other stuff in the local const is dead weight</p>",
        "id": 291611621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659376917
    },
    {
        "content": "<p>it's now solely a pointer into the <code>LocalContext</code> which has the actual type information and whatnot</p>",
        "id": 291611714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659376953
    },
    {
        "content": "<p>i found it a little weird that both the \"definition\" and the \"use\" of a local used exactly the same expr (except for adjusted source position information).</p>",
        "id": 291611740,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659376965
    },
    {
        "content": "<blockquote>\n<p>it's now solely a pointer into the LocalContext which has the actual type information and whatnot</p>\n</blockquote>\n<p>that sounds more like what i would have expected, i think.</p>",
        "id": 291611809,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659376996
    },
    {
        "content": "<p>Huh? what is a \"definition\" of a local constant?</p>",
        "id": 291611819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659377001
    },
    {
        "content": "<p>well <code>fun id (a: nat) -&gt; nat := a</code><br>\nthe <code>(a: nat)</code> part is the definition.<br>\nthe <code>a</code> part in the body is the use.<br>\nclearly at source level, these are quite different, but in the ast, they use the same expr.</p>",
        "id": 291611980,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659377086
    },
    {
        "content": "<p>I suppose you could call the things in the LocalContext the \"definition of a local_const\", but that's <code>local_decl</code>, not <code>local_const</code></p>",
        "id": 291611984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659377088
    },
    {
        "content": "<p>The expression <code>(a: nat) -&gt; nat</code> is represented as an expr like <code>Pi \"a\" (const \"nat\") (const \"nat\")</code>, there aren't any local_const involved at all</p>",
        "id": 291612123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659377156
    },
    {
        "content": "<p>i'm not sure what <code>local_const</code> is.<br>\ni was talking about lean3's <code>expr_local</code> <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 291612292,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659377239
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr\">docs#expr</a></p>",
        "id": 291612309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659377251
    },
    {
        "content": "<p>the names on the C++ side are weird</p>",
        "id": 291612327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659377262
    },
    {
        "content": "<p>ok, i see.</p>",
        "id": 291612482,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659377341
    },
    {
        "content": "<p>but the body (<code>a</code>) would be a local_const?</p>",
        "id": 291612506,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659377351
    },
    {
        "content": "<p>the local consts get involved when you enter a binder during elaboration. Let's say the body is <code>\\lam a, a</code>, so we start by entering the <code>a</code> binder. This means creating a new local_decl like <code>{name := \"a\", uniq := 1234, type := nat}</code> and then all occurrences of <code>var 0</code> get replaced with <code>local_const \"a\" 1234 &lt;&gt;</code></p>",
        "id": 291612784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659377507
    },
    {
        "content": "<p>and then we would resolve the user reference <code>a</code> to that local constant, and when we close the scope we would abstract it back to <code>var 0</code> resulting in the term <code>lam \"a\" (const \"nat\") (var 0)</code> for that identity function</p>",
        "id": 291612978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659377603
    },
    {
        "content": "<p>ok, makes sense!<br>\nwhat's the idea behind replacing the vars with locals, instead of doing the lookups ad hoc? (this really is my central question)</p>",
        "id": 291613140,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659377699
    },
    {
        "content": "<p>i guess at some points they're turned back into local_consts, because the kernel (in lean3) doesn't seem to accept vars.</p>",
        "id": 291613215,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659377742
    },
    {
        "content": "<p>i've got to go, back in like an hour.<br>\nthanks for the help so far!</p>",
        "id": 291613400,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659377852
    },
    {
        "content": "<p>i guess one reason for switching to the unique names could be that you don’t have to bother with adjusting de-bruijn indices or alpha conversion.</p>",
        "id": 291613994,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659378180
    },
    {
        "content": "<p>hmm, but then why would de-bruijn be used at all? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 291615433,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659378901
    },
    {
        "content": "<p>I believe this is the keyword:</p>\n<blockquote>\n<p>That's the locally nameless approach.</p>\n</blockquote>\n<p>There seem to be papers you could look up about \"locally nameless representation\"</p>",
        "id": 291617868,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659380151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456923\">Leonard Wiechmann</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/291613140\">said</a>:</p>\n<blockquote>\n<p>what's the idea behind replacing the vars with locals, instead of doing the lookups ad hoc? (this really is my central question)</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"456923\">Leonard Wiechmann</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/291613994\">said</a>:</p>\n<blockquote>\n<p>i guess one reason for switching to the unique names could be that you don’t have to bother with adjusting de-bruijn indices or alpha conversion.</p>\n</blockquote>\n<p>You answered your own question. It basically localizes the problem of lifting and substitution to one place, so nothing else has to worry about it. See also <a href=\"http://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf\">http://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf</a> which explains some of the theory.</p>",
        "id": 291618435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659380404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456923\">Leonard Wiechmann</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/291613215\">said</a>:</p>\n<blockquote>\n<p>i guess at some points they're turned back into local_consts, because the kernel (in lean3) doesn't seem to accept vars.</p>\n</blockquote>\n<p>Actually it's the other way around. Kernel terms must not contain local_consts, although the kernel itself also does the locally nameless thing so it will turn vars into local_consts as it traverses the term.</p>",
        "id": 291618651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659380505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/291617868\">said</a>:</p>\n<blockquote>\n<p>There seem to be papers you could look up about \"locally nameless representation\"</p>\n</blockquote>\n<p>thanks, i'll take a look!</p>",
        "id": 291625620,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659384022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/291618435\">said</a>:</p>\n<blockquote>\n<p>It basically localizes the problem of lifting and substitution to one place, so nothing else has to worry about it. See also <a href=\"http://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf\">http://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf</a> which explains some of the theory.</p>\n</blockquote>\n<p>that makes sense, thanks for the link!</p>",
        "id": 291625680,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659384046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/291618651\">said</a>:</p>\n<blockquote>\n<p>Actually it's the other way around. Kernel terms must not contain local_consts, although the kernel itself also does the locally nameless thing so it will turn vars into local_consts as it traverses the term.</p>\n</blockquote>\n<p>ah, i see. i did wonder how the kernel verified the bindings if the input used local_const.<br>\ni saw the <code>lean_assert(closed(e));</code> in <code>type_checker::infer_type_core</code>, i must have missed the conversion.</p>",
        "id": 291626055,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659384212
    },
    {
        "content": "<p>found it: <code>finalize_definition</code> in <code>definition_cmds.cpp</code> abstracts the locals.<br>\nand stuff like <code>type_checker::infer_lambda</code> <em>temporarily</em> switches to <code>expr_local</code> for inference.<br>\nseems <code>closed(e)</code> doesn't mean \"doesn't contain <em>any</em> vars\", but just means \"doesn't contain <em>free</em> vars\". (yes, that's exactly what it means. says it in the comment right above it... :D)<br>\nman, this would probably be so much easier, if i had just downloaded and compiled the code :D</p>",
        "id": 291630841,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659386503
    },
    {
        "content": "<p>anyway, thanks kyle and mario for the help, really appreciate it!</p>",
        "id": 291631309,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659386743
    },
    {
        "content": "<hr>\n<p>working my way through the typing rules in the lean paper again (The Type Theory of Lean).<br>\nhave a few questions:</p>\n<p>1) has the type theory changed in any way for lean4?</p>\n<p>2) isn't the proof irrelevance reduction rule (second line in the image) technically unjustified?<br>\nthe def-eq rule (first line) only has <em>one</em> <code>p</code>, no <code>p'</code>.<br>\nit's my understanding that you can't \"apply def-eq to the rules themselves\" (i.e. if the rule only has one <code>p</code>, you can't apply it if you have two different <code>p</code>, <code>p'</code>, even if they're def-eq).<br>\n<a href=\"/user_uploads/3121/nDKxXJXJPMpi8Jgc0hnuT7ZC/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/nDKxXJXJPMpi8Jgc0hnuT7ZC/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/nDKxXJXJPMpi8Jgc0hnuT7ZC/image.png\"></a></div>",
        "id": 291709330,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659447354
    },
    {
        "content": "<p>1) Yes and no. The theory is not supposed to have changed in any essential way, but lean 4 does include some new kernel features not supported by lean 3, mostly optimizations of things that were supported already but not primitively.</p>\n<ul>\n<li>Primitive projections. This is just shorthand for a <code>rec</code> term applied to a lambda that extracts one of the arguments, and it has the expected definitional equalities.</li>\n<li>Primitive nat and string literals. This makes <code>#reduce</code> stop early and changes the behavior of whnf around these terms, but otherwise they are just shorthand for the term construction you could do before.<ul>\n<li>Primitive nat literal operations like <code>Nat.add</code>. It only works on literals, not variables, so it can only compute things that were already computable through a long sequence of kernel reductions.</li>\n</ul>\n</li>\n<li>Eta for structures. This is a \"real\" change, but it is actually a bit closer to the paper than before, since I had to add eta for (some) structures in the \"reduction to W-types\" chapter. It does not pose any really difficult problems.</li>\n<li>Nested and mutual inductives. This is a big change, and one that probably needs some investigation at some point, but it should be checking the same rules as in lean 3 (where nested and mutual inductives were only simulated by the frontend). The simulation did not have all the desired definitional equalities though, so this is a real change.</li>\n</ul>",
        "id": 291770105,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659475153
    },
    {
        "content": "<p>2) The \"algorithmic\" rules do not have to be 1 for 1 copies of the \"idealized\" rules. They just need to be able to show essentially the same things in the same context. In this case, you can show that if you replace <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⇔</mo></mrow><annotation encoding=\"application/x-tex\">\\Leftrightarrow</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">⇔</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≡</mo></mrow><annotation encoding=\"application/x-tex\">\\equiv</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4637em;\"></span><span class=\"mrel\">≡</span></span></span></span> in the second rule you still get a provable theorem: Suppose <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>p</mi><mo>:</mo><mi mathvariant=\"double-struck\">P</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\vdash p:\\mathbb{P}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">P</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>h</mi><mo>:</mo><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\vdash h:p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><msup><mi>h</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>:</mo><msup><mi>p</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\vdash h&#x27;:p&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9463em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>p</mi><mo>≡</mo><msup><mi>p</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\vdash p\\equiv p&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6582em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9463em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>. Then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><msup><mi>p</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>≡</mo><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\vdash p&#x27;\\equiv p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9463em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>, so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><msup><mi>h</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>:</mo><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\vdash h&#x27;:p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> by the conv rule (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>α</mi><mo>≡</mo><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\vdash\\alpha\\equiv\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4637em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span> implies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\vdash e:\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> -&gt; <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\vdash e:\\beta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span>). Thus <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>h</mi><mo>≡</mo><msup><mi>h</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\vdash h\\equiv h&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> by proof irrelevance.</p>",
        "id": 291770860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659475550
    },
    {
        "content": "<p>BTW, does \"eta for structures\" literally mean for things defined with the <code>structure</code> keyword? Or does the equivalent <code>inductive</code> also have eta?</p>",
        "id": 291772290,
        "sender_full_name": "Reid Barton",
        "timestamp": 1659476356
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/commit/0aa32d643e063efd68bd31478ccd8028a3de7533\">https://github.com/leanprover/lean4/commit/0aa32d643e063efd68bd31478ccd8028a3de7533</a></p>",
        "id": 291775852,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659478410
    },
    {
        "content": "<p>Yes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Foo.fst</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n<span class=\"kd\">def</span> <span class=\"n\">Foo.snd</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">Foo.mk</span> <span class=\"n\">f.fst</span> <span class=\"n\">f.snd</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Rec</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Rec</span> <span class=\"bp\">→</span> <span class=\"n\">Rec</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Rec.fst</span> <span class=\"o\">:</span> <span class=\"n\">Rec</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n<span class=\"kd\">def</span> <span class=\"n\">Rec.snd</span> <span class=\"o\">:</span> <span class=\"n\">Rec</span> <span class=\"bp\">→</span> <span class=\"n\">Rec</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Rec</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">Rec.mk</span> <span class=\"n\">f.fst</span> <span class=\"n\">f.snd</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fail</span>\n</code></pre></div>",
        "id": 291776346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659478712
    },
    {
        "content": "<p>The kernel doesn't actually receive a \"structure\" flag. It computes whether an inductive is \"structure-like\" itself</p>",
        "id": 291776521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659478837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/291770860\">said</a>:</p>\n<blockquote>\n<p>2) The \"algorithmic\" rules do not have to be 1 for 1 copies of the \"idealized\" rules. They just need to be able to show essentially the same things in the same context.</p>\n</blockquote>\n<p>meaning \"<em>imply</em> the ideal rules\"? (in a way that's implementation friendly)<br>\ntotally forgot about the conv rule. noticed it was absent, but didn't realize it was \"baked into the proof irrelevance rule\" (like eta, which had pi-intro baked in, turning it into an extensionality principle).</p>",
        "id": 291819348,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659517153
    },
    {
        "content": "<p>The conv rule doesn't work very well algorithmically, since you don't know what other type to prove definitionally equal to the one you have. Instead, everywhere type equality constraints appear, those equalities get replaced with definitional equality checks</p>",
        "id": 291820258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659517640
    },
    {
        "content": "<p>Another standard place definitional equality checks appear is in the function application rule</p>",
        "id": 291820319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659517681
    },
    {
        "content": "<p>... I guess it doesn't show up in the paper since I don't give an algorithmic analogue of the typing judgment itself (i.e. a typechecker)</p>",
        "id": 291820494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659517786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/291820258\">said</a>:</p>\n<blockquote>\n<p>The conv rule doesn't work very well algorithmically, since you don't know what other type to prove definitionally equal to the one you have.</p>\n</blockquote>\n<p>which also applies to the transitivity rule, i guess (besides that thing about sub-singleton-elim &amp; decidability).</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/291820319\">said</a>:</p>\n<blockquote>\n<p>Another standard place definitional equality checks appear is in the function application rule<br>\n... I guess it doesn't show up in the paper</p>\n</blockquote>\n<p>i'm not sure i understand.</p>\n<p>there's this, looks like a func app rule to me: <a href=\"/user_uploads/3121/FKs-yoIlvrP8Rjd0qTwOrf-j/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/FKs-yoIlvrP8Rjd0qTwOrf-j/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/FKs-yoIlvrP8Rjd0qTwOrf-j/image.png\"></a></div><p>and these two: <a href=\"/user_uploads/3121/Qsid_zr-iJYSENsa2ObQFe-2/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Qsid_zr-iJYSENsa2ObQFe-2/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/Qsid_zr-iJYSENsa2ObQFe-2/image.png\"></a></div>",
        "id": 291822382,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659518782
    },
    {
        "content": "<p>the first one is application compatibility, and the second one is the beta rule. The function application rule is</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>f</mi><mo>:</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo>:</mo><mi>A</mi><mi mathvariant=\"normal\">.</mi><mtext>  </mtext><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mspace width=\"1em\"/><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi></mrow><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>f</mi><mtext>  </mtext><mi>x</mi><mo>:</mo><mi>B</mi><mo stretchy=\"false\">[</mo><mi>e</mi><mi mathvariant=\"normal\">/</mi><mi>x</mi><mo stretchy=\"false\">]</mo></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\dfrac{\\Gamma \\vdash f:\\forall x: A.\\;B(x)\\quad \\Gamma \\vdash e: A}{\\Gamma\\vdash f\\;x: B[e/x]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.363em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">e</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">]</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>",
        "id": 291853628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659535184
    },
    {
        "content": "<p>and the algorithmic version looks like</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊩</mo><mi>f</mi><mo>:</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo>:</mo><mi>A</mi><mi mathvariant=\"normal\">.</mi><mtext>  </mtext><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mspace width=\"1em\"/><mi mathvariant=\"normal\">Γ</mi><mo>⊩</mo><mi>e</mi><mo>:</mo><msup><mi>A</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mspace width=\"1em\"/><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>A</mi><mo>⇔</mo><msup><mi>A</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊩</mo><mi>f</mi><mtext>  </mtext><mi>x</mi><mo>:</mo><mi>B</mi><mo stretchy=\"false\">[</mo><mi>e</mi><mi mathvariant=\"normal\">/</mi><mi>x</mi><mo stretchy=\"false\">]</mo></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\dfrac{\\Gamma \\Vdash f:\\forall x: A.\\;B(x)\\quad \\Gamma \\Vdash e: A&#x27;\\quad \\Gamma \\vdash A\\Leftrightarrow A&#x27;}{\\Gamma\\Vdash f\\;x: B[e/x]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.3649em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.4289em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⊩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">e</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">]</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⊩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⊩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇔</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>",
        "id": 291853850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659535267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/291853850\">said</a>:</p>\n<blockquote>\n<p>and the algorithmic version looks like</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊩</mo><mi>f</mi><mo>:</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo>:</mo><mi>A</mi><mi mathvariant=\"normal\">.</mi><mtext>  </mtext><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mspace width=\"1em\"/><mi mathvariant=\"normal\">Γ</mi><mo>⊩</mo><mi>e</mi><mo>:</mo><msup><mi>A</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mspace width=\"1em\"/><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>A</mi><mo>⇔</mo><msup><mi>A</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊩</mo><mi>f</mi><mtext>  </mtext><mi>x</mi><mo>:</mo><mi>B</mi><mo stretchy=\"false\">[</mo><mi>e</mi><mi mathvariant=\"normal\">/</mi><mi>x</mi><mo stretchy=\"false\">]</mo></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\dfrac{\\Gamma \\Vdash f:\\forall x: A.\\;B(x)\\quad \\Gamma \\Vdash e: A&#x27;\\quad \\Gamma \\vdash A\\Leftrightarrow A&#x27;}{\\Gamma\\Vdash f\\;x: B[e/x]}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.3649em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.4289em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⊩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">e</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">]</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⊩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⊩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇔</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span><br>\n</p>\n</blockquote>\n<p>ah, makes sense.<br>\nso like with proof irrelevance, you bake in the conversion rule.</p>",
        "id": 292147093,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659702742
    },
    {
        "content": "<p>i found this check in lean3's abstract function:<br>\n<code>lean_assert(std::all_of(subst, subst+n, [](expr const &amp; e) { return closed(e) &amp;&amp; is_local(e); }));</code></p>\n<p>i was confused by the <code>closed(e)</code> part. how can a local not be closed? in lean3 maybe if the type isn't closed.<br>\nthen i checked lean4 to see if there were any changes.<br>\nand indeed there were.</p>\n<p>the check is still there, just called <code>!has_loose_bvars(e)</code> now. (<a href=\"https://github.com/leanprover/lean4/blob/6a767a66a13c588cce3829bf1de00a1830883843/src/kernel/abstract.cpp#L15\">https://github.com/leanprover/lean4/blob/6a767a66a13c588cce3829bf1de00a1830883843/src/kernel/abstract.cpp#L15</a>)<br>\nhowever it doesn't seem to do anything.</p>\n<p>has_loose_bvars seems to check the computed <code>Expr.data</code> field. but looseBVarRange is always zero for fvars: <a href=\"https://github.com/leanprover/lean4/blob/6a767a66a13c588cce3829bf1de00a1830883843/src/Lean/Expr.lean#L428\">https://github.com/leanprover/lean4/blob/6a767a66a13c588cce3829bf1de00a1830883843/src/Lean/Expr.lean#L428</a></p>\n<p>is that a bug? (and the fvar's <em>type</em> should have been checked for loose bvars; not that the type should ever contain any bvars either, because it's instantiated before putting it into the local context, though that's technically not enforced by the local context)<br>\nor is that just a redundant check?</p>",
        "id": 292148366,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659703469
    },
    {
        "content": "<p>Like I said, lean mostly works on closed terms</p>",
        "id": 292148420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659703511
    },
    {
        "content": "<p>that doesn't mean no local consts, that means no <code>var</code>s</p>",
        "id": 292148436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659703522
    },
    {
        "content": "<p>or <code>bvar</code>s in lean 4</p>",
        "id": 292148458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659703536
    },
    {
        "content": "<p>yes, i got that.</p>",
        "id": 292148535,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659703574
    },
    {
        "content": "<p>so it's not a bug that <code>looseBVarRange</code> is 0 for fvars</p>",
        "id": 292148587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659703601
    },
    {
        "content": "<p>because it doesn't have any bvars in it</p>",
        "id": 292148607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659703613
    },
    {
        "content": "<p>yeah, that's why i was confused by that check.</p>",
        "id": 292148632,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659703629
    },
    {
        "content": "<p>so it's just redundant?</p>",
        "id": 292148638,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659703634
    },
    {
        "content": "<p>?</p>",
        "id": 292148643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659703639
    },
    {
        "content": "<p>there are other expressions that have bvars in them</p>",
        "id": 292148663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659703650
    },
    {
        "content": "<p>but fvars don't</p>",
        "id": 292148667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659703658
    },
    {
        "content": "<p>this is the check: <code>return !has_loose_bvars(e) &amp;&amp; is_fvar(e);</code> (<a href=\"https://github.com/leanprover/lean4/blob/6a767a66a13c588cce3829bf1de00a1830883843/src/kernel/abstract.cpp#L15\">https://github.com/leanprover/lean4/blob/6a767a66a13c588cce3829bf1de00a1830883843/src/kernel/abstract.cpp#L15</a>)<br>\nconjunction, but the second implies the first.</p>",
        "id": 292148763,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659703694
    },
    {
        "content": "<p>in lean3, it seems to check the type's vars.</p>",
        "id": 292148870,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659703762
    },
    {
        "content": "<p>Oh I see. That could be a performance optimization but it seems unlikely, both checks should be O(1)</p>",
        "id": 292149001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659703830
    },
    {
        "content": "<p>it could also be grandfathered code since it's the exact same line modulo naming</p>",
        "id": 292149056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659703856
    },
    {
        "content": "<p>and it's in an assert anyway so it doesn't matter</p>",
        "id": 292149082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659703872
    },
    {
        "content": "<p>so it could just be for clarity</p>",
        "id": 292149108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659703891
    },
    {
        "content": "<p>i think the behavior is technically <em>different</em> in lean3:</p>\n<p>locals are initialized with their type's free var range.<br>\n(<a href=\"https://github.com/leanprover/lean/blob/master/src/kernel/expr.cpp#L164\">https://github.com/leanprover/lean/blob/master/src/kernel/expr.cpp#L164</a>)</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"n\">expr_mlocal</span><span class=\"o\">::</span><span class=\"n\">expr_mlocal</span><span class=\"p\">(</span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"n\">is_meta</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"n\">pp_n</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">)</span><span class=\"o\">:</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">expr_composite</span><span class=\"p\">(</span><span class=\"n\">is_meta</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"n\">expr_kind</span><span class=\"o\">::</span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">expr_kind</span><span class=\"o\">::</span><span class=\"n\">Local</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">.</span><span class=\"n\">hash</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">is_meta</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">has_expr_metavar</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">has_univ_metavar</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">                   </span><span class=\"o\">!</span><span class=\"n\">is_meta</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">has_local</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">has_param_univ</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">                   </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">get_free_var_range</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">                      </span><span class=\"c1\">// ^ THIS sets expr_composite.m_free_var_range</span>\n</code></pre></div>\n<p>and that's read in:<br>\n(<a href=\"https://github.com/leanprover/lean/blob/master/src/kernel/expr.h#L594\">https://github.com/leanprover/lean/blob/master/src/kernel/expr.h#L594</a>)</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"kr\">inline</span><span class=\"w\"> </span><span class=\"kt\">unsigned</span><span class=\"w\"> </span><span class=\"nf\">get_free_var_range</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">switch</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"no\">expr_kind</span><span class=\"o\">::</span><span class=\"no\">Var</span><span class=\"p\">:</span><span class=\"w\">                            </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">var_idx</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"no\">expr_kind</span><span class=\"o\">::</span><span class=\"no\">Constant</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"no\">expr_kind</span><span class=\"o\">::</span><span class=\"no\">Sort</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">default</span><span class=\"o\">:</span><span class=\"w\">                                        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">expr_composite</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">raw</span><span class=\"p\">())</span><span class=\"o\">-&gt;</span><span class=\"n\">m_free_var_range</span><span class=\"p\">;</span><span class=\"w\">  </span><span class=\"c1\">// HERE</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"cm\">/** \\brief Return true iff the given expression has free variables. */</span><span class=\"w\"></span>\n<span class=\"kr\">inline</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"nf\">has_free_vars</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">get_free_var_range</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"cm\">/** \\brief Return true iff the given expression does not have free variables. */</span><span class=\"w\"></span>\n<span class=\"kr\">inline</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"nf\">closed</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">has_free_vars</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>so the implementations seem to be inconsistent.<br>\nbut it shouldn't matter because<br>\n<span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/292148420\">said</a>:</p>\n<blockquote>\n<p>Like I said, lean mostly works on closed terms</p>\n</blockquote>",
        "id": 292149765,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659704254
    },
    {
        "content": "<p>so i guess</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/292149108\">said</a>:</p>\n<blockquote>\n<p>so it could just be for clarity</p>\n</blockquote>",
        "id": 292149867,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659704298
    },
    {
        "content": "<p>A local constant cannot have a type that depends on a var</p>",
        "id": 292153784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659706278
    },
    {
        "content": "<p>i mean, syntactically it can, of course.<br>\ni guess you're implying that lean always instantiates before putting locals into the context, right?<br>\n(so if you have <code>lam (A: Type), lam (a: #Var 0), a</code> the outer lambda is instantiated first. so <code>a</code>'s type will be a local const by the time <code>a</code> is put into the context)</p>",
        "id": 292180468,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1659718424
    },
    {
        "content": "<p>right</p>",
        "id": 292181960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659719136
    },
    {
        "content": "<p>question about K-reduction:<br>\nmy understanding is that it applies to any sub-singleton (because all arguments are given in the indices, so you can reconstruct the intro term).<br>\nbut the implementation only supports k-reduction if the ctor has <em>no arguments</em>.<br>\n<a href=\"https://github.com/leanprover/lean4/blob/fa7769260a805440f34bdd3da982e6925e7d72b4/src/kernel/inductive.cpp#L538\">https://github.com/leanprover/lean4/blob/fa7769260a805440f34bdd3da982e6925e7d72b4/src/kernel/inductive.cpp#L538</a><br>\nis this because it's not needed in practice and simplifies the implementation, or am i misunderstanding the type theory?</p>",
        "id": 294522637,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1661072956
    },
    {
        "content": "<p>what you describe is the requirements for large elimination for an inductive type in <code>Prop</code>. For K-like reduction, you need to have no arguments at all to the constructor because otherwise you would need projections to recover the arguments</p>",
        "id": 294575493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661108637
    },
    {
        "content": "<p>Among common inductive types, only <code>Eq</code> has K-like reduction (and indeed that's the main application), while <code>Acc</code> is a large eliminating Prop which does not have K-like reduction</p>",
        "id": 294575818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661108841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/lean3.20impl.20questions/near/294575493\">said</a>:</p>\n<blockquote>\n<p>For K-like reduction, you need to have no arguments at all to the constructor because otherwise you would need projections to recover the arguments</p>\n</blockquote>\n<p>i'm not sure i understand.<br>\nthe recursor lets you recover the (non-recursive) arguments.<br>\nin <code>rec C e p[b] h</code>, all non-recursive arguments must occur directly in the indices <code>p[b]</code> (for sub-singletons).<br>\nso you can turn this into <code>rec C e p[b] (intro b)</code>, recovering <code>b</code> from <code>p[b]</code>.<br>\nrecursive arguments can't be recovered because they can't be used in types.<br>\nthat's also how i understood this: \"This rule only applies when all the variables in b are actually on the LHS, which is the reason for<br>\nthe peculiar requirements on <em>subsingleton eliminators</em>. If bi appears in the parameters for its type,<br>\nthat means that pj [b] = bi for some j, and so bi is on the LHS [meaning it can be recovered].\"</p>",
        "id": 294617990,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1661152264
    },
    {
        "content": "<p>recovering them would require a little more book keeping (storing the <code>j</code> for each <code>bi</code>).<br>\nwhich is why i thought the implementation choice was pragmatic in nature.</p>",
        "id": 294618637,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1661152592
    },
    {
        "content": "<p>it's possible that lean implements a proper subset of the possible K-like inductives. It's not a very important / used mechanism except in the case of <code>eq</code></p>",
        "id": 294774772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661206491
    },
    {
        "content": "<p>I think of the three categories of things you can have in subsingleton eliminating types: (1) prop args, (2) arguments that appear in the indices, (3) recursive args, only (2) is allowed in K-like inductives, and lean implements none of them</p>",
        "id": 294774978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1661206572
    },
    {
        "content": "<p>right, makes sense, thanks!</p>",
        "id": 294816971,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1661240152
    }
]
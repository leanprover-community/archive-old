[
    {
        "content": "<p>I could put some time on transfer and parametricity. I'll have to get a refresher on parametricity though. But this project is still useful. Although it will likely be replaced in Lean 4, when we do have a FFI, we can start building CS applications that themselves may be more portable.</p>",
        "id": 164621456,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1556715759
    },
    {
        "content": "<p>The math is moving forward pretty nicely. Meanwhile the CS side of mathlib and other Lean packages is still under furnished. Please forgive us for spending time on it ;-)</p>",
        "id": 164621612,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1556715900
    },
    {
        "content": "<p>Btw, do you have any time for parametricity and transfer? We could pick it up today if you like</p>",
        "id": 164621748,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1556716072
    },
    {
        "content": "<p>I have time today, but I don't have the required knowledge</p>",
        "id": 164621804,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556716107
    },
    {
        "content": "<p>I can only repeat what Kevin wrote hundreds of times</p>",
        "id": 164621813,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556716124
    },
    {
        "content": "<p>Maybe I should talk to <span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> again</p>",
        "id": 164621816,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1556716137
    },
    {
        "content": "<p>We need Lean to understand that isomorphic stuff have the same properties, for any property that makes sense</p>",
        "id": 164621826,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556716152
    },
    {
        "content": "<p>Simon, if you want a nice project for today, you could redo my leancrawler correctly. The goal is to be able to display the graph of all concepts in a Lean project, where each declaration is a node, and each edge means a declaration uses another declaration. Mine is unfortunately really bad, many edges are missing</p>",
        "id": 164622622,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556716978
    },
    {
        "content": "<p>You misunderstand me. I'm not looking for new projects. I'm trying to find help for the projects I already have</p>",
        "id": 164623443,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1556717739
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> a bit of an aside, but a fellow one of Scott's students has just started working on <code>iso_induction</code>, using an isomorphism <code>X ≅ Y</code> to replace every object <code>Y</code> that's in your goal with an <code>X</code> (and hopefully changing nothing else). At the moment it can show that for <code>X</code> and <code>Y</code> isomorphic types, to prove <code>inhabited Y</code> it suffices to show <code>inhabited X</code>! But this is done with some very general typeclass instances pertaining to functoriality. Not too long from now you should be able to add a command after the definition of e.g. <code>local_ring</code> which generates a proof of functoriality of the construction, and then be done with transporting such structure. (At least that's the plan, anyway!)</p>",
        "id": 164623646,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1556717910
    },
    {
        "content": "<p>Interesting. I got a fair amount of push back when I tried focusing on isomorphisms for transport. That seemed like a good goal to me but Johannes didn't seem to like that idea</p>",
        "id": 164623953,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1556718238
    },
    {
        "content": "<p>I wish I understood all of this better. I still keep coming back to the same idea -- if R is a local ring and S is isomorphic to R then S is local, and I cannot see why Lean can't auto-generate this theorem using some sequence of <code>equiv</code>s. <code>R</code> and <code>S</code> are ring-equiv, so the lattice of ideals of R and of S are lattice-equiv, and the definition of local ring is some predicate on these lattices which only depends on the lattice structure so commutes with the equiv. If someone wants to update <a href=\"https://github.com/leanprover-community/mathlib/issues/408\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/408\">https://github.com/leanprover-community/mathlib/issues/408</a> so I understand better the plan for implementing this in Lean, maybe I would get less frustrated by this issue :-/</p>",
        "id": 164630636,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556723609
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 164630718,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556723665
    },
    {
        "content": "<p>I have two fintypes <code>S</code> and <code>T</code>, an equiv <code>S \\equiv T</code>, a proof that all reflexive binary relations on <code>S</code> are transitive, and I want to deduce that all reflexive binary relations on <code>T</code> are transitive.  I am adding this to my list of transport complaints ;-) The maths proof is: \"consider a reflexive binary relation on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span></span></span></span>; this obviously induces a reflexive binary relation on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span>; the induced relation is transitive; hence obviously the original relation is transitive\". </p>\n<p>How to do this in Lean in a clean and clear way?</p>\n<hr>\n<p>Background: I asked my students (in last year's exam) to prove that if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span></span></span></span> was a reflexive binary relation on a set <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> with two elements, then <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span></span></span></span> was transitive. <span class=\"user-mention\" data-user-id=\"130500\">@Abhimanyu Pallavi Sudhir</span> wrote up the solutions in Lean and he assumed that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> was <code>fin 2</code>. In a solution to such a question a mathematician would not think twice if a student wrote \"WLOG <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mo>=</mo><mo>{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">S=\\{0,1\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mrel\">=</span><span class=\"mopen\">{</span><span class=\"mord mathrm\">0</span><span class=\"mpunct\">,</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">}</span></span></span></span>\"; it is indistinguishable from \"let the elements of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> be called <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span></span></span></span>\". In fact assuming <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is <code>bool</code> makes life even easier, but then one is faced with the question above.</p>",
        "id": 164972721,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557140724
    },
    {
        "content": "<p>I don't think this is the answer you wanted but</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">hrefl</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">hxy</span> <span class=\"n\">hyz</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_symm_apply</span> <span class=\"n\">e</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_symm_apply</span> <span class=\"n\">e</span> <span class=\"n\">z</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_symm_apply</span> <span class=\"n\">e</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_symm_apply</span> <span class=\"n\">e</span> <span class=\"n\">y</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hxy</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_symm_apply</span> <span class=\"n\">e</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_symm_apply</span> <span class=\"n\">e</span> <span class=\"n\">z</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hyz</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">hrefl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">hxy</span> <span class=\"n\">hyz</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 164973498,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1557141719
    },
    {
        "content": "<p>Now Kenny golfs it (-;</p>",
        "id": 164973691,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557141905
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">hrefl</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">hxy</span> <span class=\"n\">hyz</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_symm_apply</span> <span class=\"n\">e</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_symm_apply</span> <span class=\"n\">e</span> <span class=\"n\">z</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"err\">\\</span><span class=\"bp\">|-</span> <span class=\"n\">hxy</span> <span class=\"n\">hyz</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">hrefl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">hxy</span> <span class=\"n\">hyz</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 164973732,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1557141960
    },
    {
        "content": "<p>Also, you missed the chance to use projection notation</p>",
        "id": 164973840,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557142064
    },
    {
        "content": "<p>You clearly didn't run that one</p>",
        "id": 164973841,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557142064
    },
    {
        "content": "<p>I haven't fired up Lean since a long time</p>",
        "id": 164973889,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1557142084
    },
    {
        "content": "<p>And your internal type checker is rusty (-;</p>",
        "id": 164973900,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557142097
    },
    {
        "content": "<p>You're still running Lean 3.4.1, aren't you?</p>",
        "id": 164973950,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557142177
    },
    {
        "content": "<p>I'm staying off Lean until after the exam</p>",
        "id": 164974024,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1557142209
    },
    {
        "content": "<p>Too bad that your exam is also staying off Lean</p>",
        "id": 164974108,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557142314
    },
    {
        "content": "<p>Yeah, I can prove it too; but I just know deep down that this is a special case of a general principle; given <code>e</code> and <code>h</code>, a mathematician knows in their soul that the goal is true, and doesn't want to prove it. The question, I think, is how to prove it with a tactic. I have more time for this now; Mario posted something a month or two ago but I was completely focussed on the perfectoid project at the time and didn't want to get distracted; now I am interested again.</p>\n<p>My proof was more mundane: given rb on beta I literally built ra on alpha using the equiv, proved that the relationship on beta one can build from ra is rb again, and then just transferred everything manually.</p>\n<p>But my point is that this should somehow be a one-liner.</p>",
        "id": 164993381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1557158058
    },
    {
        "content": "<p>essentially Kevin's approach, but <code>big_bertha</code> style:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">r</span> <span class=\"n\">H</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">r&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"n\">r&#39;</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">finish</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">z</span><span class=\"o\">),</span>\n  <span class=\"o\">{[</span><span class=\"n\">smt</span><span class=\"o\">]</span> <span class=\"n\">eblast_using</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">r&#39;</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)]}</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 164998189,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1557161410
    },
    {
        "content": "<p>this doesn't quite do what Kevin wants, but we can see that proving the transfer is automatic; we just have to state it. all the constructed data/lemmas in the above proof are very follow-your-nose, so it's conceivable that one could whip up a tactic that attempts to use <code>equiv.to_fun</code> and <code>equiv.inv_fun</code> to produce the requisite data when it sees a lemma in context like <code>h</code> which is applicable \"modulo equivalence\"</p>",
        "id": 164999356,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1557162333
    },
    {
        "content": "<p>There is a transfer style proof of this theorem. Floris mentioned wanting to get working on adding more transfer lemmas; I should PR <code>equiv.rel</code> if it hasn't made it in yet, it's pretty important for these kinds of proofs</p>",
        "id": 165023729,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557180861
    },
    {
        "content": "<p><a href=\"http://scholar.google.co.uk/scholar_url?url=http://www2.mat.ulaval.ca/fileadmin/Pages_personnelles_des_profs/hm/H14_Mac_Lane_Phil_Math_1996.pdf&amp;hl=en&amp;sa=X&amp;scisig=AAGBfm2Jux_hxs-Oz__pML2nCyJqSwH5vw&amp;nossl=1&amp;oi=scholarr\" target=\"_blank\" title=\"http://scholar.google.co.uk/scholar_url?url=http://www2.mat.ulaval.ca/fileadmin/Pages_personnelles_des_profs/hm/H14_Mac_Lane_Phil_Math_1996.pdf&amp;hl=en&amp;sa=X&amp;scisig=AAGBfm2Jux_hxs-Oz__pML2nCyJqSwH5vw&amp;nossl=1&amp;oi=scholarr\">In this old paper by MacLane</a> he sketches on p179 what he says Bourbaki calls a \"type\" of \"structure\". His definition of structure is sufficiently general to allow topological spaces.</p>\n<p>What is confusing me is the claim on p180 that a type of structure leads to the notion of morphism from one model of the structure to another; I'm not sure these words mean the same thing nowadays but what he's saying is that the axioms for a group give you a structure and now you can figure out what a homomorphism of groups is. But he's also saying that the axioms for a topological space give you a structure and now you can figure out what a homomorphism of topological spaces is. I did not know this. Is it true? MacLane offers no proof. I am fine with the idea that you can figure out what an <em>isomorphism</em> of structures is, but I don't see how to guess what a morphism of topological spaces is. There are some vague comments about how the power set can be covariant or contravariant, but I am confused about whether this co/contravariance is supposed to be part of the structure. Is this just a load of old codswallop or is there something here which can be made rigorous?</p>",
        "id": 167886462,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560284134
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"210057\">@Fabian Glöckle</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> This might be relevant to what you are implementing</p>",
        "id": 167887254,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560284795
    },
    {
        "content": "<p>Does anyone know the reference to Bourbaki where they define these \"types of structures\"?</p>",
        "id": 167887817,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560285225
    },
    {
        "content": "<p><a href=\"https://link-springer-com.iclibezp1.cc.ic.ac.uk/content/pdf/10.1007%2F978-3-540-34035-5.pdf\" target=\"_blank\" title=\"https://link-springer-com.iclibezp1.cc.ic.ac.uk/content/pdf/10.1007%2F978-3-540-34035-5.pdf\">https://link-springer-com.iclibezp1.cc.ic.ac.uk/content/pdf/10.1007%2F978-3-540-34035-5.pdf</a> I think.<br>\nChaiptre IV is called structures. It's in Théorie des ensembles</p>",
        "id": 167892115,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560288553
    },
    {
        "content": "<p>Thanks Chris. I've found it. Bourbaki don't just define a morphism between two structures, they have some additional data (basically the axioms that the map has to satisfy!). They explicitly give the example of topological spaces and how morphisms can either be open maps or continuous maps depending on the additional data (denoted <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">σ</span></span></span></span>), on p215 of the pdf, section 2.1 of chapter IV. In fact they explicitly flag with a bendy road sign the fact that given just a structure, you don't have enough information to define morphisms of structures.</p>",
        "id": 167894846,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560290929
    },
    {
        "content": "<p>I have some thoughts on this.<br>\n1) I already implemented the easy case: <a href=\"https://github.com/faabian/mathlib/blob/3.5/meta.lean\" target=\"_blank\" title=\"https://github.com/faabian/mathlib/blob/3.5/meta.lean\">https://github.com/faabian/mathlib/blob/3.5/meta.lean</a><br>\nTake a structure definition (like <code>ordered_ring</code>) and generate the corresponding type of homomorphisms (of maps compatible with all additional structure). I will now head for generating the category instances, forgetful functors etc.<br>\n2) I didn't know about this before, but think MacLane may be correct about being able to find out what a continuous map is:</p>\n<p>In logic/model theory, there are two types of homomorphisms, weak ones (respecting relations as in <code>R(x_1, ..., x_n) \\implies R(f x_1, ..., f x_n)</code>) and strong ones (the same with Iff). Which one would one choose in category theory? Answer: weak ones, as they correspond to precomposition with <code>f</code> if we view relations as maps <code>X \\times ... \\times X \\to Prop</code>.<br>\nThen a subset of X is the same as a predicate (unary relation) on X or Y, and for a map <code>f : X \\to Y</code>and a subset U \\subset Y, the composition \"characteristic function of U \\comp f\" is the characteristic function of the preimage of U under f.<br>\nThen topologies are subsets of the powersets, so predicates on the power sets. We already found out that the natural map between the powersets is taking preimages. So a weak homomorphism means: \"open U \\subset Y \\implies open (f^{-1} U) \\subset X\", the definition of a continuous map. (Or: the preimage of the topology of X under the map \"take preimage under f\" is the topology on Y).</p>\n<p>I didn't check in the paper, but hope this is what he meant.</p>",
        "id": 167918782,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1560320191
    },
    {
        "content": "<p>The issue is that Bourbaki's definition of \"structure\" allows more things than functions and relations -- it allows things like \"functions from the power set of the power set of X to the product of X and the power set of X\". It seems to me that MacLane just throws comments around like \"let's say power set is contravariant\" when talking about topologies, but without making it clear what he means in the general case. Is the thing I just mentioned covariant or contravariant? I'm not sure what I asked there even makes sense. Bourbaki avoid this by simply writing down the things they want to remain invariant <em>first</em>, calling them sigma, and then defining a sigma-morphism to be something that preserves sigma. They make it expressly clear that there is no \"abstract nonsense\" definition of a morphism between structures which does not involve choosing a sigma first.</p>",
        "id": 167920167,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560321987
    },
    {
        "content": "<p>But does this contradict the statement that in some cases there is a canonical way of finding sigma? I think MacLane says taking powerset to be contravariant is natural, and thus continuous maps are (unlike open maps) the natural choice. Do we know structures where this \"canonical\" choice of morphisms is not correct?</p>",
        "id": 167921705,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1560323563
    },
    {
        "content": "<p>Concerning your example, the X part should be covariant, the (X to Prop) part contravariant. I think this is fully algorithmical as the only rule is \"whenever the structure X itself appears, use f to get to Y\". This can mean both pre- or postcomposition. Then draw a diagram and say it must commute.</p>",
        "id": 167922147,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1560324065
    },
    {
        "content": "<p>So if a monotonic function is <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi><mspace width=\"0.277778em\"></mspace><mo>⟹</mo><mspace width=\"0.277778em\"></mspace><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>≤</mo><mi>f</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">x \\le y \\implies f(x) \\le f(y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">x</span><span class=\"mrel\">≤</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mrel\"><span class=\"mspace thickspace\"></span><span class=\"mrel\">⟹</span></span><span class=\"mord mathit\"><span class=\"mspace thickspace\"></span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mrel\">≤</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>, we're using the order on Prop somehow, or we're just saying an order is a category, so a morphism is a functor? What's the canonical \"weak\" morphism on a metric space? Is it <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo>)</mo><mo>≤</mo><mi>d</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo separator=\"true\">,</mo><mi>f</mi><mo>(</mo><mi>y</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">d(x,y) \\le d(f(x),f(y))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">d</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mrel\">≤</span><span class=\"mord mathit\">d</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 167924077,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560326445
    },
    {
        "content": "<p>Yes, somehow prop gets special treatment..</p>",
        "id": 167924208,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1560326598
    },
    {
        "content": "<p>The metric spaces though are a great example showing that there are more than just the algebraic structures.</p>",
        "id": 167924304,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1560326685
    },
    {
        "content": "<p>The algebraic version of a metric space map would be d(x,y) = d(f(x),f(y)) (called isometry?)</p>",
        "id": 167924584,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1560326964
    },
    {
        "content": "<p>Locally ringed spaces are a great example showing that a structure in the sense of Bourbaki is not everything that a mathematician cares about. It is surely impossible to automatically generate the definition of a morphism of locally ringed spaces. But I am not sure that a locally ringed space falls into this whole structure definition at all. On the other hand it is clearly possible to define an isomorphism of locally ringed spaces, even though they are a more complex structure than what I think is allowed by Bourbaki.</p>",
        "id": 167925016,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560327454
    },
    {
        "content": "<blockquote>\n<p>Concerning your example, the X part should be covariant, the (X to Prop) part contravariant.</p>\n</blockquote>\n<p>Does this make sense? Let's define a structure called <code>foo</code>, and a <code>foo</code> is a type <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> plus a subset of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi><mo>×</mo><mrow><mi mathvariant=\"script\">P</mi></mrow><mo>(</mo><mi>X</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">X\\times\\mathcal{P}(X)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mbin\">×</span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.08222em;\">P</span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> (the product of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and its power set). How are you going to define morphisms? How can you be covariant in part of the data and contravariant in the other part? I just don't understand how to make this precise.</p>",
        "id": 167925105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560327591
    },
    {
        "content": "<blockquote>\n<p>Locally ringed spaces are a great example showing that a structure in the sense of Bourbaki is not everything that a mathematician cares about. It is surely impossible to automatically generate the definition of a morphism of locally ringed spaces. But I am not sure that a locally ringed space falls into this whole structure definition at all. On the other hand it is clearly possible to define an isomorphism of locally ringed spaces, even though they are a more complex structure than what I think is allowed by Bourbaki.</p>\n</blockquote>\n<p>A naive autogenerated type-theoretic isom of locally ringed spaces would probably be wrong. Because the isom is a 2-categorical thing. HoTT would automatically get it right, I guess.<br>\nBut if you aren't careful, the autogenerated thing would ask for the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub><mo>=</mo><msub><mi mathvariant=\"script\">O</mi><mi>Y</mi></msub></mrow><annotation encoding=\"application/x-tex\">f_* \\mathcal{O}_X = \\mathcal{O}_Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.175696em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mrel\">=</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.22222em;\">Y</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> (with equality on the nose). Of course the isom should actually include extra data, namely an isom between those two sheaves.</p>",
        "id": 167958320,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560353453
    },
    {
        "content": "<p>But how could Lean ever figure out that it should automatically include such an isom in the autogenerated definition of an iso of LRS's? This only seems plausible if we tightly couple the categorical nature of sheaves to the definition of a sheaf. Otherwise it will just treat <code>sheaf X</code> as a discrete thing. But we want to consider them \"up to homotopy\".</p>",
        "id": 167958549,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560353560
    },
    {
        "content": "<p>I am not sure that locally ringed spaces are covered by this Bourbaki definition of structure, so probably you have to put extra allowances in for all the extra types kicking around; terms have to be equal but types just have to be isomorphic.</p>",
        "id": 167961114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560354967
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I'm not yet convinced that one can automagically produce the definition of isoms of LRS's...</p>",
        "id": 167965900,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560358165
    },
    {
        "content": "<p>If we endow everything with category instances... then maybe. Otherwise you either need to give the system a helping hand, or something clever has to be done.</p>",
        "id": 167966005,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560358221
    },
    {
        "content": "<p>The isomorphism of topological spaces enables you to push one sheaf over to the other space and now we want an isomorphism of sheaves. I don't see the problem but given that transfer seems to be such a key issue I'm still listening. I still believe that given any structure that Lean could make, it should be able to construct the notion of isomorphism between two instances of that structure (modulo possible universe issues)</p>",
        "id": 167967909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560359809
    },
    {
        "content": "<p>How should the transfer tactic realise that an isomorphism of LRS requires an isomorphism between <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>f</mi><mo>∗</mo></msub><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">f_* \\mathcal{O}_X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.175696em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>Y</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.22222em;\">Y</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span>, instead of an equality?</p>",
        "id": 167968108,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560359951
    },
    {
        "content": "<p>I've got <code>(X Y : LRS)</code>. I'm a robot. I need to figure out what is an isomorphism between <code>X</code> and <code>Y</code>. Well... an <code>LRS</code> consists of a topological space, a sheaf on that space, and some other junk.<br>\nGreat, I figure out what is an isomorphism of topological spaces. So I decide that an isom of <code>LRS</code>s consists of a topological isom <code>f : X.carrier \\iso Y.carrier</code>. Using generic transfer blabla, this allows me to transfer the sheaf <code>X.sheaf</code> from <code>X.carrier</code> to <code>Y.carrier</code> along <code>f</code>. Now, I've got two terms of type <code>sheaf Y.carrier</code>. I decide that it is very reasonable that these two terms should be equal.<br>\nFinally, this equality trivially preserves all the other junk. I have figured out what an isomorphism between <code>X</code> and <code>Y</code> is.<br>\nI'm a robot.</p>",
        "id": 167968506,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560360232
    },
    {
        "content": "<p>Well there are <code>Type</code>s inside <code>sheaf</code>, so presumably you would need to construct a notion of \"equal\" that doesn't involve literal equality of types</p>",
        "id": 167968727,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560360368
    },
    {
        "content": "<p>by induction over the syntax of the structure</p>",
        "id": 167968737,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560360382
    },
    {
        "content": "<p>This very much feels like reinventing HoTT's transport.</p>",
        "id": 167968779,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560360418
    },
    {
        "content": "<p>That is kind of the goal, right?</p>",
        "id": 167969474,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560360900
    },
    {
        "content": "<p>Hmmm... maybe it does work.</p>",
        "id": 167970737,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560361727
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"210057\">@Fabian Glöckle</span> How hard would it be for you to automatically generate such an <code>equiv</code> for an arbitrary structure using the framework that you have so far?</p>",
        "id": 167970792,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560361778
    },
    {
        "content": "<p>A difference is that in HoTT the equality is an intrinsic part of the theory, while here we're trying to emulate it by meta-level considerations, building up by induction on the structure what we expect the right interpretation of \"equality\" to be.</p>",
        "id": 167974907,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560364582
    },
    {
        "content": "<p>Equality of types in HoTT is not <em>defined</em> to be isomorphism any more than equality of ordered pairs is defined to be equality of each component</p>",
        "id": 167974932,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560364610
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> did someone progress on this while I was away?</p>",
        "id": 168673712,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1561116965
    },
    {
        "content": "<p>I didn't. I think it's at the same point it was before</p>",
        "id": 168677105,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1561120411
    },
    {
        "content": "<p>OK so we have <a href=\"https://github.com/leanprover-community/mathlib/blob/5a48be3e29dacbb2f02071db4749dcdfa74fb79d/src/measure_theory/bochner_integration.lean#L83\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/5a48be3e29dacbb2f02071db4749dcdfa74fb79d/src/measure_theory/bochner_integration.lean#L83\">Bochner integration in Lean</a>! This work has helped me to formalise a question which might be related to this transfer/transport stuff.</p>\n<p>Let's say I have a smart computer scientist undergrad who is intested in analysis and logic, and wants to do something cool in Lean. Say they read this thread and then say to me \"This Bochner integral definition -- it mentions the real numbers, and in Lean the real numbers are defined to be the Cauchy reals. Do you think it would be interesting to port the entire Bochner integral definition over to the Dedekind reals? Here's my plan. First I write an interface with Dedekind reals at the back end, providing an interface to exactly those functions and definitions and other things that are in the <code>real</code> namespace the moment the real numbers are defined in Lean (as Cauchy reals). The proofs should then barely need modifying, and everything should just port over\". And I say \"sounds great, go ahead\" and I think \"I knew this transport stuff was easy\". A week later the student comes back and says that they have run into trouble. Turns out that some of the maps between Cauchy and Dedekind reals were noncomputable, the API for the Cauchy reals built with the Dedekind reals as backend is also noncomputable, all the proofs have ported beautifully but then loads of them don't work because sometimes computer scientists used <code>simp</code> which used to work but didn't any more because of some computability issue. We then come onto the chat asking how we can fix the proof and deduce our Bochner integral thing for the Dedekind reals. We are fine if everything is noncomputable by the way -- we are mathematicians. Feel free to use all your axioms.</p>",
        "id": 170762941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562973968
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> does the above post make any sense?</p>",
        "id": 170763114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562974276
    },
    {
        "content": "<p>I don't get why computability becomes an issue. I see why the transport might be non-computable but since you're accepting that, what's the problem?</p>",
        "id": 170763329,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1562974628
    },
    {
        "content": "<p>Could this approach actually work to port the Bochner stuff over to Dedekind reals?</p>",
        "id": 170763488,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562974828
    },
    {
        "content": "<p>Surely some of the functions defined in the API for data.real.basic will allow some kind of computational reductions which the analogous objects in the Dedekind-backend reals would not satisfy, so some <code>rfl</code> proofs might break? Or am I talking nonsense?</p>",
        "id": 170763574,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562974985
    },
    {
        "content": "<p>I'm no logician</p>",
        "id": 170763598,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562975015
    },
    {
        "content": "<p>Your concern is theoretically justified, but you should replace <code>simp</code> in the example with <code>rfl</code> or <code>dsimp</code></p>",
        "id": 170763649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562975080
    },
    {
        "content": "<p>The proofs that were going to break <em>did</em> break, and were fixed, when real was made irreducible</p>",
        "id": 170763670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562975124
    },
    {
        "content": "<p>it basically makes it impossible to prove facts about real numbers by rfl</p>",
        "id": 170763674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562975138
    },
    {
        "content": "<p>so now (in theory) you could completely swap out the definition of reals with something else and fix the API theorems and nothing further should break</p>",
        "id": 170763727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562975198
    },
    {
        "content": "<p>How do I know that some rogue proof didn't unfold <code>real</code>?</p>",
        "id": 170763729,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562975204
    },
    {
        "content": "<p>you have to write some really horrible looking tactic code to unfold real</p>",
        "id": 170763740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562975227
    },
    {
        "content": "<p>I'll get Chris onto it.</p>",
        "id": 170763744,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562975238
    },
    {
        "content": "<p>So it's not impossible, but a proof that does this is visibly ugly</p>",
        "id": 170763798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562975285
    },
    {
        "content": "<p>You have to write some really horrible looking maths to say anything about the real numbers for which the answer would be different for Dedekind cuts and Cauchy sequences.</p>",
        "id": 170763800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562975292
    },
    {
        "content": "<p>A proof that did that would be visibly weird.</p>",
        "id": 170763809,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562975310
    },
    {
        "content": "<p>In fact a proof which used anything other than the Officially Mathematically Sanctioned Axioms For The Real Numbers, which is something about them being some complete archimedean field, would be visibly ugly.</p>",
        "id": 170763847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562975392
    },
    {
        "content": "<blockquote>\n<p>So it's not impossible, but a proof that does this is visibly ugly</p>\n</blockquote>\n<p>I think that you should then replace <code>real</code> by a constant and just provide an API to the proof that they satisfy those complete archimedean field axioms.</p>",
        "id": 170764043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562975686
    },
    {
        "content": "<p>Then you'd know that you could not fall off the straight and narrow.</p>",
        "id": 170764056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562975710
    },
    {
        "content": "<p>Computer-generated tactics of the future might unfold <code>real</code></p>",
        "id": 170764149,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562975840
    },
    {
        "content": "<p>Yes, it would be nice if we could do this in lean. Unfortunately the only way to truly be bulletproof is to use a constant and that pollutes the <code>#print axioms</code> list (and requires people to be careful not to introduce unsoundness)</p>",
        "id": 170764295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562976010
    },
    {
        "content": "<p>Isn't the bulletproof way just to define a complete archimedean field typeclass? the reals would just be an alias for a declaration of a type and the associated instance</p>",
        "id": 170764411,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1562976211
    },
    {
        "content": "<p>maybe not. I just googled the topic and came up with a paper where people have all sorts of axioms for the real numbers</p>",
        "id": 170764498,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1562976332
    },
    {
        "content": "<p><a href=\"https://arxiv.org/pdf/1402.6645.pdf\" target=\"_blank\" title=\"https://arxiv.org/pdf/1402.6645.pdf\">https://arxiv.org/pdf/1402.6645.pdf</a></p>",
        "id": 170764500,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1562976333
    },
    {
        "content": "<p>Should we make the construction of the localization of a ring at a submonoid irreducible as well?</p>",
        "id": 170765309,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562977559
    },
    {
        "content": "<p>There's another approach. You could make <code>real</code> into a structure that contains it's construction. Then, you have to use introduction and elimination rules to work on the construction</p>",
        "id": 170766094,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1562978707
    },
    {
        "content": "<p>Let's say that this summer I get a beginner Lean student to formalise the statement of the Birch and Swinnerton-Dyer conjecture (BSD), which says that for every cubic equation in two variables with rational coefficients,  the behaviour of the set of rational solutions of the equation is related to a value of a certain complex function which depends on the equation. The student certainly doesn't write any weird meta code and doesn't unfold any definitions of real. Note that they do use the complex numbers though, so they do use <code>real</code>. And let's say that I get a second student working on a Dedekind real library for Lean and they get some kind of regular expression going which automatically ports a bunch of mathlib over to the Dedekind reals, including the statement of BSD.</p>\n<p>Let's then say that in 2020 some team led by Christian Szegedy at  Google announces a fully formalised AI-generated incomprehensible long Lean 3.4.2 proof of BSD as formalised by my Cauchy student. My Dedekind student attempts to apply the regex to port the proof over to the Dedekind reals, but the port fails because it turns out that Szegedy has unfolded the reals in his proof for performance reasons.</p>\n<p>Do we know for sure in this situation that there is a Lean proof of BSD for Dedekind reals?</p>",
        "id": 170784613,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563014138
    },
    {
        "content": "<p>Isn't your last statement Kevin an essentially purely \"conventional\" mathematical question? something like \"(All with normal set-theory): If there exists a proof of a particular proposition P involving real numbers:</p>\n<ul>\n<li>but whose statement requires only certain axiomatised properties of the reals which we can write down in a list and agree on,</li>\n<li>and whose proof proceeds by using Cauchy-reals (meant just as some definition in terms of sets),</li>\n</ul>\n<p>does there exist a proof of the same fact which uses Dedekind-reals?\"</p>\n<p>In which case, surely the answer is \"it depends on the strength of the list of axioms which we can agree on\".</p>",
        "id": 170785860,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1563016645
    },
    {
        "content": "<p>My question is completely precise and does not depend on conventions. I completely agree that there is an analogous question in ZFC.</p>",
        "id": 170786610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563018226
    },
    {
        "content": "<p>In particular we don't have to have any sort of debate beforehand. For the Lean question I'm talking about a Lean proof and for the ZFC question I'm talking about a proof in eg Mizar. The basic question is whether a conjecture whose statement can be written using only the usual interface but whose proof might not follow this rule can always be ported to the Dedekind case because of some general theorem of logic</p>",
        "id": 170791236,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563026848
    },
    {
        "content": "<p>I can envisage how the ZFC proof might go but I'm less good at type theory</p>",
        "id": 170795943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563034819
    },
    {
        "content": "<p>Yes, provided the statement itself falls within the \"mathematically acceptable\" subset, you can translate the \"BSD for cauchy reals\" statement to \"BSD for dedekind reals\", and they will be provably equivalent using transfer theorems</p>",
        "id": 170800448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563042822
    },
    {
        "content": "<p>For comparison, the proof of dirichlet's theorem in lean via metamath has a similar flavor. The proof uses some crazy techniques using some completely different notion of reals, natural numbers, etc, but because the statement is comprehensible you can just translate the predicates across until you get the conventional lean statement.</p>",
        "id": 170800506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563042915
    },
    {
        "content": "<p>For the transfer tactic to work one needs to ensure that every single thing you can do for the Cauchy reals has some sort of analogue for the Dedekind reals.  Does the proof of this start something like \"we replace Cauchy reals with Dedekind reals, we replace the constructor with a function which takes a Cauchy sequence and returns the corresponding Dedekind limit, and we replace the eliminator with the function which takes the same inputs as the Cauchy eliminator and returns a function from the Dedekind reals instead\". But then how do you prove that the proof still works? Switching out the constructor and eliminator so they work for Dedekind reals instead is easy, you just use the equiv between Cauchy and Dedekind reals. But now there must be something to do to check that the corresponding term has the appropriate type.</p>",
        "id": 170805562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563052572
    },
    {
        "content": "<p>I don't follow - why can't you rely on Lean to typecheck the transferred expression for you?</p>",
        "id": 170807378,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563056182
    },
    {
        "content": "<p>Maybe my understanding of what <code>transfer</code> does is flawed. I think about it in terms of a specialized source-to-source transpiler. What comes out is just another Lean <code>expr</code> that will by typechecked by Lean itself.</p>",
        "id": 170807955,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563057465
    },
    {
        "content": "<blockquote>\n<p>For the transfer tactic to work one needs to ensure that every single thing you can do for the Cauchy reals has some sort of analogue for the Dedekind reals.</p>\n</blockquote>\n<p>No, what is needed is only that everything mathematically reasonable that you can do to the Cauchy reals has an analogue. If in this Szegedy fictional proof other things that aren't mathematically reasonable are exploited, it doesn't matter for the transfer. Since the resulting theorem (BSD) is a mathematically reasonable proposition, you should be able to translate it</p>",
        "id": 170811373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563064958
    },
    {
        "content": "<p>You aren't transferring the proof, you are transferring the statement</p>",
        "id": 170811378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563064999
    },
    {
        "content": "<blockquote>\n<p>Does the proof of this start something like \"we replace Cauchy reals with Dedekind reals, we replace the constructor with a function which takes a Cauchy sequence and returns the corresponding Dedekind limit, and we replace the eliminator with the function which takes the same inputs as the Cauchy eliminator and returns a function from the Dedekind reals instead\". But then how do you prove that the proof still works?</p>\n</blockquote>\n<p>For simple proofs, where the proof itself is entirely mathematically reasonable, then this works. But it's not foolproof, and can break proofs that unfold <code>real</code>.</p>\n<p>For complicated proofs, we aren't shifting anything under the foundation of the proof itself at all. We just use the statement \"BSD is true for cauchy reals\" as is, without inspecting or modifying the proof in any way. The idea is to prove statements of the form \"P is true for cauchy iff P' is true for dedekind\" where P and P' are analogous</p>",
        "id": 170813312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563068933
    },
    {
        "content": "<p>I am currently a bit confused about what the straight answer is to my straight question. If I have a Lean-formalised mathematical conjecture about complete ordered archimedean fields (i.e. about all constructions of the real numbers) and if I have a possibly \"mathematically unreasonable\" but Lean-accepted proof of this conjecture in the special case of the Cauchy reals, it is a theorem that there exists a Lean-accepted proof of the special case of Dedekind reals? If so, what is the proof? Secondly, were I to present such a conjecture and (1000 line long) proof for the Cauchy reals, what needs to be done in practice to get a proof for the Dedekind reals?</p>",
        "id": 170836123,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563114579
    },
    {
        "content": "<p>Here's another question. The Bochner integral is defined in Lean using the Cauchy reals. What if I want a version for Dedekind reals? The analogous function but in the Dedekind situation. Again this is a very precise question -- as far as I can see -- I would like to generate the term which would have been made if <code>real</code> had been defined using the Dedekind reals.</p>",
        "id": 170836741,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563115735
    },
    {
        "content": "<blockquote>\n<p>If so, what is the proof?</p>\n</blockquote>\n<p>We can prove today that \"BSD for cauchy reals holds iff BSD for dedekind reals holds\", so if we get any proof, even an unreasonable one, of BSD for cauchy reals, by composing it with this we get a proof of BSD for dedekind reals.</p>\n<blockquote>\n<p>Here's another question. The Bochner integral is defined in Lean using the Cauchy reals. What if I want a version for Dedekind reals? The analogous function but in the Dedekind situation. Again this is a very precise question -- as far as I can see -- I would like to generate the term which would have been made if real had been defined using the Dedekind reals.</p>\n</blockquote>\n<p>There are a few kinds of definitions based on reals. Some of them don't actually depend on it being any kind of reals, for example you can replace \"real is an ordered field\" with \"real' is an ordered field\" reusing the same predicate \"ordered field\".  Other definitions have the reals embedded inside; for example the Bochner integral is defined for functions over a real vector space, and so you would need Bochner' integral defined for functions over a real' vector space. The only proofs that have to be translated are those that are involved in stating the theorem, and they can either be translated similarly by replacing real with real' everywhere, or they can be explicitly transferred by proving that all sub-formulas of the statement of the theorem hold for real' iff they hold of real.</p>",
        "id": 170838412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563119128
    },
    {
        "content": "<blockquote>\n<p>We can prove today that \"BSD for cauchy reals holds iff BSD for dedekind reals holds\"</p>\n</blockquote>\n<p>What is the proof of that?</p>\n<p>You are talking again and again about transferring statements, but I want to see how to transfer a proof, especially a proof which we cannot guarantee is \"normal\". Regarding translating the Bochner integral function, I can see that this is possible in theory because no way will there be any weird real-unfolding, but I can't imagine how to do it in practice.</p>",
        "id": 170844273,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563130598
    },
    {
        "content": "<p>you can't give a 1-line explanation, the algorithm involved is hairy, but if you want to read a paper about it, try this one: &lt;deleted, see below&gt;</p>",
        "id": 170844788,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563131548
    },
    {
        "content": "<p>there are differences between the paper I linked which is in Coq and the <code>transfer</code> tactic from isabelle which we are trying to port to Lean, but I can't say what they are...</p>",
        "id": 170845761,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563133343
    },
    {
        "content": "<p>What is this random paper? It has no date or hint about where it was/will be published. Is it OK? By default I tend to be skeptical about random pdfs on the internet (I've seen a lot of crap maths). Just paranoid by default. I find computer science papers hard to read. I am looking for a theorem and a proof. The theorem says that something can <em>always</em> be done (X_for_Cauchy -&gt; X_for_Dedekind), the paper says \"we describe a new tactic\". I guess our two cultures think about these things differently.</p>",
        "id": 170846701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563134944
    },
    {
        "content": "<p>ahh, perhaps a better link would be to it's home in the Journal of Formalised Reasoning</p>",
        "id": 170846775,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563135045
    },
    {
        "content": "<p>apparently I linked a pre-print</p>",
        "id": 170846777,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563135050
    },
    {
        "content": "<p><a href=\"https://jfr.unibo.it/article/view/1574\" target=\"_blank\" title=\"https://jfr.unibo.it/article/view/1574\">https://jfr.unibo.it/article/view/1574</a></p>",
        "id": 170846779,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563135051
    },
    {
        "content": "<p>or something, weird</p>",
        "id": 170846788,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563135064
    },
    {
        "content": "<p>I am not sure where the theorem you want is stated, we'll just have to wait for a type theory specialist to chime in.</p>",
        "id": 170846916,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563135247
    },
    {
        "content": "<p>What would a proof look like, though? The basic idea of the tactic  is: define an equivalence relation for the two isomorphic types you are interested in. For the reals, this relation would be based on the axioms of a complete ordered field. For the more advanced objects you work with, the \"Strickland\" predicates you have on defined on various unnamed types. Then, mechanically go through each proof. For each definition or proof used on one type, generate a proof obligation that it is a morphism and substitute.</p>",
        "id": 170847168,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563135697
    },
    {
        "content": "<p>If you write some definition or function that is not a morphism, this tactic will fail, and you'll be stuck.</p>",
        "id": 170847219,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563135738
    },
    {
        "content": "<p>X_for_Cauchy -&gt; X_for_Dedekind is false in general</p>",
        "id": 170847383,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563136035
    },
    {
        "content": "<p>Under what circumstances is X_for_Cauchy -&gt; X_for_Dedekind always true? Only if for each definition or function used in X, it is defined only in terms of the axioms of a complete archimedian field, which are the properties shared by both, or if we can derive complete_arch_field -&gt; (X_for_Cauchy /\\ X_for_Dedekind) . So for mathlib's reals, if we try and transfer a certain definition over the Cauchy reals to the Dedekind reals, that depends on construction details of the Cauchy reals, we won't be able to because we won't be able to prove that it is a morphism. It just won't type-check.</p>",
        "id": 170847452,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563136102
    },
    {
        "content": "<p>ps: this is extremely tedious. If you thought adding additional functions to your baby <code>ring</code> tactic was a pain, this dials it up to 11 if you are working with a complex, many-propertied object. This is a generalization of the method of how ring works.</p>",
        "id": 170848215,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563137149
    },
    {
        "content": "<p>If at all possible if you know you want to reason about many kinds of isomorphic objects, define the appropriate equivalence class and work with that instead as soon as possible.</p>",
        "id": 170848433,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563137408
    },
    {
        "content": "<p>I think you guys are always thinking about the details of the construction. I can quite believe it's difficult. I'm trying to understand this \"Stricklandization\" way of thinking. But there is also a <em>theorem</em> somewhere which says that if X is a true/false statement about compete ordered Archimedean fields then X is true for Cauchy reals iff it's true for Dedekind reals. I was hoping for a reference for this. There might be some analogous theorems about localisations or kaehler one forms, and these are the things I'm really interested in, but it's easier to talk about real numbers because more people know what they are</p>",
        "id": 170850123,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563139913
    },
    {
        "content": "<p>Yes? This is the Liskov substitution principle. <a href=\"https://en.wikipedia.org/wiki/Liskov_substitution_principle\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Liskov_substitution_principle\">https://en.wikipedia.org/wiki/Liskov_substitution_principle</a></p>",
        "id": 170853627,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563146729
    },
    {
        "content": "<p>summoning <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> because I have no idea if this has a formal proof in CIC</p>",
        "id": 170854045,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563147512
    },
    {
        "content": "<p>Ah, nevermind, that isn't the proof you're looking for. I haven't been able to find anything about the theorem as stated, except that it's unprovable by computers and equivalent to the halting problem in general, if you're willing to write a degenerate enough proposition that depends on the truth or falsity of, say, the Goldbach conjectures. But that says nothing about if it exists or not in all cases.</p>",
        "id": 170865229,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563168500
    },
    {
        "content": "<p>Is there already an established name for these sort of predicates? Otherwise I propose to call them <em>characteristic predicates</em>.</p>",
        "id": 170905337,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563205585
    },
    {
        "content": "<p>Apparently in type theory we call \"complete archimedean field\" a type and the cauchy, dedekind reals a \"(strong) behavioral subtype\".</p>",
        "id": 170907863,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563207309
    },
    {
        "content": "<p>The process of deducing isomorphism invariant properties is called \"interface extraction\" as in <a href=\"https://refactoring.guru/extract-interface\" target=\"_blank\" title=\"https://refactoring.guru/extract-interface\">https://refactoring.guru/extract-interface</a> . (I guess in Rust this would be \"extract trait\". In Python this would be defining an abstract base superclass.)</p>",
        "id": 170907910,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563207345
    },
    {
        "content": "<p>and I looked some more and I found people saying that the Liskov substitution principle is actually necessary and sufficient for the theorem Kevin wanted, but I can't find a formulation explicitly in the terms he gave (that is, getting rid of all the programming related statements and deriving it purely in proof-theoretical terms). I would be shocked if it wasn't in the type theory literature somewhere, though.</p>",
        "id": 170908173,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563207496
    },
    {
        "content": "<p>I couldn't work out how to get Liskov substitution to do it. There must be more details which I'm missing.</p>",
        "id": 170908782,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563207936
    },
    {
        "content": "<p>I might ask a more mathsy version of my question on mathoverflow to see what the logicians make of it. They speak a language closer to my own.</p>",
        "id": 170908860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563207975
    },
    {
        "content": "<p>I can get behind characteristic predicate, it's shorter than \"isomorphic invariant properties\"</p>",
        "id": 170910553,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563209308
    },
    {
        "content": "<p>not by much, though</p>",
        "id": 170910638,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563209370
    },
    {
        "content": "<p>it's also less creepy than the category theory term \"skeletonization\"</p>",
        "id": 170910902,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563209549
    },
    {
        "content": "<p>Should we also have a \"characteristic predicate\" for constructions like <code>mv_polynomial</code>?</p>",
        "id": 170917699,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563214478
    },
    {
        "content": "<p>Do we need one? One thing (unrelated to transfer) about mv_polynomial is that I think someone should take a look at what instances are defined on it, and ask if they have sensible priorities</p>",
        "id": 170920311,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563216386
    },
    {
        "content": "<p>The proof of X_for_Cauchy &lt;-&gt; X_for_Dedekind depends on X and is not always true. It is true for what I am calling \"mathematically reasonable\" propositions to mimic your claims about things mathematicians refuse to do with their language, but that term is also deliberately vague so that there is no general metatheorem being applied here</p>",
        "id": 170926736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563220974
    },
    {
        "content": "<p>So the Liskov substitution principle is necessary and sufficient for Hoare logic according to Wikipedia. Is there something analogous for the calculus of inductive constructions?</p>",
        "id": 170927882,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563221864
    },
    {
        "content": "<p>I figure it ought to be simpler since there's no mutability, but I'm not a type theorist..</p>",
        "id": 170927965,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563221901
    },
    {
        "content": "<p>The substitution principle in this generality is basically HoTT's domain. If you require it for all predicates then you can easily show it's equivalent to saying \"Cauchy_reals = Dedekind_reals\"</p>",
        "id": 170928369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563222197
    },
    {
        "content": "<p>I can see how that makes sense. The only way to get 100% semantic equality would be for the two types to be exactly the same.</p>",
        "id": 170928530,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563222351
    },
    {
        "content": "<p>I actually don't mean exactly the same, I mean equal according to the = predicate in DTT, which as you know is a more subtle thing</p>",
        "id": 170928771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563222527
    },
    {
        "content": "<p>And in HoTT the difference between = and defeq is center stage</p>",
        "id": 170928793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563222560
    },
    {
        "content": "<p>But something funny is going on here because we're not using HoTT and it <em>is</em> true that for \"mathematically reasonable statements\" they're true for the Cauchy reals iff they're true for the Dedekind reals, so something is missing from my understanding. I asked at MO and, as is unfortunately sometimes the case with logic questions, I've caused a great deal of noise :-/ <a href=\"https://mathoverflow.net/questions/336191/cauchy-reals-and-dedekind-reals-satisfy-the-same-mathematical-theorems\" target=\"_blank\" title=\"https://mathoverflow.net/questions/336191/cauchy-reals-and-dedekind-reals-satisfy-the-same-mathematical-theorems\">https://mathoverflow.net/questions/336191/cauchy-reals-and-dedekind-reals-satisfy-the-same-mathematical-theorems</a></p>",
        "id": 170939770,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563232016
    },
    {
        "content": "<p>I think the answer is buried there, though, in one comment. <a href=\"https://math.stackexchange.com/questions/437948/do-isomorphic-structures-always-satisfy-the-same-second-order-sentences\" target=\"_blank\" title=\"https://math.stackexchange.com/questions/437948/do-isomorphic-structures-always-satisfy-the-same-second-order-sentences\">https://math.stackexchange.com/questions/437948/do-isomorphic-structures-always-satisfy-the-same-second-order-sentences</a>. The answer is true for 1st-order propositions, and false for higher order.</p>",
        "id": 170940850,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563233066
    },
    {
        "content": "<p>I'm hoping I can get Noah Schweber to write more details. I feel like we're making progress in the sense that I'm learning something.</p>",
        "id": 170941048,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563233324
    },
    {
        "content": "<p>noah's sketch seems like the \"just transfer the higher-order statements you need\" approach (he's probably adding extra sorts so he can quantify over things like subsets) but with more bookkeeping (this is probably the path to a uniform transfer theorem for constructions of CAOFs)</p>\n<p>amusingly, terry tao is essentially recommending that we just roll with a CAOF typeclass</p>",
        "id": 170941657,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1563233979
    },
    {
        "content": "<p>What's a CAOF typeclass?</p>",
        "id": 170941863,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563234167
    },
    {
        "content": "<p>the hypothetical typeclass for complete archimedean ordered fields, so that every instance of it corresponds to an interpretation of the generic symbol <strong>R</strong> mentioned by terry in his comment</p>",
        "id": 170941964,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1563234295
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116045\">@Jesse Michael Han</span>  Why is the typeclass hypothetical? It's easy to write down several variants.</p>",
        "id": 170943622,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1563236364
    },
    {
        "content": "<p>The typeclass approach isn't quite flexible enough, because of the need to deal with n-ary predicates with a variety of different relations between objects at the same time</p>",
        "id": 170945462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563238807
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span>  it's hypothetical because i don't think anyone's PR'd it to <code>mathlib</code> yet :^)</p>\n<p>but indeed it shouldn't be difficult</p>",
        "id": 170945476,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1563238844
    },
    {
        "content": "<p>oops, spoke too soon. It's possible to have a typeclass for \"real-like thing\" but we are embedding it in definitions <em>exactly because</em> we are not anticipating to change the definition of the reals any time soon</p>",
        "id": 170945495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563238882
    },
    {
        "content": "<p>Ah, got it. In that case, let me record my favorite version: R is the terminal object in the category of archimedean ordered fields.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">real_field</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">linear_ordered_field</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">archimedean</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">term</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_field</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">archimedean</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">is_field_hom</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>It's a bit harder to get off the ground with this one, but it's very entertaining to see how it works. (The restriction to Type is not a typo. Archimedean ordered fields are so fantastically rigid, this is enough to ensure that this is a terminal object for all universe levels.)</p>",
        "id": 170947169,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1563241366
    },
    {
        "content": "<p>I answered <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s question on MO but in the context of ZFC. In the context of Lean, having a real typeclass is the best since that will make transfer happen automatically. That said, mathlib's current reals are essentially harmless. As I explained on MO, to transfer a theorem about reals (or whatever) the only key ingredient is that the _statement_ only mentions equality and external structure between real numbers and never looks under the hood at the innards. Because mathlib's reals are opaque, it's really hard to write anything that uses the innards of mathlib's reals. Nevertheless, opaque is quite a few shades lighter than pitch black... I am still very comfortable to assert that mathlib's reals are 99.9999% transferable. The main reason I feel so comfortable is that mathlib's reals are basically computationally useless, so I doubt anyone would have had the idea to breach the opaqueness barrier unless it was absolutely necessary.</p>\n<p>The same kind of trick I mentioned on MO works for Lean but it's a much harder argument involving carefully crafted comma category-like stuff and such. I had a similar thing come up recently and I ran out of steam before I could even write down what needed to be done. This is really hard work but it's a one-time deal, so it might be worth it. (I do not have time to do it.)</p>",
        "id": 170950893,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1563247279
    }
]
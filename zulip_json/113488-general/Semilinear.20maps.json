[
    {
        "content": "<p>For a while now, the fact that mathlib doesn't have conjugate linear maps has been blocking progress. For example, the map that takes an operator to its adjoint on a complex Hilbert space is a conjugate linear map, and so is the Riesz representation. This also prevents us from developing the orthogonal group, the unitary group, etc, properly. (See <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear\">here</a> for a discussion of this issue.)</p>\n<p><a href=\"#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class/near/214442983\">Last October</a>,  <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>  proposed a solution involving redefining linear maps to be semilinear maps. A semilinear map <code>f</code> is a map from an <code>R</code>-module to an <code>S</code>-module with a ring equivalence <code>σ</code>between <code>R</code> and <code>S</code>, such that <code>f (c • x) = (σ c) • (f x)</code>. If we plug in the identity into <code>σ</code>, we get regular linear maps, and if we plug in the complex conjugate, we get conjugate linear maps. There are also other examples (e.g. Frobenius-linear maps) where this is useful which are covered by this general formulation.</p>\n<p>Now, together with <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>  and <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> , we have implemented this idea on a ~1-month old version of mathlib! The result can be found on branch <code>semilinear-option2</code>. The main issue that we had to overcome involved composition of such maps, and <code>symm</code> for linear equivalences: having things like <code>σ₁₂.trans σ₂₃</code> or <code>σ.symm</code> in the types of semilinear maps creates major problems. For example, we want the composition of two conjugate-linear maps to be a regular linear map, not<br>\na <code>conj.trans conj</code>-linear map. To solve this issue, following a discussion from back in January, we created two typeclasses to make Lean infer the right ring equivalence. The first one is <code>[ring_equiv_comp_triple σ₁₂ σ₂₃ σ₁₃]</code> which expresses the fact that <code>σ₁₂.trans σ₂₃ = σ₁₃</code>, and the second one is <code>[ring_equiv_inv_pair σ₁₂ σ₂₁]</code> which states that <code>σ₁₂</code> and <code>σ₂₁</code> are inverses of each other. Note that (again following <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> 's idea) we have introduced notation to ensure that regular linear maps can still be used as before, i.e. <code>M →ₗ[R] N</code> still works as before to mean a regular linear map.</p>\n<p>This mostly works well (maybe even surprisingly so!). Regular linear maps work essentially the same as<br>\nbefore, and we have a proof-of-concept file that shows how it handles conjugate-linear maps (<code>linear_algebra/conjugate_linear.lean</code>).</p>\n<p>Now, even though overall it works quite well, there is still a small cost to be paid:</p>\n<ol>\n<li>We have phased out the notation <code>M →ₗ N</code> (where the ring is not specified). </li>\n<li>When defining a regular linear map directly using the structure (i.e. when specifying <code>to_fun</code>, <code>map_smul'</code> and so on), there is a <code>ring_equiv.refl</code> that shows up in <code>map_smul'</code>. This can mostly be dsimp'ed away, but is mildly annoying.</li>\n<li>Elaboration seems slightly more brittle, and it fails a little bit more often than before. For example, when <code>f</code> is a linear map and <code>g</code> is something that can be coerced to a linear map (say a linear equiv), one has to write <code>↑g</code> to make it work, or sometimes even to add a type annotation. This also occurs when using <code>trans</code> twice (i.e. <code>e₁.trans (e₂.trans e₃)</code>). To mitigate this problem, we have added new notation for composition of regular linear maps (<code>∘ₗ</code> for <code>comp</code> and <code>≫ₗ</code> for <code>trans</code>). (Note that this is only provided to fix occasional elaboration issues and we don't necessarily expect this to replace <code>comp</code> and <code>trans</code>.)</li>\n<li>It seems to exacerbate the bug discussed <a href=\"#narrow/stream/113488-general/topic/odd.20repeated.20type.20class.20search\">here</a> for reasons that we don't understand all that well right now. It manifests itself in very slow calls to the tactic <code>ext</code>, and the quick fix is to manually use the right ext lemma.</li>\n<li>A few random other issues that didn't arise often enough to see a pattern.</li>\n</ol>\n<p>We would of course be very interested in PRing this to mathlib, and since this is such a big change we would like to solicit discussion here before actually going through with this.</p>\n<p>Any thoughts?</p>",
        "id": 250028000,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1629398000
    },
    {
        "content": "<p>Point 1 is no issue at all. I didn't even remember that notation existed. Point 2 seems very minor. Points 3 to 5 are extremely hard to evaluate without using the new setup.</p>",
        "id": 250030002,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1629398907
    },
    {
        "content": "<p>Note also that the elaboration issue may change in Lean 4. I have no idea whether it would become better or worse.</p>",
        "id": 250030163,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1629398978
    },
    {
        "content": "<p>Is there a particular reason why you want to use a ring equivalence as opposed to just a ring hom?</p>",
        "id": 250030284,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629399020
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Semilinear maps over a ring hom behave badly for certain constructions, in particular <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.map\">docs#submodule.map</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.range\">docs#linear_map.range</a>.  It's not impossible to do the generalization to ring homs, but it's a lot less lightweight.</p>",
        "id": 250030458,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629399116
    },
    {
        "content": "<p>I'm mostly thinking of some examples from number theory... for example you might want to consider Frobenius semilinear maps over a non-perfect field.</p>",
        "id": 250030579,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629399157
    },
    {
        "content": "<p>It would be a shame to do such a massive refactor only to find out that it's not general enough to cover natural examples</p>",
        "id": 250030697,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629399213
    },
    {
        "content": "<p>In particular, whenever <code>map</code> or <code>range</code> appear in a proof, you have to bump up your assumptions to the ring hom being a ring equiv (well, a one-sided equiv is enough ...). So you get <code>include ...</code> and <code>omit ...</code> everywhere.</p>",
        "id": 250030811,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629399250
    },
    {
        "content": "<p>I tried it at <a href=\"https://github.com/leanprover-community/mathlib/tree/semilinear5\">branch#semilinear5</a> if you're curious. (see this commit<br>\n<a href=\"https://github.com/leanprover-community/mathlib/commit/a3a1cfc7accf602f92cd5e0e52a72bfce4735072\">https://github.com/leanprover-community/mathlib/commit/a3a1cfc7accf602f92cd5e0e52a72bfce4735072</a> ) ... but got bored halfway through <code>linear_algebra.basic</code></p>",
        "id": 250030852,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629399269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/Semilinear.20maps/near/250030697\">said</a>:</p>\n<blockquote>\n<p>It would be a shame to do such a massive refactor only to find out that it's not general enough to cover natural examples</p>\n</blockquote>\n<p>I don't think the current version would preclude generalizing further to ring homs someday; the two tasks are basically independent.  One mathlib has the ring equiv generalization, if you want to further generalize to ring homs, find-and-replacing most of the <code>R ≃+* R₂</code> in the library to  <code>R →+* R₂</code> is the easy part, the hard part is fixing every proof involving <code>map</code>.</p>",
        "id": 250031908,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629399649
    },
    {
        "content": "<p>Why would you need <code>include</code> / <code>omit</code> vs just a cast from a <code>ring_equiv</code> to a <code>ring_hom</code>?</p>",
        "id": 250032866,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629399845
    },
    {
        "content": "<p>Yes that's what I was about to say. How hard would it be to setup the def to use <code>ring_hom</code> and then for the annoying lemmas you assume it's the coercion of some <code>ring_equiv</code> ?</p>",
        "id": 250033230,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1629399965
    },
    {
        "content": "<p>You still have to fix every annoying lemma separately, and that's the big task.  Because in some sections of the library the needs-fixing lemmas are closely interspersed with the don't-need-fixing lemmas.</p>",
        "id": 250033396,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629400026
    },
    {
        "content": "<p>I have a hunch it might be best to setup the def to take just a plain function, for unification reasons</p>",
        "id": 250033483,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629400060
    },
    {
        "content": "<p>Oh okay I see the issue with include and omit now</p>",
        "id": 250033599,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1629400089
    },
    {
        "content": "<p>You would also have to be very careful to ensure that regular linear maps are defined with <code>σ</code> being the coercion from a <code>ring_equiv.refl</code> to a <code>ring_hom</code> and not a <code>ring_hom.id</code>. I'm not sure how annoying this would get.</p>",
        "id": 250033649,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1629400108
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.map\">docs#submodule.map</a> should work whenever you're semilinear over a surjective ring hom. So again even for map using an equivalence is possibly not the right generalization (in my opinion)</p>",
        "id": 250034347,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629400362
    },
    {
        "content": "<p>Right, this is what I was getting at with \"one-sided equiv\"</p>",
        "id": 250034549,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629400431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/Semilinear.20maps/near/250030579\">said</a>:</p>\n<blockquote>\n<p>I'm mostly thinking of some examples from number theory... for example you might want to consider Frobenius semilinear maps over a non-perfect field.</p>\n</blockquote>\n<p>In this example, are the ring homs surjective?</p>",
        "id": 250035550,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629400774
    },
    {
        "content": "<p>No.</p>",
        "id": 250035602,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629400793
    },
    {
        "content": "<p>So presumably one never uses the <code>map</code> construction for them anyway (i.e., we don't know a use case where we'd want <code>map</code> for semilinear maps over a surjective, non-bijective ring hom).</p>",
        "id": 250036012,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629400935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/113488-general/topic/Semilinear.20maps/near/250033649\">said</a>:</p>\n<blockquote>\n<p>You would also have to be very careful to ensure that regular linear maps are defined with <code>σ</code> being the coercion from a <code>ring_equiv.refl</code> to a <code>ring_hom</code> and not a <code>ring_hom.id</code>. I'm not sure how annoying this would get.</p>\n</blockquote>\n<p>This is what I was referring to when I said<br>\n<span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Semilinear.20maps/near/250033483\">said</a>:</p>\n<blockquote>\n<p>I have a hunch it might be best to setup the def to take just a plain function, for unification reasons</p>\n</blockquote>\n<p>You're correct that <code>↑ring_equiv.refl = ring_hom.id</code> is problematic as it is not true by <code>rfl</code>, but <code>⇑ring_equiv.refl = ⇑ring_hom.id</code> does not suffer from the same problem.</p>",
        "id": 250037628,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629401657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/113488-general/topic/Semilinear.20maps/near/250033396\">said</a>:</p>\n<blockquote>\n<p>You still have to fix every annoying lemma separately, and that's the big task.  Because in some sections of the library the needs-fixing lemmas are closely interspersed with the don't-need-fixing lemmas.</p>\n</blockquote>\n<p>If we get the generality of the definition right we can always relax the lemmas about it later</p>",
        "id": 250037715,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629401703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Semilinear.20maps/near/250037628\">said</a>:</p>\n<blockquote>\n<p>You're correct that <code>↑ring_equiv.refl = ring_hom.id</code> is problematic as it is not true by <code>rfl</code>, but <code>⇑ring_equiv.refl = ⇑ring_hom.id</code> does not suffer from the same problem.</p>\n</blockquote>\n<p>Frederic was responding to Anatole's comment.  The natural way in our formalism would be neither, but instead to use two ring homs together with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ring_equiv_inv_pair</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_inv_pair₁</span> <span class=\"o\">:</span> <span class=\"n\">σ'.comp</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">ring_hom.id</span> <span class=\"n\">R₁</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_inv_pair₂</span> <span class=\"o\">:</span> <span class=\"n\">σ.comp</span> <span class=\"n\">σ'</span> <span class=\"bp\">=</span> <span class=\"n\">ring_hom.id</span> <span class=\"n\">R₂</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 250037949,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629401796
    },
    {
        "content": "<p>I guess the idea for writing lemmas that match <code>A →ₗ[⇑σ] B</code> or <code>A →ₗ[↑σ] B</code> would work for the <code>σ : R ≃+* R'</code> case but not for the surjective case <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>  was thinking about, since we don't have bundled surjective maps.</p>",
        "id": 250038586,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629402066
    },
    {
        "content": "<p>Eric, what problem are you trying to address exactly?  The experiment I tried at<br>\n<a href=\"https://github.com/leanprover-community/mathlib/commit/a3a1cfc7accf602f92cd5e0e52a72bfce4735072\">https://github.com/leanprover-community/mathlib/commit/a3a1cfc7accf602f92cd5e0e52a72bfce4735072</a><br>\nfailed for lack of energy, not because there was any technical problem.</p>",
        "id": 250039262,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629402353
    },
    {
        "content": "<p>If we really want to allow for surjective rather than bijective ring homs in <code>submodule.map</code>, then split my typeclass above as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ring_equiv_inv_pair_left</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_inv_pair₁</span> <span class=\"o\">:</span> <span class=\"n\">σ'.comp</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">ring_hom.id</span> <span class=\"n\">R₁</span><span class=\"o\">)</span> <span class=\"c1\">-- `σ` has a left inverse</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ring_equiv_inv_pair_right</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_inv_pair₂</span> <span class=\"o\">:</span> <span class=\"n\">σ.comp</span> <span class=\"n\">σ'</span> <span class=\"bp\">=</span> <span class=\"n\">ring_hom.id</span> <span class=\"n\">R₂</span><span class=\"o\">)</span> <span class=\"c1\">-- `σ` has a right inverse</span>\n</code></pre></div>\n<p>and use only the appropriate one.</p>",
        "id": 250039454,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629402421
    },
    {
        "content": "<p>I'm just exploring the consequences of Adam's suggestion to use <code>ring_hom</code>s, because it was my first thought too. I haven't made any attempt at actually trying to do it or thought of a particularly compelling reason to do so.</p>",
        "id": 250040017,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629402676
    },
    {
        "content": "<p>But at that commit I am using ring homs ...?</p>",
        "id": 250040063,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629402702
    },
    {
        "content": "<p>I think I somehow missed the message where you posted that <code>5</code> branch the first time; apologies!</p>",
        "id": 250040151,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629402740
    },
    {
        "content": "<p>I think if we really want to have <code>ring_hom</code>s instead of <code>ring_equiv</code>s, we'll need to have a few more of these typeclasses to express the fact that they are surjective/bijective/whatever. Having to pass these facts as parameters to every lemma sounds untenable.</p>",
        "id": 250041432,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1629403246
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> If we only need bijective, then nothing needs to change; we can get by with the same two typeclasses <code>ring_equiv_comp_triple</code> and  <code>ring_equiv_inv_pair</code> as before, right?</p>",
        "id": 250042451,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629403687
    },
    {
        "content": "<p>With <code>ring_equiv_inv_pair</code> expressing bijectivity.</p>",
        "id": 250042513,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629403725
    },
    {
        "content": "<p>Well, the case where we only need bijective is basically what we've done. If we want to be able to define linear maps over any <code>ring_hom</code>, with lemmas that only work in specific cases (i.e. when <code>σ</code> is surjective bijective), then I think we need some more typeclasses.</p>",
        "id": 250044285,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1629404624
    },
    {
        "content": "<p>Suppose that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma : A \\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is a morphism of rings and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">B_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> denote the image of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span>.<br>\nLet <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">f : M \\to N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> be a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span>-semilinear map.<br>\nLet <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> be an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-submodule of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>. The image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>H</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(H)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mclose\">)</span></span></span></span> is a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">B_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-submodule of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>. Consider the base-change <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><msub><mo>⊗</mo><msub><mi>B</mi><mn>0</mn></msub></msub><mi>f</mi><mo stretchy=\"false\">(</mo><mi>H</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">B \\otimes_{B_0} f(H)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93343em;vertical-align:-0.2501em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31731428571428577em;\"><span style=\"top:-2.357em;margin-left:-0.05017em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mclose\">)</span></span></span></span> of this <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">B_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-submodule. This is now a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>-module, and it comes equipped with a natural morphism of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>-modules to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>. We can then take the image of this map. In explicit terms, this is going to be the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>-submodule of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> generated by the image of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> as a function. I think this deserves to be the correct generalization of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.map\">docs#submodule.map</a> for a semilinear map, and it doesn't require any further assumptions on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span>.</p>",
        "id": 250047871,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629406563
    },
    {
        "content": "<p>The carrier set will not be defeq to the image of <code>f</code> as a function, of course, but it will be propeq in the case where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span> is surjective.</p>",
        "id": 250047963,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629406617
    },
    {
        "content": "<p>I see, so define <code>submodule.map</code> to have carrier <code>span (f '' H)</code> rather than just <code>f '' H</code>.</p>",
        "id": 250048419,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1629406831
    },
    {
        "content": "<blockquote>\n<p>feat(linear_algebra): introduce notation for linear_map.comp and linear_equiv.trans <a href=\"https://github.com/leanprover-community/mathlib/issues/8857\">#8857</a></p>\n</blockquote>\n<p>is a PR by <span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span>  that prepares the notation changes.</p>",
        "id": 250912255,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630060603
    },
    {
        "content": "<p>I'm in favour of making this change, but it would be good to try to align the notation as much as possible with the notation used in the category theory library.</p>",
        "id": 250912334,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630060654
    },
    {
        "content": "<p>What part of semilinear maps motivated the new notation?</p>",
        "id": 250912447,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630060713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/113488-general/topic/Semilinear.20maps/near/250028000\">said</a>:</p>\n<blockquote>\n<ol start=\"3\">\n<li>Elaboration seems slightly more brittle, and it fails a little bit more often than before. For example, when <code>f</code> is a linear map and <code>g</code> is something that can be coerced to a linear map (say a linear equiv), one has to write <code>↑g</code> to make <code>f.comp ↑g</code> work, or sometimes even to add a type annotation. This also occurs when using <code>trans</code> twice (i.e. <code>e₁.trans (e₂.trans e₃)</code>). To mitigate this problem, we have added new notation for composition of regular linear maps (<code>∘ₗ</code> for <code>comp</code> and <code>≫ₗ</code> for <code>trans</code>). (Note that this is only provided to fix occasional elaboration issues and we don't necessarily expect this to replace <code>comp</code> and <code>trans</code>.)</li>\n</ol>\n</blockquote>",
        "id": 250933134,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1630071721
    },
    {
        "content": "<p>I guess the notation hack </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"n\">f</span> <span class=\"bp\">`∘'`</span> <span class=\"o\">:=</span> <span class=\"n\">f.comp</span>\n</code></pre></div>\n<p>will not help at all with this elaboration issue...</p>",
        "id": 250950479,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1630078854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Semilinear.20maps/near/250912334\">said</a>:</p>\n<blockquote>\n<p>I'm in favour of making this change, but it would be good to try to align the notation as much as possible with the notation used in the category theory library.</p>\n</blockquote>\n<p>Did you have any specific suggestion in mind? In any case I agree; in fact I picked <code> ≫ₗ </code> for <code>trans</code> precisely to look like the category theory notation.</p>",
        "id": 250959686,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1630082820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/Semilinear.20maps/near/250950479\">said</a>:</p>\n<blockquote>\n<p>I guess the notation hack </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"n\">f</span> <span class=\"bp\">`∘'`</span> <span class=\"o\">:=</span> <span class=\"n\">f.comp</span>\n</code></pre></div>\n<p>will not help at all with this elaboration issue...</p>\n</blockquote>\n<p>Not yet :-) But in the upcoming main PR, it will be changed to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">infixr</span> <span class=\"bp\">`</span> <span class=\"bp\">∘ₗ</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">linear_map.comp</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">ring_hom_comp_triple.ids</span>\n</code></pre></div>\n<p>to hardcode the fact that both maps involved are plain linear maps.</p>",
        "id": 250959943,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1630082958
    },
    {
        "content": "<p>Doesn't category theory use something like <code>&lt;&lt;&gt;&gt;</code> (but then the fancy unicode variant)?</p>",
        "id": 250967236,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630086077
    },
    {
        "content": "<p>See right after <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.iso.trans/src\">src#category_theory.iso.trans</a></p>",
        "id": 250967317,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1630086119
    },
    {
        "content": "<p>I see! I took my inspiration from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.category_struct/src\">src#category_theory.category_struct</a>. Maybe the other one would be better.</p>",
        "id": 250971172,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1630087711
    },
    {
        "content": "<p>I have now changed the notation for <code>trans</code> to <code>≪≫ₗ</code>.</p>",
        "id": 251221712,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1630326492
    },
    {
        "content": "<p>People have had a week to complain, so now the notation is consistent, I'm going ahead and merging the PR.</p>",
        "id": 252170559,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630932489
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> I'm doing some preliminary experiments with a <code>is_tensor_product</code> class. So far I'm mostly amazed by how often tensor products have already been used/imported in mathlib.</p>",
        "id": 252287109,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631013057
    },
    {
        "content": "<p>I have now created the main PR for this: <a href=\"https://github.com/leanprover-community/mathlib/issues/9272\">#9272</a>. The main change since the discussion here is that we made it work with <code>ring_hom</code>s instead of <code>ring_equiv</code>s. The diff looks huge but it's not as bad as it looks: almost all of the meat is in <code>algebra/module/basic</code> and <code>linear_algebra/basic</code>, and the rest is small routine fixes.</p>",
        "id": 253906363,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1632013937
    }
]
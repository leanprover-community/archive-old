[
    {
        "content": "<p>Now that we have the <code>ext</code> tactic, let's get started tagging every theorem with <code>@[extensionality]</code> :D</p>",
        "id": 127167357,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527433611
    },
    {
        "content": "<p>All of them?</p>",
        "id": 127168051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527434846
    },
    {
        "content": "<p>I'm not sure there are that many to add</p>",
        "id": 127168090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527434884
    },
    {
        "content": "<p><code>unknown identifier 'ext'</code></p>",
        "id": 127168094,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1527434898
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> trust me, there is a <em>lot</em> to add</p>",
        "id": 127171210,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527441260
    },
    {
        "content": "<p>then PR them</p>",
        "id": 127171211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527441276
    },
    {
        "content": "<p>do you have a nonexhaustive list?</p>",
        "id": 127171213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527441293
    },
    {
        "content": "<p>not really</p>",
        "id": 127171214,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527441298
    },
    {
        "content": "<p>do you have a estimate of the number of files in mathlib</p>",
        "id": 127171222,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527441317
    },
    {
        "content": "<p>or does <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> have some magic to count that</p>",
        "id": 127171224,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527441325
    },
    {
        "content": "<p>I mean, just name a few</p>",
        "id": 127171272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527441411
    },
    {
        "content": "<p>the Z[sqrt(d)] doesn't really have the ext lemma that I want</p>",
        "id": 127171273,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527441423
    },
    {
        "content": "<p>sum, prod</p>",
        "id": 127171279,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527441431
    },
    {
        "content": "<p>I can just name every class I know</p>",
        "id": 127171280,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527441439
    },
    {
        "content": "<p>\"wrong\" is a strong word</p>",
        "id": 127171296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527441482
    },
    {
        "content": "<p>it's not suitable for the <code>ext</code> tactic</p>",
        "id": 127171322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527441498
    },
    {
        "content": "<p>my apologies</p>",
        "id": 127171325,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1527441526
    },
    {
        "content": "<p>Actually it would be great if <code>ext</code> could handle the iff style</p>",
        "id": 127171334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527441556
    },
    {
        "content": "<p>because that's the form that <code>simp</code> likes</p>",
        "id": 127171336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527441589
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span>, what do you think of changing <code>ext</code> so that it fails if it doesn't apply at least one extensionality lemma?  (when given no identifiers)</p>",
        "id": 127525559,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528081744
    },
    {
        "content": "<p>(This just follows the general principle that tactics should not \"fail silently\", as it's harder to manage flow control if they might.)</p>",
        "id": 127525563,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528081775
    },
    {
        "content": "<p>(If it seems reasonable, I'm happy to fix it.)</p>",
        "id": 127525567,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528081783
    },
    {
        "content": "<p>That makes sense. At the same time, that would differ from the behavior of <code>intros</code></p>",
        "id": 127525612,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528081836
    },
    {
        "content": "<p>Basically, you'd like to know when you expect an extensionality lemma but that it's not found. Would it make sense to have a special syntax for that? We could do <code>ext+</code> for \"apply extensionality once or more\" and <code>ext*</code>for \"zero or more times\"</p>",
        "id": 127525713,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528082054
    },
    {
        "content": "<p>My vote would be to change <code>intros</code> too, but it may be too late for that!</p>",
        "id": 127525714,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528082072
    },
    {
        "content": "<p>Well --- is doing something zero or more times ever actually useful? If you're working interactively, you should just remove it, and if you're working programmatically, it's no hassle to handle a failure, and sometimes helpful to know whether or not progress was made.</p>",
        "id": 127525728,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528082137
    },
    {
        "content": "<p>That's a good point</p>",
        "id": 127525769,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528082172
    },
    {
        "content": "<p>I'm in</p>",
        "id": 127525778,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528082218
    },
    {
        "content": "<p>Shall I do it?</p>",
        "id": 127525827,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528082320
    },
    {
        "content": "<p>Yes please</p>",
        "id": 127525830,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1528082338
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/mathlib/pull/151\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/pull/151\">https://github.com/leanprover/mathlib/pull/151</a></p>",
        "id": 127525941,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528082638
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span>, there are lots of lemmas that seem to me natural to have <code>apply</code>d automatically by <code>ext</code>, e.g.:</p>",
        "id": 128115186,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529062034
    },
    {
        "content": "<p><code>lemma pair.ext {α : Type u₁} {β : Type u₂} {X Y : α × β} (p1 : X.1 = Y.1) (p2 : X.2 = Y.2) : X = Y</code></p>",
        "id": 128115188,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529062056
    },
    {
        "content": "<p>or even <code>lemma sigma.ext {α : Type u₁} (Z : α → Type u₂) (X Y : Σ a : α, Z a) (w1 : X.1 = Y.1) (w2 : @eq.rec_on _ X.1 _ _ w1 X.2 = Y.2) : X = Y</code></p>",
        "id": 128115239,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529062127
    },
    {
        "content": "<p>This isn't possible at the moment: <code>ext</code> will happily apply one of these, but then choke because there's nothing to <code>intro</code>.</p>",
        "id": 128115251,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529062153
    },
    {
        "content": "<p>What do you think of generalising a little more?</p>",
        "id": 128115254,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529062165
    },
    {
        "content": "<p>I thought <code>ext</code> does 0+ intros</p>",
        "id": 128115314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529062244
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>import tactic.interactive\n\nuniverses u₁ u₂\n\n@[extensionality] lemma pair.ext {α : Type u₁} {β : Type u₂} {X Y : α × β} (p1 : X.1 = Y.1) (p2 : X.2 = Y.2) : X = Y :=\nbegin\n  induction X, induction Y, dsimp at *, rw p1, rw p2,\nend\n\nlemma P (X Y : ℕ × ℕ) : X = Y :=\nbegin\n  ext,\n\nend\n</pre></div>",
        "id": 128115378,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529062353
    },
    {
        "content": "<p>The <code>ext</code> here does nothing, even though <code>apply pair.ext</code> succeeds.</p>",
        "id": 128115379,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529062379
    },
    {
        "content": "<p>Mario was suggesting we extend <code>ext</code> to support that kind behavior. I think that's doable. I think we'd only have to fix the <code>intro1</code> and change <code>&gt;&gt;</code> for <code>;</code></p>",
        "id": 128116141,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529063659
    },
    {
        "content": "<p>As you say, the intro is mandatory right now</p>",
        "id": 128116157,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529063704
    },
    {
        "content": "<p>I'll have a look</p>",
        "id": 128118149,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529066993
    },
    {
        "content": "<p>Another direction to consider is the following:</p>\n<div class=\"codehilite\"><pre><span></span>meta def applicable_attribute : user_attribute := {\n  name := `applicable,\n  descr := &quot;A lemma that should be applied to a goal whenever possible.&quot;\n}\n\nrun_cmd attribute.register `applicable_attribute\n\n/- Try to apply one of the given lemmas, it succeeds if one of them succeeds. -/\nmeta def any_apply : list name → tactic name\n| []      := failed\n| (c::cs) := (mk_const c &gt;&gt;= apply &gt;&gt; pure c) &lt;|&gt; any_apply cs\n\nmeta def applicable : tactic name :=\ndo cs ← attribute.get_instances `applicable,\n   (any_apply cs) &lt;|&gt; fail &quot;no @[applicable] lemmas could be applied&quot;\n</pre></div>",
        "id": 128120340,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529070035
    },
    {
        "content": "<p>I use this pretty widely: it's for marking lemmas which are so useful that you know they are meant to be applied whenever possible.</p>",
        "id": 128120349,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529070061
    },
    {
        "content": "<p>(<code>subsingleton.elim</code> is an example)</p>",
        "id": 128120358,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529070074
    },
    {
        "content": "<p>I guess there's no reason this can't just coexist with <code>ext</code>, but if you see some reason to try to combine them I'd be interested.</p>",
        "id": 128120370,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529070120
    },
    {
        "content": "<p>That's interesting. I think I would like to preserve <code>ext</code> because it has such a precise meaning but it might be useful to mark all extensionality lemmas as applicable. Is there a way to make one attribute subsume the other?</p>",
        "id": 128120736,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529070610
    },
    {
        "content": "<p>For me it's not really important that one subsumes the other: my intention is just that the default list of tactics for <code>tidy</code> tries <code>applicable</code> first, and then tries <code>ext</code>.</p>",
        "id": 128120773,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529070676
    },
    {
        "content": "<p>(I've also got a tactic <code>semiapplicable</code>, which tries applying lemmas marked <code>semiapplicable</code>, only succeeding if it can fulfill any remaining parameters by current hypotheses. That one desperately needs a better name. :-)</p>",
        "id": 128120833,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529070744
    },
    {
        "content": "<p>(I've been curious if a case will come up where it's valuable to try applying a <code>semiapplicable</code>, and then using <code>solve_by_elim</code> to fulfill remaining arguments, but I haven't run into this in the wild.)</p>",
        "id": 128120854,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529070797
    },
    {
        "content": "<p>extensionality lemmas are definitely not applicable</p>",
        "id": 128120917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529070871
    },
    {
        "content": "<p>otherwise you would end up unfolding all your equalities on structures</p>",
        "id": 128120932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529070898
    },
    {
        "content": "<blockquote>\n<p>(I've also got a tactic <code>semiapplicable</code>, which tries applying lemmas marked <code>semiapplicable</code>, only succeeding if it can fulfill any remaining parameters by current hypotheses. That one desperately needs a better name. :-)</p>\n</blockquote>\n<p>Your message raises an important question: what are the grammatical rules for smileys and closing brackets?</p>",
        "id": 128120935,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529070900
    },
    {
        "content": "<p>(I prefer an additional space with the smiley to keep it clearly delimited :) )</p>",
        "id": 128120965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529070957
    },
    {
        "content": "<p>( Me too, but to avoid any ambiguity, I think I might start endorsing \"turning your head\" (-: )</p>",
        "id": 128121022,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529071001
    },
    {
        "content": "<p>On the subject of <code>semiapplicable</code>, I think there's a pattern of tactics for killing the current goal and we ought to have a more systematic naming convention.</p>",
        "id": 128121115,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529071098
    },
    {
        "content": "<p>Back to <code>ext</code>, if you call it as <code>ext x y z</code> and somewhere, product extensionality is applicable, the number of identifiers provided does not reflect the number of rules applied. If it was the last rule, there's no way to just decide to not apply that level of extensionality ... except if we call <code>ext x y, ext1 z</code>. Are we ok with that?</p>",
        "id": 128121331,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529071349
    },
    {
        "content": "<p>How about an optional depth limit like in <code>congr'</code></p>",
        "id": 128121398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529071432
    },
    {
        "content": "<p>Yes, good idea! Do you think we could use one of <code>with</code>, <code>in</code> or <code>at</code> to specify that limit?</p>",
        "id": 128121505,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529071551
    },
    {
        "content": "<p>lol our stockpile of prepositions is quite limited</p>",
        "id": 128121759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529071873
    },
    {
        "content": "<p>How about <code>ext x y z</code> without limit and <code>ext 3 with x y z</code> if we use a limit?</p>",
        "id": 128121760,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529071876
    },
    {
        "content": "<p>Otherwise we could also go with <code>ext x y z { depth := 3 }</code></p>",
        "id": 128121829,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529071943
    },
    {
        "content": "<p>I'm not sure that will parse</p>",
        "id": 128121841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529071974
    },
    {
        "content": "<p>Yeah, I'm not sure how to make that work either actually</p>",
        "id": 128122303,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529072559
    },
    {
        "content": "<p>Here's what I have now:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">×</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"mi\">1</span> <span class=\"k\">with</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">guard_target</span> <span class=\"n\">X</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">admit</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">guard_target</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">,</span> <span class=\"n\">admit</span><span class=\"o\">,</span>\n    <span class=\"n\">guard_target</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">,</span> <span class=\"n\">admit</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">guard_target</span> <span class=\"n\">X</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">admit</span> <span class=\"o\">},</span>\n  <span class=\"n\">trivial</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>How do you guys like that?</p>",
        "id": 128137567,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529091892
    },
    {
        "content": "<p>LGTM</p>",
        "id": 128137735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1529092073
    },
    {
        "content": "<p>:) Good, it's coming up</p>",
        "id": 128138565,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529093076
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span>, and if I just call <code>ext</code> with no arguments?</p>",
        "id": 128145906,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529103417
    },
    {
        "content": "<p>Then may God have our souls</p>",
        "id": 128145918,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529103441
    },
    {
        "content": "<p><span class=\"emoji emoji-1f61d\" title=\"stuck out tongue closed eyes\">:stuck_out_tongue_closed_eyes:</span> But seriously, same behavior as before except it now considers extensionality on products as well</p>",
        "id": 128145970,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529103498
    },
    {
        "content": "<p>Also, I fixed extensionality on functions. The attribute was applied to the tactic, not the lemma</p>",
        "id": 128145979,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529103520
    },
    {
        "content": "<p>Excellent. And if I wrote something <code>@[extensionality] lemma ulift.ext {α : Type u₁} (X Y : ulift.{u₂} α) (w : X.down = Y.down) : X = Y</code> then just plain <code>ext</code> would apply this?</p>",
        "id": 128145991,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529103558
    },
    {
        "content": "<p>Exactly</p>",
        "id": 128145995,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529103574
    },
    {
        "content": "<p>Yay, thanks!</p>",
        "id": 128145997,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529103579
    },
    {
        "content": "<p><span class=\"emoji emoji-1f44d\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 128146094,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529103714
    },
    {
        "content": "<p>What should I do with my PR that made <code>ext</code> fail if there were no extensionality lemmas to apply?</p>",
        "id": 128146162,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529103776
    },
    {
        "content": "<p>Sorry, I completely spaced out. I should just have added on top of that</p>",
        "id": 128146230,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529103851
    },
    {
        "content": "<p>No problem. I could send a PR to your PR, I guess. :-)</p>",
        "id": 128146241,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529103898
    },
    {
        "content": "<p>Haha! Yeah! Let's see what actually happens with mine when there's no rules to be applied</p>",
        "id": 128146254,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529103927
    },
    {
        "content": "<p>Also --- your commit is failing: &lt;<a href=\"https://travis-ci.org/leanprover/mathlib/builds/392889071?utm_source=github_status&amp;utm_medium=notification\" target=\"_blank\" title=\"https://travis-ci.org/leanprover/mathlib/builds/392889071?utm_source=github_status&amp;utm_medium=notification\">https://travis-ci.org/leanprover/mathlib/builds/392889071?utm_source=github_status&amp;utm_medium=notification</a>&gt;</p>",
        "id": 128146297,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1529103962
    },
    {
        "content": "<p>The main branch is broken so I'm going to wait for it to be fixed first</p>",
        "id": 128146370,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529104127
    },
    {
        "content": "<p>Actually, I'll just make sure the trouble is not because of <code>ext</code> ...</p>",
        "id": 128146596,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1529104515
    },
    {
        "content": "<p>What is people's opinion of making lemmas like this one <code>extensionality</code> lemmas?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">subset_ext</span> <span class=\"o\">{</span><span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s₁</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s₂</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s₁</span> <span class=\"err\">⊆</span> <span class=\"n\">s₂</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</pre></div>",
        "id": 135291851,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538787658
    },
    {
        "content": "<p>Is the idea that <code>ext</code> would do the work of <code>subset_iff</code> automatically?</p>",
        "id": 135291905,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1538787762
    },
    {
        "content": "<p>Yes but only in one direction</p>",
        "id": 135292050,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538788051
    },
    {
        "content": "<p>I'm not sure about this. it makes it less clear to me what <code>extensionality</code> means</p>",
        "id": 135292169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788236
    },
    {
        "content": "<p>is there a specific sense of what kind of lemmas you want to allow here?</p>",
        "id": 135292176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788254
    },
    {
        "content": "<p>I guess the idea is \"proving things by breaking objects into their constituent parts\". I'm on the fence. At first I'm tempted, but I'm not sure where it ends...</p>",
        "id": 135292245,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538788378
    },
    {
        "content": "<p>This also sounds like \"unfold definitions\" though which is a bit dangerous</p>",
        "id": 135292316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788476
    },
    {
        "content": "<p>I think Scott's definition would make sense. I'm also unsure. One reason is that I'm not clear if those lemmas could be chained</p>",
        "id": 135292332,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538788536
    },
    {
        "content": "<p>Actually there is a tactic in this area I very much want, which does \"definitional unfolding\" minus the definitional part</p>",
        "id": 135292336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788539
    },
    {
        "content": "<p>What do you mean?</p>",
        "id": 135292339,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538788552
    },
    {
        "content": "<p>I currently use <code>simp</code> for this but it could be much more deterministic and hence faster</p>",
        "id": 135292342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788561
    },
    {
        "content": "<p>This sounds like the sort of thing that I don't know that I want :-)</p>",
        "id": 135292383,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538788571
    },
    {
        "content": "<p>many functions are \"activated\" by some argument in which case they simplify to something else</p>",
        "id": 135292385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788596
    },
    {
        "content": "<p>i.e. recursive definitions</p>",
        "id": 135292386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788601
    },
    {
        "content": "<p>If we had a mechanism for emulating call-by-name evaluation, then we could use it as a replacement for simp in these cases</p>",
        "id": 135292395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788652
    },
    {
        "content": "<p><code>simp</code> is also a bit too aggressive in places, e.g. reassociating and commuting additions which can block \"computation\"</p>",
        "id": 135292400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788680
    },
    {
        "content": "<p>You could probably build it by using the <code>simp</code> machinery with only definitional lemmas</p>",
        "id": 135292444,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538788728
    },
    {
        "content": "<p>But that's the thing, I don't care about them being literally definitional equalities</p>",
        "id": 135292451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788758
    },
    {
        "content": "<p>How would you select the lemmas?</p>",
        "id": 135292453,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538788772
    },
    {
        "content": "<p>An attribute</p>",
        "id": 135292454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788777
    },
    {
        "content": "<p>So you need a new simp lemma</p>",
        "id": 135292459,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538788798
    },
    {
        "content": "<p>For example a corecursor applied to a constructor in a coinductive type</p>",
        "id": 135292500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788811
    },
    {
        "content": "<p>it's \"like\" a recursive definition but not definitional because lean didn't decide to support it out of the box</p>",
        "id": 135292502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788834
    },
    {
        "content": "<p>I was actually about to use that as a counter example</p>",
        "id": 135292503,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538788835
    },
    {
        "content": "<p>I don't want to be tied to whatever lean decided to support out of the box</p>",
        "id": 135292510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788859
    },
    {
        "content": "<p>it's not extensible</p>",
        "id": 135292517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788867
    },
    {
        "content": "<p>Yeah, I agree. I created a <code>pseudo_eqn</code> attribute for my corecursive definitions just for that purpose</p>",
        "id": 135292520,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538788908
    },
    {
        "content": "<p>Coq has a <code>cbv</code> tactic that has exactly this behavior</p>",
        "id": 135292561,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788930
    },
    {
        "content": "<p>I asked for it a long time ago and I think <code>simp</code> was the response</p>",
        "id": 135292565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788948
    },
    {
        "content": "<p>The issue with <code>simp</code> though is that if you apply it for </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">codef</span> <span class=\"n\">diverge</span> <span class=\"o\">:</span> <span class=\"n\">computation</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">think</span> <span class=\"n\">diverge</span>\n</pre></div>\n\n\n<p>\"unfolding\" will get ugly.</p>",
        "id": 135292569,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538788971
    },
    {
        "content": "<p>but <code>cbv</code> has a much more restricted evaluation behavior that allows you to almost completely skip the \"search\" part</p>",
        "id": 135292572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538788985
    },
    {
        "content": "<p>corecursors are values</p>",
        "id": 135292576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538789003
    },
    {
        "content": "<p>they only simplify when you tell them to explicitly</p>",
        "id": 135292581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538789021
    },
    {
        "content": "<p>even Coq does this with their builtin coinductives</p>",
        "id": 135292584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538789035
    },
    {
        "content": "<p>But Coq leaves in the <code>cofix</code> construct and the match statement which kind of blocks the unfolding</p>",
        "id": 135292626,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538789080
    },
    {
        "content": "<p>I should look up the specifics there though</p>",
        "id": 135292627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538789080
    },
    {
        "content": "<p>not sure I follow</p>",
        "id": 135292636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538789106
    },
    {
        "content": "<p>We can also do very little search though. One way is caching but we can also enforce a naming scheme that gives us only one candidate every time.</p>",
        "id": 135292687,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538789164
    },
    {
        "content": "<p>I was thinking that when you register a new rule, it analyzes the structure of the lemma to figure out what the active parameter is so that it can have a decision tree based dispatch</p>",
        "id": 135292708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538789234
    },
    {
        "content": "<blockquote>\n<p>not sure I follow</p>\n</blockquote>\n<p>One of the first difference I noticed between Lean and Coq is that in Lean, unfolding often introduces a match statement because case analysis is a different process than unfolding. It is similar with corecursion</p>",
        "id": 135292754,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538789305
    },
    {
        "content": "<p>i.e. if you say <code>n + 0 = n</code> and <code>n + succ m = succ (n + m)</code>, then it knows that it starts from <code>has_add.add</code>, checks the <code>nat.has_add</code> argument, then goes to the last parameter and uses one rule if <code>0</code> and another if <code>succ _</code></p>",
        "id": 135292758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538789312
    },
    {
        "content": "<p>so there is no big search</p>",
        "id": 135292764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538789345
    },
    {
        "content": "<p>Yes, I agree with that idea</p>",
        "id": 135292768,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538789370
    },
    {
        "content": "<p>I think that many uses of <code>simp</code> are actually uses of <code>cbv</code>/<code>cbn</code></p>",
        "id": 135292919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538789602
    },
    {
        "content": "<p>I think you're right</p>",
        "id": 135292980,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538789714
    },
    {
        "content": "<p>About corecursive definitions, I'm thinking of using a bound on the number of times they can be unfolded</p>",
        "id": 135293175,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1538790080
    },
    {
        "content": "<p>You could also trigger them \"in reverse\", i.e. a destructor applied to a corecursor reduces</p>",
        "id": 135293734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538791061
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I noticed that <code>ext</code> has a weird behavior where with <code>f g : a -&gt; b -&gt; c |- f = g</code> if you call <code>ext i</code> it will apply extensionality twice instead of only once. I believe it is a mistake that I made. Is this a valuable behavior for you guys?</p>",
        "id": 148876325,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543599701
    },
    {
        "content": "<p>I'm thinking of fixing it</p>",
        "id": 148876615,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543600001
    },
    {
        "content": "<p>What exactly are you planning on changing the behavior to?</p>",
        "id": 148878481,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543601953
    },
    {
        "content": "<p>My understanding is that currently, <code>ext</code> just applies as many extensionality lemmas as possible</p>",
        "id": 148878498,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543601973
    },
    {
        "content": "<p>Tricky cases: <code>ext</code> lemmas which don't consume any of the names, or which produce multiple goals with different numbers of variables (does <code>ext</code> support this currently?)</p>",
        "id": 148878616,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543602079
    },
    {
        "content": "<p>About the tricky case: for the multiple goals scenario, it is currently broken and I'm going to fix that so that ext x y, when it produces multiple goals, will use the same list (x, y) in each goal.</p>",
        "id": 148879897,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543603165
    },
    {
        "content": "<p>Currently, when <code>ext x</code> encounters an extensionality rule which does not consume names, it just keeps going until it can't anymore. For instance, with <code>f g : a -&gt; (b x c) |- f = g</code>, <code>ext x</code> will introduce <code>x</code> and use extensionality on pairs. I'd like to change that so that <code>ext x</code> only uses functional extensionality and <code>ext x _</code> will allow the pair extensionality to be used.</p>",
        "id": 148880086,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543603327
    },
    {
        "content": "<p>I guess the main thing is that currently <code>ext x</code> with an ext lemma that takes 1 name followed by an ext lemma that takes 0 names applies both, and that should not change</p>",
        "id": 148880091,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543603342
    },
    {
        "content": "<p>Really? Why not?</p>",
        "id": 148880114,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543603364
    },
    {
        "content": "<p>Because there are like 1000 uses of <code>ext</code> already</p>",
        "id": 148880135,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543603392
    },
    {
        "content": "<p>and you can use <code>ext1</code> to apply one lemma</p>",
        "id": 148880150,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543603414
    },
    {
        "content": "<p>In mathlib or other projects too? I can fix mathlib, no worries.</p>",
        "id": 148880156,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543603422
    },
    {
        "content": "<p>so IMO the current behavior makes sense in that case</p>",
        "id": 148880157,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543603423
    },
    {
        "content": "<p>The thing is that, when you want to use three extensionality lemmas and provide variable names for them but that a fourth is possible, you have to limit using numbers. I'd like to avoid that.</p>",
        "id": 148880236,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543603489
    },
    {
        "content": "<p>Here is what I did: <a href=\"https://github.com/leanprover/mathlib/pull/506\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/pull/506\">https://github.com/leanprover/mathlib/pull/506</a></p>",
        "id": 148881908,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543604995
    },
    {
        "content": "<p>Why not just add some new syntax for this other behavior that you want?</p>",
        "id": 148884473,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543607410
    },
    {
        "content": "<p>I don't see how it can be worth changing the default behavior, which is easy to understand and probably what you want most of the time</p>",
        "id": 148884498,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543607448
    },
    {
        "content": "<p>I didn't realize the syntax with <code>: n</code> existed. I'm not sure whether I've ever wanted it. I have used <code>ext1</code> to apply one extensionality lemma and not a second, but I don't know whether I've wanted to apply specifically 2 or more</p>",
        "id": 148884615,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543607528
    },
    {
        "content": "<p>it's an upper bound not a lower bound</p>",
        "id": 148891407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543613884
    },
    {
        "content": "<p>I meant \"specifically apply a number N, where N &gt;= 2\"</p>",
        "id": 148892238,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543614845
    },
    {
        "content": "<p>right, that's not what it does</p>",
        "id": 148892283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543614912
    },
    {
        "content": "<p>it applies extensionality <em>up to</em> N times</p>",
        "id": 148892294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1543614929
    },
    {
        "content": "<p>Well I would only use it when I didn't want to apply more, right?</p>",
        "id": 148892399,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543615061
    },
    {
        "content": "<p>It might as well be an exact number</p>",
        "id": 148892405,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543615067
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Why do you think <code>ext x _</code> is a bad syntax? Having <code>ext x</code> apply extensionality even when you run out of names for the new variables is inconsistent with what <code>intros</code> does. And instead, you could be writing <code>ext x; ext</code></p>",
        "id": 148893622,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543616325
    },
    {
        "content": "<p>What is <code>ext x _</code> supposed to mean?</p>",
        "id": 148893667,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543616388
    },
    {
        "content": "<p>Anyways I don't think I said it was a bad syntax...?</p>",
        "id": 148893670,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543616395
    },
    {
        "content": "<p>Although I do possibly think it is one, depending on what it is supposed to mean...</p>",
        "id": 148893719,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543616406
    },
    {
        "content": "<p>What is bad is changing very basic and useful stuff unnecessarily</p>",
        "id": 148893770,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543616478
    },
    {
        "content": "<p>Also there's lots of stuff which takes a list of names and just makes up more if there aren't enough provided, like <code>cases</code></p>",
        "id": 148893793,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543616512
    },
    {
        "content": "<p>So to me, the current behavior makes perfect sense</p>",
        "id": 148893850,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543616543
    },
    {
        "content": "<p><code>ext x</code> would not use extensionality of product after functional extensionality because it runs out of names. <code>ext x _</code> would be to trigger extensionality of product by giving it a name it can throw out.</p>",
        "id": 148894062,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543616876
    },
    {
        "content": "<p><code>ext</code> is more similar to <code>intros</code> than cases because, with cases, if you provide more names, it will not apply additional recursors.</p>",
        "id": 148894153,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543616946
    },
    {
        "content": "<p>That's pretty gross IMO</p>",
        "id": 148894263,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543617029
    },
    {
        "content": "<p>Also, your next problem will be how to apply one zero-argument extensionality lemma, when there is a second you could apply as well</p>",
        "id": 148894274,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543617050
    },
    {
        "content": "<p>I really don't understand why you want to make any change at all frankly</p>",
        "id": 148894288,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543617065
    },
    {
        "content": "<p>We could make it more like <code>cases</code> (or actually <code>rcases</code>) by using syntax like <code>ext x ⟨ y, z ⟩</code> to apply extensionality (functional, then product, then functional) on <code>f g : a -&gt; (b -&gt; c x b -&gt; c) |- f = g</code></p>",
        "id": 148894290,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543617067
    },
    {
        "content": "<blockquote>\n<p>Also, your next problem will be how to apply one zero-argument extensionality lemma, when there is a second you could apply as well</p>\n</blockquote>\n<p>This is where I would need to resort to the <code>ext : n</code> syntax.</p>",
        "id": 148894363,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543617139
    },
    {
        "content": "<blockquote>\n<p>I really don't understand why you want to make any change at all frankly</p>\n</blockquote>\n<p>I think it looks ugly to have to write <code>ext x y z : 3</code> and it makes the meaning of <code>ext x y z</code> different from what you would assume. It doesn't mean apply extensionality three times. It means apply extensionality multiple times and the first three arguments should be named <code>x</code> <code>y</code> <code>z</code></p>",
        "id": 148894477,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543617280
    },
    {
        "content": "<p>How about making it mean \"apply extensionality three times\" then?</p>",
        "id": 148894511,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543617326
    },
    {
        "content": "<p>I've never used it and I didn't read the documentation carefully</p>",
        "id": 148894514,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543617336
    },
    {
        "content": "<p>Oh wait I misparsed</p>",
        "id": 148894526,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543617348
    },
    {
        "content": "<p>Why would someone think <code>ext x y z</code> means extensionality three times?</p>",
        "id": 148894572,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543617375
    },
    {
        "content": "<p>As you can probably tell, this whole conversation is very confusing to me</p>",
        "id": 148894588,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543617419
    },
    {
        "content": "<p>An extensionality lemma for a relation would consume two names, so the number of names would never be related to the number of lemmas applied anyways</p>",
        "id": 148894777,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543617685
    },
    {
        "content": "<p>That's true</p>",
        "id": 148894794,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543617711
    },
    {
        "content": "<p>I'd like an easier way of getting <code>ext</code> to stop applying lemmas than <code>ext : n</code></p>",
        "id": 148894895,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543617802
    },
    {
        "content": "<p>Okay, so how about making <code>ext ... : 0</code> or something mean \"apply as few lemmas as possible to use all the names\"?</p>",
        "id": 148895366,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543618231
    },
    {
        "content": "<p>Or it's not that difficult to just use <code>: n</code>, and changing the default behavior just means that some other, probably equally common case (apply as many lemmas as possible) now needs a special syntax instead</p>",
        "id": 148895460,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543618325
    },
    {
        "content": "<p>For \"as many lemmas as possible\", we could go with <code>ext* x y z</code></p>",
        "id": 148895661,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543618576
    },
    {
        "content": "<p>Or we could also do <code>ext x y z *</code> or <code>ext x y z ... </code></p>",
        "id": 148897567,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543620717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span>  I think the current default behavior (as many lemmas as possible) is better. For one thing, <code>ext</code> is often used with no names.</p>",
        "id": 150725070,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543761251
    },
    {
        "content": "<p>That's true -- I often just type <code>ext</code> and it does exactly what I want it to do.</p>",
        "id": 150725075,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543761277
    },
    {
        "content": "<p>(And in situations where you really don't need the names, because the whole proof is something like <code>by ext; simp</code>.)</p>",
        "id": 150725087,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543761334
    },
    {
        "content": "<p>I'm not suggesting removing that behavior of <code>ext</code>. That's one reason I compare it with <code>intros</code>. Without names, go nuts, apply <code>ext</code> (or <code>intro</code> ) to your heart's content. But with <code>ext a b c</code>, like with <code>intros a b c</code>, you only go so far as the provided identifiers allow you.</p>",
        "id": 150733721,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543778808
    },
    {
        "content": "<p>Are you guys only concerned about <code>ext</code> or do you also depend on the case where you provide a few names?</p>",
        "id": 150733730,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1543778858
    },
    {
        "content": "<blockquote>\n<p>Are you guys only concerned about <code>ext</code> or do you also depend on the case where you provide a few names?</p>\n</blockquote>\n<p>Honestly, I have no idea. I just use it, and it normally does what I want. I haven't been keeping score of how many times it applied a zero-argument extensionality lemma that I wanted or didn't want.</p>",
        "id": 151129575,
        "sender_full_name": "Reid Barton",
        "timestamp": 1544205602
    },
    {
        "content": "<p>This is a standard problem with <em>changing</em> behavior--it's hard to evaluate how useful the old behavior is, because you just use it implicitly, as a matter of course.</p>",
        "id": 151129677,
        "sender_full_name": "Reid Barton",
        "timestamp": 1544205687
    },
    {
        "content": "<p>In this case, it is hard to imagine any compelling argument for changing the default behavior anyways.</p>",
        "id": 151129776,
        "sender_full_name": "Reid Barton",
        "timestamp": 1544205757
    }
]
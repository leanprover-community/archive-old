[
    {
        "content": "<p>I guess this has been discussed many times but I'd like to be sure. In Lean's foundation, is there any way to turn a functional relation into a function without using extra axioms (especially choice)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃!</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 254004942,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1632120819
    },
    {
        "content": "<p>You can't move from <code>Prop</code> to <code>Type</code> without AC so I'm pretty sure the answer to your question is \"no\". My understanding is that in ZFC you can do it but not here.</p>",
        "id": 254007130,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1632122176
    },
    {
        "content": "<p>It's equivalent to unique choice</p>",
        "id": 254007302,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632122298
    },
    {
        "content": "<p>which is derivable in ZF but requires additional axioms in lean</p>",
        "id": 254007359,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632122342
    },
    {
        "content": "<p>saying it \"requires choice\" is not really true, you can do it with genuinely weaker axioms, but if you want to say which of the three official axioms you would need to prove it, yes you need choice</p>",
        "id": 254007475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632122403
    },
    {
        "content": "<p>Ok, this is what I had in mind when writing a message. But it never occurred to me before than differences between ZF and CIC would impact such a basic thing.</p>",
        "id": 254007625,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1632122514
    },
    {
        "content": "<p>The specific context I had was defining the function induced on a quotient (lifted in our non-sensical terminology). I always explained this using a section of the quotient, which requires choice. But I realized that defining the associated relation doesn't seem to require axioms.</p>",
        "id": 254007770,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1632122605
    },
    {
        "content": "<p>One way to think about ZF is that it's like CIC but where everything is in a <code>Prop</code> context, since it's all sets. So every function is really a functional relation, and every set is a predicate</p>",
        "id": 254007839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632122645
    },
    {
        "content": "<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">\\pi : X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is surjective with associated relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∼</mo></mrow><annotation encoding=\"application/x-tex\">\\sim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">∼</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">f : X \\to Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span> is compatible with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∼</mo></mrow><annotation encoding=\"application/x-tex\">\\sim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">∼</span></span></span></span> then you can define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>f</mi><mo>ˉ</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\bar f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0256599999999998em;vertical-align:-0.19444em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8312199999999998em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span><span style=\"top:-3.26344em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.08332999999999999em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span></span> as a relation as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">(</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>z</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>π</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>y</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>z</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{(y, z) | \\forall x, \\pi(x) = y \\implies f(x) = z\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span><span class=\"mord\">∣∀</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7194400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">}</span></span></span></span></p>",
        "id": 254007905,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1632122698
    },
    {
        "content": "<p>Sorry about the notation mess while I edited the above message</p>",
        "id": 254007968,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1632122751
    },
    {
        "content": "<p>Yes, set-quotients in CIC need unique choice</p>",
        "id": 254008134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632122849
    },
    {
        "content": "<p>You can live with just having a functional relation instead of a function though. That's sort of what I mean about ZF, it's basically doing this for everything in the language so nothing is \"data\" and everything is (vacuously) \"computable\"</p>",
        "id": 254008290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632122950
    },
    {
        "content": "<p>so \"data\" is some kind of added thing in CIC</p>",
        "id": 254008392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632123003
    },
    {
        "content": "<p>Thanks</p>",
        "id": 254009106,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1632123492
    },
    {
        "content": "<p>If you have <code>fintype α</code> then you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.choose\">docs#fintype.choose</a> to get your function</p>",
        "id": 254009226,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1632123585
    },
    {
        "content": "<p>Of course I understand all those questions are vacuous in a finite context.</p>",
        "id": 254009364,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1632123650
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/erased\">docs#erased</a> turns out to be a way to work with \"classical\" values, if that's something you'd be willing to use. (The name \"erased\" has to do with how it's represented internally by Lean.  It probably could stand to have a more intuitive name that means \"I am thinking of a specific term, but I can't tell you what it is.\")</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.erased</span>\n\n<span class=\"sd\">/-- Short version, uses the axiom of choice but is still not noncomputable. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃!</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">erased</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- Longer version, does not use the axiom of choice. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃!</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">erased</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">⟨(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hb.1</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hb.2</span> <span class=\"n\">y</span> <span class=\"n\">h'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- erased.out is what noncomputably extracts the value from erased,</span>\n<span class=\"c1\">-- and we can check the above definitions are correct with respect</span>\n<span class=\"c1\">-- to foo'':</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo''</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃!</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo_prop</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃!</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">out</span> <span class=\"bp\">=</span> <span class=\"n\">foo''</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">erased.out</span> <span class=\"o\">(</span><span class=\"n\">erased.mk</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">foo''</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo'_prop</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃!</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">foo'</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">out</span> <span class=\"bp\">=</span> <span class=\"n\">foo''</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">foo_prop</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">using</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">,</span> <span class=\"n\">foo'</span><span class=\"o\">],</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">((</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some_spec.2</span> <span class=\"n\">y</span> <span class=\"n\">h'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some_spec.1</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 254068815,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1632151961
    },
    {
        "content": "<p>How does obtain work without choice?</p>",
        "id": 254070817,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1632152569
    },
    {
        "content": "<p>The goal is a <code>Prop</code>, so it can eliminate the existential.</p>",
        "id": 254071259,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1632152755
    },
    {
        "content": "<p>Thanks Kyle. I should have clarified that my question wasn't a Lean question. I was only interested in the abstract foundation question.</p>",
        "id": 254104062,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1632165895
    },
    {
        "content": "<p>Using propositional truncation instead of the <code>Prop</code> universe, it can be defined</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.quot</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">trunc</span> <span class=\"o\">{</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n  <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">trunc.lift_on</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">subtype.eq</span> <span class=\"bp\">$</span> <span class=\"n\">z.2.2</span> <span class=\"n\">y</span> <span class=\"n\">y.2.1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 254109494,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1632168340
    },
    {
        "content": "<p>This doesn't surprise me -- I think I kind of have the hang of <code>trunc</code> now. The point is that subsingleton data is still data so you don't need AC to make data from it.</p>",
        "id": 254114780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1632170565
    },
    {
        "content": "<p>I don't understand what that <code>trunc</code> thing means (philosophically).</p>",
        "id": 254115103,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1632170718
    },
    {
        "content": "<p><code>trunc</code> is a subsingleton type, but it is \"data\" (in the sense mentioned <a href=\"#narrow/stream/113488-general/topic/ZF-style.20functions/near/254008392\">above</a>)</p>",
        "id": 254115433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632170870
    },
    {
        "content": "<p>Instead of saying \"there exists a basis of this vector space\" you're saying \"let's choose an equivalence class of bases where two bases are always defined to be equivalent\". Because this is data you can use the universal property of quotients to define things which don't depend on the choice of basis</p>",
        "id": 254115441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1632170873
    },
    {
        "content": "<p>Making \"data\" a more concrete notion is done most easily by thinking about (a simplified model of) VM computation, in which all proofs and types are erased (replaced with stubs) while all \"data\" is preserved, and axioms are banned for computing \"data\"</p>",
        "id": 254115709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632171002
    },
    {
        "content": "<p>With that model, if you look at the type of <code>choice : \\forall A, nonempty A -&gt; A</code> you can see clearly that it takes in two stubs and outputs some data, which is an impossible feat</p>",
        "id": 254115872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632171074
    },
    {
        "content": "<p><code>unique_choice : \\forall A, nonempty (unique A) -&gt; A</code> has exactly the same problem</p>",
        "id": 254115911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632171100
    },
    {
        "content": "<p>But <code>trunc.out : trunc A -&gt; A</code> doesn't have that problem, because <code>trunc A</code> is not a stub, it is represented the same as <code>A</code> in the VM, so this is really an identity function</p>",
        "id": 254116194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632171222
    },
    {
        "content": "<p>At the logical level it is of course not an identity function, because the notion of identity is different on <code>trunc A</code> vs <code>A</code>. But the \"computational realizers\" aka bytes in the machine used to represent values, are the same</p>",
        "id": 254116358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632171287
    },
    {
        "content": "<p>I won't deny that this \"data\" thing is a weird concept, and it is odd that we are bringing a notion of computation to a mathematical/philosophical question. But that's just how CIC is, it lifts a notion of computation into the proof theory</p>",
        "id": 254116698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632171426
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/ZF-style.20functions/near/254007905\">said</a>:</p>\n<blockquote>\n<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">\\pi : X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is surjective with associated relation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∼</mo></mrow><annotation encoding=\"application/x-tex\">\\sim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">∼</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">f : X \\to Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span> is compatible with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∼</mo></mrow><annotation encoding=\"application/x-tex\">\\sim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">∼</span></span></span></span> then you can define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>f</mi><mo>ˉ</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\bar f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0256599999999998em;vertical-align:-0.19444em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8312199999999998em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span><span style=\"top:-3.26344em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.08332999999999999em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span></span> as a relation as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">(</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>z</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>π</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>y</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>z</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{(y, z) | \\forall x, \\pi(x) = y \\implies f(x) = z\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span><span class=\"mord\">∣∀</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7194400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">}</span></span></span></span></p>\n</blockquote>\n<p>I remember being pretty confused about this issue precisely because the quoted statement is also true in a topos, and the internal logic of a topos is generally considered to be constructive. Furthermore, you can construct the factorization through the quotient in HoTT, too. That basically amounts to the version with <code>trunc</code> that Chris wrote.</p>",
        "id": 254119209,
        "sender_full_name": "Reid Barton",
        "timestamp": 1632172406
    },
    {
        "content": "<p>It's really the fact that Lean has these <em>two</em> separate things, <code>Prop</code>s and subsingletons, and you need the version with subsingletons to define the factorization through the quotient, but <code>surjective</code> is only the <code>Prop</code> version. It's not something intrinsic to constructive reasoning in general.</p>",
        "id": 254119370,
        "sender_full_name": "Reid Barton",
        "timestamp": 1632172480
    },
    {
        "content": "<p>One thing I learnt from trolling constructivists on Twitter is that in constructive land there might be more than one way to express what in classical mathematics is \"one idea\", for example being Hausdorff. Is this an existence statement or an actual function which eats two points and spits out two opens?</p>",
        "id": 254125008,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1632175171
    },
    {
        "content": "<p>These two things live in different universes but are indistinguishable to a classical mathematician</p>",
        "id": 254125160,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1632175224
    },
    {
        "content": "<p>In the Hausdorff example these notions should already be distinct in ZF (without C), let alone in a general topos. The failure of unique choice is a qualitatively different thing than the failure of choice.</p>",
        "id": 254151558,
        "sender_full_name": "Reid Barton",
        "timestamp": 1632195779
    },
    {
        "content": "<p>Actually there are 3 ways you could define Hausdorff: (1) For any distinct x and y there exist U and V such that blah. (2) There exists a function which sends a pair (x, y) of distinct points to a pair (U, V) such that blah. (3) A Hausdorff space is a topological space together with a specific function as in (2).</p>",
        "id": 254151675,
        "sender_full_name": "Reid Barton",
        "timestamp": 1632195905
    },
    {
        "content": "<p>(3) is not even classically the correct notion, but if you work in a theory without quotients or propositional truncation you might have no way to express something classically correct.</p>",
        "id": 254151714,
        "sender_full_name": "Reid Barton",
        "timestamp": 1632195959
    },
    {
        "content": "<p>I guess you could argue that it doesn't matter that (3) is the \"wrong notion\" because you define the maps of Hausdorff spaces to totally ignore the \"Hausdorff structure\", and you still get the right category up to equivalence. But then it's a bit weird that your isomorphisms are not the structural ones.</p>",
        "id": 254152114,
        "sender_full_name": "Reid Barton",
        "timestamp": 1632196389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/ZF-style.20functions/near/254151675\">said</a>:</p>\n<blockquote>\n<p>Actually there are 3 ways you could define Hausdorff: (1) For any distinct x and y there exist U and V such that blah. (2) There exists a function which sends a pair (x, y) of distinct points to a pair (U, V) such that blah. (3) A Hausdorff space is a topological space together with a specific function as in (2).</p>\n</blockquote>\n<p>You didn't mention the one that contrapositives the whole statement: if all open sets around x and y intersect, then x = y</p>",
        "id": 254153260,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1632197670
    },
    {
        "content": "<p>Basically the mathematics which we're all brought up with in maths departments (where none of this is ever even mentioned) is maths in easy mode, which is appealling because we can get much further (FLT, Poincaré conjecture etc)</p>",
        "id": 254158442,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1632203100
    }
]
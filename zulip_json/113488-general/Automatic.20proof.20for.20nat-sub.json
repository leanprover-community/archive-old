[
    {
        "content": "<p>Dear All,</p>\n<p>have you ever been annoyed by nat-subtraction?</p>\n<p>This post is in the intersection of <a href=\"#narrow/stream/113488-general/topic/Proofs.20that.20should.20be.20automatic\">Proofs that should be automatic</a> and <a href=\"#narrow/stream/113488-general/topic/.60linarith.60.20failure\"><code>linarith</code> failure</a>.</p>\n<p>I tried writing a simple-minded tactic that would split nat-subtractions in a goal into the two obvious cases and continue until all nat-subtractions have been removed.</p>\n<p>Below is the experimental tactic and the example showing that it works in the case that <span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> mentioned in his post.</p>\n<p>Feel free to experiment and give comments!  If you like it, I can polish it and make a PR.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.linarith</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat.le_cases</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">or.inl</span> <span class=\"o\">(</span><span class=\"n\">tsub_eq_zero_of_le</span> <span class=\"n\">ab</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">or.inr</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">nat.exists_eq_add_of_le</span> <span class=\"o\">((</span><span class=\"n\">not_le.mp</span> <span class=\"n\">ab</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n\n<span class=\"sd\">/--  `get_sub e` extracts a list of pairs `(a, b)` from the expression `e`, where `a - b` is a</span>\n<span class=\"sd\">subexpression of `e`. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">get_sub</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">expr</span> <span class=\"bp\">×</span> <span class=\"n\">expr</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">%%</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"bp\">%%</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"o\">[</span><span class=\"n\">ga</span><span class=\"o\">,</span> <span class=\"n\">gb</span><span class=\"o\">]</span> <span class=\"bp\">←</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">mmap</span> <span class=\"n\">get_sub</span><span class=\"o\">,</span>\n                      <span class=\"n\">return</span> <span class=\"o\">((</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">ga</span> <span class=\"bp\">++</span> <span class=\"n\">gb</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">expr.app</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span> <span class=\"o\">[</span><span class=\"n\">gf</span><span class=\"o\">,</span> <span class=\"n\">ga</span><span class=\"o\">]</span> <span class=\"bp\">←</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">mmap</span> <span class=\"n\">get_sub</span><span class=\"o\">,</span>\n                      <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">gf</span> <span class=\"bp\">++</span> <span class=\"n\">ga</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">[]</span>\n\n<span class=\"sd\">/--  `remove_one_sub e` scans the expression `e` and selects the last occurrence of a</span>\n<span class=\"sd\">subtractiion `a - b`.  It splits two cases:</span>\n<span class=\"sd\">*  `a ≤ b`, in which case it replaces `a - b` with `0`, introduces the inequality `a ≤ b` into</span>\n<span class=\"sd\">   the local context and continues from there;</span>\n<span class=\"sd\">*  writes `a = b + c`, for some `c`, tries to substitute this equality and continues from there.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">remove_one_sub</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">l</span> <span class=\"bp\">←</span> <span class=\"n\">get_sub</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"k\">match</span> <span class=\"n\">l.last'</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">fail</span><span class=\"s2\">\"no subtractions\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"c1\">-- introduce names with the following meanings:</span>\n    <span class=\"c1\">-- `eq0 : a - b = 0`, `exis : ∃ c, b + c = a`, `var = c`, `ide : b + c = a`</span>\n    <span class=\"o\">[</span><span class=\"n\">eq0</span><span class=\"o\">,</span> <span class=\"n\">exis</span><span class=\"o\">,</span> <span class=\"n\">var</span><span class=\"o\">,</span> <span class=\"n\">ide</span><span class=\"o\">]</span> <span class=\"bp\">←</span> <span class=\"o\">[</span><span class=\"s2\">\"h\"</span><span class=\"o\">,</span> <span class=\"s2\">\"k\"</span><span class=\"o\">,</span> <span class=\"s2\">\"x\"</span><span class=\"o\">,</span> <span class=\"s2\">\"hx\"</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">mmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">get_unused_name</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n    <span class=\"c1\">-- either `a ≤ b` or `a = b + c`</span>\n    <span class=\"n\">cases</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">nat.le_cases</span> <span class=\"bp\">%%</span><span class=\"n\">a</span> <span class=\"bp\">%%</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">eq0</span><span class=\"o\">,</span> <span class=\"n\">exis</span><span class=\"o\">],</span>\n    <span class=\"c1\">-- on the branch where `a ≤ b`...</span>\n      <span class=\"n\">prf</span> <span class=\"bp\">←</span> <span class=\"n\">get_local</span> <span class=\"n\">eq0</span><span class=\"o\">,</span>\n      <span class=\"n\">rewrite_target</span> <span class=\"n\">prf</span><span class=\"o\">,</span>\n      <span class=\"n\">preq</span> <span class=\"bp\">←</span> <span class=\"n\">to_expr</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"n\">nat.sub_eq_zero_iff_le</span><span class=\"o\">),</span>\n      <span class=\"n\">rewrite_hyp</span> <span class=\"n\">preq</span> <span class=\"n\">prf</span><span class=\"o\">,</span>\n      <span class=\"n\">try</span> <span class=\"bp\">`</span><span class=\"o\">[</span> <span class=\"n\">simp</span> <span class=\"o\">],</span>\n    <span class=\"c1\">-- on the branch where `b &lt; a`...</span>\n      <span class=\"n\">swap</span><span class=\"o\">,</span>\n      <span class=\"n\">prf</span> <span class=\"bp\">←</span> <span class=\"n\">get_local</span> <span class=\"n\">exis</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">prf</span> <span class=\"o\">[</span><span class=\"n\">var</span><span class=\"o\">,</span> <span class=\"n\">ide</span><span class=\"o\">],</span>\n      <span class=\"n\">prf</span> <span class=\"bp\">←</span> <span class=\"n\">get_local</span> <span class=\"n\">ide</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- either substitute or rewrite</span>\n      <span class=\"n\">subst</span> <span class=\"n\">prf</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">rewrite_target</span> <span class=\"n\">prf</span><span class=\"o\">,</span>\n      <span class=\"bp\">`</span><span class=\"o\">[</span> <span class=\"n\">rw</span> <span class=\"n\">nat.add_sub_cancel_left</span> <span class=\"o\">]</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">fail</span><span class=\"s2\">\"could not rewrite: something went wrong\"</span><span class=\"o\">,</span>\n      <span class=\"n\">try</span> <span class=\"bp\">`</span><span class=\"o\">[</span> <span class=\"n\">simp</span> <span class=\"o\">]</span>\n  <span class=\"kd\">end</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">interactive</span>\n\n<span class=\"sd\">/--  Iterate replacing a subtraction with two cases.  Once this is done, try `linarith` on</span>\n<span class=\"sd\">all remaining goals. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">remove_subs</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">iterate_at_most'</span> <span class=\"mi\">10</span> <span class=\"bp\">$</span> <span class=\"n\">target</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">remove_one_sub</span><span class=\"o\">,</span>\n  <span class=\"n\">any_goals'</span> <span class=\"bp\">$</span> <span class=\"n\">try</span> <span class=\"bp\">$</span> <span class=\"bp\">`</span><span class=\"o\">[</span> <span class=\"n\">linarith</span> <span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">interactive</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">-</span> <span class=\"n\">i</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span><span class=\"o\">,</span>\n  <span class=\"n\">remove_subs</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 297632343,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662570315
    },
    {
        "content": "<p>Of course, I would be happy to know situations where this tactic works, but it would probably be more useful to have examples where it does not work!</p>",
        "id": 297636043,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662571594
    },
    {
        "content": "<p>You could remove the spurious <code>d</code> in the example <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 297636073,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662571605
    },
    {
        "content": "<p>Done!  I edited the code above.</p>",
        "id": 297636143,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662571631
    },
    {
        "content": "<p>I think it would be useful to have a version without simps and linariths, so that it could be used mid-proof without introducing non-terminal simps.</p>",
        "id": 297636976,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1662571889
    },
    {
        "content": "<p>Andrew, good point!  If I end up making a PR, I'll definitely make sure not to introduce non-terminal simps!</p>",
        "id": 297637689,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662572107
    },
    {
        "content": "<p>Btw, the simp there is mostly a lazy way of dealing with subtractions of the form <code>0 - x</code>.</p>",
        "id": 297638156,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662572264
    },
    {
        "content": "<p>I created <a href=\"https://github.com/leanprover-community/mathlib/pull/16422\">#16422</a>.</p>\n<p>The tactic no longer uses <code>simp</code> and will only use <code>linarith</code> if it is called via <code>remove_subs!</code>.</p>",
        "id": 297679137,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662587338
    },
    {
        "content": "<p>Dear All,</p>\n<p>I realize that merging a tactic this close to the transition to Lean4 is not anyone's priority.</p>\n<p>Still, if someone could take a look at <a href=\"https://github.com/leanprover-community/mathlib/pull/16443\">#16443</a> and give me some comments, I would be very grateful!  My main motivation is that I have been trying to do some Lean4 programming, but I still find it easier to go via Lean3 code.</p>\n<p>Thus, even if this tactic does not get merged, I could use a Lean3-mergeable version as a canvas to port it to Lean4.</p>\n<p>Thanks!</p>",
        "id": 297986052,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662733733
    },
    {
        "content": "<p>Following up on the discussion <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20converse.20of.20.60nat.2Esub_le_sub_left.60\">here</a>, I made the small changes to make <code>remove_subs</code> to work with <code>tsub</code>.</p>\n<p>However, while the tactic does work, <code>linarith</code> seems to be much less developed for <code>canonically_ordered...</code> than for <code>nat</code>.</p>",
        "id": 298305102,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662948523
    },
    {
        "content": "<p>Here are explicit examples highlighting the difference in behaviour of <code>linarith</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.nnreal</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">nnreal</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">linarith</span>  <span class=\"c1\">-- succeeds</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">canonically_linear_ordered_semifield</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">linarith</span>  <span class=\"c1\">-- fails</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">linarith</span>  <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>Thus, if the truncated subtractions that <code>remove_subs</code> is going to eliminate are not in <code>nat</code>, then calling <code>remove_subs!</code> may be equivalent (but slower) to calling <code>remove_subs</code>.</p>",
        "id": 298339048,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662973004
    }
]
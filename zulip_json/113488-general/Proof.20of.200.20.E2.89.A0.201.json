[
    {
        "content": "<p>Hi guys, I'm sure I've asked this before, but I can't recall/ find my previous question.</p>\n<p>How does one prove in lean that 1 ≠ 0?</p>\n<p>I vaguely remember there was a lemma somewhere in the library, which allowed to magically prove these things, but can't find it either!</p>",
        "id": 124057061,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1521718894
    },
    {
        "content": "<p>It depends! Are these natural numbers? :)</p>",
        "id": 124057222,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1521719207
    },
    {
        "content": "<p><code>example : 0  ≠  1  := dec_trivial</code></p>",
        "id": 124057227,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1521719223
    },
    {
        "content": "<p><code>zero_ne_one</code></p>",
        "id": 124057235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521719244
    },
    {
        "content": "<p>Cheers guys! Yes, I meant natural numbers</p>",
        "id": 124057239,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1521719270
    },
    {
        "content": "<p>Right. In general, <code>1 ≠ 0</code>is <code>1 = 0 → false</code> and <code>1 = 0</code> as an assumption is untrue because of <code>no_confusion</code> (which appears to be a source of confusion!).</p>",
        "id": 124057392,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1521719528
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what on Earth, there's a <code>zero_ne_one_class</code> o_O?</p>",
        "id": 124057451,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1521719646
    },
    {
        "content": "<p>I think that class is misguided, since it doesn't play well with the rest of the hierarchy. It's one of those ossified things that will eventually go away when the alg hierarchy changes</p>",
        "id": 124057462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521719716
    },
    {
        "content": "<p>I guess that's because it's only true for some rings...</p>",
        "id": 124057511,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1521719825
    },
    {
        "content": "<p>The problem is that it was intended as a mixin (who cares about an arbitrary structure with two unequal elements named 0 and 1 and no other laws?) but structure mixins don't work like this anymore</p>",
        "id": 124057855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521720596
    },
    {
        "content": "<p>Ok, reading the source, <code>zero_ne_one</code> effectively boils down to</p>\n<div class=\"codehilite\"><pre><span></span>example : (0  ≠  1) :=  λ h, nat.no_confusion h\n</pre></div>\n\n\n<p>Is it generally true that given any two <em>different</em> terms, generated by applying different constructors or constructors in different order of <code>some_inductive_type</code></p>\n<div class=\"codehilite\"><pre><span></span>inductive  some_inductive_type : Type\n| constructor_a : ...\n| constructor_b : ...\n</pre></div>\n\n\n<p><code>some_inductive_type.no_confusion</code> will be able  to distinguish between them?</p>",
        "id": 124058082,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1521720983
    },
    {
        "content": "<p>yes, that's its main purpose. The other purpose is that <code>no_confusion</code>, acting on the same constructors, gives back equalities of the constructor arguments</p>",
        "id": 124058094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521721052
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  and <span class=\"user-mention\" data-user-id=\"110027\">@Moses Schönfinkel</span> , this is very clear now.</p>",
        "id": 124058258,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1521721361
    },
    {
        "content": "<p>No worries. It's basically information one recovers from the fact that constructors for any given inductive type are disjoint and injective.</p>",
        "id": 124058438,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1521721697
    },
    {
        "content": "<p>I am confused about why Mario is surprised. 0 ne 1 is an axiom in some structures e.g. integral domains, which extend rings, so we surely expect to see these silly typeclasses for the same reason we see distribs. What am I missing?</p>",
        "id": 124058460,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521721753
    },
    {
        "content": "<p>distrib is also a silly typeclass which doesn't serve its intended purpose</p>",
        "id": 124058469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1521721792
    },
    {
        "content": "<p>I am confused about why Mario is surprised. 0 ne 1 is an axiom in some structures e.g. integral domains, which extend rings, so we surely expect to see these silly typeclasses for the same reason we see distribs. What am I missing?</p>",
        "id": 124058632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521721981
    },
    {
        "content": "<p>Is this something to do with the old structure command? Are these silly typeclasses going to disappear in Lean 4 perhaps?</p>",
        "id": 124058652,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1521722039
    },
    {
        "content": "<p>I am certain they'll be gone by the time Lean 7 is out.</p>",
        "id": 124058705,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1521722083
    }
]
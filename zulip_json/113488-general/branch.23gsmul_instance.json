[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> has started a major refactor of mathlib at <a href=\"https://github.com/leanprover-community/mathlib/tree/gsmul_instance\">branch#gsmul_instance</a>. The goal is to get rid of the global instances <code>add_comm_monoid.nat_semimodule</code>, <code>add_comm_group.int_module</code> and <code>algebra_int</code>. So far, it seems to be a lot of work, but also means we get rid of a lot of annoying diamond problems. So it definitely seems worth it. Kudos to <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> ! <span aria-label=\"muscle\" class=\"emoji emoji-1f4aa\" role=\"img\" title=\"muscle\">:muscle:</span> <span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span> </p>\n<p>I just did a bit of work on this branch, and Lean complained that it couldn't find an instance <code>algebra int (zmod p)</code>. Of course this is to be expected. So I went back to the file on <code>zmod</code>, and added that instance. But during breakfast I realised that Lean will also need <code>algebra nat (zmod p)</code>. You see where this is going: for every</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">foo_bar</span> <span class=\"n\">quux</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>we will now need two extra lines</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">nat</span> <span class=\"o\">(</span><span class=\"n\">foo_bar</span> <span class=\"n\">quux</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">algebra_nat</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">int</span> <span class=\"o\">(</span><span class=\"n\">foo_bar</span> <span class=\"n\">quux</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">algebra_int</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>(Actually, <code>algebra nat</code> should already happen for every <code>semiring</code>.)<br>\nAnd we also need <code>instance : module int (xyzzy baz)</code> for every <code>instance : add_comm_group (xyzzy baz)</code>.</p>\n<p>Is this something that we can automate? Can we change Lean 3.37.42, so that it will trigger extra instance declarations whenever it parses one of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"c1\">-- or comm_semiring</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"c1\">-- or comm_ring</span>\n</code></pre></div>",
        "id": 232985623,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617431499
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span></p>",
        "id": 232986170,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617432140
    },
    {
        "content": "<p>Would it be helpful or disrupting to have a nat_semimodule instance on int alone?</p>",
        "id": 232986231,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617432244
    },
    {
        "content": "<p>I think we need it on every abelian group.</p>",
        "id": 232986472,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617432564
    },
    {
        "content": "<p>I had a crazy idea that should fix all the diamond issues while keeping the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>-module instance on <code>add_comm_group</code>s. I'd like to hear your thoughts about it.</p>",
        "id": 232987485,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617433803
    },
    {
        "content": "<p>But you want to disable <code>algebra_int</code>, right?</p>",
        "id": 232987619,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617433936
    },
    {
        "content": "<p>If you keep <code>add_comm_group.int_module</code>, how can we make sure that we don't hit diamonds on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> again?</p>",
        "id": 232987653,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617433999
    },
    {
        "content": "<p><em>The problem</em>: we want every <code>add_comm_group</code> to be a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>-module. For now, this is registered through the instance <code>add_comm_group.int_module</code>, where the multiplication is <code>gsmul</code>, defined by induction over the integer, through the addition. But some <code>add_comm_group</code>s get different module instances. For instance, if <code>M</code> and <code>N</code> are modules over a ring <code>R</code>, then the space of linear maps <code>M →ₗ[R] N</code> has both an <code>add_comm_group</code> and an <code>R</code>-module structure. When <code>R = ℤ</code>, you get two <code>ℤ</code>-module structures on <code>M →ₗ[ℤ] N</code>, the <code>add_comm_group.int_module</code> one, and the one coming from the linear structure. And they are not defeq.</p>",
        "id": 232987669,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617434028
    },
    {
        "content": "<p><em>The solution</em>: a variation on forgetful inheritance. I want to <em>enrich</em> the definition of <code>add_comm_group</code>, by adding data: a <code>ℤ</code>-action with the right axioms. Then the instance from <code>add_comm_group</code> to <code>ℤ</code>-modules would use this data (and we would remove completely <code>add_comm_group.int_module</code>). We would only need to make sure that whenever one can construct a new <code>ℤ</code>-module, the module structure is defeq to the one stored in the <code>add_comm_group</code>.</p>",
        "id": 232987832,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617434203
    },
    {
        "content": "<p>But then we can do the same thing with <code>comm_ring</code> and <code>algebra_int</code>, right?</p>",
        "id": 232987910,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617434314
    },
    {
        "content": "<p>So we should remove that <code>algebra int (zmod n)</code> instances again?</p>",
        "id": 232987916,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617434328
    },
    {
        "content": "<p><em>An example</em>: when we define <code>M →ₗ[R] N</code>, we have to register an <code>add_comm_group</code> on this space. According to the scheme above, we should be careful about the compatibility. Since the <code>R</code>-action is given by <code>(r • f) (x) = r • (f x)</code>, using the action in the target space, we define the <code>ℤ</code>-action in the same way, by <code>(n • f) (x) = n • (f x)</code>. Then in the particular case of <code>R = ℤ</code>, everything matches, and there is no diamond.</p>",
        "id": 232987948,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617434397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/branch.23gsmul_instance/near/232987910\">said</a>:</p>\n<blockquote>\n<p>But then we can do the same thing with <code>comm_ring</code> and <code>algebra_int</code>, right?</p>\n</blockquote>\n<p>Since a <code>comm_ring</code> is in particular an <code>add_comm_group</code>, yes, it would carry such a <code>ℤ</code>-action. We can define it to be left-multiplication. And then in the case of <code>R = ℤ</code>, it means that our <code>ℤ</code>-module structure coming from the <code>add_comm_group</code> would be defeq to the <code>ℤ</code>-module structure coming from the ring structure, without having to tweak the definition of <code>ℤ</code>-multiplication.</p>",
        "id": 232988093,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617434522
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/branch.23gsmul_instance/near/232987916\">said</a>:</p>\n<blockquote>\n<p>So we should remove that <code>algebra int (zmod n)</code> instances again?</p>\n</blockquote>\n<p>Yes, we would also remove all the manual <code>algebra_int</code> instances, and define a global one that would be completely diamond-free.</p>",
        "id": 232988155,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617434563
    },
    {
        "content": "<p>ok, I think I see how this is going to work.</p>",
        "id": 232988164,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617434583
    },
    {
        "content": "<p>But we'll need to do the same trick for <code>nat</code> and <code>add_comm_monoid</code></p>",
        "id": 232988180,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617434597
    },
    {
        "content": "<p>And we should also do the same for <code>nat</code> and <code>add_comm_monoid</code>, yes.</p>",
        "id": 232988184,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617434611
    },
    {
        "content": "<p>I say this is a crazy idea because this would be a <em>huge</em> refactor.</p>",
        "id": 232988200,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617434638
    },
    {
        "content": "<p>But this <code>ℤ</code>-module thing has been a major painpoint several times, so I think it would probably be worth it.</p>",
        "id": 232988252,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617434671
    },
    {
        "content": "<p>I have a few questions abouth this idea:</p>",
        "id": 232988269,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617434692
    },
    {
        "content": "<p>And then there is <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/data/zmod/basic.lean#L337\">https://github.com/leanprover-community/mathlib/blob/master/src/data/zmod/basic.lean#L337</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">zmod.cast_hom</span> <span class=\"o\">(</span><span class=\"n\">dvd_refl</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_algebra</span>\n</code></pre></div>",
        "id": 232988278,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617434705
    },
    {
        "content": "<p>So we can now get two instances of <code>algebra (zmod n) (zmod n)</code></p>",
        "id": 232988299,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617434730
    },
    {
        "content": "<p>1) would it really solve all diamond problems in this area one can think of (<span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> has thought a lot about it, so maybe he could think of other examples I have overlooked).</p>",
        "id": 232988302,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617434737
    },
    {
        "content": "<p>One from <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> and another from <code>algebra.id</code></p>",
        "id": 232988308,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617434745
    },
    {
        "content": "<p>2) For the implementation, I expect that we could add a default field and defaults arguments for the prop fields, so hopefully this shouldn't make to much of a difference in definitions where we don't care about the defeqness, and we would only change things where they matter. But I wonder about things like <code>to_additive</code> or the <code>additive/multiplicative</code> tricks, especially since the fields in <code>add_comm_group</code> and <code>comm_group</code> would not match any more.</p>",
        "id": 232988394,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617434877
    },
    {
        "content": "<p>3) Performancewise, we would be adding data fields to a lot of structures we use all the time in mathlib, so how bad would it be?</p>",
        "id": 232988450,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617434911
    },
    {
        "content": "<p>4) This seems directly related to the issue of numerics in Lean 4. With the above design, we should probably essentially never use any more <code>int.cast</code>, and replace it with the field in the <code>add_comm_group</code> structure applied to <code>1</code>, or something like that. If we do such a refactor, we'd better plan it to be compatible with the implementation of numerics we want in Lean 4 (which I haven't really followed). <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, do you have thoughts about this?</p>",
        "id": 232988573,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617435056
    },
    {
        "content": "<p>This would mean ditching my branch  <a href=\"https://github.com/leanprover-community/mathlib/tree/gsmul_instance\">branch#gsmul_instance</a>, but I don't care, this seems like a much better solution. I'm done with my rant, and I'm going to the sea because it's our last day of freedom before yet another lockdown, but I'll be happy to read what you think of it when I'm back this evening :-)</p>",
        "id": 232988648,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617435156
    },
    {
        "content": "<p>The idea for numerics in lean 4 was to add a field <code>ofNat</code> to the base structures like <code>semiring</code>. From such a structure you get a natural interpretation of <code>nsmul</code>, although not <code>gsmul</code> (unless we extend the field to <code>ofInt</code>)</p>",
        "id": 232989069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617435677
    },
    {
        "content": "<p>That is, <code>nat.cast</code> would become a projection</p>",
        "id": 232989078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617435708
    },
    {
        "content": "<p>That's not quite the same as what you are proposing, which is to add <code>n * x</code> as a field of the structure. Perhaps we want both?</p>",
        "id": 232989155,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617435818
    },
    {
        "content": "<p>Well at least on semirings there is a natural definition of <code>n * x</code> as <code>ofNat n * x</code></p>",
        "id": 232989195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617435847
    },
    {
        "content": "<p>Right, but we also need something that works for groups</p>",
        "id": 232989396,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617436091
    },
    {
        "content": "<p>What's the advantage of adding fields to <code>add_comm_group</code> here, vs just remembering to add a few explicit nat_semimodule instances?</p>",
        "id": 232989618,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617436388
    },
    {
        "content": "<p>I suspect we would actually need very few</p>",
        "id": 232989636,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617436436
    },
    {
        "content": "<p>There don't seem to be many \"primitive\" types, my impression is that most are compound types like linear_map which inherit the module structure</p>",
        "id": 232989692,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617436484
    },
    {
        "content": "<p>Ah, the argument is it combines <code>[add_comm_monoid A] [semimodule nat A]</code> into a single parameter</p>",
        "id": 232991221,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617438425
    },
    {
        "content": "<p>Not the same, but related, I think:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.algebra_map</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">polynomial.algebra_of_algebra</span>\n\n<span class=\"c1\">-- it seems that this is not yet in mathlib</span>\n<span class=\"kd\">instance</span> <span class=\"n\">polynomial.map_algebra</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">polynomial.map_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_algebra</span>\n\n<span class=\"kd\">lemma</span> <span class=\"bp\">«</span><span class=\"n\">problem</span><span class=\"bp\">?»</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)))</span>\n  <span class=\"n\">polynomial.algebra_of_algebra</span>\n  <span class=\"n\">polynomial.map_algebra</span>\n  <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 232993149,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617440836
    },
    {
        "content": "<p>Why stop at <code>add_comm_group</code>? Why not register some kind of action of nat on all monoids and add_monoids, and an action of int on all groups and add_groups? We have this already, it's just monoid.pow etc. The axiom <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mi>h</mi><msup><mo stretchy=\"false\">)</mo><mi>n</mi></msup><mo>=</mo><msup><mi>g</mi><mi>n</mi></msup><msup><mi>h</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">(gh)^n=g^nh^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> doesn't hold in general but we could just throw this in later with the commutativity assumptions. We could at the same time try to solve the problem that <code>to_additive</code> can't handle power stuff because the order of the inputs is wrong, by making g^n mean n bub g.</p>\n<p>Would this mean that we would not have to persuade Leo to change the definition of natural multiplication in Lean 4 or is that another thing?</p>",
        "id": 232994084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617442050
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, are you convinced that statement is true?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.algebra_map</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">polynomial.algebra_of_algebra</span>\n\n<span class=\"c1\">-- it seems that this is not yet in mathlib</span>\n<span class=\"kd\">instance</span> <span class=\"n\">polynomial.map_algebra</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">polynomial.map_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_algebra</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">map_algebra_smul</span> <span class=\"o\">(</span><span class=\"n\">pr</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pa</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">pr</span> <span class=\"bp\">•</span> <span class=\"n\">pa</span> <span class=\"bp\">=</span> <span class=\"n\">polynomial.map_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">pr</span> <span class=\"bp\">*</span> <span class=\"n\">pa</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">algebra_of_algebra_smul</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pa</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">pa</span> <span class=\"bp\">=</span> <span class=\"n\">finsupp.map_range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">smul_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">pa</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"bp\">«</span><span class=\"n\">problem</span><span class=\"bp\">?»</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)))</span>\n  <span class=\"n\">polynomial.algebra_of_algebra</span>\n  <span class=\"n\">polynomial.map_algebra</span>\n  <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_algebra_smul</span><span class=\"o\">,</span> <span class=\"n\">algebra_of_algebra_smul</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 232998169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617447164
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7019\">#7019</a> adds a lemma that might make that <code>sorry</code> easier to prove, as then we can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">polynomial.map_algebra_self_algebra_map</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">ring_hom.id</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">polynomial.map_ring_hom_id</span>\n</code></pre></div>",
        "id": 232999514,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617448796
    },
    {
        "content": "<p>I've started looking at this. There is something that is a mystery for me, maybe it will look obvious to some of you. Suppose that I have changed the definition  of <code>comm_monoid</code> to add a field with data. As follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.inj_surj</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"sd\">/-- The power operation in a monoid. `a^n = a*a*...*a` n times. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">monoid.pow_rec</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">monoid.pow_rec</span> <span class=\"n\">n</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">@[ancestor monoid comm_semigroup]</span>\n<span class=\"kd\">class</span> <span class=\"n\">my_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">comm_semigroup</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">nspow</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">monoid.pow_rec</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nspow_add'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">nspow</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">nspow</span> <span class=\"n\">m</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">nspow</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I will want to fill the last field with a tactic to do it automatically, but before that let's do by hand the first breaking example, in <code>inj_surj.lean</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">my_comm_monoid_of_injective</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_comm_monoid</span> <span class=\"n\">M₁</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">nspow_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.add_zero</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.add_succ</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"o\">}</span> <span class=\"c1\">-- fails</span>\n  <span class=\"kd\">end</span>\n  <span class=\"bp\">..</span> <span class=\"n\">hf.comm_semigroup</span> <span class=\"n\">f</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"n\">hf.monoid</span> <span class=\"n\">f</span> <span class=\"n\">one</span> <span class=\"n\">mul</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Here, the <code>rw mul_one</code> in the first step of the induction succeeds, which means it is able to somehow find the <code>mul_one_class</code> instance, which is probably coming from the last line with <code>.. hf.monoid f one mul, .. hf.comm_semigroup f mul</code>. Then, in the second step of the induction, it can rewrite <code>mul_assoc</code>, so it finds the semigroup instance. Unfortunately, the <code>rw mul_comm a _</code> fails, which means it doesn't find the <code>comm_semigroup</code> instance, which should follow from the same line.</p>\n<p>Do you understand what is going on, and if there is a generic enough fix?</p>",
        "id": 233026073,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617477170
    },
    {
        "content": "<p>Unrelated to the above: but if this refactor means that <code>add_monoid_hom</code> will be defeq (for groups?) to <code>Z</code>-linear module homs, that would would be insanely cool.</p>",
        "id": 233026260,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617477347
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Can you prove the <code>pow_add</code> lemma for <code>monoid.pow_rec</code> in a separate lemma? Does that help at the location of the error?</p>",
        "id": 233026340,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617477410
    },
    {
        "content": "<p>Yes, I can prove it, and the proof I have given works fine. The question here is really about which instances are available when doing proofs inside fields of a structure.</p>",
        "id": 233026372,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617477458
    },
    {
        "content": "<p>How does the proposed <code>nsmul</code> field end up mapped to an <code>has_scalar</code> instance?</p>",
        "id": 233026849,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617477905
    },
    {
        "content": "<p>Later on, we will declare a <code>has_scalar ℕ M</code> instance on all <code>add_comm_group</code>s using this field. But for now, I am only starting with the simplest stuff, i.e., adding the fields, making sure that they are populated when creating the structure, but not using them yet. If I can't do this properly, I won't be able to go any further.</p>",
        "id": 233027118,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617478173
    },
    {
        "content": "<p>A good joke in my mwe: if instead of the automatically populated field <code>nspow</code> you fill it by hand, then you get an error at a different place:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">my_comm_monoid_of_injective</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_comm_monoid</span> <span class=\"n\">M₁</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">nspow</span> <span class=\"o\">:=</span> <span class=\"n\">monoid.pow_rec</span> <span class=\"n\">M₁</span><span class=\"o\">,</span>\n  <span class=\"n\">nspow_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.add_zero</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span> <span class=\"o\">},</span> <span class=\"c1\">-- already fails</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.add_succ</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">hf.comm_semigroup</span> <span class=\"n\">f</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"n\">hf.monoid</span> <span class=\"n\">f</span> <span class=\"n\">one</span> <span class=\"n\">mul</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Really weird...</p>",
        "id": 233027555,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617478514
    },
    {
        "content": "<p>The idea here is that, for example, <code>prod.add_comm_group.nsmul</code> would be designed such that it's defeq to <code>prod.has_scalar.smul</code>?</p>",
        "id": 233028458,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617479394
    },
    {
        "content": "<p>Yes, exactly. Just like it's done for metric spaces and uniform spaces.</p>",
        "id": 233028567,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617479485
    },
    {
        "content": "<p>A workaround to my problem is to change my prop field, using instead <code>nspow_eq_rec : ∀ (n : ℕ) (x : M), nspow n x = monoid.pow_rec n x</code>, which can be proved by <code>rfl</code> when using the default field, so no need to activate other classes. This solves my issue (though it will need some tweaks down the road with alternate constructors, but nothing bad), but still I'd be interested to understand what is going on here.</p>",
        "id": 233029963,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617480876
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">my_comm_monoid_of_injective</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_comm_monoid</span> <span class=\"n\">M₁</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">nspow_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">comm_semigroup</span> <span class=\"n\">M₁</span> <span class=\"o\">:=</span> <span class=\"n\">hf.comm_semigroup</span> <span class=\"n\">f</span> <span class=\"n\">mul</span><span class=\"o\">,</span>\n    <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">monoid</span> <span class=\"n\">M₁</span> <span class=\"o\">:=</span> <span class=\"n\">hf.monoid</span> <span class=\"n\">f</span> <span class=\"n\">one</span> <span class=\"n\">mul</span><span class=\"o\">,</span>\n  <span class=\"k\">assume</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.add_zero</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">],</span>\n      <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- monoid.pow_rec M₁ m a * 1 = monoid.pow_rec M₁ m a</span>\n      <span class=\"n\">exact</span> <span class=\"n\">mul_one</span> <span class=\"o\">(</span><span class=\"n\">monoid.pow_rec</span> <span class=\"n\">M₁</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">},</span> <span class=\"c1\">-- fails &lt;---------------------------------------------------------------------</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.add_succ</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"o\">}</span> <span class=\"c1\">-- fails</span>\n  <span class=\"kd\">end</span>\n  <span class=\"bp\">..</span> <span class=\"n\">hf.comm_semigroup</span> <span class=\"n\">f</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"n\">hf.monoid</span> <span class=\"n\">f</span> <span class=\"n\">one</span> <span class=\"n\">mul</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>gives</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>unexpected argument at application\n  @mul_one M₁ _inst_4 (@monoid.pow_rec M₁ _inst_1 _inst_2 m a)\ngiven argument\n  @monoid.pow_rec M₁ _inst_1 _inst_2 m a\nexpected argument\n  @monoid.pow_rec M₁\n    (@semigroup.to_has_mul M₁\n       (@monoid.to_semigroup M₁\n          (@monoid.mk M₁\n             (@comm_semigroup.mul M₁\n                (@function.injective.comm_semigroup M₁ M₂ _inst_1 (@comm_monoid.to_comm_semigroup M₂ _inst_3) f hf\n                   mul))\n             _\n             (@monoid.one M₁\n                (@function.injective.monoid M₁ M₂ _inst_1 _inst_2 (@comm_monoid.to_monoid M₂ _inst_3) f hf one\n                   mul))\n             _\n             _)))\n    (@monoid.to_has_one M₁\n       (@monoid.mk M₁\n          (@comm_semigroup.mul M₁\n             (@function.injective.comm_semigroup M₁ M₂ _inst_1 (@comm_monoid.to_comm_semigroup M₂ _inst_3) f hf\n                mul))\n          _\n          (@monoid.one M₁\n             (@function.injective.monoid M₁ M₂ _inst_1 _inst_2 (@comm_monoid.to_monoid M₂ _inst_3) f hf one mul))\n          _\n          _))\n    m\n    a\n</code></pre></div>",
        "id": 233036376,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617487491
    },
    {
        "content": "<p>Aah, <code>convert</code> instead of <code>exact</code> gives the goals <code>⊢ semigroup.to_has_mul M₁ = _inst_1</code> and <code>⊢ monoid.to_has_one M₁ = _inst_2</code>. So this is probably your problem: you have two non-defeq <code>mul</code>s on <code>M_1</code>, one coming from the <code>[has_mul M_1]</code> and one coming from pulling back multiplication on <code>M_2</code> and your <code>mul</code> axiom is not definitional (and similarly you have non-definitional 1s).</p>",
        "id": 233036825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617487937
    },
    {
        "content": "<p>OK so this is beyond my pay grade. If we look at the code you originally posted, as you say the <code>rw mul_one</code> in the first step of the induction succeeds. For the rewrite to succeed, Lean must be inferring an instance of <code>monoid M1</code> somehow, and you would imagine that the type class inference system is doing this, but it is <em>not</em>! Indeed <code>letI : monoid M₁ := by apply_instance,</code> on the line before <em>fails</em>! So Lean is doing some kind of magic which happens when creating structures where it looks at the <code>..</code> stuff but this is somehow not in the type class inference cache at the point where I am trying to infer an instance?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">my_comm_monoid_of_injective</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_comm_monoid</span> <span class=\"n\">M₁</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">nspow_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.add_zero</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">],</span>\n      <span class=\"c1\">-- ⊢ monoid.pow_rec M₁ m a = monoid.pow_rec M₁ m a * 1</span>\n      <span class=\"c1\">-- letI : monoid M₁ := by apply_instance, -- this FAILS</span>\n      <span class=\"c1\">-- and the next line will only work if Lean can find a monoid structure on M₁</span>\n      <span class=\"n\">rw</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"c1\">-- but it works anyway!</span>\n     <span class=\"o\">},</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 233037709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617488914
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 233037983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617489210
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 233038803,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617490160
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">my_comm_monoid_of_injective</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_comm_monoid</span> <span class=\"n\">M₁</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">nspow_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">comm_semigroup</span> <span class=\"n\">M₁</span> <span class=\"o\">:=</span> <span class=\"n\">hf.comm_semigroup</span> <span class=\"n\">f</span> <span class=\"n\">mul</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.add_zero</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.add_succ</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">hf.comm_semigroup</span> <span class=\"n\">f</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"n\">hf.monoid</span> <span class=\"n\">f</span> <span class=\"n\">one</span> <span class=\"n\">mul</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 233039171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617490606
    },
    {
        "content": "<p>Isn't the axiomatization of <code>nspow</code> incomplete? It's not possible to prove <code>nspow 0 x = 1</code></p>",
        "id": 233039238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617490694
    },
    {
        "content": "<p>(you can prove it is idempotent but I don't think that's good enough to conclude it is <code>1</code> in a monoid)</p>",
        "id": 233039273,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617490775
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">my_comm_monoid_of_injective</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">my_comm_monoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">nspow₁</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₁</span> <span class=\"o\">:=</span> <span class=\"n\">monoid.pow_rec</span> <span class=\"n\">M₁</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">nsm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">nspow₁</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">my_comm_monoid.nspow</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_comm_monoid</span> <span class=\"n\">M₁</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">nspow</span> <span class=\"o\">:=</span> <span class=\"n\">nspow₁</span><span class=\"o\">,</span>\n  <span class=\"n\">nspow_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">change</span> <span class=\"n\">nspow₁</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">nspow₁</span> <span class=\"n\">m</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">nspow₁</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nsm</span><span class=\"o\">,</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"n\">nsm</span><span class=\"o\">,</span> <span class=\"n\">nsm</span><span class=\"o\">,</span> <span class=\"n\">my_comm_monoid.nspow_add'</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">hf.comm_semigroup</span> <span class=\"n\">f</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"n\">hf.monoid</span> <span class=\"n\">f</span> <span class=\"n\">one</span> <span class=\"n\">mul</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 233039592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617491114
    },
    {
        "content": "<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ancestor monoid comm_semigroup]</span>\n<span class=\"kd\">class</span> <span class=\"n\">my_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">comm_semigroup</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">nspow</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">monoid.pow_rec</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nspow_eq'</span> <span class=\"o\">:</span> <span class=\"n\">nspow</span> <span class=\"bp\">=</span> <span class=\"n\">monoid.pow_rec</span> <span class=\"n\">M</span> <span class=\"bp\">.</span> <span class=\"n\">control_laws_tac</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">my_comm_monoid_of_injective</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">my_comm_monoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">nspow</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₁</span> <span class=\"o\">:=</span> <span class=\"n\">monoid.pow_rec</span> <span class=\"n\">M₁</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">nsm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">nspow</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">my_comm_monoid.nspow</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_comm_monoid</span> <span class=\"n\">M₁</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">nspow</span> <span class=\"o\">:=</span> <span class=\"n\">nspow</span><span class=\"o\">,</span>\n  <span class=\"n\">nspow_eq'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">funext</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nsm</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">_</span><span class=\"bp\">=</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">my_comm_monoid.nspow_eq'</span><span class=\"o\">],</span>\n    <span class=\"n\">induction</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">one.symm</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"n\">n_ih</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul</span><span class=\"o\">],</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">hf.comm_semigroup</span> <span class=\"n\">f</span> <span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"n\">hf.monoid</span> <span class=\"n\">f</span> <span class=\"n\">one</span> <span class=\"n\">mul</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 233040022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617491655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/branch.23gsmul_instance/near/233039238\">said</a>:</p>\n<blockquote>\n<p>Isn't the axiomatization of <code>nspow</code> incomplete? It's not possible to prove <code>nspow 0 x = 1</code></p>\n</blockquote>\n<p>Sure, it was just for the mwe but I also have the other axioms in my files.</p>",
        "id": 233062342,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617519932
    },
    {
        "content": "<p>Mario and Kevin, your solutions work, but they are specific to the problem at hand. My goal was really to do the following: endow a type with the power <code>monoid.pow_rec</code> (not another one) and prove with a universal tactic block that it satisfies the axioms, so that this tactic block can be used in all situations and then automated. The pullback comm_monoid was just an example of a situation where my universal tactic block, which most often works, failed because of Lean not finding the right instance. I can absolutely do it by hand or by modifying the definition like you did, but I was looking for a more principled solution which would always work automatically. Anyway, the solution to change the axioms by requiring instead equality with <code>monoid.pow_rec</code> works (the automatic proof is just by <code>rfl</code> and always works), so I'll go this route.</p>",
        "id": 233062658,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617520295
    },
    {
        "content": "<p>I would suggest avoiding a full tactic block in an auto param unless you actually need to do something tactic-like such as inspecting the kind of definition that the user gave. If it's just a theorem parametric on values provided by the user then you should prove a lemma and the auto_param tactic should be essentially <code>apply my_lemma</code></p>",
        "id": 233062914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617520627
    },
    {
        "content": "<p>That's what I did first, but the <code>my_lemma</code> needs some typeclasses that are not found, for the same reason as in my <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (that I minimized by removing the lemma and the tactic to get to the heart of the issue).</p>",
        "id": 233063272,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617521139
    },
    {
        "content": "<p>you may have to supply the typeclasses manually, since as kevin observed there is a bit of magic to construct the typeclass argument for <code>extends</code> structures inside a structure literal</p>",
        "id": 233063537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617521514
    },
    {
        "content": "<p>Yes, my question was precisely about this magic bit, and if I could make it even a little bit more magical to just work in all situations :-)</p>",
        "id": 233063684,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617521648
    },
    {
        "content": "<p>The fix in the tactic example is to add <code>letI := hf.comm_semigroup f mul</code> but I think I'm missing the actual question</p>",
        "id": 233063745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617521720
    },
    {
        "content": "<p>The tactic state inside structure fields is a bit of a mess since there are a bunch of typeclasses inside things like <code>has_mul.mul</code> that aren't actually in the context, so some theorems will work by unification and others will fail because the typeclass isn't available</p>",
        "id": 233063816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617521818
    },
    {
        "content": "<p>The actual question is \"is there a way to not need a fix\"?</p>",
        "id": 233063819,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617521825
    },
    {
        "content": "<p>Well there's an error in the provided tactic block, so no?</p>",
        "id": 233063829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617521846
    },
    {
        "content": "<p>And I suspect the answer is no.</p>",
        "id": 233063830,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617521847
    },
    {
        "content": "<p>of course the tactic block or statement has to change to make it work</p>",
        "id": 233063833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617521868
    },
    {
        "content": "<p>but this seems like a tautology</p>",
        "id": 233063882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617521897
    },
    {
        "content": "<p>Or maybe the question is \"is there a way to fix Lean to not need a fix in this kind of situation\"?</p>",
        "id": 233063886,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617521910
    },
    {
        "content": "<p>Or \"is there a magic instruction I could add in my tactic block to infer the instances I need from the <code>.. </code> line\"?</p>",
        "id": 233063902,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617521955
    },
    {
        "content": "<p>(Without adding it by hand, because by hand it would depend on the specific situation and I  want a fix that always works)</p>",
        "id": 233063930,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617522004
    },
    {
        "content": "<p>Well part of the issue is that this uses <code>old_structure_cmd</code>. When you use <code>{ .. hf.comm_semigroup f mul }</code>, it has to splat out the projections into the structure, so it's not like <code>letI : comm_semigroup M₁ := hf.comm_semigroup f mul</code> was actually added to the context. If you had <code>comm_semigroup M₁</code> available to the typeclass system, then in the new structure command it would pick that instance up since it would be a typeclass argument to <code>my_comm_monoid.mk</code>. With the old structure command it can't be, it is splatted out into fields, so you have to specify it in both places</p>",
        "id": 233064086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617522194
    },
    {
        "content": "<p>One way to write it without repetition is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">hf.comm_semigroup</span> <span class=\"n\">f</span> <span class=\"n\">mul</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">{</span> <span class=\"n\">nspow_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"k\">assume</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n      <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.add_zero</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.add_succ</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">monoid.pow_rec</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n    <span class=\"kd\">end</span>\n    <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">comm_semigroup</span> <span class=\"n\">M₁</span><span class=\"o\">),</span>\n    <span class=\"bp\">..</span> <span class=\"n\">hf.monoid</span> <span class=\"n\">f</span> <span class=\"n\">one</span> <span class=\"n\">mul</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>but that's not exactly shorter</p>",
        "id": 233064152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617522286
    },
    {
        "content": "<p>The mystery to me is that it finds <em>some</em> instances, like <code>mul_one_class</code>. And it doesn't find the same ones if the <code>nspow</code> field is populated by hand or with the tactic.</p>",
        "id": 233064196,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617522344
    },
    {
        "content": "<p>are you sure it found <code>mul_one_class</code>? It probably just got it by unification</p>",
        "id": 233064271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617522426
    },
    {
        "content": "<p>You can try the example in <a href=\"#narrow/stream/113488-general/topic/branch.23gsmul_instance/near/233026073\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/branch.23gsmul_instance/near/233026073</a></p>",
        "id": 233064370,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617522505
    },
    {
        "content": "<p>(and then try it again by filling the <code>nspow</code> field by hand instead of with the automatic block, to see the difference).</p>",
        "id": 233064451,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617522613
    },
    {
        "content": "<p>What's the goal state at the failing mul_comm?</p>",
        "id": 233064549,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1617522759
    },
    {
        "content": "<p>Indeed, if you provide <code>nspow := monoid.pow_rec M₁</code> (that is, <code>@monoid.pow_rec M₁ _inst_1 _inst_2</code>), then at the failing <code>mul_one</code> application the goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">has_mul.mul</span> <span class=\"n\">M₁</span> <span class=\"o\">(</span><span class=\"n\">mul_one_class.to_has_mul</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">has_one.one</span> <span class=\"n\">M₁</span> <span class=\"n\">_inst_2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and if you don't provide it and let it fill in automatically <code>monoid.pow_rec M₁</code> (that is, <code>@monoid.pow_rec M₁ (mul_one_class.to_has_mul M₁) (mul_one_class.to_has_one M₁)</code>), then the goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">has_mul.mul</span> <span class=\"n\">M₁</span> <span class=\"o\">(</span><span class=\"n\">mul_one_class.to_has_mul</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">has_one.one</span> <span class=\"n\">M₁</span> <span class=\"o\">(</span><span class=\"n\">mul_one_class.to_has_one</span> <span class=\"n\">M₁</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and so <code>mul_one_class.mul_one</code> actually matches by unification, not by typeclass inference.</p>",
        "id": 233064812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617523157
    },
    {
        "content": "<p>Ah, thanks for explaining the mystery! I am still wondering why filling it with the tactic block uses <code>has_mul.mul M₁ (mul_one_class.to_has_mul M₁) _ (has_one.one M₁ (mul_one_class.to_has_one M₁))</code>, and especially where the tactic block is finding this <code>mul_one_class</code> instance.</p>",
        "id": 233065001,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617523326
    },
    {
        "content": "<p>You might wonder why the automatic instantiation of <code>nspow</code> has <code>mul_one_class</code> all over it, and that's because of a trick that lean uses while elaborating the <code>monoid.pow_rec M</code> in the opt_param inside the structure definition of <code>my_comm_monoid</code>. The context at that point doesn't actually have a <code>monoid</code> instance in it, it has a bunch of fields, but lean will actually add the equivalent of <code>letI := &lt;mul, one, mul_one, one_mul&gt;</code> to typeclass inference (it's not actually using <code>letI</code> since this is part of core lean) in order to elaborate it, so you end up with these explicit <code>monoid.mk</code> things inside typeclass args</p>",
        "id": 233065071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617523418
    },
    {
        "content": "<p>ok, thanks a lot!</p>",
        "id": 233065145,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617523495
    },
    {
        "content": "<p>if you replace the field with <code>(nspow : ℕ → M → M := by show_term {exact monoid.pow_rec M})</code> with <code>pp.all</code> you will see that it is actually </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid.pow_rec</span> <span class=\"n\">M₁</span>\n            <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_one_class.to_has_mul</span> <span class=\"n\">M₁</span>\n               <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid.to_mul_one_class</span> <span class=\"n\">M₁</span>\n                  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">monoid.mk</span> <span class=\"n\">M₁</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 233065236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617523573
    },
    {
        "content": "<p>Does it mean that if I defined my <code>pow_rec</code> to also take an instance <code>[comm_semi_group G]</code>, then core Lean would also find it and add it here, and then it would be available by unification in the tactic block proof?</p>",
        "id": 233065245,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617523583
    },
    {
        "content": "<p>Unfortunately, you are pretty limited when it comes to using unification to find things, because that depends on the actual sequence of things in the hierarchy of typeclasses leading to the projections that were used</p>",
        "id": 233065278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617523661
    },
    {
        "content": "<p>you just got lucky here with <code>mul_one_class</code>, most instances can't be found this way</p>",
        "id": 233065310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617523684
    },
    {
        "content": "<p>If there are any defeq diamonds like <code>A -&gt; B -&gt; D</code> and <code>A -&gt; C -&gt; D</code> and typeclass inference finds the first path (in a context where you have <code>A</code> and need <code>D</code>), then theorems about <code>B</code> will trigger but not theorems about <code>C</code></p>",
        "id": 233065433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617523813
    },
    {
        "content": "<p>Just to summarize the discussion: there is a magical tactic \"pull an instance out of thin air\" that is used by Lean core C++ when filling in <code>opt_param</code> fields of structures. Unfortunately, it is not accessible to mere mortal users. Thanks Mario for the explanations!</p>",
        "id": 233067708,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617526878
    }
]
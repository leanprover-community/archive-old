[
    {
        "content": "<p>Hey everyone,</p>\n<p>I've been working on a small project recently to formalize polynomial time complexity. You can check it out here: <a href=\"https://github.com/prakol16/lean_complexity_theory_polytime_trees\">https://github.com/prakol16/lean_complexity_theory_polytime_trees</a>.</p>\n<p>I have a tactic <code>polyfun</code> which tries to automatically prove that functions run in polynomial time. The core idea of the tactic is to split a goal of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"n\">polytime_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">...</span> <span class=\"o\">(</span><span class=\"n\">gₙ</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"n\">polytime_funₙ</span> <span class=\"n\">f</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">g₁</span>\n<span class=\"bp\">...</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">polytime_fun</span> <span class=\"n\">gₙ</span>\n</code></pre></div>\n<p>Note that <code>polytime_funₙ f</code> is by definition <code>polytime_fun (λ (x : α₁ × ⋯ × αₙ), f x.1 x.2 ... x.n)</code>.</p>\n<p>I'm still new to tactic writing so I need some help.</p>\n<p>One issue with this is that it doesn't generalize well based on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>. Currently, I just handle <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n=2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">n=3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> each with their own lemma (although this is all I've needed so far, and it isn't terribly hard to add a few more lemmas for larger <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>). I'm not sure if there is a better way though.</p>\n<p>Another issue is determining how many parameters there are. In particular we need to ignore arguments that just supply e.g. the type, or instances. The way I do this currently is search for a <code>pencodable</code> instance on each argument. For example, if the goal was</p>\n<p><code>⊢ polytime_fun (λ (m n : list α), m ++ n)</code></p>\n<p>then it should split this into goals saying that <code>list.append</code> is a <code>polytime_fun₂</code> and projections are. However, there is an implicit argument to <code>list.append</code> (namely, <code>α</code>) which should be ignored. In this case, it is ignored because <code>Type u</code> (the type of <code>α</code>) does not have a <code>polycodable</code> instance.</p>\n<p>However, I'm worried about performance here -- is there a better way to infer which arguments are \"true\" arguments and which are likely just auxiliary information?</p>",
        "id": 292300361,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1659850747
    },
    {
        "content": "<p>You could try using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/arity\">docs#arity</a> to generalize this to however many variables, but do note that this has very little use throughout mathlib</p>",
        "id": 292354444,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1659925263
    },
    {
        "content": "<p>What's the type of <code>f</code> here?</p>",
        "id": 292381279,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1659952604
    },
    {
        "content": "<p>Would an approach based on typeclass inference work here? This is a rough outline of what I had in mind:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> A typeclass for polynomial-time functions.</span>\n<span class=\"cm\">   To make the typeclass inference work smoothly, the class `polytime` is defined for terms of arbitrary types rather than only for simple function types. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">polytime</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- the definition of a polynomial time function goes here</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The value of a polynomial-time function at any input is still a polynomial time function -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">polytime_eval</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">polytime</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">polytime</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The composition of polynomial-time function is polynomial-time -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">polytime_comp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">polytime</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">polytime</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The application of a polynomial-time function to a polynomial-time argument is polynomial-time -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">polytime_app</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">polytime</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">polytime</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>And here are some specific examples of inference in action:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nat.sq</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"c1\">-- squares a natural number</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The identity function is polynomial-time -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The function `nat.sq` is polynomial-time -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"n\">nat.sq</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Addition of natural numbers is polynomial-time -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"n\">nat.add</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Every natural number is polynomial time (one way to make sense of this is that every constant is a 0-ary function that can be evaluated in a fixed amount of time) -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">nat_polytime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- here the `α` in `id α` is ignored and only the relevant parameters are considered</span>\n<span class=\"kd\">instance</span> <span class=\"n\">eg_infer</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat.sq</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"c1\">-- a bit more work is required here, but this complicated is still derivable from typeclass inference</span>\n<span class=\"kd\">instance</span> <span class=\"n\">eg_multi_arg</span> <span class=\"o\">:</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">nat.add</span> <span class=\"o\">(</span><span class=\"n\">nat.sq</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"k\">show</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">nat.add</span> <span class=\"o\">(</span><span class=\"n\">nat.sq</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"mi\">5</span><span class=\"o\">),</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>This is by no means a complete solution, but I think it addresses some parts of the question (such as ignoring implicit arguments). There may also be a better way to do this that avoids the <code>show</code> in the last example, but I am not aware of one. I suspect that the three typeclass instances above will be enough to handle a wide variety of cases thanks to currying.</p>",
        "id": 292626404,
        "sender_full_name": "Anand Rao",
        "timestamp": 1660067292
    },
    {
        "content": "<p>I'm pretty sure typeclass search won't work for <code>comp</code>, as we had trouble with it on is_monoid_hom due to it performing higher order unification</p>",
        "id": 292642347,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660073018
    }
]
[
    {
        "content": "<p>Let me start by saying that I really don't want to start a flamewar. I am just very uneducated.<br>\nMy question is simply this:<br>\nIs there a documented reason why mathlib chose \"classical DTT\" instead of HoTT + univalence?<br>\nHas there been some experience that shows that HoTT makes daily life for the working formalising mathematician harder rather than easier?</p>\n<p>Motivation: in the <a href=\"#narrow/stream/113488-general/subject/tutorial\" title=\"#narrow/stream/113488-general/subject/tutorial\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/subject/tutorial</a> thread there is a discussion going on about transport of structure. And this is not the first time this has happened. If I understand univalence correctly, one would just be able to apply univalence to the <code>equiv</code>, which turns it into an <code>identity</code>. By induction on <code>identity</code>, one would be reduced to proving a claim that is <code>rfl</code>. Maybe I'm drastically oversimplifying. Maybe I misunderstand univalence. But this truly sounds like what mathematicians do \"between the lines\".<br>\nPlease educate me.</p>",
        "id": 135265404,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538757270
    },
    {
        "content": "<p>I'm also curious about HoTT. So I think from the thread people were discussing </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">card_eq_of_equiv</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">to_set</span> <span class=\"err\">≃</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">to_set</span><span class=\"o\">)</span> <span class=\"o\">:</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">:=</span>  <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>AFAIK the univalence axiom is <code>(X=Y)→(X≃Y)</code>. How do you apply it in this case? Wouldn't you need <code>(X≃Y)→(X=Y)</code>?</p>",
        "id": 135272847,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1538765125
    },
    {
        "content": "<p>The function <code>(X=Y)→(X≃Y)</code> comes for free. Univalence says that it is an equivalence.</p>",
        "id": 135273023,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538765304
    },
    {
        "content": "<p><code>(X=Y)→(X≃Y)</code> doesn't look like it needs any extra axioms. I think univalence is <code>(X≃Y)→(X=Y)</code>. I'm curious about how it works with isomorphisms of structures, If I have two isomorphic rings <code>R</code> and <code>S</code>, do I know <code>(1 : R) == (1 : S)</code>. Equality of the types doesn't seem like a very strong axiom.</p>",
        "id": 135273073,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1538765357
    },
    {
        "content": "<p>In fact <code>(1 : R) == (1 : S)</code> seems like it could lead to some easy contradictions, but do I know anything a bit like that?</p>",
        "id": 135273180,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1538765422
    },
    {
        "content": "<p>If you're using the correct equiv (ring isomorphisms) you know that the function maps one to the other of course</p>",
        "id": 135273490,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538765652
    },
    {
        "content": "<p>What does univalence actually say?</p>",
        "id": 135273525,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1538765693
    },
    {
        "content": "<p>No idea, I'd love to know more about HOTT. Can it do perfectoid spaces?</p>",
        "id": 135273589,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538765760
    },
    {
        "content": "<p>There's <a href=\"https://video.ias.edu/VoevodskyMemConf-2018/0912-BenediktAhrens\" target=\"_blank\" title=\"https://video.ias.edu/VoevodskyMemConf-2018/0912-BenediktAhrens\">this recent talk</a> from the Voevodsky memorial conference by Benedikt Ahrens titled \"Univalent foundations and the equivalence principle\". I haven't watched it yet though.</p>",
        "id": 135274063,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1538766106
    },
    {
        "content": "<p>How does univalence save you work? You'd still have to prove the isomorphism you chose to encode in <code>equiv</code> preserves structure</p>",
        "id": 135274190,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1538766206
    },
    {
        "content": "<p>I tried googling it, and it seems like it doesn't assume proof irrelevance. It's stated as something like <code>(A = B) ≃ (A ≃ B)</code>, where <code>≃</code> means the same thing as it does in Lean.</p>",
        "id": 135274206,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1538766230
    },
    {
        "content": "<p>IIRC \"book HoTT\" has no built-in Prop/Type distinction, so no proof irrelevance in that sense</p>",
        "id": 135274570,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538766512
    },
    {
        "content": "<p>If you see Prop in a book HoTT context, it means basically the same as what we call a subsingleton</p>",
        "id": 135274615,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538766577
    },
    {
        "content": "<blockquote>\n<p>There's <a href=\"https://video.ias.edu/VoevodskyMemConf-2018/0912-BenediktAhrens\" target=\"_blank\" title=\"https://video.ias.edu/VoevodskyMemConf-2018/0912-BenediktAhrens\">this recent talk</a> from the Voevodsky memorial conference by Benedikt Ahrens titled \"Univalent foundations and the equivalence principle\". I haven't watched it yet though.</p>\n</blockquote>\n<p>Thanks for this link. I think from 49.30 onwards it might be pretty relevant to this thread.</p>",
        "id": 135276936,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538768690
    },
    {
        "content": "<blockquote>\n<p>How does univalence save you work? You'd still have to prove the isomorphism you chose to encode in <code>equiv</code> preserves structure</p>\n</blockquote>\n<p>Right. But in the case of Bryan's problem, there is not structure. So we win.</p>",
        "id": 135277436,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538769233
    },
    {
        "content": "<p>In the case of Chris's example, he is talking about <code>(1 : R)</code>, so you need an <code>equiv</code> (or path, in HoTT-speak) that preserves <code>has_one</code>.</p>",
        "id": 135277511,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538769300
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Can you shed some light on these questions?</p>\n<blockquote>\n<p>Is there a documented reason why mathlib chose \"classical DTT\" instead of HoTT + univalence?<br>\nHas there been some experience that shows that HoTT makes daily life for the working formalising mathematician harder rather than easier?</p>\n</blockquote>",
        "id": 135277680,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538769478
    },
    {
        "content": "<p>I guess implementing it in Lean involve creating a non proof irrelevant version of <code>eq</code> and implementing it using that?</p>",
        "id": 135278023,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1538769790
    },
    {
        "content": "<p>Is that exactly the <code>equiv</code>?</p>",
        "id": 135278873,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538770672
    },
    {
        "content": "<p>Oh you mean there are parts of the <code>eq</code> API which need to be ported to <code>equiv</code>?</p>",
        "id": 135278940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538770709
    },
    {
        "content": "<p>You need the recursor, because the point is to be able to show things like \"if R is artinian and S is isomorphic to R, then S is artinian\" by applying univalence and then doing cases on the equality you get out so that you can assume S is R</p>",
        "id": 135279051,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538770820
    },
    {
        "content": "<p>I've thought about it some more, and I think what it would actually look like is <code>eq,rec_on</code> with equiv instead of <code>eq</code></p>",
        "id": 135279110,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1538770859
    },
    {
        "content": "<p><code>eq.rec_on : Π {α : Sort u_3} {a : α} {C : α → Sort u_2} {a_1 : α}, a = a_1 → C a → C a_1</code></p>",
        "id": 135279218,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538770940
    },
    {
        "content": "<p>So the idea would be that there would be some typeclass <code>[plays_well_with_equiv C]</code>?</p>",
        "id": 135279257,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538770992
    },
    {
        "content": "<p>But I don't think you can really go about it this way, unless you can rule out \"being equal to R\" as a property which you can apply the recursor to.</p>",
        "id": 135279266,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538771002
    },
    {
        "content": "<p>Because then you could just conclude that <code>S = R</code>.</p>",
        "id": 135279294,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538771039
    },
    {
        "content": "<p>that rule doesn't get tagged with my cool typeclass though</p>",
        "id": 135279335,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538771045
    },
    {
        "content": "<p>Right, so <code>plays_well_with_equiv</code> seems to be viable and I think it's what people were calling \"transportable\" earlier</p>",
        "id": 135279374,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538771091
    },
    {
        "content": "<p>Another way might be <code>equiv A B -&gt; for all C : Sort u -&gt; Sort v, C A = C B</code></p>",
        "id": 135279473,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1538771189
    },
    {
        "content": "<p>plus the typeclass on C</p>",
        "id": 135279500,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538771213
    },
    {
        "content": "<p>Oh wait -- you want <code>C A = C B</code>? Not just an equiv?</p>",
        "id": 135279522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538771243
    },
    {
        "content": "<p>ah, this paper points out a big problem with hott <code>https://hal.inria.fr/hal-01559073v2/document</code>. Just like with <code>acc</code>, you get stuck terms when you use axiomatic univalence</p>",
        "id": 135279663,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1538771379
    },
    {
        "content": "<p>But does that stop me from defining a perfectoid space?</p>",
        "id": 135279726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538771409
    },
    {
        "content": "<p>Why are we having this discussion again? I thought HoTT is irremediably tied to constructive mathematics.</p>",
        "id": 135279755,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538771460
    },
    {
        "content": "<p>if restriction maps, id, and def reduction made you tear your hair out, trying to deal with univalence will do so similarly</p>",
        "id": 135279782,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1538771496
    },
    {
        "content": "<blockquote>\n<p>Motivation: in the <a href=\"#narrow/stream/113488-general/subject/tutorial\" title=\"#narrow/stream/113488-general/subject/tutorial\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/subject/tutorial</a> thread there is a discussion going on about transport of structure. And this is not the first time this has happened. If I understand univalence correctly, one would just be able to apply univalence to the equiv, which turns it into an identity. By induction on identity, one would be reduced to proving a claim that is rfl.</p>\n</blockquote>\n<p>I had a discussion with <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> on this very issue today. What you have said is not wrong; you can use univalence to prove these kinds of theorems almost trivially, because it's basically the content of that axiom. But there are some huge asterisks that come with this assertion, which make it almost disingenuous to trot out as an advantage of HoTT, because even if in an alternate universe mathlib was based on HoTT we would still have a considerable amount of difficulty with transfer of structure proofs in exactly the form we want them to be, the problem would just be with different parts of the proof</p>",
        "id": 135281859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538773682
    },
    {
        "content": "<blockquote>\n<p>(X=Y)→(X≃Y) doesn't look like it needs any extra axioms. I think univalence is (X≃Y)→(X=Y). I'm curious about how it works with isomorphisms of structures, If I have two isomorphic rings R and S, do I know (1 : R) == (1 : S). Equality of the types doesn't seem like a very strong axiom.</p>\n</blockquote>\n<p>HoTT is kind of magic when it comes to this. One of the things which is the most impressive about how HoTT works is how it always seems to get exactly the right kind of equivalence between objects. Two types are equal iff they are (constructively) bijective, two bundled groups are equal iff they are isomorphic as groups, two bundled rings are equal iff they are isomorphic as rings.</p>",
        "id": 135282014,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538773842
    },
    {
        "content": "<p>In HoTT, <code>==</code> is actually a \"bad\" notion of equality. Instead they have a \"pathover\" <code>a =[h] b</code> where <code>h : A = B</code>, which is basically equivalent to <code>cast a h = b</code></p>",
        "id": 135282053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538773913
    },
    {
        "content": "<p>The key is that equality of sigma types <code>\\Sigma x : A, B x = \\Sigma x : A', B' x</code> is the same as the pair of an equality <code>h : A = A'</code> and a pathover <code>B x =[h] B' x</code>. For a simple example, consider equality of pointed types (i.e. a type with a zero element and no axioms). This can be defined as <code>\\Sigma A : Type, A</code>, and so an equality of sigma types <code>(A, a)</code> and <code>(A', a')</code> is an equality <code>h : A = A'</code> with a pathover <code>a =[h] a'</code>. If you unpack this, it means <code>h</code> is a bijective function from <code>A</code> to <code>A'</code> such that <code>h</code> maps <code>a</code> to <code>a'</code>. In other words, it is a pointed equivalence, which is what we wanted</p>",
        "id": 135282377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538774276
    },
    {
        "content": "<p>If you do this with groups, the pathover thing exactly asserts that the map between types preserves the 0, inv, + which is a group isomorphism</p>",
        "id": 135282432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538774316
    },
    {
        "content": "<blockquote>\n<p>How does univalence save you work? You'd still have to prove the isomorphism you chose to encode in equiv preserves structure</p>\n</blockquote>\n<p>In HoTT, the equiv is just a plain equiv, i.e. a function <code>f</code> with an inverse <code>g</code> and two <em>paths</em> <code>f o g = id</code>, <code>g o f = id</code>. That is, it looks just like the usual definition of equiv, but the new interpretation gives it magic powers to be a group isomorphism when talking about groups, etc.</p>",
        "id": 135282548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538774463
    },
    {
        "content": "<blockquote>\n<p>I tried googling it, and it seems like it doesn't assume proof irrelevance. It's stated as something like (A = B) ≃ (A ≃ B), where ≃ means the same thing as it does in Lean.</p>\n</blockquote>\n<p>Technically, it's not just any equiv, it asserts that the natural map <code>A = B -&gt; A ≃ B</code> is an equivalence</p>",
        "id": 135282629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538774532
    },
    {
        "content": "<p>HoTT is inconsistent with proof irrelevance</p>",
        "id": 135282634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538774550
    },
    {
        "content": "<p>because if equalities of groups are group isos, we can't possibly assert there is only one</p>",
        "id": 135282647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538774575
    },
    {
        "content": "<blockquote>\n<p>I guess implementing it in Lean involve creating a non proof irrelevant version of eq and implementing it using that?</p>\n</blockquote>\n<p>Yes, but it's not that simple. Just the fact that propositional equality exists in the system is enough to prove that Type eq and Prop eq are equivalent, and hence the fact that Prop eq is proof irrelevant collapses Type eq. In the hott3 library they go to great lengths to mark everything using Prop eq as \"bad\" and unusable in HoTT stuff to avoid contradictions</p>",
        "id": 135282738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538774703
    },
    {
        "content": "<blockquote>\n<p>I've thought about it some more, and I think what it would actually look like is eq,rec_on with equiv instead of eq</p>\n</blockquote>\n<p>Yes, this is an equivalent way to state univalence. Something with the same recursor as eq is provably equivalent to eq, and vice versa</p>",
        "id": 135282803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538774779
    },
    {
        "content": "<blockquote>\n<p>Another way might be equiv A B -&gt; for all C : Sort u -&gt; Sort v, C A = C B</p>\n<p>Oh wait -- you want C A = C B? Not just an equiv?</p>\n</blockquote>\n<p>These are equivalent. Even if you only had <code>A ≃ B -&gt; for all C : Sort u -&gt; Sort v, C A ≃ C B</code> you could just apply it to <code>C = \\lam x, A = x</code> to deduce <code>(A = A) ≃ (A = B)</code>, and since the first is inhabited you just apply the function to prove <code>A = B</code>. So this is also univalence</p>",
        "id": 135282952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538774952
    },
    {
        "content": "<blockquote>\n<p>ah, this paper points out a big problem with hott <a href=\"https://hal.inria.fr/hal-01559073v2/document\" target=\"_blank\" title=\"https://hal.inria.fr/hal-01559073v2/document\">https://hal.inria.fr/hal-01559073v2/document</a> . Just like with acc, you get stuck terms when you use axiomatic univalence</p>\n</blockquote>\n<p>This is why cubical type theory was invented. It provides a way to compute with univalence</p>",
        "id": 135283041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538775041
    },
    {
        "content": "<p>\"provides a way to compute with univalence\" maybe should be \"hopefully provides a way to compute with univalence, except that currently some of the things we think should compute instead blow up our computers\".</p>",
        "id": 135283559,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538775622
    },
    {
        "content": "<p>(If I understood the cubical type theorists at Dagstuhl talking about Brunerie's number correctly.)</p>",
        "id": 135283577,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1538775647
    },
    {
        "content": "<p>I watched the talk and the main thing I don't understand is why and when Id is not a subsingleton. If i define it in a similar in Lean, as Type, so without proof irrelevance, but it's still a subsingleton. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">Id</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">Id</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">Id</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"k\">begin</span> <span class=\"n\">cases</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"kn\">end</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Id</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Id</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">j</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span>\n</pre></div>\n\n\n<p>The recursors/ eliminators/ computation rules mentioned in the talk <a href=\"https://www.youtube.com/watch?v=okx4Uklvwco\" target=\"_blank\" title=\"https://www.youtube.com/watch?v=okx4Uklvwco\">https://www.youtube.com/watch?v=okx4Uklvwco</a> are the same as they are in Lean, so why do they not imply Id is a subsingleton? Obviously there are types where it is a subsingleton, which he calls \"Sets\", what would make a type a Set?</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"okx4Uklvwco\" href=\"https://www.youtube.com/watch?v=okx4Uklvwco\" target=\"_blank\" title=\"https://www.youtube.com/watch?v=okx4Uklvwco\"><img src=\"https://i.ytimg.com/vi/okx4Uklvwco/default.jpg\"></a></div>",
        "id": 135283614,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1538775709
    },
    {
        "content": "<p>Something subtle is happening in your examples. Check out what the equation compiler actually generated.</p>",
        "id": 135287498,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538780609
    },
    {
        "content": "<p>If you try to implement these by hand, you can do the case analysis on <code>i</code> but then you'll get stuck on <code>j</code>.</p>",
        "id": 135287763,
        "sender_full_name": "Reid Barton",
        "timestamp": 1538780890
    },
    {
        "content": "<p>Reid is right. <code>cases</code> and the equation compiler use a HoTT-unsound proof method that introduces Prop eq to eliminate from inductive predicates. In the end the resulting proof uses the assumption that a proof of <code>a = a</code> is definitionally refl, which is provably false in HoTT</p>",
        "id": 135288559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538782095
    },
    {
        "content": "<blockquote>\n<p>Why are we having this discussion again? I thought HoTT is irremediably tied to constructive mathematics.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  The last sentence of §7 in <a href=\"https://arxiv.org/pdf/1711.01477.pdf\" target=\"_blank\" title=\"https://arxiv.org/pdf/1711.01477.pdf\">https://arxiv.org/pdf/1711.01477.pdf</a> (by Dan Grayson) says: <em>\"The Law of Excluded Middle and the Axiom of Choice are also validated by this interpretation, so classical mathematics is supported soundly by the univalent foundations.\"</em><br>\nSo I wonder if you (we?) have been tricked by a version of the myth that all formalised math needs to be constructive.<br>\nOr is Dan Grayson pulling a trick on us?</p>",
        "id": 135296892,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538797818
    },
    {
        "content": "<p>The excluded middle and the axiom of choice are indeed consistent with HoTT</p>",
        "id": 135296941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538797966
    },
    {
        "content": "<p><code>choice</code> is not</p>",
        "id": 135296942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538797969
    },
    {
        "content": "<p>\"The axiom of choice\" here means <code>classical.axiom_of_choice</code>, that is, the one that ends in an existential</p>",
        "id": 135296989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798078
    },
    {
        "content": "<p>But actually that's kind of a lie, because in HoTT you have an explicit \"propositional truncation\" operator that has the same role as putting things in Prop in lean</p>",
        "id": 135297036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798167
    },
    {
        "content": "<p>there is no proof irrelevant universe in HoTT, like I said that's not consistent</p>",
        "id": 135297037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798189
    },
    {
        "content": "<p>I think it would be instructional to actually look at Dan Grayson's work in UniMath and judge for yourself whether the style of mathematics being done there works for you. They also are aiming for the formalization of conventional mathematics, although HoTT-isms are a frequent distraction (e.g. \"ooh, I wonder if transfinite induction still holds over n-types\")</p>",
        "id": 135297095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798345
    },
    {
        "content": "<p>just as constructive math is an occasional distraction here</p>",
        "id": 135297098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798369
    },
    {
        "content": "<p>To respond to the original question, it's my understanding that Lean/mathlib is using more traditional type theory rather than HoTT basically \"by default\". Research is on-going wrt formalizing mathematics with HoTT and making univalence compute via things like cubical types but it's still a bit avant-garde</p>",
        "id": 135297193,
        "sender_full_name": "Scott Olson",
        "timestamp": 1538798524
    },
    {
        "content": "<p>I think that's fair. I would even possibly go so far as to say that we tried it and it \"didn't work\" in the sense that the issues thrown up are not minor annoyances but major research projects</p>",
        "id": 135297211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798626
    },
    {
        "content": "<blockquote>\n<p>there is no proof irrelevant universe in HoTT, like I said that's not consistent</p>\n</blockquote>\n<p>But if you have a <code>P : Prop</code> and <code>x y : P</code>, then you would know that <code>Id p q</code> is contractible. Which seems to me just as good as proof irrelevance. In practice, I think you can even teach the computer to use this fact, without bothering you with it.</p>",
        "id": 135297257,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538798676
    },
    {
        "content": "<p>I don't think HoTT is really suitable as a practical foundation for all of math, except in the logical sense</p>",
        "id": 135297258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798676
    },
    {
        "content": "<blockquote>\n<p>But if you have a P : Prop and x y : P, then you would know that Id p q is contractible.</p>\n</blockquote>\n<p>This is not true</p>",
        "id": 135297261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798694
    },
    {
        "content": "<p>this is the same as chris's proof attempt, and it's not provable</p>",
        "id": 135297271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798712
    },
    {
        "content": "<blockquote>\n<p>I think that's fair. I would even possibly go so far as to say that we tried it and it \"didn't work\" in the sense that the issues thrown up are not minor annoyances but major research projects</p>\n</blockquote>\n<p>This is exactly what I would like to know about. Are those problems even there if you don't care about computability?</p>",
        "id": 135297273,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538798720
    },
    {
        "content": "<p>It's provably false with HITs, or even just with type equalities using univalence</p>",
        "id": 135297276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798737
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>But if you have a P : Prop and x y : P, then you would know that Id p q is contractible.</p>\n</blockquote>\n<p>This is not true</p>\n</blockquote>\n<p>I thought it was the definition of being a <code>Prop</code> in HoTT.</p>",
        "id": 135297328,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538798807
    },
    {
        "content": "<p>For example, S^1 is a higher inductive type defined by <code>base : S^1</code> and <code>loop : base = base</code>. Since this is a \"free\" construction, this <code>base</code> is not <code>refl base</code></p>",
        "id": 135297331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798814
    },
    {
        "content": "<p>Oh, I missed that you said it was a prop</p>",
        "id": 135297341,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798837
    },
    {
        "content": "<p>Sure, that makes all the difference.</p>",
        "id": 135297344,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538798848
    },
    {
        "content": "<p>That's not how it works in HoTT. Instead you would say <code>P : Type</code> and <code>is_prop P</code></p>",
        "id": 135297347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798858
    },
    {
        "content": "<p>props are <em>defined as</em> types whose path space is contractible</p>",
        "id": 135297348,
        "sender_full_name": "Scott Olson",
        "timestamp": 1538798859
    },
    {
        "content": "<p>and <code>is_prop</code> is basically <code>subsingleton</code></p>",
        "id": 135297353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798877
    },
    {
        "content": "<p>because there is no \"universe of props\"</p>",
        "id": 135297400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798920
    },
    {
        "content": "<p>Anyway, does this mean that proof irrelevance is there in the cases that we actually care about? (The other things just aren't <em>proofs</em>. They are higher order.)</p>",
        "id": 135297402,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538798929
    },
    {
        "content": "<p>No. Being a proposition is a property which may or may not hold, and it holds a lot less than you would expect</p>",
        "id": 135297418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538798976
    },
    {
        "content": "<p><code>def Prop := subtype is_prop</code> wouldn't cut it, I guess.</p>",
        "id": 135297419,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538798976
    },
    {
        "content": "<p>There is <code>trunc</code> though (indeed I borrowed the terminology from HoTT), which will make a subsingleton from any type</p>",
        "id": 135297469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799025
    },
    {
        "content": "<blockquote>\n<p>No. Being a proposition is a property which may or may not hold, and <strong>it holds a lot less than you would expect</strong></p>\n</blockquote>\n<p>(Emphasis mine). This is important information! Has this been documented somewhere?</p>",
        "id": 135297473,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799032
    },
    {
        "content": "<p>and things like exists and or are defined by truncating after taking the sum/sigma</p>",
        "id": 135297478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799054
    },
    {
        "content": "<p>But I think that equalities not being subsingletons will get in your way a lot more than you think</p>",
        "id": 135297535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799125
    },
    {
        "content": "<p>Here is a question: How do you define a group in HoTT?</p>",
        "id": 135297547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799151
    },
    {
        "content": "<p>I mean... what I'm getting from this thread is that there are \"problems\" with HoTT in practice. And I already had this vague feeling. But otoh, univalence seems a mathematician's dream. So I would like to understand those \"problems\" in more detail. And I'm asking whether someone wrote some docs saying: here's some problems for the <em>working mathematician</em> (someone who doesn't care about constructivity and computability, a priori).<br>\nDoes something like this exist?</p>",
        "id": 135297558,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799178
    },
    {
        "content": "<blockquote>\n<p>Here is a question: How do you define a group in HoTT?</p>\n</blockquote>\n<p>Benedikt did this for monoids in that talk.</p>",
        "id": 135297574,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799193
    },
    {
        "content": "<p>So it is <code>(M : Set, mul : M × M → M, e : M, 3 proofs)</code></p>",
        "id": 135297579,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799219
    },
    {
        "content": "<p>And I'm using his notation.</p>",
        "id": 135297623,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799245
    },
    {
        "content": "<p>But <code>Set</code> should probably be <code>Type</code> + <code>is_set M</code></p>",
        "id": 135297629,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799262
    },
    {
        "content": "<p>I am alluding to the <code>Set</code> part</p>",
        "id": 135297630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799264
    },
    {
        "content": "<p>I guarantee you that will be a sticking point for getting mathematicians involved</p>",
        "id": 135297644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799290
    },
    {
        "content": "<p>Ok, what's wrong with it?</p>",
        "id": 135297645,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799291
    },
    {
        "content": "<p>It is a restriction that people don't want to have to think about</p>",
        "id": 135297654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799326
    },
    {
        "content": "<p>There is an obvious definition of a group where you say <code>Type</code> instead, and it's not correct, and it will take you a while to realize this</p>",
        "id": 135297662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799361
    },
    {
        "content": "<p>Hmmm... can't notation help us there?<br>\nI claim that every mathematician understands in a few minutes that higher monoids don't have proof irrelevance for their associativity etc... (in fact there are even multiple generalisations)</p>",
        "id": 135297706,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799394
    },
    {
        "content": "<p>Is that much more to ask than understanding <code>Prop</code> vs. <code>Type</code> and universe levels?</p>",
        "id": 135297709,
        "sender_full_name": "Scott Olson",
        "timestamp": 1538799398
    },
    {
        "content": "<p>I think it is, mathematicians have <em>no concept whatsoever</em> about the higher structure of equality</p>",
        "id": 135297718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799427
    },
    {
        "content": "<blockquote>\n<p>There is an obvious definition of a group where you say <code>Type</code> instead, and it's not correct, and it will take you a while to realize this</p>\n</blockquote>\n<p>It takes a while. But if you point out the analogy with actual homotopy theory, I think people get it fairly quickly.</p>",
        "id": 135297720,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799431
    },
    {
        "content": "<p>and now you've got people thinking about homotopy theory to do groups</p>",
        "id": 135297726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799450
    },
    {
        "content": "<blockquote>\n<p>I think it is, mathematicians have <em>no concept whatsoever</em> about the higher structure of equality</p>\n</blockquote>\n<p>This is blatantly false for mathematicians coming from algebraic topology.</p>",
        "id": 135297727,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799451
    },
    {
        "content": "<p>I see I've targeted the wrong audience :)</p>",
        "id": 135297732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799466
    },
    {
        "content": "<p>Np, I think I'm getting your points.</p>",
        "id": 135297741,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799478
    },
    {
        "content": "<p>So I repeat: Can't notation take care of this?</p>",
        "id": 135297789,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799491
    },
    {
        "content": "<p>The point is that HoTT makes you think about homotopy stuff whether you want to or not</p>",
        "id": 135297795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799501
    },
    {
        "content": "<p>Can't we have easy access to \"<code>Set</code>\"</p>",
        "id": 135297796,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799501
    },
    {
        "content": "<p>Maybe? It will still come up in proofs</p>",
        "id": 135297800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799516
    },
    {
        "content": "<p>maybe you can automate that...</p>",
        "id": 135297810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799529
    },
    {
        "content": "<p>If it comes up in proofs after the definition, then this is probably for a good reason. Unless the computer should have been able to figure out <code>is_Set</code> or <code>is_Prop</code> on its own.</p>",
        "id": 135297826,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799571
    },
    {
        "content": "<p>but no one has really seriously attempted to \"just do math\" in HoTT AFAICT, except possibly UniMath. Everyone gets distracted by the abstract homotopy stuff</p>",
        "id": 135297832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799579
    },
    {
        "content": "<p>Right. I think I wouldn't get distracted. Neither would <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>, <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> or <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>. We just want to take a far and high leap into normal classical research math.</p>",
        "id": 135297880,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799654
    },
    {
        "content": "<p>Quotient modules in UniMath: <a href=\"https://github.com/UniMath/UniMath/blob/master/UniMath/Algebra/Modules/Quotient.v\" target=\"_blank\" title=\"https://github.com/UniMath/UniMath/blob/master/UniMath/Algebra/Modules/Quotient.v\">https://github.com/UniMath/UniMath/blob/master/UniMath/Algebra/Modules/Quotient.v</a></p>",
        "id": 135297881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799658
    },
    {
        "content": "<p>Do these rings and modules live in \"Set\", or are they higher order?</p>",
        "id": 135297894,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799698
    },
    {
        "content": "<p>looking at it, I don't see anything really out of place for regular math in Coq</p>",
        "id": 135297898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799711
    },
    {
        "content": "<p>their setup for modules looks much less nice than lean's: <a href=\"https://github.com/UniMath/UniMath/blob/master/UniMath/Algebra/Modules/Core.v\" target=\"_blank\" title=\"https://github.com/UniMath/UniMath/blob/master/UniMath/Algebra/Modules/Core.v\">https://github.com/UniMath/UniMath/blob/master/UniMath/Algebra/Modules/Core.v</a></p>",
        "id": 135297951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799802
    },
    {
        "content": "<p>Ooh, a hott-ism:</p>\n<div class=\"codehilite\"><pre><span></span>(** The type of linear functions M -&gt; N is a set. *)\nLemma isasetlinearfun {R : ring} (M N : module R) : isaset (linearfun M N).\nProof.\n  intros. apply (isasetsubset (@pr1linearfun R M N)).\n  - change (isofhlevel 2 (M -&gt; N)).\n    apply impred.\n    exact (fun x =&gt; setproperty N).\n  - refine (isinclpr1 _ _).\n    intro.\n    apply isapropislinear.\nDefined.\n</pre></div>",
        "id": 135298019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538799944
    },
    {
        "content": "<p>They lack the pretty notation. But maybe that's because they don't distinguish between <code>has_mul</code> and <code>has_add</code>? Otherwise it looks pretty normal?</p>",
        "id": 135298022,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799949
    },
    {
        "content": "<p>Ooh, let me see what you found.</p>",
        "id": 135298024,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538799955
    },
    {
        "content": "<p>I think it makes sense that HoTT represents too big a shift in thinking about equality to be a drop-in replacement. I've gotten the impression that they hope it will help us do a lot of (non-homotopy...) math in a better way, but if it's a new way of doing math it couldn't be for the working mathematician until the working mathematician starts doing math differently</p>",
        "id": 135298069,
        "sender_full_name": "Scott Olson",
        "timestamp": 1538799991
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Maybe that could have been proven <code>by obviously</code>...</p>",
        "id": 135298073,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800006
    },
    {
        "content": "<p>But it seems like that's still mainly hopes and works in progress. I'm curious to what extent they could eventually move away from homotopy terminology to make it more approachable to the mainstream</p>",
        "id": 135298139,
        "sender_full_name": "Scott Olson",
        "timestamp": 1538800089
    },
    {
        "content": "<p><code>@[derive is_Set] def linearfun ...</code> and automation derives it for you. I don't see anything blocking this...</p>",
        "id": 135298144,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800101
    },
    {
        "content": "<p>I think even dependent type theory is a hard sell what with the casts and hard types and such... HoTT adds even more irrelevant junk from the mathematicians POV</p>",
        "id": 135298148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800137
    },
    {
        "content": "<p>Right, I think no mathematician would want HoTT without univalence. But univalence is very enticing. And it might be worth the hurdles.</p>",
        "id": 135298209,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800211
    },
    {
        "content": "<p>But speaking of automation, we started on this discussion because we wanted to do transport of structure and anything HoTT can do using univalence we can do with a tactic</p>",
        "id": 135298210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800235
    },
    {
        "content": "<blockquote>\n<p>But speaking of automation, we started on this discussion because we wanted to do transport of structure and anything HoTT can do using univalence we can do with a tactic</p>\n</blockquote>\n<p>Seriously? That sounds cool!</p>",
        "id": 135298215,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800258
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <span class=\"emoji emoji-2b06\" title=\"up\">:up:</span> voila!</p>",
        "id": 135298222,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800271
    },
    {
        "content": "<p>We only need to get that tactic and you'll never hear us talking about HoTT or univalence again.</p>",
        "id": 135298226,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800300
    },
    {
        "content": "<p>It's not like it's an unsolved problem... that paper that was linked earlier seems to explain it in detail</p>",
        "id": 135298227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800307
    },
    {
        "content": "<p><a href=\"https://hal.inria.fr/hal-01559073v2/document\" target=\"_blank\" title=\"https://hal.inria.fr/hal-01559073v2/document\">https://hal.inria.fr/hal-01559073v2/document</a></p>",
        "id": 135298229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800314
    },
    {
        "content": "<p>But I also wanted to cure you of the idea that HoTT would magically solve these problems</p>",
        "id": 135298277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800387
    },
    {
        "content": "<p>You still have to prove that all your notions respect equality, it's just expressed differently</p>",
        "id": 135298280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800433
    },
    {
        "content": "<p>you need to prove how transport computes on a bunch of things, and this is where the work is</p>",
        "id": 135298320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800461
    },
    {
        "content": "<p>I think we should try again with <code>transfer</code> and see what goes wrong</p>",
        "id": 135298321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800491
    },
    {
        "content": "<p>Still, I hope that such a tactic would significantly decrease the length and mental overhead of Bryan's proof that equivalent sets have equivalent partitions.</p>",
        "id": 135298334,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800521
    },
    {
        "content": "<p>Right, but currently <code>transfer</code> seems a <em>framework</em> that doesn't have any tactics to guide mere mortal mathematicians through it.</p>",
        "id": 135298374,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800564
    },
    {
        "content": "<p>You need to prove that equivs respect filter and powerset... it's not that difficult</p>",
        "id": 135298375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800566
    },
    {
        "content": "<p>I've tried a couple of times, but got stuck all the time.</p>",
        "id": 135298381,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800576
    },
    {
        "content": "<p>The key is to prove those relators for lots of interesting notions</p>",
        "id": 135298386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800593
    },
    {
        "content": "<p><code>transfer</code> is useless without them</p>",
        "id": 135298388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800603
    },
    {
        "content": "<p>Right. We need a (general) tactic that would generate those two goals (in this specific case)</p>",
        "id": 135298390,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800608
    },
    {
        "content": "<p>no, you need to <em>prove</em> them</p>",
        "id": 135298393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800623
    },
    {
        "content": "<p>they are not trivial claims</p>",
        "id": 135298401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800633
    },
    {
        "content": "<p>but <code>transfer</code> will glue them together into larger proofs</p>",
        "id": 135298402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800649
    },
    {
        "content": "<p>No, I mean it takes the main goal. I invoke <code>univalence</code>. And it splits into the two goals you mentioned. Then I prove those.</p>",
        "id": 135298403,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800666
    },
    {
        "content": "<p>So we're talking about the same thing.</p>",
        "id": 135298404,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800672
    },
    {
        "content": "<p>Ideally the lemmas about <code>powerset</code> and <code>filter</code> will already be in the library</p>",
        "id": 135298444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800695
    },
    {
        "content": "<p>Currently there is no tactic called <code>transfer</code>, right?</p>",
        "id": 135298445,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800704
    },
    {
        "content": "<p>there is</p>",
        "id": 135298446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800719
    },
    {
        "content": "<blockquote>\n<p>Ideally the lemmas about <code>powerset</code> and <code>filter</code> will already be in the library</p>\n</blockquote>\n<p>Sure... at some point they will be.</p>",
        "id": 135298447,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800720
    },
    {
        "content": "<p>it's in core</p>",
        "id": 135298448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800724
    },
    {
        "content": "<p>And if VScode has a mode \"Turn current goal into lemma\" I think we would generate those facts even faster. (Instead of hiding them as subproofs.)</p>",
        "id": 135298456,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800757
    },
    {
        "content": "<p>they aren't hard theorems, but no one has tried to prove them, or more likely they are already there but without the peculiar notation</p>",
        "id": 135298457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538800764
    },
    {
        "content": "<blockquote>\n<p>You still have to prove that all your notions respect equality, it's just expressed differently<br>\nyou need to prove how transport computes on a bunch of things, and this is where the work is</p>\n</blockquote>\n<p>this was my impression when looking into cubical type theory. for example, there univalence itself seems small and easy to prove, because the details are bound up in the more fundamental ideas of transport-respecting equality in the type theory</p>",
        "id": 135298499,
        "sender_full_name": "Scott Olson",
        "timestamp": 1538800816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> What exactly would \"equiv respects powerset\" look like in Lean, to make it usable for <code>transfer</code>?</p>",
        "id": 135298507,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538800884
    },
    {
        "content": "<p>you also get things like how equalities between pairs are actually equal to pairs of equalities between the two fields (with proof-relevant equalities), which maps to how transporting pairs requires transporting each of the fields</p>",
        "id": 135298553,
        "sender_full_name": "Scott Olson",
        "timestamp": 1538800951
    },
    {
        "content": "<p>right, you have to recurse through that stuff to prove your theorem about transport of <code>partition</code>, so in the end it's not much different from the recursion that <code>transfer</code> will do</p>",
        "id": 135298623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538801120
    },
    {
        "content": "<p>or more precisely, you know immediately that the partitions of A and B are isomorphic, but what that isomorphism does is not obvious</p>",
        "id": 135298635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538801162
    },
    {
        "content": "<p>I see</p>",
        "id": 135298664,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538801177
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I know you are really busy. But I would love that after the module refactoring is done this issue would land somewhere near the top of your todo list. Turning <code>transfer</code> into something that we smoothly use on a daily basis would be a huge win.</p>",
        "id": 135299309,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538802778
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> here is a practical question. Once I said \"oh we need <code>ring</code>\". I probably said it about three times. And then one day I woke up and found that all of a sudden we had <code>ring</code>. My <em>impression</em> (correct me if I'm wrong) was that once you got down to it, it was just a cool project that maybe took you a weekend of coding because you understood exactly what needed to be done and then you just sat down and did it.</p>\n<p>Well, now we \"need\" (in the same sense) the fact that if A and B are <code>equiv</code> topological rings then <code>Spa A</code> and <code>Spa A</code> are equiv topological spaces equipped with presheaves of topological rings, and to a mathematician the proof is <code>rw h</code> where <code>h</code> is the equiv. I fully understand that in Lean life is not so easy. But is this a tactic which will randomly just appear one day in mathlib like <code>ring</code> did or is this a far more serious research project? If it is I am wondering whether it is worth making it an issue for mathlib, so we know where we are and what needs doing. It would not surprise me if mathematicians have got big ideas about what this tactic is supposed to be doing, and I have no real feeling for whether Lean is capable of doing what we actually want, or whether Lean 4 changes things. </p>\n<p>I have this mathlib issue which is not really an \"issue\" -- \"let's define the adeles!\". I am about to close it and put it instead on the \"list of stuff which we should formalise at some stage\". But my troubles with <code>module</code> are an issue I think, and non-existence of <code>transfer</code> is another issue. Is this a sensible usage of the \"issue\" functionality of github?</p>",
        "id": 135309614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538826404
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> <span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> I heartily invite you to read through this thread and share some of your insights and expertise with us.</p>",
        "id": 135315441,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538838854
    },
    {
        "content": "<blockquote>\n<p>What does univalence actually say?</p>\n</blockquote>\n<p>perhaps I'm too late, but there's this explanation with Agda code <a href=\"http://www.cs.bham.ac.uk/~mhe/agda-new/UnivalenceFromScratch.html\" target=\"_blank\" title=\"http://www.cs.bham.ac.uk/~mhe/agda-new/UnivalenceFromScratch.html\">http://www.cs.bham.ac.uk/~mhe/agda-new/UnivalenceFromScratch.html</a> (see also the arXiv version <a href=\"https://arxiv.org/abs/1803.02294\" target=\"_blank\" title=\"https://arxiv.org/abs/1803.02294\">https://arxiv.org/abs/1803.02294</a>)</p>",
        "id": 135330245,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1538869697
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  yes, there are programs that have been extracted, but they are so slow and memory-hungry they cannot be run to completion, even to calculate Brunerie's number (which is known to be 2 even in HoTT, on paper)</p>",
        "id": 135330253,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1538869798
    },
    {
        "content": "<p>Thanks for the ping, Johan. <br>\nI think Mario has said most things already, but let me reiterate some points.</p>\n<p>In HoTT you can develop ordinary mathematics. It will be mostly the same as formalizing things in mathlib. If you stay in the fragment of sets in HoTT, things will look very familiar. Here with \"set\" I mean a type <code>A</code> where for all <code>a b : A</code> the type <code>a = b</code> is a subsingleton (what we would call a propositon). </p>\n<p><strong>Disadvantages</strong><br>\nThere will be some disadvantages/inconviences when doing set-level mathematics in HoTT:</p>\n<ul>\n<li>You won't have definitional proof irrelevance. Even if you are working with sets, if you have two equalities <code>h1 h2 : a = b</code>, <code>h1</code> and <code>h2</code> will not be definitionally equal.</li>\n<li>You will have to prove that the objects you're dealing with are a set or proposition. For example: it is a lemma that <code>n ≤ m</code> is a proposition for natural numbers <code>n</code> and <code>m</code>. This is definitely automatable in 99% of the cases. </li>\n<li><code>classical.choice</code> is inconsistent. The law of excluded middle and the axiom of choice are consistent with HoTT (and HoTT is no more tied to constructive mathematics than ordinary type theory is), as long as you restrict LEM to propositions (subsingletons) and the axiom of choice to sets. The restriction of <code>classical.choice</code> to a <code>subsingleton</code> type is consistent (and actually provable) in HoTT.</li>\n<li>Instead of a single universe of propositions, there is a subuniverse of propositions (defined as <code>Prop := subtype is_prop</code> as Johan suggested above) inside every universe. This means that if you talk about a proposition, you have to decide in which universe that proposition lives. This hasn't come up as a problem in the HoTT library yet, but could lead to the insertion of some <code>ulift</code>s.</li>\n</ul>\n<p>I think the main reason why mathlib doesn't use HoTT is that we don't want to explain HoTT to all users of mathlib. Type theory is already weird enough for mathematicians, I think explaining the higher groupoid structure of equality would be too much. I think for experts, formalizing mathematics in HoTT won't be any harder than doing it in mathlib, but there will be a steeper learning curve. For example, if you have an element <code>⟨a, H⟩ : subtype P</code>, and you apply a lemma which expects the term <code>⟨a, H'⟩</code> (same element, different proof of <code>P a</code>), you will get a type error. It's easy to fix this, but very confusing for an average user (<code>⟨a, H⟩ = ⟨a, H'⟩</code> is provable by <code>subtype_eq rfl</code>).</p>\n<p><strong>Univalence</strong><br>\nAs mentioned before, univalence roughly states that if you have an equivalence between two types, then they are equal. More formally, it states that the function <code>(A = B) → (A ≃ B)</code> (which is easily defined by - for example - <code>eq.rec</code>) is itself an equivalence. One pedantic remark here is that stating that a function <code>f : A → B</code> is an equivalence (<code>is_equiv f</code>) is defined slightly different in HoTT than in mathlib. One important property we need is that <code>is_equiv f</code> is a subsingleton, and the type <code>Σ(g : B → A), g ∘ f = id × f ∘ g = id</code> is not. There are many definitions which do satisfy this property, the simplest is by saying that <code>f</code> has a left-inverse <em>and</em> <code>f</code> has a right-inverse, so <code>(Σ(g : B → A), g ∘ f = id) × (Σ(h : B → A), f ∘ h = id)</code>. To be clear: there is a bi-implication between these two different definitions, but only the second one is a subsingleton, while the first one is not.</p>\n<p>While univalence is only a statement about types, we can then prove it for all kinds of other structures: the type of equalities <code>(G = H)</code> between groups correspond to the type of group isomorphism between <code>G</code> and <code>H</code>. Equalities <code>(C = D)</code> between categories correspond to isomorphism of categories (and if <code>C</code> and <code>D</code> are so-called <em>univalent</em> categories, then it also corresponds to equivalence of categories), etc.</p>\n<p>Univalence allows you to transport definitions and theorems between isomorphic structures. The catch is that if univalence is an axiom, these transported definitions will not be definitionally equal to what you want/expect (in cubical type theory it is, see below). As long as you are working with set-level objects, this will not be a problem. You can easily prove that the transported definition is equal to what you expect (and this is definitely automatable with a tactic). When transporting theorems, this will not be a problem, since we don't care about how we've proven these theorems.<br>\nLet's look at two examples. In both cases I have a group <code>G</code>, a subgroup <code>H</code> of <code>G</code> and have proven that the property <code>PH : P H</code> holds. Now suppose <code>ϕ</code> is a group isomorphism from <code>G</code> to <code>G'</code></p>\n<ul>\n<li>It is easy to now find a subgroup <code>H'</code> of <code>G'</code> such that <code>P H'</code> holds. Just transport <code>⟨H, PH⟩</code> along the equality <code>G = G'</code> obtained from the group isomorphism. It is a lemma that <code>H'</code> is the image of <code>H</code> under <code>ϕ</code>.</li>\n<li>Suppose we already have defined a subgroup <code>H'</code> of <code>G'</code>. To show that <code>P H'</code> holds, we can show that <code>H'</code> is the image of <code>H</code> under <code>ϕ</code>. We can then use univalence to get <code>P H'</code>. This will require some reasoning steps, but I'm sure that this can be automated using a tactic.</li>\n</ul>\n<p><strong>Cubical Type Theory</strong><br>\nIn cubical type theory univalence does compute. The disadvantage is that the type theory is a lot more complicated and under active research. For example, for many variants of cubical type theory meta-theoretic properties like canonicity and decidable type-checking are still open. Reducing a couple instances of univalence will be fast and efficient. In this way it's nothing like computing Brunerie's number. Computing Brunerie's number is slow in the same way that kernel reduction in Lean is slow: you wouldn't want to compute <code>2^100</code> using kernel computation, but reducing a couple of beta-redexes with the kernel is fine. </p>\n<p>I hope this answers some questions.</p>",
        "id": 135358192,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1538929980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Thanks a lot for this extensive reply!</p>",
        "id": 135358972,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538931601
    },
    {
        "content": "<p>Many thanks Floris! Your comments are very clarifying for me.</p>",
        "id": 135365207,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538945240
    },
    {
        "content": "<p>One thing about this I haven't managed to work out is how you can end up with two different proofs of equality that are provably not equal. Are there any simple examples?</p>",
        "id": 136865419,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541004781
    },
    {
        "content": "<p>There are two ways:<br>\n(1) Using the univalence axioms, equality between types <code>A</code> and <code>B</code> correspond to (more precisely: are equivalent to) equivalences between <code>A</code> and <code>B</code>. So for example, for every bijection between <code>nat</code> and <code>int</code> you get an equality between <code>nat</code> and <code>int</code>, and these are provably unequal the corresponding bijections are unequal.</p>\n<p>(2) In HoTT, you can extend the language with <em>Higher Inductive Types</em>. These are like inductive types, where your constructors can be either new elements of the type you're constructing, but also new paths (equalities) between the elements. <br>\nFor example, you can have an interval <code>I</code> with three constructors:</p>\n<ul>\n<li><code>zero : I</code></li>\n<li><code>one : I</code></li>\n<li><code>segment : zero = one</code></li>\n</ul>\n<p>This is a trivial example, where we get a type with two points, and a path from <code>zero</code> to <code>one</code>. A more interesting example is the <code>circle</code> with two constructors:</p>\n<ul>\n<li><code>base : circle</code></li>\n<li><code>loop : base = base</code></li>\n</ul>\n<p>Using the univalence axiom you can <em>prove</em> that <code>loop</code> is not equal to <code>refl base</code>. Moreover, you can prover that the type <code>base = base</code> is equivalent to the type <code>int</code>. (the map <code>int -&gt; base = base</code> sends <code>n</code> to <code>loop ^ n</code>.)</p>\n<p>Another higher inductive type you know is <code>quotient</code> in Lean 3. For <code>quotient A</code> you have two constructors:</p>\n<ul>\n<li>A point constructor <code>quotient.mk : A -&gt; quotient A</code></li>\n<li>A path constructor <code>quotient.sound : \\forall (a b : A), a ~ b -&gt; mk a = mk b</code></li>\n</ul>\n<p>If you want to define this quotient in HoTT you want to add an additional constructor with type<code>\\forall (a b : quotient A) (p q : a = b), p = q</code>. This enforces that the resulting type is in fact a \"set\": a type where any two proofs of the same equality are in fact equal.</p>",
        "id": 136866828,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1541006039
    },
    {
        "content": "<p>For all higher inductive types you get an induction principle/recursion principle like <code>foo.rec</code> in Lean. It roughly states that to define a function out of a higher inductive type, you have to say to what elements you have to send the point constructors, and show that the map respects the path constructors. For <code>quotient</code>, this corresponds exactly to <code>quotient.lift</code> and <code>quotient.rec</code>. And for the circle, you have to use this principle to show that <code>loop != refl base</code>.</p>",
        "id": 136867092,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1541006272
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> The example about <code>circle</code> is very good. In general topology (or homotopy theory) gives good intuition for HoTT. (What's in a name?)<br>\nHave you seen fundamental groups in topology yet? Then you will have seen homotopies (continuously deforming a path into another path). And of course we want to call two paths in a topological space \"equal\" if they are homotopic. Any two homotopies between two paths <code>p_1</code> and <code>p_2</code> will be proofs that <code>p_1 = p_2</code>, but of course those homotopies don't have to be equal.<br>\nIn ordinary maths we are using setoids and quotients for all of this. (So instead of homotopies, I could have talked about equality in quotient groups instead...) The difference in homotopy theory is that we don't actually want to take the quotient. We want to remember the homotopies. And we also want to remember homotopies between homotopies. HoTT allows us to do this synthetically in the type theory. It is thus suited very well for higher-categorical reasoning in mathematics (and for synthetic homotopy theory).</p>",
        "id": 136868896,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541007926
    },
    {
        "content": "<p>I have googled the definition of fundamental group, but I don't know much more than that about them. I understand it well enough to understand most of the analogies given when reading about HoTT, but I had no idea why they were relevant to Type theory until now. I think I'll have to read up on higher inductive types. Thanks <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span></p>",
        "id": 136870378,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541009566
    }
]
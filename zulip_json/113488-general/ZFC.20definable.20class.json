[
    {
        "content": "<p>Currently, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pSet.definable\">docs#pSet.definable</a> is implemented as a class. Should it be?</p>",
        "id": 289072024,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657414455
    },
    {
        "content": "<p>My instinct says no, given what's been discussed here before: typeclasses are really only useful when there's no nontrivial equalities between objects, and sets/set functions completely break that rule</p>",
        "id": 289072030,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657414489
    },
    {
        "content": "<p>On the other hand, we do have the theorem <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.all_definable\">docs#classical.all_definable</a> stating all functions are classically definable. So maybe this is meant to be used in a way more akin to <code>decidable_eq</code> or <code>decidable_rel</code></p>",
        "id": 289072109,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657414621
    },
    {
        "content": "<p>(i.e. as an afterthought <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span>)</p>",
        "id": 289072329,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657414987
    },
    {
        "content": "<p>Oh yeah, I should probably tag <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> who made this class to begin with</p>",
        "id": 289075756,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657420495
    },
    {
        "content": "<p>The intention was to have definability instances for all formulas, but it was too much work at the time and classical.all_definable is an easy workaround using choice</p>",
        "id": 289075905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657420709
    },
    {
        "content": "<p>the rule for typeclasses is not about whether equalities exist but rather whether it is generally possible to prove all instances purely structurally on the value</p>",
        "id": 289075960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657420771
    },
    {
        "content": "<p><code>decidable</code> is a good example of this - there are often nontrivial equalities of decidable instances but the important thing is that you prove that a thing is decidable because it is structurally so</p>",
        "id": 289076056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657420892
    },
    {
        "content": "<p>Well, in this situation, that should probably be the case</p>",
        "id": 289076115,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657420935
    },
    {
        "content": "<p>There is a metatheorem that says that any ZFC formula is definable, but I don't think it is easy to derive this using only typeclass search because you have to combine many arities of definability</p>",
        "id": 289076129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657420979
    },
    {
        "content": "<p>Though wouldn't this also be the case for e.g. continuous functions? What was the rationale for not making that into a typeclass again? Feel like this was brought up last time I started a similar discussion</p>",
        "id": 289076162,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657421028
    },
    {
        "content": "<p>The idea is that it shouldn't be necessary to invoke choice to use the axiom of replacement</p>",
        "id": 289076163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421028
    },
    {
        "content": "<p>It does hit the same issues as continuous functions</p>",
        "id": 289076204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421053
    },
    {
        "content": "<p>the full derivation setup was never done</p>",
        "id": 289076210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421066
    },
    {
        "content": "<p>so it's basically a stub right now</p>",
        "id": 289076212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421074
    },
    {
        "content": "<p>with the only way to prove definability being <code>all_definable</code></p>",
        "id": 289076215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421091
    },
    {
        "content": "<p>you can of course still do manual proofs for specific formulas, but a tactic would probably be best placed to do the full metatheorem</p>",
        "id": 289076231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421123
    },
    {
        "content": "<p>I should mention that I just took care of your to-do: <a href=\"https://github.com/leanprover-community/mathlib/pull/15216\">#15216</a></p>",
        "id": 289076232,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657421123
    },
    {
        "content": "<p>But yeah, I agree that we need further development here</p>",
        "id": 289076238,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657421139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ZFC.20definable.20class/near/289076204\">said</a>:</p>\n<blockquote>\n<p>It does hit the same issues as continuous functions</p>\n</blockquote>\n<p>What were those issues again?</p>",
        "id": 289076315,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657421216
    },
    {
        "content": "<p>typeclass inference doesn't work well under lambdas</p>",
        "id": 289076520,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421490
    },
    {
        "content": "<p>you would like to reason that because <code>+</code> is continuous and <code>f</code> and <code>g</code> are continuous, <code>\\lam x, f x + g x</code> is also continuous, and this is hard for the typeclass system to unify with the necessary instances</p>",
        "id": 289076569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421531
    },
    {
        "content": "<p>If you write it in a first order way, like <code>map2 (+) f g</code>, then TC can do it</p>",
        "id": 289076612,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421587
    },
    {
        "content": "<p>but writing ZFC formulas like that would be pretty painful</p>",
        "id": 289076623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421625
    },
    {
        "content": "<p>this is actually how computability/primrec \"instances\" are done right now, although it should get some automation at some point</p>",
        "id": 289076677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421664
    },
    {
        "content": "<p>instances in quotes because they are worked out by hand</p>",
        "id": 289076700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421687
    },
    {
        "content": "<p>you get stuff like <code>list_cons.comp (hg.comp fst (fst.comp snd)) (snd.comp snd)</code> where <code>fst.comp snd</code> and <code>snd.comp snd</code> are basically a way to write de bruijn variable references</p>",
        "id": 289076766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657421771
    },
    {
        "content": "<p>I see</p>",
        "id": 289076874,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657421908
    },
    {
        "content": "<p>So the play here is to move away from instances and into metaprogramming</p>",
        "id": 289076876,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657421909
    },
    {
        "content": "<p>Now would be a great time to actually learn about Lean metaprogramming</p>",
        "id": 289076880,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657421909
    },
    {
        "content": "<p>What sorts of theorems would we want in the case of ZFC though?</p>",
        "id": 289076975,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657422050
    },
    {
        "content": "<p>I can think of a few theorems for functions, like if <code>f</code> is definable, so is <code>lambda x, {f x}</code>, that kind of stuff</p>",
        "id": 289077011,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657422088
    },
    {
        "content": "<p>But what about functions with more inputs?</p>",
        "id": 289077014,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657422099
    },
    {
        "content": "<p>As far as theorems, we would want at least enough theorems so that manual proving would show the metatheorem</p>",
        "id": 289078117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657423544
    },
    {
        "content": "<p>So that means proving that all the primitives are definable, and forall and implies are definable</p>",
        "id": 289078164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657423583
    },
    {
        "content": "<p>this is difficult because you need some higher order notions of definability to make everything work out</p>",
        "id": 289078169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657423605
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> if you learn metaprogramming you can help with the Lean 4 port! I'm going to try and learn it next week!</p>",
        "id": 289080912,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1657426963
    },
    {
        "content": "<p>On a related note, now that I brought ZFC up</p>",
        "id": 289116052,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657475789
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/Class.mem_hom_left\">docs#Class.mem_hom_left</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Class.mem_hom_right\">docs#Class.mem_hom_right</a></p>",
        "id": 289116059,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657475802
    },
    {
        "content": "<p>These seem like bad <code>simp</code> lemmas? For the same reason</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n</code></pre></div>\n<p>would be a very bad <code>simp</code> lemma</p>",
        "id": 289116080,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657475865
    },
    {
        "content": "<p>I am not so sure, because there indeed is something that decreases when going from the LHS to the RHS, namely the number of coercions.</p>",
        "id": 289116133,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1657475934
    },
    {
        "content": "<p>I mean, <code>A x</code> shouldn't be the preferred way to say <code>x ∈ (A : set Set)</code></p>",
        "id": 289116147,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657475964
    },
    {
        "content": "<p>(the RHS here isn't a coercion, since <code>Class</code> is def-eq to <code>set Set</code>)</p>",
        "id": 289116203,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657476005
    },
    {
        "content": "<p>I see where this is coming from, since there's already another <code>∈</code> operator on <code>Class</code></p>",
        "id": 289116296,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657476153
    },
    {
        "content": "<p>But I'm still not a fan</p>",
        "id": 289116383,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657476282
    },
    {
        "content": "<p>Is it not possible to have two different <code>∈</code> instances for a type?</p>",
        "id": 289119062,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657480217
    },
    {
        "content": "<p>Having an instance <code>has_mem Set Class</code> and another <code>has_mem Class Class</code> would solve the problem at hand, but it doesn't seem to work</p>",
        "id": 289119070,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657480239
    },
    {
        "content": "<p>Defining either instance makes the other no longer work</p>",
        "id": 289119072,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657480245
    },
    {
        "content": "<p>I guess we could make an exception and say that <code>A x</code> is actually the proper way to say a set belongs to a class, even if this is blatant definitional equality abuse</p>",
        "id": 289119154,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657480396
    },
    {
        "content": "<p>Here's an alternate idea, maybe we could have a predicate</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mem_set</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Set.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Class.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">A</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>to hide the def-eq abuse</p>",
        "id": 289119396,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657480801
    },
    {
        "content": "<p>Then change the theorems I mentioned to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">Class.mem_hom_left</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Class</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">↔</span> <span class=\"n\">mem_set</span> <span class=\"n\">x</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 289119446,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657480853
    },
    {
        "content": "<p>We could even go as far as to give custom notation like <code>∈ₛ</code> for this, but that seems unnecessary</p>",
        "id": 289119462,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657480885
    },
    {
        "content": "<p>I decided to go the <code>mem_set</code> route, and also added <code>of_set</code> for the cast between <code>set Set</code> and <code>Class</code>.</p>",
        "id": 289131675,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657499288
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/15234\">#15234</a></p>",
        "id": 289131678,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657499294
    },
    {
        "content": "<p>These are all technical definitions that are being used in the metamath export. I am against changing any of them</p>",
        "id": 289135385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657505420
    },
    {
        "content": "<p>Using application on <code>Class</code> is only abuse if we say it is</p>",
        "id": 289135409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657505477
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ZFC.20definable.20class/near/289135385\">said</a>:</p>\n<blockquote>\n<p>These are all technical definitions that are being used in the metamath export. I am against changing any of them</p>\n</blockquote>\n<p>Metamath export? What do you mean?</p>",
        "id": 289140525,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657511823
    },
    {
        "content": "<p>I get that we can do whatever we want with this little bit of code in a leaf file, but I still think it's best to be orderly. If we consider application on <code>set α</code> to be definitional abuse, then the situation surely shouldn't be any different with <code>Class = set Set</code>.</p>",
        "id": 289140736,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657512028
    },
    {
        "content": "<p>It muddles the distinction between <code>Class</code> and <code>Set → Prop</code> (though maybe we don't want to make any such distinction? If so, we should instead document this decision and change <code>Set → Prop</code> to <code>Class</code> throughout).</p>",
        "id": 289140866,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657512125
    },
    {
        "content": "<p>But yeah, I really want to know what that Metamath thing you mention is about. I don't think we should shy away from refactors just because the code is used by someone else.</p>",
        "id": 289141044,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657512361
    },
    {
        "content": "<p>How long does the metamath export you're talking about take? If it's fast, should we run it in the CI so that nobody breaks it by accident? Or could you add comments to definitions that should not be changed because of this export?</p>",
        "id": 289141222,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1657512550
    },
    {
        "content": "<p>Oh wait, are you running the entirety of Metamath on top of the mathlib ZFC library?</p>",
        "id": 289141295,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657512624
    },
    {
        "content": "<p>That's both impressive and dreadful</p>",
        "id": 289141299,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657512632
    },
    {
        "content": "<p>I really do think that <code>Class</code> is in an annoying state where its conventions aren't quite consistent (we use <code>Class</code> sometimes and <code>Set → Prop</code> other times and we mix and match with def-eq) and clash with those of mathlib elsewhere (the aforementioned def-eq abuse)</p>",
        "id": 289141352,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657512704
    },
    {
        "content": "<p>But I guess I can live with it if it's needed for that Metamath thing to work, as long as we document things properly</p>",
        "id": 289141357,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657512721
    },
    {
        "content": "<p>But also, would changing definitions to other definitionally equal definitions really break the Metamath export? That's all I'm ultimately suggesting</p>",
        "id": 289141647,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657513049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span>, when threads like this spin out PRs, can you make sure to link back to the thread from the PR?</p>",
        "id": 289153898,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657524527
    },
    {
        "content": "<p>Sorry, let me fix that</p>",
        "id": 289190152,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657546210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/ZFC.20definable.20class/near/289140736\">said</a>:</p>\n<blockquote>\n<p>I get that we can do whatever we want with this little bit of code in a leaf file, but I still think it's best to be orderly. If we consider application on <code>set α</code> to be definitional abuse, then the situation surely shouldn't be any different with <code>Class = set Set</code>.</p>\n</blockquote>\n<p>We could change the definition to <code>Class = (Set -&gt; Prop)</code> to address this</p>",
        "id": 289194801,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657548133
    },
    {
        "content": "<p>This wouldn't give us many instances automatically</p>",
        "id": 289197030,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657549092
    },
    {
        "content": "<p>If the idea is that <code>Class</code> is morally <code>Set → Prop</code>, and we just define it as <code>set Set</code> to get the instances automatically, that's fine by me</p>",
        "id": 289197085,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657549121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/ZFC.20definable.20class/near/289141044\">said</a>:</p>\n<blockquote>\n<p>But yeah, I really want to know what that Metamath thing you mention is about. I don't think we should shy away from refactors just because the code is used by someone else.</p>\n</blockquote>\n<p>Well, mathlib is also used as a basis for other projects. I don't think it is necessary to gratuitously break downstream projects without good reason. (That is, <code>set_theory.zfc</code> only looks like a leaf file because it's not used <em>in mathlib</em>)</p>",
        "id": 289197543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657549345
    },
    {
        "content": "<p>I mean, mathlib changes so rapidly and Lean is so unpredictable in some aspects that I imagine that most refactors inadvertently break some mathlib dependencies</p>",
        "id": 289197790,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657549470
    },
    {
        "content": "<p>But sure, we should have a good reason for these changes</p>",
        "id": 289197862,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657549501
    },
    {
        "content": "<p>What do you think about replacing <code>Set → Prop</code> by <code>Class</code>, and explaining in a docstring that <code>Class</code> is morally <code>Set → Prop</code>?</p>",
        "id": 289197900,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657549524
    },
    {
        "content": "<p>Would that break that Metamath thing?</p>",
        "id": 289197925,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657549534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113488-general/topic/ZFC.20definable.20class/near/289141222\">said</a>:</p>\n<blockquote>\n<p>How long does the metamath export you're talking about take? If it's fast, should we run it in the CI so that nobody breaks it by accident? Or could you add comments to definitions that should not be changed because of this export?</p>\n</blockquote>\n<p>It's somewhere in the 30 min range. I generally treat it as an external project which depends on mathlib, it has very few dependencies and they are all in the <code>set_theory.zfc</code> file</p>",
        "id": 289198027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657549567
    },
    {
        "content": "<p>Changing definitions without changing defeqs probably won't actually break things, since the export generates a lean source file with no tactics and lots of <code>@</code> to avoid any lean weirdness so the only thing that would cause problems is typechecking failure due to changed definitions</p>",
        "id": 289198365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657549697
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/113488-general/topic/Prime.20number.20theorem.20in.20lean/near/168472336\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Prime.20number.20theorem.20in.20lean/near/168472336</a></p>",
        "id": 289198465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657549729
    },
    {
        "content": "<p>Another question</p>",
        "id": 289198832,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657549881
    },
    {
        "content": "<p>Is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Class.to_Set\">docs#Class.to_Set</a> another one of those definitions used in the Metamath export?</p>",
        "id": 289198882,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657549903
    },
    {
        "content": "<p>If we were to replace <code>Set → Prop</code> by <code>Class</code>, then <code>to_Set</code> would just be a restatement of the <code>∈</code> predicate on classes</p>",
        "id": 289198980,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657549932
    },
    {
        "content": "<p>(and by the way, I also want to inline <code>Class.mem</code> into the <code>has_mem</code> instance, would that break things?)</p>",
        "id": 289199040,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657549959
    },
    {
        "content": "<p>Actually, more generally: what am I allowed to change, and would it be easy for me to fix the Metamath thing if anything broke?</p>",
        "id": 289199487,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657550143
    },
    {
        "content": "<p>Another project that depends on ZFC is the independence of CH</p>",
        "id": 289199618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657550192
    },
    {
        "content": "<p>metamath will use <code>Class.mem</code> and <code>Class.of_Set</code> for sure but it may not use application</p>",
        "id": 289199920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657550344
    },
    {
        "content": "<p>as for going in and refactoring the export, you might be able to but you might need a different skill set to do it since part of it is written in haskell</p>",
        "id": 289200286,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657550510
    },
    {
        "content": "<p>Most of the stuff that is likely to break is in <a href=\"https://github.com/digama0/mm0/blob/build/mm0-lean/mm0/set/basic.lean\">basic.lean</a> or <a href=\"https://github.com/digama0/mm0/blob/build/mm0-lean/mm0/set/post.lean\">post.lean</a></p>",
        "id": 289200450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657550578
    },
    {
        "content": "<p>Oh, it's good to have that reference</p>",
        "id": 289200569,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657550632
    },
    {
        "content": "<p>Maybe there is some small subset of the metamath export the that could be added to archive, at least to avoid breaking the whole thing.</p>",
        "id": 289200597,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1657550642
    },
    {
        "content": "<p><a href=\"https://github.com/digama0/mm0/blob/build/mm0-lean/mm0/set/zfc_extra.lean\">zfc_extra.lean</a> is kind of a for_mathlib file</p>",
        "id": 289200654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657550654
    },
    {
        "content": "<p>I could port those theorems over if you want</p>",
        "id": 289200695,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657550674
    },
    {
        "content": "<p>and as you can see most of this hasn't been touched since 2019</p>",
        "id": 289200726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657550687
    },
    {
        "content": "<p>but I tend to work in areas that don't break all that often so it probably still works</p>",
        "id": 289200818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657550723
    },
    {
        "content": "<p>Are these files generated automatically?</p>",
        "id": 289200978,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657550776
    },
    {
        "content": "<p>no, the files I linked are all manual, the automatic stuff is not checked in</p>",
        "id": 289201046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657550802
    },
    {
        "content": "<p>well, most of basic.lean is based on an automatically generated file</p>",
        "id": 289201152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657550843
    },
    {
        "content": "<p>it's more sensitive to changes in <a href=\"https://github.com/metamath/set.mm/\">set.mm</a> than it is to changes in lean/mathlib</p>",
        "id": 289201193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657550860
    },
    {
        "content": "<p>Oh perfect</p>",
        "id": 289201287,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657550886
    },
    {
        "content": "<p>I'll tread carefully to avoid breaking it, but I doubt I will with what I have in mind</p>",
        "id": 289201324,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657550901
    },
    {
        "content": "<p><a href=\"https://github.com/digama0/mm0/blob/build/mm0-lean/mm0/set/set.lean\">https://github.com/digama0/mm0/blob/build/mm0-lean/mm0/set/set.lean</a> is one of the autogenerated files (it's broken into 6 parts)</p>",
        "id": 289201449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657550957
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/15248\">#15248</a></p>",
        "id": 289202438,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657551352
    },
    {
        "content": "<p>What's up with the line just above <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Set.mem_Union\">docs#Set.mem_Union</a>?</p>",
        "id": 289406692,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657676437
    },
    {
        "content": "<p>That's global notation, right? Which I presume overrides the meaning of <code>⋃</code> elsewhere</p>",
        "id": 289406736,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657676503
    },
    {
        "content": "<p>If so, that's really silly, since that notation is only used once</p>",
        "id": 289406743,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657676516
    },
    {
        "content": "<p>Regarding both this and the similar notation for <code>Class</code>, what should be done? Should these be localized, prefixed/suffixed with something else, or is there no point in having them?</p>",
        "id": 289406806,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657676562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/ZFC.20definable.20class/near/289406736\">said</a>:</p>\n<blockquote>\n<p>That's global notation, right? Which I presume overrides the meaning of <code>⋃</code> elsewhere</p>\n</blockquote>\n<p>Yes, it's global notation if you import it, but no it doesn't necessarily override the meaning of <code>⋃</code> since Lean has a notation disambiguation system. However, this one seems problematic since it has a different sequence of parsing actions from those for <a href=\"https://github.com/leanprover-community/mathlib/blob/00dbc7b27bf4a4d2b0990d95e555de0bf23dce8a/src/data/set/lattice.lean#L85\"><code>set.Union</code></a>. I believe this is why <code>set.sUnion</code> uses <a href=\"https://github.com/leanprover-community/mathlib/blob/00dbc7b27bf4a4d2b0990d95e555de0bf23dce8a/src/data/set/lattice.lean#L74\"><code>⋃₀</code></a>.</p>",
        "id": 289471155,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657724075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/ZFC.20definable.20class/near/289406743\">said</a>:</p>\n<blockquote>\n<p>If so, that's really silly, since that notation is only used once</p>\n</blockquote>\n<p>Don't forget that just because something isn't used in mathlib doesn't mean it's not used by someone that uses mathlib as a dependency. This seems like something someone might want to use.</p>",
        "id": 289471222,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657724112
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/ZFC.20definable.20class/near/289471155\">said</a>:</p>\n<blockquote>\n<p>However, this one seems problematic since it has a different sequence of parsing actions from those for <a href=\"https://github.com/leanprover-community/mathlib/blob/00dbc7b27bf4a4d2b0990d95e555de0bf23dce8a/src/data/set/lattice.lean#L85\"><code>set.Union</code></a>. I believe this is why <code>set.sUnion</code> uses <a href=\"https://github.com/leanprover-community/mathlib/blob/00dbc7b27bf4a4d2b0990d95e555de0bf23dce8a/src/data/set/lattice.lean#L74\"><code>⋃₀</code></a>.</p>\n</blockquote>\n<p>Should we suffix the notation for <code>Set.Union</code> too, then?</p>",
        "id": 289475787,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657726006
    },
    {
        "content": "<p>That seems reasonable to me. I don't know what <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> thinks (and I've never used the ZFC module myself), but I'd expect that the intent is that the ZFC API closely mirror the <code>set</code> API wherever possible.</p>",
        "id": 289483064,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657728825
    },
    {
        "content": "<p>I don't have any good ideas for suffixes though...</p>",
        "id": 289505179,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657738805
    },
    {
        "content": "<p>I wanted to be lazy and do a subscript Z for ZFC but that doesn't exist in Unicode</p>",
        "id": 289505226,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657738827
    },
    {
        "content": "<p>Oh, I thought when you said \"should we suffix the notation\" that we were talking about using <code>⋃₀</code>, which should work.</p>",
        "id": 289510087,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657741119
    },
    {
        "content": "<p>But that means we'll still have a clash</p>",
        "id": 289523572,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657747773
    },
    {
        "content": "<p>Is clashing with <code>⋃₀</code> somehow better than clashing with <code>⋃</code>?</p>",
        "id": 289523605,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657747791
    },
    {
        "content": "<p>might consider using superscript ᶻ (<a href=\"https://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts#Latin,_Greek_and_Cyrillic_tables\">reference</a>)</p>",
        "id": 289526324,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1657749313
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> Yes, Lean should be able to disambiguate it better because it has the same \"shape\" vs <code>⋃</code>. That's what I was referring to with parser actions.</p>",
        "id": 289528614,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657750842
    },
    {
        "content": "<p>Lean takes all possible parses and uses types to try to choose a single possibility. I don't think it works when one uses binders and the other doesn't, but I haven't checked yet.</p>",
        "id": 289528752,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657750937
    },
    {
        "content": "<p>I think the notation should be <code>⋃₀</code> and the name should be <code>sUnion</code> for consistency with data.set.basic</p>",
        "id": 289546691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1657768159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/ZFC.20definable.20class/near/289528614\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> Yes, Lean should be able to disambiguate it better because it has the same \"shape\" vs <code>⋃</code>. That's what I was referring to with parser actions.</p>\n</blockquote>\n<p>I tested this and it doesn't seem to be the case. <a href=\"https://leanprover-community.github.io/lean-web-editor/#code=import%20set_theory.zfc%0A%0Anotation%20%60%E2%8B%83%E2%82%80%60%20%3A%3D%20Set.Union%0A%0Adef%20union%20%28x%20y%20%3A%20Set%29%20%3A%20Set%20%3A%3D%20%E2%8B%83%E2%82%80%20%7Bx%2C%20y%7D\">Lean Web Editor</a></p>",
        "id": 289547073,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657768589
    },
    {
        "content": "<p>It tries using <code>set.sUnion</code> instead</p>",
        "id": 289547089,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657768616
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> That example uses <code>notation `⋃₀ ` </code> instead of <code>prefix `⋃₀ `:110</code>, which would instead ensure the two unions have the same parsers. (See <a href=\"https://github.com/leanprover-community/mathlib/blob/00dbc7b27bf4a4d2b0990d95e555de0bf23dce8a/src/data/set/lattice.lean#L74\">this</a>.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.zfc</span>\n\n<span class=\"kd\">prefix</span> <span class=\"bp\">`⋃₀</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">110</span> <span class=\"o\">:=</span> <span class=\"n\">Set.Union</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">:=</span> <span class=\"bp\">⋃₀</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 289603491,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657810819
    },
    {
        "content": "<p>One way to check this is that with the first version you have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"bp\">`⋃₀</span> <span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">Set.Union</span>\n<span class=\"k\">#print</span> <span class=\"kd\">notation</span> <span class=\"bp\">⋃₀</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">`⋃₀`:110 := Set.Union</span>\n<span class=\"cm\">`⋃₀`:110 _:110 := set.sUnion #0</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>but with the second you have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">prefix</span> <span class=\"bp\">`⋃₀</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">110</span> <span class=\"o\">:=</span> <span class=\"n\">Set.Union</span>\n<span class=\"k\">#print</span> <span class=\"kd\">notation</span> <span class=\"bp\">⋃₀</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">`⋃₀`:110 _:110 :=</span>\n<span class=\"cm\">  | set.sUnion #0</span>\n<span class=\"cm\">  | Set.Union #0</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>I believe that's what you need to see (options with <code>|</code>) for the disambiguation system to actually work.</p>",
        "id": 289604132,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657811059
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/15352\">#15352</a></p>",
        "id": 289605149,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657811512
    }
]
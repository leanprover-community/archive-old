[
    {
        "content": "<p>I'm looking to define the type of continuous maps vanishing at infinity. Does this seem like a reasonable start? I don't want to get too deep if I'm heading in the wrong direction somehow.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.continuous_function.bounded</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Continuous functions vanishing at infinity</span>\n\n<span class=\"cm\">The type of continuous functions vanishing at infinity. When the domain is a locally compact space,</span>\n<span class=\"cm\">this type has nice properties. When the domain is compact `C₀(α, β) ≃ C(α, β)` via the identity map.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">bounded_continuous_function</span>\n\n<span class=\"sd\">/-- `C₀(α, β)` is the type of continuous functions `α → β` which vanish at infinity from a</span>\n<span class=\"sd\">topological space to a metric space with a zero element. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">zero_at_infty_continuous_map</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">metric_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">continuous_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span>\n  <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">zero_at_infty'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">ε</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">is_compact</span> <span class=\"n\">K</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">metric.closed_ball</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">ε</span><span class=\"o\">)</span>\n\n<span class=\"n\">localized</span> <span class=\"s2\">\"notation `C₀(` α `, ` β `)` := zero_at_infty_continuous_map α β\"</span> <span class=\"k\">in</span> <span class=\"n\">zero_at_infty</span>\n\n<span class=\"sd\">/-- `zero_at_infty_continuous_map_class F α β` states that `F` is a type of continuous maps which</span>\n<span class=\"sd\">vanish at infinity.</span>\n\n<span class=\"sd\">You should also extend this typeclass when you extend `zero_at_infty_continuous_map`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">zero_at_infty_continuous_map_class</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">metric_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">continuous_map_class</span> <span class=\"n\">F</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">zero_at_infty</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">ε</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">is_compact</span> <span class=\"n\">K</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">metric.closed_ball</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">ε</span><span class=\"o\">)</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">zero_at_infty_continuous_map_class</span> <span class=\"o\">(</span><span class=\"n\">zero_at_infty</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">zero_at_infty</span>\n<span class=\"kn\">section</span> <span class=\"n\">basics</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">metric_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">metric_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">zero_at_infty_continuous_map_class</span> <span class=\"n\">C₀</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.to_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">congr'</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_continuous</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.continuous_to_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_at_infty</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.zero_at_infty'</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`</span>\n<span class=\"sd\">directly. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"n\">C₀</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">fun_like.has_coe_to_fun</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">zero_at_infty_continuous_map_class</span> <span class=\"n\">F</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_t</span> <span class=\"n\">F</span> <span class=\"n\">C₀</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">continuous_to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">map_continuous</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">zero_at_infty'</span> <span class=\"o\">:=</span> <span class=\"n\">zero_at_infty</span> <span class=\"n\">f</span> <span class=\"o\">}⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_to_continuous_fun</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C₀</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f.to_continuous_map</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- See Note [custom simps projection]. We need to specify this projection explicitly in this case,</span>\n<span class=\"sd\">  because it is a composition of multiple projections. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">simps.apply</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">C₀</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n\n<span class=\"n\">initialize_simps_projections</span> <span class=\"n\">zero_at_infty_continuous_map</span> <span class=\"o\">(</span><span class=\"n\">to_continuous_map_to_fun</span> <span class=\"bp\">→</span> <span class=\"n\">apply</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">zero_at_infty_continuous_map_class</span> <span class=\"n\">F</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">bounded</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">hK₁</span><span class=\"o\">,</span> <span class=\"n\">hK₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">zero_at_infty</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">zero_lt_one</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hC</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hK₁.image</span> <span class=\"o\">(</span><span class=\"n\">map_continuous</span> <span class=\"n\">f</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">bounded.subset_ball</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">max</span> <span class=\"n\">C</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">max</span> <span class=\"n\">C</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)⟩,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">metric.closed_ball</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">C</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">metric.mem_closed_ball.mp</span> <span class=\"bp\">$</span> <span class=\"n\">hC</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span> <span class=\"o\">(</span><span class=\"n\">le_max_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">metric.mem_closed_ball.mp</span> <span class=\"bp\">$</span> <span class=\"n\">hK₂</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_max_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span>  <span class=\"o\">(</span><span class=\"n\">dist_triangle</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n    <span class=\"o\">(</span><span class=\"n\">add_le_add</span> <span class=\"o\">(</span><span class=\"n\">metric.mem_closed_ball.mp</span> <span class=\"bp\">$</span> <span class=\"n\">this</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">metric.mem_closed_ball'.mp</span> <span class=\"bp\">$</span> <span class=\"n\">this</span> <span class=\"n\">y</span><span class=\"o\">)),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">bounded_continuous_map_class</span> <span class=\"n\">C₀</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.to_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">congr'</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_continuous</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.continuous_to_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">map_bounded</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">zero_at_infty.bounded</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 275384420,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647356345
    },
    {
        "content": "<ul>\n<li>You should use <code>\\{{}}</code> around <code>\\e</code> and <code>x</code>.</li>\n<li>The final instance should be stated in terms of the <code>_class</code>, not the type of morphisms.</li>\n<li>You can drop the simps projection stuff as we haven't yet decided on the correct way to use it for homs.</li>\n<li>I know we use the notation <code>C(\\a, \\b)</code> for continuous maps but even though it's standard literature notation I think that's a shame and that we should change it to <code>\\a -&gt;C \\b</code> or something more mathlib-like. So here I'd suggest using <code>\\a -&gt;C\\_0 \\b</code> or similar.</li>\n<li>Ideally, we would have a type of bounded maps in which case your <code>bounded</code> lemma would turn into an instance <code>zero_at..._class -&gt; bounded_map_class</code>. Leave that for now I'd say.</li>\n</ul>",
        "id": 275385753,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647356889
    },
    {
        "content": "<p>This is the first time I see someone \\ {Anne, I} following closely the hom refactor so I'm very happy overall :)</p>",
        "id": 275385886,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647356965
    },
    {
        "content": "<p>The <code>⦃⦄</code> means semi-implicit argument, right? Why do I want that here? I've worked with these very little, and it seems that I can't pass it an explicit value for the argument (but I'm probably doing it wrong). Where is the documentation for these?</p>",
        "id": 275395115,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647360713
    },
    {
        "content": "<p>You  can find an explanation in <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a>. Have a look at how they're used in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.pairwise\">docs#set.pairwise</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/convex\">docs#convex</a></p>",
        "id": 275396027,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647361044
    },
    {
        "content": "<p>oh, I see, you want this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">⦄,</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span>  <span class=\"n\">is_compact</span> <span class=\"n\">K</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">⦄,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">to_fun</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">metric.closed_ball</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">ε</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>not this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">ε</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">⦄,</span> <span class=\"bp\">∃</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">is_compact</span> <span class=\"n\">K</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">K</span><span class=\"o\">⦄,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">metric.closed_ball</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">ε</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 275399025,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647362166
    },
    {
        "content": "<p>That makes way more sense. I was confused trying to figure out how <code>ε</code> and <code>x</code> were supposed to be inferred in the second one.</p>",
        "id": 275399194,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647362229
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> What about using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.cocompact\">docs#filter.cocompact</a> ?</p>",
        "id": 275399458,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647362331
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">zero_at_infty_continuous_map</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">metric_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">continuous_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span>\n  <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">zero_at_infty'</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">cocompact</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 275399727,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647362446
    },
    {
        "content": "<p>Yes, much nicer. Good point.</p>",
        "id": 275399787,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647362470
    },
    {
        "content": "<p>In that case, I guess I'll just relax <code>[metric_space β]</code> to <code>[topological_space β]</code>.</p>",
        "id": 275405127,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647364479
    },
    {
        "content": "<p>I guess we don't have any non-unital analogue of <code>topological_ring</code>, do we? I could just have <code>has_continuous_add</code> and <code>has_continuous_mul</code> separately I suppose; is that the right approach?</p>",
        "id": 275519977,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647441637
    },
    {
        "content": "<p>Or generalize the definition of <code>topological_ring</code>?</p>",
        "id": 275523707,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647443018
    },
    {
        "content": "<p>It doesn't need to assume that the underlying type actually has a ring structure, right?</p>",
        "id": 275523765,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647443036
    },
    {
        "content": "<p>Well, for non-unital semirings, sure, it would generalize just fine. But if you just relax <code>semiring</code> to <code>non_unital_semiring</code> as is, then the (perhaps minor) problem is that we don't have \"<code>has_continuous_neg</code>\" and for a ring (not a semiring), the way we get this right now is by multiplying by <code>-1</code> and using <code>has_continuous_mul</code>. All this would still be fine if it weren't for <code>non_unital_ring</code>, where you still want \"<code>has_continuous_neg</code>\" but there's no way to get it for free since you don't have <code>-1</code>. I don't see an immediately easy way to fix that.</p>",
        "id": 275551361,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647452913
    },
    {
        "content": "<p>I guess maybe the way to deal with this is to have <code>topological_semiring</code> (which only requires <code>non_unital_semiring</code>, maybe even <code>non_unital_non_assoc_semiring</code>) and is just the combination of <code>has_continuous_add</code> and <code>has_continuous_mul</code>. Then separately have <code>topological_ring</code> (which only requires <code>non_unital_ring</code> or maybe <code>non_unital_non_assoc_ring</code>) which extends <code>topological_semiring</code> by adding the currently nonexistent <code>has_continuous_neg</code>.</p>",
        "id": 275551980,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647453159
    },
    {
        "content": "<p>It looks everything would be solved by having <code>has_continuous_neg</code> and an instance <code>has_continuous_mul → has_continuous_neg</code> when working over a group.</p>",
        "id": 275553056,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647453582
    },
    {
        "content": "<p>you mean over a ring?</p>",
        "id": 275553177,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647453610
    },
    {
        "content": "<p>Yes!</p>",
        "id": 275553306,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647453645
    },
    {
        "content": "<p><code>topological_ring := topological_semiring + has_continuous_neg</code> sounds like a good idea too.</p>",
        "id": 275553406,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647453676
    },
    {
        "content": "<p>So, I am defining <code>topological_semiring</code> as above along with <code>topological_ring</code> (with a type class argument of <code>non_unital_non_assoc_ring</code>). I can write the instance of <code>[non_assoc_ring R] [has_continuous_mul R] → has_continuous_neg R</code>, but then it would be nice if Lean could automatically infer this when creating instances of <code>topological_ring</code> when possible. How do I write the definition of <code>topological_ring</code> to (try to) do this automatically?</p>",
        "id": 275851970,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647631896
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span></p>",
        "id": 275881115,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647653045
    },
    {
        "content": "<p>Long story short: Wait for Lean 4</p>",
        "id": 275881156,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647653113
    },
    {
        "content": "<p><span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span> any place I can read the long version of this story?</p>",
        "id": 275890145,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647666248
    }
]
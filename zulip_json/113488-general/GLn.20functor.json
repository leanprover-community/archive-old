[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.general_linear_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.functor.category</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.Ring.basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">playground</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">GLn_functor</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"bp\">⥤</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">R.α</span><span class=\"o\">),</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">A.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">B.α</span><span class=\"o\">),</span> <span class=\"o\">(</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"c1\">-- TODO: help me here</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span> <span class=\"o\">:</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">A.α</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">B.α</span><span class=\"o\">)),</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">unit_functor</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"bp\">⥤</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"bp\">ˣ</span><span class=\"o\">),</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">A.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">B.α</span><span class=\"o\">),</span> <span class=\"o\">(</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"c1\">-- TODO: help me here</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span> <span class=\"o\">:</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span> <span class=\"bp\">⟶</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"bp\">ˣ</span><span class=\"o\">),</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">playground</span>\n</code></pre></div>\n<p>I don't know how to fix the sorry here. Can you help me? <span aria-label=\"flushed\" class=\"emoji emoji-1f633\" role=\"img\" title=\"flushed\">:flushed:</span></p>",
        "id": 293426938,
        "sender_full_name": "ZHAO Jinxiang",
        "timestamp": 1660499536
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/Group.of_hom\">docs#Group.of_hom</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/units.map\">docs#units.map</a></p>",
        "id": 293429837,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660501460
    },
    {
        "content": "<p>You have to write the analogue of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/units.map\">docs#units.map</a> for GL n by yourself, it seems.</p>",
        "id": 293430017,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660501627
    },
    {
        "content": "<p>You may use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.map\">docs#matrix.map</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_hom.map_det\">docs#ring_hom.map_det</a></p>",
        "id": 293430448,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660502008
    },
    {
        "content": "<p><del>It's a pity that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.general_linear_group\">docs#matrix.general_linear_group</a> doesn't work for noncommutative rings like the quaternions currently.</del> (The determinant definition can't be generalized to noncommutative rings, so maybe we should just work with the unit group in the matrix ring if we want that.)</p>",
        "id": 293430533,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660502048
    },
    {
        "content": "<p>Isn't <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.general_linear_group\">docs#matrix.general_linear_group</a> just an alias for <code>units</code>?</p>",
        "id": 293437693,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660507373
    },
    {
        "content": "<p>Probably in some sense, but in the same sense that the complexes is just an alias for R x R</p>",
        "id": 293442079,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660510989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/GLn.20functor/near/293437693\">said</a>:</p>\n<blockquote>\n<p>Isn't <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.general_linear_group\">docs#matrix.general_linear_group</a> just an alias for <code>units</code>?</p>\n</blockquote>\n<p>Indeed! I was misguided by the docstring saying it's the matrices with determinant a unit. So the current definition can be generalized to noncommutative rings without problem.</p>",
        "id": 293444977,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660514287
    },
    {
        "content": "<p>That docstring is also misleading in that I think most people would interpret \"matrix with unit determinant\" as \"matrix with determinant 1\".</p>",
        "id": 293447273,
        "sender_full_name": "Reid Barton",
        "timestamp": 1660517001
    },
    {
        "content": "<p>Also \"defined as a subtype of matrices\" in that docstring is a lie</p>",
        "id": 293463194,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660538310
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.general_linear_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.functor.category</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.Ring.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.special_linear_group</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">playground</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">GLn_functor</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"bp\">⥤</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">R.α</span><span class=\"o\">),</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">A.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">B.α</span><span class=\"o\">),</span> <span class=\"o\">(</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Group.of_hom</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">f1</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">ring_hom.map_det</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">A.α</span> <span class=\"n\">_</span> <span class=\"n\">B.α</span> <span class=\"n\">_</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">monoid_hom.mk'</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">A.α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">B.α</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">refine</span> <span class=\"n\">matrix.general_linear_group.mk'</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">matrix.map</span> <span class=\"n\">X</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- TODO: help me here</span>\n      <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">),</span>\n    <span class=\"n\">apply</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- TODO: help me here</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">:</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">A.α</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">B.α</span><span class=\"o\">)),</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">unit_functor</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"bp\">⥤</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"bp\">ˣ</span><span class=\"o\">),</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">A.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">B.α</span><span class=\"o\">),</span> <span class=\"n\">units.map</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">units.map_id</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">A.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">B.α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">B.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">C.α</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">fconstructor</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">playground</span>\n</code></pre></div>\n<p>Thank you <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> . But I still don't know how to fix this.</p>",
        "id": 293469067,
        "sender_full_name": "ZHAO Jinxiang",
        "timestamp": 1660543509
    },
    {
        "content": "<p>Can you not reuse what you did in <code>unit_functor</code>?</p>",
        "id": 293470188,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660544414
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329691\">@ZHAO Jinxiang</span> This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">GLn_functor</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"bp\">⥤</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">R.α</span><span class=\"o\">),</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">A.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">B.α</span><span class=\"o\">),</span> <span class=\"o\">(</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Group.of_hom</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">units.map</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">f.map_matrix.to_monoid_hom</span><span class=\"o\">,</span> <span class=\"c\">/-</span><span class=\"cm\"> ring_hom.map_matrix -/</span>\n  <span class=\"kd\">end</span> <span class=\"o\">:</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">A.α</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">B.α</span><span class=\"o\">)),</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>Since we discovered that <code>general_linear_group</code> is actually defined to be the units, we apply <code>units.map</code> again.</p>",
        "id": 293470658,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660544809
    },
    {
        "content": "<p>In term mode you can just do <code>  map := λ _ _ f, Group.of_hom (units.map f.map_matrix.to_monoid_hom),</code> or even omit the <code>Group.of_hom</code> (not necessarily good practice).</p>",
        "id": 293470897,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660544992
    },
    {
        "content": "<p>Can you not get <code>GLn_functor</code> as the composition of some functor and <code>unit_functor</code>?</p>",
        "id": 293471135,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660545160
    },
    {
        "content": "<p>Btw, <code>unit_functor</code> already exists as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Mon.units\">docs#Mon.units</a> composed with the appropriate sequence of forgetful functors.</p>",
        "id": 293471579,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660545555
    },
    {
        "content": "<p>Yeah the doc strings are my fault I forgot to change them after the PR review changes</p>",
        "id": 293481167,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1660551330
    },
    {
        "content": "<p>Thanks for all your  helps.<br>\nBut it seems that I also need help here. <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.general_linear_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.functor.category</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.Ring.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">GLn_functor</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"bp\">⥤</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">R.α</span><span class=\"o\">),</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">A.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">B.α</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"n\">units.map</span> <span class=\"n\">f.map_matrix.to_monoid_hom</span> <span class=\"o\">:</span>\n      <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">A.α</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">B.α</span><span class=\"o\">)),</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">dunfold</span> <span class=\"n\">CommRing</span> <span class=\"n\">category.to_category_struct</span> <span class=\"n\">SemiRing.assoc_ring_hom</span> <span class=\"n\">bundled_hom.map_hom</span> <span class=\"n\">bundled_hom.bundled_hom_of_parent_projection</span> <span class=\"n\">comm_ring.to_ring</span> <span class=\"n\">bundled_hom.map</span><span class=\"o\">,</span>\n    <span class=\"n\">dunfold</span> <span class=\"n\">SemiRing.bundled_hom</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">convert_to</span> <span class=\"n\">units.map</span> <span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">A.α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_matrix</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">dunfold</span> <span class=\"n\">ring_hom.id</span> <span class=\"n\">id</span> <span class=\"n\">coe</span> <span class=\"n\">lift_t</span> <span class=\"n\">has_lift_t.lift</span> <span class=\"n\">coe_t</span> <span class=\"n\">has_coe_t.coe</span> <span class=\"n\">ring_hom.map_matrix</span> <span class=\"n\">units.map</span> <span class=\"n\">monoid_hom.mk'</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">dunfold</span> <span class=\"n\">group.to_monoid</span> <span class=\"n\">div_inv_monoid.to_monoid</span> <span class=\"n\">bundled_hom.id</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">dunfold</span> <span class=\"n\">monoid_hom.id</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">A.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">B.α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">B.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">C.α</span><span class=\"o\">),</span> <span class=\"kd\">begin</span>\n    <span class=\"c1\">-- TODO: help me here</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">units_functor</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"bp\">⥤</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"bp\">ˣ</span><span class=\"o\">),</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">A.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">B.α</span><span class=\"o\">),</span> <span class=\"n\">units.map</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">units.map_id</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">A.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">B.α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"n\">B.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">C.α</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">fconstructor</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">det_nat_trans</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">GLn_functor</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"n\">units_functor</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">matrix.general_linear_group.det</span><span class=\"o\">,</span>\n  <span class=\"n\">naturality'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span> <span class=\"n\">R'</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">R.α</span> <span class=\"bp\">→+*</span> <span class=\"n\">R'.α</span><span class=\"o\">),</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">dunfold</span> <span class=\"n\">GLn_functor</span> <span class=\"n\">units_functor</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">dunfold</span> <span class=\"n\">coe</span> <span class=\"n\">lift_t</span> <span class=\"n\">has_lift_t.lift</span> <span class=\"n\">coe_t</span> <span class=\"n\">has_coe_t.coe</span> <span class=\"n\">coe_fn</span> <span class=\"n\">fun_like.has_coe_to_fun</span> <span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- TODO: help me here</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 293544664,
        "sender_full_name": "ZHAO Jinxiang",
        "timestamp": 1660575266
    },
    {
        "content": "<p>I imagine <a href=\"https://leanprover-community.github.io/mathlib_docs/find/units.map_comp\">docs#units.map_comp</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_hom.map_matrix_comp\">docs#ring_hom.map_matrix_comp</a> will do most of the work</p>",
        "id": 293547246,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660575980
    },
    {
        "content": "<p>The first <code>sorry</code> is <code>refl</code></p>",
        "id": 293550196,
        "sender_full_name": "Reid Barton",
        "timestamp": 1660576323
    },
    {
        "content": "<p>In fact, the two first definitions can be compressed to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">GLn_functor</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"bp\">⥤</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span>       <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Group.of</span> <span class=\"o\">(</span><span class=\"n\">GL</span> <span class=\"n\">n</span> <span class=\"n\">R.α</span><span class=\"o\">),</span>\n  <span class=\"n\">map</span>       <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">units.map</span> <span class=\"n\">f.map_matrix.to_monoid_hom</span><span class=\"o\">,</span>\n  <span class=\"n\">map_id'</span>   <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">units_functor</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"bp\">⥤</span> <span class=\"n\">Group</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span>       <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">Group.of</span> <span class=\"n\">R</span><span class=\"bp\">ˣ</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span>       <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">f</span> <span class=\"o\">,</span> <span class=\"n\">units.map</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">map_id'</span>   <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">units.map_id</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 293586469,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660583622
    },
    {
        "content": "<p>I find that most of the proofs in the category theory side of mathlib are obtained by some combination of <code>ext, simp, dsimp, refl</code>.  However, since they usually take a long time to play out, trying out all combinations is usually not a viable option.  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 293586750,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660583731
    },
    {
        "content": "<p>I guess <code>tidy</code> can do them. So you can even leave out the last two fields in both defs.</p>",
        "id": 293591137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1660585440
    },
    {
        "content": "<p>Ah, this is another proof strategy: not even proving lemmas!</p>",
        "id": 293592145,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1660585798
    },
    {
        "content": "<p>What's the correct abstract category theory nonsense that makes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>↦</mo><mi>E</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">X \\mapsto End(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6943em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> into a functor?</p>",
        "id": 293592516,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660585921
    },
    {
        "content": "<p>(taking values in <code>Mon</code>, say)</p>",
        "id": 293592578,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660585930
    },
    {
        "content": "<p>Are you sure this is a functor?</p>",
        "id": 293604904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660590731
    },
    {
        "content": "<p>It's not.</p>",
        "id": 293606115,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660591206
    },
    {
        "content": "<p>But the functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>↦</mo><mi>E</mi><mi>n</mi><msub><mi>d</mi><mi>k</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>k</mi><mi>n</mi></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k \\mapsto End_k(k^n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7054em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\">n</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is, and the functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>↦</mo><mi>G</mi><msub><mi>L</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k \\mapsto GL_n(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7054em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span> is the composition of that with the units functor. I'm just wondering if there is a categorical abstraction of this.</p>",
        "id": 293606312,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660591293
    },
    {
        "content": "<p>The End in that example is a representable functor taking values in rings so maybe it has something to do with Hopf algebras rather than a general category thing</p>",
        "id": 293606685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660591430
    },
    {
        "content": "<p>oh yeah that's a good point</p>",
        "id": 293606806,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660591467
    },
    {
        "content": "<p>I guess the general thing is to take a monoid object in some monoidal category and to look at its units.</p>",
        "id": 293607155,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660591588
    },
    {
        "content": "<p>then take the functor these things represent</p>",
        "id": 293607170,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660591596
    },
    {
        "content": "<p>My viewpoint is that M : R ↦ R^n defines a \"dependent functor\" from Ring to Module over the ring, and you can view it as a sheaf of modules. Usually <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mtext>Hom</mtext><mi>R</mi></msub><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>N</mi><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{Hom}_R(M(R), N(R))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Hom</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">))</span></span></span></span> don't form a (pre)sheaf (so it's not the way to define sheaf Hom), but here M is \"quasi-coherent\" so we're OK; to define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mi>n</mi></msup><mo>→</mo><msup><mi>S</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">S^n\\to S^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>R</mi><mi>n</mi></msup><mo>→</mo><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">f : R^n\\to R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> and a ring hom <code>ϕ : R →+* S</code> you compose the isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mi>n</mi></msup><mo>≅</mo><msup><mi>R</mi><mi>n</mi></msup><msub><mo>⊗</mo><mi>S</mi></msub><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S^n\\cong R^n\\otimes_S S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup><msub><mo>⊗</mo><mi>S</mi></msub><mi>S</mi><mo>→</mo><msup><mi>S</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">R^n\\otimes_S S\\to S^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> induced by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> composed with the dependent \"<a href=\"http://functor.map\">functor.map</a> ϕ\": <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup><mo>→</mo><msup><mi>S</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">R^n\\to S^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> (as R-modules). Of course when M=N the sheaf Hom from M to itself is a sheaf of rings by composition.</p>\n<p>By the way I think we should define presheaves of modules (on ringed spaces) in terms of dependent functors, and build the API to connect with other useful definitions afterwards. Even though <code>Cat</code> is a 1-category and the (restriction of scalars) functor taking a Ring to its category of modules is a strict functor, we may want to define functors dependent on an arbitrary (op)lax functor into <code>Cat</code>, now that we have the framework (and notice that extension of scalars isn't a strict functor). However, it seems that a theory of dependent functors isn't present in the literature.</p>",
        "id": 293617119,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660595880
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> what do you mean by dependent functors? I would love to see a definition of presheaves of modules in mathlib! It's been missing for far too long. I would really like to see the sheaf of Kaehler differentials, which would be a great test case.</p>",
        "id": 293617529,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660596047
    },
    {
        "content": "<p>Dependent functor are the functorial analogue of a dependent function ;)</p>",
        "id": 293617761,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660596142
    },
    {
        "content": "<p>So <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>↦</mo><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">R \\mapsto R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6943em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> is a dependent functor because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup><mo>:</mo><mi>M</mi><mi>o</mi><msub><mi>d</mi><mi>R</mi></msub></mrow><annotation encoding=\"application/x-tex\">R^n : Mod_R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mi>o</mi><msub><mi>d</mi><mi>R</mi></msub></mrow><annotation encoding=\"application/x-tex\">Mod_R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a category which depends on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span></p>",
        "id": 293617834,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660596177
    },
    {
        "content": "<p>And when you have a morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">R \\to S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> you relate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">S^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> by base-change</p>",
        "id": 293617867,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660596195
    },
    {
        "content": "<p>This is all possible to make precise with pseudofunctors and/or Grothendieck constructions</p>",
        "id": 293618000,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660596251
    },
    {
        "content": "<p>It's basically the definition of a sheaf of modules and I <a href=\"https://github.com/leanprover-community/mathlib/commit/a96576ee24ca8b87e7b3103c901e23f9f7328b77#diff-be29c27083b2c5945ac483756ce16a0b587b96b09f3dc2704c95801ad10c16e5R31-R39\">made the definition here</a>; it's a functor dependent on a <code>oplax_functor (locally_discrete C) Cat</code>, which in the case of sheaf of modules you take it to be the sheaf of rings (which is a functor from opens to Ring) composed with the functor from Ring to Cat.<br>\n<code>variables {C : Type u} [category.{v} C] (F : oplax_functor (locally_discrete C) Cat.{v' u'})</code></p>",
        "id": 293618058,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660596285
    },
    {
        "content": "<p>I'd encourage you to PR it! I think it's time we started experimenting with this.</p>",
        "id": 293618257,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660596362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/GLn.20functor/near/293618257\">said</a>:</p>\n<blockquote>\n<p>I'd encourage you to PR it! I think it's time we started experimenting with this.</p>\n</blockquote>\n<p>I'll second this!</p>",
        "id": 293618369,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1660596418
    },
    {
        "content": "<p>I haven't developed much (if any) APIs for it; as you can see it's been abandoned for months with lots of sorries. Maybe someone can take it up!</p>",
        "id": 293618392,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660596431
    },
    {
        "content": "<p>I don't see sorries...</p>",
        "id": 293618951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660596676
    },
    {
        "content": "<p>I see merge conflicts, and I also see that I no longer understand how VS Code deals with them :-/</p>",
        "id": 293619245,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660596798
    },
    {
        "content": "<p>Yeah, it seems I haven't even written down the sorries, but I did have a <a href=\"https://github.com/leanprover-community/mathlib/commit/014c90b4862b1a6271ef3aac2ec77492bf338a48\">TODO list</a> that I just pushed. I've also defined dependent nat_trans and shown that dependent functors <a href=\"https://github.com/leanprover-community/mathlib/commit/c916a79331b1d447f8bfd8864b3dddfaa53a968d#diff-be29c27083b2c5945ac483756ce16a0b587b96b09f3dc2704c95801ad10c16e5R63\">form a category</a>. The latest commit in that branch changed functors to prefunctors, because I wanted to understand which conditions are essential. The branch does a lot of other stuff and the dependent functor portion is very much under construction; I don't think a single defintion could make a PR ...</p>",
        "id": 293620820,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660597536
    },
    {
        "content": "<p>I have made PRs with just definitions eg projective modules and elliptic curves</p>",
        "id": 293626703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660600333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/GLn.20functor/near/293617761\">said</a>:</p>\n<blockquote>\n<p>Dependent functor are the functorial analogue of a dependent function ;)</p>\n</blockquote>\n<p>This analogy actually makes a lot of sense. If categories are types and functors are functions, then functor categories are function types, functors to Cat are type families, and Grothendieck constructions are sigma types; what's missing are pi types (i.e. dependent function types), and introducing a category of dependent functors would fill in this gap.</p>\n<p>The paper <a href=\"https://arxiv.org/abs/2109.04239\">https://arxiv.org/abs/2109.04239</a> feels very relevant, but I find the notation hard to decipher. I'm unaware of any other reference.</p>\n<p>In the context of sheaves of modules we have the following:</p>\n<ol>\n<li>\n<p>We have the functor <code>Module : Ring ⥤ Cat</code> with <code>functor.map</code> given by restriction of scalars, and we consider it as a type family <code>F : β → Type*</code>.</p>\n</li>\n<li>\n<p>We can form the Grothendieck category of the functor <code>Module</code>, i.e. the category <code>BundledModule</code>, which corresponds to the sigma type <code>Σ b, F b</code>.</p>\n</li>\n<li>\n<p>Whenever we have a presheaf of rings, i.e. a functor <code>f : opens X ⥤ Ring</code> (omitting the <code>op</code>), composing with <code>Module</code> gives a functor <code>opens X ⥤ Cat</code>, corresponding to the function <code>F ∘ f : α → Type*</code>. </p>\n</li>\n<li>\n<p>Composition is functorial, resulting in a functor <code>(opens X ⥤ Ring) ⥤ (opens X ⥤ Cat)</code> from presheaves of rings to presheaves of Cats, corresponding to the fact that <code>λ f, F ∘ f : (α → β) → (α → Type*)</code> is a function.</p>\n</li>\n<li>\n<p>Now for every <code>opens X ⥤ Cat</code> we introduce a dependent functor category; this association is functorial and corresponds to the function <code>λ ι, Π a, ι a : (α → Type*) → Type*</code>.</p>\n</li>\n<li>\n<p>Composing with the functor in 4, we arrive at a functor <code>(opens X ⥤ Ring) ⥤ Cat</code>, sending a presheaf of rings O_X to the category of presheaves of modules over O_X, and we may take its Grothendieck construction, which corresponds to the type <code>Σ f, Π a, F (f a)</code>.</p>\n</li>\n<li>\n<p>This category should be equivalent (or isomorphic?) to the category of presheaves of bundled modules over X, i.e. <code>opens X ⥤ BundledModule</code>, corresponding to the type <code>α → Σ b, F b</code>. This looks similar to Theorem 3.6 in the paper.</p>\n</li>\n</ol>\n<p>Interestingly, the functoriality of the Grothendieck construction is not used in the argument above.</p>\n<p>In Type* the construction of the equivalence is very simple:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fun_to_sigma_equiv'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">Σ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">sigma.fst</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">sigma.snd</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)⟩,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">g.fst</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">g.snd</span> <span class=\"n\">a</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">sigma.eta</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"n\">sigma.eta</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>The special case <code>F := id</code> yields <code>(α → Σ b, b) ≃ (Σ f : α → Type*, Π a, f a)</code> but the construction isn't simpler.</p>\n<p>However, a lot needs to be done to flesh out the category version; for example, it's not totally clear which functors mentioned above should be strict (if any) and which are allowed to be (op)lax. To deal with sheaves of modules, it suffices to restrict to strict functors, since <code>Module : Ring ⥤ Cat</code> is strict, but we may not want to exploit this strictness since it involves equality of functors. If that's the case, then the first thing to do is probably generalizing the Grothendieck construction to any oplax functor, which I have done in <a href=\"https://github.com/leanprover-community/mathlib/compare/lax_grothendieck_bicat#diff-779e8ece193ac9cfb8b3ab087590457d8f57c59a774bd663d70eaa8e6a160ecd\">the branch</a> and should be ready to PR after some cleanup.</p>",
        "id": 294983118,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661319750
    }
]
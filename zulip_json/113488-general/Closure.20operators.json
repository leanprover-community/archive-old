[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> baked us an API for closure operators (in order/closure.lean). It provides a bundled version of a closure operator. Should we refactor <code>closure</code>, <code>convex_hull</code> and other, or should we instead prove an unbundled version as an instance for each of them?</p>",
        "id": 235993951,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619289416
    },
    {
        "content": "<p>Would this work for a bundled version of say <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.closure\">docs#submonoid.closure</a>? What would that look like if so?</p>",
        "id": 235994272,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619289637
    },
    {
        "content": "<p>Actually, you already have a Galois insertion on submonoids, which is better than a closure operator. So I don't think it's applicable there, apart from exempting from proving some lemmas by hand.</p>",
        "id": 235998368,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619292594
    },
    {
        "content": "<p>Do we have a way to downgrade a galois insertion to a closure operator then?</p>",
        "id": 236002483,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619295781
    },
    {
        "content": "<p>Yeah, we do! It's <code>galois_insertion.closure_operator</code>. We might want to rename it to <code>galois_insertion.to_closure_operator</code>.</p>",
        "id": 236005275,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619297919
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/galois_insertion.closure_operator\">docs#galois_insertion.closure_operator</a>?</p>",
        "id": 236005468,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619298025
    },
    {
        "content": "<p>Ah oops, it's rather <a href=\"https://leanprover-community.github.io/mathlib_docs/find/galois_connection.closure_operator\">docs#galois_connection.closure_operator</a></p>",
        "id": 236005831,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619298105
    },
    {
        "content": "<p>Actually, it's not much that the Galois insertion (or connection?) is more powerful than the closure operator but rather that <code>submonoid</code> is bundled. I can easily define the closure operator to output the carrier of <code>submonoid.closure</code>, but not with the information that it's a submonoid  built in.</p>",
        "id": 236006123,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619298179
    },
    {
        "content": "<p>In contrast, it works great for <code>convex_hull</code> because <code>convex</code> is unbundled.</p>",
        "id": 236006249,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619298219
    },
    {
        "content": "<p>Actually, I'm thinking there's something to be done there. The pattern \"closure operator that's actually not quite one because it outputs the closure bundled with more info\" is ultra common: subgroups, submonoids, subspaces... and I'm sure you can think of more than I do. What we could do would be to define <code>bundled_closure_operator</code> as a closure operator bundled with the information that its output is a submonoid/subgroup/subspace...<br>\nWhat's your opinion?</p>",
        "id": 236673228,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619703214
    },
    {
        "content": "<p>How is this different from a galois insertion?</p>",
        "id": 236673415,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1619703281
    },
    {
        "content": "<p>Oh, is it how Galois insertions work already?</p>",
        "id": 236673809,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619703431
    },
    {
        "content": "<p>It seems to me that you're describing exactly a galois insertion, which is already there for submonoids, subgroups etc</p>",
        "id": 236673950,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1619703487
    },
    {
        "content": "<p>In particular, you turn <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.gi\">docs#subgroup.gi</a> into a closure operator by forgetting the bundled info after applying <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.closure\">docs#subgroup.closure</a>.</p>",
        "id": 236674453,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1619703696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/113488-general/topic/Closure.20operators/near/236673950\">said</a>:</p>\n<blockquote>\n<p>It seems to me that you're describing exactly a galois insertion, which is already there for submonoids, subgroups etc</p>\n</blockquote>\n<p>No, that's not how it works. Take for example <code>submonoid.closure</code>. It's defined as <code>\\la s, Inf {S : submonoid M | s ⊆ ↑S}</code>. What I'm offering is to define it as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">bundled_closure_operator</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">\\</span><span class=\"n\">la</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">Inf</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">M</span> <span class=\"bp\">|</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"bp\">↑</span><span class=\"n\">S</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">to_coe</span> <span class=\"o\">:=</span> <span class=\"bp\">\\</span><span class=\"n\">la</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">Inf</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span> <span class=\"bp\">\\</span><span class=\"n\">and</span> <span class=\"bp\">\\</span><span class=\"n\">ex</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">S</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"n\">more</span> <span class=\"n\">infos</span> <span class=\"n\">to</span> <span class=\"n\">make</span> <span class=\"n\">to_coe</span> <span class=\"n\">a</span> <span class=\"n\">closure</span> <span class=\"n\">operator</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>or something of sort</p>",
        "id": 236674681,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619703787
    },
    {
        "content": "<p>My point is that we could change the way the info is bundled so that we can actually use the theorems associated with closure operators.</p>",
        "id": 236674948,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619703898
    },
    {
        "content": "<p>Are you asking for a shorter name for <code>subgroup.gc.closure_operator</code>?</p>",
        "id": 236676425,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619704437
    },
    {
        "content": "<p>Is this the kind of thing you're looking for?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.subgroup</span>\n\n<span class=\"sd\">/-- The `has_closure A B` typeclass represents types with</span>\n<span class=\"sd\">a canonical injection `coe : A → set B`, which has a left adjoint `closure : set B → A`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_closure</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">set_like</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">gi</span> <span class=\"o\">:</span> <span class=\"n\">galois_insertion</span> <span class=\"n\">closure</span> <span class=\"n\">coe</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">has_closure</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">has_closure</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">complete_lattice</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_closure.gi.lift_complete_lattice</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">has_closure</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">subgroup.has_closure</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_closure</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">closure</span> <span class=\"o\">:=</span> <span class=\"n\">subgroup.closure</span><span class=\"o\">,</span>\n  <span class=\"n\">gi</span> <span class=\"o\">:=</span> <span class=\"n\">subgroup.gi</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">subgroup.set_like</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 236676751,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1619704563
    },
    {
        "content": "<p>(This doesn't work great because you can't infer which <code>closure</code> you're taking from the arguments, so you need to keep writing <code>x ∈ (closure s : subgroup G)</code>.)</p>",
        "id": 236677288,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1619704794
    },
    {
        "content": "<p>I don't think that's going to work well, because we define <code>closure</code> in terms of the complete lattice structure</p>",
        "id": 236677733,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619704965
    },
    {
        "content": "<p>I have a refactor in progress that replaces <code>subgroup</code> with <code>subtype is_subgroup</code>, that might make it easier to generalize this type of thing</p>",
        "id": 236677827,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619704994
    },
    {
        "content": "<p>Yeah, as it is set up currently it wouldn't work in some places where <code>closure</code> is defined in terms of <code>Inf</code>. However, instances like  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/intermediate_field.complete_lattice\">docs#intermediate_field.complete_lattice</a> already use this technique and would definitely see advantages in terms of deduplication.</p>",
        "id": 236678208,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1619705150
    },
    {
        "content": "<p>For example, here are the first few <code>closure</code> lemmas in <code>subgroup.lean</code>, which are really just <code>galois_insertion _ coe</code> lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">subset_closure</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_closure.gi.gc.le_u</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">closure_le</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">S</span> <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_closure.gi.gc</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_closure</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">set_like.mem_coe</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">set.singleton_subset_iff</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">closure_le</span><span class=\"o\">],</span>\n     <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">le_trans</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">closure_eq_of_le</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">closure</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">closure_le.2</span> <span class=\"n\">h₁</span><span class=\"o\">)</span> <span class=\"n\">h₂</span>\n</code></pre></div>",
        "id": 236679853,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1619705739
    },
    {
        "content": "<p>Yes, you very much got my point. Sorry for being unclear. I'm mostly worried about the duplication I'm seeing all over the place (have a look at <code>convex_hull</code>, for example).</p>",
        "id": 236682532,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619706668
    },
    {
        "content": "<p>I'm now planning on bundling closure operators whose output is unbundled. I already spotted convex hull, topological closure, transitive closure, reflexive closure.<br>\nWhat do you think?</p>",
        "id": 236682777,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619706761
    },
    {
        "content": "<p>The radical of an ideal is another example :)</p>",
        "id": 236683871,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1619707104
    },
    {
        "content": "<p>Ooh, right! The radical of a natural too, but I'm not sure that already exists/there's a nice way to formulate it without using ideals.</p>",
        "id": 236683989,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619707163
    },
    {
        "content": "<p>I think radical of a natural should be an interior operator rather than a closure operator?</p>",
        "id": 236684131,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1619707207
    },
    {
        "content": "<p>rad n is literally the natural number corresponding to the radical of nZ.</p>",
        "id": 236684323,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619707275
    },
    {
        "content": "<p>Sure, but the radical of a natural can be smaller (in divisibility or the usual ordering) than the natural itself</p>",
        "id": 236684733,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1619707407
    },
    {
        "content": "<p>Ah right. Am I correct thinking that an interior operator is literally a closure operator with respect to the dual order?</p>",
        "id": 236685048,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619707509
    },
    {
        "content": "<p>Yup!</p>",
        "id": 236687464,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1619708359
    },
    {
        "content": "<p>The inequality on ideals is dual to the divisibility operator on naturals :-)</p>",
        "id": 236701325,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619712593
    },
    {
        "content": "<p>Just spotted <code>zorn.chain_closure</code> and <code>field_theory.perfect_closure</code> in the wild.</p>",
        "id": 236733881,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619725619
    },
    {
        "content": "<p>I think another closure operator that we should add ASAP is the relative algebraic closure of a set in a field extension. The general stuff about closure operators would then let us define transcendence degree, transcendence bases, etc.</p>",
        "id": 236737281,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619727032
    },
    {
        "content": "<p>Do you already have a definition and only need a refactor, or do you need to set up the theory as well?</p>",
        "id": 236737951,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619727309
    },
    {
        "content": "<p>I thought there's content to the assertion that transcendence degree is well-defined? It's some matroid property?</p>",
        "id": 236738147,
        "sender_full_name": "David Wärn",
        "timestamp": 1619727390
    },
    {
        "content": "<p>That's right. you need the exchange axiom</p>",
        "id": 236738248,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619727453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Closure.20operators/near/236737951\">said</a>:</p>\n<blockquote>\n<p>Do you already have a definition and only need a refactor, or do you need to set up the theory as well?</p>\n</blockquote>\n<p>No, as far as I'm aware the definition of relative algebraic closure is not in mathlib</p>",
        "id": 236738364,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1619727489
    },
    {
        "content": "<p>What is the \"relative algebraic closure\"? Is this just the \"algebraic closure of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>\"? Because that's the same as the integral closure, which mathlib knows about.</p>",
        "id": 236785176,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619757942
    },
    {
        "content": "<p>How do we want to deal with interior operators? Do we want to make a specific API, or just define the ones we have as closure operators on the dual order?</p>",
        "id": 236796225,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619767590
    },
    {
        "content": "<p>in particular, is there any general interaction between interior and closure operators?</p>",
        "id": 236796441,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619767769
    },
    {
        "content": "<p>The problem with this question is that there are people who feel that the principled approach is to do everything twice, and there are people who feel that duplicating code can't be the right idea, so you might not get a coherent answer about how to make an <code>interior</code> API. The only way I've seen interior and closure interact is via <code>frontier</code>, which is closure minus interior and has its own little API.</p>",
        "id": 236797397,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619768397
    },
    {
        "content": "<p>Oh, I found a funny one.  <code>span_points</code> and <code>affine_span</code> are the unbundled and bundled variant of the same closure operator. Here it seems that my approach is well worth some thought. <br>\nMy idea is that, given a partial order on <code>α</code> and a structure <code>S α</code> on <code>α</code> (think of <code>(≤)</code> and <code>subgroup</code>), we could define a \"bundled closure operator\" on <code>α</code> as an object that could be coerced to a function <code>α → S α</code>, knowing that the output of this function could itself be coerced to <code>α</code>. That way, we could get the best off both worlds.</p>",
        "id": 237308436,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620128516
    },
    {
        "content": "<p>What I don't know is whether it's possible to feed in such a structure (<code>subgroup</code>, <code>submonoid</code>, <code>affine_subspace</code>...) to a constructor. Is it?</p>",
        "id": 237310275,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620129484
    },
    {
        "content": "<p>We have things like <code>is_subgroup</code> (a predicate on subsets) which can sometimes be useful in situations like this.</p>",
        "id": 237311047,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620129790
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>, you might look at the design of <code>concrete_category</code>, and for example how we set up <code>Mon</code>, <code>Group</code>, <code>Module</code>, and so on, to see one approach to be polymorphic in typeclasses.</p>",
        "id": 237311616,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1620130059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Closure.20operators/near/235994272\">said</a>:</p>\n<blockquote>\n<p>Would this work for a bundled version of say <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.closure\">docs#submonoid.closure</a>? What would that look like if so?</p>\n</blockquote>\n<p>Turns out it works! The trick is to simply change <code>closure_operator extends α →ₘ α</code> to <code>closure_operator extends α →ₘ β</code> and ask for the instance <code>[has_coe_t β α]</code> (if anyone knows how to ask this coercion to be monotone, please tell me!).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.closure</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.submonoid.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">submonoid</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">mul_one_class</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">submonoid.neo_closure</span> <span class=\"o\">:</span> <span class=\"n\">closure_operator</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">submonoid</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">Inf</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">M</span> <span class=\"bp\">|</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"bp\">↑</span><span class=\"n\">S</span><span class=\"o\">},</span>\n  <span class=\"n\">le_closure'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">mem_Inf.2</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">S</span> <span class=\"n\">hS</span><span class=\"o\">,</span> <span class=\"n\">hS</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">idempotent'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">monotone'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>I left <code>idempotent'</code> and <code> monotone'</code> sorried because the easy way to prove them is to use my new constructors, which I haven't yet bothered to translate in this new two types closure operators paradigm.</p>",
        "id": 237359969,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620146969
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113488-general/topic/Closure.20operators/near/236677288\">said</a>:</p>\n<blockquote>\n<p>(This doesn't work great because you can't infer which <code>closure</code> you're taking from the arguments, so you need to keep writing <code>x ∈ (closure s : subgroup G)</code>.)</p>\n</blockquote>\n<p>In my conception of things, we would rather define <code>group.closure</code> and then write <code>x ∈ G.closure s</code>. The example I posted just above should clear up my intentions.</p>",
        "id": 237403973,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620164004
    },
    {
        "content": "<p>Ah good idea! I didn't like the idea of defining <code>subgroup.closure</code> and <code>submonoid.closure</code> and <code>submodule.span</code> and ... because you would have to copy over all (<code>simp</code>) lemmas, but instantiating it as a bundled type fixes that.</p>",
        "id": 237465472,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620206639
    },
    {
        "content": "<p>Is this the place you need your <code>has_coe_t</code> to be either <code>id</code> or the map sending subobjects to the carrier set? I think you're looking for the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set_like\">docs#set_like</a> typeclass in that case.</p>",
        "id": 237467051,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620207480
    },
    {
        "content": "<p>I haven't been following this thread properly but if we're going to define some fancy new <code>submodule.span</code> then we might want to do the same for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lie_submodule.lie_span\">docs#lie_submodule.lie_span</a></p>",
        "id": 237467191,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1620207563
    },
    {
        "content": "<p>Sorry, just realized this is being discussed further here: <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/monotone.20coercion\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/monotone.20coercion</a></p>",
        "id": 237467211,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620207574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/113488-general/topic/Closure.20operators/near/237467191\">said</a>:</p>\n<blockquote>\n<p>I haven't been following this thread properly but if we're going to define some fancy new <code>submodule.span</code> then we might want to do the same for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lie_submodule.lie_span\">docs#lie_submodule.lie_span</a></p>\n</blockquote>\n<p>Definitely! If the <code>lie_span</code> of <code>s</code> is the smallest <code>lie_submodule</code> whose carrier set contains <code>s</code>, then it should be defined as a closure operator.</p>",
        "id": 237467310,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620207631
    },
    {
        "content": "<p>It is indeed, according to the docstring :)</p>",
        "id": 237467349,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620207661
    },
    {
        "content": "<p>A refactor I've been considering is redefining <code>submodule</code> as <code>subtype is_submodule</code>, which means we can have a general <code>closure</code> operator which just means <code>closure (s : set A) (p : set A \\to Prop) : subtype p := Inf { x : subtype p | s \\sub \\u x}</code></p>",
        "id": 237470753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620209482
    },
    {
        "content": "<p>(this would obsolete set_like)</p>",
        "id": 237470907,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620209580
    },
    {
        "content": "<p>Interesting idea, I don't know if it would completely obsolete <code>set_like</code> though: wouldn't you have to choose between writing <code>subtype (is_subobject X)</code> everywhere, or writing <code>subobject X</code> and copying over all <code>subtype</code> lemmas?</p>",
        "id": 237471894,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620210219
    },
    {
        "content": "<p>(An appropriate version of <code>set_like</code> would basically automate the latter.)</p>",
        "id": 237471967,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620210255
    },
    {
        "content": "<p>... or define <code>submodule M</code> as <code>subobject (Module.of R M)</code>... :-) I really haven't thought whether it is at all plausible. There is a complete lattice structure on <code>subobject X</code> with reasonable assumption, however, and various functoriality / pullback / pushforward operations.</p>",
        "id": 237479939,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1620214611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Closure.20operators/near/237470753\">said</a>:</p>\n<blockquote>\n<p>A refactor I've been considering is redefining <code>submodule</code> as <code>subtype is_submodule</code>, which means we can have a general <code>closure</code> operator which just means <code>closure (s : set A) (p : set A \\to Prop) [complete_lattice (subtype p)] : subtype p := Inf {x : subtype p | s ⊆ ↑x}</code></p>\n</blockquote>\n<p>How does that interact with my refactor proposition? Would you do that instead of mine, or layer both?</p>",
        "id": 237562418,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620247558
    },
    {
        "content": "<p>Ah actually wouldn't there be the problem that closure operators don't need complete lattices to work? Partial order is enough, but I don't know whether any of the closure operators we deal with in practice are partial orders but not complete lattices.</p>",
        "id": 237625793,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620291030
    },
    {
        "content": "<p>This isn’t a redefinition of <code>closure_operator</code>, it’s a specific function that could be made into a <code>closure_operator</code></p>",
        "id": 237716058,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1620329526
    },
    {
        "content": "<p>Okay so we have Galois connections and closure operators. Which way do we want go? Should we build Galois connections from closure operators, or closure operators from Galois connections?</p>\n<p>If we start from Galois connections, then we're kind of burying the actual closure and maybe it will be harder to work with in practice (is there any way to systematically simplify it?). Further, I don't think we ever use Galois connections in expression. They rather tend to be passed as instances. The current way things are set up is that we first define the closure operator, and then prove the <code>galois_connection</code>/<code>galois_insertion</code> instance.</p>\n<p>If we start from closure operators, I don't think we have the problem that closure operators do not uniquely determine Galois connections because we're bundling them with the functions. But we might want to change the definition we currently have to get rid of the <code>galois_connection</code> field:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">fully_bundled</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">gc</span> <span class=\"o\">:</span> <span class=\"n\">galois_connection</span> <span class=\"n\">l</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">partially_bundled</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">gc</span> <span class=\"o\">:</span> <span class=\"n\">galois_connection</span> <span class=\"n\">l</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Actually, given that <code>closure_operator</code> and <code>galois_connection</code> take in the same infos and that <code>galois_connection</code> isn't really used apart from instances, wouldn't there be a way to unify them under a single structure that would both have a <code>coe_to_fun</code> and be useful as an instance on its own?</p>",
        "id": 238174485,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620665298
    },
    {
        "content": "<p>Galois connections are used in lots of places in mathlib.</p>",
        "id": 238175157,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620665575
    },
    {
        "content": "<p>But are they used in a way that's incompatible with giving them dot notation?</p>",
        "id": 238175561,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620665742
    },
    {
        "content": "<p>My concrete proposal (<a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/monotone.20coercion\">from the other thread</a>) would be to use <code>partially_bundled</code> galois insertions (connections), because I foresee a major use case will be for subobjects, where the <code>u</code> is instantiated to be <code>coe : subfoo α → set α</code>.</p>",
        "id": 238206093,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620678335
    },
    {
        "content": "<p>Let me write out a bit of code...</p>",
        "id": 238206110,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620678347
    },
    {
        "content": "<p>This is how I would rewrite lines 540-563 of <code>group_theory/subgroup.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.subgroup</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">lower_adjoint</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">gi'</span> <span class=\"o\">:</span> <span class=\"n\">galois_insertion</span> <span class=\"n\">to_fun</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">lower_adjoint</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">lower_adjoint</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">lower_adjoint</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">to_fun</span> <span class=\"o\">}</span>\n\n<span class=\"n\">initialize_simps_projections</span> <span class=\"n\">lower_adjoint</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"bp\">→</span> <span class=\"n\">apply</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">gi</span> <span class=\"o\">:</span> <span class=\"n\">galois_insertion</span> <span class=\"n\">l</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">l.gi'</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">lower_adjoint</span>\n\n<span class=\"kd\">@[simps?]</span> <span class=\"kd\">def</span> <span class=\"n\">subgroup.closure'</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">lower_adjoint</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">subgroup.closure</span><span class=\"o\">,</span>\n  <span class=\"n\">gi'</span> <span class=\"o\">:=</span> <span class=\"n\">subgroup.gi</span> <span class=\"n\">G</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Lemmas for `lower_adjoint (coe : α → set β)`, where `set_like α β`</span>\n<span class=\"kn\">section</span> <span class=\"n\">coe_to_set</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">lower_adjoint</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">set_like</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"o\">:</span> <span class=\"n\">lower_adjoint</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subset</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">closure.gi.gc.le_u</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">le_iff</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">S</span> <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"n\">closure.gi.gc</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_iff</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">set_like.mem_coe</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">set.singleton_subset_iff</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">closure.le_iff</span><span class=\"o\">],</span>\n     <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">le_trans</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">closure_eq_of_le</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">closure</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">closure.le_iff.2</span> <span class=\"n\">h₁</span><span class=\"o\">)</span> <span class=\"n\">h₂</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">lower_adjoint</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">coe_to_set</span>\n</code></pre></div>",
        "id": 238208154,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620679152
    },
    {
        "content": "<p>(Definitely not going to stick to these names, but the overall structure seems viable to me.)</p>",
        "id": 238208302,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620679225
    },
    {
        "content": "<p>Are those the only four lemma that can be generalized in this way, or are there more and you just picked them as examples?</p>",
        "id": 238212219,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620680857
    },
    {
        "content": "<p>There are definitely more, these were just the first ones I did before I got bored.</p>",
        "id": 238216532,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620682860
    },
    {
        "content": "<p>E.g. from <code>submodule.span</code> we'd also get (untested, just copied and renamed)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mono</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">closure</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"n\">closure.le_iff.2</span> <span class=\"bp\">$</span> <span class=\"n\">subset.trans</span> <span class=\"n\">h</span> <span class=\"n\">closure.subset</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">apply_self</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"n\">closure.eq_of_le</span> <span class=\"n\">closure.subset</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 238216958,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620683109
    },
    {
        "content": "<p>And then there's the other complete lattice operators:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">map_empty</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"bp\">∅</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span>\n<span class=\"n\">closure.gi.gc.l_bot</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">map_univ</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq_top_iff.2</span> <span class=\"bp\">$</span> <span class=\"n\">set_like.le_def.2</span> <span class=\"bp\">$</span> <span class=\"n\">closure.subset</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">map_union</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"bp\">⊔</span> <span class=\"n\">closure</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"n\">closure.gi.gc.l_sup</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">map_Union</span> <span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⨆</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">closure.gc.l_supr</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eq_supr_closure_singleton</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">⨆</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">closure</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">map_Union</span><span class=\"o\">,</span> <span class=\"n\">set.bUnion_of_singleton</span> <span class=\"n\">s</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>etc.</p>",
        "id": 238217459,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620683401
    },
    {
        "content": "<p>So <code>lower_adjoint</code> would act like the closure operator? And you want to feed in a <code>galois_insertion</code> inside it, then take it out?<br>\nLet's see if I can do something with that.</p>",
        "id": 238431888,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620803961
    },
    {
        "content": "<p>Note that a closure operator only requires a <code>galois_connection</code>.</p>",
        "id": 238431897,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620803969
    },
    {
        "content": "<p>Ah sorry, yes. It should probably be <code>galois_connection</code>, I just took the previous code where the <code>closure</code> map was defined in a typeclass and adjusted it, overlooking that difference.</p>",
        "id": 238440192,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620808595
    },
    {
        "content": "<p>I tried making dot notation work but it turns out weird because <code>group</code> is unbundled.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simps]</span> <span class=\"kd\">def</span> <span class=\"n\">group.closure</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hG</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">lower_adjoint</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">Inf</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"bp\">|</span> <span class=\"n\">k</span> <span class=\"bp\">⊆</span> <span class=\"n\">K</span><span class=\"o\">},</span>\n  <span class=\"n\">gc'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"n\">K</span><span class=\"o\">,</span>\n    <span class=\"o\">⟨</span><span class=\"n\">set.subset.trans</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">subgroup.mem_Inf.2</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">K</span> <span class=\"n\">hK</span><span class=\"o\">,</span> <span class=\"n\">hK</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Inf_le</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subset_closure</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">h.closure</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"n\">h.closure.gc.le_u</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 238440294,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620808658
    },
    {
        "content": "<p>Do you think there's any chance we'll need <code>upper_adjoint</code>? If I'm correct this is an interior operator.</p>",
        "id": 238440689,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620808844
    },
    {
        "content": "<p>I kind of find it weird to name a closure operator <code>lower_adjoint</code> but I guess it's more accurate as the actual closure operator is the composition of both adjoints.</p>",
        "id": 238440887,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620808961
    },
    {
        "content": "<p>The name <code>lower_adjoin</code> is definitely something of a placeholder, which I used because I'm more at home with (basic) category theory than order theory.</p>",
        "id": 238441172,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620809154
    },
    {
        "content": "<p>Note that we already have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid.closure\">docs#monoid.closure</a> but it has quite a different type; so I think <code>group.closure</code> is a bad name.</p>",
        "id": 238441487,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620809304
    },
    {
        "content": "<p>I would follow the existing mathlib convention and call it <code>subgroup.closure</code>. Dot notation seems unlikely to work well, especially since there are things like the smallest ideal of <code>R</code> containing <code>s</code> that would become <code>module.span</code> with your convention, and there's no easy way to name the <code>module R R</code> instance.</p>",
        "id": 238441575,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620809355
    },
    {
        "content": "<p>That is, I would rather write <code>ideal.span s</code> (or <code>submodule.span R s</code>) than <code>(@semiring.to_module R).span s</code></p>",
        "id": 238441725,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620809432
    },
    {
        "content": "<p>Yeah, I think so too. But I think there are also cases where dot notation turns out fine.</p>",
        "id": 238441841,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620809512
    },
    {
        "content": "<p>So what's there to be done?</p>",
        "id": 238442031,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620809614
    },
    {
        "content": "<p>I think we can just go through <code>order/closure.lean</code> and see what needs changing.</p>",
        "id": 238442133,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620809654
    },
    {
        "content": "<p>Ah yeah, I wanted to try out the case <code>α = β</code> as I suspect the <code>id</code> will turn out weird.</p>",
        "id": 238442206,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620809702
    },
    {
        "content": "<p>Ugh, yeah it does: <code>(λ (s : set E), ⋂ (t : set E) (hst : s ⊆ t) (ht : convex t), t) s ≤ t ↔ s ≤ id t</code></p>",
        "id": 238442670,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620809971
    },
    {
        "content": "<p>Then maybe we can restrict <code>closure_operator</code> to same-set closure operators and <code>lower_adjoint</code> (or however we end up calling it) to the other cases?</p>",
        "id": 238442780,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620810018
    },
    {
        "content": "<p>Is that <code>id</code> a problem?</p>",
        "id": 238443033,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620810128
    },
    {
        "content": "<p>I don't know, you tell me. But I wouldn't want <code>id</code>s to clutter all expressions involving convex hulls and stuff.</p>",
        "id": 238443111,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620810180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Closure.20operators/near/238442780\">said</a>:</p>\n<blockquote>\n<p>Then maybe we can restrict <code>closure_operator</code> to same-set closure operators and <code>lower_adjoint</code> (or however we end up calling it) to the other cases?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> is that how you saw things (with <code>galois_insertion</code> instead of <code>lower_adjoint</code>) when introducing <code>order/closure.lean</code>?</p>",
        "id": 238443858,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620810564
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113488-general/topic/Closure.20operators/near/238208154\">said</a>:</p>\n<blockquote>\n<p>This is how I would rewrite lines 540-563 of <code>group_theory/subgroup.lean</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.subgroup</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">lower_adjoint</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">gi'</span> <span class=\"o\">:</span> <span class=\"n\">galois_insertion</span> <span class=\"n\">to_fun</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">lower_adjoint</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">lower_adjoint</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">lower_adjoint</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">to_fun</span> <span class=\"o\">}</span>\n\n<span class=\"n\">initialize_simps_projections</span> <span class=\"n\">lower_adjoint</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"bp\">→</span> <span class=\"n\">apply</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">gi</span> <span class=\"o\">:</span> <span class=\"n\">galois_insertion</span> <span class=\"n\">l</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">l.gi'</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">lower_adjoint</span>\n\n<span class=\"kd\">@[simps?]</span> <span class=\"kd\">def</span> <span class=\"n\">subgroup.closure'</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">lower_adjoint</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">subgroup.closure</span><span class=\"o\">,</span>\n  <span class=\"n\">gi'</span> <span class=\"o\">:=</span> <span class=\"n\">subgroup.gi</span> <span class=\"n\">G</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Lemmas for `lower_adjoint (coe : α → set β)`, where `set_like α β`</span>\n<span class=\"kn\">section</span> <span class=\"n\">coe_to_set</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">lower_adjoint</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">set_like</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"o\">:</span> <span class=\"n\">lower_adjoint</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subset</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">closure.gi.gc.le_u</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">le_iff</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">S</span> <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"n\">closure.gi.gc</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_iff</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">set_like.mem_coe</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">set.singleton_subset_iff</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">closure.le_iff</span><span class=\"o\">],</span>\n     <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">le_trans</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eq_of_le</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">closure</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">closure.le_iff.2</span> <span class=\"n\">h₁</span><span class=\"o\">)</span> <span class=\"n\">h₂</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">lower_adjoint</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">coe_to_set</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>What's the point of introducing <code>gi'</code> first versus just putting <code>gi</code> as a field?</p>",
        "id": 238452055,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620815347
    },
    {
        "content": "<p><code>x.gi'</code> is about <code>x.to_fun</code>, <code>x.gi</code> is about <code>⇑x</code></p>",
        "id": 238452413,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620815557
    },
    {
        "content": "<p>It's like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.map_add\">docs#add_monoid_hom.map_add</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.map_add'\">docs#add_monoid_hom.map_add'</a></p>",
        "id": 238452433,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620815572
    },
    {
        "content": "<p>Aaah, I see :)</p>",
        "id": 238452743,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620815728
    },
    {
        "content": "<p>The original reason I wanted closure operators wasn't to make algebraic structures easier, but to be able to talk about results for general closure operators. So as long as there's a type for closure operators on a type, I'm happy</p>",
        "id": 238455528,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620817475
    },
    {
        "content": "<p>And when you talk about general closure operators, you mean <code>α → α</code>, right?</p>",
        "id": 238455740,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620817614
    },
    {
        "content": "<p>Yup</p>",
        "id": 238455827,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620817657
    },
    {
        "content": "<p>Uh, I'm confused. This is wrong</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">closure_operator.lower_adjoint</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">closure_operator</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lower_adjoint</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">c.to_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">gc'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 238456672,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620818135
    },
    {
        "content": "<p><code>lower_adjoint id</code> seems to rather correspond to an interior operator, but <code>lower_adjoint</code> does give closure operators. I'm confused.</p>",
        "id": 238456893,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620818250
    },
    {
        "content": "<p>Maybe for that we need an antitone Galois connection? That's weird.</p>",
        "id": 238457554,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620818633
    },
    {
        "content": "<p>I think I just tangled myself up and it actually works.</p>",
        "id": 238462052,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620821014
    },
    {
        "content": "<p>So here's how it looks</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">G</span>\n<span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">subgroup.closure'</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is it too coercion-frightening?</p>",
        "id": 238479876,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620828635
    },
    {
        "content": "<p>So Bhavik and I have been thinking about creating a constructor from a <code>complete_lattice</code>structure on `` and here's how it goes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Constructor from a `complete_lattice`. It is a commonplace construction with</span>\n<span class=\"sd\">`u := (coe : β → α)` -/</span>\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">def</span> <span class=\"n\">complete_lattice.closure</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">monotone</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">Inf</span> <span class=\"bp\">...</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">lub</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">...</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">lower_adjoint</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">Inf</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"bp\">|</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">u</span> <span class=\"n\">K</span><span class=\"o\">},</span>\n  <span class=\"n\">gc'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"n\">K</span><span class=\"o\">,</span>\n  <span class=\"o\">⟨</span><span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Inf_le</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 238518992,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620842957
    },
    {
        "content": "<p>It seems that it's hard to get back <code>galois_connection</code> from <code>complete_lattice</code>. And I say \"get back\" because most of the <code>complete_lattice</code> instances we're concerned about use at one point or another the <code>galois_connection</code> in disguise.</p>",
        "id": 238521244,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620843924
    },
    {
        "content": "<p>So I think the way to do would be basic stuff -&gt; <code>lower_adjoint</code> (sorry, <span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span>  this is slowly settling as the name <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span>) -&gt; lemmas about the closure -&gt; <code>complete_lattice</code> -&gt; more stuff</p>",
        "id": 238523322,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620844661
    },
    {
        "content": "<p>Here's where stuff happens: <a href=\"https://github.com/leanprover-community/mathlib/tree/yael/lower_adjoint\">https://github.com/leanprover-community/mathlib/tree/yael/lower_adjoint</a></p>",
        "id": 238533438,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620848968
    },
    {
        "content": "<p>Would it make sense to define <code>upper_adjoint</code> in a similar fashion?</p>",
        "id": 238548511,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620855444
    },
    {
        "content": "<p>Also, <code>order.semiconj_Sup</code> now ought to disappear, as what's in there just got heavily generalised.</p>",
        "id": 238548672,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1620855521
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7608\">#7608</a></p>",
        "id": 238927050,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1621114501
    }
]
[
    {
        "content": "<p>I am currently derailing the \"Hahn-Banach\" topic thread on differential geometry by talking about a field (in the maths sense) which is isomorphic to the complex numbers but not canonically. I've realised that in some sense I don't know how to formalise such an object and I think it boils down to a purely type-theoretic question which I can ask here.</p>\n<p>First the maths background. The real numbers turn out to be completely characterised by a list of axioms: they are the unique complete totally ordered archimedean field, up to unique isomorphism. The complex numbers however has this non-identity automorphism, namely complex conjugation, sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>+</mo><mi>i</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x+iy</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>−</mo><mi>i</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x-iy</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>. This automorphism commutes with all the algebraic structure (<code>one</code>, <code>mul</code> etc) and all the topological structure too. The complex numbers have two square roots of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>, namely (using Lean's terminology) <code>I</code> and <code>-I</code>. These square roots \"have names\".</p>\n<p>I sometimes work with an \"abstract\" algebraic closure of the real numbers however. This is a field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> equipped with a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo>→</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}\\to k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>,  such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> is isomorphic to the complex numbers, but there are two isomorphisms. The polynomial <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x^2+1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> has two roots in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>; if you choose a root of this polynomial then you get an isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi><mo>→</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}\\to k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> sending <code>I</code> to this root.</p>\n<p>But in my mental model of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>, the two square roots are \"completely indistinguishable\". In the past I have constructed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> in the following way. Take a diagram category with two un-named objects and one isomorphism between these objects. Now take a functor from this category into the category of fields, sending both unnamed objects to the complexes, and sending the isomorphism to complex conjugation. Now take the (or a) limit of this diagram. It's a field, isomorphic to both of the copies of the complexes, but \"with no preferred isomorphism\". Except that when I mentioned this to Scott, he pointed out that when making the diagram category you probably named the two objects, so you can just choose the object whose name is the first in the alphabet and hence get a \"lexicographically first\" isomorphism, and argue that it is \"preferred\". </p>\n<p>Is there any way of making the object I want? This has nothing to do with the complex numbers. I am asking for a type which has two terms, and whilst the terms are definitely distinct, it is \"impossible\" to choose one? I'm sorry that this is such a vague question. I am not even sure what I entirely mean here. I am just looking for a way of formalising my mental model -- I literally want to make it impossible to \"choose a term of type X\" without assuming some form of choice principle -- I want them to be as anonymous as possible. Can anyone make sense of what I'm saying?</p>",
        "id": 204292958,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595064105
    },
    {
        "content": "<p>Aren't you constructing your field by taking C[x]/(x^2+1)C[x] ?</p>\n<p>Where is the choice of what is i, and what is -i, entering the picture there (as long as you are not fixing the embedding of your field into a copy of C) ?</p>\n<p>Is Scott's objection merely staying that an order can be assumed?</p>",
        "id": 204294099,
        "sender_full_name": "Dima Pasechnik",
        "timestamp": 1595066282
    },
    {
        "content": "<p>When writing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}[X]/(X^2+1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, there is definitely a preferred root of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">X^2+1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>, the image of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> in the quotient.</p>",
        "id": 204294206,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1595066511
    },
    {
        "content": "<p>And I think Kevin is asking a question in psychology that has neither math content nor type theory content.</p>",
        "id": 204294248,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1595066540
    },
    {
        "content": "<p>There are certainly variations on this question that make sense, talking about stuff commuting with automorphisms or functorial constructions.</p>",
        "id": 204294261,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1595066620
    },
    {
        "content": "<p>I think Patrick is right here -- we're entering philosophical territory about the possibility of forgetting something you once knew. (Easy to demonstrate in practice, of course!)</p>",
        "id": 204294264,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595066632
    },
    {
        "content": "<p>I think you shouldn't be upset at all by my objection.</p>",
        "id": 204294304,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595066664
    },
    {
        "content": "<p>It's just fine to forget the identity of the two objects that you used as crutches in building the limit diagram.</p>",
        "id": 204294308,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595066697
    },
    {
        "content": "<p>(That is, my objection was in jest.)</p>",
        "id": 204294319,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595066722
    },
    {
        "content": "<p>Oh OK -- I'm happy to accept that my question is psychological. It's definitely how my mental model works though.</p>",
        "id": 204295696,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595069551
    },
    {
        "content": "<p>(Patrick and Dima -- your C's should be R's but I know what you mean)</p>",
        "id": 204295704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595069591
    },
    {
        "content": "<p>Is there even a way to tell that the <code>I</code> in mathlib is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> rather than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">-i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord mathdefault\">i</span></span></span></span>?</p>",
        "id": 204296137,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1595070336
    },
    {
        "content": "<p>It is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span></span></span></span> by definition. It's not a meaningful question.</p>",
        "id": 204296180,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1595070377
    },
    {
        "content": "<p>What is the purpose of forgetting which root is preferred? Is it more or less a psychological trick to make sure that my definitions are about rings or whatever, and not rings with a constant so I can transfer proofs of them across ring isomorphisms and not just ring isomorphisms that the preserve the constant. This is more or less it, right? But that's not really necessary in a theorem prover since it's impossible to make mistakes anyway.</p>",
        "id": 204296257,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1595070576
    },
    {
        "content": "<p>One time when I used it was when I made a conceptual definition in the Langlands program, by choosing an isomorphism of R-bar with C, and then I checked that my definition was independent of the choice, which gave me evidence that the definition was the one I was looking for.</p>",
        "id": 204296562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595071087
    },
    {
        "content": "<p>What about the type of all degree 2 extensions of R?</p>",
        "id": 204298403,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595074587
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements/near/204298403\">said</a>:</p>\n<blockquote>\n<p>What about the type of all degree 2 extensions of R?</p>\n</blockquote>\n<p>As far as I understand, this is the <em>type</em> of the object Kevin is asking for. The question is how to construct a generic term of this type. I'm not so sure this is the right question -- I think instead you want to prove things for arbitrary terms of the type. But if you want a generic term, you can take the one given by <code>classical.choice</code> -- it has no preferred isomorphism with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>.</p>\n<p>FWIW, this type is (morally) equivalent to \"the type of two-element types\" -- map a field to the type of square roots of -1. So the question could be stated more elementarily as \"how to construct a generic two-element type\".</p>",
        "id": 204299653,
        "sender_full_name": "David Wärn",
        "timestamp": 1595077070
    },
    {
        "content": "<p>Not sure if this is a good solution, but: If you state and prove, as a <code>Prop</code>, that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> has an algebraic closure, then use <code>classical.some</code> to obtain one such closure, I believe the two roots of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span> will be indistinguishable.</p>",
        "id": 204300359,
        "sender_full_name": "Sebastian Reichelt",
        "timestamp": 1595078343
    },
    {
        "content": "<p>Yes, I believe this works -- this is what I meant by \"take the one given by <code>classical.choice</code>\"</p>",
        "id": 204300741,
        "sender_full_name": "David Wärn",
        "timestamp": 1595079021
    },
    {
        "content": "<p>Aren't Lean 4 constants meant to also do something like this?</p>",
        "id": 204300746,
        "sender_full_name": "David Wärn",
        "timestamp": 1595079035
    },
    {
        "content": "<p>Probably this is only useful if you can internalise some metatheorems like \"any subset of R-bar which can be defined without using choice is stable under conjugation\"</p>",
        "id": 204300862,
        "sender_full_name": "David Wärn",
        "timestamp": 1595079289
    },
    {
        "content": "<p>This is just about Galois theory. The <em>category</em> of algebraic closures of R has many objects, but it's equivalent to a category with a single object whose automorphism group is Z/2. But this is just an equivalence of categories. I guess from the point of view of HoTT, the type of algebraic closures of a field is homotopy equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">BG</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathdefault\">G</span></span></span></span> where G is the absolute Galois group.</p>",
        "id": 204302095,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595081591
    },
    {
        "content": "<p>But of course the homotopy point of view doesn't mean anything in lean</p>",
        "id": 204302164,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595081671
    },
    {
        "content": "<p>In Lean, there will always be a distinguished root of <code>-1</code>, the one that is given by the <code>choice</code> function applied to the predicate \"there exists <code>x</code> such that <code>x ^ 2 = -1</code>\"!</p>",
        "id": 204303009,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1595083243
    },
    {
        "content": "<p>Agreed, but I think this is an instance where it is natural to think of that predicate having two distinct proofs :)</p>",
        "id": 204303176,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595083558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements/near/204303009\">said</a>:</p>\n<blockquote>\n<p>In Lean, there will always be a distinguished root of <code>-1</code>, the one that is given by the <code>choice</code> function applied to the predicate \"there exists <code>x</code> such that <code>x ^ 2 = -1</code>\"!</p>\n</blockquote>\n<p>OK I give in :-) What I want can't be done in Lean.</p>",
        "id": 204306764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595089254
    },
    {
        "content": "<p>It can certainly be done in type theory, you just need a few axioms to allow the construction of types with stated isomorphisms</p>",
        "id": 204308961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595092410
    },
    {
        "content": "<p>This sounds much like \"nominal sets\"</p>",
        "id": 204308971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595092427
    },
    {
        "content": "<p>It might not be possible in lean without choice (it's obviously not possible in lean with choice), but I feel like you can do something with quotient types here</p>",
        "id": 204309031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595092487
    },
    {
        "content": "<p>I want a proof that the type has two terms but I want it to be very hard to create a term of that type without using choice</p>",
        "id": 204309111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595092581
    },
    {
        "content": "<p>hm, when you put it that way it does sound rather unlikely; in lean without choice there aren't many ways to prove the existence of terms that doesn't produce an actual term</p>",
        "id": 204309131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595092647
    },
    {
        "content": "<p>To reiterate, though, the easy solution is to say</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">constant</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kn\">axiom</span> <span class=\"n\">T_not_subsing</span> <span class=\"o\">:</span> <span class=\"err\">\\</span><span class=\"n\">exists</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">!=</span> <span class=\"n\">b</span>\n</code></pre></div>\n\n\n<p>You might argue that I cheated by adding a new axiom, but this is exactly as respectable as the construction of quotient types (which is also a family of axioms), and it's obviously consistent. It just needs to be cleaned up a bit to give it an air of respectability as an axiom</p>",
        "id": 204309412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1595093099
    },
    {
        "content": "<p>Maybe I'm missing the point, but doesn't this yield a generic two-element type?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory</span><span class=\"bp\">.</span><span class=\"n\">cardinal</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">two_element_type_exists</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">cardinal</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n  <span class=\"n\">use</span> <span class=\"n\">bool</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">two_element_type</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">two_element_type_exists</span>\n</code></pre></div>",
        "id": 204312058,
        "sender_full_name": "Sebastian Reichelt",
        "timestamp": 1595096814
    },
    {
        "content": "<p>Why not just use <code>variable</code>?</p>",
        "id": 204312409,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595097347
    },
    {
        "content": "<p>At risk of making a philosophical statement, what's wrong with \"pretending that lexicographical order doesn't exist\"? At a low enough, all computer memory is ordered bits and bytes, so there is always some implicit order, even when we write an \"unordered set\"  or \"hash table\" data structure, for example. Writing such a structure is (more or less) shielding the user from knowledge of the implicit order. So why not just use the same ordered type with two elements, but pinky-promise not to ever use the first lexicographical element? Or even better, write a layer of abstraction that prevents the user from doing this?</p>",
        "id": 204313975,
        "sender_full_name": "Jack J Garzella",
        "timestamp": 1595099945
    },
    {
        "content": "<p>In addition, I'd like to point that this question isn't as esoteric as it first looks: there are many reasons why one might want to think of a number field like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"false\">(</mo><msqrt><mn>2</mn></msqrt><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q} (\\sqrt{2})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1572200000000001em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"mopen\">(</span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.90722em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.86722em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg height=\"1.08em\" preserveAspectRatio=\"xMinYMin slice\" viewBox=\"0 0 400000 1080\" width=\"400em\"><path d=\"M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.13278em;\"><span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> as an abstract field with two indistinguishable real embeddings rather than a subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> with a fixed embedding.</p>",
        "id": 204314055,
        "sender_full_name": "Jack J Garzella",
        "timestamp": 1595100089
    },
    {
        "content": "<p>Yes this is all coming from infinite places of number fields and local-global compatibility in the Langlands program.</p>",
        "id": 204315796,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595103071
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198266\">@Sebastian Reichelt</span>, this is an embarrassing demonstration of how I don't know how to work with the <code>cardinal</code> API, but this sort of trick is no obstacle to the power of <code>classical.some</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory</span><span class=\"bp\">.</span><span class=\"n\">cardinal</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">fin_cases</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">cardinal</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">two_element_type_exists</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">mk</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n  <span class=\"n\">use</span> <span class=\"n\">bool</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">two_element_type</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">two_element_type_exists</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">mk</span> <span class=\"n\">two_element_type</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"n\">two_element_type_exists</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">two_element_type</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">nz</span> <span class=\"o\">:</span> <span class=\"n\">mk</span> <span class=\"n\">two_element_type</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">ne_of_gt</span><span class=\"o\">,</span>\n    <span class=\"n\">transitivity</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">cardinal</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">not_le</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n      <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">cardinal</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">mk_fin</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n      <span class=\"n\">conv</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"o\">{</span> <span class=\"n\">to_rhs</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n      <span class=\"n\">rw</span> <span class=\"n\">two_le_iff</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n      <span class=\"n\">fin_cases</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">fin_cases</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">simpa</span> <span class=\"kn\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">zero_lt_one</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">ne</span> <span class=\"o\">:=</span> <span class=\"n\">ne_zero_iff_nonempty</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">nz</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">),</span>\n  <span class=\"n\">cases</span> <span class=\"n\">ne</span> <span class=\"k\">with</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 204326767,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595122968
    },
    {
        "content": "<p>Surely this informal notion of \"choice-free construction on R-bar\" translates to \"hygienic construction on an arbitrary alg closure of R\", where hygienic means \"functorial in isomorphisms\", and arbitrary means \"takes any alg closure as input\" (i.e. use variable instead of axiom)</p>\n<p>What <code>classical.some</code> shows is that hygiene is non-vacuous in Lean -- it is possible to write down non-hygienic constructions</p>",
        "id": 204337294,
        "sender_full_name": "David Wärn",
        "timestamp": 1595143727
    },
    {
        "content": "<p>You should checkout my <code>iso_transport</code> branch, which is a total mess, but tries formalise <code>hygienic</code> and provide some associated tactics.</p>",
        "id": 204337610,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595144442
    },
    {
        "content": "<p>The problem with algebraic closures is that they are <em>not</em> functorial! They are unique up to non-unique isomorphism. If K-&gt;L is a morphism of fields then you don't get a natural Kbar-&gt;Lbar. Pedantic mathematicians write \"Let Kbar be an algebraic closure of K\". It is exactly like turning a nonempty space into a pointed space. You can choose a point in each space, but then don't expect all morphisms of spaces to turn into morphisms of pointed spaces.</p>",
        "id": 204341128,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595151174
    },
    {
        "content": "<p>That's what makes this interesting :-)<br>\nThe category (indeed groupoid) of algebraic closures of R is non-trivial -- we are interested in functors from it</p>",
        "id": 204344680,
        "sender_full_name": "David Wärn",
        "timestamp": 1595157455
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I had no doubt that you could pick an arbitrary element of <code>two_element_type</code> using <code>classical.some</code>. But <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/type.20with.20two.20indistinguishable.20elements/near/204292958\">said</a>:</p>\n<blockquote>\n<p>I literally want to make it impossible to \"choose a term of type X\" without assuming some form of choice principle.</p>\n</blockquote>\n<p>I would argue that everything that can be constructed from or proved about <code>two_element_type</code> must follow from the fact that it has two elements, i.e. nothing else is \"known\" about that type.</p>",
        "id": 204346808,
        "sender_full_name": "Sebastian Reichelt",
        "timestamp": 1595161052
    }
]
[
    {
        "content": "<p>I am trying to encode this closed type family encoded in Haskell in Lean 4. I think it can be done via Inductive Type families but since I am absolutely novice in these advanced type system encodings, not able to figure out. Any help would be appreciated. Thanks</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">family</span> <span class=\"n\">ElementOf</span> <span class=\"n\">a</span> <span class=\"n\">where</span>\n  <span class=\"n\">ElementOf</span> <span class=\"o\">[[</span><span class=\"n\">a</span><span class=\"o\">]]</span> <span class=\"bp\">=</span> <span class=\"n\">ElementOf</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n  <span class=\"n\">ElementOf</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>   <span class=\"bp\">=</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 247723783,
        "sender_full_name": "Kaushik Chakraborty",
        "timestamp": 1627659208
    },
    {
        "content": "<p>Type families like this cannot directly be represented in lean, because type constructors are not necessarily injective. But you can do something similar with typeclasses</p>",
        "id": 247724162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627659401
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ElementOf</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">El</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">α</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">ElementOf</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">ElementOf.El</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf.El</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf.El</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf.El</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 247724602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627659639
    },
    {
        "content": "<p>thanks. so when in Haskell it is said that type family is kind of a function from types to types and type classes are function from types to terms, in Lean type classes can do both right.</p>",
        "id": 247737125,
        "sender_full_name": "Kaushik Chakraborty",
        "timestamp": 1627665535
    },
    {
        "content": "<p>yeah, because in dependent type theory, types are terms</p>",
        "id": 247739194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627666681
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  One limitation though is that you can't pattern match on types in Lean, though, right? Whereas that is what closed type families essentially do in Haskell. </p>\n<p>That is, the closest approximation in Lean of a closed type family would be  something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ElementOf</span><span class=\"bp\">!.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ElementOf</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">panic</span><span class=\"bp\">!</span> <span class=\"s2\">\"invalid type\"</span>\n</code></pre></div>\n<p>But this doesn't work because you can't pattern match on types in Lean.</p>",
        "id": 247741124,
        "sender_full_name": "Mac",
        "timestamp": 1627667659
    },
    {
        "content": "<p>What does that pattern match look like in haskell? This is a bit semantically weird so I don't know exactly how it's handled</p>",
        "id": 247741463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627667815
    },
    {
        "content": "<p>If you want to define a function out of a type family, you can add it as a field in the typeclass above</p>",
        "id": 247741633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627667888
    },
    {
        "content": "<p>The difference is that a type class is open whereas a closed type family is, well, closed.</p>",
        "id": 247741693,
        "sender_full_name": "Mac",
        "timestamp": 1627667920
    },
    {
        "content": "<p>It is possible to define an inductive type family that only holds at certain types, but it's not actually as useful as you would think</p>",
        "id": 247741802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627667969
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247741463\">said</a>:</p>\n<blockquote>\n<p>What does that pattern match look like in haskell?</p>\n</blockquote>\n<p>That pattern match is what the closed type family example <span class=\"user-mention\" data-user-id=\"118349\">@Kaushik Chakraborty</span> gave does.</p>",
        "id": 247741818,
        "sender_full_name": "Mac",
        "timestamp": 1627667974
    },
    {
        "content": "<p>okay but I already gave an approximate equivalent for that code snippet. I'm hoping for something that shows what aspect of the haskell version is missing from the lean version</p>",
        "id": 247742051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627668054
    },
    {
        "content": "<p>yes it's open. Why does that matter?</p>",
        "id": 247742091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627668065
    },
    {
        "content": "<p>that <code>panic!</code> in your version also looks bad. Is that what the haskell version does too?</p>",
        "id": 247742293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627668150
    },
    {
        "content": "<p>I don't think it makes sense for the haskell code to have a <code>panic!</code> in a type</p>",
        "id": 247742404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627668215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247742293\">said</a>:</p>\n<blockquote>\n<p>that <code>panic!</code> in your version also looks bad. Is that what the haskell version does too?</p>\n</blockquote>\n<p>I added the <code>panic!</code> match since the original example is missing a catch-all alternative )which iirc would be required in Haskell).</p>",
        "id": 247742414,
        "sender_full_name": "Mac",
        "timestamp": 1627668222
    },
    {
        "content": "<p>Are you sure? I think it is just a partial function, like a typeclass</p>",
        "id": 247742485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627668252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247742404\">said</a>:</p>\n<blockquote>\n<p>I don't think it makes sense for the haskell code to have a <code>panic!</code> in a type</p>\n</blockquote>\n<p>No, actually, Haskell does support panicing in types. It is called a <a href=\"https://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:TypeError\">TypeError</a>.</p>",
        "id": 247742518,
        "sender_full_name": "Mac",
        "timestamp": 1627668279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247742485\">said</a>:</p>\n<blockquote>\n<p>Are you sure? I think it is just a partial function, like a typeclass</p>\n</blockquote>\n<p>No it is not. Closed type families are complete. That is the entire point of them in Haskell. :P <br>\nHowever, You can cheat this with the <code>TypeError</code> I just mention much like in Lean you could with <code>panic!</code>.</p>",
        "id": 247742638,
        "sender_full_name": "Mac",
        "timestamp": 1627668361
    },
    {
        "content": "<p>Also, for reference, here is the GHC User Guide section on <a href=\"https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/type_families.html#closed-type-families\">closed type families</a>.</p>",
        "id": 247742854,
        "sender_full_name": "Mac",
        "timestamp": 1627668479
    },
    {
        "content": "<p>unfortunately that section doesn't say anything about what you can do with closed type families, it just describes the declaration, which seems pretty well handled by those <code>instance</code>s in the lean version</p>",
        "id": 247743732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627668954
    },
    {
        "content": "<p>My argument was not that  the Lean analogue of closed type families would be necessary useful, just simply that a type class with instances is not it. <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span> Also, your example could be translate d back into Haskell using associated (open) type families (which attach a type to a  type class just like you did).</p>",
        "id": 247744440,
        "sender_full_name": "Mac",
        "timestamp": 1627669308
    },
    {
        "content": "<p>Such an example would look something like this in Haskell:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"cm\">{-# LANGUAGE TypeFamilies, FlexibleInstances #-}</span>\n\n<span class=\"kr\">class</span> <span class=\"kt\">ElementOf</span> <span class=\"n\">a</span> <span class=\"kr\">where</span>\n  <span class=\"kr\">type</span> <span class=\"kt\">El</span> <span class=\"n\">a</span>\n\n<span class=\"kr\">instance</span> <span class=\"cm\">{-# OVERLAPPABLE #-}</span> <span class=\"kt\">ElementOf</span> <span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span> <span class=\"kr\">where</span>\n  <span class=\"kr\">type</span> <span class=\"kt\">El</span> <span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span> <span class=\"ow\">=</span> <span class=\"n\">a</span>\n\n<span class=\"kr\">instance</span> <span class=\"cm\">{-# OVERLAPPING #-}</span> <span class=\"kt\">ElementOf</span> <span class=\"p\">[[</span><span class=\"n\">a</span><span class=\"p\">]]</span> <span class=\"kr\">where</span>\n  <span class=\"kr\">type</span> <span class=\"kt\">El</span> <span class=\"p\">[[</span><span class=\"n\">a</span><span class=\"p\">]]</span> <span class=\"ow\">=</span> <span class=\"kt\">El</span> <span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span>\n</code></pre></div>",
        "id": 247744610,
        "sender_full_name": "Mac",
        "timestamp": 1627669378
    },
    {
        "content": "<p>Having now tested my example on GHC 8.6, it doesn't compile because Haskell doesn't support overlapping open type family alternatives. This made me remember that one of the key uses of closed type families in Haskell is to deal with such cases. As Lean is much more okay with overlap, at least that concern does not exist.</p>",
        "id": 247746549,
        "sender_full_name": "Mac",
        "timestamp": 1627670445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247724602\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ElementOf</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">El</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">α</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">ElementOf</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">ElementOf.El</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf.El</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf.El</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf.El</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>In this exemple, there would be two diferent instances of <code>ElementOf (list (list nat))</code>, right ? One with <code>nat</code> and one with <code>list nat</code> ?</p>",
        "id": 247756588,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1627676275
    },
    {
        "content": "<p>Yes. The order of the two instances is significant; you can also get the same effect by marking the first instance as <code>(priority := low)</code></p>",
        "id": 247757895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627677014
    },
    {
        "content": "<p>That is, we are relying on typeclass inference to always apply the second instance when possible</p>",
        "id": 247757942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627677049
    },
    {
        "content": "<p>Here's an attempt at something like a closed type family (in Lean 3), using <code>has_coe_to_sort</code> as a small convenience.  It requires that you say how a type is constructed, in the form of a term of <code>ElementOf.dom</code>.  I implemented a generic <code>flatten</code> with it as a small test.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ElementOf.dom</span>\n<span class=\"bp\">|</span> <span class=\"n\">incl</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf.dom</span>\n<span class=\"bp\">|</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf.dom</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf.dom</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ElementOf</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dom.to_sort</span> <span class=\"o\">:</span> <span class=\"n\">dom</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">dom.incl</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">dom.list</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">dom.to_sort</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"n\">ElementOf.dom</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ElementOf.dom.to_sort</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dom.apply</span> <span class=\"o\">:</span> <span class=\"n\">dom</span> <span class=\"bp\">→</span> <span class=\"n\">dom</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">dom.incl</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">dom.incl</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">dom.list</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">dom.apply</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">ElementOf</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">flatten</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ElementOf.dom</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">list</span> <span class=\"n\">α.apply</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ElementOf.dom.incl</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ElementOf.dom.list</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">list.bind</span> <span class=\"n\">x</span> <span class=\"n\">flatten</span>\n</code></pre></div>",
        "id": 247772778,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627687274
    },
    {
        "content": "<p>I don't have much experience with them, but maybe this is a place where unification hints can be used to automatically generate the <code>ElementOf.dom</code> term.</p>",
        "id": 247773362,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627687964
    },
    {
        "content": "<p>My memory was that unification hints were entirely broken in lean3 for anything using universe variables, and only really worked for <code>Type</code> not <code>Type*</code></p>",
        "id": 247773711,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627688485
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>'s example inspired me and led me to this implementation (in Lean 4):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"kd\">inductive</span> <span class=\"n\">Elem.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">flat</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">List</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tail</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">γ</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Elem.flat</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">Elem.list</span> <span class=\"n\">α</span> <span class=\"n\">rfl</span> <span class=\"n\">e</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">ElemOf.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">β</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">ElemOf</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">))</span> <span class=\"c1\">-- Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">flattenAux</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"n\">Elem.flat</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">cast</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">Elem.list</span> <span class=\"n\">γ</span> <span class=\"n\">h</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List.bind</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">flattenAux</span> <span class=\"n\">x</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">flatten</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">flattenAux</span> <span class=\"n\">a</span> <span class=\"n\">e</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">flatten</span> <span class=\"o\">[[</span><span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]]</span> <span class=\"c1\">-- [0, 1]</span>\n</code></pre></div>",
        "id": 247813874,
        "sender_full_name": "Mac",
        "timestamp": 1627750164
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> Nice idea with the <code>class inductive</code>.  You can get rid of the type equalities:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"kd\">inductive</span> <span class=\"n\">Elem</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">incl</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">tail</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Elem.incl</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">Elem.list</span> <span class=\"n\">e</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">ElemOf</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">β</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">ElemOf</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">))</span> <span class=\"c1\">-- Nat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">flattenAux</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"n\">Elem.incl</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">Elem.list</span> <span class=\"n\">tail</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List.bind</span> <span class=\"n\">a</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">flattenAux</span> <span class=\"n\">tail</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">flatten</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"n\">flattenAux</span> <span class=\"n\">e</span> <span class=\"n\">a</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">flatten</span> <span class=\"o\">[[</span><span class=\"mi\">0</span><span class=\"o\">]]</span> <span class=\"c1\">-- [0]</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">flatten</span> <span class=\"o\">[[[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]]]</span> <span class=\"c1\">-- [1, 2]</span>\n</code></pre></div>",
        "id": 247814341,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627750819
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I personally like including the type equalities because it makes it so you don't have to rely on the sometimes finicky nature of <code>match</code> generalizing</p>",
        "id": 247814451,
        "sender_full_name": "Mac",
        "timestamp": 1627751011
    },
    {
        "content": "<p>I'd rather make sure <code>match</code> generalizes properly than to deal with <code>cast</code>, but I suppose it's a matter of taste.</p>",
        "id": 247814596,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627751194
    },
    {
        "content": "<p>I guess as a person who does a decent amount of systems programming, casting between types is a very natural operation for me. In fact, implicit casts kind of bothers me.</p>",
        "id": 247817689,
        "sender_full_name": "Mac",
        "timestamp": 1627755573
    },
    {
        "content": "<p>That is, I would intuitively expect the <code>a</code> in the match to have the same type as the <code>a</code> outside it. The generalizing nature of <code>match</code> is often very counter-intuitive for me.</p>",
        "id": 247817795,
        "sender_full_name": "Mac",
        "timestamp": 1627755720
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315577\">@Mac</span> The <code>cast</code> function tends to be annoying to deal with when you have to prove anything about your definitions, since you've put yourself on the road toward heterogeneous equalities, or worse, trying to prove that two types are not equal (which is impossible most of the time).</p>\n<p>If it makes you feel any better, in this case the <code>match</code> \"reveals\" what <code>α</code> actually was (and the <code>a : α</code> in the type signature was unnecessary -- I removed it).  It's letting you deconstruct <code>α</code> and then, for example with <code>Elem.list</code>, reinterpret <code>a</code> as having type <code>List α'</code>, since that's the type it actually had.</p>",
        "id": 247818639,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627756915
    },
    {
        "content": "<p>It can be made more explicit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">flattenAux</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">β</span>\n<span class=\"bp\">|</span> <span class=\"n\">Elem.incl</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">Elem.list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"n\">tail</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List.bind</span> <span class=\"n\">a</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">flattenAux</span> <span class=\"n\">tail</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 247818778,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627757092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247818639\">said</a>:</p>\n<blockquote>\n<p>It's letting you deconstruct <code>α</code> and then, for example with <code>Elem.list</code>, <strong>reinterpret</strong> <code>a</code> as having type <code>List α'</code></p>\n</blockquote>\n<p>The 'reintepret' is what I have a problem with. For me, that should always require an explicit cast (it even somewhat annoys me that Lean does this automatically with things like <code>def</code>s). However, I do realize that it is often a necessary part of the Lean.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247818639\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> The <code>cast</code> function tends to be annoying to deal with when you have to prove anything about your definitions, since you've put yourself on the road toward heterogeneous equalities, or worse, trying to prove that two types are not equal (which is impossible most of the time).</p>\n</blockquote>\n<p>My proofing experience has mostly been with logical systems of my own design so I sadly don't have much experience with proving things about practical functions like these. However, I am curious as to what is the problem with heterogenous equalities? Also, are there significant problems with augment inter- or intra- type equalities with  additional axioms (i.e. ones that state terms from two distinct types are equal or that state that two types are not equal)?</p>",
        "id": 247826375,
        "sender_full_name": "Mac",
        "timestamp": 1627769744
    },
    {
        "content": "<p>I know that additional axioms in a mathematical may often be an anathema. But in program verification contexts, I don't imagine it is as much of one.</p>",
        "id": 247826427,
        "sender_full_name": "Mac",
        "timestamp": 1627769828
    },
    {
        "content": "<blockquote>\n<p>ones that state terms from two distinct types are equal</p>\n</blockquote>\n<p>It's not possible to say this in lean in any nontrivial way. Heterogeneous equality <code>HEq a b</code> (or <code>a == b</code> in lean 3) asserts that <code>a</code> and <code>b</code> have the same type and when you cast along that type equality the elements are equal. So terms of distinct types are never <code>HEq</code>.</p>",
        "id": 247870911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627842379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247826375\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247818639\">said</a>:</p>\n<blockquote>\n<p>It's letting you deconstruct <code>α</code> and then, for example with <code>Elem.list</code>, <strong>reinterpret</strong> <code>a</code> as having type <code>List α'</code></p>\n</blockquote>\n<p>The 'reintepret' is what I have a problem with. For me, that should always require an explicit cast (it even somewhat annoys me that Lean does this automatically with things like <code>def</code>s). However, I do realize that it is often a necessary part of the Lean.</p>\n</blockquote>\n<p>There is no cast because we aren't actually talking about a single variable <code>a</code>; in each case there is a different variable with a different type, and the fact they are both called <code>a</code> is only due to our naming sense. This is shadowing at best, there is no actual relation between the <code>a</code> variables inside and outside the match</p>",
        "id": 247871067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627842621
    },
    {
        "content": "<blockquote>\n<p>However, I am curious as to what is the problem with heterogenous equalities?</p>\n</blockquote>\n<p>The main problem with heterogeneous equalities is that they don't accomplish as much as you would expect of equality in an extensional type theory; in particular you can rarely rewrite with them, and it's incredibly difficult to use them at all without carefully chosen motives in the recursor</p>",
        "id": 247871141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627842784
    },
    {
        "content": "<p>The main reason for this is that the lemma <code>f == g -&gt; x == y -&gt; f x == g y</code> does not hold in lean (it's independent)</p>",
        "id": 247871208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627842871
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247826375\">said</a>:</p>\n<blockquote>\n<p>The 'reintepret' is what I have a problem with. For me, that should always require an explicit cast</p>\n</blockquote>\n<p>You can think of a <code>match</code> expression as a way to do an explicit cast, in the sense of a C# <code>is</code> type pattern (for example, <code>if (a is string s) { ... do something with s ... }</code>).  The analogy is somewhat clearer if you write the <code>match</code> explicitly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">flattenAux</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">Elem.incl</span><span class=\"o\">,</span> <span class=\"n\">a'</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">a'</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">Elem.list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"n\">t'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List.bind</span> <span class=\"n\">a'</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">flattenAux</span> <span class=\"n\">t'</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>The second case is something like a made-up <code>if (a is list&lt;α'&gt; a') { ... do something with a' ... }</code>. (Though Lean needs the <code>t</code> to drive this -- I wasn't sure of a good way to render the dependent types in C#!)</p>",
        "id": 247878394,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627853967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247871141\">said</a>:</p>\n<blockquote>\n<p>in an extensional type theory</p>\n</blockquote>\n<p>In proof assistants with an extensional type theory, in practice how do you change the type of a term to something equal? A while back I tried reading some of the NuPRL documentation, since ncatlab says it's extensional, but I couldn't find anything about that.</p>\n<p>(An idle curiosity: are there proof assistants that let you dynamically add reduction rules given proofs of equalities? This would be one way to make equal things defeq.)</p>",
        "id": 247879013,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1627854845
    },
    {
        "content": "<p>Like I mentioned to Steven in the other thread, in Mizar (which uses set theory as the foundation but has a soft type system), there a command to say <code>reconsider x as B [by ...];</code> which amounts to the proof rule <code>|- x : A, |- A &lt;= B  =&gt; |- x : B</code>, where the <code>by</code> is a proof that <code>A</code> is a subset of <code>B</code>, where <code>A</code> is the \"current\" type of <code>x</code> as determined by the typechecker. I believe you can also give the newly type ascribed <code>x</code> a different name so that you can use <code>x</code> at either the old or new type.</p>",
        "id": 247880137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627856712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247871208\">said</a>:</p>\n<blockquote>\n<p>The main reason for this is that the lemma <code>f == g -&gt; x == y -&gt; f x == g y</code> does not hold in lean (it's independent)</p>\n</blockquote>\n<p>If its independent, should you be able to safely do <code>axiom heq_trans : f == g -&gt; x == y -&gt; f x == g y</code> if needed?</p>",
        "id": 248184405,
        "sender_full_name": "Mac",
        "timestamp": 1627969773
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247870911\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>ones that state terms from two distinct types are equal</p>\n</blockquote>\n<p>It's not possible to say this in lean in any nontrivial way. Heterogeneous equality <code>HEq a b</code> (or <code>a == b</code> in lean 3) asserts that <code>a</code> and <code>b</code> have the same type and when you cast along that type equality the elements are equal. So terms of distinct types are never <code>HEq</code>.</p>\n</blockquote>\n<p>Is there anything preventing one from defining a new proper truly type heterogenous equality that does have the desired properties (either constructively or with axions)?</p>",
        "id": 248184621,
        "sender_full_name": "Mac",
        "timestamp": 1627970054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247878394\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247826375\">said</a>:</p>\n<blockquote>\n<p>The 'reintepret' is what I have a problem with. For me, that should always require an explicit cast</p>\n</blockquote>\n<p>You can think of a <code>match</code> expression as a way to do an explicit cast, in the sense of a C# <code>is</code> type pattern (for example, <code>if (a is string s) { ... do something with s ... }</code>).  The analogy is somewhat clearer if you write the <code>match</code> explicitly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">flattenAux</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Elem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">Elem.incl</span><span class=\"o\">,</span> <span class=\"n\">a'</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"n\">a'</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">Elem.list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"n\">t'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">List.bind</span> <span class=\"n\">a'</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">flattenAux</span> <span class=\"n\">t'</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>!)</p>\n</blockquote>\n<p>I get what it is doing, I just don't like it. In my view, <code>match</code>'s only effect should be pattern matching -- not type juggling. Thus <code>a</code> and <code>a'</code> should have the same type unless otherwise (explicitly) specified. However, your example does have an explicit cast in the form of the type ascription, so I am much more okay with it than I am with the implicit magic of a normal match.</p>",
        "id": 248185239,
        "sender_full_name": "Mac",
        "timestamp": 1627970883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315577\">Mac</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/248184405\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Haskell's.20closed.20type.20families.20as.20Lean's.20inductive.20family/near/247871208\">said</a>:</p>\n<blockquote>\n<p>The main reason for this is that the lemma <code>f == g -&gt; x == y -&gt; f x == g y</code> does not hold in lean (it's independent)</p>\n</blockquote>\n<p>If its independent, should you be able to safely do <code>axiom heq_trans : f == g -&gt; x == y -&gt; f x == g y</code> if needed?</p>\n</blockquote>\n<p>Well, it is closely related to injectivity of pi (if you only consider the types of the variables in the heqs) which is false in general because of Prop (<code>\\forall x: Nat, true</code> is equal to <code>\\forall x: Unit, true</code> by propositional extensionality)</p>",
        "id": 248246635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628008843
    }
]
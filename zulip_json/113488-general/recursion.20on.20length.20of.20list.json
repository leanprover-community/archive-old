[
    {
        "content": "<p>I searched the chat and found some tips about doing induction on length of list, but the proofs were in tactic mode and I need recursion. Is something like this already in Lean:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">rec_on_length</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">C</span> <span class=\"o\">[]</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">L</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>I can probably make it, assuming I've got it right, but I don't want to re-invent the wheel.</p>",
        "id": 181132949,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1574183550
    },
    {
        "content": "<p>It should just come from nat.rec I guess</p>",
        "id": 181132983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1574183572
    },
    {
        "content": "<p>OK so I tried this and ran into something I wasn't expecting.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">def</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">rec_on_size&#39;</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">L</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span> <span class=\"n\">ih</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"n\">z</span> <span class=\"n\">ih</span> <span class=\"n\">n</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">elab_as_eliminator</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">rec_on_size</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"n\">C</span> <span class=\"o\">[]</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">L</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">z</span> <span class=\"n\">ih</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">rec_on_size&#39;</span> <span class=\"n\">X</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">H</span> <span class=\"n\">hH</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rwa</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length_eq_zero</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hH</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">H</span><span class=\"o\">))</span> <span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">--                                         ^^^^^^^^^^ building term of type C H in tactic mode</span>\n</pre></div>\n\n\n<p>The first function was just practice and it turned out to be exactly <code>nat.rec</code>. But then when I got going I realised that I had a term of type <code>C []</code> and I wanted a term of type <code>Pi (L : list X), L.length = 0 -&gt; C L</code>. I built it using a rewrite. Is this going to bite me later?</p>",
        "id": 181150404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1574194921
    },
    {
        "content": "<p>I think so. It's probably better to define it using case analysis on <code>L</code></p>",
        "id": 181150638,
        "sender_full_name": "Reid Barton",
        "timestamp": 1574195099
    },
    {
        "content": "<p>or actually hmm</p>",
        "id": 181150659,
        "sender_full_name": "Reid Barton",
        "timestamp": 1574195120
    },
    {
        "content": "<p>Maybe you'll be fine</p>",
        "id": 181150664,
        "sender_full_name": "Reid Barton",
        "timestamp": 1574195126
    },
    {
        "content": "<p>I think the main thing that you want is that your term of that type evaluates to the original term if you apply it to <code>[]</code> and a proof that <code>[].length = 0</code> (which is <code>rfl</code> in this case, but that doesn't actually matter). Here you defined it by induction on a proof that the input list <code>L</code> equals <code>[]</code> (which was cooked up somehow from the hypothesis <code>L.length = 0</code>); that proof is definitionally equal to <code>rfl</code> by proof irrelevance so the application of <code>eq.rec</code> will reduce.</p>",
        "id": 181151204,
        "sender_full_name": "Reid Barton",
        "timestamp": 1574195540
    },
    {
        "content": "<p>It did occur to me that <code>list.rec_on_size'</code> might be all I need in practice.</p>",
        "id": 181158175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1574200403
    }
]
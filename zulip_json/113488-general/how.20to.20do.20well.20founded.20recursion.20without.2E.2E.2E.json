[
    {
        "content": "<p>how to do well founded recursion without well founded recursion? this is my attempt so far... not successful...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">something</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">something</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">something</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">less</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">loglike</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">something</span> <span class=\"n\">less</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">value'</span> <span class=\"o\">(</span><span class=\"n\">something.intro</span> <span class=\"n\">value</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">value</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span>\n  <span class=\"o\">(</span><span class=\"n\">loglike</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"n\">less</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">apply</span> <span class=\"n\">lt_of_le_of_ne</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">tauto</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">nat.div_lt_self</span> <span class=\"n\">value</span> <span class=\"mi\">2</span> <span class=\"n\">this</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 244930271,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625488302
    },
    {
        "content": "<p>someone on here said that well-founded recursion is just structural recursion, that's why I'm doing this</p>",
        "id": 244931102,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625488835
    },
    {
        "content": "<p>You can't use the equation compiler for this, because it doesn't support recursion on inductive predicates without well founded recursion, which is what you are trying to avoid. Instead you can just call the recursor directly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">loglike</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">something</span> <span class=\"n\">less</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">something.rec_on</span> <span class=\"n\">h</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">value</span> <span class=\"n\">h</span> <span class=\"n\">IH</span><span class=\"o\">,</span>\n  <span class=\"k\">if</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">value</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span>\n  <span class=\"o\">(</span><span class=\"n\">IH</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"n\">less</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">apply</span> <span class=\"n\">lt_of_le_of_ne</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">tauto</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">nat.div_lt_self</span> <span class=\"n\">value</span> <span class=\"mi\">2</span> <span class=\"n\">this</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 244932458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625489703
    },
    {
        "content": "<p>Well, your implementation has a bug. And I'm not asking you to fix that bug because, well, what's the point <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> I mean, I want to understand how rec_on works to fix that bug myself. I don't understand rec_on at all, how does it work?</p>",
        "id": 244936907,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625492366
    },
    {
        "content": "<p>This is the signature of rec_on:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ᾰ</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">something</span> <span class=\"n\">r</span> <span class=\"n\">ᾰ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">something</span> <span class=\"n\">r</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">ᾰ</span>\n</code></pre></div>\n<p>The first parameter is the relation obviously. And I guess the C is the result type, and <code>ᾰ</code> is a parameter in the introduction rule. <code>something r ᾰ</code> is the inductive predicate, and <code>x</code> is also a parameter in the introduction rule (???) and the <code>(∀ (y : ℕ), r y x → something r y)</code> is the hypothesis in the introduction rule (?). <code>(Π (y : ℕ), r y x → C y) → C x</code> means a function that outputs the result type and <code> C ᾰ</code> is the final result. I feel like I'm typing nonsense. Because to be honest I don't understand the parameters at all.</p>",
        "id": 244937344,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625492623
    },
    {
        "content": "<p>Oh, the explanation is here:</p>\n<blockquote>\n<p>The implicit argument, C, is the codomain of the function being defined. In type theory it is common to say C is the motive for the elimination/recursion, since it describes the kind of object we wish to construct. The next argument, n : nat, is the input to the function. It is also known as the major premise. Finally, the two arguments after specify how to compute the zero and successor cases, as described above. They are also known as the minor premises.</p>\n</blockquote>\n<p>It doesn't explain how the <code>rec_on</code> function itself is evaluated though. How is it evaluated then?</p>",
        "id": 244938346,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625493172
    },
    {
        "content": "<p>And why does your function output <code>0</code> when I run <code>#eval loglike 1000000 (something.intro 1000000 (is_wf 1000000))</code>? This is my is_wf lemma, it's gnarly but hey, I'm just goofing around!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">invent</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">something</span> <span class=\"n\">less</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">less</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">something</span> <span class=\"n\">less</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h_h</span> <span class=\"n\">y</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_wf</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">less</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">something</span> <span class=\"n\">less</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">rw</span> <span class=\"n\">less</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">something.intro</span> <span class=\"mi\">0</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n      <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">less</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">linarith</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">exact</span> <span class=\"n\">something.intro</span> <span class=\"n\">y_n.succ</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n      <span class=\"n\">intro</span> <span class=\"n\">hhh</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">less</span> <span class=\"n\">at</span> <span class=\"n\">hhh</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">nat.eq_or_lt_of_le</span> <span class=\"o\">(</span><span class=\"n\">nat.le_of_succ_le_succ</span> <span class=\"n\">hhh</span><span class=\"o\">),</span>\n      <span class=\"n\">cases</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">this</span> <span class=\"n\">at</span> <span class=\"n\">hhh</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">this.symm</span> <span class=\"n\">at</span> <span class=\"n\">y_ih</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">this.symm</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">y_ih</span> <span class=\"kd\">begin</span>\n        <span class=\"n\">rw</span> <span class=\"n\">less</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">less</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y.succ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">lt_trans</span> <span class=\"n\">this</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"kd\">end</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">less</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">y_n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y_n.succ</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n        <span class=\"n\">apply</span> <span class=\"n\">nat.lt_succ_of_le</span><span class=\"o\">,</span>\n        <span class=\"n\">linarith</span><span class=\"o\">,</span>\n      <span class=\"kd\">end</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">y_ih</span> <span class=\"kd\">begin</span>\n        <span class=\"n\">rw</span> <span class=\"n\">less</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">lt_trans</span> <span class=\"n\">this</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"kd\">end</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">invent</span> <span class=\"n\">y_n</span> <span class=\"n\">y</span> <span class=\"n\">this</span> <span class=\"kd\">begin</span>\n        <span class=\"n\">rw</span> <span class=\"n\">less</span><span class=\"o\">,</span>\n        <span class=\"n\">assumption</span><span class=\"o\">,</span>\n      <span class=\"kd\">end</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 244938578,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625493278
    },
    {
        "content": "<p>My original function, on the other hand, outputs <code>20</code>.</p>",
        "id": 244938627,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625493314
    },
    {
        "content": "<p>That is, when I stick the <code>meta</code> keyword in front of the function definition.</p>",
        "id": 244938663,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625493333
    },
    {
        "content": "<p>In your example <code>C</code> is just <code>λ  _, nat</code></p>",
        "id": 244945653,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625496960
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"270523\">Huỳnh Trần Khanh</span> <a href=\"#narrow/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E/near/244936907\">said</a>:</p>\n<blockquote>\n<p>Well, your implementation has a bug. And I'm not asking you to fix that bug because, well, what's the point <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> I mean, I want to understand how rec_on works to fix that bug myself. I don't understand rec_on at all, how does it work?</p>\n</blockquote>\n<p>Could you be more specific? It compiles just fine. As for what it actually does, I didn't pay it much attention, I think the body of the function is on you</p>",
        "id": 244949560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625499183
    },
    {
        "content": "<p>Oh, you are right, you've found one of lean's dirty secrets. Here's a function that computes a value in the singleton type <code>one_hundred</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">acc'</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">acc'</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">acc'</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">one_hundred</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">100</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">one_hundred</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">acc'.rec_on</span> <span class=\"n\">one_hundred</span> <span class=\"o\">(</span><span class=\"bp\">=</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">one_hundred</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"mi\">100</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"gr\">sorry</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">IH</span><span class=\"o\">,</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>You won't guess what the value is though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">foo.1</span> <span class=\"c1\">-- 0</span>\n</code></pre></div>",
        "id": 244950681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625499818
    },
    {
        "content": "<p>Change one character and it works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">one_hundred</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">acc.rec_on</span> <span class=\"n\">one_hundred</span> <span class=\"o\">(</span><span class=\"bp\">=</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">one_hundred</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"mi\">100</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"gr\">sorry</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">IH</span><span class=\"o\">,</span> <span class=\"n\">x</span>\n<span class=\"k\">#eval</span> <span class=\"n\">foo.1</span> <span class=\"c1\">-- 100</span>\n</code></pre></div>",
        "id": 244950792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625499883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"270523\">Huỳnh Trần Khanh</span> <a href=\"#narrow/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E/near/244938346\">said</a>:</p>\n<blockquote>\n<p>It doesn't explain how the <code>rec_on</code> function itself is evaluated though. How is it evaluated then?</p>\n</blockquote>\n<p>When you declare an inductive type, the kernel makes lambda functions that correspond to the type's constructors. When the whnf reduction procedure needs to apply the recursor, there's a kernel function that fishes out the appropriate lambda and just applies it like a regular function. You can see the procedure for making one of the computation rules here:<br>\n<a href=\"https://github.com/leanprover/lean4/blob/99e2a577910812726958303fd1deeae52f57684e/src/kernel/inductive.cpp#L639\">https://github.com/leanprover/lean4/blob/99e2a577910812726958303fd1deeae52f57684e/src/kernel/inductive.cpp#L639</a><br>\n<a href=\"https://github.com/ammkrn/nanoda_lib/blob/998ef68742d2ccc9f82442d70ae16802f44e33f2/src/inductive.rs#L1116\">https://github.com/ammkrn/nanoda_lib/blob/998ef68742d2ccc9f82442d70ae16802f44e33f2/src/inductive.rs#L1116</a></p>\n<p><a href=\"https://github.com/digama0/lean-type-theory\">Mario's paper</a> has a written description in 2.6.3/2.6.4</p>",
        "id": 244951234,
        "sender_full_name": "Chris B",
        "timestamp": 1625500184
    },
    {
        "content": "<p>I'm not sure if there's a way to get Lean to print the value level of the computation rule. Someone else might know.</p>",
        "id": 244951483,
        "sender_full_name": "Chris B",
        "timestamp": 1625500338
    },
    {
        "content": "<p>Or if you know any of the languages used in the type checkers you can use one of those to print out whatever kernel terms you want.</p>",
        "id": 244951750,
        "sender_full_name": "Chris B",
        "timestamp": 1625500554
    },
    {
        "content": "<p>Here's an example for <code>nat.rec_on</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">nat.rec_on</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">n.succ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nat.rec_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">nat.rec_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"n\">z</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">nat.rec_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nat.rec_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"n\">z</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>So when given <code>z</code> as initial value and <code>s</code> as a successor function, it returns <code>z</code> when the input is <code>0</code>, and when the input is <code>n+1</code>, it first calls itself recursively at <code>n</code> to produce a result <code>IH</code>, then calls <code>s n IH</code></p>",
        "id": 244952034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625500758
    },
    {
        "content": "<p>When the inductive type contains a nested function, <code>IH</code> will itself be a function, which can be called by the provided user function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">foo.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm simplifying to the nondependent case here but it still has a rather involved function signature. The recursor takes one \"configuration\" argument of type <code>(ℕ → foo) → (ℕ → α) → α</code>, which defines what we want to compute by recursion, and one \"main\" argument of type <code>foo</code>, which is what we are actually recursing over. When we define the body, we get two arguments, of types <code>ℕ → foo</code> and <code>ℕ → α</code>. The first argument is the contents of the current value after destructing the <code>foo.mk</code>: since it has one argument of type <code>ℕ → foo</code> the recursor gives it to us, and we can call this function to receive embedded values. The other function of type <code>ℕ → α</code> is the inductive hypothesis. We are trying to define a function returning values in <code>α</code>, so if we want to query the children of the current value we can use this function to do so.</p>",
        "id": 244953030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625501415
    },
    {
        "content": "<p>Mario, can you expand what the \"dirty secret\" about <code>acc</code> is there? Having the VM produce a different answer to the one you have a proof of seems like a pretty big deal, even if it doesn't impact soundness.</p>",
        "id": 244953241,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625501578
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">IH</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">IH</span> <span class=\"mi\">2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rec_f</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">foo.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rec_f</span> <span class=\"o\">(</span><span class=\"n\">foo.mk</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">rec_f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 244953382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625501676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Indeed, this is a bug in the VM that can cause programs to crash or compute wrong answers. The dirty secret is that because supporting large-eliminating propositions is complicated, the lean devs punted on the problem and only implemented it for two specific types: <code>eq</code> and <code>acc</code>. Luckily you can simulate all other large eliminating inductives using these, and the built in compilation strategy uses them, so people were none the wiser.</p>",
        "id": 244953588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625501834
    },
    {
        "content": "<p>In case you were wondering where the <code>0</code> came from:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">acc'</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">acc'</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">acc'</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">acc'.rec_on</span> <span class=\"n\">string</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"s2\">\"\"</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cc</span><span class=\"o\">⟩</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">IH</span><span class=\"o\">,</span> <span class=\"n\">x</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">foo</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">vm check failed: is_external(o) (possibly due to incorrect axioms, or sorry)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 244953868,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1625502031
    },
    {
        "content": "<p>Actually there are a few more builtin inductive predicates, like <code>and</code>. This one gives a nice error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">and'</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">and'</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">and</span> <span class=\"n\">true</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"o\">⟨⟩⟩</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">and.rec</span> <span class=\"n\">true</span> <span class=\"n\">true</span> <span class=\"o\">(</span><span class=\"n\">one_hundred</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"mi\">100</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span> <span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"c1\">-- 100</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo'</span> <span class=\"o\">:</span> <span class=\"n\">and'</span> <span class=\"n\">true</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"o\">⟨⟩⟩</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">and'.rec</span> <span class=\"n\">true</span> <span class=\"n\">true</span> <span class=\"o\">(</span><span class=\"n\">one_hundred</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"mi\">100</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span> <span class=\"n\">foo'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"c1\">-- code generation failed, inductive predicate 'and'' is not supported</span>\n</code></pre></div>",
        "id": 244954428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625502409
    },
    {
        "content": "<p>Amusingly, it seems the humble <code>true</code> was supported however:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">true'</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">true'</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">true.rec</span> <span class=\"o\">(</span><span class=\"n\">one_hundred</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"mi\">100</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"c1\">-- 100</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo'</span> <span class=\"o\">:</span> <span class=\"n\">true'</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">true'.rec</span> <span class=\"o\">(</span><span class=\"n\">one_hundred</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"mi\">100</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"n\">foo'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"c1\">-- 100</span>\n</code></pre></div>",
        "id": 244954605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625502567
    },
    {
        "content": "<p>The recursor for <code>true</code> is very useless:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"n\">eliminator</span> <span class=\"n\">true.rec</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">l</span><span class=\"o\">},</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">true</span> <span class=\"bp\">→</span> <span class=\"n\">C</span>\n</code></pre></div>",
        "id": 244954637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625502602
    },
    {
        "content": "<p>so the moral of the story is... lean codegen is a clownfest? <span aria-label=\"clown\" class=\"emoji emoji-1f921\" role=\"img\" title=\"clown\">:clown:</span> this is honestly... intriguing. like... lean can do something entirely different if it doesn't understand how to interpret our code computationally...</p>",
        "id": 244954893,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625502790
    },
    {
        "content": "<p>what's the motivation for this quirk though? performance?</p>",
        "id": 244954913,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625502813
    },
    {
        "content": "<p>to be quite frank I've never intentionally introduced a bug before... it's kind of weird that the lean devs intentionally introduce a bug into their software for some reason, and I want to understand the reasoning</p>",
        "id": 244955285,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625503012
    },
    {
        "content": "<blockquote>\n<p>intentionally introduce a bug</p>\n</blockquote>\n<p>Please don't accuse anyone of being malicious.</p>",
        "id": 244955462,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1625503168
    },
    {
        "content": "<p>hmm I don't? it's just that I find this quirk intriguing <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 244955480,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625503194
    },
    {
        "content": "<p>The story with all of these things is simply limited developer time.  This is not an intentional limitation, just that nobody had the time and motivation to implement it.</p>",
        "id": 244955545,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1625503228
    },
    {
        "content": "<p>People's efforts go into what the community wants. Lean has made it into Nature with some high-powered maths but in all that code there is no <code>#eval</code> at all, it's not what (those kinds of) mathematicians do. Because there is no big demand for getting the Lean 3 VM better, it stays as it is.</p>",
        "id": 244955608,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1625503303
    },
    {
        "content": "<p>Alright. Thank you for taking the time to answer this extremely crazy question! I have to go to bed now, see you! And I learned an extremely crazy quirk of the Lean theorem prover too <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span></p>",
        "id": 244956270,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625503782
    },
    {
        "content": "<p>One final question (because I can't sleep LOL): this quirk doesn't exist in Lean 4 right?</p>",
        "id": 244959553,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1625506233
    },
    {
        "content": "<p>Well-founded recursion isn't structural recursion (except in the sense that it involves structural recursion on <code>well_founded</code>). To my (admittedly freshly-formed) understanding, it's about constructing a function via <code>well_founded.fix</code>, together with the proof, via<code>well_founded.fix_eq</code>, that the function so constructed has the desired properties.</p>",
        "id": 244961558,
        "sender_full_name": "Gihan Marasingha",
        "timestamp": 1625508020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"270523\">Huỳnh Trần Khanh</span> <a href=\"#narrow/stream/113488-general/topic/how.20to.20do.20well.20founded.20recursion.20without.2E.2E.2E/near/244959553\">said</a>:</p>\n<blockquote>\n<p>One final question (because I can't sleep LOL): this quirk doesn't exist in Lean 4 right?</p>\n</blockquote>\n<p>Lean 4 behavior is very slightly worse than lean 3 here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">OneHundred</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">100</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">OneHundred</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">100</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">True'</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"n\">True'</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">True.foo</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">True.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OneHundred</span><span class=\"o\">)</span> <span class=\"n\">mk</span> <span class=\"n\">True.foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"c1\">-- code generator does not support recursor 'True.rec' yet, consider using 'match ... with' and/or structural recursion</span>\n<span class=\"kd\">def</span> <span class=\"n\">True'.foo</span> <span class=\"o\">:</span> <span class=\"n\">True'</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">True'.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OneHundred</span><span class=\"o\">)</span> <span class=\"n\">mk</span> <span class=\"n\">True'.foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"c1\">-- code generator does not support recursor 'True'.rec' yet, consider using 'match ... with' and/or structural recursion</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">And'</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">And'</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">And.foo</span> <span class=\"o\">:</span> <span class=\"n\">And</span> <span class=\"n\">True</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"o\">⟨⟩⟩</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">And.rec</span> <span class=\"n\">True</span> <span class=\"n\">True</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OneHundred</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mk</span><span class=\"o\">)</span> <span class=\"n\">And.foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"c1\">-- 100</span>\n<span class=\"kd\">def</span> <span class=\"n\">And'.foo</span> <span class=\"o\">:</span> <span class=\"n\">And'</span> <span class=\"n\">True</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨⟩,</span> <span class=\"o\">⟨⟩⟩</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">And'.rec</span> <span class=\"n\">True</span> <span class=\"n\">True</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OneHundred</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mk</span><span class=\"o\">)</span> <span class=\"n\">And'.foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"c1\">-- code generator does not support recursor 'And'.rec' yet, consider using 'match ... with' and/or structural recursion</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Eq'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Eq.foo</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Eq.rec</span> <span class=\"n\">Nat</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OneHundred</span><span class=\"o\">)</span> <span class=\"n\">mk</span> <span class=\"mi\">0</span> <span class=\"n\">Eq.foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"c1\">-- 100</span>\n<span class=\"kd\">def</span> <span class=\"n\">Eq'.foo</span> <span class=\"o\">:</span> <span class=\"n\">Eq'</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Eq'.rec</span> <span class=\"n\">Nat</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OneHundred</span><span class=\"o\">)</span> <span class=\"n\">mk</span> <span class=\"mi\">0</span> <span class=\"n\">Eq'.foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"c1\">-- code generator does not support recursor 'Eq'.rec' yet, consider using 'match ... with' and/or structural recursion</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Acc'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">Acc'</span> <span class=\"n\">r</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Acc'</span> <span class=\"n\">r</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Acc.foo</span> <span class=\"o\">:</span> <span class=\"n\">Acc</span> <span class=\"n\">Eq</span> <span class=\"n\">mk</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Acc.rec</span> <span class=\"n\">OneHundred</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OneHundred</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">IH</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">mk</span> <span class=\"n\">Acc.foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"c1\">-- code generator does not support recursor 'Acc.rec' yet, consider using 'match ... with' and/or structural recursion</span>\n<span class=\"kd\">def</span> <span class=\"n\">Acc'.foo</span> <span class=\"o\">:</span> <span class=\"n\">Acc'</span> <span class=\"n\">Eq</span> <span class=\"n\">mk</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Acc'.rec</span> <span class=\"n\">OneHundred</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OneHundred</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">IH</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">mk</span> <span class=\"n\">Acc'.foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"c1\">-- code generator does not support recursor 'Acc'.rec' yet, consider using 'match ... with' and/or structural recursion</span>\n</code></pre></div>\n<p>This makes sense considering that even regular well founded recursion is not implemented yet. On the bright side, the error is uniformly reported instead of having a loophole that allows seeing behind the under construction sign</p>",
        "id": 244965919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625511860
    },
    {
        "content": "<p>Oops, spoke too soon:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">False'</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">False.foo</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">False.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OneHundred</span><span class=\"o\">)</span> <span class=\"n\">False.foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"c1\">-- server crash</span>\n<span class=\"kd\">def</span> <span class=\"n\">False'.foo</span> <span class=\"o\">:</span> <span class=\"n\">False'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">False'.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OneHundred</span><span class=\"o\">)</span> <span class=\"n\">False'.foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"c1\">-- code generator does not support recursor 'False'.rec' yet, consider using 'match ... with' and/or structural recursion</span>\n</code></pre></div>",
        "id": 244966116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625512066
    },
    {
        "content": "<p>although to be fair I think it's fine to say that evaluating <code>False.rec</code> is undefined behavior</p>",
        "id": 244966180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625512105
    }
]
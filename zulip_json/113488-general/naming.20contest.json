[
    {
        "content": "<p>Any suggestions for a conciser name?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_basis_to_matrix_mul_linear_map_to_matrix_mul_is_basis_to_matrix</span>\n  <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb'</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">b'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc'</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">c'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">hc.to_matrix</span> <span class=\"n\">c'</span> <span class=\"bp\">⬝</span> <span class=\"n\">linear_map.to_matrix</span> <span class=\"n\">hb'</span> <span class=\"n\">hc'</span> <span class=\"n\">f</span> <span class=\"bp\">⬝</span> <span class=\"n\">hb'.to_matrix</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">linear_map.to_matrix</span> <span class=\"n\">hb</span> <span class=\"n\">hc</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 213573086,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1602861112
    },
    {
        "content": "<p>Can that be split into two lemmas?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_basis_to_matrix_mul_linear_map_to_matrix</span>\n  <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb'</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">b'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc'</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">c'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">hc.to_matrix</span> <span class=\"n\">c'</span> <span class=\"bp\">⬝</span> <span class=\"n\">linear_map.to_matrix</span> <span class=\"n\">hb'</span> <span class=\"n\">hc'</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">linear_map.to_matrix</span> <span class=\"n\">hb'</span> <span class=\"n\">hc</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n<p>and a similar <code>linear_map_to_matrix_mul_is_basis_to_matrix</code>?</p>\n<p>Or am I missing something there?</p>",
        "id": 213575069,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602861895
    },
    {
        "content": "<p>Ah good point, I was thinking about how to describe \"basis change\" in Lean.</p>",
        "id": 213575272,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1602862007
    },
    {
        "content": "<p>But we can do it one side at a time.</p>",
        "id": 213575292,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1602862015
    },
    {
        "content": "<p>Still quite a long name :/</p>",
        "id": 213575315,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1602862027
    },
    {
        "content": "<p>You could turn one of the underscores into a dot and put it in the <code>is_basis</code> namespace.</p>",
        "id": 213580512,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1602864585
    },
    {
        "content": "<p>Eric's version also looks like a good simp lemma.</p>",
        "id": 213580658,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1602864646
    },
    {
        "content": "<p>I'm going to review API around <code>null_measurable</code>, and I need 4 names:</p>\n<ul>\n<li>null measurable set;</li>\n<li>null measurable function;</li>\n<li>the <code>measurable_space</code> structure that corresponds to <code>null_measurable_set</code>;</li>\n<li>the type tag for \"<code>α</code> with <code>measurable_set</code> = <code>null_measurable_set</code>\".<br>\nFor the first two, <code>null_measurable_set</code> and <code>null_measurable</code> look like obvious choices. What about the other two?</li>\n</ul>",
        "id": 260589943,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636311292
    },
    {
        "content": "<p>Just for the record, I know that we need a refactor of the Bochner integral (and I'm planning to do it in a few months, when I have just a little bit of free time), for the following reason. Currently, our version only works when the target space is second countable (this is the setting in which every measurable function can be approximated by simple functions). However, there is a very important application of integral where this is not the case: if you consider a continuous linear operator on a Banach space, then its spectral projections are defined by Cauchy-like integral formulas, so we need integrals there -- and such spaces of operators are never second-countable. </p>\n<p>The most general setting to define the integral of a function <code>f</code> is to assume that there is a measurable function <code>g</code>, taking its values in a second-countable subspace, and coinciding almost everywhere with <code>f</code>. (see <a href=\"https://en.wikipedia.org/wiki/Bochner_measurable_function\">https://en.wikipedia.org/wiki/Bochner_measurable_function</a>). The name for this would probably be <code>strongly_ae_measurable</code>, or something like that. And it covers the use-case above of spectral projections. So I am planning to generalize the Bochner integral, replacing the <code>ae_measurable</code> assumption with <code>strongly_ae_measurable</code> (which coincides with <code>ae_measurable</code> when the target space is second-countable).</p>\n<p>This does not really answer your questions, but I think this is something to keep in mind for any measure theory API review.</p>",
        "id": 260590829,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1636312529
    },
    {
        "content": "<p>As for your questions, <code>null_measurable_set</code> is great. <code>null_measurable</code> is ok for the function (but in the end it is equivalent to <code>ae_measurable</code>, so I am not so sure we need the two names). Then, you could go with <code>measurable_space_completion μ</code> for the completed sigma-algebra, and <code>is_complete_measurable_space μ</code> for the fact that all null measurable sets are measurable (as in <a href=\"https://en.wikipedia.org/wiki/Complete_measure\">https://en.wikipedia.org/wiki/Complete_measure</a>)</p>",
        "id": 260591021,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1636312798
    },
    {
        "content": "<p>In what generality <code>null_measurable = ae_measurable</code>?</p>",
        "id": 260592316,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636314683
    },
    {
        "content": "<p>In any case, I think that we should have better API for <code>null_measurable_set</code>s.</p>",
        "id": 260592410,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636314823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113488-general/topic/naming.20contest/near/260592316\">said</a>:</p>\n<blockquote>\n<p>In what generality <code>null_measurable = ae_measurable</code>?</p>\n</blockquote>\n<p>I guess when the target space is second-countable.</p>",
        "id": 260595965,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1636319799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113488-general/topic/naming.20contest/near/260592410\">said</a>:</p>\n<blockquote>\n<p>In any case, I think that we should have better API for <code>null_measurable_set</code>s.</p>\n</blockquote>\n<p>Yes, definitely!</p>",
        "id": 260595969,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1636319808
    },
    {
        "content": "<p>What should the <a href=\"https://ncatlab.org/nlab/show/pasting+law+for+pullbacks\">pasting law for pullbacks</a> be called?<br>\nIn particular</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X₁</span> <span class=\"n\">X₂</span> <span class=\"n\">X₃</span> <span class=\"n\">Y₁</span> <span class=\"n\">Y₂</span> <span class=\"n\">Y₃</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">X₁</span> <span class=\"bp\">⟶</span> <span class=\"n\">X₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"o\">:</span> <span class=\"n\">X₂</span> <span class=\"bp\">⟶</span> <span class=\"n\">X₃</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">Y₁</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₂</span> <span class=\"o\">:</span> <span class=\"n\">Y₂</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y₃</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">i₁</span> <span class=\"o\">:</span> <span class=\"n\">X₁</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i₂</span> <span class=\"o\">:</span> <span class=\"n\">X₂</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i₃</span> <span class=\"o\">:</span> <span class=\"n\">X₃</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y₃</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">i₁</span> <span class=\"bp\">≫</span> <span class=\"n\">f₂</span> <span class=\"bp\">=</span> <span class=\"n\">f₁</span> <span class=\"bp\">≫</span> <span class=\"n\">i₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">i₂</span> <span class=\"bp\">≫</span> <span class=\"n\">g₂</span> <span class=\"bp\">=</span> <span class=\"n\">g₁</span> <span class=\"bp\">≫</span> <span class=\"n\">i₃</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pasting_law</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">is_limit</span> <span class=\"o\">(</span><span class=\"n\">pullback_cone.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h₂</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_limit</span> <span class=\"o\">(</span><span class=\"n\">pullback_cone.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">i₁</span> <span class=\"bp\">≫</span> <span class=\"n\">f₂</span> <span class=\"bp\">≫</span> <span class=\"n\">g₂</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"bp\">≫</span> <span class=\"n\">g₁</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"n\">i₃</span><span class=\"o\">,</span>\n    <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">category.assoc</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">category.assoc</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">category.assoc</span><span class=\"o\">]))</span> <span class=\"bp\">≃</span>\n  <span class=\"n\">is_limit</span> <span class=\"o\">(</span><span class=\"n\">pullback_cone.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h₁</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>And the implications in both directions that will be proved before this.</p>",
        "id": 263387029,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1638413152
    },
    {
        "content": "<p>I'm going to add <code>Prop</code> versions of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype\">docs#fintype</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/encodable\">docs#encodable</a>. How should I call them?</p>",
        "id": 263563104,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1638529313
    },
    {
        "content": "<p><code>_root_.finite</code> and <code>_root_.countable</code>?</p>",
        "id": 263564776,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1638530249
    },
    {
        "content": "<p><del>doesn't <a href=\"https://leanprover-community.github.io/mathlib_docs/find/countable\">docs#countable</a> already exist?</del> guess not</p>",
        "id": 263565411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638530608
    },
    {
        "content": "<p>Funnily enough an undergraduate and I wrote <code>_root_.countable</code> at Xena on Thursday but it's on the student's laptop and I don't know their name :-)</p>",
        "id": 263663637,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1638571777
    },
    {
        "content": "<p>I already have <code>_root_.countable</code> with some instances. I'll add glue code and PR it over week-end.</p>",
        "id": 263667451,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1638574612
    },
    {
        "content": "<p>I'm going to formalize a few versions of the <a href=\"https://en.wikipedia.org/wiki/Phragm%C3%A9n%E2%80%93Lindel%C3%B6f_principle\">Phragmén–Lindelöf principle</a>. Mathlib naming convention leads to very long names. What do you think about names like <code>phragmen_lindelof.(shape)</code>, where <code>(shape)</code> is one of <code>sector</code>, <code>first/second/third/fourth_quadrant</code> etc?</p>",
        "id": 272564018,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1645329972
    },
    {
        "content": "<p>(and now I see that I forgot to polish <code>_root_.countable</code>)</p>",
        "id": 272564038,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1645330013
    },
    {
        "content": "<p>Looks good to me.</p>",
        "id": 272579718,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1645349543
    },
    {
        "content": "<p>What should the additive version of <code>div_inv_monoid</code> be called? <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sub_neg_monoid\">docs#sub_neg_monoid</a> exists, but <code>@[to_additive]</code> thinks it should be called <code>sub_neg_add_monoid</code>, as demonstrated by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.injective.sub_neg_add_monoid\">docs#function.injective.sub_neg_add_monoid</a>.</p>",
        "id": 274315240,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646585260
    },
    {
        "content": "<p>/poll With or without <code>add_</code>?</p>\n<ul>\n<li>sub_neg_monoid, keeping the existing class name and fixing to_additive to match</li>\n<li>sub_neg_add_monoid, changing the existing class name and leaving to_additive alone</li>\n</ul>",
        "id": 274315384,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646585354
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>, since I think you added this originally</p>",
        "id": 274315422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646585384
    },
    {
        "content": "<p>/poll What should <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mi>G</mi></msup></mrow><annotation encoding=\"application/x-tex\">V^G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">G</span></span></span></span></span></span></span></span></span></span></span> be called for a G-representation V? (<a href=\"https://github.com/leanprover-community/mathlib/pull/11207/files#diff-92d45ccdf14ad18f844dc7d0faddeae9c2089a7205c7ef33aad57f674ec8b61e\">Context</a>)</p>\n<ul>\n<li>fixed_space</li>\n<li>invariants</li>\n</ul>",
        "id": 275771137,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1647591569
    },
    {
        "content": "<p>Context: <a href=\"https://github.com/leanprover-community/mathlib/pull/11207/files#diff-92d45ccdf14ad18f844dc7d0faddeae9c2089a7205c7ef33aad57f674ec8b61e\">https://github.com/leanprover-community/mathlib/pull/11207/files#diff-92d45ccdf14ad18f844dc7d0faddeae9c2089a7205c7ef33aad57f674ec8b61e</a></p>",
        "id": 275772296,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1647592412
    },
    {
        "content": "<p><code>cohomology.H 0 G V</code> ;-) (this is not a correct answer -- there should probably just be an isomorphism...)</p>",
        "id": 275772474,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647592529
    },
    {
        "content": "<p>invariants seems good also because the dual guy is called the coinvariants (what else?)</p>",
        "id": 275783369,
        "sender_full_name": "Reid Barton",
        "timestamp": 1647598779
    },
    {
        "content": "<p>How should I call the following lemmas?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">prod.snd</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">h.image</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h.image</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h.1.prod</span> <span class=\"n\">h.2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subset</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">mem_image_of_mem</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">mem_image_of_mem</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">)}</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">i</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h.image</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">finite.pi</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subset</span> <span class=\"bp\">$</span> <span class=\"n\">subset_pi_eval_image</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 279748995,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1650580753
    },
    {
        "content": "<p>Probably, the name of the first lemma should include <code>finite</code> and <code>prod</code>. There is also a reasonable lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∨</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∨</span> <span class=\"n\">finite</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">finite</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 279753504,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1650584053
    },
    {
        "content": "<p><code>set.finite_of_prod_iff</code>, using the rule \"<code>of</code> refers to the type of arguments\"?</p>",
        "id": 279782644,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650607138
    },
    {
        "content": "<p>I would name the third one <code>set.prod_finite_iff</code>.</p>",
        "id": 279788662,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650612660
    },
    {
        "content": "<p><code>of</code> sounds weird to me, since it's the type we're talking about. <br>\nI like <code>set.finite_prod_iff</code> for both the first and the third one, and I'm not sure how to best disambiguate them. Both of them are follow the example of existing names. E.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_pi_iff\">docs#measurable_pi_iff</a> , <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_prod\">docs#measurable_prod</a> for the first one, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.finite_union\">docs#set.finite_union</a> / <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.tendsto_prod_iff\">docs#filter.tendsto_prod_iff</a> for the other one (we seem to be quite inconsistent about whether to append <code>iff</code> to a name).</p>",
        "id": 279809187,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1650626105
    },
    {
        "content": "<p>Well, when we usually use <code>of</code> for proofs, it also refers to the type</p>",
        "id": 279811167,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650627421
    },
    {
        "content": "<p>I think we also sometimes use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/of_fintype\">docs#of_fintype</a> in names, which is referring to a non-<code>Prop</code> type</p>",
        "id": 279811216,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650627454
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib/pull/13619\">#13619</a> I swap LHS with RHS and describe the new LHS in the name. Not sure if it is a good solution.</p>",
        "id": 279894941,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1650674343
    },
    {
        "content": "<p>How should I call the following definition?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">name_me</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">γ</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Equivalently, <code>name_me f o₁ o₂ = o₁.bind (λ a, o₂.map (f a))</code>.</p>",
        "id": 282516311,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652716720
    },
    {
        "content": "<p>This already exists</p>",
        "id": 282516372,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652716752
    },
    {
        "content": "<p>How is it called?</p>",
        "id": 282516423,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652716770
    },
    {
        "content": "<p>Ah no, I thought it was <a href=\"https://leanprover-community.github.io/mathlib_docs/find/option.lift_or_get\">docs#option.lift_or_get</a> but it doesn't do the same thing when one of the arguments is <code>none</code>.</p>",
        "id": 282517000,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652716957
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">name_me</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 282517038,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652716971
    },
    {
        "content": "<p>What does <a href=\"https://leanprover-community.github.io/mathlib_docs/find/with_top.has_add\">docs#with_top.has_add</a> do?</p>",
        "id": 282517079,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652716987
    },
    {
        "content": "<p>This is what applicative functors let you do in a generalized way for any number of arguments (keep adding <code>&lt;*&gt;</code>).</p>",
        "id": 282517123,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652717005
    },
    {
        "content": "<p>Yeah that's what it does.</p>",
        "id": 282517196,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652717036
    },
    {
        "content": "<p>Note the <code>f &lt;$&gt; x &lt;*&gt; y </code> version only works when <code>α β γ</code> are in the same universe</p>",
        "id": 282517326,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652717074
    },
    {
        "content": "<p>A good name would be <code>option.map\\2</code> but indeed you can just write it out monadically.</p>",
        "id": 282517351,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652717086
    },
    {
        "content": "<p>Yes, I wanted to prove some lemmas about this combinator, then use it for <code>(+)</code> and <code>(*)</code> on <code>with_top</code>.</p>",
        "id": 282517394,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652717106
    },
    {
        "content": "<p>Yeah... but if we perform the functor refactor we talked about, that wouldn't be a problem anymore.</p>",
        "id": 282517426,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652717119
    },
    {
        "content": "<p>it was never clear to me whether that refactor would actually work</p>",
        "id": 282517468,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652717140
    },
    {
        "content": "<blockquote>\n<p>monadically</p>\n</blockquote>\n<p>(n.b. this uses the weaker notion of an applicative functor, no need for monads)</p>",
        "id": 282517508,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652717161
    },
    {
        "content": "<p>What are you fearing? I thought about it and couldn't see anything wrong.</p>",
        "id": 282517566,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652717168
    },
    {
        "content": "<p>Typeclass search not handling <code>out_param</code>s well enough</p>",
        "id": 282517585,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652717181
    },
    {
        "content": "<p>Yury, Yakov already wanted to do that, and it turns out that this is not a good global instance because sometimes you want the top element to not do anything</p>",
        "id": 282517656,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652717217
    },
    {
        "content": "<p>Let me dig out the PR...</p>",
        "id": 282517674,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652717226
    },
    {
        "content": "<p>We <strong>already have</strong> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/with_top.has_add\">docs#with_top.has_add</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/with_top.mul_zero_class\">docs#with_top.mul_zero_class</a></p>",
        "id": 282517796,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652717272
    },
    {
        "content": "<p>Ah right, it was subtraction. <a href=\"https://github.com/leanprover-community/mathlib/pull/8889\">#8889</a></p>",
        "id": 282518048,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652717373
    },
    {
        "content": "<p>I'd expect something close to Haskell's naming (<code>liftA\\2</code>)</p>",
        "id": 282518154,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1652717407
    },
    {
        "content": "<p>For the name, I would follow Haskell and use some variant of <a href=\"https://hoogle.haskell.org/?hoogle=(a%20%2D%3E%20b%20%2D%3E%20c)%20%2D%3E%20Maybe%20a%20%2D%3E%20Maybe%20b%20%2D%3E%20Maybe%20c&amp;scope=set%3Astackage\"><code>lift2</code></a></p>",
        "id": 282518173,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1652717414
    },
    {
        "content": "<p>Yeah so <code>0 * top = 0</code>, not <code>0 * top = top</code>.</p>",
        "id": 282518275,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652717461
    },
    {
        "content": "<p>Yes, <code>lift₂</code> will be used for the <code>else</code> branch.</p>",
        "id": 282518529,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652717558
    },
    {
        "content": "<p>We currently have two duplicate theorems <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.insert_nonempty\">docs#set.insert_nonempty</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.nonempty_insert\">docs#set.nonempty_insert</a>. My PR <a href=\"https://github.com/leanprover-community/mathlib/pull/14884\">#14884</a> is meant to ditch one in favor of the other, but I was asked to do a poll to see which one is preferred.</p>",
        "id": 287004373,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655872914
    },
    {
        "content": "<p>Consider that:</p>\n<ul>\n<li>we also have lemmas <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.univ_nonempty\">docs#set.univ_nonempty</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.singleton_nonempty\">docs#set.singleton_nonempty</a></li>\n<li><code>insert_nonempty</code> is currently the most used of the two (though not by a huge margin)</li>\n</ul>",
        "id": 287004434,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655872959
    },
    {
        "content": "<p>/poll What name should we use? </p>\n<ul>\n<li>insert_nonempty</li>\n<li>nonempty_insert</li>\n</ul>",
        "id": 287004460,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655872981
    },
    {
        "content": "<p>This is the old debate about whether the naming for <code>p x</code> is <code>x_p</code> when <code>p</code> is a <code>Prop</code>-valued predicate that is amenable to dot notation, and, as far as I know, we haven't reached consensus about this yet. It would be nice to have <a href=\"https://leanprover-community.github.io/contribute/naming.html\">#naming</a> prescribe something.</p>",
        "id": 287004666,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1655873225
    },
    {
        "content": "<p>Maybe this is a decision that can be made per predicate and documented in the predicate's docstring. It seems (though I haven't measured) that <code>set.nonempty</code> most often uses the <code>*_nonempty</code> convention.</p>",
        "id": 287004850,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1655873417
    },
    {
        "content": "<p>I also think this decision should be made on a per-predicate basis. I'd be somewhat annoyed if I had to rename e.g. <code>one_to_game</code> to <code>to_game_one</code> (example from one of my PRs). No doubt there's a similar situation going the other way (though I'm awful at coming up with examples for things like this).</p>",
        "id": 287004993,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655873597
    },
    {
        "content": "<p>Just to relink the old thread on this type of naming issue: <a href=\"#narrow/stream/113488-general/topic/.23naming.20and.20dot.20notation/near/246520191\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/.23naming.20and.20dot.20notation/near/246520191</a></p>",
        "id": 287042479,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1655899134
    },
    {
        "content": "<p>For what it's worth, I'd expect it to be called <code>to_game_one</code> to match all the <code>coe_one</code> lemmas we have</p>",
        "id": 287042540,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1655899183
    },
    {
        "content": "<p>Unfortunate but understandable</p>",
        "id": 287047035,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655901548
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/15061\">#15061</a> adds two recursion principles for <code>P : ℕ → ℕ → Sort*</code> for which I'm looking for naming suggestions: </p>\n<ul>\n<li>\n<p><code>strong_sub_recursion</code>: if for all <code>a b : ℕ</code> we can extend <code>P</code> from the rectangle strictly below <code>(a,b)</code> to <code>P a b</code>, then we have <code>P n m</code> for all <code>n m : ℕ</code>.  <br>\nThis was originally proved and named by <span class=\"user-mention\" data-user-id=\"389019\">@Chris Birkbeck</span> in <a href=\"https://github.com/leanprover-community/mathlib/pull/14828\">#14828</a> (which is now closed)</p>\n</li>\n<li>\n<p><code>pincer_recursion</code>: if we have <code>P i 0</code> and <code>P 0 i</code> for all <code>i : ℕ</code>, and for any <code>x y : ℕ</code> we can extend <code>P</code> from <code>(x,y+1)</code> and <code>(x+1,y)</code> to <code>(x+1,y+1)</code>, then we have <code>P n m</code> for all <code>n m : ℕ</code>. <br>\n<code>pincer_recursion</code> is just a name I made up for this.  Does anyone know if this is already known by another name?  Or can anyone suggest a better name for this?</p>\n</li>\n</ul>",
        "id": 288258495,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1656752466
    },
    {
        "content": "<p>Another naming question: <a href=\"https://github.com/leanprover-community/mathlib/pull/15072\">#15072</a> defines <code>multichoose</code> which (by contrast with <code>choose</code>) counts the number of <em>multisets</em> of cardinality <code>k</code> from a type of cardinality <code>n</code>, or equivalently the number of ways to select <code>k</code> items (up to permutation) from <code>n</code> items <em>with</em> replacement.  (This is another step toward getting <span class=\"user-mention\" data-user-id=\"511228\">@Huỳnh Trần Khanh</span>'s  <a href=\"https://github.com/leanprover-community/mathlib/pull/11162\">#11162</a> \"stars and bars\" tidied up and finalised.)</p>\n<p>Some reviewers have suggested that the name <code>multichoose</code> (which I took from <a href=\"https://github.com/leanprover-community/mathlib/pull/11162\">#11162</a>) is a problem because it wrongly suggests multinomial coefficients.  The alternative name <code>multicombination</code> has been suggested.  Does anyone have a strong preference for either of these names, or another suggestion?</p>",
        "id": 288340358,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1656872385
    },
    {
        "content": "<p>According to <a href=\"https://mathworld.wolfram.com/Multichoose.html\">https://mathworld.wolfram.com/Multichoose.html</a> multichoose should be fine for this.</p>",
        "id": 288340606,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1656872727
    },
    {
        "content": "<p>Another way to justify the name is that where <code>choose</code> is choosing things singly, <code>multichoose</code> is choosing things with multiplicity.</p>",
        "id": 288340676,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1656872827
    },
    {
        "content": "<p>In the doc string, it'd be good to mention that multichoose is also known as counting multicombinations (and have multicombination in the module doc's tags), if you haven't already.</p>",
        "id": 288340686,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1656872870
    },
    {
        "content": "<p>May as well put in a hint that this is not the multinomial coefficient, too.</p>",
        "id": 288340762,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1656872956
    },
    {
        "content": "<p>As a counterpoint, <a href=\"https://www.rdocumentation.org/packages/iterpc/versions/0.4.2/topics/multichoose\">https://www.rdocumentation.org/packages/iterpc/versions/0.4.2/topics/multichoose</a> is the multinomial coefficient, but this library seems to be unique in calling it that. \"Multichoose\" seems to be this PR's multichoose everywhere else.</p>",
        "id": 288340965,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1656873258
    },
    {
        "content": "<p>Maybe add a reference to Wolfram for the naming in the docstring, just to be extra safe?</p>",
        "id": 288341429,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656874041
    },
    {
        "content": "<p>Yeah, if the docs make it clear enough that this name is used elsewhere and not the multinomial coefficient, then I completely support it</p>",
        "id": 288354639,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656893613
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.mk_set_le_aleph_0\">docs#cardinal.mk_set_le_aleph_0</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.lt_aleph_0_iff_set_finite\">docs#cardinal.lt_aleph_0_iff_set_finite</a>. These are very similar statements but have very different names.</p>",
        "id": 289909540,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658099551
    },
    {
        "content": "<p>The only other related lemma with a similar name to the former is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.mk_subtype_le_aleph_0\">docs#cardinal.mk_subtype_le_aleph_0</a>, while there's a few other lemmas about finite sets with similar names to the latter, such as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.lt_aleph_0_iff_finite\">docs#cardinal.lt_aleph_0_iff_finite</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.lt_aleph_0_of_finite\">docs#cardinal.lt_aleph_0_of_finite</a>.</p>",
        "id": 289909599,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658099652
    },
    {
        "content": "<p>I would much prefer to be consistent, particularly since we'll be adding a bunch more very similar lemmas now that we have our new <a href=\"https://leanprover-community.github.io/mathlib_docs/find/countable\">docs#countable</a> typeclass. So I might as well put it up to vote.</p>",
        "id": 289909630,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658099762
    },
    {
        "content": "<p>/poll Which scheme should we prefer for these lemmas?</p>\n<ul>\n<li>mk_set_le_aleph_0</li>\n<li>lt_aleph_0_iff_set_finite</li>\n<li>other (suggest)</li>\n</ul>",
        "id": 289909683,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658099866
    },
    {
        "content": "<p>I marginally prefer the <code>lt_aleph_0_iff_set_finite</code> scheme, since it allows us to clearly distinguish between the iff versions and the one sided versions of these lemmas.</p>",
        "id": 289909733,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658099922
    },
    {
        "content": "<p>We have duplicate definitions: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.nat_prod_nat_equiv_nat\">docs#equiv.nat_prod_nat_equiv_nat</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.mkpair_equiv\">docs#nat.mkpair_equiv</a>.</p>",
        "id": 290046428,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1658197564
    },
    {
        "content": "<p>/poll Which name should <strong>stay</strong> in <code>mathlib</code>?<br>\nequiv.nat_prod_nat_equiv_nat<br>\nnat.mkpair_equiv<br>\nI don't care</p>",
        "id": 290046462,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1658197601
    },
    {
        "content": "<p>I want to remove one of the names, no matter which one.</p>",
        "id": 290046483,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1658197637
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib/pull/15509\">#15509</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/15510\">#15510</a> for PRs implementing different options.</p>",
        "id": 290046897,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1658198053
    },
    {
        "content": "<p>There are many possible equivalences between <code>ℕ × ℕ</code> and <code>ℕ</code>, and the name <code>equiv.nat_prod_nat_equiv_nat</code> doesn't specify which one it is. Since the to_fun and inv_fun are already named <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.mkpair\">docs#nat.mkpair</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.unpair\">docs#nat.unpair</a>, it's better to include (at least one of) these in the name.</p>",
        "id": 290047178,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658198357
    },
    {
        "content": "<p>It looks like <code>nat.mkpair_equiv</code> wins.</p>",
        "id": 290089585,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1658232970
    },
    {
        "content": "<p>In case anyone didn't see the poll hidden in the other thread and wants to vote (about nondiscrete normed field), please read the summary post immediately prior to the poll: <a href=\"#narrow/stream/116395-maths/topic/hypotheses.20for.20a.20field.20property/near/290408091\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/hypotheses.20for.20a.20field.20property/near/290408091</a></p>",
        "id": 290519802,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1658501242
    },
    {
        "content": "<p>I think the naming for <code>continuous_linear_map.lmul</code> and friends is weird. It doesn't match the non-continuous version (which had some recent changes in <a href=\"https://github.com/leanprover-community/mathlib/pull/15310\">#15310</a>). Before <a href=\"https://github.com/leanprover-community/mathlib/pull/15310\">#15310</a>, <code>continuous_linear_map.lmul</code> was defined in terms of <code>algebra.lmul</code> (and I'm fairly certain that the \"l\" is for \"linear\", because the docstring used to call it a bilinear map, even though it was an algebra hom), and I believe this is why it was named as such.</p>\n<p>In any case, we used to have <code>algebra.lmul_left</code> and <code>algebra.lmul_right</code> (now named <code>linear_map.mul_left</code> and <code>linear_map.mul_right</code>), but <code>continuous_linear_map.lmul_right</code> does <em>not</em> correspond to  <code>linear_map.mul_right</code> and <code>continuous_linear_map.lmul_left</code> doesn't even exist. So, I think the things in the <code>continuous_linear_map</code> namespace should be renamed appropriately. My feeling is:</p>\n<ol>\n<li><code>continuous_linear_map.lmul</code> → <code>continuous_linear_map.mul</code></li>\n<li><code>continuous_linear_map.lmul_right</code> → <code>continuous_linear_map.mul_flip</code> (or just delete this if it's not frequently used; it's literally defined as <code>(continuous_linear_map.mul _ _).flip</code>)</li>\n<li><code>continuous_linear_map.lmul_left_right</code> → <code>continuous_linear_map.mul_mul</code></li>\n</ol>",
        "id": 292063494,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659643810
    },
    {
        "content": "<p>I think maybe people missed this yesterday.</p>",
        "id": 292181112,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659718707
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib/pull/16161\">#16161</a> I am making <code>equiv_like</code> extend <code>fun_like</code>, and to do so we must rename the current <code>coe_injective'</code> field to something else. Currently in the PR it has been renamed to <code>coe_inv_injective'</code> (the type is <code>∀ e g : E, coe e = coe g → inv e = inv g → e = g</code>). However, <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> mentioned that this seems wrong, but can't think of anything better. Hence poll:</p>",
        "id": 294720814,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661184729
    },
    {
        "content": "<p>/poll the field <code>equiv_like.coe_injective'</code> should be renamed to:<br>\ncoe_inv_injective'<br>\next'<br>\neq_of_coe_eq_of_inv_eq</p>",
        "id": 294720947,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1661184789
    },
    {
        "content": "<p>I completely agree with Anne's remark <a href=\"https://github.com/leanprover-community/mathlib/pull/16161/files#r951390479\">here</a> so I don't love <code>coe_inv_injective'</code> but it is definitely the least bad of the various possibilities I can think of.</p>",
        "id": 294753634,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1661196432
    },
    {
        "content": "<p><a href=\"https://github.com/prakol16/lean_complexity_theory_polytime_trees\">Here</a>, I defined polynomial time functions using the native datatype <code>ptree</code> (\"plain binary tree\"). This is because mathlib's <code>mkpair</code> encoding causes exponential blowup in e.g. the encoding of lists. At some point, I will try porting this to mathlib. In addition, the entire computability library should, I believe, be refactored to use this datatype, because it is the most direct representation of what we actually want to represent -- namely tree structures. I've already discussed this a bit with <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> .</p>\n<p>What should this data structure be called:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ptree</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">ptree</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">ptree</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 296677883,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1662057703
    },
    {
        "content": "<p>/poll What to call a plain binary tree<br>\nptree<br>\nplain_tree<br>\nbinary_tree</p>",
        "id": 296678204,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1662057821
    },
    {
        "content": "<p>I assume this is the same as <code>tree unit</code>?</p>",
        "id": 296697612,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662065483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/naming.20contest/near/296697612\">said</a>:</p>\n<blockquote>\n<p>I assume this is the same as <code>tree unit</code>?</p>\n</blockquote>\n<p>Yes, I think so</p>",
        "id": 296698490,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1662065852
    },
    {
        "content": "<p>You could also use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/free_magma\">docs#free_magma</a> <code>unit</code> right?</p>",
        "id": 296706752,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662069668
    },
    {
        "content": "<p>I don't like <code>binary_tree</code> because it implies that <code>tree</code> isn't binary.</p>",
        "id": 296742438,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1662085587
    },
    {
        "content": "<p>In fact, it's a bit unfortunate that we have both <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bin_tree\">docs#bin_tree</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tree\">docs#tree</a> and the difference isn't that one is binary and the other is not the difference is in how leaves are represented. Edit: I guess this is due to the former being in core</p>",
        "id": 296742586,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1662085707
    }
]
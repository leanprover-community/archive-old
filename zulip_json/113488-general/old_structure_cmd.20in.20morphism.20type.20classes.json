[
    {
        "content": "<p>I just stumbled into an issue in the morphism type classes: we never standardized on whether to use the old structure command or not when defining these classes. This creates problems when a new morphism class extends two other ones that use opposite conventions in this respect. For example, <code>continuous_semilinear_map_class</code>  extends <code>semilinear_map_class</code> which uses the old structure command and <code>continuous_map</code> which does not. Here's the sort of problem it can create:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.algebra.module.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">continuous_linear_map_class</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span>  <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">map_add</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The <code>have</code> fails because Lean is trying to find a coercion to a function via the two different possible pathways.</p>\n<p>I think we should standardize on using the old structure command throughout, because it's much nicer to have the <code>coe</code> field directly in the structure rather than buried under possibly several levels of structure, but I thought this should be discussed here. (I already opened <a href=\"https://github.com/leanprover-community/mathlib/pull/16164\">#16164</a> when I thought the problem was restricted to <code>continuous_map_class</code>, but clearly it's not.)</p>",
        "id": 294381258,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1660957388
    },
    {
        "content": "<p>Yeah, Anne and I came to the same conclusion several months ago but nothing has been done since.</p>",
        "id": 294405223,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1660981991
    },
    {
        "content": "<p>I thought when we had this discussion last it was referring to the structures, not the typeclasses? (Perhaps you're not referring to the discussion on the centroid PR that I'm thinking of)</p>",
        "id": 294412683,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660986746
    }
]
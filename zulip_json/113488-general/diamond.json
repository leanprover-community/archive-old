[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">add_comm_group.int_module.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring.to_add_comm_group</span> <span class=\"n\">_</span> <span class=\"n\">int.ring</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">@</span><span class=\"n\">semiring.to_semimodule.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_semiring.to_semiring.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_comm_semiring.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"n\">int.comm_ring</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>This one might be well-known. I think <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> reported similar issues before.</p>",
        "id": 229636319,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615373222
    },
    {
        "content": "<p>It is stopping some statement from typechecking in LTE. Is there a chance that we can fix this?</p>",
        "id": 229636385,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615373245
    },
    {
        "content": "<p>Using<code>local attribute [-instance] add_comm_group.int_module</code> so it doesn't appear in the first place is one solution</p>",
        "id": 229636879,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615373541
    },
    {
        "content": "<p>I think this is the diamond that <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>'s approach of redefining int/nat multiply might fix, although I don't recall whether their proposal worked for <code>int</code> too, or just <code>nat</code>.</p>",
        "id": 229636999,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615373636
    },
    {
        "content": "<p>The proposal is to redefine the definitions of both nat and int multiplication in core, to make sure that this precise diamond is defeq. I have never tried it because I don't know how to work on core.</p>",
        "id": 229639000,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615374676
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/issues/551\">lean#551</a></p>",
        "id": 229686506,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615391613
    },
    {
        "content": "<p>courage!</p>",
        "id": 229687757,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615391912
    },
    {
        "content": "<p>I wonder how big of a refactor this will be for mathlib</p>",
        "id": 229687804,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615391927
    },
    {
        "content": "<p>Depends on how often people (ab)use defeq of <code>m * 0 = 0</code> and the succ version.</p>",
        "id": 229688803,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615392101
    },
    {
        "content": "<p>I suspect it's rather on the other end: people didn't abuse defeq of <code>0 * m = 0</code> because it wasn't true. The change would make it possible to abuse it, but we won't notice because we already have the non-abusing proofs.</p>",
        "id": 229689585,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615392239
    },
    {
        "content": "<p>Case in point:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp, norm_cast]</span> <span class=\"kd\">theorem</span> <span class=\"n\">cast_mul</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">mul_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_zero</span><span class=\"o\">],</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">cast_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span>\n<span class=\"k\">show</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cast_mul</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">left_distrib</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mul_succ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 229690447,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615392410
    },
    {
        "content": "<p>I added the <code>convert</code>, because before, it would \"just work\"</p>",
        "id": 229690578,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615392436
    },
    {
        "content": "<p>The unfolded version of the new <code>nat.mul</code> / the current <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid.pow/src\">src#monoid.pow</a> is very ugly compared to the current <code>nat.mul</code>, most notably now involving <code>nat.brec</code>. Does this have bad consequences for speed of definitional reduction?</p>",
        "id": 229693303,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615393055
    },
    {
        "content": "<p>Why can't the equation compiler reduce <code>monoid.pow</code> to <code>nat.rec_on n 1 (λ _, (*) a)</code>?</p>",
        "id": 229694094,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615393306
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/tree/pechersky/mul-on-left\">branch#pechersky/mul-on-left</a></p>",
        "id": 229759479,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615415597
    },
    {
        "content": "<p>Seems like it build on my machine</p>",
        "id": 229759517,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615415619
    },
    {
        "content": "<p>That is, using the modified lean core. It should still work on regular lean, I think, because the proofs have been changed just to avoid the defeq <code>x * 0 = 0</code> mostly.</p>",
        "id": 229759697,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615415670
    },
    {
        "content": "<p>This mathlib branch now builds on both 3.27.0 and the dev-nat-mul-on-left without needing any changes to support either lean version. However, Johan's example is still not <code>rfl</code> in either version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">add_comm_group.int_module.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring.to_add_comm_group</span> <span class=\"n\">_</span> <span class=\"n\">int.ring</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">@</span><span class=\"n\">semiring.to_semimodule.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_semiring.to_semiring.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_comm_semiring.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"n\">int.comm_ring</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_instance</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Do you foresee that some other change is needed to make it work? I didn't change the defn of int-multiplication.</p>",
        "id": 229792234,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615437146
    },
    {
        "content": "<p>In fact, I'm not sure how core int mul would be changed. This is what I have on the <a href=\"https://github.com/leanprover-community/lean/issues/511\">lean#511</a> branch right now. To me, that just seems like a case-bash against the two constructors.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of_nat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">]</span>    <span class=\"o\">:=</span> <span class=\"n\">neg_of_nat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">]</span>    <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">neg_of_nat</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">]</span>    <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">]</span>    <span class=\"o\">:=</span> <span class=\"n\">of_nat</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 229792343,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615437246
    },
    {
        "content": "<p>Yes, you would also need to change int multiplication. What matters is that it is defeq to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/gsmul\">docs#gsmul</a> (in the sense that you can modify the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/gsmul\">docs#gsmul</a> if you like, to have two matching definitions). In particular, I don't think the int multiplication should case on the second variable: first, one should have the nat action on int, as on any semigroup, and then construct int multiplication from this.</p>",
        "id": 229808165,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615449137
    },
    {
        "content": "<p>You need a monoid for a nat action. Semigroups just have a pnat action, as observed by Damiano Testa recently.</p>",
        "id": 229808400,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615449325
    },
    {
        "content": "<p>I think nat should be renamed pnat_with_zero</p>",
        "id": 229808473,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615449370
    },
    {
        "content": "<p>You're right. I am using semigroup and monoid interchangeably in my head!</p>",
        "id": 229808491,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615449389
    },
    {
        "content": "<p>(I was saying \"you're right\" to your first line, not to the second one :-)</p>",
        "id": 229808507,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615449422
    },
    {
        "content": "<p>The fundamental object is pnat, proved by Euclid to be a free monoid on an infinite generating set. Then you make nat by adding a zero and defining a pathological <code>+</code> operation</p>",
        "id": 229811839,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615451252
    },
    {
        "content": "<p>You can tell it's pathological because Goldbach and twin primes are still open</p>",
        "id": 229811952,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615451295
    },
    {
        "content": "<p>Then shouldn't \\N be notation for pnat? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 229811993,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1615451328
    },
    {
        "content": "<p>Sure! That's how I used the notation for 30 years</p>",
        "id": 229812023,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615451345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/diamond/near/229811952\">said</a>:</p>\n<blockquote>\n<p>You can tell it's pathological because Goldbach and twin primes are still open</p>\n</blockquote>\n<p>I can't resist: <a href=\"https://themoreyouknow.github.io/div/\">https://themoreyouknow.github.io/div/</a></p>",
        "id": 229819812,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615455232
    },
    {
        "content": "<p>Here's one of the problems (thanks Eric for explaining). Why doesn't <code>rfl</code> work here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n\n<span class=\"c1\">-- dev branch</span>\n<span class=\"k\">#reduce</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">nat.mul</span> <span class=\"mi\">5</span> <span class=\"n\">k</span> <span class=\"c1\">-- λ (k : ℕ), ((((0.add k).add k).add k).add k).add k</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">nat.mul'</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">nat.mul'</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"k\">#reduce</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">nsmul</span> <span class=\"mi\">5</span> <span class=\"n\">k</span>    <span class=\"c1\">-- λ (k : ℕ), k.add (k.add (k.add (k.add k)))</span>\n<span class=\"k\">#reduce</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">nat.mul'</span> <span class=\"mi\">5</span> <span class=\"n\">k</span> <span class=\"c1\">-- λ (k : ℕ), k.add (k.add (k.add (k.add k)))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nsmul</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n.mul'</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- does not work??</span>\n</code></pre></div>",
        "id": 229858106,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615473426
    },
    {
        "content": "<p>Is that on master or on your branch?</p>",
        "id": 229860934,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615474374
    },
    {
        "content": "<p>(or is that irrelevant)?</p>",
        "id": 229861038,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615474412
    },
    {
        "content": "<p>For the <code>mul'</code> and <code>nsmul</code>, it is irrelevant. Here is that regular old <code>nat.mul</code> does on 3.27:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- 3.27 branch</span>\n<span class=\"k\">#reduce</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">nat.mul</span> <span class=\"mi\">5</span> <span class=\"n\">k</span> <span class=\"c1\">-- λ (k : ℕ), 5.mul k</span>\n</code></pre></div>",
        "id": 229861519,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615474564
    },
    {
        "content": "<p>It's not relevant for <code>mul'</code> and <code>nsmul</code> because both are defined via addition on the left</p>",
        "id": 229861602,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615474593
    },
    {
        "content": "<p>Even better (or worse?):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">nat.mul'</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">nat.mul'</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nsmul'</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">nsmul'</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"k\">#reduce</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">nsmul</span> <span class=\"mi\">5</span> <span class=\"n\">k</span>    <span class=\"c1\">-- λ (k : ℕ), k.add (k.add (k.add (k.add k)))</span>\n<span class=\"k\">#reduce</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">nat.mul'</span> <span class=\"mi\">5</span> <span class=\"n\">k</span> <span class=\"c1\">-- λ (k : ℕ), k.add (k.add (k.add (k.add k)))</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nsmul'</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">nat.mul'</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- does not work??</span>\n</code></pre></div>",
        "id": 229861826,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615474681
    },
    {
        "content": "<p>A way out is to avoid the equation compiler, which is just not good here, and use instead</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">nat.mul'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.rec_on</span> <span class=\"n\">n</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">rec</span><span class=\"o\">,</span> <span class=\"n\">rec</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nsmul'</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.rec_on</span> <span class=\"n\">n</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">rec</span><span class=\"o\">,</span> <span class=\"n\">rec</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nsmul'</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">nat.mul'</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nsmul'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">nat.mul'</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 229863411,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615475174
    },
    {
        "content": "<p>I would have thought that the way to define (a+1)b was ab+b rather than b+ab?</p>",
        "id": 229984363,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615531407
    },
    {
        "content": "<p>Okay, wow, I have the following working on dev lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">add_comm_group.int_module.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring.to_add_comm_group</span> <span class=\"n\">_</span> <span class=\"n\">int.ring</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">@</span><span class=\"n\">semiring.to_semimodule.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_semiring.to_semiring.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_comm_semiring.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"n\">int.comm_ring</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 230085188,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615577683
    },
    {
        "content": "<p>But -- is it worth it? Check out the <a href=\"https://github.com/leanprover-community/mathlib/tree/pechersky/mul-on-left\">branch#pechersky/mul-on-left</a></p>",
        "id": 230085224,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615577702
    },
    {
        "content": "<p>I removed many <code>multiplicative</code> proofs that (ab)used(?) defeq(?) I got lazy at the end and fell back to <code>convert multiplicative; try { ... }</code>.</p>",
        "id": 230085506,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615577827
    },
    {
        "content": "<p>What branch of lean are you working from?</p>",
        "id": 230085734,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615577933
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/issues/551\">lean#551</a> sorry, typo</p>",
        "id": 230085781,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615577961
    },
    {
        "content": "<p>My confusion is the same as CI's: <a href=\"https://github.com/leanprover-community/mathlib/compare/pechersky/mul-on-left#diff-037522102a2edcd0b33801a2dc6dc56ea0eacefd5bd58c17402eec520dff4fffR52\">https://github.com/leanprover-community/mathlib/compare/pechersky/mul-on-left#diff-037522102a2edcd0b33801a2dc6dc56ea0eacefd5bd58c17402eec520dff4fffR52</a>. Where is <code>nat.smul</code> defined?</p>",
        "id": 230086239,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615578179
    },
    {
        "content": "<p>(I think you can edit the <code>leanproject.yml</code> to point at your branch somehow, also)</p>",
        "id": 230086280,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615578200
    },
    {
        "content": "<p>Nice! Finally, you didn't need to change int multiplication?</p>",
        "id": 230086328,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615578227
    },
    {
        "content": "<p>No, I did:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">smul</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>       <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">smul</span> <span class=\"n\">n</span> <span class=\"n\">b</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.smul</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">smul</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_neg</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">m.smul</span>\n<span class=\"bp\">|</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">]</span>    <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">m.succ.smul</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_neg</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">int.neg</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">int.add</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"n\">int.smul</span>\n</code></pre></div>",
        "id": 230086508,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615578315
    },
    {
        "content": "<p>Testing now with your <code>nat.rec</code> style instead of eq compiler style.</p>",
        "id": 230086681,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615578389
    },
    {
        "content": "<p>So that I can have a branch of mathlib that compiles in both dev and 3.27 contexts.</p>",
        "id": 230086744,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615578418
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  what's the syntax to change the toml to a lean branch?</p>",
        "id": 230086773,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615578429
    },
    {
        "content": "<p>Wouldn't <code>smul n b + b</code> be closed to the current definition? I think swapping the order of that plus is making things hard for you.</p>",
        "id": 230086792,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615578432
    },
    {
        "content": "<p>I think you have to push a tag to your fork</p>",
        "id": 230086824,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615578449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> would know more</p>",
        "id": 230086843,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615578458
    },
    {
        "content": "<p>I did addition on left to style after the <code>pow</code> preference.</p>",
        "id": 230086926,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615578494
    },
    {
        "content": "<p>Perhaps pow should be defined as <code>nat.smul n (opposite.op (additive.of_mul x))</code></p>",
        "id": 230087099,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615578591
    },
    {
        "content": "<p>And then nsmul / pow can have different conventions</p>",
        "id": 230087143,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615578602
    },
    {
        "content": "<p>I guess my argument is more that you're changing two things at once, and it makes it hard to tell how much fallout each change is responsible for</p>",
        "id": 230087252,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615578644
    },
    {
        "content": "<p>I can't see the new definition of <code>int.mul</code> on the branch of <a href=\"https://github.com/leanprover-community/lean/issues/551\">lean#551</a>. I am probably not looking at the right branch.</p>",
        "id": 230088625,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615579258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/diamond/near/230086824\">said</a>:</p>\n<blockquote>\n<p>I think you have to push a tag to your fork</p>\n</blockquote>\n<p>Exactly. Once you've pushed a tag, github actions will automatically build and upload a release.  You can then refer to this release in the leanpkg.toml:</p>\n<div class=\"codehilite\" data-code-language=\"TOML\"><pre><span></span><code><span class=\"n\">lean_version</span> <span class=\"o\">=</span> <span class=\"s\">\"pechersky/lean:mytagname\"</span>\n</code></pre></div>",
        "id": 230088843,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1615579329
    },
    {
        "content": "<p>Ah apologies. OK I've pushed to the lean branch.</p>",
        "id": 230089157,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615579445
    },
    {
        "content": "<p>Thanks for pushing.</p>\n<p>I agree that <code>(n + 1) * a = n * a + a</code> is more natural that <code>(n + 1) * a = a + n * a</code>.</p>",
        "id": 230093240,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615581135
    },
    {
        "content": "<p>OK I'll test that instead. I realized recently that I had been checking for the module typeclass <code>rfl</code> proof via</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">convert</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>and that can fail even when <code>:= rfl</code> works. So perhaps not as many changes needed to happen as I made. But still, more proofs avoid defeq now so they'll work in either case. I'll see how brittle it is to switching the mul direction.</p>",
        "id": 230093531,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615581254
    },
    {
        "content": "<p><code>convert rfl</code> is extremely close to <code>congr'</code> which is better because it takes an optional numeral argument.</p>",
        "id": 230093703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615581354
    },
    {
        "content": "<p>But why would <code>convert rfl</code> leave with me with a <code>module Z Z</code> goal when <code> := rfl</code> just works?</p>",
        "id": 230093814,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615581397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/diamond/near/230093240\">said</a>:</p>\n<blockquote>\n<p>I agree that <code>(n + 1) * a = n * a + a</code> is more natural that <code>(n + 1) * a = a + n * a</code>.</p>\n</blockquote>\n<p>But that means that <code>1 * a</code> is not defeq to <code>a</code></p>",
        "id": 230095600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615582325
    },
    {
        "content": "<p>and, as more detail, with that definition, neither is <code>a * 1</code> defeq to <code>a</code></p>",
        "id": 230095863,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615582446
    },
    {
        "content": "<p>but we already have that neither a * 1 nor 1 * a are equal to a.</p>",
        "id": 230097092,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615582942
    },
    {
        "content": "<p><code>a * 1 = 0 + a</code> IIRC</p>",
        "id": 230097111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615582949
    },
    {
        "content": "<p>That's a very good point. Then I agree that <code>(n + 1) * a = a + n * a</code> is better!</p>",
        "id": 230097146,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615582967
    },
    {
        "content": "<p>who says <code>succ n</code> isn't <code>1 + n</code> anyway? :-)</p>",
        "id": 230097233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615583014
    },
    {
        "content": "<p>I have a dev lean build with the mul-on-right working, where I've fixed defeq proofs to be robust to both versions. Now I'm polishing away mathlib proofs that use that defeq. That will allow us to test one vs the other more easily.</p>",
        "id": 230097323,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615583051
    },
    {
        "content": "<p>It's true that currently neither of <code>1 * a</code> and <code>a * 1</code> are defeq to <code>a</code>. Having <code>1 * a = a</code> by defeq (and even <code>1 • a = a</code> in a monoid) looks like it couldn't hurt!</p>",
        "id": 230097822,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615583301
    },
    {
        "content": "<p>It might lead some computer scientists astray, they might abuse definitional equality</p>",
        "id": 230119019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615594219
    },
    {
        "content": "<p>What is the situation here? </p>\n<p>After Sebastien's heroic efforts we now have a new definition of <code>group</code> and <code>monoid</code>. Is there now still an argument for changing the definition of <code>int.mul</code>?</p>",
        "id": 236170586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619442733
    },
    {
        "content": "<p>I think the argument was to make <a href=\"https://leanprover-community.github.io/mathlib_docs/find/smul_eq_mul\">docs#smul_eq_mul</a> true by <code>rfl</code> for <code>nat</code> and <code>int</code></p>",
        "id": 236179416,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619445933
    },
    {
        "content": "<p><del>But I don't think there is a diamond any more to motivate this</del>. Edit: Hmm, that's already true by rfl, so I must be missing something.</p>",
        "id": 236179460,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619445948
    },
    {
        "content": "<p>My understanding is that my dev rebuilds and mathlib refactors were coming from the point of view of \"we can't change nsmul or gsmul, so let's change nat mul and int mul instead\". While Sebastien then said \"hey, why the restricted assumption that we can't change how we work with nsmul and gsmul\"?</p>",
        "id": 236179703,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619446033
    },
    {
        "content": "<p>Is the diamond behind <code>semiring.to_semimodule</code> and <code>add_comm_monoid.nat_semimodule</code> now defeq?</p>",
        "id": 236182871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619447193
    },
    {
        "content": "<p>No, this is not <code>rfl</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">add_comm_group.int_module.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring.to_add_comm_group</span> <span class=\"n\">_</span> <span class=\"n\">int.ring</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">@</span><span class=\"n\">semiring.to_module.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_semiring.to_semiring.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_comm_semiring.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"n\">int.comm_ring</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- nope</span>\n</code></pre></div>",
        "id": 236183452,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619447409
    },
    {
        "content": "<p>Then the problem is still there. The diamond problem that Sebastien solved was one that came up with composite types like <code>prod</code> and <code>tensor_product</code> where <code>add_comm_monoid.nat_semimodule</code> would form a diamond with itself, rather than a niche one that only really comes up when working heavily with nat.</p>",
        "id": 236184753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619447866
    },
    {
        "content": "<p>(or int)</p>",
        "id": 236185085,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619447984
    },
    {
        "content": "<p>Perhaps though this raises that the <code>subsingleton (module nat N)</code> instance needs to come back (it's now a <code>lemma</code>), since the problem isn't fully gone yet</p>",
        "id": 236185331,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619448063
    },
    {
        "content": "<p>This works for me (on master). Are you up to date?</p>",
        "id": 236196420,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619451334
    },
    {
        "content": "<p>Maybe I was using an outdated master</p>",
        "id": 236196586,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619451393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/diamond/near/236170586\">said</a>:</p>\n<blockquote>\n<p>What is the situation here? </p>\n<p>After Sebastien's heroic efforts we now have a new definition of <code>group</code> and <code>monoid</code>. Is there now still an argument for changing the definition of <code>int.mul</code>?</p>\n</blockquote>\n<p>There could still be an argument, if we wanted to refactor <code>nat.cast</code> and <code>int.cast</code>, replacing them with <code>n • 1</code> to get nice definitional behavior on most types. With this definition, if you want the cast from nat to itself to be equal to the identity definitionally, you would need to have <code>n * 1 = n</code>, which requires swapping multiplication. But this is way less important than before, since we got rid of all of our diamonds and this thing I mentioned would just require one additional rewrite in a few places.</p>",
        "id": 236197154,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619451626
    },
    {
        "content": "<p><a href=\"https://olive-caribou-rfe62wpk.ws-us03.gitpod.io/#/workspace/mathlib\">https://olive-caribou-rfe62wpk.ws-us03.gitpod.io/#/workspace/mathlib</a> indicates that yes, it is <code>rfl</code></p>",
        "id": 236199824,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619452710
    },
    {
        "content": "<p>I think you have to share a gitpod workspace by doing \"Gitpod: share workspace snapshot\" in the control+shift+p menu for us to see what you see, that link is private</p>",
        "id": 236201773,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1619453510
    },
    {
        "content": "<p>I see. In any case, it's just the example from above copied, and no errors.</p>",
        "id": 236206598,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619455666
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/lean-web-editor/#code=import%20algebra.module.basic%0A%0Aexample%20%3A%20%40add_comm_group.int_module.%7B0%7D%20int%20(%40ring.to_add_comm_group%20_%20int.ring)%20%3D%0A%20%20%40semiring.to_module.%7B0%7D%20int%0A%20%20%20%20(%40comm_semiring.to_semiring.%7B0%7D%20int%20(%40comm_ring.to_comm_semiring.%7B0%7D%20int%20int.comm_ring))%20%3A%3D%20rfl%20--%20yep%0A\">who needs gitpod</a></p>",
        "id": 236223437,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619462472
    }
]
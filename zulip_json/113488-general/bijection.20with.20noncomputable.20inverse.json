[
    {
        "content": "<p>There are some concepts which are obvious to computer scientists who have learnt some constructive logic but which are alien to mathematicians, and I am interested in explaining them to mathematicians.</p>\n<p>One of these concepts is the idea that there are types which don't have decidable equality. I think I've cracked this one. One can argue that the real numbers on either side of the equality at, say, <a href=\"https://mathoverflow.net/a/331385/1384\" target=\"_blank\" title=\"https://mathoverflow.net/a/331385/1384\">this answer</a> are clearly \"well-defined\" or \"computable to arbitrary accuracy\" or however mathematicians would like to think of it, but mathematicians can just as easily see that there is no \"one method\" which will answer all questions of this nature (as evidenced by the fact that apparently there is no known method which will answer that one).</p>\n<p>I want to do the same for bijections. Mathematicians still find it jarring that the concept of \"bijection\" and \"map with a two-sided inverse\" are not \"the same\" in Lean. I'd like to give an example of a bijection from the reals to the reals which is defined by an algorithm but for which there is no obvious algorithm to define the inverse. I'm assuming such a function exists -- does it? I'm also assuming that this question can be made precise (where \"real number\" becomes something like \"for all n, a rational number within 1/n of the real numbers\" or whatever; I'm hoping there are no issues here).</p>",
        "id": 167825286,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237194
    },
    {
        "content": "<p>an even simpler example of non-decidable equality is <code>nat -&gt; nat</code></p>",
        "id": 167825398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237280
    },
    {
        "content": "<p>I think mathematicians will prefer the real example. I'm not sure they understand what a Turing machine is.</p>",
        "id": 167825431,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237319
    },
    {
        "content": "<p>I am not talking about turing machines, I mean functions</p>",
        "id": 167825447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237343
    },
    {
        "content": "<p>Mathematicians are typically not taught what a computable function is.</p>",
        "id": 167825489,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237362
    },
    {
        "content": "<p>just regular functions</p>",
        "id": 167825529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237375
    },
    {
        "content": "<p>Well fair enough.</p>",
        "id": 167825540,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237396
    },
    {
        "content": "<p>to properly talk about decidability you need some notion of computing though</p>",
        "id": 167825545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237398
    },
    {
        "content": "<p>an informal sense is sufficient</p>",
        "id": 167825552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237413
    },
    {
        "content": "<p>I know but this is the hard part for mathematicians. The example with the reals I think gets the point across for decidability.</p>",
        "id": 167825567,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237431
    },
    {
        "content": "<p>\"if I can't decide it, how can a machine?\"</p>",
        "id": 167825570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237440
    },
    {
        "content": "<p>Maybe <code>nat -&gt; nat</code> is a place to look for computable bijections with a non-computable inverse?</p>",
        "id": 167825637,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237496
    },
    {
        "content": "<p>really? I find the idea that real numbers are not decidable at least a bit weird, given that we generally picture them as completed entities, where 1 = 2 in real is no different from 1 = 2 in nat</p>",
        "id": 167825642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237502
    },
    {
        "content": "<p>plus I can ask my calculator if real numbers are equal no problem</p>",
        "id": 167825657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237528
    },
    {
        "content": "<p>All I'm saying is that a mathematician will not even flinch when you say \"conjecture: some stupid sum of binomial coefficients is pi^7\"</p>",
        "id": 167825662,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237538
    },
    {
        "content": "<p>and then you can say \"hah! But both sides are well-defined real numbers, and we can't figure out if they're equal.\"</p>",
        "id": 167825683,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237566
    },
    {
        "content": "<p>conjecture: the function that maps all goldbach counterexamples to 1 and other stuff to 0 is the constant 0 function</p>",
        "id": 167825686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237573
    },
    {
        "content": "<p>I believe you</p>",
        "id": 167825694,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237584
    },
    {
        "content": "<p>I think it's easier to draw the parallel between Pi1 statements and equality of functions than equality of reals, but maybe that's the logician in me</p>",
        "id": 167825759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237629
    },
    {
        "content": "<p>and I can use this to give noncomputable bijections with noncomputable inverses</p>",
        "id": 167825762,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237633
    },
    {
        "content": "<p>does Goldbach help with the noncomputable inverse thing?</p>",
        "id": 167825780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237663
    },
    {
        "content": "<p>I don't know whether I have a convincing example for the bijection problem</p>",
        "id": 167825791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237676
    },
    {
        "content": "<p>Mathematicians don't know what a Pi1 statement is either.</p>",
        "id": 167825796,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237685
    },
    {
        "content": "<p>obviously don't say that</p>",
        "id": 167825804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237695
    },
    {
        "content": "<p>say goldbach or RH or something</p>",
        "id": 167825807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237702
    },
    {
        "content": "<p>We're so ignorant. Only the logicians know, and they're retiring and not being replaced.</p>",
        "id": 167825810,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237706
    },
    {
        "content": "<p>At least in the UK.</p>",
        "id": 167825815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237719
    },
    {
        "content": "<p>I mentioned the bijection between <code>option</code> and <code>roption</code> before, but I don't want to explain that one</p>",
        "id": 167825860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237733
    },
    {
        "content": "<p>Yes, I looked at that comment and even wrote the code constructing the equiv afterwards</p>",
        "id": 167825871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237757
    },
    {
        "content": "<p>I used your trick of subst to avoid heqs, IIRC</p>",
        "id": 167825879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237776
    },
    {
        "content": "<p>The problem is that you can't just use some simple type like <code>nat -&gt; nat</code> because you usually get obvious bijections, even if weird ones also exist</p>",
        "id": 167825894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237789
    },
    {
        "content": "<p>you have to put some strange subtype on the thing</p>",
        "id": 167825899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237803
    },
    {
        "content": "<p>you can embed <code>roption nat</code> in <code>nat -&gt; bool</code> as monotone sequences</p>",
        "id": 167825913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237832
    },
    {
        "content": "<p>and of course <code>option nat</code> is isomorphic to <code>nat</code></p>",
        "id": 167825978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237870
    },
    {
        "content": "<p>so perhaps that's a solution</p>",
        "id": 167825984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560237884
    },
    {
        "content": "<p>Thanks for these comments; I'll think more.</p>",
        "id": 167826009,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560237931
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">enat</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">enat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">to_bool_iff</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">le_succ_of_le</span> <span class=\"err\">$</span> <span class=\"o\">(</span><span class=\"n\">to_bool_iff</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>the inverse to <code>f</code> is noncomputable</p>",
        "id": 167826176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560238097
    },
    {
        "content": "<p>Oh I like that!</p>",
        "id": 167826351,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560238318
    },
    {
        "content": "<p>With the reals I was going round in circles thinking \"I need to have some sort of discontinuity, where a and b are a long way apart but f(a) and f(b) are close -- and yet aren't all computable functions continuous or some such nonsense?\"</p>",
        "id": 167826419,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560238379
    },
    {
        "content": "<p>Here we have the discontinuity with f(1000000000000) and f(0) looking very close for the first gazillion entries, and yet f is still computable.</p>",
        "id": 167826455,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560238419
    },
    {
        "content": "<p>I am quite good at \"silly little maths puzzles\" but I am much less good at these ones, because I have been brought up resolutely classical, so it's hard for me to tell the difference between option and roption. But because these are different things to you, you can tell which is which; they all just look like \"some countable set\" to me.</p>",
        "id": 167826630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560238572
    },
    {
        "content": "<p>This feels a bit like that embedding of nat into f : nat -&gt; nat from yesterday. These are somehow all implementation issues, computationally equivalent (but with different running times). I've never thought about these sorts of problems before in my life.</p>",
        "id": 167826680,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560238638
    },
    {
        "content": "<p>I've spent 25 years living in a world where \"computable\" = \"terminates instantly\" and I had <code>noncomputable theory</code> at the top of the file anyway.</p>",
        "id": 167826711,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560238678
    },
    {
        "content": "<p>I think of it topologically - <code>roption</code> looks like the set {1/n...} \\cup {0}</p>",
        "id": 167826712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560238680
    },
    {
        "content": "<p>It certainly does now.</p>",
        "id": 167826765,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560238698
    },
    {
        "content": "<p>so while there is an additional element, it isn't \"apart\" from the others, unlike <code>option</code> where it's a disjoint union</p>",
        "id": 167826792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560238740
    },
    {
        "content": "<p>The <code>dint</code> example is actually computably isomorphic to <code>int</code>, because the constraint is that the functions are basically translations, so you don't get any of this \"almost the same\" business - you can just evaluate the function at any point to find out what it translates 0 to</p>",
        "id": 167826891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560238833
    },
    {
        "content": "<p>Right. My point is that given <code>dint</code> you know where to put it -- \"it's the same as int\". But your notion of \"the same\" is more refined than mine -- for me, option and roption are the same, and for things like enat you know whether it's option nat or roption nat.  For me, they're just all nat, because I've never been asked to think in this way.</p>",
        "id": 167826979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560238932
    },
    {
        "content": "<p>surely you have a notion of topological distinctness though</p>",
        "id": 167826989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560238959
    },
    {
        "content": "<p>Oh <em>definitely</em>. I can certainly see that topologically they're not the same. I thought this was just an analogy though.</p>",
        "id": 167827001,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560238982
    },
    {
        "content": "<p>like there are different topologies on the same underlying points</p>",
        "id": 167827013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560238989
    },
    {
        "content": "<p>Sure.</p>",
        "id": 167827015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560238994
    },
    {
        "content": "<p>it's not an analogy at all, there is literally a topological structure</p>",
        "id": 167827022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560239006
    },
    {
        "content": "<p>If you'd asked me to give you a continuous bijection with a discontinuous inverse, between two countable sets, I would have given you this instantly.</p>",
        "id": 167827029,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560239025
    },
    {
        "content": "<p>I could well have given you that exact example in fact. But I don't see what this has to do with computability.</p>",
        "id": 167827093,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560239053
    },
    {
        "content": "<p>Domain theory is the branch of computer science that deals with putting topologies on all these types, such that the computable functions are continuous</p>",
        "id": 167827094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560239054
    },
    {
        "content": "<p>So if I put the topology on nat so that the closed sets are nat and the finite sets, what does domain theory tell me about that?</p>",
        "id": 167827125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560239106
    },
    {
        "content": "<p>That horrible non-Hausdorff topology is called the Zariski topology.</p>",
        "id": 167827146,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560239124
    },
    {
        "content": "<p>(sort-of)</p>",
        "id": 167827152,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560239132
    },
    {
        "content": "<p>I don't think you can obtain all topologies via domain theory; it's usually phrased in terms of monotone functions on a chain complete partial order</p>",
        "id": 167827327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560239294
    },
    {
        "content": "<p>So just these \"orderish\" ones like 0 union 1/n maybe.</p>",
        "id": 167827433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560239410
    },
    {
        "content": "<p>that said I can believe that your zariski example is representable</p>",
        "id": 167827445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560239436
    },
    {
        "content": "<p>It's what the topology on Spec(Z) is.</p>",
        "id": 167827465,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560239462
    },
    {
        "content": "<p>What about if I say every even number is less than every odd number, but on even numbers and on odd numbers it's the usual &lt;=?</p>",
        "id": 167827542,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560239525
    },
    {
        "content": "<p>the disjoint union of nat and nat</p>",
        "id": 167827548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560239539
    },
    {
        "content": "<p>omega+omega</p>",
        "id": 167827553,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560239552
    },
    {
        "content": "<p>with the order topology.</p>",
        "id": 167827557,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560239559
    },
    {
        "content": "<p>aha, you can do zariski</p>",
        "id": 167827687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560239724
    },
    {
        "content": "<p>you can take the representative of n to be a function which has 1 at <code>a, a+n, a+2n, ...</code> quotient over all choices of <code>a</code></p>",
        "id": 167827765,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560239787
    },
    {
        "content": "<p>the constraint is you should not ever be able to tell, given such a function, whether you actually have a representative of <code>n</code> or something else, but you can determine in finite time that two distinct elements are distinct</p>",
        "id": 167827880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560239903
    },
    {
        "content": "<p>The epistemological interpretation is that the open sets represent your knowledge of the function at some point in time; you can knock off finitely many natural numbers as not being the represented value so the open sets are cofinite</p>",
        "id": 167827989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560240011
    },
    {
        "content": "<p>It is possible to come up with arbitrary orders and interpret programming languages into those domains to get a funny model, but given a standard model you may not find your order represented</p>",
        "id": 167828109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560240172
    },
    {
        "content": "<p>The \"Furstenburg topology\" is the topology on Z induced from the profinite topology on the completion of Z; the closed sets are the arithmetic progressions.</p>",
        "id": 167828111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560240177
    },
    {
        "content": "<p>Anyway, this is just my mind wandering. Thanks for the roption example!</p>",
        "id": 167828154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560240224
    },
    {
        "content": "<p>I had no idea about this \"topological model\" of computability.</p>",
        "id": 167828217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560240251
    },
    {
        "content": "<p>it kind of reminds me of some quantum computations... you can calculate the period of a periodic function efficiently without being able to get particular values</p>",
        "id": 167828236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560240271
    },
    {
        "content": "<p>That's how they factor large integers!</p>",
        "id": 167828427,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560240408
    },
    {
        "content": "<p>right, I'm thinking of shor's algorithm</p>",
        "id": 167828437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560240424
    },
    {
        "content": "<p>maybe you can find a furstenburg topology in there</p>",
        "id": 167828463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560240461
    },
    {
        "content": "<p>Oh, the zariski example doesn't quite work, because you can determine n if you find a and then search for the next set value. But permuting the values is actually a much more effective approach. You let the representative of <code>n</code> be a bijection between <code>nat</code> and <code>nat - {n}</code> (quotient over all such). Then given any such function you can never find <code>n</code>, you can only eliminate possible candidates for <code>n</code> by enumerating the members</p>",
        "id": 167828809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560240766
    },
    {
        "content": "<p>Oh! I'm thinking too hard about this. The easy solution is to say that a representative is a monotone sequence of finsets whose union is <code>nat - {n}</code></p>",
        "id": 167829386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560241286
    },
    {
        "content": "<p>and you can do the same trick to get the Furstenburg topology - a representative of n is a sequence of pairs (ai,di) such that ai = n (mod di) for all i, and such that n is uniquely determined by the full sequence</p>",
        "id": 167829458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560241333
    },
    {
        "content": "<blockquote>\n<p>The epistemological interpretation is that the open sets represent your knowledge of the function at some point in time; you can knock off finitely many natural numbers as not being the represented value so the open sets are cofinite</p>\n</blockquote>\n<p>Exercise for Kevin: What familiar topology do you get appllying this to the entire type <code>nat -&gt; bool</code>?</p>",
        "id": 167833777,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560245520
    },
    {
        "content": "<p>I've been busy writing <a href=\"https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/\" target=\"_blank\" title=\"https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/\">https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/</a></p>",
        "id": 167835218,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560246830
    },
    {
        "content": "<p>I'm going to guess that it's just the profinite topology on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mi mathvariant=\"double-struck\">N</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.845223em;\"></span><span class=\"strut bottom\" style=\"height:0.845223em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845223em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathbb mtight\">N</span></span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 167835298,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560246872
    },
    {
        "content": "<p>The dumb algorithms will only end up evaluating functions at finitely many places</p>",
        "id": 167835347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560246915
    },
    {
        "content": "<p>So the issue seems to be whether there can be an algorithm which can end up evaluating functions at an arbitrarily large set of places and yet always be guaranteed to terminate.</p>",
        "id": 167835402,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560246964
    },
    {
        "content": "<p>I think you can rule that out with a compactness argument</p>",
        "id": 167835627,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560247188
    },
    {
        "content": "<p>Or Konig's lemma</p>",
        "id": 167835720,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560247244
    },
    {
        "content": "<p>So, in particular, pretty much any reasonable encoding of the p-adics will be assigned their usual profinite topology</p>",
        "id": 167836157,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560247677
    },
    {
        "content": "<p>I'm not sure if someone raised this above, but the space of infinite bit strings is the Cantor space 2^\\mathbb{N} with the product topology (which probably coincides with the profinite topology). This is a metric space, and you should think of computable things as being <em>uniformly</em> continuous functions. IIRC there is no uniformly continuous function that picks out the streams that eventually have  a 1, as opposed to the ones that don't (or at least, this is the fable I tell myself in my head)</p>",
        "id": 167846703,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560257635
    },
    {
        "content": "<p>I'd just come back to this thread with some more questions and perhaps David has answered one. </p>\n<p>So yes by the profinite topology I meant the product topology. I am a bit confused about the metric space claim. sure I can put a metric space structure on it -- but I am equally sure that I can put two different metric space structures on it such that the uniformly continuous functions on one do not coincide with the uniformly continuous functions on the other. Is a product of uniform spaces a uniform space? Isn't a continuous function from a compact space automatically uniformly continuous anyway?</p>\n<p>Reid, I am a bit confused about the logic of things here. I don't want to start using compactness arguments or Konig's lemma yet -- they are mathsy things so they don't see the notion of computability; they might see the notion of continuity, but I thought that's what we were trying to prove.</p>\n<p>The claim washing around here seems to be that computable functions from <code>nat -&gt; bool</code> are continuous (or now we have this rival bid of uniformly continuous). So what about computable functions <code>(nat -&gt; bool) -&gt; nat</code>? What topology am I supposed to be putting on <code>nat</code> here? If the discrete topology, then continuous image of compact is compact so all continuous functions have finite image. Do all computable functions <code>(nat -&gt; bool) -&gt; nat</code>have finite image? </p>\n<p>The general theorem can't be that the target always has the discrete topology though, becuase the identity function is a continuous function from <code>nat -&gt; bool</code> which has infinite image. </p>\n<p>What is going on here?</p>",
        "id": 167847998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560258501
    },
    {
        "content": "<p>In computable land, things are not so easy: <a href=\"https://link.springer.com/chapter/10.1007/11494645_3\" target=\"_blank\" title=\"https://link.springer.com/chapter/10.1007/11494645_3\">https://link.springer.com/chapter/10.1007/11494645_3</a></p>",
        "id": 167848256,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560258688
    },
    {
        "content": "<p>Also, it might be something like not functions from Cantor space but functions from functionals on Cantor space. It's a bit too late here for me, so I should look up some references tomorrow. Certainly work of Andrej Bauer and of Martin Escardo is relevant here.</p>",
        "id": 167848384,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560258786
    },
    {
        "content": "<p>One more potentially relevant reference and I may come back to this tomorrow: <a href=\"https://www.jstor.org/stable/27590306?seq=1#page_scan_tab_contents\" target=\"_blank\" title=\"https://www.jstor.org/stable/27590306?seq=1#page_scan_tab_contents\">https://www.jstor.org/stable/27590306?seq=1#page_scan_tab_contents</a></p>",
        "id": 167848534,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560258895
    },
    {
        "content": "<p>So you asked whether every computable (total) function from <code>nat -&gt; bool</code> to <code>bool</code> can only depend on the value of its argument at finitely many natural numbers.</p>",
        "id": 167849040,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560259291
    },
    {
        "content": "<p>Oh yes, that was a question I meant to flag up again. If I have a computable function <code>(nat -&gt; bool) -&gt; nat</code> then is there some <code>B</code> such that the computable function does not depend on the values of the function which are greater than <code>B</code>? Note that this is not true for <code>(nat -&gt; bool) -&gt; (nat -&gt; bool)</code> so I am a bit bewildered about what's going on here.</p>",
        "id": 167849263,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560259454
    },
    {
        "content": "<p>The argument is going to go something like this. Suppose <code>F : (nat -&gt; bool) -&gt; bool</code> is not of this form, that is, there is no N such that <code>F</code> is determined by the restriction of its argument <code>f</code> to numbers less than N. The only thing that <code>F</code> can do with <code>f</code> is evaluate it at various values. So suppose <code>F</code> starts out by evaluating <code>f</code> at some value <code>i</code>.</p>",
        "id": 167849313,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560259501
    },
    {
        "content": "<p>Aah, so the target is now <code>bool</code>? Is that always the target for these questions?</p>",
        "id": 167849366,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560259540
    },
    {
        "content": "<p><code>f</code> is going to return either <code>tt</code> or <code>ff</code>. Now in at least one of these two cases, <code>F</code> must still have the property that the result depends on infinitely many more values of <code>f</code>. (Otherwise, we could get a bound for the maximum index that <code>F</code> depends on.)</p>",
        "id": 167849481,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560259604
    },
    {
        "content": "<p>Let's say it's <code>tt</code>, and then mentally set <code>f i = tt</code> and continue running the algorithm. It has to next check the value of <code>f</code> at a new index <code>j</code>.</p>",
        "id": 167849618,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560259686
    },
    {
        "content": "<p>and again we can partially specify <code>f</code> in a way to ensure that <code>F</code> depends on infinitely many more of its values. (This is basically the proof of Konig's lemma happening here.)</p>",
        "id": 167849670,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560259747
    },
    {
        "content": "<p>Furthermore we may as well assume <code>j</code> is different from <code>i</code> since evaluating <code>f</code> at <code>i</code> again doesn't help <code>F</code>.</p>",
        "id": 167849782,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560259808
    },
    {
        "content": "<p>In this way we get an infinite sequence of constraints <code>f i0 = b0</code>, <code>f i1 = b1</code>, <code>f i2 = b2</code> ...<br>\nNow choose a function <code>f</code> which satisfies all these constraints (this is a form of compactness), and run the algorithm for <code>F</code> on this <code>f</code>--it has to run forever, a contradiction because we assumed that the algorithm was total.</p>",
        "id": 167849865,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560259895
    },
    {
        "content": "<p>If we removed random bits of the space <code>nat -&gt; bool</code>, we might not be able to do the step where we picked <code>f</code>. For example, <code>nat</code> can be embedded within <code>nat -&gt; bool</code> and then the argument would break down at that step</p>",
        "id": 167849993,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560259967
    },
    {
        "content": "<p>So if we stick to functions to <code>bool</code> we can guarantee they only query finitely many values, so they're continuous.</p>",
        "id": 167850070,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560260036
    },
    {
        "content": "<p>If you have a semidecidable subset of <code>nat -&gt; bool</code> then it's the union of the sets accepted by countably many functions <code>(nat -&gt; bool) -&gt; bool</code> (given by \"run the semidecision procedure for <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span></span></span></span> steps, and return true if it accepts, otherwise false\") and so it's an open subset.</p>",
        "id": 167850377,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560260229
    },
    {
        "content": "<p>This proof still works for <code>(nat -&gt; bool) -&gt; nat</code>, without any changes. It doesn't work for <code>(nat -&gt; bool) -&gt; (nat -&gt; bool)</code> because the values are now functions, which can delay the computation of <code>f</code> while still depending on infinitely many parts of it</p>",
        "id": 167885444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560283321
    },
    {
        "content": "<p>what you can say is that in any case, finitely many evaluations of <code>f</code> are performed before a value is produced</p>",
        "id": 167885575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560283394
    },
    {
        "content": "<p>Sure in any run only finitely many evaluations occur. The question is whether there is a uniform bound independent of the function. Reid proved that this was true for functions to <code>bool</code>. What about functions to <code>nat</code>?</p>",
        "id": 167886546,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560284199
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">enat</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">enat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"n\">to_bool_iff</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">le_succ_of_le</span> <span class=\"err\">$</span> <span class=\"o\">(</span><span class=\"n\">to_bool_iff</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>the inverse to <code>f</code> is noncomputable</p>\n</blockquote>\n<p>Except that this is not a bijection! The statement <code>function.surjective f</code> is equivalent to <code>∀ (p : nat → bool), (∃ n, p n = tt) ∨ (∀ n, p n = ff)</code> (provably in plain Lean) but the latter is a non-provable instance of the law of excluded middle. In fact, the inverse becomes definable in Lean with the (somewhat stronger) assumption <code>[decidable  (∃ n, p n = tt)]</code>.</p>\n<p>To return to <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s original question, what is missing from lean to prove that every bijection is invertible is the _Principle of Definite Description_, which is also known as the _Principle of Unique Choice_. In Lean, the Axiom of Choice is formulated as:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">axiom</span> <span class=\"n\">choice</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</pre></div>\n\n\n<p>The Axiom of Unique Choice can be formulated as follows:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">axiom</span> <span class=\"n\">unique_choice</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">subsingleton</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</pre></div>\n\n\n<p>Given a function <code>f : α → β</code>, <code>function.injective f</code> yields <code>Π (y : β), subsingleton { x :  α // f x = y }</code> and <code>function.surjective f</code> yields <code>Π (y : β), nonempty { x :  α // f x = y }</code> and thus <code>unique_choice</code> can be used to define the inverse.</p>\n<p>Unlike <code>choice</code>, which gives classical logic by Diaconescu's Theorem and hence many noncomputable functions <code>nat → nat</code>, <code>unique_choice</code> has no consequence on the logic of Prop and cannot be used to prove the existence of a noncomputable function <code>nat → nat</code> in Lean. It does have interesting properties on the type structure of Lean. The main consequence is that <code>unique_choice</code> allows <code>Prop</code> to eliminate into <code>Type</code> and since <code>Prop</code> is impredicative, this makes the whole hierarchy of types impredicative as well. So the real problem for inverting bijections is with predicativity rather than computability. Assuming <code>unique_choice</code> every bijection has an inverse, but <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>'s example is still not invertible since it is not provably bijective.</p>",
        "id": 167886986,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560284558
    },
    {
        "content": "<p>You can first prove that a computable function <code>(nat -&gt; bool) -&gt; nat</code> is bounded by the same kind of argument (otherwise we can construct an input for which the output exceeds N for every N).</p>",
        "id": 167887052,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560284631
    },
    {
        "content": "<p>Or since we already proved that computable functions to bool are continuous, consider the open cover by the sets <code>{f | F f = i}</code> and take a finite subcover.</p>",
        "id": 167887327,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560284855
    },
    {
        "content": "<blockquote>\n<p>Except that this is not a bijection! </p>\n</blockquote>\n<p>I can switch on some maths settings and then prove that it is, which surely means that it can't \"not [be] a bijection\" before -- it was just not <em>provably</em> a bijection or something.</p>",
        "id": 167888208,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560285515
    },
    {
        "content": "<p>But, for most of these settings, if you switch on those settings you can also prove that every bijection has an inverse!</p>",
        "id": 167888557,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560285773
    },
    {
        "content": "<p>em is weaker than full choice.</p>",
        "id": 167889424,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560286332
    },
    {
        "content": "<p>I don't think em implies bijections have an inverse.</p>",
        "id": 167889462,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560286364
    },
    {
        "content": "<p>Maths settings FTW</p>",
        "id": 167889564,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560286442
    },
    {
        "content": "<p>My claim has always been in the context of assume all classical axioms but not <code>noncomputable</code></p>",
        "id": 167889605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560286448
    },
    {
        "content": "<p>It's interesting. I always regard all of this non-maths stuff (computability, classicality) as just \"non-maths stuff\", but I am slowly beginning to be able to distinguish these various bogs from one another.</p>",
        "id": 167889669,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560286516
    },
    {
        "content": "<p>In constructive maths it is probably not possible, because a constructive proof that it is a bijection is basically an equiv</p>",
        "id": 167889679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560286522
    },
    {
        "content": "<p>I liked David Roberts' comment on my blog post -- if you think of functions as relations then one can prove that the inverse is a \"functional relation\" -- and yet it still doesn't arise from a function.</p>",
        "id": 167889791,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560286573
    },
    {
        "content": "<p>right, that's a good way to think about it</p>",
        "id": 167889811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560286593
    },
    {
        "content": "<p>In ZFC and classical first order logic is there a notion of computability?</p>",
        "id": 167889816,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560286598
    },
    {
        "content": "<p>[indicating my still huge level of ignorance]</p>",
        "id": 167889838,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560286617
    },
    {
        "content": "<p>because I thought that in ZFC a function was the same as a functional relation.</p>",
        "id": 167889862,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560286637
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>what you can say is that in any case, finitely many evaluations of <code>f</code> are performed before a value is produced</p>\n</blockquote>\n<p>Sure in any run only finitely many evaluations occur. The question is whether there is a uniform bound independent of the function. Reid proved that this was true for functions to <code>bool</code>. What about functions to <code>nat</code>?</p>\n</blockquote>\n<p>I mean that statement uniformly. For any computable closed term of <code>(nat -&gt; bool) -&gt; A</code>, there exists n such that the argument will be evaluated at most n times before the result becomes a value</p>",
        "id": 167889948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560286687
    },
    {
        "content": "<p>I see. But the value itself can depend on other arguments (e.g. <code>id</code> evaluates nothing and depends on everything)</p>",
        "id": 167890005,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560286746
    },
    {
        "content": "<p><code>id : (nat -&gt; bool) -&gt; (nat -&gt; bool)</code> does not evaluate the function <code>f</code> at all before returning <code>f</code></p>",
        "id": 167890056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560286802
    },
    {
        "content": "<p><code>f</code> is assumed to already be a value here (i.e. a lambda) since it was passed to <code>id</code></p>",
        "id": 167890130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560286828
    },
    {
        "content": "<p>the difference is that the meaning of \"value\" depends on the type in question</p>",
        "id": 167890187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560286866
    },
    {
        "content": "<p>for <code>nat -&gt; bool</code>, a value is something of the form <code>\\lam x : nat, e</code></p>",
        "id": 167890198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560286879
    },
    {
        "content": "<p>for <code>bool</code>, a value is either <code>tt</code> or <code>ff</code>, and for <code>nat</code> a value is <code>succ $ ... $ succ 0</code></p>",
        "id": 167890212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560286901
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  To be more precise with this last comment, it's totally fine to assume the full law of excluded middle in Prop. Since Prop can't eliminate into Type, you won't get any noncomputable functions out of that. But then you get into this awful scenario where you can prove the _existence_ of noncomputable functions <code>nat → nat</code> but you can't produce a single one: every closed term <code>nat → nat</code> is still computable. I find that scenario rather bizarre but I also like bizarre stuff... By the way, for the same reason, your question has a different answer if you ask for the _existence_ of an inverse rather than an actual term for the inverse.</p>",
        "id": 167890229,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560286922
    },
    {
        "content": "<p>there are noncomputable closed terms, e.g. unguarded use of <code>choice</code></p>",
        "id": 167890322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560286983
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>: Yes, that's my point. With <code>choice</code> every bijection has an inverse.</p>",
        "id": 167890406,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560287047
    },
    {
        "content": "<p>I'm talking about classical + computable though, where you are allowed to use <code>choice</code> but only to prove a proposition</p>",
        "id": 167890441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560287083
    },
    {
        "content": "<p>in particular that means that if you only ask for existence of an inverse it's easy since you just use choice to construct a noncomputable function, and then the exists shields the noncomputability</p>",
        "id": 167890490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560287135
    },
    {
        "content": "<p>Yes, then you can prove the _existence_ of an inverse but you can't get to the inverse without eliminating the proposition.</p>",
        "id": 167890494,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560287139
    },
    {
        "content": "<blockquote>\n<p>In ZFC and classical first order logic is there a notion of computability?</p>\n</blockquote>\n<p>No, except of course for the deep embedding, a.k.a the usual notion of computability by math/cs using turing machines or whatever</p>",
        "id": 167890640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560287242
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">bijective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I don't know how to prove this constructively :-(</p>",
        "id": 167890720,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560287294
    },
    {
        "content": "<p>The only constructor I know for exists is \"just show me the function\" and that's exactly what I can't do.</p>",
        "id": 167890742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560287325
    },
    {
        "content": "<p>the proof uses <code>choice</code></p>",
        "id": 167890750,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560287337
    },
    {
        "content": "<p>or at least <code>unique_choice</code></p>",
        "id": 167890792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560287372
    },
    {
        "content": "<p>oh I see, but it's still computable probably [goes to check]</p>",
        "id": 167890800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560287383
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n\n<span class=\"n\">def</span> <span class=\"n\">equiv_thing</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">bijective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">choose</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"kn\">using</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n  <span class=\"n\">use</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hg</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I love that <code>choose</code> tactic; it makes that argument so much easier than it used to be.</p>",
        "id": 167891429,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560287979
    },
    {
        "content": "<p>you can eta-reduce <code>fun y, hf.2 y</code></p>",
        "id": 167891515,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560288031
    },
    {
        "content": "<p>Eta reduction is defeq for pi types but not for inductive tires</p>",
        "id": 167891935,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560288421
    },
    {
        "content": "<p>did autocorrect change tyre to tire there?</p>",
        "id": 167891977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560288456
    },
    {
        "content": "<p>Maybe it's bed time, I seem to have spent all day thinking about type theory</p>",
        "id": 167892057,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560288504
    },
    {
        "content": "<p>eta reduction is defeq for inductive types, although sometimes lean gets confused</p>",
        "id": 167892112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560288549
    },
    {
        "content": "<p>hey, a reasonable application of <code>axiom_of_choice</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">equiv_thing</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">bijective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"bp\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">axiom_of_choice</span> <span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">in</span>\n<span class=\"bp\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"bp\">_</span><span class=\"o\">),</span> <span class=\"n\">hg</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 167892567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560288937
    },
    {
        "content": "<p>Personally I've always found <code>choice</code> philosophically dubious, and I'd much prefer to stick to <code>axiom_of_choice</code> plus <code>unique_choice</code> wherever possible</p>",
        "id": 167892809,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560289136
    },
    {
        "content": "<blockquote>\n<p>Personally I've always found <code>choice</code> philosophically dubious, and I'd much prefer to stick to <code>axiom_of_choice</code> plus <code>unique_choice</code> wherever possible</p>\n</blockquote>\n<p>I put that sort of comment in the same box as \"personally I find castling philosophically dubious in chess\". Isn't it all a game?</p>",
        "id": 167892853,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560289189
    },
    {
        "content": "<p>It's another part of the \"mathematicians' rules of conduct\" I guess. We don't make definitions that depend on which element <code>choice</code>produces.</p>",
        "id": 167892945,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560289261
    },
    {
        "content": "<blockquote>\n<p>eta reduction is defeq for inductive types, although sometimes lean gets confused</p>\n</blockquote>\n<p>The proof of <code>complex.eta</code> is not <code>rfl</code>, it's <code>cases, rfl</code></p>",
        "id": 167892962,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560289286
    },
    {
        "content": "<p>If you replace <code>choice</code> by <code>axiom_of_choice</code>+<code>unique_choice</code> then you're forced to prove, for example, that the dimension of a vector space does not depend on the choice of basis</p>",
        "id": 167893023,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560289334
    },
    {
        "content": "<p>oh, right there are multiple things called eta</p>",
        "id": 167893689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560289927
    },
    {
        "content": "<p>I'm not sure what I thought you meant</p>",
        "id": 167893700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560289951
    },
    {
        "content": "<p><code>axiom_of_choice</code> + <code>unique_choice</code> makes type theory look basically like ZFC</p>",
        "id": 167893748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560290001
    },
    {
        "content": "<p>However, it doesn't really affect proofs very much, you can just have a long lived hypothesis <code>variable [has_choice]</code> and do this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">universe</span> <span class=\"n\">u</span>\n<span class=\"n\">class</span> <span class=\"n\">has_choice</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">unchoice</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">[</span><span class=\"n\">has_choice</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}],</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"bp\">⟨</span><span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">axiom_of_choice</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n  <span class=\"k\">let</span> <span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">axiom_of_choice</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n    <span class=\"n\">exists_true_iff_nonempty</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"bp\">@</span><span class=\"n\">H</span> <span class=\"bp\">⟨</span><span class=\"n\">F</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 167894615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560290711
    },
    {
        "content": "<p>I think <code>choice</code> is the idea that since doing this is needless boilerplate we may as well just pick a global choice function</p>",
        "id": 167894735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560290826
    },
    {
        "content": "<p>It's harmless for proofs but not for definitions</p>",
        "id": 167895436,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560291490
    },
    {
        "content": "<p>for definitions, you can just put <code>[has_choice]</code> in the arguments to the definition</p>",
        "id": 167895787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560291849
    },
    {
        "content": "<blockquote>\n<p>em is weaker than full choice.</p>\n</blockquote>\n<p>Sorry <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>, I think an earlier reply was partly mistakenly written to Kevin instead of  you. You are totally right that EM for Prop is very weak and almost harmless. However, it becomes dangerous in combination with <code>unique_choice</code>, even locally!</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">section</span>\n<span class=\"kn\">parameter</span> <span class=\"n\">unique_choice</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">subsingleton</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">nonempty_decidable_of_em</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">h</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">nonempty</span><span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">is_true</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">nonempty</span><span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">is_false</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">subsingleton</span> <span class=\"c1\">-- show instance</span>\n\n<span class=\"n\">def</span> <span class=\"n\">decidable_of_em</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">unique_choice</span> <span class=\"o\">(</span><span class=\"n\">nonempty_decidable_of_em</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 167898728,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560294181
    },
    {
        "content": "<p>what's wrong with that? A mathematician would think that's fine</p>",
        "id": 167900106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560295412
    },
    {
        "content": "<p>it's basically saying that <code>if p then 1 else 0</code> exists</p>",
        "id": 167900119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560295430
    },
    {
        "content": "<p>which is a perfectly fine ZFC-ish thing to do</p>",
        "id": 167900221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560295507
    },
    {
        "content": "<p>it's just not computable</p>",
        "id": 167900226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560295512
    },
    {
        "content": "<p>Yes, 100% of mathematicians (including me!) believe in Unique Choice. But this is not about mathematics, it's about the type theory of Lean. The problem is that it systematically breaks predicativity, even locally. So if Lean insists on predicativity of Type, Unique Choice is not an option.</p>",
        "id": 167900398,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560295702
    },
    {
        "content": "<p>For what it's worth, I think Lean should have an \"impredicative mode\" where Unique Choice is true (but not full choice). This mode would make a lot of universe issues wash away, but it may have other consequences where ignoring props would trickle up to ignoring some types... This option needs a deeper look but it would match better with mathematics where types are also occasionally ignored.</p>",
        "id": 167900593,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560295996
    },
    {
        "content": "<p>This trickling, combined with simpler universe constraint calculations, might make typing undecidable. That's the main implementation issue.</p>",
        "id": 167901343,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560296692
    },
    {
        "content": "<p>Do you still want computability in your impredicative mode?</p>",
        "id": 167901557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560296952
    },
    {
        "content": "<p>because that basically means you can't erase anything</p>",
        "id": 167901568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560296965
    },
    {
        "content": "<p>so you lose the ability to have \"programs with assertions\"</p>",
        "id": 167901644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560297010
    },
    {
        "content": "<p>This is what actually happens in most HoTT libraries, but I don't think it's particularly practical for computation</p>",
        "id": 167901680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560297054
    },
    {
        "content": "<p><code>unique_choice</code> on its own doesn't make anything undecidable. But perhaps you want a computation rule such as <code>unique_choice _ _ &lt;a&gt; ~&gt; a</code></p>",
        "id": 167901767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560297125
    },
    {
        "content": "<p>I don't see it fixing any universe issues, although computation may end up doing weird things with universes</p>",
        "id": 167901817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560297201
    },
    {
        "content": "<p>Yes, that mode is for mathematics only. To obtain a computation, we would need to remove the mode and resolve the predicativity issues manually. In theory, this is possible but with the impredicative mode, Lean could accept things that are actually beyond what plain Lean can handle, so there is no choice but to do this process manually.</p>",
        "id": 167902383,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560297898
    },
    {
        "content": "<p>what are the impredicative constructions you envision?</p>",
        "id": 167902418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560297958
    },
    {
        "content": "<p>lean can already do impredicative stuff with Prop</p>",
        "id": 167902461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560297970
    },
    {
        "content": "<p>if you don't care about computation, then it seems like you can just have <code>choice</code>in Type and just ignore <code>noncomputable</code></p>",
        "id": 167902488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560298029
    },
    {
        "content": "<p>That doesn't work because noncomputable can't be eliminated, any derived term in Type* is noncomputable as well and must be marked that way. This can be mitigated by using type classes, but that only covers standardized ways of eliminating noncomputable axioms whereas the full process requires some creativity.</p>",
        "id": 167902984,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560298747
    },
    {
        "content": "<p>The larger issue is that Math Computable and Lean Computable mean different things. In mathematics, computable is a computation that _happens_ to always terminate, but plain Lean requires more. The mode I'm proposing is an in-between, where some principles such as <code>unique choice</code> are accepted as rules (because they are admissible) but not necessarily as axioms. Then the admissible rules could be eliminated manually, if needed, to get a plain term.</p>",
        "id": 167903262,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560299141
    },
    {
        "content": "<p>noncomputable can't be eliminated but it can be ignored</p>",
        "id": 167903786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560299578
    },
    {
        "content": "<p>actually you can trivially make noncomputable types computable</p>",
        "id": 167903809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560299610
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">axiom</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">def</span> <span class=\"n\">foo&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">id</span> <span class=\"n\">foo</span>\n</pre></div>",
        "id": 167903907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560299730
    },
    {
        "content": "<blockquote>\n<p>The larger issue is that Math Computable and Lean Computable mean different things. In mathematics, computable is a computation that _happens_ to always terminate, but plain Lean requires more.</p>\n</blockquote>\n<p>Actually, I would argue that lean's (non)<code>noncomputable</code> + classical axioms matches math computable pretty well. Here \"happens to terminate\" is expressed as \"classically proven to terminate\", which is not exactly the same because of the gap between provability and truth, but it's indistinguishable from within the system</p>",
        "id": 167904097,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560299979
    },
    {
        "content": "<p><code>unique_choice</code> is not admissible as a computable axiom, without changing the interpretation of Prop, but it is admissible as a noncomputable axiom if you think ZF is reasonable. Even <code>choice</code> is admissible as a noncomputable axiom if you think ZFC + some universes is reasonable</p>",
        "id": 167904287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560300213
    },
    {
        "content": "<p>I think <code>unique_choice</code> might still be admissible as a _rule_. I still don't know how it plays with inductive construction, which is just another bunch of rules (if you want to think about them that way) but rules aren't necessarily compatible.</p>",
        "id": 167904750,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560300754
    },
    {
        "content": "<p>what do you mean by \"as a rule\"?</p>",
        "id": 167904782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560300836
    },
    {
        "content": "<p>A deduction rule rather than as an axiom (an actual constant).</p>",
        "id": 167904925,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560300965
    },
    {
        "content": "<p>I don't see any way that a term constructor could end up differing in any essential way from a constant given all the other stuff in DTT</p>",
        "id": 167904947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560301000
    },
    {
        "content": "<p>If you allow a context in your rule, then I will just lambda abstract and build the constant</p>",
        "id": 167904991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560301071
    },
    {
        "content": "<p>Proofs are finite. Axioms are more powerful than rules.</p>",
        "id": 167905027,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560301083
    },
    {
        "content": "<p>Unless you put an unusual constraint on the rule, it's equivalent</p>",
        "id": 167905056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560301138
    },
    {
        "content": "<p>so I'm asking what the constraint is</p>",
        "id": 167905076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560301163
    },
    {
        "content": "<p>like usually stuff like <code>and.left</code> and <code>or.elim</code> are done as rules, but because DTT has lambda and app it makes no difference to introduce them as constants instead</p>",
        "id": 167905148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560301222
    },
    {
        "content": "<p>The actual rule for Unique Choice would require a new subsingleton judgment and the obvious accompanying rules (e.g. two elements of a subsingleton are definitionally equal, Pi's of subsingletons are subsingletons, and the unique choice rule). In plain Lean, these subsingletons could be universe ranked and all props would be automatic subsingletons. In the impredicative case, there could be a single subsingleton judgment, which would make unique choice work. I don't know if this is actually sound for Lean type theory. I think it would definitely make Lean less lean.</p>",
        "id": 167906800,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560303388
    },
    {
        "content": "<p>oh, you want an assumption of defeq?</p>",
        "id": 167907035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560303737
    },
    {
        "content": "<p>Yes, as it should be for mathematics...</p>",
        "id": 167907046,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560303781
    },
    {
        "content": "<p>Is it possible to prove something is a subsingleton, or is it a syntactic judgment?</p>",
        "id": 167907057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560303799
    },
    {
        "content": "<p>because if you can prove it then this makes the whole theory extensional</p>",
        "id": 167907073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560303831
    },
    {
        "content": "<p>It's just syntactic, that's the whole point. That way it could be eliminated from proof terms with some creative work.</p>",
        "id": 167907126,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560303862
    },
    {
        "content": "<p>so then what is a subsingleton that isn't already a prop?</p>",
        "id": 167907138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560303892
    },
    {
        "content": "<p>Well, this is going into speculation since I haven't worked out whether any of this makes sense for lean type theory. From the front end point of view, in the impredicative case, the subsingleton judgment would take the place of Prop and (hopefully) universe levels of subsingletons would simply wash away entirely. That would make the Lean front end essentially the same except that Props would eliminate into Type automatically.</p>",
        "id": 167907624,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560304612
    },
    {
        "content": "<p>The predicative case is more complicated, it would probably need a hierarchy of Prop* that parallels Type* and what eliminates where would be complicated. This is probably not worth it, but unique choice might still work.</p>",
        "id": 167907695,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560304700
    },
    {
        "content": "<p>Because subsingletons (aka props) are judgments, they can be tracked much better even in the impredicative case, which makes it plausible to undo this addition and \"manually\" work out a plain Lean term from an extended one. It's plain that adding this is sound because of the set theoretic model. Computational soundness is less clear but not bad. The one thing that worries me a lot is quotients, which can be used to produce subsingletons out of nowhere...</p>",
        "id": 167908024,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560305149
    },
    {
        "content": "<p>Then again, subsingleton judgments might give a better way of defining quotients...<br>\nThis all needs deeper thinking...</p>",
        "id": 167908094,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560305233
    },
    {
        "content": "<p>I'm still confused how (in the impredicative case) you have done anything different from renaming Prop to subsingleton</p>",
        "id": 167909400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560306909
    },
    {
        "content": "<p>Lean's <code>subsingleton</code> would still have to exist as a separate thing, since there are things that are only proven to be subsingletons, and AFAICT this doesn't make that part any different</p>",
        "id": 167909459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560306980
    },
    {
        "content": "<p>Except for universe level computations and elimination into type?</p>",
        "id": 167909488,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560307038
    },
    {
        "content": "<p>universe level computation meaning what</p>",
        "id": 167909493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560307059
    },
    {
        "content": "<p>I see, elimination into type meaning it's proof relevant?</p>",
        "id": 167909552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560307123
    },
    {
        "content": "<p>They disappear into subsingletons, which makes impredicativity happen and unique choice trivial.</p>",
        "id": 167909562,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560307132
    },
    {
        "content": "<p>Do you still expect em or axiom_of_choice?</p>",
        "id": 167909658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560307295
    },
    {
        "content": "<p>as you have pointed out this lets you build a <code>decidable p</code>, which breaks canonicity (to be fair, it's already broken but this makes it even easier)</p>",
        "id": 167909738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560307416
    },
    {
        "content": "<p>And actually this does break decidability of the typing relation as well, because if you have something like <code>X := if RH then 1 else 0</code> then if RH is provable we have <code>prop_decidable RH == of_true proof_of_RH</code> (defeq because <code>decidable</code> is a subsingleton, and we can set to be syntactically so) and hence <code>X == 1</code> definitionally</p>",
        "id": 167909968,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560307752
    },
    {
        "content": "<p>No, I don't. I expect terms that I can use but that other people can prove. If other people want AC, that's fine but I can't use their stuff for my work. Same goes for RH.</p>",
        "id": 167909977,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560307792
    },
    {
        "content": "<p>My point being that whether this term <code>X</code> is defeq to 1 or not actually depends on whether a proof of RH exists</p>",
        "id": 167910053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560307870
    },
    {
        "content": "<p>I could write <code>theorem proof_of_RH : X = 1 := rfl</code> and lean has to go find me a proof of RH</p>",
        "id": 167910060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560307911
    },
    {
        "content": "<p>yeah, I'm becoming increasingly convinced that <code>unique_choice</code> + definitional <code>subsingleton</code> will totally break the type system</p>",
        "id": 167910200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308122
    },
    {
        "content": "<p>unless you go full extensional, but lean needs more interaction modes for that</p>",
        "id": 167910256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308173
    },
    {
        "content": "<p>Yes, that's the issue: at some point typeability becomes undecidable. This is almost unavoidable in an impredicative system. However, this is where the creativity I mentioned earlier comes into play. To make this into a computable term, I have to decide RH...<br>\nBut the main point is that with a closed term in this impredicative system, I can isolate a finite number of proofs to resolve (with zero implication that I can).</p>",
        "id": 167910266,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560308202
    },
    {
        "content": "<p>It's quite possible that my proposal goes too far close to extensional type theory. My main goal is to go as far as possible in that direction without breaking anything significant.</p>",
        "id": 167910375,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560308378
    },
    {
        "content": "<p>The problem isn't merely that there are noncomputable things, it's the part where noncomputable things \"infect\" defeq so that you can't decide types</p>",
        "id": 167910384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308393
    },
    {
        "content": "<p>it means that <code>axiom</code> is not safe in this system</p>",
        "id": 167910447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308409
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 167910449,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560308412
    },
    {
        "content": "<p>Definitely. (But non-propositional constants are already unsafe.)</p>",
        "id": 167910490,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560308464
    },
    {
        "content": "<p>To be fair, that's kind of a weird requirement; most mathematicians would not be surprised that you can get garbage if you add arbitrary axioms, but you can't break defeq in lean even then</p>",
        "id": 167910501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308477
    },
    {
        "content": "<p>I think it's important for <code>unique_choice</code> to work that the proof of <code>nonempty</code> is proof relevant</p>",
        "id": 167910570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308545
    },
    {
        "content": "<p>being able to defeq change \"proofs\" around leads to lots of defeq things in Type, which is bad</p>",
        "id": 167910601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308602
    },
    {
        "content": "<p>A proof relevant version of nonempty would make unque choice trivial.</p>",
        "id": 167910602,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560308605
    },
    {
        "content": "<p>not exactly trivial; it might be a proof relevant subsingleton</p>",
        "id": 167910652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308652
    },
    {
        "content": "<p>I mean it's basically <code>trunc</code> at that point</p>",
        "id": 167910660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308672
    },
    {
        "content": "<p>It is, which makes it trivial.</p>",
        "id": 167910670,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560308697
    },
    {
        "content": "<p>I mean it implies the existence of quotient types and so on</p>",
        "id": 167910698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308728
    },
    {
        "content": "<p>but that's all in lean already so maybe it's not impressive</p>",
        "id": 167910706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308745
    },
    {
        "content": "<p>I'm always assuming quotients. That's 99% of why Lean is the best.</p>",
        "id": 167910757,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560308768
    },
    {
        "content": "<p>Part of my masters thesis was the discovery that even the very limited form of large elimination allowed in lean (to support <code>acc</code> and <code>eq</code>) causes problems</p>",
        "id": 167910767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308802
    },
    {
        "content": "<p>the large elimination rule is all about reasoning that an inductive type is \"basically a subsingleton\"</p>",
        "id": 167910781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308847
    },
    {
        "content": "<p>Link?</p>",
        "id": 167910785,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560308856
    },
    {
        "content": "<p><a href=\"https://github.com/digama0/lean-type-theory/releases\" target=\"_blank\" title=\"https://github.com/digama0/lean-type-theory/releases\">https://github.com/digama0/lean-type-theory/releases</a></p>",
        "id": 167910788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308869
    },
    {
        "content": "<p>section 3.1 is about how acc causes undecidability of the typing relation</p>",
        "id": 167910858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560308947
    },
    {
        "content": "<p>I see. I had read an earlier version but I see that there are new pieces I need to read. Thanks!</p>",
        "id": 167910866,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1560308966
    },
    {
        "content": "<p>OK, so here's a good discussion about the Cantor space and the property I was trying to think of, called 'searchability'</p>\n<p><a href=\"https://mathoverflow.net/a/330699/4177\" target=\"_blank\" title=\"https://mathoverflow.net/a/330699/4177\">https://mathoverflow.net/a/330699/4177</a></p>\n<p>This is 'inside the effective topos', but you can think of it as being in 'computable land' (or, apparently, 'Type I computability'). Essentially, there is no computable function 2^N \\to 2 = {0,1} that on input f:N\\to 2 outputs 1 if \\exists n with f(n)=1 and outputs 0 otherwise.</p>",
        "id": 167929191,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560331581
    },
    {
        "content": "<p>Perhaps ironically, I'm examining a thesis where the author would have done well to mention this stuff, but is coming from a rather different background, so seems unaware of it, so it's been on my mind, and I'm glad I needed to look up a good discussion on this stuff.</p>",
        "id": 167929259,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560331659
    },
    {
        "content": "<p>I don't think this summary is correct. It is all very confusing to me, but I think Andrej's argument only shows that in the internal logic of the effective topos there is no function which provably has the desired property. But in the original article <a href=\"http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/\" target=\"_blank\" title=\"http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/\">http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/</a> (on Andrej's own blog), there is demonstrated a program that does exactly that! I think the caveat is that one cannot <em>prove</em> that this program actually works from within the system.</p>",
        "id": 167939124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560340852
    },
    {
        "content": "<p>It's not really clear to me in what sense the functions in that blog post are functions except that you can program them in Haskell and they work</p>",
        "id": 167940861,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560342270
    },
    {
        "content": "<p>That seems to be strong evidence that they are computable functions</p>",
        "id": 167941164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560342497
    },
    {
        "content": "<p>what's not clear is whether they are total, but I can believe that as long as the input functions are computable, a modulus of continuity exists so it should halt</p>",
        "id": 167941184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560342541
    },
    {
        "content": "<p>Right, the question is what happens when the input function is not computable, but it's not clear that this question is even meaningful</p>",
        "id": 167941307,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560342625
    },
    {
        "content": "<p>of course, these functions are not allowed</p>",
        "id": 167941530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560342795
    },
    {
        "content": "<p>Obviously we can't assert this property, but we can observe that the function always halts from the meta level</p>",
        "id": 167941631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560342850
    },
    {
        "content": "<p>but that does mean that lean can't prove that it halts</p>",
        "id": 167941639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560342868
    }
]
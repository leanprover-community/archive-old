[
    {
        "content": "<p>Is every canonically ordered monoid automatically cancellative?</p>",
        "id": 169770164,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562425062
    },
    {
        "content": "<p>Probably not, because it isn't in mathlib.</p>",
        "id": 169770165,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562425072
    },
    {
        "content": "<p><code>with_top nat</code> is a counterexample</p>",
        "id": 169770380,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1562425351
    },
    {
        "content": "<p>Aha, thanks</p>",
        "id": 169770470,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562425510
    },
    {
        "content": "<p>No it isn't</p>",
        "id": 169770472,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1562425516
    },
    {
        "content": "<p>Why not?</p>",
        "id": 169770477,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562425534
    },
    {
        "content": "<p><code>fin n</code> with saturating addition is a counterexample</p>",
        "id": 169770478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562425536
    },
    {
        "content": "<p>Sorry it is.</p>",
        "id": 169770530,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1562425615
    },
    {
        "content": "<p>There isn't really anything in the definition that looks like a cancellation law. Notice that <code>lt_of_add_lt_add_left</code> is just the contrapositive of <code>add_le_add_left</code> for total orders</p>",
        "id": 169770589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562425687
    },
    {
        "content": "<p>Ok, thanks</p>",
        "id": 169770596,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562425723
    },
    {
        "content": "<p>The comment for <code>ordered_comm_monoid</code> is a lie</p>",
        "id": 169770659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562425823
    },
    {
        "content": "<p>I think it is trying to describe <code>ordered_cancel_comm_monoid</code></p>",
        "id": 169770676,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562425867
    },
    {
        "content": "<p>Right... I guess that might have added to the confusion for me.</p>",
        "id": 169771765,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562427962
    },
    {
        "content": "<p>Does it make sense to have a <code>canonically_ordered_cancel_monoid</code>?</p>",
        "id": 169771773,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562427980
    },
    {
        "content": "<p>I guess this is not provable:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">canonically_ordered_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ordered_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→</span><span class=\"err\">₀</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 169772017,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562428446
    },
    {
        "content": "<p>You need the cancellative thing</p>",
        "id": 169772019,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562428456
    },
    {
        "content": "<p>Talking of canonically ordered monoids,</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">canonically_ordered_monoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">ordered_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">order_bot</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_iff_exists_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>it occurred to me yesterday that this <code>le_iff_exists_add</code> axiom implies that that <code>0 ≤ b</code> for all <code>b</code>, which makes it surprising that Lean asks for the <code>lattice.order_bot</code>structure; it could be generated automatically, because one can prove that bot must be 0 from the other stuff.</p>",
        "id": 169777878,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562438542
    },
    {
        "content": "<p>I guess that I'm saying that instead of <code>canonically_ordered_monoid</code> extending <code>lattice.order_bot</code> it should not mention it at all, and then there should just be an instance making a lattice.order_bot from a canonically ordered monoid.</p>",
        "id": 169777958,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562438698
    },
    {
        "content": "<p>That's true, but you still want the structure to have both a bot and a zero. What if the structure already has a bot and a zero? Granted it's pretty unlikely that they are not defeq, but this definition permits it</p>",
        "id": 169777973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562438744
    },
    {
        "content": "<p>In any case I don't think that would be a very good instance - it is a kind of cross cutting thing, it will cause typeclass inference to get more complicated</p>",
        "id": 169778035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562438834
    },
    {
        "content": "<p>Then again, it's already an instance with this definition <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 169778039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562438863
    },
    {
        "content": "<p>So it seems to me that it should be like the lt in a preorder: <code>canonically_ordered_monoid</code> should not extend <code>lattice.order_bot</code> but it should ask for three fields, <code>le_iff_exists_add</code> and then <code>bot</code> but with the <code>:=</code> thing so that the user can define it if they want but if they don't it defaults to <code>zero</code>, and then a tactic can autogenerate <code>bot_le</code> if the user wants it to.</p>",
        "id": 169778093,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562438951
    },
    {
        "content": "<p>it is already doing basically that</p>",
        "id": 169778225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562439187
    },
    {
        "content": "<p>You can stick <code>(bot := 0)</code> at the end and I think it will work</p>",
        "id": 169778231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562439220
    },
    {
        "content": "<blockquote>\n<p>it is already doing basically that</p>\n</blockquote>\n<p>It's not, at least in the sense that if I write this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">canonically_ordered_comm_semiring</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">),</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">:=</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">:=</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">add_comm</span> <span class=\"o\">:=</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">),</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"n\">le_refl</span><span class=\"o\">,</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"n\">le_trans</span><span class=\"o\">,</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"n\">le_antisymm</span><span class=\"o\">,</span>\n  <span class=\"n\">add_le_add_left</span> <span class=\"o\">:=</span> <span class=\"n\">add_le_add_left</span><span class=\"o\">,</span>\n  <span class=\"n\">lt_of_add_lt_add_left</span> <span class=\"o\">:=</span> <span class=\"n\">lt_of_add_lt_add_left</span><span class=\"o\">,</span>\n<span class=\"c1\">--  bot := ⊥,</span>\n<span class=\"c1\">--  bot_le := bot_le,</span>\n  <span class=\"n\">le_iff_exists_add</span> <span class=\"o\">:=</span> <span class=\"n\">le_iff_exists_add</span><span class=\"o\">,</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">),</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:=</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:=</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span>\n  <span class=\"n\">left_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">left_distrib</span><span class=\"o\">,</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">right_distrib</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_mul</span> <span class=\"o\">:=</span> <span class=\"n\">zero_mul</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_zero</span> <span class=\"o\">:=</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:=</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_ne_one</span> <span class=\"o\">:=</span> <span class=\"n\">zero_ne_one</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_eq_zero_iff</span> <span class=\"o\">:=</span> <span class=\"n\">mul_eq_zero_iff</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>then, unsurprisingly, it says</p>\n<div class=\"codehilite\"><pre><span></span>invalid structure value { ... }, field &#39;bot&#39; was not provided\ninvalid structure value { ... }, field &#39;bot_le&#39; was not provided\n</pre></div>",
        "id": 169778373,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562439473
    },
    {
        "content": "<p>I don't want my player to have to worry about bot. I might just make another constructor.</p>",
        "id": 169778419,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562439524
    },
    {
        "content": "<p>I mean stick <code>(bot := 0)</code> in <code>canonically_ordered_monoid</code></p>",
        "id": 169778436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562439582
    },
    {
        "content": "<p>I think having a custom constructor would solve a lot of problems, but lean magic only works on the builtin constructor which makes this unattractive</p>",
        "id": 169778514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562439683
    },
    {
        "content": "<p>lean magic includes <code>i_just_proved_all_teh_theorems</code> or whatever it's called now (<code>structure_helper</code> I think)</p>",
        "id": 169778561,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562439734
    },
    {
        "content": "<p>One way to recover the structure notation is to have an auxiliary class with the arguments. <code>nonneg_comm_group</code> was my attempt at this, but I think in practice it ends up just being one more class in the hierarchy</p>",
        "id": 169778580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562439811
    },
    {
        "content": "<blockquote>\n<p>I mean stick <code>(bot := 0)</code> in <code>canonically_ordered_monoid</code></p>\n</blockquote>\n<p>In <code>preorder</code> we see</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_iff_le_not_le</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">order_laws_tac</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>So the question is how to prove <code>bot_le</code>;  I can't even right click on <code>order_laws_tac</code> to see what it's doing.</p>",
        "id": 169778841,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562440267
    },
    {
        "content": "<p>If clicking doesn't work you can always put it somewhere else, i.e. <code>#print order_laws_tac</code> and then click on it there</p>",
        "id": 169779588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562441735
    },
    {
        "content": "<p>it's basically <code>exact rfl</code></p>",
        "id": 169779592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562441750
    },
    {
        "content": "<p>Ordered monoids are a big mess, I think. They are partly \"locked\" into core. Lots of lemmas are duplicated. In core we don't have the <code>to_additive</code> machinery. Sometimes assumptions are unnecessary. Etc...</p>\n<p>It would be a big relief if this could be moved out of core and into mathlib. Is this at all an option? core probably needs that <code>nat</code> is an example of an ordered additive commutative monoid. But does that mean we need the general class in core?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">-- in core</span>\n<span class=\"n\">class</span> <span class=\"n\">ordered_cancel_add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n      <span class=\"kn\">extends</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">add_left_cancel_semigroup</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n              <span class=\"n\">add_right_cancel_semigroup</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">partial_order</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span>       <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">le_of_add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- #####################</span>\n\n<span class=\"c1\">-- in mathlib (on a local branch)</span>\n<span class=\"c\">/-</span><span class=\"cm\">- An ordered (additive) commutative monoid is a commutative monoid</span>\n<span class=\"cm\">  with a partial order such that addition is an order embedding, i.e.</span>\n<span class=\"cm\">  `a + b ≤ a + c ↔ b ≤ c`. These monoids are automatically cancellative. -/</span>\n<span class=\"n\">class</span> <span class=\"n\">ordered_add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">partial_order</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span>       <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_add_lt_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- An ordered commutative monoid is a commutative monoid</span>\n<span class=\"cm\">  with a partial order such that addition is an order embedding, i.e.</span>\n<span class=\"cm\">  `a * b ≤ a * c ↔ b ≤ c`. These monoids are automatically cancellative. -/</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">to_additive</span> <span class=\"n\">ordered_add_comm_monoid</span><span class=\"o\">]</span>\n<span class=\"n\">class</span> <span class=\"n\">ordered_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">partial_order</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_le_mul_left</span>       <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 195944387,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588325393
    },
    {
        "content": "<p>Without <code>to_additive</code> I fear that the multiplicative and additive versions will diverge, which doesn't seem like a good idea.<br>\nMoving <code>to_additive</code> into core would be one option. But I don't really like that idea, because it will become harder to change it...</p>",
        "id": 195959388,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588338825
    },
    {
        "content": "<p>It actually was in core once</p>",
        "id": 195959462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588338859
    },
    {
        "content": "<p>Therefore I would very much prefer moving these classes out of core and into mathlib...</p>",
        "id": 195959474,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588338871
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ordered.20monoids/near/195959462\" title=\"#narrow/stream/113488-general/topic/ordered.20monoids/near/195959462\">said</a>:</p>\n<blockquote>\n<p>It actually was in core once</p>\n</blockquote>\n<p>I guess it was moved out of it for a reason (-;</p>",
        "id": 195959482,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588338882
    },
    {
        "content": "<p>at least, a kind of crappy version of it was, and I wrote the current version and PR'd it, and Leo said no, so there is now a massive workaround in <code>algebra.group</code> to fix all the attributes that should be in core</p>",
        "id": 195959542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588338927
    },
    {
        "content": "<p>Why does core need <code>int</code> again? Shouldn't <code>nat</code> be enough?</p>",
        "id": 195959645,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588338984
    },
    {
        "content": "<p>it has special VM support</p>",
        "id": 195959655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588338997
    },
    {
        "content": "<p>I see.</p>",
        "id": 195959660,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339005
    },
    {
        "content": "<p>And why does it need lemmas about <code>nat</code> and <code>int</code>?</p>",
        "id": 195959673,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339016
    },
    {
        "content": "<p>Or would it be enough if it knew <code>has_add nat</code>?</p>",
        "id": 195959695,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339035
    },
    {
        "content": "<p>etc..</p>",
        "id": 195959698,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339038
    },
    {
        "content": "<p>It doesn't, I think</p>",
        "id": 195959702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339039
    },
    {
        "content": "<p>At least, I can't think of a reason off hand</p>",
        "id": 195959739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339068
    },
    {
        "content": "<p>So... could we move almost all of the algebraic hierarchy out of core?</p>",
        "id": 195959749,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339077
    },
    {
        "content": "<p>Or does <code>norm_num</code> need them?</p>",
        "id": 195959803,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339095
    },
    {
        "content": "<p>we don't need <code>ring int</code> in core, but we do need <code>ring</code> and <code>int</code> in core</p>",
        "id": 195959808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339100
    },
    {
        "content": "<p>Why <code>ring</code>?</p>",
        "id": 195959821,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339109
    },
    {
        "content": "<p>because it is used by <code>norm_num</code> lemmas</p>",
        "id": 195959832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339118
    },
    {
        "content": "<p>How many lemmas does <code>norm_num</code> need?</p>",
        "id": 195959853,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339135
    },
    {
        "content": "<p>several, but they are all quite basic</p>",
        "id": 195959872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339153
    },
    {
        "content": "<p>and purpose built</p>",
        "id": 195959888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339165
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/blob/master/library/init/algebra/norm_num.lean\" title=\"https://github.com/leanprover-community/lean/blob/master/library/init/algebra/norm_num.lean\">https://github.com/leanprover-community/lean/blob/master/library/init/algebra/norm_num.lean</a></p>",
        "id": 195960000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339241
    },
    {
        "content": "<p>Hmm... so it wants to know about <code>ordered_ring</code>s... that doesn't sound good.</p>",
        "id": 195960108,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339325
    },
    {
        "content": "<p>it wants to know an unbounded number of things about number theoretic functions, which is why <code>norm_num</code> in mathlib is so large</p>",
        "id": 195960148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339373
    },
    {
        "content": "<p>it's easy to scale back and move things around there</p>",
        "id": 195960170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339390
    },
    {
        "content": "<p>there is an open issue in my head to rewrite <code>tactic.norm_num</code> in lean</p>",
        "id": 195960218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339422
    },
    {
        "content": "<p>So... are there parts that could move to mathlib... or is norm_num locking it all up?</p>",
        "id": 195960228,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339432
    },
    {
        "content": "<p>there isn't really any reason to have it in C++ except possibly efficiency</p>",
        "id": 195960275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339445
    },
    {
        "content": "<p>as far as I know that's about it for algebra in the C++, except for the mysterious <code>@[algebra]</code> attribute</p>",
        "id": 195960344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339506
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/blob/master/library/init/algebra/classes.lean\" title=\"https://github.com/leanprover-community/lean/blob/master/library/init/algebra/classes.lean\">https://github.com/leanprover-community/lean/blob/master/library/init/algebra/classes.lean</a></p>",
        "id": 195960378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339538
    },
    {
        "content": "<p>Hmm... but we want <code>norm_num</code> to be efficient, right?</p>",
        "id": 195960387,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339544
    },
    {
        "content": "<p>It will be pretty efficient even in lean</p>",
        "id": 195960465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339576
    },
    {
        "content": "<p>this is not the kind of program that benefits greatly from native implementation</p>",
        "id": 195960487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339595
    },
    {
        "content": "<p>but we will have to do performance tests to see what the damage is</p>",
        "id": 195960526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339641
    },
    {
        "content": "<p>How much work do you estimate this to be?</p>",
        "id": 195960540,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339666
    },
    {
        "content": "<p>maybe 1/3 of mathlib's <code>norm_num</code></p>",
        "id": 195960629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339723
    },
    {
        "content": "<p>it's pretty straightforward what needs to be done</p>",
        "id": 195960648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339747
    },
    {
        "content": "<p>I meant: is this 1 day, 1 week, 1 month?</p>",
        "id": 195960668,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339769
    },
    {
        "content": "<p>1 day? If I actually do it on that day</p>",
        "id": 195960694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588339794
    },
    {
        "content": "<p>What do we need to do to make this issue in your head bubble to the top of your priority queue?</p>",
        "id": 195960767,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339834
    },
    {
        "content": "<p>I think maybe waiting a week or so would help</p>",
        "id": 195960810,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588339878
    },
    {
        "content": "<p>Because of your current refactor? Or what?</p>",
        "id": 195960889,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588339930
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> So... if I leave the definition of <code>ordered_add_comm_monoid</code> in core, do you think I can move almost all lemmas about it to mathlib?</p>",
        "id": 195963070,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588341434
    },
    {
        "content": "<p>The lemmas that <code>norm_num</code> needs are all in that file you linked to?</p>",
        "id": 195963087,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588341454
    },
    {
        "content": "<p>I believe so</p>",
        "id": 195963195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588341529
    },
    {
        "content": "<p>Ok, maybe that is the easiest way forward. Then I don't have to pester you about norm_num <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 195963234,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588341557
    },
    {
        "content": "<p>there is an official list of definitions used by the C++</p>",
        "id": 195963256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588341574
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/blob/master/src/library/constants.txt\" title=\"https://github.com/leanprover-community/lean/blob/master/src/library/constants.txt\">https://github.com/leanprover-community/lean/blob/master/src/library/constants.txt</a></p>",
        "id": 195963632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588341784
    },
    {
        "content": "<p>Oooh cool! That will be helpful!</p>",
        "id": 195963849,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588341913
    },
    {
        "content": "<p>Is it transitively closed?</p>",
        "id": 195963867,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588341930
    },
    {
        "content": "<p>I don't think so</p>",
        "id": 195963992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588342003
    },
    {
        "content": "<p>It shouldn't be</p>",
        "id": 195964010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588342020
    },
    {
        "content": "<p>these are constants that are directly referenced somewhere in C++</p>",
        "id": 195964039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588342040
    },
    {
        "content": "<p>Ok, would you mind writing 20 lines of lean code that will print the transitive closure?</p>",
        "id": 195964133,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588342094
    },
    {
        "content": "<p>It's probably almost the same as printing all the places a name is used... but not exactly</p>",
        "id": 195964158,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588342117
    },
    {
        "content": "<p>In the other thread you wrote</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">all</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"n\">run_cmd</span> <span class=\"n\">do</span>\n  <span class=\"n\">env</span> <span class=\"err\">←</span> <span class=\"n\">get_env</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">env</span><span class=\"bp\">.</span><span class=\"n\">fold</span> <span class=\"n\">mk_name_set</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">d</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">value</span><span class=\"bp\">.</span><span class=\"n\">fold</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"bp\">_</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">n</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span>\n        <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"bp\">`</span><span class=\"n\">with_zero</span><span class=\"bp\">.</span><span class=\"n\">ordered_add_comm_monoid</span> <span class=\"k\">then</span>\n          <span class=\"n\">name_set</span><span class=\"bp\">.</span><span class=\"n\">insert</span> <span class=\"n\">t</span> <span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">to_name</span>\n        <span class=\"k\">else</span> <span class=\"n\">t</span>\n      <span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">t</span>\n      <span class=\"kn\">end</span><span class=\"o\">),</span>\n  <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"n\">l</span>\n</code></pre></div>",
        "id": 195964284,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588342205
    },
    {
        "content": "<p>Let me see if I can adapt that code.</p>",
        "id": 195964293,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588342211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/ordered.20monoids/near/195963256\" title=\"#narrow/stream/113488-general/topic/ordered.20monoids/near/195963256\">said</a>:</p>\n<blockquote>\n<p>there is an official list of definitions used by the C++</p>\n</blockquote>\n<p>Note that this list is far from exhaustive.  For example, most definitions that are overridden in the VM don't appear there.  Or the definitions necessary for tactics.</p>",
        "id": 195965364,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1588342944
    },
    {
        "content": "<p>So... is there an automated way to figure out which lemmas can be moved to mathlib?</p>",
        "id": 195965690,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1588343143
    },
    {
        "content": "<p>I think the list in <code>constants.txt</code> is pretty accurate when it comes to lemmas.  It's just very incomplete for definitions.  However, first we need to excise <code>norm_num</code>.</p>",
        "id": 195968435,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1588344778
    },
    {
        "content": "<p>What do you think about adding a <code>@[magic]</code> attribute (naming TBD) that is required on all definitions or lemmas referenced in C++? It should be possible to check this from the C++ file that <code>constants.txt</code> generates, as well as in <code>DECLARE_VM_BUILTIN</code> and other macros that construct bindings</p>",
        "id": 196148724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588577652
    },
    {
        "content": "<p>I'm not enthusiastic.  This sounds like a lot of work.  If it's just about moving stuff to mathlib, the easiest approach is delete-test-move-back.  Tactics written in Lean also reference definitions and lemmas, should these be tagged with magic as well?</p>",
        "id": 196149602,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1588578352
    },
    {
        "content": "<p>no, this is just so that the lean code has a visible marker that its behavior is affected in some way by C++</p>",
        "id": 196149747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588578448
    },
    {
        "content": "<p>I really don't like that there is no evidence in the file that <code>nat.add</code> does something different than its definition and <code>mynat.add</code> is mysteriously much worse</p>",
        "id": 196149840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588578502
    },
    {
        "content": "<p>(the answer to the second question is no)</p>",
        "id": 196150047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588578669
    },
    {
        "content": "<p>maybe <code>@[extern_cpp]</code> is a better name</p>",
        "id": 196150091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588578708
    },
    {
        "content": "<p>Agda has something like that; they use the syntax <code>{-# BUILTIN #-}</code>. This allows the standard library to be a separate project from Agda itself (though with Lean's current release cadence, there'd be little benefit to that).</p>",
        "id": 196150201,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1588578790
    },
    {
        "content": "<p>I don't know of any language that doesn't have some sigil on builtins except lean</p>",
        "id": 196150228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588578819
    },
    {
        "content": "<p>Lean 4 uses <code>@[extern]</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> Nat basic instances -/</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">extern</span> <span class=\"s2\">&quot;lean_nat_add&quot;</span><span class=\"o\">]</span>\n<span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@&amp;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">@&amp;</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>I'd be oke with moving closer to Lean 4.</p>",
        "id": 196150235,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1588578823
    },
    {
        "content": "<p>although I am also interested in extending this beyond just VM builtins to things like lemmas with external linkage to C++</p>",
        "id": 196150312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588578884
    },
    {
        "content": "<p>perhaps that should be a separate attribute</p>",
        "id": 196150342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588578907
    },
    {
        "content": "<p>I don't know whether it is necessary or useful to put the C++ name of the extern function in the attribute. Unlike lean 4, you can't really use those names to call the function in lean 3</p>",
        "id": 196150435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588578971
    },
    {
        "content": "<p>so you would still need the <code>DECLARE_VM_BUILTIN</code> macro, and the best you could do is double check that the names declared in both places match</p>",
        "id": 196150467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588579010
    },
    {
        "content": "<p>I think <code>@[extern]</code> without c++ function name would be fine.</p>",
        "id": 196150474,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1588579021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/113488-general/topic/ordered.20monoids/near/196150201\" title=\"#narrow/stream/113488-general/topic/ordered.20monoids/near/196150201\">said</a>:</p>\n<blockquote>\n<p>Agda has something like that; they use the syntax <code>{-# BUILTIN #-}</code>. This allows the standard library to be a separate project from Agda itself (though with Lean's current release cadence, there'd be little benefit to that).</p>\n</blockquote>\n<p>Well, there seems to be good reason to move core theorems and definitions to mathlib. I think the main blocker to moving builtins out of core is that it would break the tests. How does Agda do tests?</p>",
        "id": 196150876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588579292
    },
    {
        "content": "<p>I don't know the codebase too well, but from what I recall, the Agda setup is this: Agda ships with a super minimal 'builtin library' containing only the builtins. The tests import these and define a few other things in a 'test standard library'. The real standard library that users work with also imports the builtins and builds on them. One could probably also ignore the builtin library completely, instead binding the builtins manually, but I don't know why one would.</p>\n<p>With that said, Agda has way less builtins than Lean, so the ergonomics are probably different.</p>",
        "id": 196153637,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1588581103
    }
]
[
    {
        "content": "<p>Just proved <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mo>(</mo><mi>P</mi><mo>∨</mo><mi>Q</mi><mo>)</mo><mspace width=\"0.277778em\"></mspace><mo>⟺</mo><mspace width=\"0.277778em\"></mspace><mi mathvariant=\"normal\">¬</mi><mi>P</mi><mo>∧</mo><mi mathvariant=\"normal\">¬</mi><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">\\neg (P \\lor Q ) \\iff \\neg P \\land \\neg Q</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathrm\">¬</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin\">∨</span><span class=\"mord mathit\">Q</span><span class=\"mclose\">)</span><span class=\"mrel\"><span class=\"mspace thickspace\"></span><span class=\"mrel\">⟺</span></span><span class=\"mord mathrm\"><span class=\"mspace thickspace\"></span><span class=\"mord mathrm\">¬</span></span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin\">∧</span><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\">Q</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>P</mi><mo>∨</mo><mi mathvariant=\"normal\">¬</mi><mi>Q</mi><mo>→</mo><mi mathvariant=\"normal\">¬</mi><mo>(</mo><mi>P</mi><mo>∧</mo><mi>Q</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\neg P \\lor \\neg Q \\to \\neg (P \\land Q)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin\">∨</span><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\">Q</span><span class=\"mrel\">→</span><span class=\"mord mathrm\">¬</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin\">∧</span><span class=\"mord mathit\">Q</span><span class=\"mclose\">)</span></span></span></span> in Lean. I don't see why the converse would require classical logic though. Can someone please explain?</p>",
        "id": 136299566,
        "sender_full_name": "Ken Lee",
        "timestamp": 1540246251
    },
    {
        "content": "<blockquote>\n<p>Just proved <span class=\"tex-error\">$$\\not (P \\and Q ) \\iff \\not P \\and \\not Q$$</span> and <span class=\"tex-error\">$$\\not P \\or \\not Q \\to \\not (P \\and Q)$$</span> in Lean. I don't see why the converse would require classical logic though. Can someone please explain?</p>\n</blockquote>\n<p>Oh no. It didn't format the inline maths.</p>",
        "id": 136299609,
        "sender_full_name": "Ken Lee",
        "timestamp": 1540246286
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mo>(</mo><mi>P</mi><mo>∧</mo><mi>Q</mi><mo>)</mo><mspace width=\"0.277778em\"></mspace><mo>⟺</mo><mspace width=\"0.277778em\"></mspace><mi mathvariant=\"normal\">¬</mi><mi>P</mi><mo>∧</mo><mi mathvariant=\"normal\">¬</mi><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">\\neg (P \\land Q ) \\iff \\neg P \\land \\neg Q</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathrm\">¬</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin\">∧</span><span class=\"mord mathit\">Q</span><span class=\"mclose\">)</span><span class=\"mrel\"><span class=\"mspace thickspace\"></span><span class=\"mrel\">⟺</span></span><span class=\"mord mathrm\"><span class=\"mspace thickspace\"></span><span class=\"mord mathrm\">¬</span></span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin\">∧</span><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\">Q</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>P</mi><mo>∨</mo><mi mathvariant=\"normal\">¬</mi><mi>Q</mi><mo>→</mo><mi mathvariant=\"normal\">¬</mi><mo>(</mo><mi>P</mi><mo>∧</mo><mi>Q</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\neg P \\lor \\neg Q \\to \\neg (P \\land Q)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin\">∨</span><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\">Q</span><span class=\"mrel\">→</span><span class=\"mord mathrm\">¬</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin\">∧</span><span class=\"mord mathit\">Q</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 136299662,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540246323
    },
    {
        "content": "<p><code>\\neg (P \\land Q ) \\iff \\neg P \\land \\neg Q$$ and $$\\neg P \\lor \\neg Q \\to \\neg (P \\land Q)</code></p>",
        "id": 136299665,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540246325
    },
    {
        "content": "<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mo>(</mo><mi>P</mi><mo>∧</mo><mi>Q</mi><mo>)</mo><mspace width=\"0.277778em\"></mspace><mo>⟺</mo><mspace width=\"0.277778em\"></mspace><mi mathvariant=\"normal\">¬</mi><mi>P</mi><mo>∧</mo><mi mathvariant=\"normal\">¬</mi><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">\\neg (P \\land Q ) \\iff \\neg P \\land \\neg Q</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathrm\">¬</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin\">∧</span><span class=\"mord mathit\">Q</span><span class=\"mclose\">)</span><span class=\"mrel\"><span class=\"mspace thickspace\"></span><span class=\"mrel\">⟺</span></span><span class=\"mord mathrm\"><span class=\"mspace thickspace\"></span><span class=\"mord mathrm\">¬</span></span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin\">∧</span><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\">Q</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>P</mi><mo>∨</mo><mi mathvariant=\"normal\">¬</mi><mi>Q</mi><mo>→</mo><mi mathvariant=\"normal\">¬</mi><mo>(</mo><mi>P</mi><mo>∧</mo><mi>Q</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\neg P \\lor \\neg Q \\to \\neg (P \\land Q)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin\">∨</span><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\">Q</span><span class=\"mrel\">→</span><span class=\"mord mathrm\">¬</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mbin\">∧</span><span class=\"mord mathit\">Q</span><span class=\"mclose\">)</span></span></span></span></p>\n</blockquote>\n<p>Thanks!</p>",
        "id": 136299713,
        "sender_full_name": "Ken Lee",
        "timestamp": 1540246384
    },
    {
        "content": "<p>related question: more generally, how does one go about determining whether a proof can be done constructively?</p>",
        "id": 136301162,
        "sender_full_name": "Jean Lo",
        "timestamp": 1540248059
    },
    {
        "content": "<p>If it implies excluded middle then it can't be done constructively. There's an exercise somewhere proving a whole load of things imply excluded middle.</p>",
        "id": 136301256,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1540248233
    },
    {
        "content": "<p>but that is not necessary.</p>",
        "id": 136301345,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540248330
    },
    {
        "content": "<p>you can't check every Kripke model though... is there some finite subset that we can check</p>",
        "id": 136301420,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540248403
    },
    {
        "content": "<p>there is a completeness result that says any intuitionistically invalid statement is false on a finite kripke model</p>",
        "id": 136301599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540248688
    },
    {
        "content": "<p>that makes set of intuitionstically valid theorems a Π1 set, thus a Δ1 set?</p>",
        "id": 136301662,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540248771
    },
    {
        "content": "<p>yes, so it is decidable</p>",
        "id": 136301672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540248797
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132889\">@Jean Lo</span>  Here is a basic strategy for checking that various simple things can't be done constructively. First observe that all the rules of constructive logic apply when \"truth values\" are...something like...open sets in a topological space (I hope I remembered this right). You model \"not\" as \"interior of the complement\" and \"implies\" as \"is a subset of\". Then some stuff like \"P or not P\" simply isn't true in this interpretation, because the union of an open set and the interior of its complement might not be the whole space.</p>",
        "id": 136301676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1540248818
    },
    {
        "content": "<p>does this together with the 14-theorem give you a fast(er) way of determining stuff?</p>",
        "id": 136301727,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540248855
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Kuratowski%27s_closure-complement_problem\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Kuratowski%27s_closure-complement_problem\">https://en.wikipedia.org/wiki/Kuratowski%27s_closure-complement_problem</a></p>",
        "id": 136301729,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540248869
    },
    {
        "content": "<p>It's not complete, unfortunately</p>",
        "id": 136301731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540248876
    },
    {
        "content": "<p>at least not unless you consider all topologies</p>",
        "id": 136301735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540248891
    },
    {
        "content": "<p>I don't know, but I don't know what a Kripke model is and yet I've used this way of thinking about things to convince myself that certain propositions can't be proved in classical logic and basically it's the only way I know to do such a thing.</p>",
        "id": 136301744,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1540248908
    },
    {
        "content": "<p>just consider the Kuratowski algebra?</p>",
        "id": 136301745,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540248909
    },
    {
        "content": "<p>A Kripke model is based on a kind of epistemological interpretation of the formulas. There are a bunch of points called \"worlds\", and at each point there are things that are known to be true at that world, but the things that are not known to be true are just unknowns. There is a \"in the future\" accessibility relation to other worlds where more things may be known (but previously known things are still known), and things are known to be false only if they are never known in the future</p>",
        "id": 136301848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540249073
    },
    {
        "content": "<p>I don't think Kevin cares</p>",
        "id": 136301894,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540249100
    },
    {
        "content": "<p>For example, suppose we have time 0 and time 1, and at time 0 nothing is known and at time 1 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\">p</span></span></span></span> is known. Then at time 0 neither <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\">p</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">\\neg p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\">p</span></span></span></span> is known</p>",
        "id": 136301904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540249132
    },
    {
        "content": "<p>This semantics generalizes nicely to modal logic as well, where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">□</mi><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\Box A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord amsrm\">□</span><span class=\"mord mathit\">A</span></span></span></span> means A is known now and henceforth in the future</p>",
        "id": 136302025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540249302
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">□</mi></mrow><annotation encoding=\"application/x-tex\">\\square</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.675em;\"></span><span class=\"strut bottom\" style=\"height:0.675em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord amsrm\">□</span></span></span></span> <code>\\square</code></p>",
        "id": 136302083,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540249349
    },
    {
        "content": "<p>My intuition regarding <code>¬(p ∧ q) → ¬p ∨ ¬q</code> is that, as my assumption, I know \"<code>p</code> and <code>q</code> aren't <em>both</em> true\", but I don't know <em>which one</em> is false, and the conclusion requires me to pick one of the two and prove it's false, which I cannot do</p>",
        "id": 136302094,
        "sender_full_name": "Scott Olson",
        "timestamp": 1540249373
    },
    {
        "content": "<p>ah, is that the program interpretation</p>",
        "id": 136302122,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540249439
    },
    {
        "content": "<p>yeah, interpreting <code>∧</code> as a pair type and <code>∨</code> as a sum type</p>",
        "id": 136302208,
        "sender_full_name": "Scott Olson",
        "timestamp": 1540249508
    },
    {
        "content": "<p>I think the corresponding model is where at time 0 nothing is known, at time 1a we know q, and at time 1b we know p.</p>",
        "id": 136302213,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540249522
    },
    {
        "content": "<p>The kripke model for this one has three points, with time 0 where nothing is known and a branching future. In world 1, p is known, and in world 2 q is known. Then since <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi><mo>∧</mo><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">p\\land q</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.55556em;\"></span><span class=\"strut bottom\" style=\"height:0.75em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\">p</span><span class=\"mbin\">∧</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">q</span></span></span></span> is true in no world, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mo>(</mo><mi>p</mi><mo>∧</mo><mi>q</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\neg(p\\land q)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathrm\">¬</span><span class=\"mopen\">(</span><span class=\"mord mathit\">p</span><span class=\"mbin\">∧</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">q</span><span class=\"mclose\">)</span></span></span></span> is true in every world, but neither <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">\\neg p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\">p</span></span></span></span> nor <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">\\neg q</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">q</span></span></span></span> is true in world 0</p>",
        "id": 136302267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540249564
    },
    {
        "content": "<p>:)</p>",
        "id": 136302274,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540249571
    },
    {
        "content": "<p>Interesting, I've never heard of that stuff but it lines up really well with what I did in my head</p>",
        "id": 136302330,
        "sender_full_name": "Scott Olson",
        "timestamp": 1540249663
    },
    {
        "content": "<p>I think you can consider the more general <code>((p ∧ q) → r) → (p → r) ∨ (q → r)</code> and use the same model</p>",
        "id": 136302335,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540249669
    },
    {
        "content": "<p>yes</p>",
        "id": 136302374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540249683
    },
    {
        "content": "<p>cool</p>",
        "id": 136302405,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540249696
    },
    {
        "content": "<p>There is no single finite model complete for intuitionistic logic though, or equivalently there is an infinite family of truth values over one proposition</p>",
        "id": 136302409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540249701
    },
    {
        "content": "<p>or maybe \"truth values\" just don't make sense</p>",
        "id": 136302427,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540249720
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>h : (p ∧ q) → false\n⊢ (p → false) ∨ (q → false)\n</pre></div>\n\n\n<p>(expanding the \\not to the function to false)</p>\n<p>I can either assume <code>p</code> or assume <code>q</code> (the two worlds) and then prove <code>false</code>, but I can't apply the function <code>h</code> with just one of them</p>",
        "id": 136302429,
        "sender_full_name": "Scott Olson",
        "timestamp": 1540249721
    },
    {
        "content": "<p><a href=\"https://upload.wikimedia.org/wikipedia/commons/5/5c/Rieger-Nishimura.svg\" target=\"_blank\" title=\"https://upload.wikimedia.org/wikipedia/commons/5/5c/Rieger-Nishimura.svg\">https://upload.wikimedia.org/wikipedia/commons/5/5c/Rieger-Nishimura.svg</a></p>",
        "id": 136302449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540249754
    },
    {
        "content": "<p>what is thsi</p>",
        "id": 136302461,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540249767
    },
    {
        "content": "<p>I saw this image for the first time like three days ago and I was very confused about how I had never seen it before</p>",
        "id": 136302472,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540249785
    },
    {
        "content": "<p>it is the lattice of propositions over one variable</p>",
        "id": 136302478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540249790
    },
    {
        "content": "<p>up to equivalence</p>",
        "id": 136302485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540249798
    },
    {
        "content": "<p>in classical logic it is much less interesting, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">⊥</mi><mo>&lt;</mo><mi>p</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">¬</mi><mi>p</mi><mo>&lt;</mo><mi mathvariant=\"normal\">⊤</mi></mrow><annotation encoding=\"application/x-tex\">\\bot &lt; p,\\neg p &lt; \\top</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathrm\">⊥</span><span class=\"mrel\">&lt;</span><span class=\"mord mathit\">p</span><span class=\"mpunct\">,</span><span class=\"mord mathrm\">¬</span><span class=\"mord mathit\">p</span><span class=\"mrel\">&lt;</span><span class=\"mord mathrm\">⊤</span></span></span></span></p>",
        "id": 136302539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540249820
    },
    {
        "content": "<p>interesting</p>",
        "id": 136302543,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540249828
    },
    {
        "content": "<p>the program interpretation is to let <code>p</code> to mean <code>X contains 1</code> and <code>q</code> to mean <code>X contains no 1</code> where <code>X</code> is an arbitrary (computable) binary sequence, right?</p>",
        "id": 136302586,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540249889
    },
    {
        "content": "<p>that's one way to do it</p>",
        "id": 136302662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540249971
    },
    {
        "content": "<p>But if you like the program (aka BHK) formulation of intuitionistic semantics, then you might like the computational interpretation of peirce's law as call with continuation</p>",
        "id": 136302766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540250059
    },
    {
        "content": "<p>I never understood what call/cc means</p>",
        "id": 136302777,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540250082
    },
    {
        "content": "<p>The type is <code>callcc : ((p -&gt; q) -&gt; p) -&gt; p</code>. Suppose we are building something of type N, say, and in the course of it we want to do double negation elimination on some proposition <code>p</code>, like say \"this TM halts\". Then that means we are going to do something with this value of type <code>p</code>, so that's a function <code>p -&gt; N</code>, and so callcc steals this \"continuation\" and passes it to the enclosed function of type <code>(p -&gt; N) -&gt; p</code></p>",
        "id": 136302993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540250321
    },
    {
        "content": "<p>For example, consider the following implementation of <code>em</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">constant</span> <span class=\"n\">callcc</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">p</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">p</span>\n\n<span class=\"n\">def</span> <span class=\"n\">em</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"err\">⊕</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">empty</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">callcc</span> <span class=\"bp\">_</span> <span class=\"n\">empty</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n<span class=\"k\">show</span> <span class=\"n\">p</span> <span class=\"err\">⊕</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">empty</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"err\">$</span>\n<span class=\"k\">show</span> <span class=\"n\">p</span> <span class=\"err\">⊕</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">empty</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">hp</span>\n</pre></div>\n\n\n<p>This function looks like magic when you see it for the first time. It's a computational interpretation of EM! So we can just put in our favorite nondecidable proposition to this oracle, like the Riemann hypothesis, and find out the answer. It calls <code>callcc</code> at this point, which remembers our position in the code, and then calls the <code>sum.inr</code> constructor. So the oracle says: RH is false! We are happy until we find out maybe that RH is actually true, and in justified anger return to our function to prove a contradiction. When we call the function though, it calls <code>H</code> with <code>sum.inl hp</code>. What happened? The function <code>H</code> remembers when we called callcc the first time, and \"rewinds time\" with our proof of RH in hand. So the oracle says: RH is true! and it stole our proof.</p>",
        "id": 136303945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540251274
    },
    {
        "content": "<blockquote>\n<p>our favorite nondecidable proposition to this oracle, like the Riemann hypothesis</p>\n</blockquote>\n<p>hmm...</p>",
        "id": 136304147,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540251559
    },
    {
        "content": "<p>I guess this is like \"innocent until proven guilty\", we have \"false until proven true\"</p>",
        "id": 136304242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540251664
    },
    {
        "content": "<p>I still don't understand what it does... thanks for your lengthy explanation though</p>",
        "id": 136304249,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540251669
    },
    {
        "content": "<p>The semantics is a bit tricky to explain without a notion of \"continuation\"</p>",
        "id": 136304262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540251693
    },
    {
        "content": "<p>the idea is that every expression exists in a context, where you are evaluating an expression <em>in order to pass it to something else</em></p>",
        "id": 136304322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540251730
    },
    {
        "content": "<p>and this something else can be thought of as a function from the type of the expr to the \"final output\"</p>",
        "id": 136304335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540251751
    },
    {
        "content": "<p>which can be whatever, it doesn't really matter</p>",
        "id": 136304340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540251761
    },
    {
        "content": "<p>it's like an expression with a hole in it where our expr goes</p>",
        "id": 136304349,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540251784
    },
    {
        "content": "<p>and <code>callcc</code> saves this expr-with-hole that surrounds the <code>callcc f</code> expression itself, and calls <code>f</code> on it</p>",
        "id": 136304376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540251827
    },
    {
        "content": "<p>This enables bizarre behavior like returning twice from a function or functions that call each other as coroutines, or exception handling</p>",
        "id": 136304463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540251937
    },
    {
        "content": "<p>lots of control flow can be expressed using continuations</p>",
        "id": 136304470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540251955
    },
    {
        "content": "<p>what kind of thing is call/cc?</p>",
        "id": 136304536,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540252022
    },
    {
        "content": "<p>is it a function that we can implement? is it a function that only exists in some alternate programming language?</p>",
        "id": 136304544,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540252039
    },
    {
        "content": "<p>it isn't a function you can implement in lean, but it is a function that could conceivably be supported in the VM as a primitive</p>",
        "id": 136306080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540254088
    },
    {
        "content": "<p>Could you write your RH thing in say <code>Scheme</code>?</p>",
        "id": 136318157,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540275598
    },
    {
        "content": "<p>yes</p>",
        "id": 136318356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540275857
    },
    {
        "content": "<p>I think they are the pioneers of callcc</p>",
        "id": 136318362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540275879
    },
    {
        "content": "<p>then what would it return?</p>",
        "id": 136318441,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540275995
    },
    {
        "content": "<p>like I said, \"false\" until you prove it wrong</p>",
        "id": 136318449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540276040
    },
    {
        "content": "<p>and then it goes back in time with your proof and says \"true\"</p>",
        "id": 136318453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540276058
    },
    {
        "content": "<p>do you have actual Scheme code?</p>",
        "id": 136318501,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540276094
    },
    {
        "content": "<p>no, but you should just be able to use <code>callcc</code> in a term like I've shown</p>",
        "id": 136318508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540276126
    },
    {
        "content": "<p>the lean code should translate without issue to scheme</p>",
        "id": 136318521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540276162
    },
    {
        "content": "<p>there is also the matter of scheme not being a typed language</p>",
        "id": 136318583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540276222
    },
    {
        "content": "<p>if the time travel is the part that is surprising, a more pedestrian explanation is that it just saves the current state of the VM - the call stack and values of the variables, then we can later \"reset\" to this execution state</p>",
        "id": 136318709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540276493
    },
    {
        "content": "<p>how does the program \"take\" our proof?</p>",
        "id": 136318715,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540276511
    },
    {
        "content": "<p>you pass it to the function in an attempt to derive false</p>",
        "id": 136318717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540276533
    },
    {
        "content": "<p>and rather than producing a proof of false, it abandons the entire execution of the rest of the program and resets with this proof in hand</p>",
        "id": 136318761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540276564
    },
    {
        "content": "<p>does <code>callcc</code> have any equational lemmas?</p>",
        "id": 136318779,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540276637
    },
    {
        "content": "<p>yes, but they are a bit weird because they depend on the execution context</p>",
        "id": 136318784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540276658
    },
    {
        "content": "<p>You have to set up the idea of a dynamic semantics. Let's say we want to evaluate <code>e1 + e2</code>, we can write this as <code>e1 + e2 &lt; K</code>where <code>K</code> is the call stack. It is expecting a value of type <code>nat</code> say, here. So we first evaluate <code>e1</code>, that is, <code>e1 &lt; _ + e2, K</code> where we have pushed <code>_ + e2</code> on the stack. We get to a value <code>v &gt; _ + e2, K</code> (the arrow is reversed to indicate that the value is done computing) which steps to <code>e2 &lt; v + _, K</code>. That is we are evaluating <code>e2</code> now. This finishes to <code>v2 &gt; v + _, K</code> which steps to <code>v' &gt; K</code> where <code>v'</code> is the actual result of adding numbers <code>v</code> and <code>v2</code></p>",
        "id": 136318985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540276926
    },
    {
        "content": "<p>I don't understand how you can pass the proof to the function</p>",
        "id": 136319003,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540276935
    },
    {
        "content": "<p>the function doesn't accept things of type <code>p</code> right</p>",
        "id": 136319008,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540276947
    },
    {
        "content": "<p>it wants a thing of type <code>(p -&gt; q) -&gt; p</code></p>",
        "id": 136319009,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540276957
    },
    {
        "content": "<p>In the <code>em</code> example I define a particular function of type <code>(p -&gt; false) -&gt; p</code></p>",
        "id": 136319021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540276991
    },
    {
        "content": "<p>or rather <code>(p + not p -&gt; false) -&gt; p + not p</code></p>",
        "id": 136319037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540277019
    },
    {
        "content": "<p>so when the callcc is called it evaluates this function giving it a kind of magic function which has type <code>p + not p -&gt; false</code></p>",
        "id": 136319085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540277065
    },
    {
        "content": "<p>this function should not ever be called, because it \"destroys the universe\" rather than producing a proof of false</p>",
        "id": 136319152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540277171
    },
    {
        "content": "<p>Here's another example. If <code>f : (N -&gt; false) -&gt; N</code> is the constant function 42, then <code>callcc f</code> just returns 42. Nothing special happens as long as <code>f</code> never uses its argument</p>",
        "id": 136319316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540277435
    },
    {
        "content": "<p>But if <code>f = \\lam g, false.elim (g 12)</code>, then <code>callcc f</code> returns 12</p>",
        "id": 136319330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540277475
    },
    {
        "content": "<p>how?</p>",
        "id": 136319335,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540277515
    },
    {
        "content": "<p>and if <code>f = \\lam g, false.elim (g 12) + false.elim (g 13)</code>?</p>",
        "id": 136319377,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540277554
    },
    {
        "content": "<p>returns 12</p>",
        "id": 136319379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540277561
    },
    {
        "content": "<p>the rest of the computation is abandoned once <code>g</code> is called</p>",
        "id": 136319386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540277586
    },
    {
        "content": "<p>hmm...</p>",
        "id": 136319394,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540277618
    },
    {
        "content": "<p>The function <code>g</code> given to <code>f</code> is actually the expr-with-hole that <code>callcc f</code> is situated in</p>",
        "id": 136319395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540277619
    },
    {
        "content": "<p>it might make more sense if <code>g</code> is called <code>throw</code> instead</p>",
        "id": 136319465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540277716
    },
    {
        "content": "<p>and <code>callcc</code> is <code>catch</code></p>",
        "id": 136319468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540277723
    }
]
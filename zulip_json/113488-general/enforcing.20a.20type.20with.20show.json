[
    {
        "content": "<p>Sometimes, you want to tell Lean that a term has some type, but even type annotations are not enough because Lean sees them but it discards them right away as it has its own opinion on what the type is, so why should it listen to you. I've just seen a trick in Yury's PR <a href=\"https://github.com/leanprover-community/mathlib/issues/4199\">#4199</a> where Lean has no choice but listen to you. Maybe it's a standard trick, but it was new to me so I thought I could share it here. The idea is to first give the type with <code>show</code>, and then the term:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">range_rec</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat.rec</span> <span class=\"n\">x</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat.rec</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n\n<p>Lean is happy with this, while I don't know how to make it happy only with type annotations.</p>",
        "id": 211104518,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1600937832
    },
    {
        "content": "<p>In fact, I can do it with type annotations:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">range_rec</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat.rec</span> <span class=\"n\">x</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">nat.rec</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n\n<p>But still it's a good trick to know.</p>",
        "id": 211104804,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1600938027
    },
    {
        "content": "<p>Note that <code>show</code> leaves \"junk\" (an identity function) in the term, unlike type annotations. This is actually the reason behind the difference in behavior</p>",
        "id": 211140728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600958416
    },
    {
        "content": "<p>so you should be careful doing this in things like simp lemmas</p>",
        "id": 211140840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600958466
    }
]
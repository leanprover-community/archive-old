[
    {
        "content": "<p>Something that has been talked about many times before is having a variant on <code>finset</code> that's \"for mathematics\" (i.e., ignores issues of computability/decidability). There's a design with seemingly good definitional properties that's been rattling around my mind for a while that I spent some time today developing out to see how it might work.</p>\n<p>Here's an overview of the design:</p>\n<ul>\n<li>We keep <code>finset</code> as a data type for use in computation (and perhaps it is renamed to reflect its intended use and properties).</li>\n<li>We replace <code>set.finite</code> with a predicate that says that there exists a finset with the same elements:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">set.is_finite</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_finset</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>\n<ul>\n<li>We define a bundled <code>finite_set</code> type implementing <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set_like\">docs#set_like</a>, and because all the <code>finset</code> business is in a <code>Prop</code> we can hide away computational issues using <code>classical</code> while making the carrier set have nice definitional properties.</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Bundled finite sets -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">finite_set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finite</span> <span class=\"o\">:</span> <span class=\"n\">carrier.is_finite</span><span class=\"o\">)</span>\n</code></pre></div>\n<ul>\n<li>We replace <code>fintype</code> with a <code>Prop</code>-valued predicate, allowing us to avoid diamond problems:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">finite_type</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">univ_finite</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span><span class=\"o\">)</span>\n</code></pre></div>\n<ul>\n<li>To work with unbundled finite sets, we use <code>[finite_type s]</code> just like how we are already using <code>[fintype s]</code>, but now <code>s.to_finite_set</code> has the nice property that it <em>definitionally</em> coerces to <code>s</code>.</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">set.to_finite_set</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">finite_type</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">finite_set.mk</span> <span class=\"n\">s</span>\n<span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">finite_set.univ</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite.to_finset.map</span> <span class=\"o\">(</span><span class=\"n\">function.embedding.subtype</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">set.coe_to_finite_set</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">finite_type</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s.to_finite_set</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<ul>\n<li>We can still talk about computation by introducing instances for computing specific sets as <code>finset</code>s. We can compute specific <code>finite_set</code>s too by giving <code>has_finset</code> instances for them (since they coerce to <code>set</code>).</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Class for computing a `finset` for a `set`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_finset</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_finset</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">eq_to_finset</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">to_finset</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 282193391,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652406091
    },
    {
        "content": "<p><em>(code <a href=\"#narrow/stream/113488-general/topic/bundled.20finite.20sets.20.28no.20decidable.20instances.29/near/282195508\">below</a>)</em></p>",
        "id": 282193399,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652406108
    },
    {
        "content": "<p>For defining operations on <code>finite_set</code>, the pattern is to</p>\n<ol>\n<li>Define a <code>set.is_finite</code> constructor for the given set, for instance</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_finite.inter</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.is_finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨⟨</span><span class=\"n\">hs.to_finset</span> <span class=\"bp\">∩</span> <span class=\"n\">ht.to_finset</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">}⟩⟩</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>This involves giving a corresponding <code>finset</code> construction.</p>\n<ol start=\"2\">\n<li>Define the <code>finite_set</code> operation, for instance</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_inter</span> <span class=\"o\">(</span><span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">set.is_finite.inter</span> <span class=\"n\">s.finite</span> <span class=\"n\">t.finite</span><span class=\"o\">⟩⟩</span>\n</code></pre></div>\n<p>This is simply a matter of bundling the <code>is_finite</code> operation.</p>\n<ol start=\"3\">\n<li>Provide extensionality lemmas, for instance</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_inter</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n</code></pre></div>",
        "id": 282193689,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652406429
    },
    {
        "content": "<p>For lifting operations on sets to computations on <code>finset</code>s, then one can also define some instances for set operations.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">s.get_finset</span> <span class=\"bp\">∩</span> <span class=\"n\">t.get_finset</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>The <code>has_finset</code> class is the <code>set</code>/<code>finset</code> analogue to <code>decidable_eq</code>, which is for <code>Prop</code>/<code>Bool</code>.  I don't really know how well this class works in practice, but using instances seems like a reasonably good place to record this sort of thing.</p>",
        "id": 282193847,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652406676
    },
    {
        "content": "<p>I guess these <code>has_finset</code> instances can actually be useful for defining <code>is_finite</code> constructors.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_finite.inter</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.is_finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">hs.has_finset</span><span class=\"o\">,</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">ht.has_finset</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">is_finite_of_has_finset</span> <span class=\"o\">}</span>\n<span class=\"c1\">-- ^ code that's not specific to the situation.</span>\n</code></pre></div>",
        "id": 282194418,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652407247
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>newest code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! ## finiteness predicate for sets -/</span>\n\n<span class=\"c1\">-- to replace `set.finite`</span>\n<span class=\"kd\">structure</span> <span class=\"n\">set.is_finite</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_finset</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">set</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Noncomputably get the data of a `finset` that represents this set. -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">is_finite.to_finset</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">hs.exists_finset.some</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_finite.mem_to_finset</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">hs.to_finset</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hs.exists_finset.some_spec.symm</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">eq_iff_iff</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- Class for computing a `finset` for a `set`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_finset</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_finset</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">eq_to_finset</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">to_finset</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Computably get a `finset` that represents this `finite_set`.</span>\n<span class=\"sd\">(Writing `get_finset` since mathlib already has `to_finset`.) -/</span>\n<span class=\"kd\">@[reducible]</span> <span class=\"kd\">def</span> <span class=\"n\">get_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_finset.to_finset</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_get_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s.get_finset</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">has_finset.eq_to_finset</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">eq_iff_iff</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">coe_get_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s.get_finset</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">has_finset.eq_to_finset</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">@[inline]</span> <span class=\"kd\">instance</span> <span class=\"n\">has_to_finset.of_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">s.get_finset</span> <span class=\"bp\">∪</span> <span class=\"n\">t.get_finset</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">s.get_finset</span> <span class=\"bp\">∩</span> <span class=\"n\">t.get_finset</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">s.get_finset</span> <span class=\"bp\">\\</span> <span class=\"n\">t.get_finset</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">has_finset</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_finset</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">t</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">s.get_finset.bUnion</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get_finset</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_finset</span> <span class=\"o\">(</span><span class=\"bp\">∅</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_finset</span> <span class=\"o\">({</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨{</span><span class=\"n\">x</span><span class=\"o\">},</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_finset</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"n\">s.get_finset</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_finset</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">s.get_finset.image</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_finite_of_has_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_finset</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">has_finset.eq_to_finset</span> <span class=\"n\">_</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">is_finite.has_finset</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_finset</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">hs.to_finset</span><span class=\"o\">,</span> <span class=\"n\">hs.exists_finset.some_spec</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_finite.union</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.is_finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">hs.has_finset</span><span class=\"o\">,</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">ht.has_finset</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">is_finite_of_has_finset</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_finite.inter</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.is_finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">hs.has_finset</span><span class=\"o\">,</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">ht.has_finset</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">is_finite_of_has_finset</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_finite.sdiff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">t.is_finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">hs.has_finset</span><span class=\"o\">,</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">ht.has_finset</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">is_finite_of_has_finset</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_finite.bUnion</span>\n  <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">t</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">hs.has_finset</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">has_finset</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">is_finite_of_has_finset</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_finite.image</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">hs.has_finset</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">is_finite_of_has_finset</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_finite.emptyc</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∅</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_finite_of_has_finset</span> <span class=\"n\">_</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_finite.singleton</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">({</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_finite_of_has_finset</span> <span class=\"n\">_</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">is_finite.insert</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">hs.has_finset</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">is_finite_of_has_finset</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">set</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\">! ## Bundled finite sets -/</span>\n\n<span class=\"sd\">/-- Bundled finite sets -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">finite_set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finite</span> <span class=\"o\">:</span> <span class=\"n\">carrier.is_finite</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Create a `finite_set` from a proof of finiteness.  -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">set.is_finite.to_finite_set</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finite_set</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">set_like</span> <span class=\"o\">(</span><span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">finite_set.carrier</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">congr'</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_carrier</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s.carrier</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_mk</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finite_set.mk</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_to_finite_set</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.is_finite</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">hs.to_finite_set</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">@[ext]</span> <span class=\"kd\">theorem</span> <span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s'</span> <span class=\"o\">:=</span> <span class=\"n\">set_like.ext</span> <span class=\"n\">h</span>\n\n<span class=\"sd\">/-- Copy of a `my_subobject` with a new `carrier` equal to the old one. Useful to fix definitional</span>\n<span class=\"sd\">equalities. See Note [range copy pattern]. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">copy</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s'</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">s'</span><span class=\"o\">,</span>\n  <span class=\"n\">finite</span> <span class=\"o\">:=</span> <span class=\"n\">hs.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">s.finite</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_copy</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s'</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s.copy</span> <span class=\"n\">s'</span> <span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">copy_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s'</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.copy</span> <span class=\"n\">s'</span> <span class=\"n\">hs</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"n\">set_like.coe_injective</span> <span class=\"n\">hs</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">has_coe.of_finset</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">finite_set.mk</span> <span class=\"bp\">↑</span><span class=\"n\">s</span> <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩⟩⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">finset.mem_coe</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_to_finset_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.finite.to_finset</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_to_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.finite.to_finset</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_union</span> <span class=\"o\">(</span><span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">set.is_finite.union</span> <span class=\"n\">s.finite</span> <span class=\"n\">t.finite</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_inter</span> <span class=\"o\">(</span><span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">set.is_finite.inter</span> <span class=\"n\">s.finite</span> <span class=\"n\">t.finite</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_sdiff</span> <span class=\"o\">(</span><span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">set.is_finite.sdiff</span> <span class=\"n\">s.finite</span> <span class=\"n\">t.finite</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_emptyc</span> <span class=\"o\">(</span><span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">set.is_finite.emptyc</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_singleton</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨{</span><span class=\"n\">x</span><span class=\"o\">},</span> <span class=\"n\">set.is_finite.singleton</span> <span class=\"n\">x</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_insert</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">set.is_finite.insert</span> <span class=\"n\">x</span> <span class=\"n\">s.finite</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_union</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_inter</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_sdiff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_emptyc</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">∅</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_insert</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">insert</span> <span class=\"n\">y</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bUnion</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finite_set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">⋃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">t</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">set.is_finite.bUnion</span> <span class=\"n\">s.finite</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_bUnion</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finite_set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s.bUnion</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">bUnion</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">image</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">set.is_finite.image</span> <span class=\"n\">f</span> <span class=\"n\">s.finite</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_image</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">monad</span> <span class=\"n\">finite_set</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">image</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">pure</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">},</span>\n  <span class=\"n\">seq</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">t</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">t.bUnion</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">s.image</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n  <span class=\"n\">bind</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">s.bUnion</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finite_set</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\">! ## Finite types -/</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">finite_type</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">univ_finite</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_finite</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finite_set</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- `set.univ` as a `finite_set`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">univ</span> <span class=\"o\">[</span><span class=\"n\">finite_type</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">finite_type.univ_finite.to_finite_set</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_univ</span> <span class=\"o\">[</span><span class=\"n\">finite_type</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_univ</span> <span class=\"o\">[</span><span class=\"n\">finite_type</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span>\n\n<span class=\"sd\">/-- Every type that is computably finite is also a `finite_type`.</span>\n<span class=\"sd\">(Should `fintype` even exist if there is `finite_type`?) -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">of_fintype</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">finite_type</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨⟨</span><span class=\"n\">finset.univ</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">finset.coe_univ</span><span class=\"o\">⟩⟩⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finite_set</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\">! ## Mechanism for bundling a `set` as a `finite_set' -/</span>\n\n<span class=\"sd\">/-- Get the bundled `finite_set` for a set that has a `finite_type` instance. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">set.to_finite_set</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">finite_type</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">finite_set.mk</span> <span class=\"n\">s</span>\n<span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">finite_set.univ</span> <span class=\"o\">:</span> <span class=\"n\">finite_set</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite.to_finset.map</span> <span class=\"o\">(</span><span class=\"n\">function.embedding.subtype</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">set.coe_to_finite_set</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">finite_type</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">s.to_finite_set</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n</div></div>",
        "id": 282195508,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652408488
    },
    {
        "content": "<p>Why not go the other way around and hold a <code>set</code> in <code>finset</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nodup</span> <span class=\"o\">:</span> <span class=\"n\">nodup</span> <span class=\"n\">val</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">to_set</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">coe_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">val</span> <span class=\"bp\">↔</span> <span class=\"n\">to_set</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then you can define the coercion from <code>finset α</code> to <code>set α</code> as <code>finset.to_set</code>. No need for a new structure, and not much changes.</p>",
        "id": 282216456,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652430081
    },
    {
        "content": "<p>That still needs decidable instances to be useful as data. The design goals are (1) to keep a computational finite set definition around, (2) to have a computationally irrelevant finite set definition (no more decidable instances in proofs about mathematical finite sets!), (3) to have this definition have good definitional properties with respect to <code>set</code>, (4) to have <code>fintype</code> be a Prop so that instances may enjoy proof irrelevance, and (5) to have a way to associate computational sets to computationally irrelevant ones (so we at least have a place to put fintype algorithms).</p>\n<p>That suggested change to <code>finset</code> partly handles 3 and does not simultaneously handle 1 and 2. The issue with 3 is that even if the sets are definitionally equal, the multisets might not be.</p>",
        "id": 282235058,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652442321
    },
    {
        "content": "<p>Of course, this is a trade-off. But experience suggests that we care much more about the <code>finset α → set α</code> coercion than the <code>finset α → multiset α</code> one.</p>",
        "id": 282235216,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652442408
    },
    {
        "content": "<p>I'm afraid this will just end up being \"Yet another way to talk about finite things\" while the symptom of the problem hasn't been solved. Namely, decidability shouldn't stop defeq. A few uneducated solutions I have to this are:</p>\n<ul>\n<li>Do not handle decidability with instances. An option is your <code>compuitable</code> typeclass. Another one would to have a fully separate decidability handler, which automatically marks declaration with the right decidability instances.</li>\n<li>Make subsingleton elimination defeq, at least for <code>decidable</code> and <code>fintype</code></li>\n</ul>",
        "id": 282235428,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652442596
    },
    {
        "content": "<blockquote>\n<p>Make subsingleton elimination defeq, at least for decidable and fintype</p>\n</blockquote>\n<p>I've always suggested this, or at least a type-class inference system that can handle defeq. I feel like the deeper we get into maths, the more we can't rejig to make things defeq. I often struggle accepting that <code>x^1</code> is not definitionally equal to <code>x</code> (or hell, even <code>1*x</code> or <code>x*1</code>),  and these issues are just going to keep intensifying, c.f. representation theory</p>",
        "id": 282244196,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652447636
    },
    {
        "content": "<p>I'm curious if the change in <a href=\"https://github.com/leanprover-community/mathlib/pull/14122\">#14122</a> will make decidable arguments in proofs less annoying</p>",
        "id": 282244516,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652447787
    },
    {
        "content": "<p>I guess this will mostly solve <code>decidable</code>, but no good solution to <code>fintype</code> still :(</p>",
        "id": 282244866,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652447961
    },
    {
        "content": "<p>And the only real reason it solves is it because no-one ever writes decidable instances ;b</p>",
        "id": 282244895,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652447980
    },
    {
        "content": "<blockquote>\n<p>Make subsingleton elimination defeq, at least for decidable and fintype</p>\n</blockquote>\n<p>I think it's strictly better to just make <code>decidable</code> and <code>fintype</code> propositions, mainly because it's a thing we can actually do</p>",
        "id": 282247720,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652449188
    },
    {
        "content": "<p>Making <code>decidable p : Prop</code> would be pointless (and would make <code>if</code> noncomputable!), so I assume you meant something else</p>",
        "id": 282247837,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652449223
    },
    {
        "content": "<p>Well, effectively it means getting rid of (i.e., not using) <code>decidable</code></p>",
        "id": 282247894,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652449255
    },
    {
        "content": "<p>(Also, it's not constructively pointless!)</p>",
        "id": 282247921,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652449266
    },
    {
        "content": "<p><code>decidable</code> is still needed for meta code though</p>",
        "id": 282247937,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652449272
    },
    {
        "content": "<p>(Also, it's not constructively pointless!)</p>",
        "id": 282247962,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652449281
    },
    {
        "content": "<p>Well, effectively it means getting rid of (i.e., not using) <code>decidable</code></p>",
        "id": 282247963,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652449281
    },
    {
        "content": "<p>Right, <code>if</code> should be noncomputable</p>",
        "id": 282247985,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652449294
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/bundled.20finite.20sets.20.28and.20avoiding.20decidable.20instances.29/near/282247985\">said</a>:</p>\n<blockquote>\n<p>Right, <code>if</code> should be noncomputable</p>\n</blockquote>\n<p>Then we need a different <code>if</code> for meta code</p>",
        "id": 282248003,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652449307
    },
    {
        "content": "<p>If you're going down the extensional type theory road then you are going to have way bigger problems than that</p>",
        "id": 282248026,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652449322
    },
    {
        "content": "<p>The general case is that if you want a definitionally irrelevant subsingleton then we already have it, it's called <code>Prop</code>. I agree including the case of <code>decidable</code> is a bit silly.</p>",
        "id": 282250917,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652450485
    },
    {
        "content": "<p>Does the type theory become more complex if we allow <code>trunc</code> to be definitionally irrelevant too?</p>",
        "id": 282251706,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652450807
    },
    {
        "content": "<p>Because we could wrap everything where this problem arises in <code>trunc</code> if necessary</p>",
        "id": 282251738,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652450829
    },
    {
        "content": "<p>I'm pretty sure all of these amount to equality reflection, i.e., if you have <code>h : a = b</code> then <code>a</code> and <code>b</code> are defeq</p>",
        "id": 282252071,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652450994
    },
    {
        "content": "<p>except the ones involving <code>decidable</code>, which I'm not sure about</p>",
        "id": 282252172,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652451031
    },
    {
        "content": "<p>what was the issue with equality reflection again?</p>",
        "id": 282252217,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652451060
    },
    {
        "content": "<p>It's way outside the scope of Lean. I've seen a theorem prover based on extensional type theory but I don't remember what it was called, or how serious it was</p>",
        "id": 282252442,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652451187
    },
    {
        "content": "<p>NuPRL has extensional types I believe.</p>",
        "id": 282253032,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1652451467
    },
    {
        "content": "<p>The main issue is that to check a defeq the kernel might have to synthesize some arbitrary proof of equality--obviously there's no algorithm that can do so in all cases, so how do you make something usable and reliable and trustable.</p>",
        "id": 282253278,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652451579
    },
    {
        "content": "<p>In Lean's current type theory the definitional equality is more or less decidable by an algorithm and that algorithm works in practice most of the time.</p>",
        "id": 282253440,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652451636
    },
    {
        "content": "<p>why can't we just use the current kernel typechecker. if a <code>rfl</code> that should work fails that shouldn't be able to affect consistency</p>",
        "id": 282253497,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652451659
    },
    {
        "content": "<p>and then we can just add the extra <code>rfl</code>s that need kernel support</p>",
        "id": 282253559,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652451684
    },
    {
        "content": "<p>Those extra <code>rfl</code>s are where the problem is</p>",
        "id": 282253714,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652451749
    },
    {
        "content": "<p>Those extra <code>rfl</code>s are where the problem is</p>",
        "id": 282253733,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652451759
    },
    {
        "content": "<p>how so? say for example we have Lean + \"if there's a proof that a type <code>t</code> is a subsingleton in the instance cache somehow, then <code>a = b : @eq t</code> is <code>rfl</code>\"</p>",
        "id": 282254083,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652451904
    },
    {
        "content": "<p>Well the kernel doesn't have an instance cache</p>",
        "id": 282254583,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652452101
    },
    {
        "content": "<p>Proof irrelevance for <code>Prop</code> is already a bit funny and I think it's why definitions using well-founded recursion don't compute in the kernel (right?)</p>",
        "id": 282255052,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652452317
    },
    {
        "content": "<p>Hmm, I guess not, but the higher-level automation could add the instances that are used using <code>have</code> statements to the proofs. I guess this is really slow and complicated, though</p>",
        "id": 282255053,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652452318
    },
    {
        "content": "<p>For specific types, however, specific support could be added and that solves 99% of the issues (fintype, decidable, Q-algebras maybe)</p>",
        "id": 282255209,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652452379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/bundled.20finite.20sets.20.28and.20avoiding.20decidable.20instances.29/near/282248003\">said</a>:</p>\n<blockquote>\n<p>Then we need a different <code>if</code> for meta code</p>\n</blockquote>\n<p>I suggest <code>mif</code></p>",
        "id": 282255527,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1652452512
    },
    {
        "content": "<p>OK so let's suppose you write down a rule \"if <code>a : fintype X</code> and <code>b : fintype X</code> then <code>a</code> and <code>b</code> are defeq\"</p>",
        "id": 282255977,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652452709
    },
    {
        "content": "<p>How do you know when to apply the rule?</p>",
        "id": 282256020,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652452731
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> That makes sense, but we should probably think ahead to Lean 4 -- we probably don't want to override its programming language features.  We could have <code>if'</code> on the math side, or <code>cif</code> for \"classical if\".</p>",
        "id": 282256102,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652452774
    },
    {
        "content": "<p>Maybe I'm trying to type check <code>rfl : 0 = sum (x : X), x</code></p>",
        "id": 282256106,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652452777
    },
    {
        "content": "<p>That <code>sum</code> involves a <code>fintype X</code> argument which might be stuck for some reason (e.g., uses an axiom). But wait! what if I can somehow cook up a second <code>b : fintype X</code> which isn't stuck, and then keep reducing</p>",
        "id": 282256331,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652452870
    },
    {
        "content": "<p>Now I am back to the same problem, namely, I should be able to synthesize terms out of thin air</p>",
        "id": 282256452,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652452918
    },
    {
        "content": "<p>Maybe you say: well too bad, I don't know how to do that. Then you are in the nontransitivite defeq situation. The <code>sum</code> with the bad <code>fintype</code> instance is convertible to the one with the good <code>fintype</code> instance (by <code>fintype</code> irrelevance), which can be reduced to <code>0</code>. But we aren't capable of reducing the original <code>sum</code> to <code>0</code>.</p>",
        "id": 282256824,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652453046
    },
    {
        "content": "<p>If that is going to happen anyways, then maybe <code>sum</code> should just be noncomputable in the first place, and we can use tactics/propositional reasoning when we want to \"compute\" it. At least this is something that we could Just Do today, and doesn't require modifying the kernel with possibly other consequences.</p>",
        "id": 282257229,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652453183
    },
    {
        "content": "<p>Thanks, that's a really good explanation. I feel like a non-transitive defeq isn't that evil, though - hell, I thought we had it already for some language features. Plus, it also fits my idea of \"true by definition\" in informal mathematics.</p>",
        "id": 282257513,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652453299
    },
    {
        "content": "<p>But I guess this second approach is the current tsum/etc approach, and that leaves us with a lot of arguments we have to carry around. Maybe we can improve that by making an instanced version of <code>nonempty (x)</code>for relevant x, and then we get TC search and not a bunch of annoying arguments everywhere</p>",
        "id": 282257673,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652453378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/bundled.20finite.20sets.20.28and.20avoiding.20decidable.20instances.29/near/282235216\">said</a>:</p>\n<blockquote>\n<p>Of course, this is a trade-off. But experience suggests that we care much more about the <code>finset α → set α</code> coercion than the <code>finset α → multiset α</code> one.</p>\n</blockquote>\n<p>I suspect I'm not being understood here. The issues is not about coercions per se. The proposed <code>finite_set</code> type has the property that the finite sets are definitionally equal if and only if the underlying sets are definitionally equal. When you have the <code>multiset</code> in the mix as actual data, you essentially have diamond problems, which I at least would like to avoid.</p>\n<p>Regarding a trade-off, the five design goals I mentioned are all met by the <code>finite_set</code> proposal. It does not meet the unmentioned number 6 (not be a whole lot of work) but I think this is unavoidable.</p>\n<p>So long as we keep using data structures for finite sets as if they were <code>set</code>s that are finite, I think we're going to keep having a struggle.  Regarding your concern about \"yet another way to talk about finite things\", it seems similar to how we have both lists and functions <code>fin n -&gt; A</code>, but we don't try to force one to be the other.</p>",
        "id": 282257852,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652453441
    },
    {
        "content": "<p>Or maybe you really specifically need the definitional equality (because these expressions are appearing in the index of some type family) and then yes, I agree it would be much nicer if you could convince the kernel to do these conversions; I just don't know what the framework for making it work reliably should look like, and I'm not sure whether anyone does</p>",
        "id": 282257859,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652453446
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Do you have any thoughts about the <code>finite_set</code> proposal? It seems like you're in favor at least in principle. I'm wondering partly because I know you spent time a while back working on this sort of thing.</p>",
        "id": 282257971,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652453495
    },
    {
        "content": "<p>To reduce work, I think leaving <code>fintype</code> as-is makes sense for now (rather than replacing it) and introducing <code>finite_type</code> for the <code>Prop</code> version, then having <code>finite_type</code> instances from <code>fintype</code> instances.</p>",
        "id": 282258168,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652453567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/bundled.20finite.20sets.20.28and.20avoiding.20decidable.20instances.29/near/282216456\">said</a>:</p>\n<blockquote>\n<p>Why not go the other way around and hold a <code>set</code> in <code>finset</code>?<br>\n&lt;snip&gt;</p>\n</blockquote>\n<p>Just to note, the effect of this change is to have nicer definitional control of what finset membership means, but it's orthogonal to decidability discussions.</p>",
        "id": 282258544,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652453706
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> What's \"this\"? I assume you're clarifying Yael's suggestion?</p>",
        "id": 282259758,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652454177
    },
    {
        "content": "<p>\"this\" refers to Yael's suggestion in the message I quoted</p>",
        "id": 282259833,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652454214
    },
    {
        "content": "<p>After going through all of what we have already in <code>data/set/finite</code> and reorganizing it (<a href=\"https://github.com/leanprover-community/mathlib/pull/14136\">#14136</a>), I guess we already have pretty much everything set up for bundled finite sets. Here's an overview for a proposed design:</p>\n<ul>\n<li><code>finset</code> remains as-is. It's the computational model (i.e. a data structure) for finite sets.</li>\n<li><code>fintype</code> remains as-is. Paired with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.to_finite\">docs#set.to_finite</a>, this is the database of ways to turn sets that are finite into computable finite sets. (It's the finite set analogue of <code>decidable</code>.)</li>\n<li><code>set.finite</code> remains as-is. This is the predicate that represents the mere fact that a set is finite without offering any computational guarantees.</li>\n<li>In <code>data/set/finite</code> there is a long list of <code>fintype</code> instances that give ways of computing different set constructions already.</li>\n<li>Parallel to that, <code>data/set/finite</code> also has a long list of <code>set.finite</code> constructions. These are mostly formulaic, just applying <code>fintype</code> instances.</li>\n<li>Then we can define <code>finite_set</code>, which is a <code>set</code> that is <code>set.finite</code>. This will have all the properties I mentioned in my first posts. Operations on <code>finite_set</code> can be lifted in a mostly  formulaic way from corresponding <code>set.finite</code> constructions, and properties should be mostly liftable from <code>set</code> properties due to the fact a <code>finite_set</code> \"is\" a <code>set</code>. (Note: in the VM, a <code>finite_set</code> will be essentially computationally irrelevant, similar to <code>set</code>. At most they'll be passed around as zero-argument constructors.)</li>\n<li>We can also define <code>finite_type</code>. There are a couple ways this could be defined, but probably the easiest is <code>nonempty (fintype A)</code>. This is a type whose <code>set.univ</code> can be given as a <code>finite_set</code>.</li>\n</ul>",
        "id": 282360549,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652545329
    },
    {
        "content": "<p>+1 for <code>finite_type</code>, I thought <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> mentioned at some point that he was thinking of adding this.</p>",
        "id": 282362991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652548548
    },
    {
        "content": "<p>I've started working on a typeclass for countable types (and sorts), see <a href=\"https://github.com/leanprover-community/mathlib/tree/YK-countable\">branch#YK-countable</a>.</p>",
        "id": 282363046,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652548634
    },
    {
        "content": "<p>It would be nice if someone adopts this branch.</p>",
        "id": 282363053,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652548647
    },
    {
        "content": "<p>About <code>finite_type</code>: please make it work for <code>Sort*</code>.</p>",
        "id": 282363059,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652548666
    },
    {
        "content": "<p>E.g., you can define <code>finite_type (α : Sort*) := (ex_equiv_fin : ∃ n : nat, nonempty (α ≃ fin n))</code></p>",
        "id": 282363115,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652548713
    },
    {
        "content": "<p>With this typeclass, we can have lemmas about finite unions/intersections without dealing separately with unions over proofs of propositions.</p>",
        "id": 282363142,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652548785
    },
    {
        "content": "<p>I was wondering all the ways we have to represent finite (multi)sets in mathlib. Here's what I could think of (and if there are others anyone can think of, I'll add them to the list).</p>\n<p>Finite sets:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset\">docs#finset</a> (a <code>multiset</code> without duplicates)</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set\">docs#set</a> satisfying <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.finite\">docs#set.finite</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set\">docs#set</a> whose coercion has a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype\">docs#fintype</a> instance</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp\">docs#finsupp</a> with <code>fin 2</code> codomain</li>\n</ul>\n<p>Finite multisets:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset\">docs#multiset</a> (a <code>list</code> modulo permutation)</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp\">docs#finsupp</a> with <code>ℕ</code> codomain</li>\n</ul>",
        "id": 284939283,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1654294806
    },
    {
        "content": "<p>This is a kind of funny and perhaps roundabout way to work with finite sets:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">false</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finset'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">finsupp</span> <span class=\"n\">α</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finset'.to_set</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">finsupp.to_fun</span>\n</code></pre></div>\n<p>If you expand out the definitions it's essentially something Yael suggested earlier, which is a finite set definition that contains both a <code>finset</code> and a <code>set</code> so you can get definitional control over both.</p>",
        "id": 284939483,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1654294949
    }
]
[
    {
        "content": "<p>In a proof I am working on I got an error I don't fully understand, and it's possibly a diamond. The error is in <a href=\"https://github.com/leanprover-community/flt-regular/blob/RB_poss_diam/src/number_theory/discriminant/basic.lean#L190\">number_theory/discriminant/basic</a>, in the <code>flt-regular</code> repo, branch <code>RB_possible_diam</code>. Before spending some time to provide a minimal example, I would ask if someone immediately recognize the error. The type of <code>this</code> and the goal are quite long with <code>set_option pp.all true</code>, but almost identical. <code>diff</code> tells me that the only difference is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>             <span class=\"bp\">@</span><span class=\"n\">subtype.decidable_eq.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span>\n               <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span>\n                  <span class=\"bp\">@</span><span class=\"n\">has_lt.lt.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">nat</span> <span class=\"n\">nat.has_lt</span> <span class=\"n\">x</span>\n                    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">power_basis.dim.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">K</span> <span class=\"n\">L</span>\n                       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">euclidean_domain.to_comm_ring.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_euclidean_domain.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">K</span> <span class=\"n\">_inst_7</span><span class=\"o\">))</span>\n                       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">division_ring.to_ring.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_division_ring.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">L</span> <span class=\"n\">_inst_8</span><span class=\"o\">))</span>\n                       <span class=\"n\">_inst_10</span> <span class=\"n\">pb</span><span class=\"o\">))</span>\n               <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">nat.decidable_eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>instead of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>             <span class=\"n\">classical.prop_decidable</span>\n               <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">eq.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span>\n                  <span class=\"o\">(</span><span class=\"n\">fin</span>\n                     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">power_basis.dim.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">K</span> <span class=\"n\">L</span>\n                        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">euclidean_domain.to_comm_ring.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_euclidean_domain.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">K</span> <span class=\"n\">_inst_7</span><span class=\"o\">))</span>\n                        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">division_ring.to_ring.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_division_ring.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">L</span> <span class=\"n\">_inst_8</span><span class=\"o\">))</span>\n                        <span class=\"n\">_inst_10</span> <span class=\"n\">pb</span><span class=\"o\">))</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Does someone recognize this error?</p>",
        "id": 260154299,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635954671
    },
    {
        "content": "<p>There's probably a mis-stated lemma somewhere</p>",
        "id": 260154664,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635954806
    },
    {
        "content": "<p>Which of those is your goal, and which is the lemma application?</p>",
        "id": 260154704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635954826
    },
    {
        "content": "<p>The goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">vandermonde</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">L</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">pb.basis</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">det</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>that is also the type of <code>this</code> (without <code>set_option pp.all true</code>). Let me see if I can produce a reasonable self contained example.</p>",
        "id": 260155237,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635955038
    },
    {
        "content": "<p>The error goes away if I get rid of the open locale classical and add all the decidable_eq iota arguments lean asks for</p>",
        "id": 260155287,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1635955062
    },
    {
        "content": "<p>Being a stupid mathematician who doesn't know anything about <code>classical</code> I am very happy with this solution</p>",
        "id": 260155561,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635955174
    },
    {
        "content": "<p>Right, the underlying problem is either:</p>\n<ul>\n<li>you have a definition without a <code>decidable</code> argument (fine), but you <code>unfold</code> it  (not fine) rather than adding a lemma that introduces the <code>decidable</code> argument</li>\n<li>you have a lemma that needs a <code>decidable</code> argument in its _statement_, but you let it fall back to the classical one (not fine)</li>\n</ul>",
        "id": 260156222,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635955403
    },
    {
        "content": "<p>Can you paste a permalink to the relevant lines?</p>",
        "id": 260156282,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635955435
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/flt-regular/blob/71b6e4152b6a18647cc001c8fee2afcc501e70ae/src/number_theory/discriminant/basic.lean#L190\">Here it is</a></p>",
        "id": 260156481,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635955495
    },
    {
        "content": "<p>Note that both the lemma and <code>this</code> are actually false, but it doesn't matter.</p>",
        "id": 260156726,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635955583
    },
    {
        "content": "<p><del>Gitpod seems to run out of memory while trying to open that unfortunately...</del> I had a bad cache</p>",
        "id": 260158388,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635956306
    },
    {
        "content": "<p>I've <a href=\"https://github.com/leanprover-community/flt-regular/blob/ee10a50e9c2c2e3b1da55a5551d0fba548ed550a/src/number_theory/discriminant/basic.lean#L190\">sorried</a> the error</p>",
        "id": 260159027,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635956568
    },
    {
        "content": "<p><code>exact this</code> should close the goal, but it doesn't.</p>",
        "id": 260159065,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635956591
    },
    {
        "content": "<p>As Alex suggests, you should remove <code>open_locale classical</code>, add <code>decidable</code> to all the lemmas with complaints in their statements, then add back <code>open_locale classical</code></p>",
        "id": 260159127,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635956620
    },
    {
        "content": "<p>In any case I am trying to avoid <code>open_locale classical</code> and adding <code>decidable_eq ι</code> where is needed.</p>",
        "id": 260159148,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635956630
    },
    {
        "content": "<p>Ah, I should have <em>both</em> <code>open_locale classical</code> and <code>decidable_eq ι</code>?</p>",
        "id": 260159247,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635956662
    },
    {
        "content": "<p>No no no.</p>",
        "id": 260159288,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635956677
    },
    {
        "content": "<p>What you <em>don't</em> want is to put a <code>classical.dec_something</code> into the <em>type</em> of a lemma.</p>",
        "id": 260159320,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635956702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260159247\">said</a>:</p>\n<blockquote>\n<p>Ah, I should have <em>both</em> <code>open_locale classical</code> and <code>decidable_eq ι</code>?</p>\n</blockquote>\n<p>Only if you want the former. It's fine to have it if it makes things convenient inside <code>def</code>s and proofs, but it can lead to traps in lemmas</p>",
        "id": 260159359,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635956717
    },
    {
        "content": "<p>It's fine if it's in the <em>proof</em>, because you never need to match the proof.</p>",
        "id": 260159365,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635956722
    },
    {
        "content": "<p>In proofs you can always use <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#classical\">tactic#classical</a>, which is less of a trap</p>",
        "id": 260159396,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635956741
    },
    {
        "content": "<p>That's what the <code>classical</code> linter checks.</p>",
        "id": 260159403,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1635956743
    },
    {
        "content": "<p>I think the best approach is:</p>\n<ul>\n<li>Use the <code>classical</code> tactic in proofs that need it</li>\n<li>For noncomputable defs, create a very small section around only the def, and use <code>open_locale classical</code> in that section</li>\n</ul>",
        "id": 260159520,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635956786
    },
    {
        "content": "<p>Having <code>open_locale classical</code> at the top is a trap waiting to be sprung</p>",
        "id": 260159581,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635956816
    },
    {
        "content": "<p>So for instance;</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- it's fine to use the classical decidable_eq argument inside this def, because it's already</span>\n<span class=\"c1\">-- noncomputable anyway</span>\n<span class=\"kn\">section</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"sd\">/-- Given an `A`-algebra `B` and `b`, an `ι`-indexed family of elements of `B`, we define</span>\n<span class=\"sd\">`discriminant A ι b` as the determinant of `trace_matrix A ι b`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">discriminant</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">trace_matrix</span> <span class=\"n\">A</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">det</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- this needs a `decidable_eq` argument otherwise it's not general enough</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">discriminant_def</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">discriminant</span> <span class=\"n\">A</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">trace_matrix</span> <span class=\"n\">A</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">det</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">convert</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 260159864,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635956946
    },
    {
        "content": "<p>Sorry for the stupid question, but is this the same as adding <code>[decidable_eq ι]</code> to the def?</p>",
        "id": 260160284,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635957123
    },
    {
        "content": "<p>And in any case I should add <code>noncomputable</code>, right?</p>",
        "id": 260160304,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635957135
    },
    {
        "content": "<p>You should write a small tutorial for mathematicians <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span> . I've always thought putting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kd\">noncomputable theory</span>\n</code></pre></div>\n<p>at the beginning of the file means \"let's do standard mathematics and forget about this CS stuff\".</p>",
        "id": 260161433,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635957591
    },
    {
        "content": "<p>One of the \"I don't care about decidability\" solutions/band-aids is to use <code>convert</code> (and sometimes <code>convert_to</code>) in place of <code>exact</code>. It's able to deal with differing decidable instances.</p>",
        "id": 260161645,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635957671
    },
    {
        "content": "<p>(I haven't looked at what you're doing to see if it applies, but it can be a useful way to avoid redesigning definitions, even if that might be the right thing to do.)</p>",
        "id": 260161708,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635957703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260160284\">said</a>:</p>\n<blockquote>\n<p>Sorry for the stupid question, but is this the same as adding <code>[decidable_eq ι]</code> to the def?</p>\n</blockquote>\n<p>No, because adding <code>decidable_eq ι</code> means that all the lemmas about it need to as well</p>",
        "id": 260161872,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635957771
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260160304\">said</a>:</p>\n<blockquote>\n<p>And in any case I should add <code>noncomputable</code>, right?</p>\n</blockquote>\n<p>You have <code>noncomputable theory</code> at the top of the file so that's not needed. If you want to remind yourself which things are computable, then remove <code>noncomputable theory</code> and add <code>noncomputable</code> wherever lean complains.</p>",
        "id": 260161949,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635957813
    },
    {
        "content": "<p><code>noncomputable theory</code>is indeed an \"I don't care about this\" lever, but <code>open_locale classical</code> just hides it until it bites you later</p>",
        "id": 260162113,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635957874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260161433\">said</a>:</p>\n<blockquote>\n<p>You should write a small tutorial for mathematicians <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span> . I've always thought putting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kd\">noncomputable theory</span>\n</code></pre></div>\n<p>at the beginning of the file means \"let's do standard mathematics and forget about this CS stuff\".</p>\n</blockquote>\n<p>Perhaps we should have a new library note on this topic?</p>",
        "id": 260162438,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1635958019
    },
    {
        "content": "<p>If I do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"sd\">/-- Given an `A`-algebra `B` and `b`, an `ι`-indexed family of elements of `B`, we define</span>\n<span class=\"sd\">`discriminant A ι b` as the determinant of `trace_matrix A ι b`. -/</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">discriminant</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">trace_matrix</span> <span class=\"n\">A</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">det</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">discriminant_def</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">discriminant</span> <span class=\"n\">A</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">trace_matrix</span> <span class=\"n\">A</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">det</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>it immediately complains because <code>failed to synthesize type class instance for... [decidable_eq ι]</code>. And if I add it I am not able to prove the lemma anymore. I am sure I am doing something wrong here...</p>",
        "id": 260162948,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635958216
    },
    {
        "content": "<p>Right, that's why in my comment I said:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- this needs a `decidable_eq` argument otherwise it's not general enough</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">discriminant_def</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">discriminant</span> <span class=\"n\">A</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">trace_matrix</span> <span class=\"n\">A</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">det</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">convert</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 260163082,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635958284
    },
    {
        "content": "<p>That lemma needs <code>[decidable_eq ι]</code> because it's about <code>trace_matrix</code></p>",
        "id": 260163137,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635958305
    },
    {
        "content": "<p>And one of the arguments to <code>trace_matrix</code> needs <code>decidable_eq</code></p>",
        "id": 260163169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635958317
    },
    {
        "content": "<p>OK, I don't care to add <code>[decidable_eq ι]</code>, but <code>rfl</code> doesn't prove it.</p>",
        "id": 260163411,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635958411
    },
    {
        "content": "<p>Right, you need <code>by convert rfl</code>  because you have to prove the two different decidable instances are equal</p>",
        "id": 260164953,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635958954
    },
    {
        "content": "<p>One of the tools in the toolbox for the mathematician who doesn't care about decidability is <code>by convert rfl</code>. Not sure if that works here</p>",
        "id": 260164975,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635958958
    },
    {
        "content": "<p>It doesn't <span aria-label=\"unamused\" class=\"emoji emoji-1f612\" role=\"img\" title=\"unamused\">:unamused:</span></p>",
        "id": 260165038,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635958981
    },
    {
        "content": "<p>Sorry, it does</p>",
        "id": 260165141,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635959025
    },
    {
        "content": "<p>I'm confused Riccardo; it worked in <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260159864\">the snippet I posted</a></p>",
        "id": 260165150,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635959029
    },
    {
        "content": "<p><del>I think you're running into this because <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.trace_form\">docs#algebra.trace_form</a> needs a <code>decidable_eq</code> argument, but you could argue \"it's noncomputable anyway, what's the point\"</del></p>",
        "id": 260165376,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635959099
    },
    {
        "content": "<p><del>If you replaced that argument with the classical instance in the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.trace_form\">docs#algebra.trace_form</a>, then all the pain would fall inside mathlib and flt-regular wouldn't run into it</del></p>",
        "id": 260165450,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635959128
    },
    {
        "content": "<p>It's <code>det</code> that requires a <code>decidable_eq</code> I think, not <code>trace_form</code>.</p>",
        "id": 260165752,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635959277
    },
    {
        "content": "<p>There is no <code>decidable_eq</code> in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.trace_form\">docs#algebra.trace_form</a> if I am not blind.</p>",
        "id": 260165903,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635959325
    },
    {
        "content": "<p>Ah you're right</p>",
        "id": 260166042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635959380
    },
    {
        "content": "<p>OK, things are better and better. But now <a href=\"https://github.com/leanprover-community/flt-regular/blob/7f84b5577445cf900e6f29a99f682761034d2d34/src/number_theory/discriminant/basic.lean#L114\">this</a> line has become very slow. It think that everything comes from <code> ¬discriminant A b = 0</code> and <code> discriminant A b ≠ 0</code>, but I am not even sure what <code>≠</code> means.</p>",
        "id": 260166764,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635959705
    },
    {
        "content": "<p><code>decidable_eq</code> only matters when an <code>ite</code> / <code>if</code> is involved. It doesn't affect what <code>=</code> means</p>",
        "id": 260167649,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635960113
    },
    {
        "content": "<p>Maybe it's because I removed <code>open_locale classical</code> or whatever, but in practice the proofs where <code>≠</code> is involved are now broken.</p>",
        "id": 260168096,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635960320
    },
    {
        "content": "<p>I'm waiting for gitpod...</p>",
        "id": 260168167,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635960352
    },
    {
        "content": "<p>Anywhere you do <code>rw discriminant</code> you introduce a diamond</p>",
        "id": 260168340,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635960429
    },
    {
        "content": "<p>You have to use <code>rw discriminant_def</code> instead</p>",
        "id": 260168375,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635960442
    },
    {
        "content": "<p>Ah, this is good to know!</p>",
        "id": 260168504,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635960493
    },
    {
        "content": "<p>The problem you're running into with that <code>by convert h</code> line is weird</p>",
        "id": 260168689,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635960595
    },
    {
        "content": "<p>It looks like it might be a bug in the <code>classical</code> tactic</p>",
        "id": 260168728,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635960603
    },
    {
        "content": "<p>In that without the <code>by convert</code> it fails with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">synthesized</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">definitionally</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"n\">expression</span> <span class=\"n\">inferred</span> <span class=\"kd\">by</span> <span class=\"n\">typing</span> <span class=\"n\">rules</span><span class=\"o\">,</span> <span class=\"n\">synthesized</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">_inst</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"n\">inferred</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But <code>_inst</code> is precisely <code>classical.prop_decidable</code>, <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#classical\">tactic#classical</a> just isn't letting you know that</p>",
        "id": 260168830,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635960651
    },
    {
        "content": "<p>Writing <code>discriminant_def</code> instead of <code>discriminant</code> indeed fixes all the issues!</p>",
        "id": 260169030,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635960746
    },
    {
        "content": "<p>Not the slowdown though, right?</p>",
        "id": 260169075,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635960772
    },
    {
        "content": "<p>No</p>",
        "id": 260169131,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635960802
    },
    {
        "content": "<p>On gitpod this takes forever:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">zero_of_not_linear_independent</span> <span class=\"o\">[</span><span class=\"n\">is_domain</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hli</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">linear_independent</span> <span class=\"n\">A</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">discriminant</span> <span class=\"n\">A</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_contra</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Is this just gitpod?</p>",
        "id": 260169677,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635961073
    },
    {
        "content": "<p>Same here, I had to add <code>classical</code> at the beginning of the proof.</p>",
        "id": 260169853,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635961140
    },
    {
        "content": "<p>My short (and incomplete and opinionated) tutorial for mathematicians who don't want to learn much about decidability but still want to contribute to mathlib:</p>\n<p>Decidability is a mechanism for helping us write definitions that are \"computable,\" which has something to do with constructive mathematics, something classical mathematicians tend not to be familiar with.  We say a <code>Prop</code> is decidable if there is some algorithm that can decide whether it is true or false; Godel proved no such algorithm exists for all <code>Prop</code>s.  In classical mode, we pretend there is a noncomputable \"algorithm\" that can make these decisions.</p>\n<ol>\n<li>Feel free to use <code>open_locale classical</code> and <code>noncomputable theory</code>. It will likely lead to less work down the road if you use the <code>classical</code> tactic instead of <code>open_locale classical</code>, but then you'll need to add all the <code>decidable</code> instances Lean will ask you for.  It's up to you to decide which road to take.</li>\n<li>Sometimes you will have things that will surprisingly not rewrite, or you'll have <code>exact</code>s that won't go through.  This might be because of decidable instances not lining up (from the fake classical one being equal to but not being defeq to a real decidable instance). Try using <code>convert_to</code> to \"refresh\" these instances, or to surgically change one part of an expression to create a new goal that looks like the rw lemma you're trying to use; in this case, you can usually use <code>convert</code> to apply the rw lemma.  For example, if both sides look the same but <code>refl</code> doesn't work, try <code>convert rfl</code>.</li>\n<li>When you submit a PR to mathlib, be prepared for decidability experts to help you reconfigure your code to be more general (and maybe for them to tell you how much of a mess you've made of things -- but proving things at all is usually the hard part). This work will help people in the future avoid needing to use these <code>convert</code>/<code>convert_to</code> tricks.</li>\n</ol>\n<p>It can also be worth running things by the decidability experts on Zulip ahead of time, since they'll likely have tricks to make a lot of this decidability wrangling less painful.</p>",
        "id": 260169891,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635961157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260169853\">said</a>:</p>\n<blockquote>\n<p>Same here, I had to add <code>classical</code> at the beginning of the proof.</p>\n</blockquote>\n<p>I think this is a nasty bug somewhere (in <code>by_contra</code> or the instance lookup)</p>",
        "id": 260169932,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635961179
    },
    {
        "content": "<p>How can <code>classical</code> have a bug? It just adds <code>classical.prop_decidable</code> to the context and resets the instance cache.  (If there's a bug, it must be <em>really</em> nasty.)</p>",
        "id": 260170152,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635961262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260170152\">said</a>:</p>\n<blockquote>\n<p>How can <code>classical</code> have a bug? It just adds <code>classical.prop_decidable</code> to the context and resets the instance cache.  (If there's a bug, it must be <em>really</em> nasty.)</p>\n</blockquote>\n<p>The bug is that it adds the instance as a <code>have</code> not a <code>let</code></p>",
        "id": 260170257,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635961321
    },
    {
        "content": "<p>Which means subsequent tactics can end up with diamonds they can't resolve</p>",
        "id": 260170336,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635961342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260169891\">said</a>:</p>\n<blockquote>\n<ol>\n<li>Feel free to use <code>open_locale classical</code> and <code>noncomputable theory</code>. It will likely lead to less work down the road if you use the <code>classical</code> tactic instead of <code>open_locale classical</code>, but then you'll need to add all the <code>decidable</code> instances Lean will ask you for.  It's up to you to decide which road to take.<br>\n</li>\n</ol>\n</blockquote>\n<p>This is what I've always done. But I discovered today it's not completely true...</p>",
        "id": 260170438,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635961384
    },
    {
        "content": "<p>Including step 2? That's the key part for this to actually be workable. (If annoying and many times painful!)</p>",
        "id": 260170539,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635961436
    },
    {
        "content": "<p>This is the original reason I opened this thread. If you look at the first message, I had</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kd\">noncomputable theory</span>\n</code></pre></div>\n<p>at the beginning of the file, but I encountered a strange error at some point.</p>",
        "id": 260170924,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635961566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260169932\">said</a>:</p>\n<blockquote>\n<p>I think this is a nasty bug somewhere (in <code>by_contra</code> or the instance lookup)</p>\n</blockquote>\n<p>The instance trace starts looking for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/eq.decidable\">docs#eq.decidable</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/decidable_eq_of_decidable_le\">docs#decidable_eq_of_decidable_le</a> which starts a massive search for order instances</p>",
        "id": 260170932,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635961571
    },
    {
        "content": "<p>But indeed this may be because I was using <code>rw [discriminant]</code> instead of <code>rw [discriminant_def]</code>, let me see.</p>",
        "id": 260171000,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635961600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> Did you try <code>convert this</code> at the beginning? If the only difference is that decidable instance in the type, then it should have worked.</p>",
        "id": 260171228,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635961708
    },
    {
        "content": "<p>I got a timeout.</p>",
        "id": 260171256,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635961728
    },
    {
        "content": "<p>Ah, here's the problem in <code>zero_of_not_linear_independent</code>; you need to <code>rw discriminant_def at h</code>. If you do that, the <code>by convert h</code> goes away, and it is much faster</p>",
        "id": 260171284,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635961749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260169891\">said</a>:</p>\n<blockquote>\n<p>In classical mode, we pretend there is a noncomputable \"algorithm\" that can make these decisions.</p>\n</blockquote>\n<p>This simply isn't true.</p>",
        "id": 260172346,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1635962216
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.dec\">docs#classical.dec</a>?</p>",
        "id": 260172465,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635962276
    },
    {
        "content": "<p>You can pretend anything you want but mathematicians don't pretend there is an algorithm here.</p>",
        "id": 260172570,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1635962309
    },
    {
        "content": "<p>This kind of wording really isn't helping anything.</p>",
        "id": 260172650,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1635962341
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> thank you! Now everything seems to be working normal. I am not sure I've understood what was the problem at the beginning, and why I cannot simply put <code>open_locale classical</code>, but I am happy anyway.</p>",
        "id": 260172840,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635962404
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Thanks for the feedback that the scare quotes and wording aren't effective. How would you say it?</p>",
        "id": 260172945,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635962425
    },
    {
        "content": "<p>The main point is that going to classical mode is declaring not to be interested in computability aspects. It's not \"pretending\" false things.</p>",
        "id": 260173214,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1635962538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span>, the problem comes down to the fact that when you forget to put <code>decidable_eq T</code> in a lemma statement, then either:</p>\n<ul>\n<li>You have no <code>open_locale classical</code>, and lean complains at you that you must add the argument. If you add this argument, your lemma is now as general as it need to be, and applies to all decision procedures.</li>\n<li>You have <code>open_locale classical</code>, and lean inserts <code>classical.dec_eq</code> or equivalent. As a result, your lemma is now <strong>about the  <code>classical.dec_eq</code>  instance</strong>, and not about arbitrary decision algorithms any more</li>\n</ul>\n<p>The problem with the second outcome is that a later lemma inevitably introduces a decision algorithm such as \"nat equality is obvious\", and your lemma doesn't apply to it because your lemma is only about \"the algorithm chosen using choice\"</p>",
        "id": 260173341,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635962593
    },
    {
        "content": "<p>A more useful explanation is to give more details about how Lean uses decidable stuff. But I think this is already covered in TPIL.</p>",
        "id": 260173349,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1635962595
    },
    {
        "content": "<p>I have a WIP linter that would have identified this problem, but I haven't found time to get it working properly</p>",
        "id": 260173682,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635962752
    },
    {
        "content": "<p>And then why it is OK to have <code>open_locale classical</code> for definitions?</p>",
        "id": 260174271,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635962979
    },
    {
        "content": "<p>It's about whether the instance appears on the LHS or the RHS of the <code>:=</code>. Letting classical instances leak into your type (aka statement) instead of parameterizing your type is almost always a bad idea, letting them leak into your implementation (aka proof) is fine</p>",
        "id": 260175309,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635963391
    },
    {
        "content": "<p>Perhaps a better spelling would have been to use the <code>classical</code> tactic in <code>discriminant</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Given an `A`-algebra `B` and `b`, an `ι`-indexed family of elements of `B`, we define</span>\n<span class=\"sd\">`discriminant A ι b` as the determinant of `trace_matrix A ι b`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">discriminant</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">classical</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">trace_matrix</span> <span class=\"n\">A</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">det</span>\n\n<span class=\"c1\">-- this needs a `decidable_eq` argument otherwise it's not general enough</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">discriminant_def</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">discriminant</span> <span class=\"n\">A</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">trace_matrix</span> <span class=\"n\">A</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">det</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">convert</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>which also avoids the <code>open_locale classical</code></p>",
        "id": 260175422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635963445
    },
    {
        "content": "<p>The real problem here is the idea that <code>matrix.det</code> \"depends\" on the <code>decidable_eq ι</code> instance at all</p>",
        "id": 260176171,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635963788
    },
    {
        "content": "<p>What would you propose? If you replaced that with a classical instance, this wouldn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix.determinant</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">matrix.det</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"mi\">2</span><span class=\"o\">],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]]</span>\n</code></pre></div>",
        "id": 260176469,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635963923
    },
    {
        "content": "<p>That seems fine</p>",
        "id": 260176632,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635963989
    },
    {
        "content": "<p>Ok, I think I understand now the issue with my code. I can go home and let the discussion to you <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 260176883,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1635964107
    },
    {
        "content": "<p>It's not like the definition of <code>matrix.det</code> is a good algorithm anyways</p>",
        "id": 260176974,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635964149
    },
    {
        "content": "<p>Tying together the definition of a thing with the way to compute that thing just leads to a definition which is bad for both reasoning about and computing</p>",
        "id": 260177093,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635964190
    },
    {
        "content": "<p>Unfortunately, I think mathlib is too far down this road already</p>",
        "id": 260177164,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635964207
    },
    {
        "content": "<p>Ah, your argument being that in lean4 we can still attach an efficient determinant implementation to a noncomputable definition?</p>",
        "id": 260177204,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635964224
    },
    {
        "content": "<p>You could do it in Lean 3</p>",
        "id": 260177307,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635964281
    },
    {
        "content": "<p>Oh, actually I think I agree with your original claim after all</p>",
        "id": 260177324,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635964289
    },
    {
        "content": "<p>The only reason it requires <code>decidable_eq</code> is because <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multilinear_map.map_add'\">docs#multilinear_map.map_add'</a> uses it in a proof field</p>",
        "id": 260177351,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635964307
    },
    {
        "content": "<p>That's ridiculous, we can just use the classical instance in that field</p>",
        "id": 260177374,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635964318
    },
    {
        "content": "<p>Or put a <code>[decidable_eq \\io]</code> argument on it</p>",
        "id": 260177497,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635964355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260177164\">said</a>:</p>\n<blockquote>\n<p>Unfortunately, I think mathlib is too far down this road already</p>\n</blockquote>\n<p>We always boast that mathlib isn't scared of large refactors. So this seems like a challenge. If we know what to do, let's just turn the library on its head.</p>",
        "id": 260178895,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1635964958
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260177497\">said</a>:</p>\n<blockquote>\n<p>Or put a <code>[decidable_eq \\io]</code> argument on it</p>\n</blockquote>\n<p>I'm going ahead with this to see what happens</p>",
        "id": 260179228,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635965131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260176469\">said</a>:</p>\n<blockquote>\n<p>What would you propose? If you replaced that with a classical instance, this wouldn't work:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix.determinant</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">matrix.det</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"mi\">2</span><span class=\"o\">],</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>If we want to remove the decidability argument here, I would suggest having <code>matrix.gaussian_elim_det</code> and prove <code>matrix.gaussian_elim_det = matrix.det</code></p>",
        "id": 260179871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1635965407
    },
    {
        "content": "<p>The decidability argument isn't even used in the computation, I don't think</p>",
        "id": 260179919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635965431
    },
    {
        "content": "<p>It's used in a type it doesn't need to be in</p>",
        "id": 260179946,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635965442
    },
    {
        "content": "<p>In fact, I think you can't even do gaussian elimination in an arbitrary ring, so we would need it to be a separate definition anyway</p>",
        "id": 260179986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1635965459
    },
    {
        "content": "<p>There are polynomial-size arithmetic circuits (using only ring operations) to compute determinants but for computations that come up in practice, yeah, you would usually be working over a ring (or field!) where a better algorithm is available</p>",
        "id": 260180223,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635965553
    },
    {
        "content": "<p>huh, I just checked wikipedia and all the listed O(n^3) algorithms require a field</p>",
        "id": 260180519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1635965685
    },
    {
        "content": "<p>I don't remember whether the arithmetic circuits are O(n^3), might be O(n^4). It was not so easy to find this stuff.</p>",
        "id": 260180602,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635965719
    },
    {
        "content": "<p>Is it possible to extend the ring to a field of fractions? There might be characteristic constraints</p>",
        "id": 260180688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1635965760
    },
    {
        "content": "<p>Aha: <a href=\"http://page.mi.fu-berlin.de/rote/Papers/pdf/Division-free+algorithms.pdf\">http://page.mi.fu-berlin.de/rote/Papers/pdf/Division-free+algorithms.pdf</a></p>",
        "id": 260180915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1635965849
    },
    {
        "content": "<p>indeed it's O(n^4)</p>",
        "id": 260180925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1635965855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260179946\">said</a>:</p>\n<blockquote>\n<p>It's used in a type it doesn't need to be in</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/issues/10140\">#10140</a> (wip, needs propagating downstream)</p>",
        "id": 260183480,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635967074
    },
    {
        "content": "<p>This makes declaring multilinear_maps slightly harder, but using them easier</p>",
        "id": 260183553,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635967093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260176632\">said</a>:</p>\n<blockquote>\n<p>That seems fine</p>\n</blockquote>\n<p>To be explicit, the simplest version of what I suggest would be to rename the current definition to <code>matrix.det_naive_impl</code> and wrap it in a <code>by classical</code> wrapper named <code>matrix.det</code> (like you suggested Riccardo do for <code>discriminant</code>), and continue to have all the lemmas be about the new <code>matrix.det</code>. Then in your <code>#eval</code> you have to type <code>#eval matrix.det_naive_impl</code>, but this isn't a big deal because if you wanted to compute the determinant of a matrix that wasn't tiny you would have needed to select a less naive implementation anyways.</p>",
        "id": 260185083,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635967742
    },
    {
        "content": "<p>It seems pretty clear to me that being able to write <code>#eval matrix.det</code> instead of <code>#eval matrix.det_naive_impl</code> is not worth paying this <code>decidable_eq</code> tax whenever you just want to prove stuff.</p>",
        "id": 260185364,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635967880
    },
    {
        "content": "<p>Of course if it happens that in this case the <code>decidable_eq</code> instance was unnecessary anyways then that's fine too.</p>",
        "id": 260185587,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635967979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260178895\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260177164\">said</a>:</p>\n<blockquote>\n<p>Unfortunately, I think mathlib is too far down this road already</p>\n</blockquote>\n<p>We always boast that mathlib isn't scared of large refactors. So this seems like a challenge. If we know what to do, let's just turn the library on its head.</p>\n</blockquote>\n<p>There's a way that almost works, and if we had an additional feature (<code>erased_param</code>) I think it should be very possible.  The idea of <code>erased_param</code> is that it marks arguments that the VM should erase, in addition to the <code>Prop</code> arguments it already erases.</p>\n<p>Here's what goes wrong right now.  A variant of <code>decidable</code> but for types rather than props could be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">computable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"n\">value</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>so then if <code>x</code> is some noncomputable thing, <code>computable.value x</code> could potentially give a computable version.  However, this <code>x</code> argument \"infects\" everything with noncomputableness, even if it is never used, like in this contrived example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">unit'</span> <span class=\"bp\">|</span> <span class=\"n\">mk</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">unit'</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">unit'.mk</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">unit'.mk'</span> <span class=\"o\">:</span> <span class=\"n\">unit'</span> <span class=\"o\">:=</span> <span class=\"n\">classical.choice</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"c1\">-- (!)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">unit'.mk'.computable</span> <span class=\"o\">:</span> <span class=\"n\">computable</span> <span class=\"n\">unit'.mk'</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">value</span> <span class=\"o\">:=</span> <span class=\"n\">unit'.mk</span><span class=\"o\">,</span>\n  <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">unit'.mk'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>If it were possible to write the class as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">computable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">erased_param</span> <span class=\"bp\">$</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"n\">value</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then (assuming in my ignorance that all the engineering challenges can be worked out) that instance wouldn't be noncomputable anymore and you would be allowed to do <code>#eval computable.value unit'.mk'</code>.</p>\n<p>Other systems have this feature, like <a href=\"https://agda.readthedocs.io/en/v2.6.1/language/runtime-irrelevance.html\">Agda</a>.</p>",
        "id": 260186582,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635968411
    },
    {
        "content": "<p>(Instances of <code>computable</code> are free to depend on as many <code>computable</code> and <code>decidable</code> instances as they might want.)</p>",
        "id": 260186713,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635968484
    },
    {
        "content": "<p>Kyle, didn't you have a version of something like this before that used <code>erased</code>? Does</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">computable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">erased</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"n\">erased.mk</span> <span class=\"n\">value</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>work?</p>",
        "id": 260186991,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635968617
    },
    {
        "content": "<p>Yeah, it's possible to mimic this using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/erased\">docs#erased</a>, but I couldn't really get it to work in a smooth way.</p>",
        "id": 260187042,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635968641
    },
    {
        "content": "<p>In particular, using typeclass inference to build general <code>computable</code> instances from others.  (I didn't try <em>that</em> hard, to be honest.)</p>",
        "id": 260187202,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635968714
    },
    {
        "content": "<p>I guess what I would try is to put every instance in the form <code>computable (erased.mk _)</code> and have instances like <code>[computable (erased.mk a)] [computable (erased.mk b)] : computable (erased.mk (a + b))</code>... but you probably already tried that</p>",
        "id": 260187680,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635968923
    },
    {
        "content": "<p>Maybe for <code>Prop</code> the fact that we have connectives that already work on the \"erased\" form is important, I don't know.</p>",
        "id": 260187790,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635968978
    },
    {
        "content": "<p>That instance would have exposed noncomputable <code>a</code> and <code>b</code> though</p>",
        "id": 260187813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1635968990
    },
    {
        "content": "<p>Here were some experiments: <a href=\"https://gist.github.com/kmill/3808acff688ff3c0f26bc743146bcf4a\">https://gist.github.com/kmill/3808acff688ff3c0f26bc743146bcf4a</a></p>\n<p>The problem is that <code>computable (erased.mk _)</code> poisons computability, so you need something else.  I tried some notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">omni</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">0</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">(</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">erased</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(\"omniscient\").  This lets you write <code>computable (omni _)</code> without that poisoning.</p>",
        "id": 260187821,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635968993
    },
    {
        "content": "<p>but now that extra syntax is going to get in the way of typeclass inference</p>",
        "id": 260188069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1635969099
    },
    {
        "content": "<p>That was indeed the problem, and I couldn't find any way around that.</p>",
        "id": 260188240,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635969149
    },
    {
        "content": "<p>I wonder if this is enough information for Leo to implement first-class <a href=\"https://leanprover-community.github.io/mathlib_docs/find/erased\">docs#erased</a> in the compiler? If <code>erased A</code> was defeq to <code>A</code> then everything would work</p>",
        "id": 260188646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1635969333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260185587\">said</a>:</p>\n<blockquote>\n<p>Of course if it happens that in this case the <code>decidable_eq</code> instance was unnecessary anyways then that's fine too.</p>\n</blockquote>\n<p>Turns out I'm wrong, while the instance is unnecessary in <code>multilinear_map</code>, it's still needed by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.sign\">docs#equiv.perm.sign</a></p>",
        "id": 260194168,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635971817
    },
    {
        "content": "<p>Does the laplacian expansion of det also need decidable_eq? Probably, since it's a sum over fintypes?</p>",
        "id": 260194621,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635972031
    },
    {
        "content": "<p>Isn't <code>(-1)^(i + j)</code> meaningless if your indices aren't ordered?</p>",
        "id": 260194968,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635972228
    },
    {
        "content": "<p>I feel like any attempt to generalize that term will require decidability</p>",
        "id": 260195030,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635972246
    },
    {
        "content": "<p>BTW reading the paper Mario shared, we have clows, called cycle, and cycles, which are cycle.nodup</p>",
        "id": 260195181,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635972349
    },
    {
        "content": "<p>Maybe if you want to avoid <code>decidable_eq</code> in <code>matrix.det</code> you could create a <code>finset (bool × finset (n × n))</code>, where <code>finset (n × n)</code> represents the graph of a permutation of <code>n</code> and the <code>bool</code> is its sign.  Given one of these containing all permutations, you can define the determinant using the sum-over-permutations definition.</p>\n<p>What might work for creating this is taking a <code>list n</code> representative <code>l</code> for <code>finset.univ</code>, calculating <code>list.permutations l</code> and zipping each with <code>l</code>, showing there are no dups so these lists can be written as a <code>finset (n × n)</code>, then working out the sign sequence for these partitions and zipping the <code>finset</code>s with that, showing the resulting list has no dups to create a <code>finset</code>, and then showing the resulting <code>finset</code> didn't depend on the <code>list n</code> representative.  It seems like <code>decidable_eq</code> isn't needed for any of these steps.  (Though I'm not sure it's worth it.)</p>",
        "id": 260202756,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635976388
    },
    {
        "content": "<p>FWIW given that <code>fintype</code> is constructive, it's odd that it doesn't provide decidable equality--it's not any of the standard constructive meanings of \"finite\".</p>",
        "id": 260203352,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635976763
    },
    {
        "content": "<p>This is because of the definition of list.nodup doesn't require decidable equality, iirc</p>",
        "id": 260203653,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635976898
    },
    {
        "content": "<p>At least, why it doesn't require it. Could one use it to provide a decidable_eq instance?</p>",
        "id": 260203753,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1635976939
    },
    {
        "content": "<p>It doesn't need one because it's a <code>Prop</code>.  If <code>list.nodup</code> were a <code>decidable_pred</code>, I think you could manufacture a <code>decidable_eq</code>.</p>",
        "id": 260203827,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635976992
    },
    {
        "content": "<p>I think a faster way to describe Kyle's construction is to see that <code>fintype X</code> is basically <code>trunc</code> of a <code>bijection</code> <code>fin n -&gt; X</code>, so if you have a matrix indexed by <code>X</code> you can precompose the rows and columns by that bijection and then take the determinant of that <code>n</code> x <code>n</code> matrix.</p>",
        "id": 260204009,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635977099
    },
    {
        "content": "<p>The usual notion of finiteness would be <code>trunc</code> of an <code>equiv</code> <code>fin n -&gt; X</code>.</p>",
        "id": 260204048,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635977124
    },
    {
        "content": "<p>That's a lot better than what I suggested.</p>",
        "id": 260204093,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635977152
    },
    {
        "content": "<p>You still need to check that this isn't dependent on the <code>bijection</code> but if you don't mind admitting classical reasoning to prove this then there's certainly no problem.</p>",
        "id": 260204203,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635977197
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.trunc_equiv_fin\">docs#fintype.trunc_equiv_fin</a></p>",
        "id": 260204274,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635977241
    },
    {
        "content": "<p>Which requires decidable equality</p>",
        "id": 260204456,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635977348
    },
    {
        "content": "<p>This is assuming <code>decidable_eq</code>--so having decidable equality is exactly being able to upgrade from <code>bijection</code> to <code>equiv</code> (since <code>fin n</code> definitely has decidable equality)</p>",
        "id": 260204462,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635977352
    },
    {
        "content": "<p>What are you referring to by <code>bijection</code> here? <code>subtype bijective</code>?</p>",
        "id": 260204615,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635977449
    },
    {
        "content": "<p>In fact now I realize that what's weird about <code>fintype</code> is precisely that it mixes <code>trunc</code> and <code>bijection</code>, when most constructive settings don't even have both of these as distinct concepts.</p>",
        "id": 260204654,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635977482
    },
    {
        "content": "<p>The point is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.complete\">docs#fintype.complete</a> is a <code>Prop</code>, when it \"should\" be some kind of witness data</p>",
        "id": 260204755,
        "sender_full_name": "Reid Barton",
        "timestamp": 1635977549
    },
    {
        "content": "<p>Do we have <code>fintype.trunc_fin_embedding</code> that says fin (card X) embeds into a finite type X?</p>",
        "id": 260204910,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635977648
    },
    {
        "content": "<p>That wouldn't need decidable equality, which I think is what you were saying above.</p>",
        "id": 260204965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635977685
    },
    {
        "content": "<p>It's funny how there's a difference between <code>trunc {f : fin n -&gt; X // bijective f}</code>, which is whether the type's elements can be listed (but you don't know where in the list any given element is), and <code>trunc {f : X -&gt; fin n // bijective f}</code> which is whether each element can be numbered (but you can't list out the elements).  The second one implies decidable equality, and the first is basically <code>fintype</code>.</p>",
        "id": 260205107,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635977772
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> This should do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fintype.trunc_fin_bijective</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">trunc</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">fintype.card</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">function.bijective</span> <span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">dunfold</span> <span class=\"n\">fintype.card</span> <span class=\"n\">finset.card</span> <span class=\"n\">at</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">quot.rec_on_subsingleton</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finset.univ</span> <span class=\"n\">α</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nd</span> <span class=\"o\">:</span> <span class=\"n\">l.nodup</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">l.length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">trunc.mk</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">finset.mem_univ_val</span> <span class=\"n\">finset.univ.2</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n  <span class=\"n\">subst</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">l.nth_le</span> <span class=\"n\">i</span> <span class=\"n\">i.property</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nd.nth_le_inj_iff</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">fin.ext</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">list.mem_iff_nth_le</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260207442,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635979327
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/10141\">#10141</a></p>",
        "id": 260213961,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1635984080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260180915\">said</a>:</p>\n<blockquote>\n<p>Aha: <a href=\"http://page.mi.fu-berlin.de/rote/Papers/pdf/Division-free+algorithms.pdf\">http://page.mi.fu-berlin.de/rote/Papers/pdf/Division-free+algorithms.pdf</a></p>\n</blockquote>\n<p>Speaking of which, someone coincidentally posted a codegolf challenge about a division-free O(n^4) determinant algorithm yesterday: <a href=\"https://codegolf.stackexchange.com/questions/236835/birds-algorithm-for-computing-determinants\">https://codegolf.stackexchange.com/questions/236835/birds-algorithm-for-computing-determinants</a></p>",
        "id": 260342199,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636064132
    },
    {
        "content": "<blockquote>\n<p>Yes @pajonk, I think we can agree that a 1x1 matrix is not really a matrix</p>\n</blockquote>\n<p>I believe that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>×</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">1 \\times 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> matrices exist, and that they are different. <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 260342529,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636064311
    },
    {
        "content": "<p>lean says that \"they are different\" doesn't typecheck</p>",
        "id": 260342748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636064473
    },
    {
        "content": "<p>So they are very different!</p>",
        "id": 260343086,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636064728
    },
    {
        "content": "<p>\"They are different\" probably means that they are not <a href=\"https://leanprover-community.github.io/mathlib_docs/find/heq\">docs#heq</a> and I'm not sure that we can prove it.</p>",
        "id": 260344397,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636065542
    },
    {
        "content": "<p>I encountered another problem similar to the first one in this thread. In a proof, if I put</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n</code></pre></div>\n<p>everything is OK, but with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">classical.dec_eq</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>there is a problem. Does this mean there is a problem somewhere or I should just use <code>classical.prop_decidable</code> and be happy?</p>",
        "id": 261236018,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1636713907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/260342529\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Yes @pajonk, I think we can agree that a 1x1 matrix is not really a matrix</p>\n</blockquote>\n<p>I believe that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>×</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">1 \\times 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> matrices exist, and that they are different. <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>\n</blockquote>\n<p>Fun fact: according to Lean, the type of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> matrices <em>equals</em> the type of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> matrices.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.matrix.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">empty</span> <span class=\"n\">m</span> <span class=\"n\">R</span> <span class=\"bp\">=</span> <span class=\"n\">matrix</span> <span class=\"n\">empty</span> <span class=\"n\">n</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">empty</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 261238353,
        "sender_full_name": "David Wärn",
        "timestamp": 1636715511
    },
    {
        "content": "<p>Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span>?</p>",
        "id": 261244513,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636719803
    },
    {
        "content": "<p>I think I have understood the problem: I recently added <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.aeval_root_derivative_of_splits\">docs#polynomial.aeval_root_derivative_of_splits</a>. This lemma uses, in the statement, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.erase\">docs#multiset.erase</a>, that has <code> [decidable_eq α]</code> as an assumption.<br>\nThe point is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.aeval_root_derivative_of_splits\">docs#polynomial.aeval_root_derivative_of_splits</a> does <em>not</em> have any <code> [decidable_eq]</code> in the assumptions, since at the beginning of the file there is <code>open_locale classical</code>, so I think Lean just uses <code>λ (a b : L), classical.prop_decidable (eq a b)</code>. Now, if I use that lemma somewhere else where the same instance is filled using <code>classical.dec_eq L</code> I get a problem. Indeed</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">logic.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">),</span> <span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">classical.dec_eq</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>does not work. I don't know if this is the intended behavior  or not. Maybe the correct solution is just to add <code>[decidable_eq L]</code> in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.aeval_root_derivative_of_splits\">docs#polynomial.aeval_root_derivative_of_splits</a> even if there is <code>open_locale classical</code>?</p>",
        "id": 261245383,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1636720393
    },
    {
        "content": "<p>So in practice I've solved my problem and I think I even really understood it :)</p>",
        "id": 261245404,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1636720413
    },
    {
        "content": "<p>The problem is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.dec_eq\">docs#classical.dec_eq</a> is a <code>lemma</code> but carries data</p>",
        "id": 261246251,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636720937
    },
    {
        "content": "<p>Lean never unfolds lemmas</p>",
        "id": 261246267,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636720947
    },
    {
        "content": "<p>Apparently that's necessary: <a href=\"https://leanprover-community.github.io/mathlib_docs/notes.html#classical%20lemma\">https://leanprover-community.github.io/mathlib_docs/notes.html#classical%20lemma</a></p>",
        "id": 261246357,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636721003
    },
    {
        "content": "<p>I think that the confusion, at least for me, comes from the fact that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>is <em>less</em> general than</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">foo1</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">T</span><span class=\"o\">]</span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>even if in <code>foo1</code> it seems to be one assumption more than in <code>foo</code>.</p>",
        "id": 261246948,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1636721307
    },
    {
        "content": "<p>Because <code>foo</code> only applies to the <code>decidable_eq</code> produced by <code>classical</code>, while <code>foo1</code> applies to any <code>decidable_eq</code> instance.</p>",
        "id": 261247018,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1636721354
    },
    {
        "content": "<p>This is surely a stupid thing, but I've understood it before</p>",
        "id": 261247066,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1636721383
    },
    {
        "content": "<p>Yes, that's certainly true, but it doesnt'explain why <code>classical.prop_decidable</code> and <code>classical.dec_eq</code> aren't equivalent by <code>rfl</code> despite having the same implementation</p>",
        "id": 261247375,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636721536
    },
    {
        "content": "<p>I opened <a href=\"https://github.com/leanprover-community/mathlib/issues/10292\">#10292</a> to see if the library note is still true</p>",
        "id": 261247448,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636721603
    },
    {
        "content": "<p>Sure, that is a deeper question. At the moment I am just looking to understand how to do classical mathematics, and I am more and more convinced  that <code>open_locale classical</code> is not always the right way.</p>",
        "id": 261247689,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1636721756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/261238353\">said</a>:</p>\n<blockquote>\n<p>Fun fact: according to Lean, the type of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> matrices <em>equals</em> the type of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> matrices.</p>\n</blockquote>\n<p>I assume this doesn't work for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> vs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>×</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">1 \\times 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> nor $1 \\times 0$$ vs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>×</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">2\\times 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>?</p>",
        "id": 261249045,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636722557
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/261238353\">said</a>:</p>\n<blockquote>\n<p>Fun fact: according to Lean, the type of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> matrices <em>equals</em> the type of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span> matrices.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.matrix.basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">empty</span> <span class=\"n\">m</span> <span class=\"n\">R</span> <span class=\"bp\">=</span> <span class=\"n\">matrix</span> <span class=\"n\">empty</span> <span class=\"n\">n</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">empty</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>For those who are confused by this example (which included me), first consider this example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">empty_pi</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">empty</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">empty</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">empty</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subsingleton.elim</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This proof makes sense: <code>α</code> and <code>β</code> are both \"functions\" out of the empty type, so they're equal, so the Pi-types of them must also be equal.<br>\nNow  the arrow-case is a direct consequence of this (recall that <code>X → Y</code> is just notation for <code>Π _ : X, Y</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">empty_arrow</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">empty</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">empty</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">empty_pi</span>\n</code></pre></div>\n<p>and that's how the above proof works.</p>",
        "id": 261258500,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1636727002
    },
    {
        "content": "<p>ha ha that's a funny proof David. Can you prove <code>matrix m empty = matrix n empty</code>? I'm not so sure this is provable.</p>",
        "id": 261277346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636734831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/261247066\">said</a>:</p>\n<blockquote>\n<p>This is surely a stupid thing, but I've understood it before</p>\n</blockquote>\n<p>Here's another weird \"choosing stuff\" thing. These computer scientists took the axiom of choice too far. You know when in a proof we say \"OK we know this set can't be empty so let's just choose an element at random; I don't care which one it is but I know it has these properties and those will be enough to finish the proof\". The computer scientists want to know which element we pick, but we don't care, we would happily choose a different element next year when we are lecturing the same proof, so the computer scientists made this <code>classical.choice</code> thing where they <em>choose exactly the same element every time</em>. Before I appreciated this, I just thought that this choice axiom did nothing more than <code>cases h with x hx</code> when the goal was a Type, but then when I realised it was always the same <code>x</code> as opposed to a random one I think I felt a little giddy.</p>",
        "id": 261278546,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636735361
    },
    {
        "content": "<p>Same here!</p>",
        "id": 261282544,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1636737148
    },
    {
        "content": "<p>That's one reason to sometimes avoid <code>classical.choice</code> in definitions: since it's actually picking out some unknown-to-you but very specific element, there's nothing that requires you to prove the choice it made didn't matter.  (What if by some unlucky coincidences you manage to prove a \"false\" theorem because all the definitions chose the same elements with <code>classical.choice</code>?)</p>\n<p>I was trying to think of the cases that feel safe to use it (from an avoiding-unluckly-coincidences perspective), and the only thing that comes to mind is when you want to extract the element of a singleton type (that includes the classical decidable instances).</p>\n<p>There seems to be an awkward way to make it so you have to show choices didn't matter, but it's pretty awkward.  If each definition that uses choice in a non-unique way exposes an arbitrariness type (for the auxiliary data that we imagine the choice function uses to make its choices), then you're forced to prove that the choice didn't matter.  But then you have to manage these arbitrariness types and thread them correctly through all your definitions...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Select an element of  `α` using the data from `x`. -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">my_choice</span> <span class=\"o\">{</span><span class=\"n\">κ</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">sigma.snd</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">classical.choice</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">),</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h.some</span><span class=\"o\">⟩⟩)</span>\n</code></pre></div>\n<p>The point is that this is now unprovable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">unprovable</span> <span class=\"o\">{</span><span class=\"n\">κ</span> <span class=\"n\">κ'</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">κ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">κ'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_choice</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">my_choice</span> <span class=\"n\">x'</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But that's no good if everyone just chooses a random number:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">provable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_choice</span> <span class=\"mi\">37</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">my_choice</span> <span class=\"mi\">37</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 261284748,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636738121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/261278546\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113488-general/topic/A.20possible.20diamond/near/261247066\">said</a>:</p>\n<blockquote>\n<p>This is surely a stupid thing, but I've understood it before</p>\n</blockquote>\n<p>Here's another weird \"choosing stuff\" thing. These computer scientists took the axiom of choice too far. You know when in a proof we say \"OK we know this set can't be empty so let's just choose an element at random; I don't care which one it is but I know it has these properties and those will be enough to finish the proof\". The computer scientists want to know which element we pick, but we don't care, we would happily choose a different element next year when we are lecturing the same proof, so the computer scientists made this <code>classical.choice</code> thing where they <em>choose exactly the same element every time</em>. Before I appreciated this, I just thought that this choice axiom did nothing more than <code>cases h with x hx</code> when the goal was a Type, but then when I realised it was always the same <code>x</code> as opposed to a random one I think I felt a little giddy.</p>\n</blockquote>\n<p>In some sense isn't this the whole point of choice. I was always confused by choice because in order to prove <code>nonempty α</code> you have to provide a witness anyway so why not just return the witness provided. Then I realised that the power lay in the fact that it always returns the same element regardless of the witness. I realised this when proving Lagrange's theorem. To prove the isomorphism of sets <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo>×</mo><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>H</mi><mo>≃</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">H × G / H ≃ G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> you need choice. Given <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">g \\in G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> you send it to the pair <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>g</mi><mo separator=\"true\">,</mo><mi>a</mi><mi>H</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(a^{-1}g, aH)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> is an element of the same coset as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span>. You use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> to prove nonemptiness of the coset containing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> but you have to make sure you always choose the same element of the coset regardless of what element of the coset you start with.</p>\n<p>I quite the following alternative version of choice when introducing the concept. They won't have to understand the difference between <code>nonempty</code> and <code>inhabited</code> or anything like that to understand it. It is <code>∀ {α : Sort u}, ∃ f : α → α, ∀ x y, f x = f y</code>. I can't remember how strong it is compared with the other versions. I think it's pretty weak but I think it still covers a lot of uses of choice. I thought about this once but I can't remember.</p>",
        "id": 283942660,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1653514036
    },
    {
        "content": "<p>There is another theorem called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.axiom_of_choice\">docs#classical.axiom_of_choice</a> (rarely used in mathlib because <code>classical.choice</code> is easier) which is closer to the version found in the textbooks. The reason <code>classical.choice</code> being a function is important is that it lets you use it in lambdas to get statements like <code>classical.axiom_of_choice</code>; it is actually strictly stronger though since <code>axiom_of_choice</code> still keeps everything behind an existential so it is not <code>noncomputable</code> in the lean sense and you can't use it to define noncomputable things</p>",
        "id": 283946384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653516279
    },
    {
        "content": "<p>I guess the point is that the function should be random but not the element.</p>",
        "id": 283946560,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1653516416
    },
    {
        "content": "<p>the function should be a <em>function</em></p>",
        "id": 283947026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653516729
    },
    {
        "content": "<p>this is a rare case where the function-ness is the important part</p>",
        "id": 283947046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653516744
    },
    {
        "content": "<p>Reading the proof of <a href=\"https://en.wikipedia.org/wiki/Diaconescu%27s_theorem\">Diaconescu's theorem</a> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.em/src\">src#classical.em</a>) is great for understanding how powerful this property is</p>",
        "id": 283947132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1653516826
    }
]
[
    {
        "content": "<p>Let's say we have a function whose type is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p'</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Here,  <code>α</code> and <code>β</code> are types, and <code>p</code> and <code>p'</code> have types <code>α → β → Prop</code> and <code>α × β → Prop</code> respectively.<br>\nThe ordered pair <code>(a, b)</code> is in the product. This is a little annoying because <code>c</code> is not definitionally equal to <code>(c.1, c.2)</code>.</p>\n<p>Another way to write this function would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test'</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">c.1</span> <span class=\"n\">c.2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p'</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">test</span> <span class=\"n\">c.1</span> <span class=\"n\">c.2</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Unfortunately, this definition of <code>test'</code> doesn't seem to work, because of the above problem with unifying <code>c</code> with <code>(c.1, c.2)</code>.</p>\n<p>On the other hand, it does work the other way around:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Everything type checks</span>\n<span class=\"kd\">def</span> <span class=\"n\">test'</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">c.1</span> <span class=\"n\">c.2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p'</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p'</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">test'</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Does this mean writing in the second format -- so that ordered pairs do not appear in types -- is preferable? Or is there an easy way to get from <code>test</code> to <code>test'</code>?</p>\n<p>My use case is <code>path.prod</code>, which has type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">prod</span> <span class=\"o\">{</span><span class=\"n\">a₁</span> <span class=\"n\">b₁</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a₂</span> <span class=\"n\">b₂</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">γ₁</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">a₁</span> <span class=\"n\">b₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ₂</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">a₂</span> <span class=\"n\">b₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"o\">(</span><span class=\"n\">a₁</span><span class=\"o\">,</span> <span class=\"n\">a₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b₁</span><span class=\"o\">,</span> <span class=\"n\">b₂</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>whereas I want to use it in a situation where the paths go from <code>c₁.1</code> to <code> c₂.1</code> and <code>c₁.2</code> to <code>c₂.2</code> for some <code>c₁</code> and <code>c₂</code>.</p>\n<p>Would it be preferable if the type was</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">prod</span> <span class=\"o\">{</span><span class=\"n\">c₁</span> <span class=\"n\">c₂</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">γ₁</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">c₁.1</span> <span class=\"n\">c₂.1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ₂</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">c₁.2</span> <span class=\"n\">c₂.2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">c₁</span> <span class=\"n\">c₂</span>\n</code></pre></div>",
        "id": 266477716,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1640920488
    },
    {
        "content": "<p>can you make a mwe? it seems to me that everything should typecheck</p>",
        "id": 266478268,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640921318
    },
    {
        "content": "<p>Here's a toy case that doesn't type check:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p'</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">test'</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">c.1</span> <span class=\"n\">c.2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p'</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">test</span> <span class=\"n\">c.1</span> <span class=\"n\">c.2</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 266478566,
        "sender_full_name": "Praneeth Kolichala",
        "timestamp": 1640921837
    },
    {
        "content": "<p>ahh, I see. I guess the \"correct\" way to do this is with the equation compiler:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p'</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">test'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">c.1</span> <span class=\"n\">c.2</span><span class=\"o\">),</span> <span class=\"n\">p'</span> <span class=\"n\">c</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">test</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>but I'm really not sure what's preferrable</p>",
        "id": 266478709,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640922061
    },
    {
        "content": "<p>(or if you don't wanna mess with indices <code>match</code> and so on)</p>",
        "id": 266478717,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640922086
    },
    {
        "content": "<p>You can use the equation compiler, or since you have a prop, you can use tactic mode and case split your c.</p>",
        "id": 266479125,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640922771
    },
    {
        "content": "<p>Or you can switch to lean4 where c should be defeq to (c.fst,c.snd) (I think?)</p>",
        "id": 266479183,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1640922843
    },
    {
        "content": "<p>woah, I didn't know we had eta in lean4!</p>",
        "id": 266479731,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640923654
    },
    {
        "content": "<p>If we do that's news to me. I thought we were just asking for it</p>",
        "id": 266494238,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640945086
    },
    {
        "content": "<p><a href=\"#narrow/stream/116290-rss/topic/Recent.20Commits.20to.20lean4.3Amaster/near/262462713\">https://leanprover.zulipchat.com/#narrow/stream/116290-rss/topic/Recent.20Commits.20to.20lean4.3Amaster/near/262462713</a></p>",
        "id": 266494423,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640945348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"437861\">Praneeth Kolichala</span> <a href=\"#narrow/stream/113488-general/topic/Ordered.20pair.20in.20type.20of.20result/near/266477716\">said</a>:</p>\n<blockquote>\n<p>Would it be preferable if the type was</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">prod</span> <span class=\"o\">{</span><span class=\"n\">c₁</span> <span class=\"n\">c₂</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">γ₁</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">c₁.1</span> <span class=\"n\">c₂.1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ₂</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">c₁.2</span> <span class=\"n\">c₂.2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">path</span> <span class=\"n\">c₁</span> <span class=\"n\">c₂</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I think so. You can also think of it as a backwards-style \"how to build a path in a product of spaces\", rather than a forwards-style \"what can I do with a pair of paths\".<br>\nIf we indulge in a bit of free association, the type of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.ext\">docs#prod.ext</a> is analogous.</p>",
        "id": 266518305,
        "sender_full_name": "Reid Barton",
        "timestamp": 1640976715
    }
]
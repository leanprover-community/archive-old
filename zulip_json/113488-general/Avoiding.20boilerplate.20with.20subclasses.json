[
    {
        "content": "<p>Hi,</p>\n<p>I am trying to prepare for some geometry introduction to Lean, where students will need to prove facts about synthetic geometry, using concepts like lines, segments, rays, angles, circles, triangles,... All these have in common that they are subsets of the plane, which are \"distinguished\" in some way, so I decided that there would be structures corresponding to each of them, which would remember how they were created. Ideally I would redefine then the equality sign (a ray is defined by two points -it's the half-line starting at the first and containing the second point-, but the second point is not uniquely determined given a ray). If I'm not mistaken, the equality cannot be changed, so instead I go for has_equiv. Here is a mwe of what I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pts</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IncidencePlane</span> <span class=\"o\">(</span><span class=\"n\">Point</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">Line</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">belongs</span> <span class=\"o\">:</span> <span class=\"n\">Point</span> <span class=\"bp\">→</span> <span class=\"n\">Line</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">between</span> <span class=\"o\">:</span> <span class=\"n\">Point</span> <span class=\"bp\">→</span> <span class=\"n\">Point</span> <span class=\"bp\">→</span> <span class=\"n\">Point</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">IncidencePlane</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IncidencePlane</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Stuff about Line</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">Line</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">belongs</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">Line</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">pts</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- Stuff about Segment</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Segment</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span>\n<span class=\"kd\">infix</span> <span class=\"bp\">`⬝`</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"o\">:=</span> <span class=\"n\">Segment.mk</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Segment</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">Segment</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">P</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">between</span> <span class=\"n\">S.A</span> <span class=\"n\">P</span> <span class=\"n\">S.B</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_equiv</span> <span class=\"o\">(</span><span class=\"n\">Segment</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">S.A</span> <span class=\"bp\">=</span> <span class=\"n\">T.A</span> <span class=\"bp\">∧</span> <span class=\"n\">S.B</span> <span class=\"bp\">=</span> <span class=\"n\">T.B</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">S.A</span> <span class=\"bp\">=</span> <span class=\"n\">T.B</span> <span class=\"bp\">∧</span> <span class=\"n\">S.B</span> <span class=\"bp\">=</span> <span class=\"n\">T.A</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">Segment.has_coe_to_set</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">Segment</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">pts</span><span class=\"o\">⟩</span>\n<span class=\"kd\">end</span> <span class=\"n\">Segment</span>\n\n<span class=\"c1\">-- Stuff about Ray</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Ray</span> <span class=\"o\">(</span><span class=\"n\">Point</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">):=</span>\n    <span class=\"o\">(</span><span class=\"n\">origin</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span>\n<span class=\"kd\">notation</span> <span class=\"n\">A</span> <span class=\"bp\">`=&gt;`</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">Ray.mk</span> <span class=\"n\">A</span> <span class=\"n\">B</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Ray</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">Ray</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">P</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">between</span> <span class=\"n\">r.origin</span> <span class=\"n\">P</span> <span class=\"n\">r.target</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">between</span> <span class=\"n\">r.origin</span>  <span class=\"n\">r.target</span>  <span class=\"n\">P</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_equiv</span> <span class=\"o\">(</span><span class=\"n\">Ray</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">S.origin</span> <span class=\"bp\">=</span> <span class=\"n\">T.origin</span> <span class=\"bp\">∧</span> <span class=\"o\">((</span><span class=\"n\">between</span> <span class=\"n\">S.origin</span> <span class=\"n\">S.target</span> <span class=\"n\">T.target</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">between</span> <span class=\"n\">S.origin</span> <span class=\"n\">T.target</span> <span class=\"n\">S.target</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">has_coe_to_set</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">Ray</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">pts</span><span class=\"o\">⟩</span>\n<span class=\"kd\">end</span> <span class=\"n\">Ray</span>\n\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">⬝</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">=&gt;</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">IncidencePlane</span>\n</code></pre></div>\n<p>As you can see, both <code>Segment</code> and <code>Ray</code>are instances of <code>has_mem</code> (they are subsets of points) and have a defined notion of equivalence <code>has_equiv</code>. When defining a new such object, I need to write a bunch of code that deals with this. I would like to instead have them be instances of a class, say <code>Subset Ω</code>, so that something like this would make the last checks pass:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Segment</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span><span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Subset</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n<span class=\"o\">(</span><span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"bp\">...</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">equiv</span> <span class=\"o\">:</span> <span class=\"bp\">...</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>and then I would be able to, given <code>S : Segment Ω</code>, consider <code>S.A</code>, <code>S.B</code>, and also <code>S : set Ω</code>. I'm sure that this is possible, I tried something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Subset</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">has_mem_subset</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">subset</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">P</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">S.mem</span> <span class=\"n\">P</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">coe_subset_to_set</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">subset</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">pts</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>but I am a bit lost. Any pointers?</p>\n<p>Thank you.</p>",
        "id": 284751513,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1654179378
    },
    {
        "content": "<p>Do you know about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sym2\">docs#sym2</a>?</p>",
        "id": 284751902,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1654179559
    },
    {
        "content": "<p>That would probably help with segments, but not with the rest of distinguished subsets, right?</p>",
        "id": 284752420,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1654179830
    },
    {
        "content": "<p>Here's a more concise question. I'd like to avoid the line <code>instance : has_coe (Segment Ω) (Subset Ω) := ⟨λ S, S.to_Subset⟩</code> in the code below, at the cost of adding as many lines as necessary in the <code>Segment</code> part.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IncidencePlane</span> <span class=\"o\">(</span><span class=\"n\">Point</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">Line</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">between</span> <span class=\"o\">:</span> <span class=\"n\">Point</span> <span class=\"bp\">→</span> <span class=\"n\">Point</span> <span class=\"bp\">→</span> <span class=\"n\">Point</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">IncidencePlane</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">IncidencePlane</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Subset</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">has_mem_subset</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"bp\">Ω</span> <span class=\"o\">(</span><span class=\"n\">Subset</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">P</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">Subset.mem</span> <span class=\"bp\">Ω</span> <span class=\"n\">S</span> <span class=\"n\">P</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">coe_subset_to_set</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">Subset</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">}⟩</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Segment</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Subset</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">Segment</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Subset</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">S.to_Subset</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Segment_mk</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Segment</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">mem</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">between</span> <span class=\"n\">A</span> <span class=\"n\">P</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n  <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">B</span> <span class=\"o\">}</span>\n<span class=\"kd\">infix</span> <span class=\"bp\">`⬝`</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"o\">:=</span> <span class=\"n\">Segment_mk</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">A</span><span class=\"bp\">⬝</span><span class=\"n\">B</span> <span class=\"c1\">-- works</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">⬝</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"c1\">-- WANT THIS TO WORK</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">IncidencePlane</span>\n</code></pre></div>",
        "id": 284779151,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1654191691
    },
    {
        "content": "<p>It works for me in the sense that there are no errors. What do you want to happen? Output is <code>↑(A⬝B) : set Ω</code>.</p>",
        "id": 284779617,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654191899
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> it works as is, but I want to reduce the boilerplate needed to declare the Segment stuff. I have half a more structures like Segment (Ray, Angle, Circle, Triangle) and for each of them now I need about 6 lines of code. It seems to me that it should be doable in one line (plus one more to define notation)...</p>",
        "id": 284812622,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1654208457
    }
]
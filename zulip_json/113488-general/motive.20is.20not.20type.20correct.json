[
    {
        "content": "<p>I'm not sure where this belongs, probably not <a class=\"stream\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members\">#new members</a> , so <a class=\"stream\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general\">#general</a> it is.</p>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib/issues/3498\">#3498</a>, Floris raised the idea that an approach going through a list of digits might be nicer than strong induction on the natural numbers. However that requires the lemma that <code>0 &lt; (digits b m).last _</code>, which from what I can tell is not in mathlib yet. However, when I try to write a proof for this, I get stuck with <code>motive is not type correct</code> or just <code>failed</code> when I'm rewriting. What does this mean? and any suggestions are welcome.</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"304229\">@Angela Li</span> </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">digits</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">digits_ne_nil_iff_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">digits</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"o\">[]</span> <span class=\"bp\">↔</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">last_digit_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">digits</span> <span class=\"n\">b</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">last</span> <span class=\"o\">((</span><span class=\"n\">digits_ne_nil_iff_ne_zero</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">hm</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"bp\">_|_|</span><span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> This one is trivial, proof omitted -/</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> This one can be done by existing lemmas, proof omitted -/</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c\">/-</span><span class=\"cm\"> This case I haven&#39;t got a clue for -/</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">digits</span><span class=\"o\">],</span> <span class=\"c\">/-</span><span class=\"cm\"> Why does `simp` work and `rw` not work? -/</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">digits_aux_def</span><span class=\"o\">],</span> <span class=\"c\">/-</span><span class=\"cm\"> motive is not type correct? But now `simp` also fails... -/</span>\n    <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 204738496,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1595463854
    },
    {
        "content": "<p>does <code>simp_rw</code> work?</p>",
        "id": 204738628,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1595463966
    },
    {
        "content": "<p>The problem is that the <code>_</code> in your goal also has a copy of <code>digits_aux ...</code> in it, and when you try to rewrite the visible one, Lean complains that the type-dependency might break.</p>",
        "id": 204738680,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595464020
    },
    {
        "content": "<p>It does work when I change the <code>simp</code> to <code>simp_rw</code>, but not when I change the <code>rw</code> to <code>simp_rw</code></p>",
        "id": 204738696,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1595464041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/motive.20is.20not.20type.20correct/near/204738680\">said</a>:</p>\n<blockquote>\n<p>The problem is that the <code>_</code> in your goal also has a copy of <code>digits_aux ...</code> in it, and when you try to rewrite the visible one, Lean complains that the type-dependency might break.</p>\n</blockquote>\n<p>Right, so am I approaching this from a wrong perspective? Is the fact that <code>list.last</code> takes a proof which depends on rest of the term causing the issue here?</p>",
        "id": 204738794,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1595464123
    },
    {
        "content": "<p>Yes.</p>",
        "id": 204739223,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595464504
    },
    {
        "content": "<p>Just in case this is <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>, <a href=\"https://gist.github.com/shingtaklam1324/3fe981a9162ef2b62a9e6e26226f8297\">here</a> is the rest of the code in context of that PR, but this lemma is probably nice to have anyways</p>",
        "id": 204739249,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1595464526
    },
    {
        "content": "<p>Does this (incomplete) help:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">=</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">last</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">last</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">digits</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"err\">%</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">::</span> <span class=\"n\">digits</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"bp\">_|_|</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"bp\">_|</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">digits_last</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">digits</span> <span class=\"n\">b</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">last</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">digits</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">/</span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">last</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"n\">b</span> <span class=\"n\">m</span> <span class=\"n\">h</span> <span class=\"n\">hm</span><span class=\"o\">),</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 204739898,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595465173
    },
    {
        "content": "<p>It does help, but then I feel like I'm going to need strong induction for this at some point, since I would need a statement about <code>digits b (m/b)</code>. Trying <code>nat.strong_induction_on m</code> doesn't work, presumably for the same reason.  So I'm not sure what approach to take here.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">last_digit_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">):</span>\n  <span class=\"o\">(</span><span class=\"n\">digits</span> <span class=\"n\">b</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">last</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"bp\">_|_|</span><span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> This one is trivial, proof omitted -/</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> This one can be done by existing lemmas, proof omitted -/</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">strong_induction_on</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"c1\">-- error about failed unification,kind of expected</span>\n   <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 204751741,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1595466763
    },
    {
        "content": "<p>Some students are asking me what all this \"motive is not type correct\" stuff is about, and I realise I can't explain it properly. Here's something pretty minimal which I managed to knock up:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hQ</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hPQ</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">ite</span> <span class=\"n\">P</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- rw hPQ, -- motive is not type correct</span>\n  <span class=\"c1\">-- `simp_rw [hPQ]` and `simp only [hPQ]` don't work either</span>\n  <span class=\"n\">delta</span> <span class=\"n\">ite</span><span class=\"o\">,</span> <span class=\"c1\">-- _inst_1.rec_on (λ (hnc : ¬P), 2) (λ (hc : P), 1) = 1</span>\n  <span class=\"c1\">-- oh look, a term `_inst_1` whose type mentions `P`</span>\n  <span class=\"n\">unfreezingI</span> <span class=\"o\">{</span><span class=\"n\">cases</span> <span class=\"n\">_inst_1</span> <span class=\"k\">with</span> <span class=\"n\">hfalse</span> <span class=\"n\">htrue</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"c1\">-- ⊢ 2 = 1 but contradictory hypotheses</span>\n    <span class=\"n\">finish</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"c1\">-- ⊢ 1 = 1</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- The previous proof uses propext somewhere. This one uses it</span>\n<span class=\"c1\">-- explicitly</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hQ</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hPQ</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">ite</span> <span class=\"n\">P</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">hPQ'</span> <span class=\"o\">:=</span> <span class=\"n\">propext</span> <span class=\"n\">hPQ</span><span class=\"o\">,</span> <span class=\"c1\">-- now P and Q are *equal*</span>\n  <span class=\"n\">subst</span> <span class=\"n\">hPQ'</span><span class=\"o\">,</span> <span class=\"c1\">-- `hQ : P` lol</span>\n  <span class=\"n\">rw</span> <span class=\"n\">if_pos</span> <span class=\"n\">hQ</span><span class=\"o\">,</span> <span class=\"c1\">-- we win</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Is it possible to solve every \"motive is not type correct\" error just by manually taking stuff apart?</p>\n<p>I have finally discovered how to search for old threads in a stream. Click on a stream, click \"more topics\" at the bottom of the list and then search for the topic you want. Doing this I navigated to this old thread above. <span class=\"user-mention\" data-user-id=\"266440\">@Shing Tak Lam</span> these were really nice puzzles. Do we still need any of the below?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.digits</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"c1\">--set_option pp.proofs true</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">digits_ne_nil_iff_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">digits</span> <span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"o\">[]</span> <span class=\"bp\">↔</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">not_congr</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"c1\">-- tidy up</span>\n      <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">b.digits</span> <span class=\"n\">d.succ</span> <span class=\"bp\">≠</span> <span class=\"n\">list.nil</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n      <span class=\"n\">clear</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- next line only works for b&gt;=2 so deal with base cases first</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"k\">suffices</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">b.succ.succ.digits</span> <span class=\"n\">d.succ</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">b.succ.succ.digits</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n          <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n          <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">},</span>\n        <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">d.succ</span> <span class=\"bp\">%</span> <span class=\"n\">b.succ.succ</span><span class=\"o\">,</span> <span class=\"n\">d.succ</span> <span class=\"bp\">/</span> <span class=\"n\">b.succ.succ</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n        <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">digits_add</span> <span class=\"n\">b.succ.succ</span> <span class=\"n\">dec_trivial</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">mod_lt</span> <span class=\"n\">_</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n        <span class=\"o\">{</span> <span class=\"n\">congr'</span><span class=\"o\">,</span>\n          <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">nat.div_add_mod</span> <span class=\"n\">_</span> <span class=\"n\">b.succ.succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">using</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n          <span class=\"n\">ring</span> <span class=\"o\">},</span>\n        <span class=\"o\">{</span> <span class=\"n\">by_contra</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n          <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n          <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩,</span>\n          <span class=\"n\">rw</span> <span class=\"n\">nonpos_iff_eq_zero</span> <span class=\"n\">at</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n          <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span> <span class=\"o\">:</span> <span class=\"n\">d.succ</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n          <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">nat.div_add_mod</span> <span class=\"n\">d.succ</span> <span class=\"n\">b.succ.succ</span><span class=\"o\">,</span>\n          <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n      <span class=\"o\">},</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">{</span><span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span><span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">--#eval nat.digits 0 4</span>\n<span class=\"c1\">--#eval nat.digits_aux 2 dec_trivial 6</span>\n<span class=\"c1\">--#check list.last_repeat_succ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat.digits_succ</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">digits</span> <span class=\"n\">b</span> <span class=\"n\">n.succ</span> <span class=\"bp\">≠</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">digits_ne_nil_iff_ne_zero</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_ne_zero</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"c1\">--#check @one_le_div</span>\n<span class=\"c1\">--#where</span>\n<span class=\"c1\">--#check le_div_iff_mul_le -- ambiguous overload</span>\n\n<span class=\"c1\">-- couldn't find this lemma in mathlib</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">nat.one_le_div</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">nat.le_div_iff_mul_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n  <span class=\"n\">congr'</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">one_mul</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"c1\">--set_option pp.proofs true</span>\n\n<span class=\"c1\">-- b=0,1 special cases dealt with directly;</span>\n<span class=\"c1\">-- b&gt;=2 use strong induction and nat.digits_add_two_add_one</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">last_digit_succ_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">digits</span> <span class=\"n\">b</span> <span class=\"n\">n.succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">last</span>\n  <span class=\"o\">(</span><span class=\"n\">nat.digits_succ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- b = 0</span>\n  <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- b = 1</span>\n  <span class=\"n\">cases</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">one_ne_zero</span><span class=\"o\">,</span>\n    <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"c1\">-- come on Lean -- is that a bug in convert?</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">digits_one</span> <span class=\"n\">n.succ</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">list.last_repeat_succ</span><span class=\"o\">]</span> <span class=\"o\">},</span> <span class=\"c1\">-- worked</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nat.strong_induction_on</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">clear</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">lt_or_le</span> <span class=\"n\">n.succ</span> <span class=\"n\">b.succ.succ</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">hnb</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">hbn</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))),</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">digits_of_lt</span> <span class=\"n\">b.succ.succ</span> <span class=\"n\">n.succ</span> <span class=\"n\">dec_trivial</span> <span class=\"n\">hnb</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- boss level 2≤b</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">digits_add_two_add_one</span><span class=\"o\">],</span>\n    <span class=\"k\">have</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">rwa</span> <span class=\"n\">nat.one_le_div</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"n\">list.last_cons</span><span class=\"o\">,</span>\n    <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"c1\">-- remove easier leg first</span>\n    <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">nat.digits_succ</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">nat.sub_add_cancel</span> <span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"c1\">-- use induction hypothesis</span>\n      <span class=\"n\">convert</span> <span class=\"n\">h</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">nat.sub_add_cancel</span> <span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">},</span>\n      <span class=\"n\">refine</span> <span class=\"n\">lt_of_lt_of_le</span> <span class=\"o\">(</span><span class=\"n\">nat.sub_lt</span> <span class=\"n\">foo</span> <span class=\"n\">zero_lt_one</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">nat.div_le_of_le_mul'</span><span class=\"o\">,</span>\n      <span class=\"n\">nlinarith</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"c1\">-- wow,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Again I could always wriggle out of the motive is not type correct thing by using <code>change</code> to change nasty <code>eq.rec</code> or whatever embedded proofs into nicer ones.</p>",
        "id": 274225535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646463497
    },
    {
        "content": "<p>The motive is whatever you're left with once you take out every occurrence of the term you want to rewrite. So if you want to rewrite <code>P</code> in <code>@ite P (_inst : decidable P) 1 2</code>, the motive looks something like <code>@ite ? (_inst : decidable ?) 1 2</code>. And <code>_inst : decidable ?</code> is not type-correct if <code>?</code> is a free variable, so you get a type error.</p>",
        "id": 274261555,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1646509745
    },
    {
        "content": "<p>Similarly for the induction, the motive is what you're left with once you take out the induction variable.</p>",
        "id": 274261658,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1646509902
    },
    {
        "content": "<p>(They are really the same thing since rewriting is just induction on <code>eq</code>.)</p>",
        "id": 274261751,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1646510038
    },
    {
        "content": "<p>So this error really is a consequence of dependent types: the term that you are trying to rewrite appears in the type of some other subterm. Sometimes you can fix it by providing a better motive along the lines of <code>refine @nat.induction_on (λ k, some_predicate_on k (but_not n)) n _ _</code> (or using the <code>occurrences</code> option of <code>rw</code>). Other times you can get rid of the dependent type entirely.</p>",
        "id": 274261881,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1646510175
    },
    {
        "content": "<p>Right -- I saw examples of this yesterday. The dependent type was embedded in a proof and I could supply another much simpler proof of the same statement, insert it with <code>change</code> and then the rewrite would work</p>",
        "id": 274262631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646511139
    },
    {
        "content": "<p>It seems that the motive could always be made type-correct by inserting <code>cast</code>s in the right places? Maybe that could even be done automatically?</p>",
        "id": 274297857,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1646562099
    },
    {
        "content": "<p>This is done automatically, by <code>simp</code></p>",
        "id": 274303712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646570278
    },
    {
        "content": "<p>Which leaves the question why <code>simp</code> does not always solve \"motive not type correct\" situations.<br>\nOr does it?</p>",
        "id": 274361513,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1646641909
    }
]
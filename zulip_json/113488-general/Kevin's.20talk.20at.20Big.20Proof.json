[
    {
        "content": "<p>I've just uploaded <a href=\"https://youtu.be/PSQq0RbgWH8\" target=\"_blank\" title=\"https://youtu.be/PSQq0RbgWH8\">Kevin's talk</a> at the Big Proof meeting at Edinburgh.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"PSQq0RbgWH8\" href=\"https://youtu.be/PSQq0RbgWH8\" target=\"_blank\" title=\"https://youtu.be/PSQq0RbgWH8\"><img src=\"https://i.ytimg.com/vi/PSQq0RbgWH8/default.jpg\"></a></div>",
        "id": 166800148,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1559123657
    },
    {
        "content": "<p><a href=\"http://wwwf.imperial.ac.uk/~buzzard/docs/buzzard_big_proof2019.pdf\" target=\"_blank\" title=\"http://wwwf.imperial.ac.uk/~buzzard/docs/buzzard_big_proof2019.pdf\">http://wwwf.imperial.ac.uk/~buzzard/docs/buzzard_big_proof2019.pdf</a></p>",
        "id": 166801608,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559125238
    },
    {
        "content": "<p>What if there was a theorem prover where whenever you declared a structure, unless you explicitly declared that you wouldn't (with the <code>evil</code> keyword or something :D), you had to provide a notion of isomorphism, and it was then illegal to make a definition which used the structure without that definition being transportable over under your defined notion of isomorphism?</p>",
        "id": 166806202,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1559129973
    },
    {
        "content": "<p>Isn't that more or less HoTT?</p>",
        "id": 166806271,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559130007
    },
    {
        "content": "<p>I have no idea</p>",
        "id": 166806276,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1559130011
    },
    {
        "content": "<p>HoTT even figures out the notion of isomorphism for you</p>",
        "id": 166806304,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559130028
    },
    {
        "content": "<p>hmm. I don't know anything about HoTT. But that world seems scary---and for some reason spheres are different!</p>\n<p>I just want <code>is_local R</code> to have an (autogenerated) proof that it is preserved by ring isomorphism!!</p>",
        "id": 166806374,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1559130108
    },
    {
        "content": "<p>I just love the aesthetic of <code>evil def dagger_category := ...</code></p>",
        "id": 166806448,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1559130166
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Here's your missing M1F problem:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">set_theory</span><span class=\"bp\">.</span><span class=\"n\">zfc</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Set</span>\n\n<span class=\"n\">def</span> <span class=\"n\">of_nat</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"err\">∅</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"bp\">ℕ</span> <span class=\"n\">Set</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">of_nat</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">omega_nat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"err\">↑</span><span class=\"n\">n</span> <span class=\"err\">∈</span> <span class=\"n\">omega</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"n\">omega_zero</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">omega_succ</span> <span class=\"o\">(</span><span class=\"n\">omega_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">singleton_subset</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"err\">⊆</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">mem_singleton</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">rfl</span><span class=\"o\">),</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span> <span class=\"n\">c</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">mem_singleton</span> <span class=\"n\">c</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"n\">H</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">ne_empty_of_mem</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h0</span><span class=\"o\">,</span> <span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_empty</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"bp\">▸</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">insert_ne_empty</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span> <span class=\"o\">:=</span>\n<span class=\"n\">ne_empty_of_mem</span> <span class=\"err\">$</span> <span class=\"n\">mem_insert</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">succ_ne_empty</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"err\">∅</span> <span class=\"o\">:=</span> <span class=\"n\">insert_ne_empty</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">Set</span>\n<span class=\"kn\">open</span> <span class=\"n\">Set</span>\n\n<span class=\"n\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"err\">↑</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"err\">↑</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"err\">↑</span><span class=\"mi\">2</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"err\">↑</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"err\">↑</span><span class=\"mi\">2</span><span class=\"o\">}}</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">two_mem_X</span> <span class=\"o\">:</span> <span class=\"err\">↑</span><span class=\"mi\">2</span> <span class=\"err\">∈</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">mem_insert</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"err\">$</span> <span class=\"n\">mem_insert</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"err\">$</span> <span class=\"n\">mem_insert</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"err\">↑</span><span class=\"mi\">2</span><span class=\"o\">}</span> <span class=\"err\">∈</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">mem_insert</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"err\">$</span> <span class=\"n\">mem_insert</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"err\">↑</span><span class=\"mi\">2</span><span class=\"o\">}</span> <span class=\"err\">⊆</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">singleton_subset</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">two_mem_X</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"err\">↑</span><span class=\"mi\">2</span> <span class=\"err\">⊆</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">h</span> <span class=\"err\">∅</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"err\">↑</span><span class=\"mi\">0</span> <span class=\"err\">∈</span> <span class=\"o\">{</span><span class=\"err\">↑</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"err\">↑</span><span class=\"mi\">1</span><span class=\"o\">},</span> <span class=\"k\">from</span> <span class=\"n\">mem_insert</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"err\">$</span> <span class=\"n\">mem_singleton</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">rfl</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">mem_insert</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">insert_ne_empty</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">mem_insert</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">insert_ne_empty</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">mem_insert</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">succ_ne_empty</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">mem_insert</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">succ_ne_empty</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mem_empty</span> <span class=\"bp\">_</span> <span class=\"n\">h</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 166808352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559131895
    },
    {
        "content": "<p>I originally wrote <code>lists</code> to help solve this problem, but ZFC set theory approach works too. With <code>lists</code> the whole thing is decidable so you could just use <code>dec_trivial</code> for everything</p>",
        "id": 166808451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559131974
    },
    {
        "content": "<p>don't we have <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>V</mi><mi>ω</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_\\omega</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.03588em;\">ω</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> in mathlib or something</p>",
        "id": 166808487,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1559132021
    },
    {
        "content": "<p>yeah, that's <code>lists</code>, more or less</p>",
        "id": 166808495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559132037
    },
    {
        "content": "<p>it's actually finite ZFA</p>",
        "id": 166808556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559132078
    },
    {
        "content": "<p>so <code>X</code> here is a member of <code>lists nat</code> where the <code>nat</code> gives atoms at the bottom like <code>1</code> and <code>2</code>. Here I used finite von Neumann ordinals for 1 and 2 and so the final part is a bit tricky since you have to show that the empty set is not equal to <code>1</code> or <code>2</code></p>",
        "id": 166808666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559132163
    },
    {
        "content": "<blockquote>\n<p>What if there was a theorem prover where whenever you declared a structure, unless you explicitly declared that you wouldn't (with the <code>evil</code> keyword or something :D), you had to provide a notion of isomorphism, and it was then illegal to make a definition which used the structure without that definition being transportable over under your defined notion of isomorphism?</p>\n</blockquote>\n<p>I think this is just a matter of not ever writing <code>def my_predicate (X : Type) [group X] : Prop := ...</code>, and instead writing <code>def my_predicate_functorial (G : core Group) ⥤ Prop := ...</code>.</p>\n<p>One then hopes that the <code>map</code> field of the functor can be built by automation. Once that automation is in place, one goes back to just writing <br>\n<code>def my_predicate (X : Type) [group X] : Prop := ...</code>, but with <code>@[derive iso_functorial]</code> prepended, and then you have transport of structure using the tactic <code>iso_induction</code> Yiming is writing.</p>",
        "id": 166812545,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1559135363
    },
    {
        "content": "<p><code>isodef my_predicate (X : Type) [group X] : Prop := ...</code></p>",
        "id": 166814959,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1559136819
    },
    {
        "content": "<p>The difference between <code>@[derive iso_functorial] def</code> and <code>isodef</code> is not too big... I could handle that.</p>",
        "id": 166818965,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559138967
    },
    {
        "content": "<p>We (read: Mario and Floris) solved Larry's challenge in 3 days. Let's see what the other communities can do with Kevin's challenges (-;</p>",
        "id": 166835756,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559149636
    },
    {
        "content": "<p>I had a long talk to Larry Paulson after my talk. He was interested in how it all happened. Someone (I forgot who :-( ) told me that they were very sorry to lose Floris! Maybe they were from Nijmegen? Maybe it was Freek. </p>\n<p>I am leaving Big Proof now :-/ I have a talk to give in London tomorrow and I also need to get back to Imperial because I have an unformalisation project to supervise! The project is to take data.filter.basic and translate it into pdf form :-) Patrick told me that he didn't know a good reference for this stuff.</p>",
        "id": 166838802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559151642
    },
    {
        "content": "<p>Wow! <em>unformalisation</em>. That sounds like we're living the future.</p>",
        "id": 166838870,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559151697
    },
    {
        "content": "<p>I don't know how many Lean people there were at Big Proof 2017, but I really felt that we were the dominant tribe in Big Proof 2019. There was me, Sander Dahmen, Rob Lewis, Patrick Massot, Neil Strickland, Ed Ayers, Jeremy Avigad, Scott Morrison, and also all the people I've forgotten because I'm a fool. On the Isabelle side there was Larry Paulson, his post-docs Angeliki Koutsoukou Argyraki and Wenda Li, and Manuel Eberl and Mohammad Abdulaziz from Munich, and then representing other systems we had Peter Koepke and John Harrison (who I'd never met before and who is a really nice guy). I'm trying to list all the people who were into formalising mathematics; I have probably forgotten some people; I'll edit if I've made any real howlers.</p>\n<p>I found it very interesting talking to the Isabelle people.</p>",
        "id": 166839450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559152122
    },
    {
        "content": "<p>Wojciech Nawrocki was also there.</p>",
        "id": 166841061,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559153170
    },
    {
        "content": "<p>I'm proof reading the print proofs of one of my papers, and I realised that it has a nice example of the mathematicians code of honour:</p>\n<ul>\n<li>Definition 1.a: two gadgets X and Y are called <em>quasi-compatible</em> if blah...</li>\n<li>Definition 1.b: two gadgets X and Y are called <em>strongly quasi-compatible</em> if blah... and bleh...</li>\n<li>Remark: <span aria-label=\"warning\" class=\"emoji emoji-26a0\" role=\"img\" title=\"warning\">:warning:</span> it is not known whether strong quasi-compatibility is an equivalence relation.</li>\n</ul>",
        "id": 166841936,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559153710
    },
    {
        "content": "<p>I don't spend a word on whether <em>quasi-compatibility</em> is an equivalence relation. And the warning/remark was only added after Deligne pointed out to me that I should add the warning. <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 166842198,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559153882
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  Yeah, I did my master thesis under supervision of Freek, so it was probably him.</p>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Thanks for the nice video of the talk! And great talk as always, Kevin!</p>\n<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I've also done some unformalization of HoTT proofs, where the formal proof existed before it was written up anywhere.</p>",
        "id": 166850159,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559159373
    },
    {
        "content": "<blockquote>\n<p>What if there was a theorem prover where whenever you declared a structure, unless you explicitly declared that you wouldn't (with the <code>evil</code> keyword or something :D), you had to provide a notion of isomorphism, and it was then illegal to make a definition which used the structure without that definition being transportable over under your defined notion of isomorphism?</p>\n</blockquote>\n<p>Something based on Bourbaki's set theory? That would be evil.</p>",
        "id": 166858411,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1559165032
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2019/06/02/equality-part-3-canonical-isomorphism/\" target=\"_blank\" title=\"https://xenaproject.wordpress.com/2019/06/02/equality-part-3-canonical-isomorphism/\">https://xenaproject.wordpress.com/2019/06/02/equality-part-3-canonical-isomorphism/</a></p>\n<p><span class=\"user-mention\" data-user-id=\"130272\">@David Michael Roberts</span> grilled me on Twitter a bit about my claims about equality and how it's confused with canonical isomorphism by even the greatest mathematicians. I wrote some more about this on my blog, stuff which didn't make it into the talk. </p>\n<p>The more I think about canonical isomorphism, the more I realise how impossible it is to make a tactic which does everything a mathematician does with it -- not least because some stuff we do with it is really quite subtle.</p>",
        "id": 167095854,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559434210
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Here are some marvellous code snippets to kickstart your week: <a href=\"https://github.com/leanprover-community/mathlib/search?q=canonical&amp;unscoped_q=canonical\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/search?q=canonical&amp;unscoped_q=canonical\">https://github.com/leanprover-community/mathlib/search?q=canonical&amp;unscoped_q=canonical</a></p>",
        "id": 167152809,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559533734
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/1A93I7zDB6sia-NBym9GWFP3/32uczu.jpg\" target=\"_blank\" title=\"32uczu.jpg\">32uczu.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/1A93I7zDB6sia-NBym9GWFP3/32uczu.jpg\" target=\"_blank\" title=\"32uczu.jpg\"><img src=\"/user_uploads/3121/1A93I7zDB6sia-NBym9GWFP3/32uczu.jpg\"></a></div>",
        "id": 167519597,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559852985
    }
]
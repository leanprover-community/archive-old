[
    {
        "content": "<p>The current definition of an algebra has a severe problem: if you have type <code>X</code> with an existing <code>module R X</code> structure, it's impossible to put an <code>algebra R X</code> structure on it in such a way that the <code>module R X</code> structure derived from that <code>algebra R X</code> will be definitionally equal to the original one.</p>\n<p>(I ran into this just now trying to prove Schur's lemma in an <code>R</code>-linear category with finite dimensional hom spaces: every <code>X  ‚ü∂ Y</code> has a <code>module R (X ‚ü∂ Y)</code>, but we also need to talk about the <code>algebra R (X ‚ü∂ X)</code> structures.)</p>\n<p>Oliver Nash and I were trying a few weeks ago to replace this definition, moving to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_mul_assoc'</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">‚Ä¢</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">mul_smul_comm'</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">‚Ä¢</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Unfortunately it was proving a lot of work. About three weeks ago we ground to a halt, and in the intervening time <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>'s diamond refactoring PRs have arrived, and I'm not at all confident I can bring the existing half-working <a href=\"https://github.com/leanprover-community/mathlib/tree/replace_algebra_def\">branch#replace_algebra_def</a> up to master (I've just tried, and pushed, but who knows what state it is in... It's going to have further collisions with <a href=\"https://github.com/leanprover-community/mathlib/issues/7255\">#7255</a>.)</p>",
        "id": 235947738,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619247050
    },
    {
        "content": "<p>This alternative definition also has the nice feature that it generalises immediately to nonassociative and nonunital settings, unlike the current design.</p>",
        "id": 235947761,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619247103
    },
    {
        "content": "<p>I'm definitely game to work on this some more, but I thought it might be worth doing some coordination here first.</p>",
        "id": 235947804,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619247132
    },
    {
        "content": "<p>Perhaps the best strategy is actually to abandon the existing <a href=\"https://github.com/leanprover-community/mathlib/tree/replace_algebra_def\">branch#replace_algebra_def</a> (this makes me sad, and will probably make <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> even sadder, as he'd done a lot of work here!), and start over, after both <a href=\"https://github.com/leanprover-community/mathlib/issues/7255\">#7255</a> and <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>'s <a href=\"https://github.com/leanprover-community/mathlib/issues/7322\">#7322</a>.</p>",
        "id": 235947850,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619247205
    },
    {
        "content": "<p>Advice, complaints, or promises to contribute to the next attempt all welcome. :-)</p>",
        "id": 235947895,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619247246
    },
    {
        "content": "<p>I don't understand your first comment - surely <code>smul := has_scalar.smul</code> ensures definitional equality?</p>",
        "id": 235951473,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619251370
    },
    {
        "content": "<p>Hmm, okay, you're absolutely right, my problem in Schur's lemma is not about <code>algebra</code>. It is something even more basic, where I have an <code>add_comm_group</code> which is also a <code>ring</code>, and Lean can't see that it's only an <code>add_comm_group</code> in one way. :-(</p>",
        "id": 235956072,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619255443
    },
    {
        "content": "<p>If anyone feels like having a look at <code>findim_endomorphism_simple_eq_one</code> in <code>schur.lean</code> on <a href=\"https://github.com/leanprover-community/mathlib/tree/schur2\">branch#schur2</a>, I am stumped. If I can just get the <code>obtain</code> line to work everything is fine.</p>",
        "id": 235956168,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619255595
    },
    {
        "content": "<p>I had a look. The thing that creates problem is that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">findim_endomorphism_simple_eq_one</span>\n  <span class=\"o\">[</span><span class=\"n\">linear</span> <span class=\"bp\">ùïú</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">simple.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">X</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n\n<span class=\"bp\">@</span><span class=\"n\">finite_dimensional</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">End</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">category.to_category_struct</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span><span class=\"o\">)</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">_inst_4</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">preadditive.category_theory.End.add_comm_group</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"n\">_inst_2</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear.category_theory.End.module</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"n\">_inst_2</span> <span class=\"bp\">ùïú</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">euclidean_domain.to_comm_ring</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_euclidean_domain</span> <span class=\"bp\">ùïú</span> <span class=\"n\">_inst_4</span><span class=\"o\">))</span>\n       <span class=\"n\">_inst_6</span>\n       <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"bp\">=</span>\n  <span class=\"bp\">@</span><span class=\"n\">finite_dimensional</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">End</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">category.to_category_struct</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span><span class=\"o\">)</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">_inst_4</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring.to_add_comm_group</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">End</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">category.to_category_struct</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span><span class=\"o\">)</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">preadditive.category_theory.End.ring</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"n\">_inst_2</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">algebra.to_semimodule</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">End</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">category.to_category_struct</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span><span class=\"o\">)</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_comm_semiring</span> <span class=\"bp\">ùïú</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">euclidean_domain.to_comm_ring</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_euclidean_domain</span> <span class=\"bp\">ùïú</span> <span class=\"n\">_inst_4</span><span class=\"o\">)))</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">End</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">category.to_category_struct</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span><span class=\"o\">)</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">preadditive.category_theory.End.ring</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"n\">_inst_2</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear.category_theory.End.algebra</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"n\">_inst_2</span> <span class=\"bp\">ùïú</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">euclidean_domain.to_comm_ring</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_euclidean_domain</span> <span class=\"bp\">ùïú</span> <span class=\"n\">_inst_4</span><span class=\"o\">))</span>\n          <span class=\"n\">_inst_6</span>\n          <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n</code></pre></div>\n<p>fails. If you try to <code>congr</code> it away, you see that the first problem it encounters is with two <code>add_comm_group</code> which are obvisouly the same, but where Lean can not see it. Probably for lack of beta-reduction (or whatever greek letter is meant here): two structures have the same fields which are all defeq, but the structures themselves are not defeq. A way out is to make sure that the first structure is also an assembly of stuff, and not a monolithic structure, by replacing the line 89 of <code>preadditive/default.lean</code> with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">End</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">..</span> <span class=\"n\">preadditive.hom_group</span> <span class=\"n\">X</span> <span class=\"n\">X</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Once this is done, Lean can see that both <code>add_comm_group</code>s are defeq. Then it runs into the second problem that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">linear.category_theory.End.module</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">algebra.to_semimodule</span>\n</code></pre></div>\n<p>is not defeq either. I have not yet investigated this one.</p>",
        "id": 235961565,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619261992
    },
    {
        "content": "<p>Thanks very much <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> for having a look at this (I've been banging my head on this!!)</p>",
        "id": 235961742,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619262151
    },
    {
        "content": "<p>I found that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">nu</span><span class=\"o\">‚ü©</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">exists_spectrum_of_is_alg_closed_of_finite_dimensional</span> <span class=\"bp\">ùïú</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">End</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">End.of</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n</code></pre></div>",
        "id": 235961745,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619262159
    },
    {
        "content": "<p>works, if I run</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">semimodule</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">mul_action</span> <span class=\"n\">has_scalar</span>\n</code></pre></div>\n<p>before embarking on the proof.</p>",
        "id": 235961751,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619262176
    },
    {
        "content": "<p>Then <code>ext</code> blasts through to the fields, and <code>refl</code> verifies they really do match up.</p>",
        "id": 235961794,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619262198
    },
    {
        "content": "<p>This exactly fits with your diagnosis.</p>",
        "id": 235961803,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619262209
    },
    {
        "content": "<p>I'll see if your <code>{ .. }</code> trick (which I'm not sure whether I love or loath... :-) can solve the semimodule problem too.</p>",
        "id": 235961877,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619262275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60/near/235947850\">said</a>:</p>\n<blockquote>\n<p>Perhaps the best strategy is actually to abandon the existing <a href=\"https://github.com/leanprover-community/mathlib/tree/replace_algebra_def\">branch#replace_algebra_def</a> (this makes me sad, and will probably make <span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> even sadder, as he'd done a lot of work here!), and start over, after both <a href=\"https://github.com/leanprover-community/mathlib/issues/7255\">#7255</a> and <span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span>'s <a href=\"https://github.com/leanprover-community/mathlib/issues/7322\">#7322</a>.</p>\n</blockquote>\n<p>While I note that Eric has pointed out that we actually can solve the defeq problem by clobbering <code>smul</code>, I still plan to try to change the definition of <code>algebra</code> and I agree that we should probably just abandon <a href=\"https://github.com/leanprover-community/mathlib/tree/replace_algebra_def\">branch#replace_algebra_def</a>. I'm hoping to start again with a fresh branch in a week or so, hopefully after <a href=\"https://github.com/leanprover-community/mathlib/issues/7255\">#7255</a> and <a href=\"https://github.com/leanprover-community/mathlib/issues/7322\">#7322</a> have landed.</p>",
        "id": 235961995,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619262396
    },
    {
        "content": "<p>It's totally doable, just a matter of being persistent enough.</p>",
        "id": 235962013,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619262426
    },
    {
        "content": "<p>I am really starting to wonder it we should ditch once and for all old style structures, and go for new style structures. It should solve this problem as the structures would not be a bunch of random fields, but nice functions to the substructures that the structure extends, that we could arrange for equality in this kind of situation. Of course, this would be a crazy refactor, but we will probably have to do it at some point (both to solve our performance problems, this kind of issue, and to port to Lean 4)...</p>",
        "id": 235962152,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619262543
    },
    {
        "content": "<p><span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> Oh boy. :-) We should have listened to Leo back in ... 2017?</p>",
        "id": 235962286,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619262714
    },
    {
        "content": "<p>I wonder if we could write some code to perform such a refactor. It would be an awesome validation of the value of digital formalisation if it could be done. Most of the effort for a human carrying out such a task would be pretty  automatic and I bet that even when there is a choice to be made, it's usually from a smallish list so I could imagine some localised brute force approach would work.</p>",
        "id": 235962559,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619262990
    },
    {
        "content": "<p>Don't new style structures make this problem go away for only one \"canonical\" path through the algebra heirarchy DAG?</p>",
        "id": 235962609,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619263078
    },
    {
        "content": "<p>And leave exactly the same problem for non-canonical paths</p>",
        "id": 235962667,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619263104
    },
    {
        "content": "<p>I still think most of it should be human-driven, since there are choices to be made (i.e., what is the most important path along which we will go down the instances -- this is what one should extend) and what is more accessory. But I think it wouldn't be that bad, in fact.</p>",
        "id": 235962684,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619263131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60/near/235962609\">said</a>:</p>\n<blockquote>\n<p>Don't new style structures make this problem go away for only one \"canonical\" path through the algebra heirarchy DAG?</p>\n</blockquote>\n<p>Yes, exactly, it only solves the problem along the canonical paths. Which we should choose wisely to minimize the number of issues.</p>",
        "id": 235962702,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619263168
    },
    {
        "content": "<p>My impression is that the problem we're seeing here is due to different paths being taken in different places</p>",
        "id": 235962788,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619263224
    },
    {
        "content": "<p>So making one or the other canonical won't help</p>",
        "id": 235962849,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619263266
    },
    {
        "content": "<p>No, here it is really: define an <code>add_comm_group</code> instance <code>foo</code> on something, then defining a <code>ring</code> instance <code>bar</code> with <code>{ ..., .. foo}</code>, and then <code>bar.to_add_comm_group</code> is not defeq to <code>foo</code>.</p>",
        "id": 235962874,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619263310
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60/near/235962152\">said</a>:</p>\n<blockquote>\n<p>I am really starting to wonder it we should ditch once and for all old style structures, and go for new style structures. </p>\n</blockquote>\n<p>Really I'm not competent to judge. But Leo, who thought about the whole system more than anyone else by several order of magnitude, has a very strong opinion about this. I don't see how he could tell us more clearly that he thinks we should be using new structures.</p>",
        "id": 235965638,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1619266141
    },
    {
        "content": "<p>One could imagine a \"bit by bit\" refactor where leaves are turned into new structures first. </p>\n<p>What would a typical refactor look like, turning an old structure into a new structure? I personally don't know the difference between old structures and new structures, it's just some CS thing as far as I am concerned. One would delete the <code>old_structure_cmd</code> line, and then everything breaks, and then one redefines the structure causing the problem and/or adds a bunch of projection lemmas which used to be generated and now aren't?</p>",
        "id": 235966907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619267558
    },
    {
        "content": "<p>Here's a concrete question. It seems to me that <code>topology.algebra.open_subgroup</code> is only imported by <code>topology.algebra.nonarchimedean</code>, which is not imported by anything. Does it make sense to see what happens if we delete <code>set_option old_structure_cmd true</code> in that file and refactor? Or does the whole thing have to be done in one go?</p>",
        "id": 235967164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619267793
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7355\">#7355</a> It wasn't that hard to change <code>open_subgroup</code>. What difficulties will one run into in general? Ones of the form I saw (<code>cases U</code> changed behaviour) or far nastier ones? One down, about 50 to go!</p>",
        "id": 235968080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619268816
    },
    {
        "content": "<p>One type of the change that will come up - if you change <code>comm_group</code> to new style, you'll have to add a  new <code>mul_comm</code> field.</p>",
        "id": 235968449,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619269204
    },
    {
        "content": "<p>OK so I just deleted all of them in one go (the vast majority are in <code>src/algebra</code> BTW) and the first thing that breaks is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- An `add_monoid` is an `add_semigroup` with an element `0` such that `0 + a = a + 0 = a`. -/</span>\n<span class=\"kd\">@[ancestor add_semigroup add_zero_class]</span>\n<span class=\"kd\">class</span> <span class=\"n\">add_monoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">add_semigroup</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">add_zero_class</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">nsmul</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">M</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">nsmul_rec</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nsmul_zero'</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">nsmul</span> <span class=\"mi\">0</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">.</span> <span class=\"n\">try_refl_tac</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">nsmul_succ'</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">nsmul</span> <span class=\"n\">n.succ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">nsmul</span> <span class=\"n\">n</span> <span class=\"n\">x</span> <span class=\"bp\">.</span> <span class=\"n\">try_refl_tac</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I get an error on <code>add_zero_class M</code> in <code>extends add_semigroup M, add_zero_class M</code> and the error is</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>invalid 'structure' header, field 'to_has_add' from 'add_zero_class' has already been declared\n</code></pre></div>\n<p>So this means...what?  add_semigroups and add_zero_classes both have an <code>add</code>, I guess, but the actual complaint is that <code>add_semigroup.to_has_add</code> and <code>add_zero_class.to_has_add</code> both exist. </p>\n<p>Is one fix for this to literally not <code>extend</code> anything and just to write all the fields all over again and then just define the projections manually?</p>",
        "id": 235969018,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619269711
    },
    {
        "content": "<p>That's the only fix - you only get to extend things that don't overlap</p>",
        "id": 235969462,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619270113
    },
    {
        "content": "<p>So you have to decide which is most canonical</p>",
        "id": 235969476,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619270129
    },
    {
        "content": "<p>Eg, <code>comm_ring</code> can only extend one of <code>ring</code>, and <code>comm_semiring</code></p>",
        "id": 235969535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619270178
    },
    {
        "content": "<p>I suspect the correct choice is always the one with more data, in this case <code>ring</code> which has neg and sub</p>",
        "id": 235969558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619270225
    },
    {
        "content": "<p>Right. So for example with <code>add_monoid</code> it seems the thing to extend is <code>add_zero_class</code> and then add <code>assoc</code> manually. I'm currently trying to figure out how to prove a monoid is a semigroup.</p>",
        "id": 235969632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619270295
    },
    {
        "content": "<p>ooh suddenly loads of errors disappeared. This is quite satisfying. This is going to be a major but do-able refactor.</p>",
        "id": 235969678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619270361
    },
    {
        "content": "<p>It might be worth agreeing on canonical paths before going too far with this</p>",
        "id": 235969733,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619270406
    },
    {
        "content": "<p>Eg, get a graphviz file with the instance heirarchy, and agree on the correct spanning tree and highlight it in a different color.</p>",
        "id": 235969759,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619270433
    },
    {
        "content": "<p>Yes this is why I started, to try and understand what the main issues were.</p>",
        "id": 235969761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619270440
    },
    {
        "content": "<p>And to be quite honest the other reason I'm interested is that I trust Leo.</p>",
        "id": 235969823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619270477
    },
    {
        "content": "<p>So I think the biggest impact of this change would be that we end up with tens of copies of <code>(mul/add)_(assoc_comm)</code></p>",
        "id": 235970238,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619270954
    },
    {
        "content": "<p>A custom <code>newish_structure</code> command could generate those and the projections automatically though</p>",
        "id": 235970249,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619270994
    },
    {
        "content": "<p>Lol, we have to decide which of <code>cancel_monoid -&gt; left_cancel_monoid -&gt; monoid</code> and <code>cancel_monoid -&gt; right_cancel_monoid -&gt; monoid</code> is canonical</p>",
        "id": 235970991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619271757
    },
    {
        "content": "<p>Yeah, it is difficult to do this in my head. I am now staring at <code>cancel_comm_monoid</code> and trying to figure out whether I should be going to <code>left_cancel_monoid</code> or <code>comm_monoid</code>. In fact I realise now I don't understand what is going on. Presumably we still need the four theorems that a cancel_monoid is a left/right_cancel_monoid and a left/right_cancel_monoid is a monoid? And presumably they all have to be instances? I'm just showing my ignorance of the problem.</p>",
        "id": 235971314,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619272125
    },
    {
        "content": "<p>OK so on the <code>delete-old-structures</code> branch I deleted all old_structure_cmds and I fixed what looked like one of the most challenging files -- algebra/group/defs (of course I'll have broken a lot of the files it depends on). You can see what the diff looks like <a href=\"https://github.com/leanprover-community/mathlib/compare/delete-old-structures?expand=1#diff-9860a3e2f558fa016e7026f97d27d9196714b9948782edcc6b572689d674d839\">here</a></p>",
        "id": 235971807,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619272688
    },
    {
        "content": "<p>Yes, anything you remove from <code>extends</code> has to be added as an instance</p>",
        "id": 235971930,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619272817
    },
    {
        "content": "<p>You could avoid tie breaking by saying neither left nor right is canonical, and have <code>cancel_monoid</code> extend <code>monoid</code></p>",
        "id": 235971973,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619272855
    },
    {
        "content": "<p>Given that mathlib (currently) seems to favour left modules, I would choose <code>left_cancel_monoid</code>.</p>",
        "id": 235976491,
        "sender_full_name": "Julian K√ºlshammer",
        "timestamp": 1619276469
    },
    {
        "content": "<p>Anyway, there won't be a lot of things extending <code>cancel_monoid</code>, so this shouldn't really matter. There are essentially two kinds of classes: those that really play a role in the main hierarchy, and those that are merely gadgets to be able to state theorems in the right generality. The gadgets should probably never appear in the main hierarchy: there should be instances from the main classes to the gadgets, and theorems proved assuming the right gadget class.</p>",
        "id": 235977096,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619276672
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60/near/235970249\">said</a>:</p>\n<blockquote>\n<p>A custom <code>newish_structure</code> command could generate those and the projections automatically though</p>\n</blockquote>\n<p>As one of the main proponents for old structures, I should probably say something about this. The main technical problem with new structures as currently implemented in lean 3 is that they outright reject diamond inheritance. What I think it should do instead is that given <code>extends A, B, C</code> it will classify the superclasses according to whether they contain any fields also present in any superclasses earlier in the list (in which case they are marked non-canonical). All canonical superclasses are embedded, and non-canonical superclasses get a pack/unpack parent instance. That way, this is the same as new structures when there are no diamonds, and the same as old structures when there are diamonds, and when there is a mix it just does the right thing</p>",
        "id": 236029460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619316703
    },
    {
        "content": "<p>This doesn't change the observation made up-thread that we should be careful to make sure we get the right spanning tree of canonical extensions</p>",
        "id": 236029529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619316759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Replacing.20the.20definition.20of.20.60algebra.60/near/235969733\">said</a>:</p>\n<blockquote>\n<p>It might be worth agreeing on canonical paths before going too far with this</p>\n</blockquote>\n<p>I don't understand what this means. If foo extends bar1 and bar2, and both bar1 and bar2 extend bar, then we still surely need all the theorems foo -&gt; bar1, foo -&gt; bar2, bar1 -&gt; bar and bar2 -&gt; bar, so surely a defeq diamond is inevitable? Are we talking about priorities? I am a complete amateur at type class inference, I have little understanding of how it works and little understanding of the difference between old and new structures and little understanding of the issues in this thread, but I am interested to learn, not least because I can now finally announce that Oliver Nash is going to be my post-doc for the next three years and I'd like to understand what he's doing!</p>",
        "id": 236079708,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619370807
    },
    {
        "content": "<p>The issue isn't about defeq diamonds, but rather about minimizing the number of non-compositional(? - we need a name for this) instances, that is, instances where bar1 is not literally a member of foo and so we have to explode foo into fields and put them back together to produce an instance of bar1. These instances are large when foo has many fields and so we want to keep them to a minimum, but composition is necessarily diamond-free so they can't all be compositional instances</p>",
        "id": 236080045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619371140
    },
    {
        "content": "<p>An example: <code>semiring</code> could either extend <code>monoid_with_zero</code> and <code>has_one</code>, or it could extend <code>add_comm_monoid</code> and <code>monoid</code>. The second choice is clearly better than the first, since you will encounter much more often reductions of semirings to monoids and add_comm_monoids than to the more exotic <code>monoid_with_zero</code>.</p>",
        "id": 236080143,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619371221
    },
    {
        "content": "<p>PS this from the <a href=\"https://arxiv.org/abs/2001.04301\">tabled typeclass resolution</a> paper (the number is the number of routes to has_add, other than the 0 on has_add which is presumably an edge case)</p>\n<p><a href=\"/user_uploads/3121/KpPoEfmPtZN8J2V0uq33SpF3/routes_to_has_add.png\">routes_to_has_add.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/KpPoEfmPtZN8J2V0uq33SpF3/routes_to_has_add.png\" title=\"routes_to_has_add.png\"><img src=\"/user_uploads/3121/KpPoEfmPtZN8J2V0uq33SpF3/routes_to_has_add.png\"></a></div>",
        "id": 236080353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619371419
    },
    {
        "content": "<p>Here's a simple demonstration of the difference between old style and new style. In both cases I'm simulating what <code>extends</code> would do if you didn't have the keyword:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">bar1</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">bar2</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- new structure style inheritance</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">new_structure</span>\n<span class=\"kd\">class</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_bar1</span> <span class=\"o\">:</span> <span class=\"n\">bar1</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">to_bar2</span> <span class=\"o\">:</span> <span class=\"n\">bar2</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo.bar1</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar1</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"n\">foo.to_bar1</span>\n<span class=\"kd\">instance</span> <span class=\"n\">foo.bar2</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar2</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"n\">foo.to_bar2</span>\n<span class=\"kd\">end</span> <span class=\"n\">new_structure</span>\n\n<span class=\"c1\">-- old structure style inheritance</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">old_structure</span>\n<span class=\"kd\">class</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo.bar1</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar1</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">foo.x</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">foo.y</span><span class=\"o\">}</span>\n<span class=\"kd\">instance</span> <span class=\"n\">foo.bar2</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar2</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">foo.z</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">foo.w</span><span class=\"o\">}</span>\n<span class=\"kd\">end</span> <span class=\"n\">old_structure</span>\n</code></pre></div>",
        "id": 236080459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619371543
    },
    {
        "content": "<p>And here's an example where <code>bar1</code> uses new style inheritance and <code>bar2</code> uses old style inheritance (they can't both use new style in this case because of the shared field <code>x</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">bar1</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">bar2</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mixed_structure</span>\n<span class=\"kd\">class</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_bar1</span> <span class=\"o\">:</span> <span class=\"n\">bar1</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo.bar1</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar1</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"n\">foo.to_bar1</span>\n<span class=\"kd\">instance</span> <span class=\"n\">foo.bar2</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar2</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">bar1.x</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">foo.z</span><span class=\"o\">}</span>\n<span class=\"kd\">end</span> <span class=\"n\">mixed_structure</span>\n</code></pre></div>",
        "id": 236080619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619371700
    },
    {
        "content": "<p><del>Oh! I thought that the interesting question was when you wanted to extend things which had overlapping fields. But here this is not the case</del>(written before 2nd example). OK so now I understand the difference between old structures and new structures (indeed I was just re-reading the <a href=\"https://github.com/leanprover/lean/wiki/Refactoring-structures\">wiki page about this</a> to try and get up to speed). Now why does this matter?</p>",
        "id": 236080623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619371704
    },
    {
        "content": "<p>I should probably try to write a blog post about this, because it's the only way I will make any sense of it, and I have learnt from a lot of previous experience that if I learn something and then forget it again (something which happens all too often at my age) then I can re-learn it very efficiently if I've written it down in my own words.</p>",
        "id": 236080651,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619371763
    },
    {
        "content": "<p>The achilles heel of new style structures is that you can't use them when there are overlapping fields (or rather you can still use the same method but you get the wrong result because you end up with two copies of the overlapped fields)</p>",
        "id": 236080659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619371780
    },
    {
        "content": "<p>in the first example there are no overlaps so new structures work fine</p>",
        "id": 236080714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619371813
    },
    {
        "content": "<p>Right, but my understanding is that the argument is that we should now consider new style structures because it may or may not solve some problem or other.</p>",
        "id": 236080733,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619371827
    },
    {
        "content": "<p>Right, so the question is how to be as new-structure-like as we can subject to the constraint that new style diamonds are impossible</p>",
        "id": 236080756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619371867
    },
    {
        "content": "<p>I don't understand Scott's first claim at the top of this thread:</p>\n<blockquote>\n<p>The current definition of an algebra has a severe problem: if you have type <code>X</code> with an existing <code>module R X</code> structure, it's impossible to put an <code>algebra R X</code> structure on it in such a way that the <code>module R X</code> structure derived from that <code>algebra R X</code> will be definitionally equal to the original one.</p>\n</blockquote>\n<p>Maybe I should start by trying to do this exercise and understanding why this fails.</p>",
        "id": 236080906,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619371992
    },
    {
        "content": "<p>In the <code>mixed_structure</code> example, I have broken the symmetry between the two parent structures by embedding <code>bar1</code> as a field of <code>foo</code> and recombining fields for <code>bar2</code>. For lack of a better name I'm calling the <code>bar1</code> kind \"compositional inheritance\" and <code>bar2</code> non-compositional. We want as many compositional edges in the structure graph as possible, but the compositional edges have to be diamond free</p>",
        "id": 236080918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619372003
    },
    {
        "content": "<p>I'm afraid I have this rather unfashionable trait in me whereby I like to understand stuff by seeing explicit examples, rather than just eating up the axioms and then becoming an expert :-/</p>",
        "id": 236081012,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619372063
    },
    {
        "content": "<p>Ah, I haven't been talking about that issue, just new structures in general</p>",
        "id": 236081144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619372183
    },
    {
        "content": "<p>Right but I'm keen to learn about everything right now</p>",
        "id": 236081164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619372201
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra/src\">src#algebra</a></p>",
        "id": 236081181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619372218
    },
    {
        "content": "<p>I'm not sure I see the problem either. Although you won't get the module structure itself to be the same, all the projections can still be defeq to the old ones, and this is all we generally expect (it's difficult to get defeq of the instances themselves in most cases)</p>",
        "id": 236081316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619372355
    },
    {
        "content": "<p>but I thought we want defeq instances?</p>\n<p>If every structure were completely flat, this would be impossible right, because eta reduction for structures is not definitional (if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>‚àà</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">z\\in\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span> then <code>{re := z.re, im := z.im} = z</code> can't be proved by <code>rfl</code>). But surely it is going to be pretty much impossible to make everything definitional here?</p>",
        "id": 236081845,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619372843
    },
    {
        "content": "<p>So here's an example of what I think scott is talking about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">bar1</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">bar2</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n<span class=\"kd\">class</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo.bar1</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar1</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">foo.x</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">foo.y</span><span class=\"o\">}</span>\n<span class=\"kd\">instance</span> <span class=\"n\">foo.bar2</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bar2</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">foo.x</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">foo.z</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bla</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Œ±</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">bar1</span> <span class=\"o\">(</span><span class=\"n\">bla</span> <span class=\"n\">Œ±</span><span class=\"o\">)]</span>\n<span class=\"kn\">include</span> <span class=\"n\">B</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">bla.foo</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">bla</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">bar1.x</span><span class=\"o\">,</span> <span class=\"bp\">..</span><span class=\"o\">‚Äπ</span><span class=\"n\">bar1</span> <span class=\"o\">(</span><span class=\"n\">bla</span> <span class=\"n\">Œ±</span><span class=\"o\">)‚Ä∫}</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">foo.bar1</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">bla.foo</span> <span class=\"n\">Œ±</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">bar1.x</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">foo.bar1</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">bla.foo</span> <span class=\"n\">Œ±</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">bar1.x</span> <span class=\"n\">_</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">bar1.y</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">foo.bar1</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">bla.foo</span> <span class=\"n\">Œ±</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">bar1.y</span> <span class=\"n\">_</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 236081948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619372924
    },
    {
        "content": "<p>Now you might call this a non-defeq diamond, but this is actually fairly common in the hierarchy and mostly harmless. That is, we would classify this as a defeq diamond because all projections are defeq, even though the instances themselves are not</p>",
        "id": 236082144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619373124
    },
    {
        "content": "<p>An example we have in mathlib is cancel_monoid extending both left_cancel_monoid and right_cancel_monoid as an old structure, both of which live over monoid. If we manage to make ourselves a monoid instance on a type, and then manage to extend it to a left_cancel_monoid and to a right_cancel_monoid, then type class inference might well be able to spit out the original monoid structure from the left_cancel_monoid. But if we then put the cancel_monoid instance into the type class inference machine, there is surely no way that both implications cancel_monoid -&gt; left_cancel_monoid and cancel_monoid -&gt; right_cancel_monoid can produce structures which are defeq to the ones we have already.</p>",
        "id": 236082183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619373163
    },
    {
        "content": "<p>Oh so this is <em>allowed</em>? I thought that this was exactly what Scott was complaining about! This is not the issue we are trying to solve? As far as I can see it's surely provably unsolvable?</p>",
        "id": 236082230,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619373224
    },
    {
        "content": "<p>Right, the issue is that we don't have eta for structures. It's basically impossible to make the first <code>example</code> work, unless <code>bar1</code> happens to be a compositional superclass of <code>foo</code>. But as we've established it's not possible for everything to be compositional superclasses so new structures are going to end up making a new distinction that wasn't visible before matter</p>",
        "id": 236082235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619373241
    },
    {
        "content": "<p>To be sure it's a bit of a pain when you have non-defeq instances like this, because if you apply an unknown function on the instances (like <code>nat.cast</code>) then you have to unfold it enough to know that the function only uses the projections out of the instance, not the instances themselves</p>",
        "id": 236082348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619373339
    },
    {
        "content": "<p>OK re-reading the thread and these comments have been very helpful -- thanks. So really this is not about diamonds, it's about something else, if \"diamond\" is being interpreted as \"not even equal if you include eta reduction\".</p>",
        "id": 236082624,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619373615
    },
    {
        "content": "<p>The thing is, the more complicated definitions we pile on top of a structure the harder it becomes to prove that the function uses only projections, because all the higher level definitions will take an instance argument directly. In this case I think the definition in question is <code>finite_dimensional</code></p>",
        "id": 236082768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619373763
    }
]
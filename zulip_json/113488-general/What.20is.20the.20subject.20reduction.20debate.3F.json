[
    {
        "content": "<p>A Coq user I know recently said they don’t particularly like Lean because Lean breaks subject reduction.  I’ve heard about this on many online discussions (<a href=\"https://github.com/coq/coq/issues/10871\">Github</a>, <a href=\"#narrow/stream/113488-general/topic/Kevin's.20talk.20at.20MSR\">Lean Zulip</a>, <a href=\"https://coq.zulipchat.com/#narrow/stream/237977-Coq-users/topic/First.20Theorem.20Prover.20War\">Coq Zulip</a>, as well as smaller discussions on <a href=\"https://artagnon.com/articles/leancoq\">a blog</a>, <a href=\"https://news.ycombinator.com/item?id=27560975\">Hacker News</a>, <a href=\"https://news.ycombinator.com/item?id=22793797\">More Hacker News</a>, and <a href=\"https://proofassistants.stackexchange.com/questions/908/what-exactly-is-setoid-hell\">PA Stack Exchange</a>).  But at the same time there is really nothing clearly explaining the debate from both sides (at least not without wading through long back-and-forths between <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  and  <span class=\"user-mention\" data-user-id=\"260981\">@Pierre-Marie Pédrot</span>).  Can someone explain the issue <strong>from both sides?</strong> (I also have seen places where  <span class=\"user-mention\" data-user-id=\"198375\">@Karl Palmskog</span> has suggested this to be well-documented.)</p>",
        "id": 274334065,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646608327
    },
    {
        "content": "<p>To start, here is my very vague understanding of what is going on, probably filled with many misunderstandings:  There is a property called subject reduction that relates to definitional equality.  It is desired, because without it, two things which should be defeq aren’t. Because Lean extends definitional equality to quotients, when a quotient is applied to <code>Prop</code> it can <a href=\"https://github.com/coq/coq/issues/10871#issuecomment-541325340\">break subject reduction</a> and therefore break definitional equality (maybe even make defeq undecidable?). It is important at this point to note that I believe <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">Mario’s thesis</a> shows this doesn’t break consistency, or soundness relative to the usual set theoretic model.  I’m not sure it really even breaks soundness relative any constructive models, at least at the <code>Prop</code> level.  (Does it effect anything about which <code>Prop</code>s are provable with or without axioms?)</p>",
        "id": 274334070,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646608334
    },
    {
        "content": "<p>Now, for Lean users, it seems this is viewed as a non-issue which doesn’t come up in practice.  I believe to produce this error you have to take a quotient of a <code>Prop</code> which is a no-op which no-one would do, right?  And since the issue is just defeq failing, you can always prove it another away.  Moreover, it is easy to have defeq fail just because it timed out.  (I recall Lean has trouble even adding numbers using definitional equality.)  And of course Lean users are happy to use non-constructive axioms which I think also get around this issue somehow (although I don’t understand why).  I also assume all this is just a consequence of other nice properties one gets in Lean, but I'm not sure I could name those.  In short for a typical Lean user, I think they would say there isn’t really anything obviously broken here.</p>",
        "id": 274334073,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646608341
    },
    {
        "content": "<p>On the other hand, Coq users seem to see this at least as a “code smell” where this nice property of the type theory is broken for no good reason and it doesn’t bode well for Lean.  (Actually, I think subject reduction is also broken in Coq via coinductive types, and they know this, but the difference in their minds is that they are trying to fix it while Lean developers don’t care about such issues.)  Also, I think Coq developers have a very different model in their heads, and a set-theoretic soundness proof wouldn’t suffice.  Instead the soundness proof they have in mind is proof theoretic and to do this they need properties like soundness reduction.  I also think because defeq is undecidable in Lean (if I have this right), that this means that Lean is more like extensional type theory than intentional type theory (which is maybe another code smell for type theorists).</p>",
        "id": 274334078,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646608347
    },
    {
        "content": "<p>I also think there is a big part of this that comes down to computation.  I think (and maybe I’m mistaken) that Coq’s kernel is where Coq does its computation.  So for example, I think the four color theorem was a giant defeq proof all done in the kernel.  For Lean users, computing in the kernel via <code>rfl</code> is more like a tactic.  If it works, great; if it fails or times out, try something else.  No big deal.  For Lean 3 the bulk of computation happens in the vm (or for Lean 4 in compiled code).  I think both Coq and Lean users (especially Lean 4 since it is a programming language) would be horrified if say they could write a simple function which should compute but crashes.  The difference seems to be where they expect this code to compute.  For Coq users this should compute in the kernel, but for Lean users it should compute in the VM (or compiled code in Lean 4).  And I think for Lean subject-reduction is not an issue in the VM for some reason.</p>",
        "id": 274334082,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646608354
    },
    {
        "content": "<p>But I’m still not sure if I’m mixing subject reduction up with other issues (or even worth I have no idea what I'm talking about here).  I’m also not sure if subject reduction issues are easy to fix in Lean (e.g. <a href=\"https://github.com/coq/coq/issues/10871#issuecomment-541391392\">just don’t allow quotients over <code>Prop</code></a>)?  Also Mario seems to claim that <a href=\"#narrow/stream/113488-general/topic/Kevin's.20talk.20at.20MSR/near/177835824\">quotients aren’t really the issue, but subsingleton elimination + proof irrelevance is</a>.  Is this all a necessary evil to get nice properties (e.g. defeq quotients)  Or is subject reduction just one small part of what Coq users see as a larger problem stemming from various design choices of Lean?  And is there some sense that this is particularly not an issue for Lean users specifically because Lean users typically use classical logic?</p>",
        "id": 274334121,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646608419
    },
    {
        "content": "<p>I know I’m being too careless with the terms “Coq users” and “Lean users”.  Neither is a monolithic group and there is, of course, non-trivial overlap.</p>",
        "id": 274334127,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646608426
    },
    {
        "content": "<blockquote>\n<p>There is a property called subject reduction that relates to definitional equality. It is desired, because without it, two things which should be defeq aren’t.</p>\n</blockquote>\n<p>Not exactly. Subject reduction is the property that if you replace a subterm of a term with a defeq one (especially if the subterm is the result of reduction), the resulting big term remains typecheckable. This fails in lean because if you reduce some of the identities in <code>@id A (@id B (@id C t))</code> you can deduce transitivity of defeq, so by applying one of the counterexamples to transitivity you get a term such that reducing the internal identity functions results in another term that doesn't typecheck</p>",
        "id": 274334275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646608582
    },
    {
        "content": "<p>Ok, so it is about type checkability.  I see.</p>",
        "id": 274334388,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646608752
    },
    {
        "content": "<blockquote>\n<p>Because Lean extends definitional equality to quotients, when a quotient is applied to Prop it can break subject reduction and therefore break definitional equality (maybe even make defeq undecidable?).</p>\n</blockquote>\n<p>Quotients in <code>Prop</code> are a red herring. The quotient of a Prop is not a thing people ever do, and it's not what makes the Coq folks upset. This is a silly oversight in the lean 3 axioms, and you can remove it without breaking mathlib by making quotients have the type <code>Sort (max 1 u)</code> instead of <code>Sort u</code>.</p>",
        "id": 274334405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646608795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/113488-general/topic/What.20is.20the.20subject.20reduction.20debate.3F/near/274334070\">said</a>:</p>\n<blockquote>\n<p>It is important at this point to note that I believe <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">Mario’s thesis</a> shows this doesn’t break consistency, or soundness relative to the usual set theoretic model.  I’m not sure it really even breaks soundness relative any constructive models, at least at the <code>Prop</code> level.  (Does it effect anything about which <code>Prop</code>s are provable with or without axioms?)</p>\n</blockquote>\n<p>The quotient axioms are actually quite load-bearing in lean, since they are used to derive function extensionality. If you were to simply remove quotient types from lean you would want to put this back in as an axiom.</p>",
        "id": 274334540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646608974
    },
    {
        "content": "<blockquote>\n<p>I also think because defeq is undecidable in Lean (if I have this right), that this means that Lean is more like extensional type theory than intentional type theory (which is maybe another code smell for type theorists).</p>\n</blockquote>\n<p>This depends on what you mean by \"defeq\". In my thesis I separate two notions of \"defeq\": the ideal one, which is transitive and satisfies subject reduction and is undecidable, and the \"algorithmic\" one, which is (approximately) what lean implements, is decidable, non-transitive and fails SR.</p>",
        "id": 274334639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646609149
    },
    {
        "content": "<blockquote>\n<p>And I think for Lean subject-reduction is not an issue in the VM for some reason.</p>\n</blockquote>\n<p>Subject reduction doesn't apply because the VM is not a type system, it is an evaluation semantics. What matters is that VM computation does not get stuck, and this happens exactly when the lean term is not <code>noncomputable</code>. One open question that still remains from the thesis is whether and in what sense the VM is type-preserving. We would certainly like it to be true: if we have a closed term of type <code>nat</code> we want it to compute to a <code>nat</code>, not a <code>string</code> or something else. But the VM will execute right through <code>eq.cast</code> operations as if they were identity functions, which means that you can get terms applied to things that would not type check in lean, at which point it becomes hard to see how to get back on the well-typed train.</p>",
        "id": 274334890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646609441
    },
    {
        "content": "<p>So it sounds like all the issues come down to non-transitivity of defeq in the \"algorithmic\" version of defeq produced by Lean's kernel.  I assume Coq has (or is aiming for) a kernel where defeq is (in theory with enough time and resources) transitive?</p>",
        "id": 274335465,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646610311
    },
    {
        "content": "<p>I have this vague idea that subject reduction is related to the idea that given a term you'd like to be able to put it into some kind of unique canonical normal form. But most mathematical objects don't have this property -- for example the word problem is not solvable even for finitely presented groups, which means that faced with a random element of such a group, \"does this reduce to the identity\" is not algorithmically decidable. Perhaps it's the fact that mathematicians spend their lives manipulating such objects that they don't have a particular desire to try and always put objects into some kind of canonical normal form.</p>",
        "id": 274335611,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646610501
    },
    {
        "content": "<blockquote>\n<p>I have this vague idea that subject reduction is related to the idea that given a term you'd like to be able to put it into some kind of unique canonical normal form.</p>\n</blockquote>\n<p>That's a different desirable property of type systems called \"canonicity\". This is important for anything with a proper evaluation semantics, for example VM computation - it would be no good if you could write computable functions producing <code>nat</code> and the VM just crashes somewhere in the middle of computation. Lean's defeq reduction relation fails canonicity if you use any axioms (propext, quot.sound, choice all break it)</p>",
        "id": 274335905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646611044
    },
    {
        "content": "<p>But even if you have canonicity in principle, it can still be surprisingly tricky to make use of this fact. For example in the POPL panel discussion you were in with Favonia, he mentioned the \"Brunerie number\" which is essentially a stress test of the canonicity property of certain cubical type theories. The fact that you can still get stuck due to implementation limits is one reason why I don't consider canonicity and strong normalization to be particularly useful properties in their bare form with no runtime bounds.</p>",
        "id": 274336149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646611298
    },
    {
        "content": "<p>It's also why I always mention that Metamath / MM0 have linear time verification, because this is a property very much absent from DTT systems. They can at least promise that verification is decidable, but this is an impossibly weak statement - the asymptotic complexity of DTT verification is the fastest growing computable function I know how to describe</p>",
        "id": 274336328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646611479
    },
    {
        "content": "<p>What's a simple concrete example of failure of subject reduction? It doesn't seem like any have been posted to zulip before.</p>",
        "id": 274336483,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1646611684
    },
    {
        "content": "<p>This is <a href=\"https://github.com/coq/coq/issues/10871#issuecomment-541325340\">one example</a> which I think was copying Mario's thesis.  It uses quotients.  I'm curious given the above, if it can be done without quotients (or at least quotients in <code>Prop</code>).</p>",
        "id": 274336525,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646611777
    },
    {
        "content": "<p>(I assume this is a failure of SR, but I'm still not sure of these things.)</p>",
        "id": 274336580,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646611842
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">acc</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_rec</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">acc</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">acc.rec</span> <span class=\"n\">A</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">inv</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">acc</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">acc</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">acc.intro</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">acc.inv</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">inv</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- ok</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">my_rec</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"c1\">-- 1</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">my_rec</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"c1\">-- acc.rec _ h</span>\n\n<span class=\"c1\">-- failure of transitivity</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">my_rec</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"c1\">-- ok</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">inv</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"c1\">-- ok</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">my_rec</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">my_rec</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"c1\">-- ok</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">my_rec</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"c1\">-- fail</span>\n\n<span class=\"c1\">-- failure of SR:</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">my_rec</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">my_rec</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"c1\">-- ok</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">my_rec</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"c1\">-- fail</span>\n\n<span class=\"c1\">-- fooling tactics into producing type incorrect terms:</span>\n<span class=\"kd\">def</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">my_rec</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">my_rec</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">my_rec</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n<span class=\"c1\">-- kernel failed to type check declaration 'T' this is usually due to a buggy tactic or a bug in the builtin elaborator</span>\n<span class=\"c1\">-- elaborated type:</span>\n<span class=\"c1\">--   ∀ {A : Type} {R : A → A → Prop} (x : A) (h : acc R x) (X : 1 = my_rec x h → Type), X _ = X _</span>\n<span class=\"c1\">-- elaborated value:</span>\n<span class=\"c1\">--   λ {A : Type} {R : A → A → Prop} (x : A) (h : acc R x) (X : 1 = my_rec x h → Type), id (eq.refl (X rfl))</span>\n<span class=\"c1\">-- nested exception message:</span>\n<span class=\"c1\">-- type mismatch at application</span>\n<span class=\"c1\">--   X rfl</span>\n<span class=\"c1\">-- term</span>\n<span class=\"c1\">--   rfl</span>\n<span class=\"c1\">-- has type</span>\n<span class=\"c1\">--   1 = 1</span>\n<span class=\"c1\">-- but is expected to have type</span>\n<span class=\"c1\">--   1 = my_rec x h</span>\n</code></pre></div>",
        "id": 274338966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646615089
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> if we want a public summary of the issue on both sides, the Proof Assistant Stack Exchange may be a good neutral ground. Pierre-Marie already talks about subject reduction in his answer here: <a href=\"https://proofassistants.stackexchange.com/questions/583/what-is-the-state-of-coinductive-types-and-reasoning-in-coq\">https://proofassistants.stackexchange.com/questions/583/what-is-the-state-of-coinductive-types-and-reasoning-in-coq</a></p>",
        "id": 274355680,
        "sender_full_name": "Karl Palmskog",
        "timestamp": 1646636090
    },
    {
        "content": "<p>Gaëtan Gilbert linked to the following 2019 paper by Abel &amp; Coquand in an earlier debate (\"Failure of Normalization in Impredicative Type Theory with Proof-Irrelevant Propositional Equality\"): <a href=\"https://arxiv.org/abs/1911.08174\">https://arxiv.org/abs/1911.08174</a></p>",
        "id": 274359654,
        "sender_full_name": "Karl Palmskog",
        "timestamp": 1646640232
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198375\">@Karl Palmskog</span> I missed that question.  Indeed Pierre-Marie’s answer is helpful, especially the section on Subject Reduction.  For example, here is a snippet:</p>\n<blockquote>\n<p>On the practical side, this is not a black-and-white issue. It actually depends on the magnitude of SR breakage. One can survive within a locally broken system (case in point: Coq), but the more failures of SR, the less practical the proof assistant. Indeed, failure of SR means that type-checking is not stable by the equational theory of the language, a clear source of non-modularity. A perfectly fine proposition may become ill-typed after substituting a subterm by another <em>convertible</em> one. This is particularly infuriating when it happens because it is virtually impossible to debug, as one has to manually apply the typing rules to see where it fails.</p>\n</blockquote>",
        "id": 274381559,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646654451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198375\">@Karl Palmskog</span> I would very much be open to having this be a question on that stack exchange.  I almost went there first, but given I understood so little about it, I though it was best to get some more clarity first here.</p>",
        "id": 274383023,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646655444
    },
    {
        "content": "<p>I haven't looked at the source but that quotation of Pierre-Marie sounds really fishy. It seems to imply there the situation is ok in Coq but not in Lean. However we still haven't seen any example where this \"issue\" arose except for specifically hand-crafted cases designed to exhibit this phenomenon.</p>",
        "id": 274383337,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646655672
    },
    {
        "content": "<p>That source was only about Coq, so that is (at least one reason) why it doesn't mention Lean.</p>",
        "id": 274383429,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646655732
    },
    {
        "content": "<p>In particular it is about co-inductive types, which is where SR breaks in Coq I believe.</p>",
        "id": 274383832,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646656020
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Given that your example seems to depend on <a href=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\">proof irrelevance</a> of <code>Prop</code> and the <a href=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\">small (subsingleton) elimination</a> of <code>Prop</code> used in the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/acc\">docs#acc</a>, do you think this would also be a problem for <a href=\"https://coq.inria.fr/doc/addendum/sprop.html\">Coq's <code>SProp</code></a>?  I don't know enough to understand the difference between Coq's <code>SProp</code> and Lean's <code>Prop</code>.  It seems <code>SProp</code> is proof irrelevant, but I don't know how elimination works.  Maybe the first thing would be to see if one could define <a href=\"https://leanprover-community.github.io/mathlib_docs/find/acc\">docs#acc</a> in <code>SProp</code>...</p>",
        "id": 274384409,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646656370
    },
    {
        "content": "<p>Also I thought Arend has a Prop type which is proof irrelevant and supports sub-singleton elimination (even to sub-singletons in Type).  I wonder if they have problems, or if HoTT comes to save the day.</p>",
        "id": 274384553,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646656499
    },
    {
        "content": "<p>Oh, from <a href=\"https://arend-lang.github.io/2019/12/16/Arend-1.2.0-released.html\">Arend's 1.2.0 release</a>:</p>\n<blockquote>\n<p>We decided to make \\Prop proof relevant in general (but it is still proof irrelevant in some cases). The implementation in 1.1.0 was incorrect and it turns out that it is impossible to implement it without loss of the normalization property.</p>\n</blockquote>",
        "id": 274384933,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646656717
    },
    {
        "content": "<blockquote>\n<p>but the more failures of SR, the less practical the proof assistant.</p>\n</blockquote>\n<p>Lean has turned out to be a really practical system for doing hard mathematics, and my understanding is that SR is completely broken in Lean. So this word \"practical\" might be highly subject-dependent.</p>",
        "id": 274386706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646657688
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> and <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  I think it would at least be nice to know where the boundary is that one has to exploit (or avoid) to get into this case.  If nothing else, it gives a better argument for why it isn't a big deal in practice.  (For Coq it seems to be using positive co-induction types in a certain way.)  I used to think in Lean it was taking quotients of Props.   Know I think it is exploiting proof irrelevance of certain kinds of <a href=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\">syntactic subsingleton</a> definitions or something like that.</p>",
        "id": 274387181,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646657941
    },
    {
        "content": "<p>The conjecture is: the boundary is somewhere in pure type theory land, it has nothing to do with formalized mathematics.</p>",
        "id": 274387310,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646658003
    },
    {
        "content": "<p>Just like we know by Gödel that maths are undecidable, but in practice this never shows up unless you are working in very specific areas of set theory.</p>",
        "id": 274387738,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1646658167
    },
    {
        "content": "<p>Note the same argument can be made about any obscure bug in Lean.  I guess your point is that there is no way for someone to exploit this \"bug\" to trick Lean into accepting a bad proof (unlike the recent unsoundness bug in Lean 4).  So it just comes down to, if you do weird stuff Lean might crash with an incomprehensible error, but that is just normal for computers.  (Edit: Crash is too strong a word.  Error is more correct.)</p>",
        "id": 274388346,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646658453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/What.20is.20the.20subject.20reduction.20debate.3F/near/274387310\">said</a>:</p>\n<blockquote>\n<p>The conjecture is: the boundary is somewhere in pure type theory land, it has nothing to do with formalized mathematics.</p>\n</blockquote>\n<p>Following this reasoning and given the fact that Lean 4 will be (and already is) a powerful and genuine programming language, I wonder if this issue has a higher chance of showing up in other domains. For example, if someone wants to use Lean 4 to create some unorthodox application or programming language or something like that</p>",
        "id": 274388373,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1646658470
    },
    {
        "content": "<p>Jason, this has nothing to do with soundness. This simply never happened.</p>",
        "id": 274388781,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646658681
    },
    {
        "content": "<p>Arthur, this is perfectly valid concern, I have no idea. I guess the Coq people who think subject reduction is important have good reason to think so, related to whatever they are doing with their proof assistant. If we start to use Lean for whatever they are doing where subject reduction is important then we may have to care.</p>",
        "id": 274389000,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646658793
    },
    {
        "content": "<p>I guess that is my point.  The boundary is that if it isn’t a soundness issue (which I agree this isn’t and hasn’t ever been) then it is just a usability question.  If there are some funky side issues with the type theory which don’t break soundness, then Lean users can live with those if they don’t come up in practice.</p>",
        "id": 274389037,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646658821
    },
    {
        "content": "<p>Frankly we could even live with a soundness issue if it were as artificial as what we are currently discussing.</p>",
        "id": 274389161,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1646658872
    },
    {
        "content": "<p>I’m not sure you speak for the community on that point.</p>",
        "id": 274389240,
        "sender_full_name": "Jason Rute",
        "timestamp": 1646658913
    },
    {
        "content": "<p>We're trying to type in proofs here, not exploit the system :-)</p>",
        "id": 274396328,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646662270
    },
    {
        "content": "<p>I think the concern, in case of unsoundness, is accidental/unintentional exploitation. Weird scenario: an AI learns how to abuse it</p>",
        "id": 274398185,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1646663158
    },
    {
        "content": "<p>The theoretical existence of soundness holes in the theory can make proof translation much more difficult, because a proof of soundness translates fairly directly to a proof export algorithm. As long as soundness is an open question (like in Coq), it is unclear how to move the theorems into a known-to-be-sound foundation.</p>\n<p>A variation on this issue appears in Lean, in the claim that \"Type is all you need\". This is certainly a plausible claim given how we normally use mathlib, so if we want to translate Lean proofs to ZFC then the analogue of a soundness hole would be a construction of a ZFC model with an inaccessible or something like that. That is, it's something that is entirely possible to do, but difficult to accidentally stumble upon (because we aren't usually exploiting such strong induction principles in lean). A translation procedure then has to figure out what kind of subsystem captures all the things done in practice (including higher universes than <code>Type</code>, because <a href=\"#narrow/stream/113488-general/topic/Highest.20universe.20in.20mathlib\">they do show up in practice</a>) even though there are clear ways to break it.</p>",
        "id": 274407598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646667030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/What.20is.20the.20subject.20reduction.20debate.3F/near/274387738\">said</a>:</p>\n<blockquote>\n<p>Just like we know by Gödel that maths are undecidable, but in practice this never shows up unless you are working in very specific areas of set theory.</p>\n</blockquote>\n<p>I'm not sure I agree with this statement. Maths is undecidable, and this property shows up all the time in the fact that mathematicians still have a job and we did not find a way to push-button automate the whole thing away. (Hm, this seems to be a conflicting meaning of \"undecidable\" since I think you mean \"independent of the base theory\".) Still, I would say that in just the same way as above, the theoretical existence of independent statements makes it much harder to figure out how to decide in practice large classes of problems with a uniform method.</p>",
        "id": 274408513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646667421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/What.20is.20the.20subject.20reduction.20debate.3F/near/274386706\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>but the more failures of SR, the less practical the proof assistant.</p>\n</blockquote>\n<p>Lean has turned out to be a really practical system for doing hard mathematics, and my understanding is that SR is completely broken in Lean. So this word \"practical\" might be highly subject-dependent.</p>\n</blockquote>\n<p>SR is not \"completely broken\" in lean. I would say the situation is pretty similar to that described in Coq. The main evidence that SR is a thing to watch out for is in the fact that <code>dsimp</code> and <code>change</code> put an <code>id</code> in the proof term (they wouldn't need to do that if SR always happened reliably), and sometimes unfolding things with <code>dsimp</code> can make defeq problems much harder which can cause slow or unusable proofs (this came up one or two times in LTE in some joint coding sessions with <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>). So to me it is a hazard sign that I have been aware of for a long time but have only had to come near a small handful of times in all my leaning.</p>",
        "id": 274409233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646667729
    },
    {
        "content": "<p>By undecidable, I mean that some statements are neither provable nor refutable (which implies in particular that there is no algorithm to decide the truth of all statements). And I don't think this has anything to do with mathematicians having a job: even if everything were decidable (and even decidable by a reasonable time algorithm), this would not solve the problem of finding the interesting questions and the fruitful theories, which is the heart of our job.</p>",
        "id": 274409256,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1646667746
    },
    {
        "content": "<p>In fact, I would say that the issues with unfolding are far more commonly performance issues than actual rejected proofs. It isn't too hard to come up with examples where <code>x = y</code> and <code>y = z</code> are fast to check but <code>x = z</code> is super slow, even if it might resolve to defeq eventually you can't put it in your proof and so you are working around lack of \"effective transitivity\".</p>",
        "id": 274409519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646667873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/What.20is.20the.20subject.20reduction.20debate.3F/near/274409233\">said</a>:</p>\n<blockquote>\n<p>sometimes unfolding things with <code>dsimp</code> can make defeq problems much harder which can cause slow or unusable proofs (this came up one or two times in LTE in some joint coding sessions with <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span>).</p>\n</blockquote>\n<p>The memories <span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span></p>",
        "id": 274409855,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646668033
    },
    {
        "content": "<p>This discussion came up again on the new <a href=\"https://proofassistants.stackexchange.com/questions/1183/how-much-of-trouble-is-leans-failure-of-normalization-given-that-logical-consi\">Proof Assistant StackExchange</a> (not by me).</p>",
        "id": 276812673,
        "sender_full_name": "Jason Rute",
        "timestamp": 1648422155
    },
    {
        "content": "<p>I realize however that the real question is not something like \"why is Lean broken\" or \"how is Lean usable given that it is broken\".  We know from Mario that subsingleton elimination + proof irrelevance is the issue and that is a relatively small issue.  <em>I think the real question is what does having subsingleton elimination and proof irrelevance give you in Lean?</em>  This may be obvious to others, but I'm not certain. I have the (possibly) wrong impression that they are there to allow you to write computable functions using (Prop) classical logic and run them in the VM, and maybe also to ignore proofs during computation, making computation faster.  But maybe I'm totally mistaken.</p>",
        "id": 276812837,
        "sender_full_name": "Jason Rute",
        "timestamp": 1648422398
    },
    {
        "content": "<p>What exactly does \"subsingleton elimination\" mean here?</p>",
        "id": 276813439,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1648423356
    },
    {
        "content": "<p>Presumably it doesn't refer to <code>subsingleton.elim</code>, as I don't think the lean 3 kernel knows about that</p>",
        "id": 276813449,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1648423391
    },
    {
        "content": "<p>I'm referring to what <a href=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\">this document</a> calls subsingleton elimination, and what Mario explicitly used in <a href=\"#narrow/stream/113488-general/topic/What.20is.20the.20subject.20reduction.20debate.3F/near/274338966\">his example above</a> to eliminate <a href=\"https://leanprover-community.github.io/mathlib_docs/find/acc\">docs#acc</a> to <code>nat</code> (which doesn't go through if you define a similar thing to <code>acc</code> in Coq's <code>SProp</code>).</p>",
        "id": 276813721,
        "sender_full_name": "Jason Rute",
        "timestamp": 1648423863
    },
    {
        "content": "<p>Maybe it's worth calling it \"syntactic subsingleton elimination\" just for sake of discussion.</p>",
        "id": 276814691,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1648425601
    },
    {
        "content": "<p>Reposting my comment from the SE question:</p>\n<p>\"why does Lean have proof irrelevance\": Without proof irrelevance, I think it is hard to argue that your logic acts like classical mathematics, because subtypes don't act like subtypes anymore. Things are much more like HoTT at this level. (It doesn't have to be definitional proof irrelevance though. Coq gets by just fine with axiomatic proof irrelevance. But definitional proof irrelevance is unquestionably convenient, and even Coq recognized this in adding SProp.)</p>\n<p>\"why... syntactic subsingleton elimination\": The main application of subsingleton elimination is constructing definitions by well founded recursion where the proof of well-foundedness is a Prop and hence erased by the VM/compiler, which is important in practice. If well_founded was data, then the noncomputable checker would have to get more sophisticated with an effect system and ghost annotations so that noncomputable proofs of well foundedness can be used in computable recursive functions.</p>",
        "id": 276825173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648440101
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <br>\nYes, the motivation for including <code>id</code> in <code>dsimp</code> and <code>change</code> was performance because of unfolding. Before we had <code>id</code> there, we would often have performance problems with them. I don't recall having ever added an auxiliary <code>id</code> to workaround the SR issue.<br>\nI am glad you are always willing to explain the \"SR issue\" to users. <br>\nNot sure how to convince others this is a nonissue and soundness is not affected. Should we create a FAQ for it? <br>\nBTW, I found the issue about \"type checking stability\" raised by one of the Coq guys very disingenuous. To trigger the SR issue we need to use types such as <code>acc</code>(the accessibility predicate for well-founded recursion) which is mainly used by Lean to justify termination and is barely used by users.</p>",
        "id": 276887121,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648479961
    },
    {
        "content": "<p>Regarding \"subsingleton elimination\", the main motivation was extra definitional equalities when using structural recursion.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">):</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Vector.map2</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">β</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">σ</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nil</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">cons</span> <span class=\"n\">b</span> <span class=\"n\">bs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">map2</span> <span class=\"n\">f</span> <span class=\"n\">as</span> <span class=\"n\">bs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Vector.map2_cons_eq</span> <span class=\"o\">:</span> <span class=\"n\">map2</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">b</span> <span class=\"n\">bs</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">map2</span> <span class=\"n\">f</span> <span class=\"n\">as</span> <span class=\"n\">bs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span> <span class=\"c1\">-- It would not hold without subsingleton elimination</span>\n</code></pre></div>",
        "id": 276888261,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648480380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/113488-general/topic/What.20is.20the.20subject.20reduction.20debate.3F/near/274388373\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/What.20is.20the.20subject.20reduction.20debate.3F/near/274387310\">said</a>:</p>\n<blockquote>\n<p>The conjecture is: the boundary is somewhere in pure type theory land, it has nothing to do with formalized mathematics.</p>\n</blockquote>\n<p>Following this reasoning and given the fact that Lean 4 will be (and already is) a powerful and genuine programming language, I wonder if this issue has a higher chance of showing up in other domains. For example, if someone wants to use Lean 4 to create some unorthodox application or programming language or something like that</p>\n</blockquote>\n<p>No, there isn't a higher chance. To trigger the issue, one has to use types such as <code>Acc</code> (the accessibility predicate for defining well-founded recursion). It is indirectly used by Lean to justify a function terminates. The whole process is automated by Lean. Lean converts the definition to one using <code>WellFounded.fix</code> to prove termination, proves the equations theorems, and compiles the code. When reasoning about the code, one uses the equalities proved automatically by Lean. <br>\nNote that even when (very advanced) users want to use <code>Acc</code> to show that a new relation <code>R</code> is well-founded, the SR issue does not occur there. It is a very localized use. They would prove that the relation is well-founded, and Lean would use the fact as a \"black box\". The file <code>src/Init/WF.lean</code> contains examples.</p>",
        "id": 276891765,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648481936
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/113488-general/topic/What.20is.20the.20subject.20reduction.20debate.3F/near/274398185\">said</a>:</p>\n<blockquote>\n<p>I think the concern, in case of unsoundness, is accidental/unintentional exploitation. Weird scenario: an AI learns how to abuse it</p>\n</blockquote>\n<p>It was mentioned above, but it does not hurt to repeat: there is no soundness issue.</p>",
        "id": 276892009,
        "sender_full_name": "Leonardo de Moura",
        "timestamp": 1648482041
    }
]
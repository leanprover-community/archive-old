[
    {
        "content": "<p>I am always a bit annoyed by the <code>deprecated</code> directory, and so I spent some time over the last few weeks changing all the main classes in there (<code>is_submonoid</code>, <code>is_subgroup</code> etc, and <code>is_group_hom</code>, <code>is_ring_hom</code> etc) to structures (my understanding is that we still want these things around but not in the typeclass system). My <code>undeprecate</code> branch just compiled for the first time the other day; I changed 87 files. It's <a href=\"https://github.com/leanprover-community/mathlib/issues/8178\">#8178</a> .</p>\n<p>There are still some loose ends here however, and I thought that maybe I should get some community input. What I would imagine the next step would be is to start removing imports of deprecated files. I had it in my head that there were a few places where these structures were really useful, however I am now less sure about this. The main examples where you see the advantage of the unbundled approach is in the rare-but-they-do-exist cases where <code>R</code> is, say, a ring, and (in the middle of a long tactic proof) you define some <code>S : add_subgroup R</code> and then do some stuff with it and then later on manage to show that it's closed under R's multiplication. With the deprecated system you had <code>S : set R</code> with <code>[is_add_subgroup S]</code> and you just add an instance of <code>[is_add_subring S]</code> and keep going. With the new system you need to make a new <code>S' : subring R</code> and all your hypotheses about <code>S</code> now need to be beefed up to apply to <code>S'</code> or else you can't rewrite with them. This turns out to be only a minor annoyance.</p>\n<p>But the real reason I'm bringing this up is that once this change is made, there are some definitions and results in mathlib which are much harder to state, or rather can in theory be stated but only in a convoluted way. An example is <code>subtype.monoid</code>, which looks like <a href=\"https://github.com/leanprover-community/mathlib/blob/6f88eecaf787d46fa4c37dc660d32b1b2c87414c/src/deprecated/submonoid.lean#L226\">this</a> in master (clean, but using the fact that <code>is_submonoid</code> is a class) and like <a href=\"https://github.com/leanprover-community/mathlib/blob/7b824c17232271ddeec8fa316ee3afc644743690/src/deprecated/submonoid.lean#L236\">this</a> on the branch where <code>is_submonoid</code> becomes a structure. Notice the weird <code>[fact (is_submonoid s)]</code>. Why is this here? Well, if I just wrote <code>(hs : is_submonoid s)</code> then I could get <code>subtype.monoid</code> compiling no problem, but the problems all start later when we're doing things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_submonoid.coe_mul</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">is_submonoid</span> <span class=\"n\">s</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This is the version on my branch, which works fine. But without using <code>fact</code> Lean has no way of figuring out what the multiplication is, because <code>M</code> is a monoid but <code>s : set M</code> so it's hard to get the _statement_ to typecheck.</p>\n<p>As I say, the branch compiles right now, so one can look through the changed files and see the facts I've added. There aren't that many, and I know for sure that these results cannot really be used anywhere because these facts will not be in the typeclass system in general, I didn't make an instance of <code>fact (is_submonoid s)]</code> anywhere. So one way forward would be simply to <em>delete</em> lemmas like <code>is_submonoid.coe_mul</code> completely. Basically they have become unusable because of the change, and I see little point in keeping them. I'm aware that deleting lemmas is not something which is usually done so this is why I wanted to ask about it.</p>\n<p>Some early work of Kenny on Galois theory used <code>is_add_subgroup</code> and because I knew the material well and was confident that analogous <code>add_subgroup</code> versions weren't there, I took the trouble to refactor them and remove a deprecated import. If there are any other areas of mathlib where people want me to make the refactor from is_X to X then I'm in quite a good position to work on this stuff now because I know the tricks (and by this time next month I'll have forgotten them). However another point of view might be that because I made a PR which touches 87 files it might be best to get it merged ASAP. However I can certainly work on completely deleting those deprecated lemmas today or tomorrow.</p>",
        "id": 246854196,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626964001
    },
    {
        "content": "<p>Wowowow! Thanks a lot for this massive effort!<br>\nMy first reaction is: we should get rid of those <code>fact</code>-lemmas, and merge the rest ASAP.</p>",
        "id": 246854854,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626964274
    },
    {
        "content": "<p>OK I will remove the lemmas which cannot be being used because they have facty typeclasses; I can do it at Xena tonight.</p>",
        "id": 246857148,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626965246
    },
    {
        "content": "<p>I think we should get rid of all these lemmas about <code>is_submonoid</code> (at least, if there is a <code>submonoid</code> alternative, which should be the case almost always). The only things we really want to keep are the translations between <code>is_submonoid</code> and <code>submonoid</code>: <code>submonoid.of</code> (which maybe should be renamed <code>is_submonoid.submonoid</code> to enable projection notation) and <code>submonoid.is_submonoid</code>.<br>\nAll declarations <code>foo</code> about <code>is_submonoid</code> that can be proven by <code>M.submonoid.foo</code> should be removed.</p>",
        "id": 246857175,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1626965259
    },
    {
        "content": "<p>Should this be done in this PR or in another one? Thanks for the input!</p>",
        "id": 246857269,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626965297
    },
    {
        "content": "<p>In general PR's which touch a huge number of files are really scary, but actually I'm only changing things which nobody else is working on so it's much less scary than you think.</p>",
        "id": 246857335,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626965332
    },
    {
        "content": "<p>If you make separate PRs, you're changing the statement of a lot of lemmas in this PR that will be removed in the next PR. <br>\nSo it will at least be easier to review if you decide to make a single PR. It also depends on how likely merge conflicts are (and your willingness to resolve them).</p>",
        "id": 246857662,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1626965479
    },
    {
        "content": "<p>If you think that a lot of proofs of lemmas that we want to keep use lemmas that we are removing, then it might be easier to make separate PRs.</p>",
        "id": 246857918,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1626965574
    },
    {
        "content": "<p><code>is_submonoid.coe_mul</code> is an API lemma about some <code>has_mul</code> instance that you are also deleting, right?</p>",
        "id": 246859625,
        "sender_full_name": "Reid Barton",
        "timestamp": 1626966130
    },
    {
        "content": "<p>Oh that's the <code>subtype.monoid</code> you mentioned</p>",
        "id": 246860153,
        "sender_full_name": "Reid Barton",
        "timestamp": 1626966367
    },
    {
        "content": "<p>Oh I'm confused now. <code>subtype.monoid</code> used to be a def, but now it is an instance; how come?</p>",
        "id": 246860953,
        "sender_full_name": "Reid Barton",
        "timestamp": 1626966695
    },
    {
        "content": "<p>We want to remove <code>subtype.monoid</code> and instead use <code>(hM : is_submonoid M).submonoid.monoid</code> (if really needed).</p>",
        "id": 246864363,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1626968333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/deprecated.20folder.20--.20deleting.20lemmas.3F/near/246860953\">said</a>:</p>\n<blockquote>\n<p>Oh I'm confused now. <code>subtype.monoid</code> used to be a def, but now it is an instance; how come?</p>\n</blockquote>\n<p>My impression is that it used to be dangerous in some way to make it an instance; it was occasionally made a local instance IIRC.</p>",
        "id": 246868796,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626970335
    },
    {
        "content": "<p>Like for example about 12 lines after its definition, on your branch <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 246869923,
        "sender_full_name": "Reid Barton",
        "timestamp": 1626970862
    },
    {
        "content": "<p>So just to be clear -- we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_subgroup.normal_in_normalizer\">docs#is_subgroup.normal_in_normalizer</a> stating in a deprecated way that a subgroup is normal in its normalizer, and this is never used in mathlib, and we also have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subgroup.normal_in_normalizer\">docs#subgroup.normal_in_normalizer</a>, which states this in the non-deprecated way, and the statement uses <code>subtype.group</code> which is going to be removed, and so I am also going to remove <code>is_subgroup.normal_in_normalizer</code>.</p>",
        "id": 246871473,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626971615
    },
    {
        "content": "<p>PS I think merge conflicts are highly unlikely unless there's some big refactor of algebra going on that I don't know about.</p>",
        "id": 246871568,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626971648
    },
    {
        "content": "<p>OK so that was less painful than expected -- all the facts I added are removed now.</p>",
        "id": 246877361,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626974089
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> or anyone else who understands this stuff: right now <code>ring_theory.subring</code> imports <code>deprecated.subring</code>, but it's the other way around for submonoids. I propose switching this, having <code>deprecated.subring</code> import <code>ring_theory.subring</code>,  and moving <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.to_subring\">docs#set.to_subring</a> into <code>deprecated.subring</code> and renaming it to <code>is_subring.subring</code>. This way I can work on removing all <code>import deprecated.subring</code> from undeprecated mathlib. I have already achieved this with <code>deprecated.subfield</code>.</p>",
        "id": 246884989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626977456
    },
    {
        "content": "<p>Wouldn't it be easier to move <code>deprecated.*</code> back into the main tree? Because that's the end goal anyway, right?</p>",
        "id": 246885309,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626977620
    },
    {
        "content": "<p>I agree with Johan that we eventually want to remove the <code>deprecated</code> folder entirely. My thought is to have 20-30 lines at the end of <br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/group_theory/submonoid/basic.lean\">https://github.com/leanprover-community/mathlib/blob/master/src/group_theory/submonoid/basic.lean</a><br>\n(or perhaps in a separate file) about <code>is_submonoid</code>, with just the results in<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/468328daee53ea78e8522daa20893a434ce30b57/src/deprecated/submonoid.lean#L34-L59\">https://github.com/leanprover-community/mathlib/blob/468328daee53ea78e8522daa20893a434ce30b57/src/deprecated/submonoid.lean#L34-L59</a><br>\nand<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/468328daee53ea78e8522daa20893a434ce30b57/src/deprecated/submonoid.lean#L410-L415\">https://github.com/leanprover-community/mathlib/blob/468328daee53ea78e8522daa20893a434ce30b57/src/deprecated/submonoid.lean#L410-L415</a><br>\nThere might be a little bit more that we want to keep, if it doesn't have a good bundled analogue. But something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_submonoid.inter\">docs#is_submonoid.inter</a> can be removed since we can take meets of bundled submonoids.</p>\n<p>The same can be true about rings.</p>",
        "id": 246901634,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1626986176
    },
    {
        "content": "<p>In the long run I'd be tempted to extract the proofs from things like <code>submonoid.has_inf</code> and move them back out to <code>is_submonoid.inter</code></p>",
        "id": 246902359,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626986580
    },
    {
        "content": "<p>But right now we prove the same thing from scratch in both places, so we may as well throw out the one we don't use</p>",
        "id": 246904826,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626987717
    },
    {
        "content": "<p>so right now I have removed all <code>import.deprecated.*</code> from all mathlib files other than those in <code>src/deprecated</code> (and <code>test</code>), and a bunch of stuff has broken again, so in some sense I feel like I'm back to square one. I am now creating diffs like the following screenshot:</p>\n<p><a href=\"/user_uploads/3121/uClQrYNbkati0KSEWxZCCm90/diff.png\">diff.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/uClQrYNbkati0KSEWxZCCm90/diff.png\" title=\"diff.png\"><img src=\"/user_uploads/3121/uClQrYNbkati0KSEWxZCCm90/diff.png\"></a></div><p>There are random places all over mathlib where people prove <code>is_group_hom</code> for a map, and I'm replacing them with defs (if they don't seem to be there already) and adding a simp lemma. Am I going the right way? I could just add some deprecated imports back in and I'd have everything compiling again. So far I've added set.singleton_mul_hom to replace <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.singleton.is_mul_hom\">docs#set.singleton.is_mul_hom</a>, multiset.map_add_monoid_hom to replace <code>is_add_monoid_hom (multiset.map f)</code>, <code>countp_add_monoid_hom</code> to replace <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.countp.is_add_monoid_hom\">docs#multiset.countp.is_add_monoid_hom</a> and so on. Should I cut my losses and stop or is this what we want?</p>",
        "id": 246914069,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626993719
    },
    {
        "content": "<p>Shouldn't simps take care of making the simp lemma for you?</p>",
        "id": 246914198,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626993837
    },
    {
        "content": "<p>I don't understand <code>simps</code>. Is this what it does?</p>",
        "id": 246914260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626993865
    },
    {
        "content": "<p>attribute#simps</p>",
        "id": 246914291,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626993892
    },
    {
        "content": "<p>I'm not very good at attributes.</p>",
        "id": 246914305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626993905
    },
    {
        "content": "<p>Simps makes the boilerplate lemmas for equivs and I think bundled homs</p>",
        "id": 246914325,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626993924
    },
    {
        "content": "<p>I didn't get it before but I just put <code>@[simps?]</code> before any definition and if the lemmas look reasonable I keep it in</p>",
        "id": 246914347,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1626993946
    },
    {
        "content": "<p>Right now my question is whether I should be going down this rabbithole at all. I've changed 86 files, got mathlib compiling, then I deleted a few imports and now it's all broken again.</p>",
        "id": 246914416,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626993972
    },
    {
        "content": "<p>works fine most of the time, you can also make it <code>simp</code> the RHS before making a lemma (I can't remember how though)</p>",
        "id": 246914422,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1626993977
    },
    {
        "content": "<p>simps {rhs := true} iirc</p>",
        "id": 246914605,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626994134
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 246914612,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626994143
    },
    {
        "content": "<p>Kevin, if you manage to convince some maintainer to merge <a href=\"https://github.com/leanprover-community/mathlib/issues/8317\">#8317</a> then you'll have less deprecated group homs to handle.</p>",
        "id": 246914848,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1626994342
    },
    {
        "content": "<p>Apparently you should be tagging <code>to_compl</code> with <code>simps</code></p>",
        "id": 246915276,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626994724
    },
    {
        "content": "<p>Me? Why?</p>",
        "id": 246915320,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1626994775
    },
    {
        "content": "<p>Because above I was replacing <code>is_monoid_hom (foo : X -&gt; Y) := ...</code> with <code>foo_monoid_hom : X -&gt;* Y := ...</code> and then <code>@[simp] lemma foo_monoid_hom_coe : (foo_monoid_hom : X -&gt; Y) = foo := rfl</code> and Yakov told me I should be using <code>@[simps]</code>.</p>",
        "id": 246949493,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627026666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113488-general/topic/deprecated.20folder.20--.20deleting.20lemmas.3F/near/246914198\">said</a>:</p>\n<blockquote>\n<p>Shouldn't simps take care of making the simp lemma for you?</p>\n</blockquote>\n<p>Wait a minute. I'm now doing this <code>simps</code> thing and I've noticed that it's not making <code>coe</code> lemmas, it's making <code>apply</code> lemmas. For example in the deprecated days we had <code>multiset.map_is_add_monoid_hom</code> (a proof that <code>map f : multiset α → multiset β</code> preserves 0 and addition) and I'm changing it to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">multiset.map_add_monoid_hom</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span> <span class=\"bp\">→+</span> <span class=\"n\">multiset</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>If I <code>@[simps]</code> this I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">multiset.map_add_monoid_hom_apply</span><span class=\"o\">:</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">map_add_monoid_hom</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p>whereas I was proposing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">map_add_monoid_hom_coe</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">map_add_monoid_hom</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">multiset</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>and of course the linter doesn't like both. Which one should be in mathlib? Or isn't it as simple as that?</p>",
        "id": 247090469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627156643
    },
    {
        "content": "<p><code>simps</code> hasn't been taught to distinguish coe from apply (yet)</p>",
        "id": 247096812,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627165892
    },
    {
        "content": "<p>IMO we should teach it to though</p>",
        "id": 247096868,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627165948
    },
    {
        "content": "<p>You can get those lemmas with <code>@[simps {fully_applied := ff}]</code>. See <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simps_cfg\">docs#simps_cfg</a> for more info.<br>\nThere is no way yet to tell simps that for certain projections you should always have <code>{fully_applied := ff}</code>.</p>",
        "id": 247098542,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1627169206
    },
    {
        "content": "<p>Thanks! I don't know whether they are good simp lemmas in practice but if we're moving away from the <code>is_</code> structures completely then one of them at least seems to be necessary</p>",
        "id": 247115114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627200668
    },
    {
        "content": "<p>Can you tell it to call the unapplied lemmas <code>coe_foo</code> rather than <code>foo_apply</code> though Floris?</p>",
        "id": 247116134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627202302
    },
    {
        "content": "<p>A piece of GitHub usage you might not have known: if you are deciding whether or not to use two PRs, A and then B (which depends on A), one option is to make PR A, then raise PR B with a base of A rather than a base of <code>master</code>. (That is, it is a pull request for merging B into A, not into master.) That way, both PRs can be reviewed independently, with PR B being reviewed as though A had already been merged into master, but really you haven't actually merged A into master. When the whole stack of PRs is ready to merge, you can merge B into A, and then Bors squash-merge A into master. See <a href=\"https://blog.logrocket.com/using-stacked-pull-requests-in-github/\">https://blog.logrocket.com/using-stacked-pull-requests-in-github/</a> for a longer-form explanation with screenshots. (This workflow may or may not be any use for what you want to do here; I just saw some words upthread which suggested this might be appropriate.)</p>",
        "id": 247128772,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1627223081
    },
    {
        "content": "<p>Was that intended for a different thread?</p>",
        "id": 247129166,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627223781
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/deprecated.20folder.20--.20deleting.20lemmas.3F/near/247116134\">said</a>:</p>\n<blockquote>\n<p>Can you tell it to call the unapplied lemmas <code>coe_foo</code> rather than <code>foo_apply</code> though Floris?</p>\n</blockquote>\n<p>Currently the setup is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">initialize_simps_projections</span> <span class=\"n\">add_hom</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"bp\">→</span> <span class=\"n\">apply</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If you want the <code>coe</code> naming uniformly, you can replace it with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">initialize_simps_projections</span> <span class=\"n\">add_hom</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"bp\">→</span> <span class=\"n\">coe</span> <span class=\"n\">as_prefix</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Not sure if that is preferred throughout the whole library, though.</p>",
        "id": 247137868,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1627236911
    },
    {
        "content": "<p>Sure, but what I'm asking is how to make <code>@[simps apply]</code> output <code>f_hom_apply : ⇑f_hom x = f x</code> and <code>@[simps coe]</code> output <code>coe_f_hom : ⇑f_hom = f</code></p>",
        "id": 247143771,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627245806
    },
    {
        "content": "<p>Or at least, a way to get both via simps, the exact spelling needed doesn't matter, only the lemmas it generates</p>",
        "id": 247143834,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627245886
    },
    {
        "content": "<p>This is possible, as long as you write the <code>coe</code> projection as <code>[simps? coe {fully_applied := ff}]</code><br>\nYou have to change the initialization to the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- See Note [custom simps projection] -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">add_hom.simps.coe</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→+</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">e</span>\n\n<span class=\"n\">initialize_simps_projections</span> <span class=\"n\">add_hom</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"bp\">→</span> <span class=\"n\">apply</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"bp\">→</span> <span class=\"n\">coe</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">coe</span> <span class=\"n\">as_prefix</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(apparently you have to give the coercion explicitly for the second name of the <code>to_fun</code> projection)</p>\n<p>Here is a full example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.simps</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span>    <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">≃</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"o\">:=</span> <span class=\"n\">equiv</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"bp\">$</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">equiv.to_fun</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- See Note [custom simps projection] -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">equiv.simps.coe</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">e</span>\n\n<span class=\"n\">initialize_simps_projections</span><span class=\"bp\">?</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"bp\">→</span> <span class=\"n\">apply</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"bp\">→</span> <span class=\"n\">coe</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">coe</span> <span class=\"n\">as_prefix</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Composition of equivalences `e₁ : α ≃ β` and `e₂ : β ≃ γ`. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">equiv.trans</span> <span class=\"o\">(</span><span class=\"n\">e₁</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e₂</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">≃</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">e₂</span> <span class=\"bp\">∘</span> <span class=\"n\">e₁</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simps</span><span class=\"bp\">?</span> <span class=\"n\">coe</span> <span class=\"o\">{</span><span class=\"n\">fully_applied</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span><span class=\"o\">}]</span> <span class=\"n\">equiv.trans</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">[simps] &gt; adding projection equiv.coe_trans:</span>\n<span class=\"cm\">        &gt; ∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (e₁ : α ≃ β) (e₂ : β ≃ γ),</span>\n<span class=\"cm\">  ⇑(e₁.trans e₂) = ⇑e₂ ∘ ⇑e₁</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simps</span><span class=\"bp\">?</span><span class=\"o\">]</span> <span class=\"n\">equiv.trans</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">[simps] &gt; adding projection equiv.trans_apply:</span>\n<span class=\"cm\">        &gt; ∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (e₁ : α ≃ β) (e₂ : β ≃ γ) (ᾰ : α),</span>\n<span class=\"cm\">  ⇑(e₁.trans e₂) ᾰ = (⇑e₂ ∘ ⇑e₁) ᾰ</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>This is assuming that with <code>@[simps]</code> (without options) you want to generate the <code>apply</code> lemma and not the <code>coe</code> lemma.</p>",
        "id": 247148847,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1627251989
    },
    {
        "content": "<p>I guess the only thing that would be left to ask for would be for <code>coe</code> to imply <code>fully_applied:=ff</code></p>",
        "id": 247149606,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627253355
    },
    {
        "content": "<p>That's a todo in <a href=\"https://github.com/leanprover-community/mathlib/issues/5489\">#5489</a></p>",
        "id": 247165234,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1627278231
    },
    {
        "content": "<p>I was just thinking about ways the ways we tend to attach properties to terms.</p>\n<ul>\n<li>Typeclasses let you associate data to a term more or less syntactically: if a term has a particular form, then you can provide some additional structure.  A downside is that rewriting an expression tends to break the connection.</li>\n<li>\"Bundling\" the property by defining a structure along with coercions to the underlying data.  This solves the rewrite problem, but the structure isn't <em>literally</em> the data.  Attaching multiple different kinds of data can require a carefully designed hierarchy.</li>\n</ul>\n<p>One that doesn't seem to be used much is tagging.  This is a general tagging function I was just playing with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[reducible]</span> <span class=\"kd\">def</span> <span class=\"n\">attach</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>You can use this to define sets with an attached proof that they are subgroups:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">the_subgroup</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">attach</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Then, for example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">the_subgroup.mem_inter_iff</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h''</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">s'</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">the_subgroup</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"n\">h''</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">the_subgroup</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">the_subgroup</span> <span class=\"n\">s'</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">set.mem_inter_iff</span>\n</code></pre></div>\n<p>Theoretically, the <code>the_subgroup</code> terms in an expression are able to help you apply lemmas that need a proof of <code>is_subgroup</code>, but otherwise the tags will be ignored.</p>\n<p>Here are some basic examples (sorry, it's for an older version of mathlib, before <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s recent changes...).  I haven't really tested the idea, but I thought I'd throw it out there in case it's somehow interesting.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.int.parity</span>\n<span class=\"kn\">import</span> <span class=\"n\">deprecated.subgroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">@[reducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">attach</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">the_even</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">attach</span> <span class=\"n\">even</span> <span class=\"n\">n</span> <span class=\"n\">h</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">the_odd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">odd</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">attach</span> <span class=\"n\">odd</span> <span class=\"n\">n</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">the_even_add_one_eq</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">the_even</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">the_odd</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">int.even_add_one</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">])</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">the_subgroup</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">attach</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"o\">(</span><span class=\"n\">the_subgroup</span> <span class=\"n\">s</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">the_subgroup_attach</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_subgroup</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">the_subgroup</span> <span class=\"n\">s</span> <span class=\"n\">infer_instance</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">the_subgroup.inter</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">the_subgroup</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"bp\">∩</span> <span class=\"n\">the_subgroup</span> <span class=\"n\">s'</span> <span class=\"n\">h'</span> <span class=\"bp\">=</span> <span class=\"n\">the_subgroup</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"n\">infer_instance</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subgroup.of_eq</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">subgroup.of</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">the_subgroup</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">the_subgroup.mem_inter_iff</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h''</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">s'</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">the_subgroup</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"n\">h''</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">the_subgroup</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">the_subgroup</span> <span class=\"n\">s'</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">set.mem_inter_iff</span>\n</code></pre></div>",
        "id": 248737171,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628372859
    },
    {
        "content": "<p>Aren't these just subtypes of \"set X\"?</p>",
        "id": 248745366,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628385768
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> A term with <code>attach</code>ed data is definitionally equal to that term -- there aren't any new types here -- for the subgroup example, <code>the_subgroup s h</code> is trivially defeq to <code>s</code>.  It's true that the terms for which you can write a <code>the_subgroup</code> term correspond to terms of a subtype (in particular, <code>{s : set α // is_subgroup s}</code>), but nothing is explicitly constructed.  This lets you manipulate tagged terms easier, I think. For example you can sort the attached data:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">attach_swap</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">β'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">β'</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">attach</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">attach</span> <span class=\"n\">β'</span> <span class=\"n\">x</span> <span class=\"n\">h'</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">attach</span> <span class=\"n\">β'</span> <span class=\"o\">(</span><span class=\"n\">attach</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>In principle, you can also attach data other than proofs, and then they would in a sense \"just\" be sigma types.  One difference from a sigma type is that the additional data is sort of discarded, and it's only used to help fill in implicit arguments during elaboration or when proving things.</p>",
        "id": 248746549,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628387986
    },
    {
        "content": "<p>So your attach is like constructing a term of a subtype then instantly coercing it back to the original type</p>",
        "id": 248746649,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628388109
    },
    {
        "content": "<p>Sure, if you want there to be a type involved to explain it. (Are you suggesting it would be better that way?  This is just meant add some data to the AST that's easy to access and easy to ignore. Also, if it were using subtypes, it would have to be done in a way that that coercion you describe doesn't get <code>simp</code>ed away.)</p>",
        "id": 248747084,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628388783
    },
    {
        "content": "<p>I'm saying that <code>attach</code> is fine for constructing such tagged terms. What about requiring such tagged terms, as an argument for a def or a proof? Then you are proving the data and the proof separately, to be able to say <code>lemma ex (x : X) (h : P x) : Q (attach x h) := ...</code>. I guess I'm not fully understanding what <code>attach</code> gives you that subtypes do not.</p>",
        "id": 248747432,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628389259
    },
    {
        "content": "<p>I am not saying that subtypes are the solution to the problem, but rather, I want to appreciate what you propose!</p>",
        "id": 248747454,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628389306
    },
    {
        "content": "<p>Ah, here's a difference where your approach is \"trivially defeq\" but the subtype one isn't:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">deprecated.subgroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">the_subgroup</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">subtype</span> <span class=\"n\">is_subgroup</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">class</span><span class=\"o\">]</span> <span class=\"n\">is_subgroup</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">the_subgroup.mem_inter_iff</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h''</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">s'</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">the_subgroup</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"n\">h''</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">the_subgroup</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">the_subgroup</span> <span class=\"n\">s'</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- by rw set.mem_inter_iff</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">set.mem_inter_iff</span><span class=\"o\">,</span> <span class=\"c1\">-- fails</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[reducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">attach</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">the_subgroup'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">attach</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">the_subgroup'.mem_inter_iff</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h''</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">s'</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">the_subgroup'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"n\">h''</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">the_subgroup'</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">the_subgroup'</span> <span class=\"n\">s'</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">set.mem_inter_iff</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 248747789,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628389586
    },
    {
        "content": "<p>The subtype approach requires a <code>by convert set.mem_inter_iff _ _ _</code></p>",
        "id": 248747799,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628389645
    },
    {
        "content": "<p>This is all very untested, but the design constraints I was going for are (1) that rewrites should work with tagged data, and (2) that the tags don't unintentionally disappear (I suspect <code>simp</code> will gobble them up if they were subtypes).  Using subtypes is an interesting idea, but I think things tend to work out better following the principle \"if a function could take a sigma type, existential, or subtype, make it take the components separately.\"</p>",
        "id": 248747969,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628389806
    },
    {
        "content": "<p>Another way tagged data works is, of course, with structures.</p>",
        "id": 248748115,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628390032
    },
    {
        "content": "<p>Which are inherently even more opaque than subtypes.</p>",
        "id": 248748154,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628390045
    },
    {
        "content": "<p>A place tags are sort of used already in mathlib is to create \"new\" types for having a different collection of instances.  There's a variation I haven't seen (though it's possible it's there somewhere, mathlib is big!) where there are additional unused arguments whose purpose is to parameterize instances.  One example might be where you want to take a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_torsor\">docs#add_torsor</a>, choose an origin, and treat it like an additive group.</p>",
        "id": 248748347,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628390404
    },
    {
        "content": "<p>This could potentially also be a way to have a set remember that it comes from a <code>set_like</code>, which might be an alternative to things like <code>is_subgroup</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sets</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">set_like</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">the</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">set_like</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">sets</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">attach</span> <span class=\"n\">_</span> <span class=\"n\">s</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">some_set</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">set_like</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">sets</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">h.some</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">h.some_spec.symm</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">the_subgroup.inter</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">sets</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"n\">sets</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">the</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"bp\">∩</span> <span class=\"n\">the</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">t</span> <span class=\"n\">h'</span> <span class=\"bp\">=</span>\n    <span class=\"n\">the</span> <span class=\"o\">(</span><span class=\"n\">subgroup</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">h.some</span> <span class=\"bp\">⊓</span> <span class=\"n\">h'.some</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">some_set</span><span class=\"o\">]})</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 248748623,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628390927
    },
    {
        "content": "<p>(There's probably some way to not have to write lemmas like <code>the_subgroup.inter</code>.  I just chose it for demonstration.)</p>",
        "id": 248748693,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628391041
    }
]
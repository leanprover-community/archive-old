[
    {
        "content": "<p>Is it true that only a small number of inductive types is enough to implement all other inductive types? I was playing with this idea, and I managed to use only <code>false</code>, <code>nat</code> and <code>psigma</code> to re-implement all inductive types and props from <code>core.lean</code>. Is there a type that can't be implemented using those three types? If there's no such type, why do we have inductive constructions as a part of the kernel?</p>",
        "id": 268131567,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1642261633
    },
    {
        "content": "<p>Set theory would tell you that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pSet\">docs#pSet</a> is enough to reimplement everything. <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 268131657,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1642261745
    },
    {
        "content": "<p>The part of the kernel that handles inductives implements general rules for checking inductives and constructing recursors. If you're willing to trust them (and the theory) to handle <code>false</code>, <code>nat</code>, and <code>psigma</code>, it seems like you've already bought and paid for the underlying theory, so you might as well use it. The post-mortem on e.g. Lean 3's mutual inductives seems to suggest that the \"implement complex constructions as machine-generated compositions of simpler elements\" is not without tradeoffs. Inductive types are pretty central to the user experience in Lean; in terms of getting actionable feedback and communicating with users and stuff, I would assume a direct implementation is much better.</p>",
        "id": 268135129,
        "sender_full_name": "Chris B",
        "timestamp": 1642265845
    },
    {
        "content": "<p>How did you make <code>eq</code>?</p>",
        "id": 268135713,
        "sender_full_name": "Reid Barton",
        "timestamp": 1642266399
    },
    {
        "content": "<blockquote>\n<p>Set theory would tell you that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pSet\">docs#pSet</a> is enough to reimplement everything.</p>\n</blockquote>\n<p>Maybe I don't understand the Lean type theory enough, but as far as I can tell, you can't implement <code>nat</code> using only <code>pSet</code> without any other inductive types. Being able to inductively construct an infinite type (such as <code>nat</code>) using Lean inductive constructions basically implies the ZFC axiom of infinity.</p>\n<blockquote>\n<p>Inductive types are pretty central to the user experience in Lean; in terms of getting actionable feedback and communicating with users and stuff, I would assume a direct implementation is much better.</p>\n</blockquote>\n<p>Of course. But I'm not talking about the user interface at all. When you define an inductive type, all that you get back from the kernel are some constants and their types. The meta level code then proves other things, noconfusion, induction, dcases, and similar lemmas. My point is that we can only have a small number of builtin constants and define everything other in terms of that. User would not see any difference (except that a recursor of a type will actually have a concrete definition).</p>\n<blockquote>\n<p>How did you make eq?</p>\n</blockquote>\n<p>Here is my definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">iff</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here are other definitions (there may be some mistake, I haven't formally proved they are equivalent to the actual definitions from <code>core.lean</code>):</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Definitions</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">test</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">false</span> <span class=\"bp\">→</span> <span class=\"n\">false</span>\n<span class=\"kd\">def</span> <span class=\"n\">true.intro</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">false</span><span class=\"o\">),</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">not</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">false</span>\n<span class=\"kn\">local</span> <span class=\"kd\">prefix</span> <span class=\"bp\">`¬`</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"o\">:=</span> <span class=\"n\">not</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">not_not</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬¬</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"n\">dite</span> <span class=\"n\">p</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">h₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">or</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">q</span>\n<span class=\"kd\">def</span> <span class=\"n\">or.inl</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">or</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"kd\">def</span> <span class=\"n\">or.inr</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">or</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">and</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">and.intro</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">and</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span>\n<span class=\"kd\">def</span> <span class=\"n\">and.left</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">and</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"n\">dite</span> <span class=\"n\">p</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h₂</span> <span class=\"n\">h₃</span><span class=\"o\">,</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">and.right</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">and</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"n\">dite</span> <span class=\"n\">q</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h₂</span> <span class=\"n\">h₃</span><span class=\"o\">,</span> <span class=\"n\">h₁</span> <span class=\"n\">h₃</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">iff</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">and</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">iff.intro</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"n\">and.intro</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span>\n<span class=\"kd\">def</span> <span class=\"n\">iff.mp</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">h.left</span>\n<span class=\"kd\">def</span> <span class=\"n\">iff.mpr</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">iff</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">h.right</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">iff</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"kn\">local</span> <span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">=</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">eq</span>\n<span class=\"kd\">def</span> <span class=\"n\">eq.refl</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">and.intro</span> <span class=\"n\">id</span> <span class=\"n\">id</span>\n<span class=\"kd\">def</span> <span class=\"n\">eq.subst</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h₂</span>\n\n<span class=\"kd\">def</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span>\n<span class=\"kd\">def</span> <span class=\"n\">punit</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">def</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"kd\">def</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">subtype</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">psigma</span> <span class=\"n\">β</span>\n<span class=\"kd\">def</span> <span class=\"n\">subtype.val</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">subtype</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x.fst</span>\n<span class=\"kd\">def</span> <span class=\"n\">subtype.property</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">subtype</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x.snd</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">psigma</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">prod.fst</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">prod</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x.fst</span>\n<span class=\"kd\">def</span> <span class=\"n\">prod.snd</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">prod</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">x.snd</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ'</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"kd\">def</span> <span class=\"n\">option.none</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">false.elim</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">option.some</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">option.is_some</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">x.fst</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">le</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">le</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lt</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">and</span> <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">iff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_some</span> <span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"n\">k</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">list.length</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">xs.snd.fst</span>\n<span class=\"kd\">def</span> <span class=\"n\">list.nil</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">option.none</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">list.cons</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">xs.length</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">option.some</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n<span class=\"n\">xs.length.succ</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">test</span>\n</code></pre></div>\n</div></div>",
        "id": 268139736,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1642271429
    },
    {
        "content": "<p>This is covered in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a>, chapter 5.</p>",
        "id": 268139903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642271711
    },
    {
        "content": "<p>Specifically, you need 8 inductive types:</p>\n<ul>\n<li><code>false</code></li>\n<li><code>psigma</code></li>\n<li><code>psum</code></li>\n<li><code>ulift</code></li>\n<li><code>nonempty</code></li>\n<li><code>W_type</code>  (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/W_type\">docs#W_type</a>)</li>\n<li><code>eq</code></li>\n<li><code>acc</code>  (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/acc\">docs#acc</a>)</li>\n</ul>",
        "id": 268139997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642271815
    },
    {
        "content": "<p>The main one is <code>W_type</code>, but then you need all the others to actually put stuff together into the form needed by <code>W_type</code></p>",
        "id": 268140052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642271883
    },
    {
        "content": "<p>Regarding your constructions:</p>\n<ul>\n<li>The <code>true</code> construction works as a type that is bijective with <code>true</code>, but it doesn't have all the right defeqs. The W-type reduction includes all the same defeqs as a genuine inductive type.</li>\n<li>Same thing for <code>and</code> and <code>or</code>, and in particular those constructions are not intuitionistic, they require LEM to prove the recursor and such</li>\n<li>Your definition of <code>eq</code> is not strong enough: in lean you can prove <code>eq.subst</code> when <code>P : A -&gt; Sort u</code>, not just <code>Prop</code>. I believe your construction is equivalent to lean's <code>eq</code>, but you need to use lean's <code>eq</code> to prove the equivalence...</li>\n<li>The <code>unit</code> construction is wrong, <code>Sort u</code> is not a singleton type</li>\n<li><code>punit</code> isn't actually universe polymorphic like lean's</li>\n<li>The <code>bool</code> model will make <code>bool.cases</code> noncomputable</li>\n<li>The <code>option</code> model makes <code>option.cases</code> noncomputable</li>\n</ul>",
        "id": 268140316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642272341
    },
    {
        "content": "<p>I think it's worth reading how all the (non-dependent) inductive types can be encoded in an impredicative type theory like the Calculus of Constructions -- It doesn't even have any built-in inductive types!</p>\n<p>However, with Lean, you have universe level problems, and also defeqs and computability will break. <code>eq</code> doesn't work as Carneiro points out, and I think (handwavingly) that this is connected to the fact that to make a category finitely complete, you need a terminal object, binary products and equalizers.</p>",
        "id": 268140551,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1642272662
    },
    {
        "content": "<p>You should also check out Church encodings, which are a general mechanism for encoding inductive types in lambda calculus or System F (i.e. a haskell-like type theory). Unfortunately it doesn't work properly in the presence of a universe hierarchy, which is why CIC builds it in instead</p>",
        "id": 268140932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642273129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/113488-general/topic/Inductive.20constructions/near/268139736\">said</a>:</p>\n<blockquote>\n<p>Of course. But I'm not talking about the user interface at all. When you define an inductive type, all that you get back from the kernel are some constants and their types. The meta level code then proves other things, noconfusion, induction, dcases, and similar lemmas. My point is that we can only have a small number of builtin constants and define everything other in terms of that. User would not see any difference (except that a recursor of a type will actually have a concrete definition).</p>\n</blockquote>\n<p>Recursors are already given a concrete definition by the kernel, they get lambda/value-level term(s) in the form of a reduction rule.</p>\n<p>The point of the lean 3 mutual inductives example was that the introduction of an intermediate mapping between what's going on in the kernel and what the user sees has a high chance of bleeding through into the UX. Giving users feedback or letting them look at lower level information about their inductive now requires you to go back and forth through this translation layer in a manner that's completely transparent.</p>\n<p>If the idea was that users would write their inductives explicitly in terms of the primitives you (or Mario) mentioned then that wouldn't be the case, but you would have a different proof assistant at that point.</p>",
        "id": 268141107,
        "sender_full_name": "Chris B",
        "timestamp": 1642273271
    },
    {
        "content": "<p>Note that by using <code>dite</code> in your definitions above, you're using another inductive type, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/decidable\">docs#decidable</a></p>",
        "id": 268155143,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1642292587
    }
]
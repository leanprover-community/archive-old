[
    {
        "content": "<p>I've decided to finally start work on matching the APIs on complete lattices and conditionally complete lattices</p>",
        "id": 286879641,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655799120
    },
    {
        "content": "<p>Here's one sticking point I've quickly noticed: what's up with <code>complete_semilattice_Sup</code> and <code>complete_semilattice_Inf</code>?</p>",
        "id": 286879714,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655799145
    },
    {
        "content": "<p>They unconditionally imply <code>complete_lattice</code>, so surely it makes no sense to have them in the typeclass hierarchy?</p>",
        "id": 286879908,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655799287
    },
    {
        "content": "<p>Those two classes should be completely removed from the hierarchy, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/boolean_algebra.core\">docs#boolean_algebra.core</a> as well. They are alternative constructors, not mathematically meaningful typeclasses.</p>",
        "id": 286879919,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655799296
    },
    {
        "content": "<p>Then that's a good starting point for the refactor</p>",
        "id": 286879951,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655799318
    },
    {
        "content": "<p>I'm on it</p>",
        "id": 286879954,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655799321
    },
    {
        "content": "<p>Note that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complete_semilattice_Sup\">docs#complete_semilattice_Sup</a> was added somewhat recently in <a href=\"https://github.com/leanprover-community/mathlib/pull/6797\">#6797</a> by <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>; I would wait for their opinion before pushing for removing it</p>",
        "id": 286880807,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1655799887
    },
    {
        "content": "<p>(Of course, you can still play around with removing it to understand what breaks before that)</p>",
        "id": 286880839,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1655799908
    },
    {
        "content": "<p>I opened a draft PR <a href=\"https://github.com/leanprover-community/mathlib/pull/14863\">#14863</a></p>",
        "id": 286881906,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655800469
    },
    {
        "content": "<p>I edited its description to link back here</p>",
        "id": 286882374,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1655800732
    },
    {
        "content": "<p>Ooh cool. Violeta, I think those typeclasses are meant to have a purpose but they are misdefined. I worked it out the other day but I can't remember where I got to - but essentially if you add the right caveat to le_Sup etc. they make sense.</p>",
        "id": 286887416,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655803484
    },
    {
        "content": "<p>That to me just suggests that there's other potentially useful typeclasses, which doesn't change that the current ones should be removed.</p>",
        "id": 286887699,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655803637
    },
    {
        "content": "<p>I'm curious as to what your proposal is though</p>",
        "id": 286887726,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655803655
    },
    {
        "content": "<p>Oh I totally agree they need to be removed.</p>",
        "id": 286887769,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655803684
    },
    {
        "content": "<p>OK, let me try and put my thoughts together.</p>\n<p>You can think of many classes in the order hierarchy as \"failing to be complete\" in various ways, or \"succeeding at being complete\" in certain cases. Certain sets have Sups and Inf, by which I mean well-behaved ones, obviously: when I say \"a set has an Inf\" I mean \"for that set <code>s</code>, <code>Inf s</code> is a glb for s<code>, a la </code>complete_lattice_of_Inf<code>, and obviously analogously for </code>Sup`.</p>\n<p>For instance, an <code>order_top</code> has <code>Inf</code> for the empty set/<code>Sup</code> for <code>set.univ</code>. An <code>order_bot</code> vice versa. A <code>bounded_order</code> for both. A <code>lattice</code> has them both for every non-empty finite set. A <code>semilattice_inf</code> has only Inf for the same. You get the picture.</p>\n<p>We even have some stuff that doesn't use the same notation but which fits into this view. An <code>omega_complete_partial_order</code> essentially has Sups for every chain. There are concepts which I think we don't have but which fit into this framework - a directed-complete partial order is a porder where each directed subset has a Sup.</p>\n<p>Obviously, a <code>conditionally_complete_lattice</code> is a porder where every non-empty bounded above set has a Sup, and vice versa for Inf. So it also fits into this view. We also have <code>conditionally_complete_linear_order_bot</code>, which is described as \"nonempty subset which is bounded above has a supremum, and every nonempty subset (necessarily bounded below) has an infimum\", though this isn't quite true: an empty subset has a sensible <code>Sup</code> (see <code>is_lub_cSup'</code> and note the lack of requirement of <code>s</code> to be nonempty). So actually a <code>conditionally_complete_linear_order_bot</code> has \"bounded above Sups and nonempty Infs\", and indeed I think these are dual to one another? We don't seem to have a <code>conditionally_complete_linear_order_top</code> but I hope it's clear what that would be.</p>\n<p><code>complete_semilattice_Inf</code> should be \"you have as much <code>Inf</code> as you can without completing the lattice\", I guess was my thought. If you have every <code>Inf</code> except the <code>Inf</code> of the empty set, I think that's actually <code>conditionally_complete_linear_order_bot</code>, though, and <code>every Inf for bounded below sets\" should be \"</code>conditionally_complete_linear_order_top`\", though we don't have it, as I say.</p>\n<p>My overall point is this, which I think you should take into account in this refactor: there is a general paradigm here where there is some sensible set of sets on which <code>Infs</code> or <code>Sups</code> make sense, and the lattice of this <code>set of sets</code> corresponds to the lattice of differently complete structures that we have.</p>\n<p>We also have types like <code>with_bot</code> and <code>with_top</code>. These are a bit different. They are used sometimes in two different ways:</p>\n<ul>\n<li>Sometimes they are used like closure operators. That is to say, \"with_top nat\" is \"doing the minimal you want to do to nat in order to make it an order_top\". In theory, given any of the semicomplete structures mentioned above, and a partial order, you could apply a closure operator using that structure to your partial order in order to produce a new partial order that is in a precise sense minimal with respect to that structure. In the extreme case of \"closure over <code>complete_lattice</code>\", this is the Dedekind–MacNeille completion, which we have using <code>order.concept</code>, and I wonder (speculation!) that maybe the work of Yaël in <code>order.concept</code> might provide a general framework to define such a \"closure via a semicompletion\".</li>\n<li>Sometimes we use <code>with_bot</code> etc. <em>not</em> like closure operators. <code>nat</code> is already an <code>order_bot</code>, but <code>with_bot nat</code> is a different type with its own uses! So here it is... I don't know how to say it, really just a type constructor but not a closure operator of any kind. My claim is not that this is bad, but that conceptually it's a different thing. While it would be work, perhaps more than it's worth, we could try to separate out these two different uses. I have a theory that they probably cause some trouble in some places.</li>\n</ul>\n<p>Separately I think to the above things, but interrelated with the first: some types have the property that for some sets, not only do they have Sups/Infs for some sets, but those Sups/Infs are, for some sets, actually Max/Min (which is to say, they are not just glb/lubs but greatest/least elements of the set). In other types, it might be the case that some sets always have a maximal element but not a greatest element - this I think is more different, but it's another property. And because a Sup is the \"greatest of upper bounds\", the presence of greatest and and least elements of at least some sets is tied up with Sup/Inf presence.</p>\n<p>So, to summarise (I'm sorry this is long but I hope it is useful):</p>\n<ul>\n<li>There is a general paradigm where you have some \"semicompleteness/conditional completeness property for a type\", which is essentially some predicate on sets which says whether or not you have <code>Sups</code> and/or <code>Infs</code> for sets meeting that predicate. (Is this a filter? I don't understand filters, but it might be.)</li>\n<li>Nearly every structure we have in the pure order hierarchy can be described this way.</li>\n<li>Abstracting this common description might make it easier to use the hierarchy, understand how it fits together, and extend it in future.</li>\n<li>\"Closure with respect to a semicompleteness structure\" is a meaningful concept and one we might be able to support.</li>\n<li>There are a few lacunae or other issues to consider and this isn't a total view.</li>\n</ul>\n<p>Thanks for listening.</p>",
        "id": 286891500,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655805842
    },
    {
        "content": "<p>Wrenna, do you know about categorical limits?</p>",
        "id": 286891896,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655806108
    },
    {
        "content": "<p>Vaguely!</p>",
        "id": 286891915,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655806124
    },
    {
        "content": "<p>I guess what I describe above might be that in a sense? But I didn't want to go <em>too</em> abstract.</p>",
        "id": 286891982,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655806183
    },
    {
        "content": "<p>\"Sups in different situations\" are exactly limits (or colimits? who cares), and this is the right way to talk about them.</p>",
        "id": 286892004,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655806204
    },
    {
        "content": "<p>I'm afraid you're reinventing category theory, that's it <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 286892065,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655806227
    },
    {
        "content": "<p>Sure, I am not claiming to be doing anything new! And isn't it all category theory really? ;) But just as, say, in an algebraic concept \"the algebraic closure of a field\" is useful in and of itself, even though I'm sure it has a categorical interpretation, perhaps it is useful to have these things without simply saying \"well, it's general abstract nonsense\".</p>",
        "id": 286892251,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655806344
    },
    {
        "content": "<blockquote>\n<p>Abstracting this common description might make it easier to use the hierarchy, understand how it fits together, and extend it in future.</p>\n</blockquote>\n<p>This is what the files in <code>catgeory_theory</code> do.</p>",
        "id": 286892314,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655806393
    },
    {
        "content": "<p>Well - this was a reply to Violeta so I shall see what she thinks.</p>",
        "id": 286892350,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655806413
    },
    {
        "content": "<p>You should look up the correspondence between order and category concepts. Here's the ones I can think of on the spot:</p>\n<ul>\n<li>Preorders and categories</li>\n<li>bottom/top element and initial/final object</li>\n<li>sup/inf and binary limit/colimit</li>\n<li>Sup/Inf and arbitrary limit/colimit</li>\n<li>order dual and opposite category</li>\n<li>Heyting algebras and cartesian closed categories</li>\n</ul>",
        "id": 286892549,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655806544
    },
    {
        "content": "<p>Yes, I do know about these things.</p>",
        "id": 286893935,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655807493
    },
    {
        "content": "<p>I don't really understand category theory but that's a really cool insight into the order hierarchy</p>",
        "id": 286902679,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655813158
    },
    {
        "content": "<p>That said, from a design perspective, I have no idea how we would actually implement this</p>",
        "id": 286902817,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655813228
    },
    {
        "content": "<p>I don't know if you meant my post or Yaël's, though I guess your latter comment applies to either.</p>",
        "id": 286902878,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655813262
    },
    {
        "content": "<p>I mean your post</p>",
        "id": 286902906,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655813279
    },
    {
        "content": "<p>Ah - thank you then :D</p>",
        "id": 286902918,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655813284
    },
    {
        "content": "<p>One idea I had - though it wasn't very popular - was to redefine Sup and Inf so that they go into the complete_lattice completion, and then essentially you're talking about \"when is Sup/Inf a principal ideal over there\". But that doesn't get to the heart of the matter. (It's a bit like embedding a field in its algebraic completion because then it's easier to talk about \"the roots of a polynomial\" even when they don't exist in the current field, I guess.)</p>",
        "id": 286903129,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655813403
    },
    {
        "content": "<p>That would certainly be a huge change, I don't know what repercussions it might have to change their types like that</p>",
        "id": 286903658,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655813681
    },
    {
        "content": "<p>Oh it would be massive, it's a terrible idea :D</p>",
        "id": 286903685,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655813695
    },
    {
        "content": "<p>But the nice thing about that is that you don't have any kind of junk value for <code>Inf</code> or <code>Sup</code> - it has <em>some</em> meaning. From wikipedia:</p>\n<p><code>The partially ordered set S is join-dense and meet-dense in the Dedekind–MacNeille completion; that is, every element of the completion is a join of some set of elements of S, and is also the meet of some set of elements in S. The Dedekind–MacNeille completion is characterized among completions of S by this property.</code></p>\n<p>Because members of the completion are cuts, which you can think of as sets where the lower bound of their upper bounds is equal to the set (or the pair of that with the dual), if you think about this a little, those sets which are cuts are I think exactly those that have Sups (or Infs dually). So it really does measure \"the degree of Sup/Inf failure\".</p>",
        "id": 286906378,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655815151
    },
    {
        "content": "<p>I guess I just feel like we have:<br>\n<code>ωSup_le_ωSup_of_le</code><br>\n<code>Sup_le_Sup</code><br>\n<code>cSup_le_cSup</code></p>\n<p>And these are all <em>the same theorem</em> - \"on good sets, Sup is monotonic\" - but we prove it in three unrelated ways. This is what indicates to me that you <em>could</em> do a deep refactor here. If someone wants to introduce a new notion of \"semicomplete partial order\" - and as noted, there are such notions - we want them to get all these theorems \"for free\", ideally.</p>",
        "id": 286907876,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655815923
    },
    {
        "content": "<blockquote>\n<p>There is a general paradigm where you have some \"semicompleteness/conditional completeness property for a type\", which is essentially some predicate on sets which says whether or not you have Sups and/or Infs for sets meeting that predicate.</p>\n</blockquote>\n<p>Probably best phrased in terms of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.has_limits_of_shape\">docs#category_theory.limits.has_limits_of_shape</a></p>",
        "id": 286935297,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655826889
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/conditional.20lattice.20refactor/near/286907876\">said</a>:</p>\n<blockquote>\n<p>And these are all <em>the same theorem</em> - \"on good sets, Sup is monotonic\" - but we prove it in three unrelated ways. </p>\n</blockquote>\n<p>I fear that even if we proved this general theorem, we'd still want the specific instantiations depending on what the \"good sets\" are</p>",
        "id": 286985092,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655852750
    },
    {
        "content": "<p>That said there should be a much greater effort in making sure these APIs look approximately the same</p>",
        "id": 286985205,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655852822
    },
    {
        "content": "<p>The refactor builds!</p>",
        "id": 286990881,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655857984
    },
    {
        "content": "<p>It definitely looks much cleaner IMO</p>",
        "id": 286990892,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655858001
    },
    {
        "content": "<p>The other PR I made cleaning up the file builds too, it's on <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> to merge it</p>",
        "id": 286991291,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655858396
    },
    {
        "content": "<p>There's still some cleanup I want to do to this file before moving on to actually match APIs</p>",
        "id": 286992021,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655859195
    },
    {
        "content": "<p>Mostly tweak some <code>simp</code> attributes and remove some redundant or frankly pointless theorems</p>",
        "id": 286992022,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655859195
    },
    {
        "content": "<p>There's still some cleanup I want to do to this file before moving on to actually match APIs</p>",
        "id": 286992023,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655859196
    },
    {
        "content": "<p>Oh I definitely agree we'd want the specific instantiations.</p>",
        "id": 287033684,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655893791
    },
    {
        "content": "<p>But as you say, it's about matching APIs and similar constructions. Well done on the initial refactor - this is the one just removing complete_semilattice_Inf?</p>",
        "id": 287033798,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655893850
    },
    {
        "content": "<p>I think the next thing to do that would be useful is just creating a hasse diagram of the hierarchy here and identifying anything else that is a natural structure you'd want, or things like the omega_complete_partial_order which aren't currently in the hierarchy directly but have a natural place in it?</p>\n<p>While in some ideal world, yes, some kind of nice categorical construction would be nice, at the very least we can get a clear picture of what the current state of affairs is. Sorry to maths wikipedia (would be good to get a good non-wiki source on this), but these pages are interesting:</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Complete_partial_order\">https://en.wikipedia.org/wiki/Complete_partial_order</a><br>\n<a href=\"https://en.wikipedia.org/wiki/Completeness_(order_theory)\">https://en.wikipedia.org/wiki/Completeness_(order_theory)</a></p>\n<p>The \"Completeness in terms of adjunctions\" section in the latter looks particularly interesting. Which also contains \"The considerations in this section suggest a reformulation of (parts of) order theory in terms of category theory, where properties are usually expressed by referring to the relationships (morphisms, more specifically: adjunctions) between objects, instead of considering their internal structure. For more detailed considerations of this relationship see the article on the categorical formulation of order theory\", although said article appears to have been deleted...</p>",
        "id": 287034332,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655894171
    },
    {
        "content": "<p>(The \"Introduction to Lattices and Order\" book that Yael has mentioned before might provide a good source? Would be good to get feedback from multiple order theorists before doing anything wild maybe.)</p>",
        "id": 287034472,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655894280
    },
    {
        "content": "<p>Just a side comment, but putting these three files (<code>complete_lattice</code>, <code>conditionally_complete_lattice</code>, and <code>omega_complete_lattice</code>) on the same folder would help us keep the API matched</p>",
        "id": 287038596,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655896960
    },
    {
        "content": "<p>And also declutter the huge <code>order</code> folder</p>",
        "id": 287038611,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655896969
    },
    {
        "content": "<p>I was thinking about a more general <code>lattice</code> folder, actually.</p>",
        "id": 287038802,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655897071
    },
    {
        "content": "<p>Even then, maybe these specific files still deserve a subfolder?</p>",
        "id": 287039508,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655897457
    },
    {
        "content": "<p>Even then, maybe these specific files still deserve a subfolder?</p>",
        "id": 287039510,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655897457
    },
    {
        "content": "<p>The whole point is that they should have very similar lemmas, just with somewhat different hypotheses</p>",
        "id": 287039511,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655897457
    },
    {
        "content": "<p>Highly unconvinced. Very similar files are rarely (never?) grouped alone in a subfolder. Instead, they are either spread through similar folders (eg the <code>.interval</code>  or <code>.pointwise</code> files) or mixed within a bigger folder (eg <code>algebra.big_operators.</code>).</p>",
        "id": 287039820,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655897626
    },
    {
        "content": "<p>You mean <code>omega_complete_partial_order</code>.</p>",
        "id": 287048244,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655902153
    },
    {
        "content": "<p>It isn't a lattice.</p>",
        "id": 287048254,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655902156
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> This page points out one reason we might keep these structures. <a href=\"https://ncatlab.org/nlab/show/suplattice\">https://ncatlab.org/nlab/show/suplattice</a></p>\n<p>Namely, while any <code>complete_semilattice_Sup</code> is a <code>complete_lattice</code>, a <code>Sup</code>-preserving map may not preserve Infs. So the type of structure-preserving maps from these things is different.</p>",
        "id": 287069864,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655911448
    },
    {
        "content": "<p>We have no API whatsoever for maps preserving these structures though, and if we did, surely that would be orthogonal to the typeclasses themselves?</p>",
        "id": 287071024,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655911971
    },
    {
        "content": "<p>e.g. group homomorphisms are defined separately from groups</p>",
        "id": 287071139,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655912030
    },
    {
        "content": "<p>Aye, I am not sure if it's an issue in practice.</p>",
        "id": 287071161,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655912043
    },
    {
        "content": "<p>But at least it is a \"why would you ever define such a thing\": as ever, the answer is categorical.</p>",
        "id": 287071287,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1655912081
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/Sup_hom\">docs#Sup_hom</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Inf_hom\">docs#Inf_hom</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/SemilatticeSup\">docs#SemilatticeSup</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/SemilatticeInf\">docs#SemilatticeInf</a></p>",
        "id": 287079759,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655915684
    },
    {
        "content": "<p>Oh nice</p>",
        "id": 287106437,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655928572
    },
    {
        "content": "<p>Guess that settles it</p>",
        "id": 287106560,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1655928616
    },
    {
        "content": "<p>But the fact that the same objects with different maps form a different category is an important property and it <strong>does not</strong> mean that we should make the objects different.</p>",
        "id": 287120436,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1655935748
    },
    {
        "content": "<p>On this topic, I was thinking</p>",
        "id": 287546369,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656318239
    },
    {
        "content": "<p>It might be clearer what the relation between these different lattices are if instead of having fields <code>Inf_le</code> and <code>le_Inf</code> separately in the classes, we had a single field <code>is_glb_Inf</code></p>",
        "id": 287546485,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656318307
    },
    {
        "content": "<p>Same goes for <code>Sup</code></p>",
        "id": 287546494,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656318313
    },
    {
        "content": "<p>For complete lattices, <code>is_glb (Inf s)</code> always, for conditionally complete lattices this happens for nonempty sets that are bounded above, for conditionally complete linear orders with a bottom element it happens when they're bounded above</p>",
        "id": 287546830,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656318512
    },
    {
        "content": "<p>We can then deduce <code>le_Inf</code> and <code>Inf_le</code> from here</p>",
        "id": 287546846,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656318530
    },
    {
        "content": "<p>If nothing else, this approach is certainly conceptually easier</p>",
        "id": 287546859,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656318542
    },
    {
        "content": "<p>And since <code>is_glb (Inf s)</code> is def-eq to <code>le_Inf s \\and Inf_le s</code> it shouldn't make any proofs harder</p>",
        "id": 287546909,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656318582
    },
    {
        "content": "<p>It might fail to make them easier if there's no better ways to prove <code>is_glb</code> though</p>",
        "id": 287547065,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656318658
    },
    {
        "content": "<p>The tendency is to rather split fields (<a href=\"https://github.com/leanprover-community/mathlib/pull/14556\">#14556</a>) because it makes things easier to prove.</p>",
        "id": 287547350,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656318826
    },
    {
        "content": "<p><code>is_glb (Inf s)</code> has type <code>α → Prop</code>; what are you intending as the second argument?</p>",
        "id": 287547876,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656319126
    },
    {
        "content": "<p>Or did you mean <code>is_glb set.univ (Inf s)</code> or <code>is_glb s (Inf s)</code>?</p>",
        "id": 287547920,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656319151
    },
    {
        "content": "<p>Surely <code>is_glb s (Inf s)</code>is the only thing that makes sense?</p>",
        "id": 287692629,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656409472
    },
    {
        "content": "<p>Personally I think this has much to commend it.</p>",
        "id": 287692656,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656409490
    },
    {
        "content": "<p>the split approach is essentially \"Inf s \\mem lower_bounds s\" and \"Inf s \\mem upper_bounds (lower_bounds s)\". It certainly makes sense to have these as their own theorems. But I'm not sure what's better in terms of defining the structure.</p>",
        "id": 287693052,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656409711
    },
    {
        "content": "<p>I think that <code>is_glb_Inf</code> is a good idea because we already have API about <code>is_glb</code>/<code>is_lub</code>.</p>",
        "id": 287851334,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1656508690
    },
    {
        "content": "<p>In case of a <code>conditionally_complete_lattice</code>, the axiom should say that for any bounded from below nonempty set <code>s</code>, we have <code>is_glb s (Inf s)</code>.</p>",
        "id": 287851497,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1656508783
    },
    {
        "content": "<p>But I don't recommend you to start this refactor before running, e.g., a poll on Zulip.</p>",
        "id": 287851557,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1656508804
    },
    {
        "content": "<p>Here's an idea, might be a bad idea, might be a good idea, who knows</p>",
        "id": 288302672,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656815808
    },
    {
        "content": "<p>We could create a structure <code>generalized_lattice</code> that looks like the current <code>conditional_lattice</code>, but with extra fields for the sets of sets for which <code>le_cSup</code>, etc. hold</p>",
        "id": 288302753,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656815978
    },
    {
        "content": "<p>We can then create typeclasses for special cases</p>",
        "id": 288302761,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656815988
    },
    {
        "content": "<p>If these sets are the universal set, it's a complete lattice, it they contain the sets of sets bounded above, then they're a conditional complete lattice, and so on</p>",
        "id": 288302810,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656816030
    },
    {
        "content": "<p>A nice thing about this approach is that we can change the def-eqs: for instance, naturals are a conditionally complete lattice, but we might prefer to use the <code>set.finite</code> predicate instead of <code>bdd_above</code>, and on ordinals, we might prefer to use <code>small</code> instead</p>",
        "id": 288302826,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656816090
    },
    {
        "content": "<p>This approach might also alleviate having to prove the same results over and over for these different types: we can prove whatever version is true in the most general case, then specialize</p>",
        "id": 288302894,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656816215
    },
    {
        "content": "<p>I think that's not too far from what I was thinking about, and I like it.</p>",
        "id": 288330535,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656858950
    },
    {
        "content": "<p>However, it shouldn't be called a generalized lattice.</p>",
        "id": 288330581,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656859005
    },
    {
        "content": "<p>Because a lattice is (in particular) one of these where the sets that have this property etc. are the finite sets.</p>",
        "id": 288330601,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656859054
    },
    {
        "content": "<p>Also it's worth thinking about how the presence of Sups and the presence of Infs is related. Obviously all Infs iff all Sups, but...</p>",
        "id": 288330654,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656859100
    },
    {
        "content": "<p><code>generalized_conditionally_complete_partial_order</code> might work as a name maybe.</p>",
        "id": 288330684,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656859155
    },
    {
        "content": "<p>That suggestion sounds a bit like refactoring <code>field</code> to allow other non-invertibility conditions, which I think I considered before but seemed dubious</p>",
        "id": 288333498,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1656862796
    },
    {
        "content": "<p>My opinion is that this is solving a problem we don't have.</p>",
        "id": 288335612,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656865790
    },
    {
        "content": "<p>Our order theoretic library does not fine grain enough on what exactly we are allowed to take a supremum of? This is expected, because order theory is a simple special case of category theory. If you want this fine graining, use categories, not orders.</p>",
        "id": 288335710,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656865884
    },
    {
        "content": "<p>In the opposite direction, you could go as far as ditching <code>lattice</code> because \"it's just <code>generalized_conditionally_complete_partial_order α (range $ λ x : α × α, {x.1, x.2})</code> after all\".</p>",
        "id": 288335791,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656866018
    },
    {
        "content": "<p>I think that even if we did have a <code>generalized_conditionally_complete_partial_order</code>, we'd still want <code>lattice</code> and all the other special cases. The difference is that now we'd be proving a lot of theorems on <code>generalized_conditionally_complete_partial_order</code> and then transferring them to these special cases.</p>",
        "id": 288354617,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656893525
    },
    {
        "content": "<p>I'm not sure if \"just use categories\" is a viable solution here. One because I don't know category theory <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span> and two because surely we still have an interest in speaking in these structures as order structures?</p>",
        "id": 288354626,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656893562
    },
    {
        "content": "<p>That's what I'm not sure about. We are going well without these hypothetical typeclasses.</p>",
        "id": 288355769,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656894939
    },
    {
        "content": "<p>That's a fair point</p>",
        "id": 288356002,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656895252
    },
    {
        "content": "<p>I guess we've done alright without a single unifying class</p>",
        "id": 288356006,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656895263
    },
    {
        "content": "<p>I do think we should consider refactoring <code>omega_complete_partial_order</code> so that it uses the Sup notation, rather than a different notation.</p>",
        "id": 288378175,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656921720
    },
    {
        "content": "<p>It doesn't use <code>Sup</code>?</p>",
        "id": 288378243,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656921744
    },
    {
        "content": "<p>That's a surprise given all we've discussed</p>",
        "id": 288378251,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656921752
    },
    {
        "content": "<p>(note: I've never actually touched that code)</p>",
        "id": 288378261,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656921759
    },
    {
        "content": "<p>let me just double-check</p>",
        "id": 288378268,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656921766
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/omega_complete_partial_order\">docs#omega_complete_partial_order</a></p>",
        "id": 288378289,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656921777
    },
    {
        "content": "<p>(My computer is always slow first thing in the morning, like its owner.)</p>",
        "id": 288378315,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656921801
    },
    {
        "content": "<p>Yeah, we should totally use <code>Sup</code> there too</p>",
        "id": 288378394,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656921848
    },
    {
        "content": "<p>Well it just works a differently too because the domain of <code>ωSup</code> is chains.</p>",
        "id": 288378475,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656921903
    },
    {
        "content": "<p>Rather than, as <code>Sup</code> works everywhere else, the domain being sets, and then having theorems which say \"when this set matches this predicate, Sup of it works\"</p>",
        "id": 288378522,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656921936
    },
    {
        "content": "<p>Oh</p>",
        "id": 288378629,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656921983
    },
    {
        "content": "<p>In that case I'm not so sure anymore</p>",
        "id": 288378653,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656922001
    },
    {
        "content": "<p>well I think it may reflect the fact that it was designed differently</p>",
        "id": 288378668,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922016
    },
    {
        "content": "<p>conceptually it really is the same.</p>",
        "id": 288378702,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922036
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Complete_partial_order\">https://en.wikipedia.org/wiki/Complete_partial_order</a></p>",
        "id": 288378704,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922038
    },
    {
        "content": "<p>I maintain that we should be able to describe the three notions on here, of which I believe we have one (?)</p>",
        "id": 288378734,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922056
    },
    {
        "content": "<p>I guess there's an alternate universe where suprema of conditionally complete lattices take in the subtype of bounded sets instead of sets</p>",
        "id": 288378743,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656922065
    },
    {
        "content": "<p>Yes.</p>",
        "id": 288378747,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922072
    },
    {
        "content": "<p>Which I think would... be less good.</p>",
        "id": 288378761,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922082
    },
    {
        "content": "<p>It would suck not being able to use the theorems on conditionally complete lattices on complete lattices</p>",
        "id": 288378832,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656922118
    },
    {
        "content": "<p>Yes</p>",
        "id": 288378838,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922123
    },
    {
        "content": "<p>Although there's not really that many common theorems, to be fair</p>",
        "id": 288378841,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656922125
    },
    {
        "content": "<p>Mostly just easy ones like <code>Sup {a} = a</code> and such</p>",
        "id": 288378858,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656922139
    },
    {
        "content": "<p>Do we have any such situations with omega-complete partial orders?</p>",
        "id": 288378889,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1656922165
    },
    {
        "content": "<p>In terms of annoyances I've encountered, to be honest in the past it's mostly been things like \"it's oddly hard to know what the right way to talk about the minimum of a set of natural numbers are\", and that isn't (directly) an issue with Sup</p>",
        "id": 288378917,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113488-general/topic/conditional.20lattice.20refactor/near/288378889\">said</a>:</p>\n<blockquote>\n<p>Do we have any such situations with omega-complete partial orders?</p>\n</blockquote>\n<p>Well, every complete lattice is an omega-complete partial order, so we must have all the theorems of the latter on the former.</p>",
        "id": 288379061,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922264
    },
    {
        "content": "<p>But yeah - I don't think we have to do this refactor, but while I see Yael's complaint, I'm not necessarily saying we should be able to talk about arbitrary Sups - just that we should make sure we have every commonly-used notion of completeness and they should fit together nicely.</p>",
        "id": 288379215,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/conditional.20lattice.20refactor/near/288378475\">said</a>:</p>\n<blockquote>\n<p>Well it just works a differently too because the domain of <code>ωSup</code> is chains.</p>\n</blockquote>\n<p>chains btw are omega-chains here, and they aren't actually sets because they're monotone functions from Nat to your type or whatnot</p>",
        "id": 288379305,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1656922437
    },
    {
        "content": "<p>My PR broke and I can't figure out why for the life of me</p>",
        "id": 289747425,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657901069
    },
    {
        "content": "<p>Can someone check <a href=\"https://github.com/leanprover-community/mathlib/pull/14863\">#14863</a> and tell me why it suddenly changes how the order in <code>upper_set</code>is defined?</p>",
        "id": 289747478,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657901099
    },
    {
        "content": "<p>It's possible that the problem is not that the order is different, but that there are too many metavariables to infer the order.</p>",
        "id": 289748046,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1657901388
    },
    {
        "content": "<p>What happens if you use <code>@compl_subset_compl</code> instead?</p>",
        "id": 289748227,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1657901473
    },
    {
        "content": "<p>I'm almost sure the order changed, since changing the <code>≤</code> to <code>≥</code> fixes these lemmas</p>",
        "id": 289750237,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657902471
    },
    {
        "content": "<p>I'll still try to provide everything explicitly, give me a sec</p>",
        "id": 289750294,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657902485
    },
    {
        "content": "<p>Yeah look,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">compl_le_compl</span> <span class=\"o\">:</span> <span class=\"n\">s.compl</span> <span class=\"bp\">≤</span> <span class=\"n\">t.compl</span> <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"bp\">≥</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">compl_subset_compl</span>\n</code></pre></div>\n<p>this works, the original doesn't</p>",
        "id": 289788304,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657922303
    },
    {
        "content": "<p>I think I see the issue</p>",
        "id": 289788509,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657922438
    },
    {
        "content": "<p><code>upper_set</code> is getting its <code>≤</code> from <code>set_like.partial_order</code></p>",
        "id": 289788586,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657922475
    },
    {
        "content": "<p>So it seems like my PR accidentally uncovered a diamond</p>",
        "id": 289788605,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657922485
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span></p>",
        "id": 289788625,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657922497
    },
    {
        "content": "<p>Oh wait, <code>set_like</code> provides a partial order by default? <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 289802425,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1657937406
    },
    {
        "content": "<p>Yep</p>",
        "id": 289802734,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657937829
    },
    {
        "content": "<p>I presume that should be a definition rather than an instance?</p>",
        "id": 289802749,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657937877
    },
    {
        "content": "<p>Or maybe the solution is to short-circuit typeclass inference in <code>upper_set</code>?</p>",
        "id": 289802828,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657937984
    },
    {
        "content": "<p>We can probably strip that off because most set-like structures are actually complete lattices (so there's no need for a <code>partial_order</code> instance). If lemmas are stated in the generality of <code>set_like</code> using that default partial order, we can restate them using an order embedding or something of sort.</p>",
        "id": 289802833,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1657937992
    },
    {
        "content": "<p>You wanna go ahead? I could try fixing this diamond myself but I've never worked with <code>set_like</code> before and I don't want to screw something up</p>",
        "id": 289802972,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657938176
    },
    {
        "content": "<p>You have at least until I wake tomorrow to try it out!</p>",
        "id": 289803176,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1657938457
    },
    {
        "content": "<p>I started a fix attempt at <a href=\"https://github.com/leanprover-community/mathlib/pull/15411\">#15411</a>, but I have no idea if it will work</p>",
        "id": 289808282,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657946703
    },
    {
        "content": "<p>The original point of set_like is \"objects with canonical embedding to sets that preserves order and membership and coercion to sort\"</p>",
        "id": 289811657,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657952136
    },
    {
        "content": "<p>The current behavior is useful; if it's not useful to you, then it sounds like you need a weaker <code>less_set_like</code> class</p>",
        "id": 289811727,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657952237
    },
    {
        "content": "<p>(or to rename the existing one)</p>",
        "id": 289811778,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657952286
    },
    {
        "content": "<p>I'm glad to hear that because turning <code>set_like.partial_order</code> into a <code>def</code> breaks a lot of things I don't really understand</p>",
        "id": 289811785,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657952324
    },
    {
        "content": "<p>So, the solution here would be to remove the <code>set_like</code> instance for <code>upper_set</code>?</p>",
        "id": 289811801,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657952382
    },
    {
        "content": "<p>...or possibly, just use the order-dual to get the reverse ordering Yaël wants</p>",
        "id": 289811805,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657952399
    },
    {
        "content": "<p>...and/or revert <a href=\"https://github.com/leanprover-community/mathlib/pull/14982\">#14982</a></p>",
        "id": 289811855,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1657952439
    },
    {
        "content": "<p>Yeah, either we need a new typeclass for \"a bit less set-like than set_like\" to use for <code>upper_set</code>, or we should not have made <code>upper_set</code> less set-like in the first place</p>",
        "id": 289812202,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657953028
    },
    {
        "content": "<p>What's the immediate solution though?</p>",
        "id": 289868427,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658040512
    },
    {
        "content": "<p>This is blocking my PR for no good reason</p>",
        "id": 289868430,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658040534
    },
    {
        "content": "<p>It shouldn't be hard to revert <a href=\"https://github.com/leanprover-community/mathlib/pull/14982\">#14982</a> - we can then figure out what should or shouldn't be done long term</p>",
        "id": 289868448,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658040578
    },
    {
        "content": "<p>I still think that just using the order dual of <code>upper_set</code> is the most elegant solution btw</p>",
        "id": 289868501,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658040621
    },
    {
        "content": "<p>Using the order dual in the place where we state the isomorphism, you mean?</p>",
        "id": 289868740,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658041060
    },
    {
        "content": "<p>A revert seems reasonable to me, but let's wait to hear from <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span></p>",
        "id": 289868815,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658041185
    },
    {
        "content": "<p>Indeed, and if we want to use this order on filters, use the order dual too</p>",
        "id": 289869187,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658041722
    },
    {
        "content": "<p>That's one of the justifications Yaël originally gave for this</p>",
        "id": 289869208,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1658041784
    },
    {
        "content": "<p>Filters already have this order</p>",
        "id": 289869329,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658041949
    },
    {
        "content": "<p>I don't think you'll persuade anyone that changing the order on filters is a good idea</p>",
        "id": 289869336,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658041978
    },
    {
        "content": "<p>Just to be clear; which is \"your PR\" in question?</p>",
        "id": 289869478,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658042215
    },
    {
        "content": "<p>The original order on <code>upper_set</code> was the result of <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> being doubtful about not using the inclusion order, but the literature is clear that upper sets and filters should be ordered by reverse inclusion (and Bhavik changed his mind), so I would rather suggest either:</p>\n<ul>\n<li>Getting rid of the <code>set_like → partial_order</code> instance</li>\n<li>Getting rid of the <code>set_like (upper_set α) α</code> instance</li>\n</ul>",
        "id": 289874918,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658050363
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/upper_set.set_like\">docs#upper_set.set_like</a> is the offending instance I assume?</p>",
        "id": 289875000,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658050512
    },
    {
        "content": "<p>If the literature is clear on this, can you edit the docstring to reference it for our choice?</p>",
        "id": 289875053,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658050585
    },
    {
        "content": "<p>I think it makes sense to retain the <code>set_like → partial_order</code> instance (I've used it recently).</p>",
        "id": 289990381,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1658161963
    }
]
[
    {
        "content": "<p>I feel like <code>div_inv_monoid</code> does not quite fulfill its purpose of common ancestor of <code>group</code> and <code>group_with_zero</code> because <code>div</code> and <code>inv</code> are currently lawless. We still have a fair share of lemmas which are duplicated between both. For example,</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/inv_one\">docs#inv_one</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/one_inv\">docs#one_inv</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/one_zpow\">docs#one_zpow</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/one\">docs#one</a>_zpow₀</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/group.to_has_involutive_inv\">docs#group.to_has_involutive_inv</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/group_with_zero.to_has_involutive_inv\">docs#group_with_zero.to_has_involutive_inv</a></li>\n</ul>\n<p>What do people think of making <code>div_inv_monoid</code> stronger and thus potentially more useful for deduplicating lemmas?</p>",
        "id": 278406644,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649505735
    },
    {
        "content": "<p>The original motivation was <code>div_eq_mul_inv</code>, so it's not <em>entirely</em> lawless</p>",
        "id": 278407502,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649506941
    },
    {
        "content": "<p>Okay so I will make <code>div_inv_monoid</code> extend <code>has_involutive_inv</code>. While I'm at it, shouldn't we have <code>div_inv_comm_monoid</code>?</p>",
        "id": 279224050,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650205608
    },
    {
        "content": "<p>I am thinking of lemmas like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/div_eq_inv_mul\">docs#div_eq_inv_mul</a></p>",
        "id": 279224072,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650205665
    },
    {
        "content": "<p>Let me also add another motivation to my original message: Pointwise operations (<code>set</code>, <code>finset</code>, <code>filter</code>) make a group <em>except</em> for <code>a / a = 1</code>. This means that we currently</p>\n<ul>\n<li>duplicate the instances: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.div_inv_monoid\">docs#set.div_inv_monoid</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.div_inv_monoid'\">docs#set.div_inv_monoid'</a> (same for the other two). This is rather minor</li>\n<li>lack almost all lemmas relating division and inversion. For example, when <code>s t : finset α</code> and <code>α</code> is a <code>group</code>, it is true that <code>(t / s)⁻¹ = s / t</code> but it is a pain to prove.</li>\n</ul>",
        "id": 279224297,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650205919
    },
    {
        "content": "<p><code>div_inv_monoid</code>/<code>div_inv_comm_monoid</code> could help here by being \"a group (with zero), except that division doesn't have to bring you back to <code>1</code>\".</p>",
        "id": 279224357,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650205991
    },
    {
        "content": "<p>I went through all instances of <code>div_inv_monoid</code> and it seems that nothing relies on the current precise implementation.</p>",
        "id": 279224370,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650206020
    },
    {
        "content": "<p>I agree that <code>div_eq_inv_mul</code> and similar lemmas look like sufficient justification for <code>div_inv_comm_monoid</code></p>",
        "id": 279224703,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650206467
    },
    {
        "content": "<p>Do we already have the group versions of those lemmas?</p>",
        "id": 279224714,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650206487
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/div_eq_inv_mul'\">docs#div_eq_inv_mul'</a> ?</p>",
        "id": 279226616,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650209325
    },
    {
        "content": "<p>Some thoughts over at <a href=\"https://github.com/leanprover-community/mathlib/tree/stronger_div_inv_monoid\">branch#stronger_div_inv_monoid</a>. I am still figuring which<code>group /</code>group_with_zero<code> lemmas should be turned into axioms of </code>div_inv_monoid<code>. So far I've gone with </code>inv_inv : a⁻¹⁻¹ = a<code> and </code>inv_mul_rev : (a * b)⁻¹ = b⁻¹ * a⁻¹` and it seems to work well.</p>",
        "id": 279243305,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650233885
    },
    {
        "content": "<p>Okay I'm hitting a problem with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.div_inv_monoid\">docs#matrix.div_inv_monoid</a>. Inversion of matrices isn't involutive.</p>",
        "id": 279266199,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650268062
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>, is there any way to make this work?</p>",
        "id": 279266628,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650268579
    },
    {
        "content": "<p>I'd encourage you to do the <code>div_inv_comm_monoid</code> change first before going too deep into this second can of worms</p>",
        "id": 279266671,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650268664
    },
    {
        "content": "<p>I mean, are you happy with me nuking <code>matrix.div_inv_monoid</code> into pieces?</p>",
        "id": 279266731,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650268698
    },
    {
        "content": "<p>Given that <code>data.matrix.zpow</code> is a leaf file, this should be fine.</p>",
        "id": 279266756,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650268749
    },
    {
        "content": "<p>It might be worth waiting for <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>'s opinion on that kind of thing; originally <code>div_inv_monoid</code> was intended purely to unify the two notations, but with your suggested change it's now not able to do that any more (in this case, for matrices)</p>",
        "id": 279266953,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650268897
    },
    {
        "content": "<p>Maybe the solution is to have both <code>div_inv_class</code> (for the notation) and <code>div_inv_monoid</code> (for the lemma deduplication).</p>",
        "id": 279267041,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650268971
    },
    {
        "content": "<p>I'm not sure about the names, but an additional typeclass would alleviate my specific concern above.</p>",
        "id": 279267133,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650269085
    },
    {
        "content": "<p>If you look at <a href=\"https://github.com/leanprover-community/mathlib/tree/stronger_div_inv_monoid\">branch#stronger_div_inv_monoid</a>, you will also see that I had to manually copy the new fields from <code>div_inv_monoid</code> to a bunch of structures because extending <code>div_inv_monoid</code> would make them have many two redundant fields. Having this notation typeclass would fix this.</p>",
        "id": 279267221,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650269171
    },
    {
        "content": "<p>What about <code>has_lawful_div</code>?</p>",
        "id": 279267223,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650269179
    },
    {
        "content": "<p>For the stronger or weaker notion?</p>",
        "id": 279267629,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650269660
    },
    {
        "content": "<p>The weaker one.</p>",
        "id": 279267655,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650269709
    },
    {
        "content": "<p>Involution of inverse is too strong for matrices. But as we have it defined, inv thrice is inv.</p>",
        "id": 279267994,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1650270155
    },
    {
        "content": "<p>Ask Anne, they made the matrix inv work. The zpow is just making its commutation make sense with npow.</p>",
        "id": 279268027,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1650270196
    },
    {
        "content": "<p>I think the div_eq_inv_mul is a powerful law, because it implies statements about associativity of various operators. The fact that the matrix semiring admits an inverse that respects this structure is to me, reason enough to have it.</p>",
        "id": 279268661,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1650270975
    },
    {
        "content": "<p>It doesn't buy you much, though. You can take an arbitrary <code>inv</code> and derive <code>div</code> from it. Sure, we do get a few lemmas about the interaction of <code>div</code> and <code>mul</code> but that's it.</p>",
        "id": 279269252,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650271574
    },
    {
        "content": "<p><code>matrix</code> actually respects <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.mul_inv_rev\">docs#matrix.mul_inv_rev</a>, which is a pretty crucial lemma.</p>",
        "id": 279269273,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650271603
    },
    {
        "content": "<p>Just look at the sheer amount of lemmas I can deduplicate/generalize and convince yourself: <a href=\"https://github.com/leanprover-community/mathlib/tree/stronger_div_inv_monoid\">branch#stronger_div_inv_monoid</a></p>",
        "id": 279270121,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650272623
    },
    {
        "content": "<p>Removing an existing typeclass is an orthogonal discussion to adding a new one</p>",
        "id": 279273739,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650276644
    },
    {
        "content": "<p>(making a typeclass stronger to the point that existing instances are no longer true amounts to removing it and adding a new one with the same name)</p>",
        "id": 279273758,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650276691
    },
    {
        "content": "<p>Okay so I have three propositions, modulo naming:</p>\n<ul>\n<li>Have a class which just contains the bare minimum for division and inversion and use it in <code>extends</code> clause to avoid copying over all the <code>zpow</code> fields, and add a stronger typeclass<ul>\n<li><code>div_inv_class</code> = the current <code>div_inv_monoid</code></li>\n<li><code>div_inv_monoid</code> = <code>div_inv_class</code> + <code>has_involutive_inv</code></li>\n</ul>\n</li>\n<li>Moderately strengthen <code>div_inv_monoid</code> and add a stronger typeclass<ul>\n<li><code>div_inv_class</code> = the current <code>div_inv_monoid</code> + <code>(a * b)⁻¹ = b⁻¹ * a⁻¹</code></li>\n<li><code>div_inv_monoid</code> = <code>div_inv_class</code> + <code>has_involutive_inv</code>. I did not yet manage to prove <code>a * b = 1 → a⁻¹ = b</code> from this, even though all candidate types (yes, even <code>set</code>) in mathlib respect it. If it doesn't hold generally, we might consider adding it as well.</li>\n</ul>\n</li>\n<li>Strengthen <code>div_inv_monoid</code> and make the weaker one a mixin typeclass<ul>\n<li><code>div_inv_class</code> = mixin for <code>a / b = a * b⁻¹</code> and eventually the <code>zpow</code> fields. Does that work diamond-wise?</li>\n<li><code>div_inv_monoid</code> = the current <code>div_inv_monoid</code> + <code>has_involutive_inv</code>.</li>\n</ul>\n</li>\n</ul>\n<p>All three versions do not break any current instance of <code>div_inv_monoid</code>, and actually only one of them (namely <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.div_inv_monoid\">docs#matrix.div_inv_monoid</a>) can't be upgraded to the new version of <code>div_inv_monoid</code>.</p>",
        "id": 279286853,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650288861
    },
    {
        "content": "<p>Another possibility for the names is <code>div_inv_monoid</code> and <code>division_monoid</code>.</p>",
        "id": 279287311,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650289268
    },
    {
        "content": "<p>Another name that may or may not be useful is <code>has_distrib_inv</code> to somewhat match <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_distrib_neg\">docs#has_distrib_neg</a> (although the type of distributivity is quite different)</p>",
        "id": 279287707,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650289629
    },
    {
        "content": "<p>I wouldn't regard these as similar, distributivity is about the interaction of multiplication and addition, but here there is only multiplicative structure. You can see also the form of the axiom <code>neg_mul</code> is different from <code>(a * b)⁻¹ = b⁻¹ * a⁻¹</code> because in <code>neg_mul</code> only one side is negated. It is like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mi mathvariant=\"normal\">.</mi><mi>x</mi><mi>y</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>g</mi><mi mathvariant=\"normal\">.</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">g.xy = (g.x)y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> versus <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mi mathvariant=\"normal\">.</mi><mi>x</mi><mi>y</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>g</mi><mi mathvariant=\"normal\">.</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>g</mi><mi mathvariant=\"normal\">.</mi><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g.xy = (g.x)(g.y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> again.</p>",
        "id": 279288171,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650289961
    },
    {
        "content": "<p>It's rather left or right commutativity of a unary and a binary functions.</p>",
        "id": 279288231,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650290018
    },
    {
        "content": "<p>... which means that <code>has_distrib_neg</code> might be a misnomer.</p>",
        "id": 279288337,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650290076
    },
    {
        "content": "<p>The name <code>has_distrib_neg</code> seems fine to me, it's the part of distributivity/bilinearity that has to do with negation in each argument.</p>",
        "id": 279288488,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650290181
    },
    {
        "content": "<p>I mean it's not <code>neg</code> itself that is <code>distrib</code>utive, but otherwise it's fine.</p>",
        "id": 279288707,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650290375
    },
    {
        "content": "<p>Oh it depends on whether you think of <code>neg</code> as part of the additive structure or as multiplication by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>; maybe that's what you meant?</p>",
        "id": 279288885,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650290481
    },
    {
        "content": "<p>Yes, kind of</p>",
        "id": 279288913,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650290508
    },
    {
        "content": "<p>Like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>∗</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>∗</mo><mi>a</mi><mo>+</mo><mo stretchy=\"false\">(</mo><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>∗</mo><mi>b</mi><mo>=</mo><mo>−</mo><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">-(a + b) = (-1) * (a + b) = (-1) * a + (-1) * b = - a - b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">−</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> which now looks like <code>div_inv</code> stuff and not <code>neg_mul</code> yet I used the distributive law to get it</p>",
        "id": 279289121,
        "sender_full_name": "Reid Barton",
        "timestamp": 1650290663
    },
    {
        "content": "<p><code>has_distrib_inv</code> was a dumb suggestion because we need a name for the additive concept <code>-(a + b) = -b + -a</code>, sorry for the distraction.</p>",
        "id": 279290686,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650291794
    },
    {
        "content": "<p>And the additive name is obviously already taken</p>",
        "id": 279290707,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650291813
    },
    {
        "content": "<p>Technically, it's not distributivity, but antidistributivity.</p>",
        "id": 279290805,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650291873
    },
    {
        "content": "<p>I'm hitting something weird... Making <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_ordered_add_comm_group_with_top\">docs#linear_ordered_add_comm_group_with_top</a> extend <code>has_sub</code> and <code>has_neg</code> instead of <code>sub_neg_monoid</code> and copying over the fields makes Lean reject the default value for <code>sub</code>.</p>",
        "id": 279298056,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650295948
    },
    {
        "content": "<p>Okay so I managed to make version 1 compile. The diff is rather huge, so I will first PR the definition of <code>division_monoid</code>, then the lemma generalizations.</p>",
        "id": 279643512,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650524727
    },
    {
        "content": "<p>It's been a while, hopefully my comments don't lead to too much wasted work!</p>\n<p>The definition of <code>div_inv_monoid</code> had the following main motivation: <code>group_with_zero</code> used to assume <code>div</code> would be defined in terms of <code>inv</code> but for <code>fractional_ideal</code> it's the other way around. So we should replace the definitional equality <code>a / b = a * b⁻¹</code> with a propositional one. Since <code>group</code> might have the same issue in the future, I made a superclass of both <code>group</code> and <code>group_with_zero</code> <code>div_inv_monoid</code> carrying a definition of <code>div</code> and <code>inv</code> and a proof <code>div_eq_mul_inv</code>. A few results nicely generalized from <code>group</code>(<code>_with_zero</code>) to <code>div_inv_monoid</code> but the motivation was to remove a technical obstruction to a specific instance, rather than generalizing as many lemmas as possible.</p>\n<p>Having said that, I think it's a valuable project to generalize as much as reasonable, so indeed a stronger subclass of <code>group</code> and <code>group_with_zero</code> does make sense.</p>",
        "id": 279651360,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1650530455
    },
    {
        "content": "<p>If you could have a look at <a href=\"https://github.com/leanprover-community/mathlib/tree/stronger_div_inv_monoid\">branch#stronger_div_inv_monoid</a> and tell me what you think, I would be grateful!</p>",
        "id": 279651544,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650530556
    },
    {
        "content": "<p>Alright, here's my thoughts on the implementation:</p>\n<ul>\n<li>Mixins can be useful in specific cases, but they do have a tendency to hurt performance. In particular, the fully unfolded term size of a type determines the worst-case typechecking behaviour. So a long inheritance chain including mixins on a <code>group G</code> instance can really hurt typechecking on <code>s : submonoid G</code>, and even worse on typechecking <code>x : s</code>. Also, we probably don't need to switch often in applications between assuming that inverses are very lawful and only a bit lawful, so mixins probably don't help either.</li>\n<li>Naïvely I would assume \"monoid with a (partial) inverse operator\" is one with a strong specification on the inverse of <code>inv_spec : ∀ a b, a * b = 1 → a⁻¹ = b</code>. As far as I can tell, your code puts that in <code>group</code> still, and in the thread you noted that everything currently already satisfies this axiom. (An example of a <code>division_monoid</code> in your branch that doesn't satisfy <code>inv_spec</code> would be a <code>comm_monoid</code> where <code>inv = id</code>.)</li>\n<li>I think we should keep a class isomorphic to <code>div_inv_monoid</code>, since its syntactic role means it can be easily applied to any type with division and inverses, even if those inverses aren't neatly involutive (like matrix (pseudo)inverses).</li>\n</ul>",
        "id": 279654115,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1650532233
    },
    {
        "content": "<p>So overall I think your branch is going in the right direction, except I would like the <code>inv_spec</code> axiom to be a part of the new class. The name <code>division_monoid</code> I'm not totally convinced of (since mathematicians tend to care more about inverses than division) but I guess it works since it's essentially the meet of <code>group</code> and <code>division_ring</code>.</p>",
        "id": 279654494,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1650532496
    },
    {
        "content": "<ul>\n<li><code>division_monoid</code> is not a mixin,  though?</li>\n<li>If you think this axiom is justified, I will add it. The question now is whether this implies any of <code>inv_mul_rev : ∀ a b, (a * b)⁻¹ = b⁻¹ * a⁻¹</code> or <code>inv_inv : ∀ a, a⁻¹⁻¹ = a</code>. I believe <code>matrix</code> is a counterexample for <code>inv_inv</code>, and I can't see how we could derive <code>inv_mul_rev</code> because we would need some cancellation property to prove  <code>(a * b) * (b⁻¹ * a⁻¹) = 1</code>. One thing I also have to check is whether <code>filter</code> respects <code>inv_spec</code>.</li>\n<li>Does that mean you do not want to have both <code>div_inv_monoid</code> and <code>division_monoid</code>? because this is a problem for classes currently extending <code>div_inv_monoid</code> as we do not want to clutter their declarations with the redundant <code>inv_mul_rev</code> and <code>inv_inv</code>.</li>\n<li>I also thought about <code>inversion_monoid</code>, but I quite like the parallel with <code>division_ring</code> indeed.</li>\n</ul>",
        "id": 279654832,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650532739
    },
    {
        "content": "<ul>\n<li>Indeed! I was trying to respond to some questions on mixins upthread.</li>\n<li>I agree that neither follows from <code>inv_spec</code>, for example if you take the naturals then <code>neg_spec</code> only says <code>- 0 = 0</code> and leaves <code>neg</code> totally unspecified otherwise. But if <code>filter</code> also satisfies <code>inv_spec</code> then I don't see that adding it as a new axiom (alongside <code>inv_inv</code> and <code>inv_mul_rev</code>) will cause any problems, while providing a better base for the group axioms.</li>\n<li>I wanted to say that keeping <code>div_inv_monoid</code> as it is, like you have done, seems like the correct approach to me. Sorry if that was unclear.</li>\n</ul>",
        "id": 279655354,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1650533116
    },
    {
        "content": "<p>Fancy! I will figure out the <code>filter</code> conundrum and add <code>inv_spec</code> then! (do you think there's a better name for it?)</p>",
        "id": 279655520,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650533217
    },
    {
        "content": "<p>For groups it's called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/eq_inv_of_mul_eq_one\">docs#eq_inv_of_mul_eq_one</a> so let's use that.</p>",
        "id": 279655619,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1650533275
    },
    {
        "content": "<p>Okay so I managed to prove that <code>inv_eq_of_mul_eq_one</code> on <code>α</code> implies <code>inv_eq_of_mul_eq_one</code> on <code>set α</code>/<code>finset α</code>, but it was harder than I thought! When multiplication is cancellable, you can show that <code>s</code> and <code>t</code> are singletons and then <code>s⁻¹ = t</code> is pretty obvious, but of course a <code>group_with_zero</code> isn't cancellative.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_inv</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">inv_eq_of_mul_eq_one</span> <span class=\"o\">(</span><span class=\"n\">h.subset</span> <span class=\"bp\">$</span> <span class=\"n\">mem_image2_of_mem</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">hst</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nonempty</span> <span class=\"o\">:=</span> <span class=\"n\">h.symm.subst</span> <span class=\"n\">one_nonempty</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hst.of_image2_right</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">inv_inv</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hst.of_image2_left</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">H</span> <span class=\"n\">hb</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">inv_inv</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 279711054,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650561336
    },
    {
        "content": "<p>But <code>H</code> together with <code>hst</code> still are telling you that <code>s</code> and <code>t</code> are singletons, right?</p>",
        "id": 279827656,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1650636108
    },
    {
        "content": "<p>Hmm... You're right. I will try proving the earlier lemma without using cancellability.</p>",
        "id": 279827941,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650636222
    },
    {
        "content": "<p>Update: <code>filter</code> <strong>is</strong> a <code>division_monoid</code>! I will now open the PR.</p>",
        "id": 280794806,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651412118
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13860\">#13860</a></p>",
        "id": 280798457,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651417053
    },
    {
        "content": "<p>Here's the second bit of the refactor: <a href=\"https://github.com/leanprover-community/mathlib/pull/14000\">#14000</a>. It introduces new <code>division_monoid</code> lemmas to replace the <code>group</code> and <code>group_with_zero</code> ones (but leaves the deletion of those to the next PR).</p>",
        "id": 281509264,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651884641
    },
    {
        "content": "<p>I tried my best to make it as straightforward as possible.</p>",
        "id": 281509274,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1651884660
    }
]
[
    {
        "content": "<p>Can't you prove <code>\\lam a f x, L a (f x)</code> is tri-linear by proving it's separately linear in each argument?</p>\n<ul>\n<li>Linear in <code>a</code>; use <code>apply_linear</code>, <code>L.is_linear</code></li>\n<li>Linear in <code>f</code>; use <code>L.is_linear2</code>, <code>apply_linear</code></li>\n<li>Linear in <code>x</code>; use <code>L.is_linear2</code>, <code>f.is_linear</code></li>\n</ul>",
        "id": 283724596,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653388192
    },
    {
        "content": "<p>(I moved this to a new thread, feel free to rename it)</p>",
        "id": 283724756,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653388275
    },
    {
        "content": "<p>I Lean 4  you can abuse type class system to automatically prove linearity/continuity of lambda functions. Here are the core instances that tear each lambda into its atomic function: <a href=\"https://github.com/lecopivo/SciLean/blob/master/SciLean/Core/Mor/IsLin/Core.lean\">https://github.com/lecopivo/SciLean/blob/master/SciLean/Core/Mor/IsLin/Core.lean</a><br>\nThose instances vaguely correspond to SKI combinators.</p>\n<p>To deal with addition and alike I use the fact that uncurried add is linear:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">diag_parm.arg_x.isLin</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y₁</span> <span class=\"bp\">→</span> <span class=\"n\">Y₂</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">yy</span> <span class=\"o\">:</span> <span class=\"n\">Y₁</span> <span class=\"bp\">×</span> <span class=\"n\">Y₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">yy.1</span> <span class=\"n\">yy.2</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Y₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g₁</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g₂</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Y₂</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g₂</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₂</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>However, there are some issues with higher order unification so you need to add certain class instances manually, when <code>f</code> has additional trailing argument, example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">priority</span> <span class=\"o\">:=</span> <span class=\"n\">mid</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">subst.arg_x.parm_a.isSmooth</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsSmooth</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">IsSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">try</span> <span class=\"n\">infer_instance</span> <span class=\"n\">apply</span> <span class=\"n\">subst.arg_x.isSmooth</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">done</span>\n</code></pre></div>\n<p>It is trivialy solvable by direct application of a previous instance, but Lean is unable to do it automatically. I'm still unsure what is the general pattern of these \"additional instances\"</p>",
        "id": 283726430,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653389277
    },
    {
        "content": "<p>A quick test for something like <code>\\la p, matrix.trace (f p.1 + g p.2)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"n\">W</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p.1</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">p.2</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>A part of the trace that shows the sequence of reasoning:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.synthInstance</span><span class=\"o\">]</span> <span class=\"n\">main</span> <span class=\"n\">goal</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p.fst</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">p.snd</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">yy</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">yy.fst</span> <span class=\"bp\">+</span> <span class=\"n\">yy.snd</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"n\">f</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p.fst</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">p.fst</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"n\">g</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p.snd</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"n\">p.snd</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">22</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">p.fst</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">p.snd</span>\n<span class=\"o\">[</span><span class=\"n\">Meta.synthInstance.newAnswer</span><span class=\"o\">]</span> <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"mi\">27</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p.fst</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">p.snd</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 283727703,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653390038
    },
    {
        "content": "<p>The requirement that a variable appears only once is too harsh, for example this is also a linear function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">g</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p.1</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">p.1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 283728006,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653390240
    },
    {
        "content": "<p>Note that we actually used to have such a typeclass system in lean3 (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_add_monoid_hom\">docs#is_add_monoid_hom</a> etc), but it didn't behave well with the simplifier or composition</p>",
        "id": 283728154,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653390328
    },
    {
        "content": "<p>Do you have an example of problematic cases? It works quite well for me in Lean 4, and and main use case is exactly to steer simplifier when applying theorems.</p>",
        "id": 283728813,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653390757
    },
    {
        "content": "<p>I remember reading <a href=\"https://arxiv.org/abs/2202.01629\">Use and abuse of instance parameters in the Lean mathematical library</a> which states that the unbundled approach for morphisms was problematic for mathlib3.</p>",
        "id": 283729063,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653390917
    },
    {
        "content": "<p>I don't know what the canonical reference is for that problem,  it was discovered quite a while ago. It's entirely possible that the problem is not as bad in Lean 4.</p>",
        "id": 283729096,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653390938
    },
    {
        "content": "<p>I know that my approach is impossible in lean3 as it is heavily relaying on the new type class system's ability handling cycles.</p>",
        "id": 283729207,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653391006
    },
    {
        "content": "<p>I can also do the tri-linearity of <code>\\lam a f x, L a (f x)</code>. The only catch if that for linearity in <code>x</code> you need to set <code>f</code> type to bundled linear map, in my notation <code>W ⊸ Y</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Vec</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n  <span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsLin</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n\n  <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">⊸</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">L</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n  <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">L</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n  <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">IsLin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">L</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 283729944,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1653391449
    },
    {
        "content": "<p>Yes I thought the whole point of hanging on to the deprecated lean 3 version of this was that people were aware that it might come back into play in lean 4</p>",
        "id": 283756368,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653403821
    }
]
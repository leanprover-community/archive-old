[
    {
        "content": "<p>This time I ask before refactoring: should we add </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_mem.mem.up</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">mem_of_superset</span> <span class=\"n\">hx</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">hx.up</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>If yes, what would be a good name? <code>up</code> is very short, but is it clear enough?</p>",
        "id": 249354556,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1628858200
    },
    {
        "content": "<p>This lemma is used a <em>lot</em>.</p>",
        "id": 249354614,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1628858244
    },
    {
        "content": "<p>It feels a bit weird to put dot notation on <code>has_mem.mem</code> that only applies to one particular instance of <code>has_mem</code></p>",
        "id": 249359457,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628860987
    },
    {
        "content": "<p>Here's a neat trick that doesn't prevent other types defining a different meaning of <code>has_mem.up</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"sd\">/-- Alias for dot notation -/</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">filter_mem_dot_notation</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">P</span>\n\n<span class=\"c1\">-- wrap the resulting `Prop` in a type alias for dot notation</span>\n<span class=\"kd\">instance</span> <span class=\"n\">filter.has_mem'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">mem</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">u</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">filter_mem_dot_notation</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"n\">f.sets</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">--note: for dot notation, `hx` is wrapped.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">filter_mem_dot_notation.up</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">filter_mem_dot_notation</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- result: dot notation that is specific to `filter.has_mem`</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">hx.up</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>(edit: split the discussion about error message weirdness to <a href=\"#narrow/stream/113488-general/topic/invalid.20field.20notation.2C.20insufficient.20number.20of.20arguments/near/249360436\">a new thread</a>)</p>",
        "id": 249360699,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628861622
    },
    {
        "content": "<p>This weirdness is the reason why it wasn't done before, but it actually causes no harm (and I think we recently did the same for other similar cases).</p>",
        "id": 249361761,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1628862188
    },
    {
        "content": "<p>I'm not sure I understand; are you saying that your original <code>has_mem.mem.up</code> causes no harm, or that my revised solution that doesn't produce the weird error causes no harm?</p>",
        "id": 249361933,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628862276
    },
    {
        "content": "<p>I'm talking about my suggestion.</p>",
        "id": 249361969,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1628862301
    },
    {
        "content": "<p>But if yours works and does not leak anywhere then it's ok.</p>",
        "id": 249362007,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1628862321
    },
    {
        "content": "<p>Just checking you weren't saying that we'd already used the trick I suggest elsewhere. Can you come up with a similar case for the approach you suggest? It might be worth assembling a list of things like <code>has_mem.mem.up</code>, so that in future someone can try the dot  notation hack I suggest above in lots of places at once, in order to increase the chance of finding leaks.</p>",
        "id": 249362400,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628862540
    },
    {
        "content": "<p>Sorry, I need to go now. I'll return tonight.</p>",
        "id": 249362654,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1628862712
    },
    {
        "content": "<p>Would it still work if it were put on <code>has_subset.subset</code> instead? I like thinking of this fact as being functorial in <code>h</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">has_subset.subset.up</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span>\n</code></pre></div>\n<p>To make this more general, there could be a typeclass to introduce <code>has_subset.subset.up</code> functors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_subset_up</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_subset</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">up</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_subset.subset.up</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_subset</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_subset_up</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_subset_up.up</span> <span class=\"n\">h</span> <span class=\"n\">hx</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">filter.subset_up</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_subset_up</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">∈</span><span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">up</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">mem_of_superset</span> <span class=\"n\">hx</span> <span class=\"n\">h</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">h.up</span> <span class=\"n\">hx</span>\n</code></pre></div>\n<p>Or there could be a more specialized version of this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_subset_up</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_subset</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">up</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_subset.subset.up</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mem</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_subset</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_subset_up</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_subset_up.up</span> <span class=\"n\">h</span> <span class=\"n\">hx</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_subset_up</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">up</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">h</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">mem_of_superset</span> <span class=\"n\">hx</span> <span class=\"n\">h</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">h.up</span> <span class=\"n\">hx</span>\n</code></pre></div>",
        "id": 249385919,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628874376
    },
    {
        "content": "<p>The typeclass approach is probably more sensible than the type alias approach I suggested. Can you think of a second instance, or is the only place this happens on filters anyway?</p>",
        "id": 249396922,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628879848
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">subtype.subset_up</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_subset_up</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">up</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">set.inclusion</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">h.up</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 249398713,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628880793
    },
    {
        "content": "<p>I can't get it to work where <code>up</code> gives structured functions, like homomorphisms.  The subset relation for subobjects giving homomorphisms between their coercions to types could have been another use.</p>",
        "id": 249399321,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628881167
    },
    {
        "content": "<p>What I tried was</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">has_subset_up</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_subset</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">up</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but then <code>h.up a</code> is \"too many arguments\"</p>",
        "id": 249399759,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628881361
    },
    {
        "content": "<p><code> β</code> should be an outparam, right?</p>",
        "id": 249402260,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628882585
    },
    {
        "content": "<p>Do you mean in this version?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">has_subset_up</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_subset</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">up</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">⊆</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It's not an <code>out_param</code> because subset-of relations can have multiple induced maps.  <code>set α</code> can have one for both <code>filter</code> and <code>subtype</code>.</p>",
        "id": 249402609,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628882757
    },
    {
        "content": "<p>All this is a lot of fun but it really smells over-engineering until we have a second lemma that would use it.</p>",
        "id": 249403887,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1628883389
    },
    {
        "content": "<p>My original suggestion works without any type class search or tricky aliasing.</p>",
        "id": 249403952,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1628883419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Is there any reason the filter lemma couldn't be <code>has_subset.subset.up</code>?  Another possible name is <code>has_subset.subset.map</code>, though I don't think there's much of a reason to prefer that over <code>up</code>.</p>",
        "id": 249405168,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628884121
    },
    {
        "content": "<p>I don't care about attaching it to <code>has_mem</code> vs <code>has_subset</code>, both would make sense.</p>",
        "id": 249405251,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1628884169
    }
]
[
    {
        "content": "<p>I expected <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_field\">docs#normed_field</a> to be a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_ring\">docs#normed_ring</a> whose underlying ring is a field. However, <code>normed_field</code> uses the more restrictive multiplicative condition <code>‚àÄ (a b : Œ±), ‚à•a * b‚à• = ‚à•a‚à• * ‚à•b‚à•</code>. What is the reason behind this choice?</p>",
        "id": 278279564,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649410835
    },
    {
        "content": "<p>Note, the difference appears at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_division_ring\">docs#normed_division_ring</a></p>",
        "id": 278279731,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649410936
    },
    {
        "content": "<p>Yes, I saw that too.</p>",
        "id": 278279787,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649410974
    },
    {
        "content": "<p>I guess this implies that a normed ring which is a field, isn't necessarily a normed field (for example I think that n(x)=min(|x|_p,1) is a perfectly good normed_ring structure on the p-adic numbers). But I think this is probably OK.</p>",
        "id": 278279967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649411083
    },
    {
        "content": "<p>But it isn't a mixin, so you'd need to use <code>is_field</code></p>",
        "id": 278280364,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649411348
    },
    {
        "content": "<p>Related to this, there's nothing in the library about normed modules, right? I only found <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_space\">docs#normed_space</a>, which assumes you're working over a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_field\">docs#normed_field</a>.</p>",
        "id": 278280563,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649411483
    },
    {
        "content": "<p>I believe this could be weakened on the spot.</p>",
        "id": 278280772,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649411602
    },
    {
        "content": "<p>Do you mean that we could add a <code>normed_module</code> class, where we replace <code>normed_field</code> by <code>normed_ring</code>? That should be enough for my purposes.</p>",
        "id": 278281393,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649411925
    },
    {
        "content": "<p>No no no! Eric spent six months removing something similar. I mean that <code>normed_space</code> could be redefined by replacing <code>normed_field</code> with <code>normed_ring</code>.</p>",
        "id": 278281530,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649411991
    },
    {
        "content": "<p>Oh, so you're saying that all (or at least part of) the existing lemmas will work in that greater generality, so we can just change the definition?</p>",
        "id": 278281733,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649412052
    },
    {
        "content": "<p>That I don't know. I suspect some of them will. My point is that your <code>normed_module</code> has the same axioms as the current <code>normed_space</code>, so it should be the same class.</p>",
        "id": 278281848,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649412110
    },
    {
        "content": "<p>Else, <code>[normed_field ùïú] [normed_module ùïú E]</code> will have less theorems than<code>[normed_field ùïú] [normed_space ùïú E]</code> even though they are mathematically the same.</p>",
        "id": 278281993,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649412180
    },
    {
        "content": "<p>Ah, I see what you mean. I'll try to replace <code>normed_field</code> in the <code>normed_space</code> definition and see what breaks.</p>",
        "id": 278282158,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649412264
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 278282186,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649412276
    },
    {
        "content": "<p>Note that what we call \"normed field\" is usually called a \"valued field\", and \"normed field\" only require the inequality.</p>",
        "id": 278285962,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1649414644
    },
    {
        "content": "<p>There is a discussion about this somewhere</p>",
        "id": 278285988,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1649414660
    },
    {
        "content": "<p>Yes, that's precisely why I expected the definition of <code>normed_field</code> to be different.</p>",
        "id": 278286014,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649414679
    },
    {
        "content": "<p>If I use the <code>[ normed_ring R] (is_field R)</code> approach, I can't use <code>inv</code>, right? I think this will be a problem.</p>",
        "id": 278286832,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649415191
    },
    {
        "content": "<p>I think it would be easier to add a new class <code>normed_field'</code> that uses the inequality in the definition.</p>",
        "id": 278286964,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649415250
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/278285962\">said</a>:</p>\n<blockquote>\n<p>Note that what we call \"normed field\" is usually called a \"valued field\", and \"normed field\" only require the inequality.</p>\n</blockquote>\n<p>(I'm not saying that <code>normed_field'</code> would be the right name for this new class; I also know that <code>valued_field</code> is in use, so choosing names here would not be trivial).</p>",
        "id": 278287188,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649415411
    },
    {
        "content": "<p>You can always use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_field.to_field\">docs#is_field.to_field</a> to get an actual <code>field</code> instance, and use <code>inv</code>. But you will lose some definitional equalities</p>",
        "id": 278287217,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1649415438
    },
    {
        "content": "<p>Even doing that, I don't see how I could use lemmas about inv. For instance, this is one of the first lemmas in <code>analysis/normed_space/basic</code>. I've replaced <code>normed_field</code> by <code>normed_ring</code> in the definition of <code>normed_space</code> and added an <code>is_field Œ±</code> hypothesis to <code>norm_smul</code>. <br>\nWith the field instance, Lean doesn't complain anymore about a missing <code>has_inv</code>, but the <code>inv_smul_smul‚ÇÄ</code> and <code>norm_inv</code> in the proof fail (probably because of what you said about defeqs).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed.normed_field</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œ≥</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œπ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">prio</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">extends_priority</span> <span class=\"mi\">920</span>\n<span class=\"kd\">class</span> <span class=\"n\">normed_space</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ≤</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semi_normed_group</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">module</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">norm_smul_le</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">Œ≤</span><span class=\"o\">),</span> <span class=\"bp\">‚à•</span><span class=\"n\">a</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">b</span><span class=\"bp\">‚à•</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">‚à•</span><span class=\"n\">a</span><span class=\"bp\">‚à•</span> <span class=\"bp\">*</span> <span class=\"bp\">‚à•</span><span class=\"n\">b</span><span class=\"bp\">‚à•</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span> <span class=\"n\">prio</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semi_normed_group</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.all</span> <span class=\"n\">true</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">norm_smul</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"n\">Œ±</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hŒ±</span> <span class=\"o\">:</span> <span class=\"n\">is_field</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">‚à•</span><span class=\"n\">s</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">x</span><span class=\"bp\">‚à•</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à•</span><span class=\"n\">s</span><span class=\"bp\">‚à•</span> <span class=\"bp\">*</span> <span class=\"bp\">‚à•</span><span class=\"n\">x</span><span class=\"bp\">‚à•</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"n\">hŒ±.to_field</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">normed_space.norm_smul_le</span> <span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n     <span class=\"k\">calc</span> <span class=\"bp\">‚à•</span><span class=\"n\">s</span><span class=\"bp\">‚à•</span> <span class=\"bp\">*</span> <span class=\"bp\">‚à•</span><span class=\"n\">x</span><span class=\"bp\">‚à•</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à•</span><span class=\"n\">s</span><span class=\"bp\">‚à•</span> <span class=\"bp\">*</span> <span class=\"bp\">‚à•</span><span class=\"n\">s</span><span class=\"bp\">‚Åª¬π</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">s</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">x</span><span class=\"bp\">‚à•</span>     <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inv_smul_smul‚ÇÄ</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n               <span class=\"bp\">...</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">‚à•</span><span class=\"n\">s</span><span class=\"bp\">‚à•</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">‚à•</span><span class=\"n\">s</span><span class=\"bp\">‚Åª¬π‚à•</span> <span class=\"bp\">*</span> <span class=\"bp\">‚à•</span><span class=\"n\">s</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">x</span><span class=\"bp\">‚à•</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"n\">mul_le_mul_of_nonneg_left</span> <span class=\"o\">(</span><span class=\"n\">normed_space.norm_smul_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">norm_nonneg</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n               <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à•</span><span class=\"n\">s</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">x</span><span class=\"bp\">‚à•</span>                 <span class=\"o\">:</span>\n      <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">norm_inv</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_inv_cancel</span> <span class=\"o\">(</span><span class=\"n\">mt</span> <span class=\"n\">norm_eq_zero.1</span> <span class=\"n\">h</span><span class=\"o\">),</span> <span class=\"n\">one_mul</span><span class=\"o\">]</span> <span class=\"o\">}</span>  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 278289215,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649416606
    },
    {
        "content": "<p>That ought to work with <code>letI</code> instead of <code>haveI</code></p>",
        "id": 278289464,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649416765
    },
    {
        "content": "<p>But I'm not convinced that building API around <code>is_field</code> is the right way to go</p>",
        "id": 278289509,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649416798
    },
    {
        "content": "<p>The last line still fails if I switch to <code>letI</code>.</p>",
        "id": 278289785,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649416946
    },
    {
        "content": "<p>Why would you not turn <code>[normed_ring Œ±] (hŒ± : is_field Œ±)</code> into <code>[normed_field Œ±]</code> (assuming the correct definition)?</p>",
        "id": 278289854,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649417002
    },
    {
        "content": "<p>Do you mean the <code>&lt;=</code> definition? I would prefer to do that.</p>",
        "id": 278290091,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649417129
    },
    {
        "content": "<p>I was trying the <code>is_field</code> approach because it was suggested above (and would avoid creating this new <code>normed_field'</code> class).</p>",
        "id": 278290217,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649417180
    },
    {
        "content": "<p>Creating <code>normed_field'</code> definitely sounds like the right idea.</p>",
        "id": 278290252,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649417201
    },
    {
        "content": "<p>(modulo naming choices)</p>",
        "id": 278290298,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649417238
    },
    {
        "content": "<p>Do people have opinions about the name of this class / potentially renaming <code>normed_field</code>?</p>",
        "id": 278290314,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649417252
    },
    {
        "content": "<p>The alternative would be to replace <code>normed_field K</code> with <code>[field K] [has_multiplicative_norm K]</code> and have <code>[field K] [has_submultiplicative_norm K]</code> for the &lt;= case</p>",
        "id": 278290433,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649417312
    },
    {
        "content": "<p>I'm happy to see <code>normed_field</code> renamed to <code>valued_field</code>, but then we should probably rename <code>normed_division_ring</code> to <code>valued_ring</code> (or <code>valued_division_ring</code>?) as well.</p>",
        "id": 278290434,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649417313
    },
    {
        "content": "<p>The natural choices would be <code>normed_field</code> for the <code>&lt;=</code> definition and <code>valued_field</code> for the existing <code>=</code> one, <del>but <a href=\"https://leanprover-community.github.io/mathlib_docs/find/valued_field\">docs#valued_field</a> exists already</del>.</p>",
        "id": 278290445,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649417321
    },
    {
        "content": "<p>Does it?</p>",
        "id": 278290470,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649417335
    },
    {
        "content": "<p>Oh, maybe it doesn't!</p>",
        "id": 278290522,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649417375
    },
    {
        "content": "<p>I think I got confused because there's a <code>valued_field</code> file (<code>topology.algebra.valued_field</code>).</p>",
        "id": 278290547,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649417393
    },
    {
        "content": "<p>I'm happy with using <code>normed_field</code> and <code>valued_field</code> then (and <code>valued_division_ring</code>).</p>",
        "id": 278290701,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649417473
    },
    {
        "content": "<p>Watch out for name conflicts indeed because we have weird instance names in the file you mentioned. Eg <a href=\"https://leanprover-community.github.io/mathlib_docs/find/valued_ring.separated\">docs#valued_ring.separated</a></p>",
        "id": 278291017,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649417671
    },
    {
        "content": "<p>Maybe it would make sense to rename that instance? I don't see <code>valued_ring</code> used in any other name.</p>",
        "id": 278291341,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649417870
    },
    {
        "content": "<p>I've renamed <code>normed_field</code> to <code>valued_field</code> and <code>normed_division_ring</code> to <code>valued_division_ring</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13239\">#13239</a>. I also renamed <code>valued_ring.separated</code> to <code>valued.separated</code>.</p>",
        "id": 278318652,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649430846
    },
    {
        "content": "<p>Doesn't <a href=\"https://github.com/leanprover-community/mathlib/pull/13239\">#13239</a> make the naming really inconsistent? Some things are called <code>normed_foo</code> (groups, spaces) and some are called <code>valued_foo</code> (rings, fields), even though both version just extend <code>has_norm</code> and some algebraic structure</p>",
        "id": 278347296,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1649444133
    },
    {
        "content": "<p>The new naming convention will  be <code>normed_</code> to mean <code>‚à•a * b‚à• ‚â§ ‚à•a‚à• * ‚à•b‚à•</code> and <code>valued_</code> for <code>‚à•a * b‚à• = ‚à•a‚à• * ‚à•b‚à•</code>.</p>",
        "id": 278348437,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649444610
    },
    {
        "content": "<p>I assume the idea is to add classes with the old names in a subsequent PR</p>",
        "id": 278354106,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649447502
    },
    {
        "content": "<p>Yes, exactly, I plan to add <code>normed_division_ring</code> and <code>normed_field</code> in a future PR.</p>",
        "id": 278417487,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649521020
    },
    {
        "content": "<p>Can you add something to the PR description explaining that the motivation for the rename is to free up names for those ideas?</p>",
        "id": 278418652,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649522519
    },
    {
        "content": "<p>A PR touching 98 files needs a good description! I assume it was just a find and replace? It's usually a good idea to either state explicitly that's all you did, or point out which parts you had to change by hand</p>",
        "id": 278418767,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649522659
    },
    {
        "content": "<p>Yes, it was just find and replace. I'll add a description.</p>",
        "id": 278419918,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649524044
    },
    {
        "content": "<p>Just to be clear, we're not planning to rename the current <code>normed_space</code> to <code>valued_space</code> because of this, are we?</p>",
        "id": 278422915,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649527708
    },
    {
        "content": "<p>I have to say that I disagree with the name <code>valued_field</code> for a field endowed with a multiplicative norm. In my experience, the term <code>valued_field</code> refers to a field endowed with a valuation, and while rank one valuations do indeed give rise to such norms, there are higher rank valuations as well. I would suggest <code>submultiplicative_normed_field</code> for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>‚â§</mo></mrow><annotation encoding=\"application/x-tex\">\\le</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">‚â§</span></span></span></span> version and <code>normed_field</code> (or <code>multiplicative_normed_field</code>) for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">=</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span></span></span></span> version.</p>",
        "id": 278424850,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649530387
    },
    {
        "content": "<p>Now I know somewhat might refer to the nlab page <a href=\"https://ncatlab.org/nlab/show/normed+field\">https://ncatlab.org/nlab/show/normed+field</a> where <code>valued_field</code> is mentioned to be defined by Berkovich, but we should keep in mind that Berkovich's notes only consider rank one valuations (he calls them real valuations) because indeed Berkovich spaces are built out of rank one valuations. The approach of Huber, which is now probably more common, uses higher rank valuations as well.</p>",
        "id": 278424945,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649530558
    },
    {
        "content": "<p>Actually, looking at this wiki page, <a href=\"https://en.wikipedia.org/wiki/Berkovich_space\">https://en.wikipedia.org/wiki/Berkovich_space</a> , I think the names <code>seminormed_field</code> and <code>normed_field</code> could be appropriate.</p>",
        "id": 278425223,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649530854
    },
    {
        "content": "<p>Does the token <code>semi</code> in that suggestion align with its meaning in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/semi_normed_ring\">docs#semi_normed_ring</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_ring\">docs#normed_ring</a>?</p>",
        "id": 278425312,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649530975
    },
    {
        "content": "<p>(or phrased differently, which of these two classes should <code>semi_normed_field</code> extend?)</p>",
        "id": 278425414,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649531098
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> , it's true that this only refers to valuations in the sense of Berkovich or Bosch-Guntzer-Remmert, but I don't think we can use <code>seminormed_field</code> and <code>normed_field</code> (following their notation, a norm is a seminorm in which norm x = 0 implies x = 0). That's the current mathlib convention too.</p>",
        "id": 278425597,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649531392
    },
    {
        "content": "<p>I would definitely keep <code>normed_field</code> for the <code>‚à•a * b‚à• ‚â§ ‚à•a‚à• * ‚à•b‚à•</code> case, but I would be open to renaming <code>valued_field</code> to something else.</p>",
        "id": 278425691,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649531517
    },
    {
        "content": "<p>Maybe <code>rank_one_valued_field</code>?</p>",
        "id": 278425998,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649531899
    },
    {
        "content": "<p>What about <code>submultiplicative_seminormed_ring</code>, <code>multiplicative_seminormed_ring</code> and <code>normed_ring</code> as a mixin, which could then be applied to any (commutative?) ring? I guess my main point is that I think word <code>valued</code> should be reserved for valuations, whereas the word <code>(semi)normed</code> should be reserved for (semi)norms.</p>",
        "id": 278426139,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649532113
    },
    {
        "content": "<p>To avoid confusion with semi, a shorter spelling of <code>submultiplicative</code> could be <code>le</code>, as in <code>le_seminormed_ring</code>.</p>",
        "id": 278426890,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1649533176
    },
    {
        "content": "<p>If the main goal is to avoid <code>valued_field</code>/<code>valued_ring</code> (which I agree could create confusion with general valuations), maybe we could just name these <code>multiplicative_normed_field</code>/<code>multiplicative_normed_ring</code> and keep using <code>(semi)normed</code> for the sub-multiplicative classes.</p>",
        "id": 278427494,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649533998
    },
    {
        "content": "<p>Maybe I read too quickly, but I think using semi with a different meaning for fields and vector spaces would be really bad. Also note that for analysis the correct class is <code>nondiscrete_normed_field</code> anyway.</p>",
        "id": 278428717,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1649535782
    },
    {
        "content": "<p><code>real_valued_field</code>?</p>",
        "id": 278432455,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649540524
    },
    {
        "content": "<p>Personally, I would prefer to keep <code>normed_field</code> as is, and provide a new class <code>submultiplicative_normed_field</code> (or a different name) for the other version. Mathlib's current naming agrees with the literature in at least one place: <em><a href=\"https://books.google.com/books?id=7WUkDwAAQBAJ&amp;pg=PA2#v=onepage&amp;q&amp;f=false\">Topological Vectors Spaces and Their Applications</a></em>.</p>",
        "id": 278444137,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649558986
    },
    {
        "content": "<p>Note that we do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/semi_normed_ring\">docs#semi_normed_ring</a> .</p>",
        "id": 278446150,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649562583
    },
    {
        "content": "<p>Anyway, personally I would be happy with whatever names are chosen for a (sub)multiplicative (semi)normed fields, as long as the name in mathlib isn't of the form <code>*valued*</code>.</p>",
        "id": 278446399,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649563012
    },
    {
        "content": "<p>Yes, I know, but I don't think it matters. For fields (or division rings), the natural condition is multiplicativity, not submultiplicativity. An intuitive explanation for this is: these objects have <code>inv</code> and the multiplicativity condition is equivalent to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/norm_inv\">docs#norm_inv</a>, so the norm and the inverse play nice. Do we even have a natural example of a (submultiplicatively) normed division ring for which the norm is <em>not</em> multiplicative? I saw Kevin's example above, but it seemed contrived (although I am not qualified to judge such things).</p>",
        "id": 278446402,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649563025
    },
    {
        "content": "<p>My \"min of two valuations\" example was indeed contrived; I don't know if it comes up in practice. I don't remember seeing anything like that in Bosch-Guentzer-Remmert (which I've always taken as the canonical reference in the non Archimedean case).</p>",
        "id": 278450634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649570651
    },
    {
        "content": "<p>What about keeping <code>normed_field</code> (which is the most frequent situation, so it should have the shortest name), and adding something like <code>le_normed_field</code> or <code>le_mul_normed_field</code> or <code>submul_normed_field</code> (avoiding the word <code>semi</code> since in mathlib it is associated to norms that can vanish on nonzero elements)?</p>",
        "id": 278451041,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1649571391
    },
    {
        "content": "<p>(and adding docstrings explaining all this, of course!)</p>",
        "id": 278451055,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1649571458
    },
    {
        "content": "<p>I'm in favor of that as long as we can come up with at least <em>one</em> \"naturally occurring\" example of such a thing. Otherwise, why would we bother to create this new type class? <span class=\"user-mention\" data-user-id=\"406490\">@Mar√≠a In√©s de Frutos Fern√°ndez</span> , do you have such an example from your work?</p>",
        "id": 278451245,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649571769
    },
    {
        "content": "<p><code>le_normed_field</code> or <code>le_mul_normed_field</code> are bad because they sound like lemma names.</p>",
        "id": 278454285,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1649576866
    },
    {
        "content": "<p>Sebastien's remaining suggestion, <code>submul_normed_field</code> sounds pretty good to my ear. I think people will naturally read <code>submul</code> as \"sub-multiplicative\", and \"sub-multiplicative normed field\" is an easy-to-interpret-correctly name.</p>",
        "id": 278454497,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1649577175
    },
    {
        "content": "<p>I agree with <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> though that we should have some motivating examples of things that satisfy only that typeclass before adding it</p>",
        "id": 278454583,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649577291
    },
    {
        "content": "<p>For the application I have in mind, I actually care about multiplicatively normed fields. I want to prove that if a field K is complete with respect to a rank 1 valuation, and L/K is an algebraic extension, then there's a  unique rank 1 valuation on L extending the valuation on K (so in particular, I can extend the p-adic absolute value on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"true\">‚Äæ</mo></mover><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathbb{Q}}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2414em;vertical-align:-0.3525em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8889em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span><span style=\"top:-3.8089em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1667em;\"><span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.085em;\"><span style=\"top:-2.4836em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3525em;\"><span></span></span></span></span></span></span></span></span></span>, and then define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">C</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> as the completion of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"true\">‚Äæ</mo></mover><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathbb{Q}}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2414em;vertical-align:-0.3525em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8889em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span><span style=\"top:-3.8089em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1667em;\"><span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.085em;\"><span style=\"top:-2.4836em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3525em;\"><span></span></span></span></span></span></span></span></span></span>). The reason I wanted to add this <code>submul_normed_field</code> class is that I am following the proof in Bosch-Guentzer-Remmert, and a couple of the results used in the argument are proven for fields with a norm that's only assumed to be power-multiplicative. However, since it seems that no one is planning to use sub-multiplicatively normed fields, I will just formalize those results assuming the existing <code>normed_field</code>.</p>",
        "id": 278537564,
        "sender_full_name": "Mar√≠a In√©s de Frutos Fern√°ndez",
        "timestamp": 1649675342
    },
    {
        "content": "<p>I was directed to this thread after posting the following message. <a href=\"#narrow/stream/116395-maths/topic/Discrete.20metric.2E/near/281125426\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Discrete.20metric.2E/near/281125426</a></p>",
        "id": 281139153,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651662183
    },
    {
        "content": "<p>At best I'm basically struggling to understand a lot of things about the hierarchy here. At least the names (as I think the above discussion might reflect) seem confusing. But in general I feel quite suspicious of the way the whole thing currently works. I was wondering where things are at in general with this.</p>",
        "id": 281139529,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651662461
    },
    {
        "content": "<p>I'm of the opinion that a switch from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- current</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"c1\">-- ring</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>  <span class=\"c1\">-- module</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"c1\">-- algebra</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- proposed</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>might be reasonable, as it gives us the flexibility to mix and match tight vs loose bounds on the multiplication of the norm, and matches how we currently spell</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- current, topology</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_add_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_continuous_const_smul</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_continuous_const_smul</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Obviously it's much more verbose, but we already pay that cost in the topology library.</p>\n<p>This would also free us from having separate <code>normed_ring</code> and <code>normed_comm_ring</code> typeclasses, as well as unifying <code>normed_space</code> and <code>normed_algebra</code>.</p>",
        "id": 281140152,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651662900
    },
    {
        "content": "<p>Hang on, I'm not sure <code>variables [normed_ring R] [normed_group M] [normed_space R M]</code> currently works.</p>",
        "id": 281146266,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651666699
    },
    {
        "content": "<p><code>normed_space</code> is defined only for <code>normed_field</code>.</p>",
        "id": 281146285,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651666714
    },
    {
        "content": "<p>Whoops, fixed</p>",
        "id": 281147401,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651667370
    },
    {
        "content": "<p>I think this is closer to what you want, but variables [ring R] [non_unital_semi_normed_ring R] might be better, as it were. Actually what you want really is an equivalent of <code>[has_continuous_const_smul R]</code> for here.</p>\n<p>Could you define <code>[has_semimultiplicative_norm R]</code>, which requires only <code>[has_norm R]</code>, and is basically a wrapper around <code>‚àÄ (a b : Œ±), ‚à•a * b‚à• ‚â§ ‚à•a‚à• * ‚à•b‚à•</code>? And then also <code>[has_multiplicative_norm R]</code>. How you handle <code>normed_group R</code> I'm less sure of - what about a wrapper <code>[has_dist_eq_norm_sub R]</code> which depends only on <code>[has_sub R]</code>, <code>[has_dist R]</code>, and <code>[has_norm R]</code>, and then wraps around <code>dist x y = ‚à•x - y‚à•</code>? That does miss out the metric space aspect and the differentiation between pseudometric and metrics (also, not sure it should be semi_normed_group - surely pseudo_normed_group?)</p>\n<p>We don't seem to have an extension of <code>[has_norm R] [has_zero R] [has_neg R] [has_add R]</code> that is basically \"‚à•0‚à• = 0\", \"‚à•-a‚à• = ‚à•a‚à•\", \"‚à•a + b‚à• ‚â§ ‚à•a‚à• + ‚à•b‚à•\". It feels like we probably should? Because such a class - call it [norm_pseudogood R] - would then mean that<br>\n<code>[add_comm_group R] [has_norm R]  [has_dist R] [norm_pseudogood R] [has_dist_eq_norm_sub R]</code> is exactly our current `[sub_normed_group R]\".</p>",
        "id": 281147745,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651667562
    },
    {
        "content": "<p>Also, does the notion of a <code>normed_module</code> not make sense? I liked what you first had - we just can't currently do it!</p>",
        "id": 281147828,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651667618
    },
    {
        "content": "<blockquote>\n<p>Could you define <code>[has_semimultiplicative_norm R]</code> &lt;snip&gt;</p>\n</blockquote>\n<p><del>That is precisely the meaning that <code>normed_ring</code> has in my <code>-- proposed</code> example above</del></p>",
        "id": 281147850,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651667632
    },
    {
        "content": "<p>It's confusingly named, then - if you look at <code>has_continuous_const_smul</code>, what's nice about that is that it's only asserting a property of - oh you crossed it out.</p>",
        "id": 281147982,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651667695
    },
    {
        "content": "<p>To pick up <code>norm_pseudogood</code> - it is kinda weird that we don't currently have something like this, an ability to say \"this norm basically does all the things you want it to do to make a pseudometric out of it\". (Obviously a norm has ‚à•a‚à• = 0 -&gt; a = 0 also.)</p>",
        "id": 281148166,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651667805
    },
    {
        "content": "<p>Sorry, what I'm proposing is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- `add_comm_group ` moved from `extends` to an argument</span>\n<span class=\"kd\">class</span> <span class=\"n\">normed_group</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">A</span><span class=\"o\">]</span>  <span class=\"kd\">extends</span> <span class=\"n\">has_norm</span> <span class=\"n\">E</span><span class=\"o\">,</span> <span class=\"n\">metric_space</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">dist_eq</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- this also works for `comm_ring` and everything inbetween</span>\n<span class=\"kd\">class</span> <span class=\"n\">normed_ring</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">non_unital_semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">normed_group</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">norm_mul_le</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- could relax the `division_ring` requirement, but that probably doesn't buy anything</span>\n<span class=\"kd\">class</span> <span class=\"n\">normed_field</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">division_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">normed_ring</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">norm_mul_eq</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- doesn't extend `module` any more, and may as well relax to `has_scalar` to make typeclass search easier</span>\n<span class=\"kd\">class</span> <span class=\"n\">normed_space</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_norm</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_norm</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">norm_smul_le</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 281148232,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651667839
    },
    {
        "content": "<p>Right :) What I'm saying is that that the approach of topology - which is to separate out the properties of the operations from the structure - seems good.</p>",
        "id": 281148285,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651667877
    },
    {
        "content": "<p>I like your <code>normed_space</code> there - it doesn't extend! But if you think about it, kinda odd that it's then called <code>normed_space</code>. And that isn't the approach your other examples give - because they extend the structure.</p>",
        "id": 281148419,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651667933
    },
    {
        "content": "<p>Right, you're arguing that you want to go one stage further and break <code>normed_group</code> into smaller pieces than I have there?</p>",
        "id": 281148421,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651667934
    },
    {
        "content": "<p>Yes.</p>",
        "id": 281148430,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651667939
    },
    {
        "content": "<blockquote>\n<p>And that isn't the approach your other examples give - because they extend the structure.</p>\n</blockquote>\n<p>What do you mean by that?</p>",
        "id": 281148471,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651667961
    },
    {
        "content": "<p>I'd like to explain why I think it is important to keep <code>normed_field k</code> instead of a bunch of mixins. The problem with mixins is that they lead to combinatorial explosion when new spaces are built out of them, and then new spaces are built out of these new spaces. So in this kind of situation it is better performancewise to have a single typeclass to use that subsumes everything. And it turns out that many many things are built using normed fields (spaces of continuous linear maps, of analytic maps, of continuous multilinear maps, manifolds, and so on).</p>",
        "id": 281148597,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651668003
    },
    {
        "content": "<p>Oh, no, maybe it is the same, I forgot how extending works.</p>",
        "id": 281148603,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651668005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281148597\">said</a>:</p>\n<blockquote>\n<p>I'd like to explain why I think it is important to keep <code>normed_field k</code> instead of a bunch of mixins. The problem with mixins is that they lead to combinatorial explosion when new spaces are built out of them, and then new spaces are built out of these new spaces. So in this kind of situation it is better performancewise to have a single typeclass to use that subsumes everything. And it turns out that many many things are built using normed fields (spaces of continuous linear maps, of analytic maps, of continuous multilinear maps, manifolds, and so on).</p>\n</blockquote>\n<p>Once you have the mixins, can you not define <code>normed_field</code> as a specific thing?</p>",
        "id": 281148663,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651668046
    },
    {
        "content": "<p>In the way that, say, <code>linear_ordered_add_comm_monoid</code> is really a specific manifestation of a pile of structure.</p>",
        "id": 281148738,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651668095
    },
    {
        "content": "<p>Precisely, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_ordered_add_comm_monoid\">docs#linear_ordered_add_comm_monoid</a> does not use mixins, it <em>extends</em> a lot of structures.</p>",
        "id": 281148897,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651668161
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> the thing about <code>normed_ring</code> extending <code>normed_group</code> is: what if I have a norm on a ring that is submultiplicative on the multplication, but doesn't interact with the addition at all?</p>",
        "id": 281148899,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651668163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281148899\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> the thing about <code>normed_ring</code> extending <code>normed_group</code> is: what if I have a norm on a ring that is submultiplicative on the multplication, but doesn't interact with the addition at all?</p>\n</blockquote>\n<p>That doesn't strike me as all that useful - but you could always add a <code>normed_monoid</code> in between</p>",
        "id": 281148977,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651668197
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281148897\">said</a>:</p>\n<blockquote>\n<p>Precisely, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_ordered_add_comm_monoid\">docs#linear_ordered_add_comm_monoid</a> does not use mixins, it <em>extends</em> a lot of structures.</p>\n</blockquote>\n<p>Right - I think you make a strong argument for having, ultimately, normed_field` present at the top of the hierarchy.</p>",
        "id": 281148995,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651668208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281148897\">said</a>:</p>\n<blockquote>\n<p>Precisely, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_ordered_add_comm_monoid\">docs#linear_ordered_add_comm_monoid</a> does not use mixins, it <em>extends</em> a lot of structures.</p>\n</blockquote>\n<p>So would you argue that the topology library should switch to this model?</p>",
        "id": 281149138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651668273
    },
    {
        "content": "<p>Note, we're already running into some issues with timeouts in this normed hierarchy. See the end of this thread: <a href=\"#narrow/stream/144837-PR-reviews/topic/.2313719.3A.20non-unital.20normed.20comm.20ring\">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.2313719.3A.20non-unital.20normed.20comm.20ring</a></p>",
        "id": 281149203,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651668305
    },
    {
        "content": "<p>Can you show us a real-world example where you feel our current hierarchy has shortcomings? In a way, our hierarchy is designed to be able to deal with most interesting examples, but if there is a natural situation where it fails it is an interesting datapoint.</p>",
        "id": 281149218,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651668316
    },
    {
        "content": "<p>I suppose I'll re-bring-up the context I was working in from the other thread (where it felt troublesome in part). So I was doing this yesterday (I am trying to formalise some code-based cryptography theorems about a design). <a href=\"https://gist.github.com/linesthatinterlace/25eb6d69d1264fecca89f904d18b4eff\">https://gist.github.com/linesthatinterlace/25eb6d69d1264fecca89f904d18b4eff</a></p>",
        "id": 281149413,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651668418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281149138\">said</a>:</p>\n<blockquote>\n<p>So would you argue that the topology library should switch to this model?</p>\n</blockquote>\n<p>No, mixins are fine to specify additional properties of structures that don't show up too much. But the main players in the hierarchy should really be single typeclasses, not one typeclasses with several mixins.</p>",
        "id": 281149415,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651668419
    },
    {
        "content": "<p>I know we already have the L_0 \"norm\", of a kind, but it isn't actually a norm - except it is if the underlying field has the discrete norm!</p>",
        "id": 281149509,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651668460
    },
    {
        "content": "<blockquote>\n<p>And it turns out that many many things are built using normed fields (spaces of continuous linear maps, of analytic maps, of continuous multilinear maps, manifolds, and so on).</p>\n</blockquote>\n<p>As part of my refactoring of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/exp\">docs#exp</a>, I've found that many things defined in terms of <code>normed_field</code> etc actually generalize just fine to topological rings; so in these cases <code>norm</code> was never a main player after all</p>",
        "id": 281149578,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651668483
    },
    {
        "content": "<p>(well, it's a seminorm)</p>",
        "id": 281149585,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651668485
    },
    {
        "content": "<blockquote>\n<p>I know we already have the L_0 \"norm\", of a kind</p>\n</blockquote>\n<p>Do we? <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi_Lp.normed_space\">docs#pi_Lp.normed_space</a> requires p to be <del>positive</del> at least 1</p>",
        "id": 281149621,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651668517
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/measure_theory/function/lp_space.html\">https://leanprover-community.github.io/mathlib_docs/measure_theory/function/lp_space.html</a></p>",
        "id": 281149690,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651668566
    },
    {
        "content": "<p>albeit that is different, but it's clearly tightly related (though I have no idea if there is linking API).</p>",
        "id": 281149796,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651668612
    },
    {
        "content": "<p>I don't see the problem with the Hamming distance: you can locally register a normed group instance with the discrete distance on a finite group, and then take its <code>pi_Lp 1</code>, no? (There's no field involved here).</p>",
        "id": 281150038,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651668734
    },
    {
        "content": "<p>Wrenna, that just gives a garbage value (0) when p=0</p>",
        "id": 281150105,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651668770
    },
    {
        "content": "<p>But you really want to use the <code>L^1</code> distance for the Hamming distance.</p>",
        "id": 281150169,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651668815
    },
    {
        "content": "<p>I'm not even sure what you mean by L^0 norm Wrenna.</p>",
        "id": 281150348,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651668892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281149578\">said</a>:</p>\n<blockquote>\n<p>As part of my refactoring of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/exp\">docs#exp</a>, I've found that many things defined in terms of <code>normed_field</code> etc actually generalize just fine to topological rings; so in these cases <code>norm</code> was never a main player after all</p>\n</blockquote>\n<p>If you want to do analysis (use derivatives, for instance), you can't do without the normed field structure.</p>",
        "id": 281150381,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651668911
    },
    {
        "content": "<p>Regarding shortcomings in the current structure, it would be nice if lemmas like the following would be possible to state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- not allowed, ‚Ñï isn't a field</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"n\">‚Ñï</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">‚à•</span><span class=\"n\">n</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">x</span><span class=\"bp\">‚à•</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">‚à•</span><span class=\"n\">n</span><span class=\"bp\">‚à•</span> <span class=\"bp\">*</span> <span class=\"bp\">‚à•</span><span class=\"n\">x</span><span class=\"bp\">‚à•</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- not allowed, `units R` isn't a field</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">normed_space</span> <span class=\"o\">(</span><span class=\"n\">units</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I guess this is only a complaint about <code>normed_space</code> not the rest of the heirarchy</p>",
        "id": 281150626,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651669049
    },
    {
        "content": "<p>Having <code>normed_space</code> only requiring a <code>normed_semiring</code> instead of a <code>normed_field</code> would definitely make sense to me.</p>",
        "id": 281150809,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651669122
    },
    {
        "content": "<p>I'm suggesting the stronger change of not even making it extend module, so that it can be used for norm-preserving group actions too (my second example)</p>",
        "id": 281150865,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651669150
    },
    {
        "content": "<p>I guess R is supposed to be a ring in that second example?</p>",
        "id": 281151189,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651669263
    },
    {
        "content": "<p>I guess that would also mean changing the definition slightly, so that its norm_smul and not norm_smul_le, right?</p>",
        "id": 281151666,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651669448
    },
    {
        "content": "<p>Yeah, there's really no reason for <code>normed_space</code> to require <code>normed_field</code>. I found myself assuming <code>normed_field</code> in a bunch of place just because <code>normed_space</code> required me to.</p>",
        "id": 281151690,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1651669460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281150865\">said</a>:</p>\n<blockquote>\n<p>I'm suggesting the stronger change of not even making it extend module, so that it can be used for norm-preserving group actions too (my second example)</p>\n</blockquote>\n<p>I agree with this, and I suppose the rest of my complaint is a feeling that we should try to cut down the hierarchy if we can. Also \"semi_normed\" stuff is ill-named.</p>",
        "id": 281151752,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651669496
    },
    {
        "content": "<p>Also - surely <code>normed_group</code> should be described so that it extends <code>metric_space</code> and <code>semi_normed_group</code> (which should be <code>pseudo_normed_group</code>.</p>",
        "id": 281151928,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651669572
    },
    {
        "content": "<p>Disagreed about the \"semi_normed\". This is common terminology. Although I've seen pseudo-normed too. In LCTVS theory I think seminorm is more common.</p>",
        "id": 281151955,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651669590
    },
    {
        "content": "<p>Isn't seminorm normally about the multiplicativity/submultiplicativity stuff?</p>",
        "id": 281152002,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651669618
    },
    {
        "content": "<p>No? Reference?</p>",
        "id": 281152052,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651669643
    },
    {
        "content": "<p>Oh, no, I'm probably just wrong. I thought someone said it above.</p>",
        "id": 281152094,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651669659
    },
    {
        "content": "<p>The issue I see is that it is easily confused with <code>semiring</code>, which is a different type of <code>semi</code> (I think?).</p>",
        "id": 281152223,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651669703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281151928\">said</a>:</p>\n<blockquote>\n<p>Also - surely <code>normed_group</code> should be described so that it extends <code>metric_space</code> and <code>semi_normed_group</code> (which should be <code>pseudo_normed_group</code>.</p>\n</blockquote>\n<p>Essentially, it does, in the sense that a <code>normed_group</code> is automatically a <code>metric_space</code> and a <code>semi_normed_group</code>. Whether this is part of the definition or an instance which is registered later on is just a technical detail of the implementation (made in view of performance constraints), but has no practical importance for the end user.</p>",
        "id": 281152323,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651669753
    },
    {
        "content": "<p>Yeah, <code>semi_normed_whatever</code> comes from <code>seminorm</code>. I believe we could get rid of the underscore to make the connection more obvious.</p>",
        "id": 281152406,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1651669798
    },
    {
        "content": "<p>Well, I found it mildly confusing, as an end user - but I take your point.</p>",
        "id": 281152459,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651669809
    },
    {
        "content": "<p>Maybe even <code>seminorm_group</code> could be acceptable, and it would save us three keystrokes.</p>",
        "id": 281152528,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1651669844
    },
    {
        "content": "<p>If you redefined normed_space to only need a normed_semiring, would you still keep the submultiplicative property for the latter? Does it all work OK if you do that?</p>",
        "id": 281152584,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651669867
    },
    {
        "content": "<p>technically of course it should be <code>seminorm_add_group</code>.</p>",
        "id": 281152742,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651669942
    },
    {
        "content": "<p>Are seminormed multiplicative groups a thing?</p>",
        "id": 281152823,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1651669993
    },
    {
        "content": "<p>but what about <code>seminorm_add_semigroup</code>? What, indeed, of <code>semisubmultivativenormed_semiring</code></p>",
        "id": 281152827,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651669996
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281152823\">said</a>:</p>\n<blockquote>\n<p>Are seminormed multiplicative groups a thing?</p>\n</blockquote>\n<p>In fairness I don't... <em>think</em> so - but I could believe in them.</p>",
        "id": 281152881,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651670035
    },
    {
        "content": "<p>Any generalization of normed_space will require changing norm_smul_le to norm_smul.</p>",
        "id": 281153159,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651670155
    },
    {
        "content": "<p>Right. Which suggests we do want to keep track of the submultiplicative distinction...</p>",
        "id": 281153311,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651670210
    },
    {
        "content": "<p>I think you are conflating mul and smul.</p>",
        "id": 281153418,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651670262
    },
    {
        "content": "<p>Nothing has ever been submultiplicative though. <code>normed_space</code> is currently submultiplicative but that's because we can directly recover multiplicativity from <code>field</code>.</p>",
        "id": 281153424,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1651670266
    },
    {
        "content": "<p>Isn't <code>normed_ring</code> submultiplicative?</p>",
        "id": 281153450,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651670280
    },
    {
        "content": "<p>Yes, but that's mul, not smul</p>",
        "id": 281153547,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651670312
    },
    {
        "content": "<p>I still am not <em>really</em> sure about the bundling of <code>metric_space</code> into the definition of <code>normed_group</code>. Intuitively I would think of a <code>normed_group</code> as a group with a norm added (on which, yes, a metric is induced - I guess the current definition is to ensure you don't have another dist hanging round).</p>",
        "id": 281153574,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651670325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281153547\">said</a>:</p>\n<blockquote>\n<p>Yes, but that's mul, not smul</p>\n</blockquote>\n<p>Oh - I see, right. Why will that need changing?</p>",
        "id": 281153638,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651670364
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_space\">docs#normed_space</a></p>",
        "id": 281153688,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651670387
    },
    {
        "content": "<p>It has an le right now, but that's because we can prove equality since we have a field. If we don't have a field (or division ring) we can't prove equality, so we need to assume it.</p>",
        "id": 281153848,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651670448
    },
    {
        "content": "<p>And you need to keep the equality - it's not otherwise a useful notion?</p>",
        "id": 281153898,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651670470
    },
    {
        "content": "<p>Right. And if you didn't, then you would need yet another type class where you have equality.</p>",
        "id": 281154015,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651670523
    },
    {
        "content": "<p>What did you think to the hamming distance thing I posted above?</p>",
        "id": 281154114,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651670571
    },
    {
        "content": "<p>I'm not quite convinced of that--do you really need a type class for when you have equality? Seems like that usually only happen over a normed field, in which case you can use a lemma</p>",
        "id": 281154140,
        "sender_full_name": "Reid Barton",
        "timestamp": 1651670589
    },
    {
        "content": "<p>Is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> a \"normed module\" over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>M</mi><mrow><mi>n</mi><mo>√ó</mo><mi>n</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">M_{n \\times n}(\\mathbb{R})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">√ó</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">R</span><span class=\"mclose\">)</span></span></span></span> (with the operator norm)?</p>",
        "id": 281154214,
        "sender_full_name": "Reid Barton",
        "timestamp": 1651670636
    },
    {
        "content": "<p>Hmm, Reid I think you're right. I retract my claim.</p>",
        "id": 281154345,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651670695
    },
    {
        "content": "<p>Remember we only recently removed the equality requirement induced by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_algebra\">docs#normed_algebra</a></p>",
        "id": 281154552,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651670787
    },
    {
        "content": "<p>Wrenna, can you link the hamming distance thing (I'm on mobile)</p>",
        "id": 281154615,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1651670818
    },
    {
        "content": "<p><a href=\"https://gist.github.com/linesthatinterlace/25eb6d69d1264fecca89f904d18b4eff\">https://gist.github.com/linesthatinterlace/25eb6d69d1264fecca89f904d18b4eff</a></p>",
        "id": 281154678,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651670852
    },
    {
        "content": "<p>(It would be cool to link this into <code>computability.language</code> somewhat though as I think it's only defined for fixed sizes anyway I'm not sure that's necessary, and I wanted the module structure.)</p>",
        "id": 281154881,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651670930
    },
    {
        "content": "<p>As I said above, I think it's just the <code>L^1</code> distance on the product for the discrete distance on the factor, so we have already all the needed bits in mathlib (with the current hierarchy).</p>",
        "id": 281154894,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651670938
    },
    {
        "content": "<p>Yes, that was my first conclusion :) - though I still (see my other thread) don't know how to quickly put the discrete distance on things.</p>",
        "id": 281154957,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651670977
    },
    {
        "content": "<p>(the thread in question is <a href=\"#narrow/stream/116395-maths/topic/Discrete.20metric.2E/near/281125426\">Discrete metric.</a>)</p>",
        "id": 281155205,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651671074
    },
    {
        "content": "<p>Ah, thanks, sorry.</p>",
        "id": 281155215,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651671082
    },
    {
        "content": "<p>Still, thinking of it in terms of finset cardinality (which is closer to the L0 norm perspective) was quite nice and straightforward. Also, I note that if you are defining the hamming distance on something not equipped with <code>sub</code>, you probably can't use the L1 norm.</p>",
        "id": 281155266,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651671110
    },
    {
        "content": "<p>If I re-wrote it to be about <code>set.card</code> instead, you wouldn't even need the decidable_eq predicate - classically you don't, of course.</p>",
        "id": 281155514,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651671228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281155266\">said</a>:</p>\n<blockquote>\n<p>Still, thinking of it in terms of finset cardinality (which is closer to the L0 norm perspective) was quite nice and straightforward. Also, I note that if you are defining the hamming distance on something not equipped with <code>sub</code>, you probably can't use the L1 norm.</p>\n</blockquote>\n<p>I am not sure it makes a difference whether there is a <code>sub</code> or not: <code>pi_Lp 1</code> puts a distance on a finite product of metric spaces, it does not require subtraction as far as I can tell.</p>",
        "id": 281156316,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651671613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281154957\">said</a>:</p>\n<blockquote>\n<p>Yes, that was my first conclusion :) - though I still (see my other thread) don't know how to quickly put the discrete distance on things.</p>\n</blockquote>\n<p>Indeed, I think you are right and this is missing currently!</p>",
        "id": 281156614,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651671750
    },
    {
        "content": "<p>I think in that thead I put my first attempt at it (this is how I was interacting with the hierarchy). The difficulty was that because everything admits the discrete metric, you have to be, uh, really careful about how you define it.</p>",
        "id": 281156695,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651671800
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281156316\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/normed_ring.20vs.20normed_field/near/281155266\">said</a>:</p>\n<blockquote>\n<p>Still, thinking of it in terms of finset cardinality (which is closer to the L0 norm perspective) was quite nice and straightforward. Also, I note that if you are defining the hamming distance on something not equipped with <code>sub</code>, you probably can't use the L1 norm.</p>\n</blockquote>\n<p>I am not sure it makes a difference whether there is a <code>sub</code> or not: <code>pi_Lp 1</code> puts a distance on a finite product of metric spaces, it does not require subtraction as far as I can tell.</p>\n</blockquote>\n<p>I think you are right, thinking about it. Though I wonder - technically there's no reason you can't have an infinite version of the hamming distance, though it wouldn't be a metric space.</p>",
        "id": 281156843,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651671852
    },
    {
        "content": "<p>But in general the \"norm\" on <code>f : Œ± -&gt; Œ≤</code>that sends it to # (<a href=\"http://function.support\">function.support</a> f) is... well, it's certainly defined. Probably not useful though.</p>",
        "id": 281157156,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651671980
    },
    {
        "content": "<p>(It's kinda weird that you could technically assign the hamming norm to a field extension by thinking of it as a vector space under a particular basis, but that completely, I think, will have little  or nothing to do with the field structure.)</p>",
        "id": 281157514,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1651672172
    }
]
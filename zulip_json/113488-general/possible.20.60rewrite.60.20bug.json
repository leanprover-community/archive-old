[
    {
        "content": "<p>I think I may have found a weird bug while messing about with <code>rewrite</code>.</p>\n<p>Specifically, I was going through <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s <code>ImperialCollegeLondon/formalising-mathematics</code> repo and wanted to be cute with a solution in the file <code>./src/week_1/Part_A_logic.lean</code>. The \"cute\" solution in question was:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Spoilered for those who want to go through the repo exercises</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">or.left_comm</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"bp\">↔</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"bp\">;</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">or.assoc</span> <span class=\"n\">at</span> <span class=\"bp\">*;</span>\n  <span class=\"n\">rw</span> <span class=\"n\">or.comm</span> <span class=\"n\">Q</span> <span class=\"n\">at</span> <span class=\"bp\">*;</span>\n  <span class=\"n\">rw</span> <span class=\"n\">or.assoc</span> <span class=\"n\">at</span> <span class=\"bp\">*;</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The above is just fine (if a bit obtuse, which I guess was my intent...). The problem arises when trying to use sequential syntax, like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">or.left_comm</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"bp\">↔</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"bp\">;</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">or.assoc</span><span class=\"o\">,</span> <span class=\"n\">or.comm</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"n\">or.assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*;</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This now fails to <code>rw or.assoc at h</code> on the <code>→</code> case, but succeeds on the conclusion, and succeeds on both statements in the <code>←</code> case.</p>\n</div></div>\n<p>This project was on an older version of Lean/mathlib, but I <code>leanproject up</code>'d it just to make sure, and it still fails. I was wondering if this was <em>actually</em> a bug, or if there's something I'm missing. I suspect there might just be some weirdness as to how <code>rw [...]</code> interacts with the semicolon or something; I can't say for sure, though.</p>",
        "id": 265460518,
        "sender_full_name": "Scott Howard",
        "timestamp": 1639887920
    },
    {
        "content": "<p>Could you make a self-contained example?</p>",
        "id": 265460919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639888657
    },
    {
        "content": "<p>I can try, give me a moment.</p>",
        "id": 265460959,
        "sender_full_name": "Scott Howard",
        "timestamp": 1639888696
    },
    {
        "content": "<p>I would blame <code>rw at *</code> here, this is a rather weird operation since it requires that the rewrite sequence applies to everything in the context</p>",
        "id": 265460969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639888747
    },
    {
        "content": "<p>that is, <code>rw a at *; rw b at *</code> is not equivalent to <code>rw [a, b] at *</code> because both <code>a</code> and <code>b</code> have to apply to every hypothesis that is rewritten, while in the separated version they can rewrite a different set of assumptions</p>",
        "id": 265461033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639888858
    },
    {
        "content": "<p>if you replace <code>*</code> with the appropriate set of hypotheses it should work</p>",
        "id": 265461048,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639888883
    },
    {
        "content": "<p>I guess the thing I'm finding strange is that <code>h</code> in the first case is identical to the conclusion in the second, but the problem only shows up with the <code>h</code>. I'll try what you said, however, that might indeed be the problem.</p>",
        "id": 265461118,
        "sender_full_name": "Scott Howard",
        "timestamp": 1639889014
    },
    {
        "content": "<p>without an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> it's hard to follow along here, I'm speculating based on the proof script</p>",
        "id": 265461186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639889111
    },
    {
        "content": "<p>I'll get something together. Just juggling a thing or two, shouldn't be too long</p>",
        "id": 265461279,
        "sender_full_name": "Scott Howard",
        "timestamp": 1639889193
    },
    {
        "content": "<p>If you are just interested in a slick proof, there is no need to <code>split</code> in the first place. <code>rw [← or.assoc, or.comm Q, or.assoc]</code> should work</p>",
        "id": 265461284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639889216
    },
    {
        "content": "<p>MWE:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Spoilered for those who want to go through the repo exercises</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">test</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">or.assoc</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">((</span><span class=\"n\">hp</span> <span class=\"bp\">|</span> <span class=\"n\">hq</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">hr</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hq</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hr</span> <span class=\"o\">}},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"bp\">|</span> <span class=\"n\">hq</span> <span class=\"bp\">|</span> <span class=\"n\">hr</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hq</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hr</span> <span class=\"o\">}},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">or.comm</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"bp\">↔</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"bp\">|</span> <span class=\"n\">hq</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hq</span> <span class=\"o\">}},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">hq</span> <span class=\"bp\">|</span> <span class=\"n\">hp</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hq</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span> <span class=\"o\">}},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">or.left_comm</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"bp\">↔</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"bp\">;</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">or.assoc</span><span class=\"o\">,</span> <span class=\"n\">or.comm</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"n\">or.assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*;</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">test</span>\n</code></pre></div>\n</div></div>\n<p>Same behavior shows up, but the error hits earlier, in the way you describe, if I instead use the default <code>or.assoc</code> and <code>or.comm</code> from base Lean.</p>\n<p>So I'm satisfied it shouldn't work anyway, but I'm confused why this difference in behavior.</p>",
        "id": 265461600,
        "sender_full_name": "Scott Howard",
        "timestamp": 1639889781
    },
    {
        "content": "<p>Thanks for taking a look and letting me know about that, by the way---I didn't know that subtlety of <code>rw</code>.</p>",
        "id": 265462215,
        "sender_full_name": "Scott Howard",
        "timestamp": 1639890757
    },
    {
        "content": "<p>I'm not sure whether it is considered a bug, but I have narrowed down the unusual behavior here to the <code>try_lst</code> function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">try_lst</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">tactic</span> <span class=\"n\">unit</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>            <span class=\"o\">:=</span> <span class=\"n\">failed</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">tac</span> <span class=\"o\">::</span> <span class=\"n\">tacs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"k\">match</span> <span class=\"n\">tac</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">success</span> <span class=\"n\">_</span> <span class=\"n\">s'</span> <span class=\"o\">:=</span> <span class=\"n\">try</span> <span class=\"o\">(</span><span class=\"n\">try_lst</span> <span class=\"n\">tacs</span><span class=\"o\">)</span> <span class=\"n\">s'</span>\n  <span class=\"bp\">|</span> <span class=\"n\">exception</span> <span class=\"n\">e</span> <span class=\"n\">p</span> <span class=\"n\">s'</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">try_lst</span> <span class=\"n\">tacs</span> <span class=\"n\">s'</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">exception</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">exception</span> <span class=\"n\">e</span> <span class=\"n\">p</span> <span class=\"n\">s'</span>\n    <span class=\"bp\">|</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span>\n    <span class=\"kd\">end</span>\n  <span class=\"kd\">end</span>\n</code></pre></div>\n<p>The odd part here is that in the <code>exception e p s'</code> case we continue with the rest of the tactics using the exception state: <code>try_lst tacs s'</code>. This is a weird thing to do, because the exception state is usually some intermediate state and continuing from there can lead to unpredictable behavior. Most of the time you would roll back the state, i.e. using <code>try_lst tacs s</code> in this function.</p>\n<p>It manifests in the example like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">or.assoc</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">or.comm</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"n\">or.assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- h: (P ∨ Q) ∨ R</span>\n  <span class=\"c1\">-- ⊢ P ∨ Q ∨ R</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>What happens here is that we try to run <code>rw [← or.assoc, @or.comm Q, or.assoc] at  h</code> and <code>rw [← or.assoc, @or.comm Q, or.assoc]</code> together using <code>try_lst</code>. For the first call, we do <code>rw ← or.assoc at h</code>, turning <code>h</code> into <code>(P ∨ Q) ∨ R</code>, and then attempt to <code>rw @or.comm Q at h</code> which fails. The <code>try_lst</code> catches the failure, using the partially rewritten <code>h</code>, and then continues with <code>rw ← or.assoc</code>, <code>rw @or.comm Q</code>, and <code>rw or.assoc</code> which all succeed, resulting in the state <code>h: (P ∨ Q) ∨ R ⊢ P ∨ Q ∨ R</code>.</p>",
        "id": 265462422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639891108
    },
    {
        "content": "<p>I see. A good reason to make sure that the list really <em>does</em> match against everything you want to hit with it. Thanks a bunch!</p>",
        "id": 265462543,
        "sender_full_name": "Scott Howard",
        "timestamp": 1639891411
    }
]
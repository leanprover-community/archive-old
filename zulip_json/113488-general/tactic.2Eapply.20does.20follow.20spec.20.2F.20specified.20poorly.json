[
    {
        "content": "<p>The <code>apply</code> tactic has an option <code>new_goals</code>, which should be one of</p>\n<div class=\"codehilite\"><pre><span></span>/-- How to order the new goals made from an `apply` tactic.\nSupposing we were applying `e : ∀ (a:α) (p : P(a)), Q`\n- `non_dep_first` would produce goals `⊢ P(?m)`, `⊢ α`. It puts the P goal at the front because none of the arguments after `p` in `e` depend on `p`. It doesn&#39;t matter what the result `Q` depends on.\n- `non_dep_only` would produce goal `⊢ P(?m)`.\n- `all` would produce goals `⊢ α`, `⊢ P(?m)`.\n-/\ninductive new_goals\n| non_dep_first | non_dep_only | all\n</pre></div>\n\n\n<p>(<code>non_dep_first</code> is the default behaviour).</p>\n<p>However I've just noticed that this only applies the one of the goals --- <code>apply</code> will put the _most_ dependent argument first, but then not worry about furthering ordering of goals.</p>\n<p>Here's an example:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">forall_congr</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>After the <code>apply</code> statement we get the goals:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"mi\">4</span> <span class=\"n\">goals</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"err\">⊢</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"o\">(</span><span class=\"err\">⇑?</span><span class=\"n\">m_3</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"err\">⊢</span> <span class=\"n\">Sort</span> <span class=\"err\">?</span>\n\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"err\">⊢</span> <span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"err\">⊢</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"err\">?</span><span class=\"n\">m_1</span>\n</pre></div>\n\n\n<p>Here I'd argue that what has been presented as the second goal should actually come last, as both the third and fourth goals depend on it.</p>",
        "id": 192337037,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1585617909
    },
    {
        "content": "<p>It's not a bug per se, perhaps just unspecified.</p>",
        "id": 192337309,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1585618224
    },
    {
        "content": "<p>I thought a little about patching this (in Lean, not C++), but it seemed painful. The partial ordering on expressions by \"depending on\" is pretty easy to implement, but it seems we don't have an insertion sort algorithm for \"ordering\" a list under a partial ordering ...</p>",
        "id": 192337384,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1585618301
    },
    {
        "content": "<p>Having this fixed wouldn't actually solve my underlying problem, because what I really care about is that the 4th goal in the example above comes before either the 2nd or 3rd, and there's I think no principled way to argue this should be the output of <code>apply</code>...</p>",
        "id": 192337439,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1585618349
    }
]
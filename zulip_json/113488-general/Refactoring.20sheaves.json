[
    {
        "content": "<p>Now that sheaves over sites has a rich and useful API, I think it is increasingly favorable that we switch the \"official definition\" of sheaves over topological spaces to be the one in terms of grothendieck topologies. This switch was also briefly discussed in <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions\">this topic</a>. The main pros are </p>\n<ol>\n<li>The <code>X.Sheaf C</code> category is now defeq to <code>(opens.grothendieck_topology X).Sheaf C</code>, so that functors between categories of sheaves over sites (and other categorical results) could be specialized onto topological spaces without the abundant equivalences.</li>\n<li>It allows sheaves over spaces to value in arbitrary categories that doesn't have all products.</li>\n</ol>\n<p>Some changes / cons are</p>\n<ol>\n<li>(I saw someone mention this elsewhere) People would need to know what sites are before using it. But this could be solved by sufficient documentation.</li>\n<li>For <code>F : X.sheaf C</code>, <code>F.1</code> now has the type of a functor, and we need <code>F.presheaf</code> to access the dot notation, but I think writing out the explicit projection is favored in mathlib nonetheless. </li>\n<li><code>X.sheaf C</code> is no longer a subtype of <code>X.presheaf C</code>, but following the arguments of making <code>Sheaf</code> not a subtype, I think this is a conscious and appreciated change.</li>\n</ol>\n<p>There is also a draft PR <a href=\"https://github.com/leanprover-community/mathlib/pull/15384\">#15384</a> which builds but still fails lint (mainly because <code>[has_products C]</code> is no longer nessecary) and lacks documentation if one would like to see how the switch went.</p>",
        "id": 289724799,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1657890926
    },
    {
        "content": "<p>From my experience with <span class=\"user-mention\" data-user-id=\"391579\">@Jake Levinson</span> formalizing some things this past week, I think it is really important, if such a refactoring is made, that there is a <em>very</em> good API that allows someone who doesn't know what a site is to pretend they are working with a topological space, with the \"backend\" doing the work of creating the relevant site,  canonical Grothendieck topology on that site, showing that a sheaf in the topology sense is the same as a sheaf in the Grothendieck sense, etc.</p>",
        "id": 289789130,
        "sender_full_name": "Sam van G",
        "timestamp": 1657922832
    },
    {
        "content": "<p>On a related, but different topic, also regarding the appropriate level of generality in the definition of sheaf: we ran into quite some trouble with forgetful functors and the category <code>C</code>. I am worried that con (3) in Andrew's comment above might lead to similar problems but I may be wrong, I can't truly assess that.<br>\nIn our PR <a href=\"https://github.com/leanprover-community/mathlib/pull/15398\">#15398</a> we tried to address this by introducing some notation, but with limited success. If anyone who knows the category theory part of the library better than we do can show how to make the transition from object of C to underlying set <a href=\"https://github.com/leanprover-community/mathlib/pull/15398#discussion_r922520725\">here</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/15398#discussion_r922521056\">here</a> less painful, that would be great.</p>",
        "id": 289789768,
        "sender_full_name": "Sam van G",
        "timestamp": 1657923274
    },
    {
        "content": "<p>Tagging <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  <span class=\"user-mention\" data-user-id=\"496319\">@Nikolas Kuhn</span> in case they want to weigh in (my point of view may very well be too naive or I may be misunderstanding how to use the category part of the library correctly)</p>",
        "id": 289789929,
        "sender_full_name": "Sam van G",
        "timestamp": 1657923371
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"411579\">@Sam van G</span> can you explain what troubles you are referring to with forgetful functors?</p>",
        "id": 289789939,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657923379
    },
    {
        "content": "<p>It is explained in detail in Jake's two comments on our PR: <a href=\"https://github.com/leanprover-community/mathlib/pull/15398/files\">https://github.com/leanprover-community/mathlib/pull/15398/files</a></p>",
        "id": 289790014,
        "sender_full_name": "Sam van G",
        "timestamp": 1657923452
    },
    {
        "content": "<p>Hmmm.... it seems that you're not really using the <code>whiskering</code> api we have set up for sheaves.</p>",
        "id": 289790386,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657923735
    },
    {
        "content": "<p>We still don't have the general notion of stalks for sheaves on sites (e.g. w.r.t. topos-theoretic points, or something similar)</p>",
        "id": 289790428,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657923787
    },
    {
        "content": "<p>That's one important point that's missing from the sheaves-on-sites part of the library</p>",
        "id": 289790440,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657923802
    },
    {
        "content": "<p>I could definitely believe that we overlooked or misunderstood part of the API. (I remember seeing the word <code>whiskering</code> but not knowing what it meant.)</p>",
        "id": 289790651,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1657924011
    },
    {
        "content": "<p>That said, everything seemed to work fine until those last two lines of the proof, when we weren’t able to easily deal with the <code>(forget C).map</code> applications.</p>",
        "id": 289790705,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1657924062
    },
    {
        "content": "<p>We have a good API for filtered colimits of concrete categories. presumably that would help here.</p>",
        "id": 289791490,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657924700
    },
    {
        "content": "<p>That's pretty cool notation!</p>",
        "id": 289792194,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657925288
    },
    {
        "content": "<p>Okay, your last 4 lines </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">change</span> <span class=\"o\">(((</span><span class=\"n\">forget</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"o\">((</span><span class=\"n\">forget</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"n\">s</span> <span class=\"bp\">=</span>\n<span class=\"o\">(((</span><span class=\"n\">forget</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"o\">((</span><span class=\"n\">forget</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">forget</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">forget</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">T.naturality</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>can be changed to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">map_on_sections</span><span class=\"o\">,</span> <span class=\"n\">restrict_along</span><span class=\"o\">],</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"n\">nat_trans.naturality</span><span class=\"o\">],</span>\n</code></pre></div>",
        "id": 289792365,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657925442
    },
    {
        "content": "<p>And your last few lines in the other direction can be proved using </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_on_sections</span><span class=\"o\">,</span> <span class=\"n\">forget_map_eq_coe</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h_eq</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">h_eq</span><span class=\"o\">,</span>\n<span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Top.presheaf.germ</span><span class=\"o\">],</span>\n<span class=\"k\">let</span> <span class=\"n\">ι'</span> <span class=\"o\">:</span> <span class=\"o\">(⟨</span><span class=\"n\">V</span><span class=\"o\">,</span><span class=\"n\">hxV</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">open_nhds</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span><span class=\"n\">hxU</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ι</span><span class=\"o\">,</span>\n<span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">limits.colimit.w</span> <span class=\"n\">_</span> <span class=\"n\">ι'.op</span><span class=\"o\">,</span> <span class=\"n\">comp_apply</span><span class=\"o\">],</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 289793017,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657926032
    },
    {
        "content": "<p>It seems that there is some API missing here. The API around <code>germ</code> is done for any category <code>C</code> essentially by using the colimit api, but now you're using it on elements when you have a concrete category, so there is some back-and-forth that needs to happen when you apply a composition of moprhisms.</p>",
        "id": 289793166,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657926166
    },
    {
        "content": "<p>Awesome! We’ll make those edits. If you can think of any API additions you think we should add in this same PR, we’d be happy to extend it.</p>",
        "id": 289793373,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1657926339
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"411579\">@Sam van G</span></p>",
        "id": 289793382,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1657926349
    },
    {
        "content": "<p>One sec I think I can clean up the second block</p>",
        "id": 289793393,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657926361
    },
    {
        "content": "<p>Okay here's the complete proof with the new finishing lines</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Being locally surjective is equivalent to being surjective on stalks. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">locally_surjective_iff_surjective_on_stalks</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">ℱ</span> <span class=\"bp\">⟶</span> <span class=\"bp\">𝒢</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_locally_surjective</span> <span class=\"n\">T</span> <span class=\"bp\">↔</span> <span class=\"n\">is_surjective_on_stalks</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">hT</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c\">/-</span><span class=\"cm\"> human proof:</span>\n<span class=\"cm\">    Let g ∈ Γₛₜ 𝒢 x be a germ. Represent it on an open set U ⊆ X</span>\n<span class=\"cm\">    as ⟨t, U⟩. By local surjectivity, pass to a smaller open set V</span>\n<span class=\"cm\">    on which there exists s ∈ Γ_ ℱ V mapping to t |_ V.</span>\n<span class=\"cm\">    Then the germ of s maps to g -/</span>\n\n    <span class=\"c1\">-- Let g ∈ Γₛₜ 𝒢 x be a germ.</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- Represent it on an open set U ⊆ X as ⟨t, U⟩.</span>\n    <span class=\"n\">rcases</span> <span class=\"bp\">𝒢.</span><span class=\"n\">germ_exist</span> <span class=\"n\">x</span> <span class=\"n\">g</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hxU</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"c1\">-- By local surjectivity, pass to a smaller open set V</span>\n    <span class=\"c1\">-- on which there exists s ∈ Γ_ ℱ V mapping to t |_ V.</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hT</span> <span class=\"n\">U</span> <span class=\"n\">t</span> <span class=\"n\">x</span> <span class=\"n\">hxU</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">hxV</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">h_eq</span><span class=\"o\">⟩,</span>\n\n    <span class=\"c1\">-- Then the germ of s maps to g.</span>\n    <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">forget</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">ℱ.germ</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxV</span><span class=\"o\">⟩)</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">Top.presheaf.stalk_functor_map_germ_apply</span> <span class=\"n\">V</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxV</span><span class=\"o\">⟩</span> <span class=\"n\">T</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n\n    <span class=\"c1\">-- New finish</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_on_sections</span><span class=\"o\">,</span> <span class=\"n\">forget_map_eq_coe</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">h_eq</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"bp\">𝒢.</span><span class=\"n\">germ_res</span><span class=\"o\">],</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n\n  <span class=\"o\">{</span> <span class=\"c\">/-</span><span class=\"cm\"> human proof:</span>\n<span class=\"cm\">    Let U be an open set, t ∈ Γ ℱ U a section, x ∈ U a point.</span>\n<span class=\"cm\">    By surjectivity on stalks, the germ of t is the image of</span>\n<span class=\"cm\">    some germ f ∈ Γₛₜ ℱ x. Represent f on some open set V ⊆ X as ⟨s, V⟩.</span>\n<span class=\"cm\">    Then there is some possibly smaller open set x ∈ W ⊆ V ∩ U on which</span>\n<span class=\"cm\">    we have T(s) |_ W = t |_ W. -/</span>\n    <span class=\"n\">intros</span> <span class=\"n\">U</span> <span class=\"n\">t</span> <span class=\"n\">x</span> <span class=\"n\">hxU</span><span class=\"o\">,</span>\n\n    <span class=\"n\">set</span> <span class=\"n\">t_x</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">forget</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">𝒢.</span><span class=\"n\">germ</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hxU</span><span class=\"o\">⟩)</span> <span class=\"n\">t</span> <span class=\"k\">with</span> <span class=\"n\">ht_x</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">s_x</span><span class=\"o\">,</span> <span class=\"n\">hs_x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">_ₛₜ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">s_x</span> <span class=\"bp\">=</span> <span class=\"n\">t_x</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hT</span> <span class=\"n\">x</span> <span class=\"n\">t_x</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hxV</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ℱ.germ_exist</span> <span class=\"n\">x</span> <span class=\"n\">s_x</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- rfl : ℱ.germ x s = s_x</span>\n    <span class=\"k\">have</span> <span class=\"n\">key_W</span> <span class=\"o\">:=</span> <span class=\"bp\">𝒢.</span><span class=\"n\">germ_eq</span> <span class=\"n\">x</span> <span class=\"n\">hxV</span> <span class=\"n\">hxU</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">_</span><span class=\"bp\">*</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">t</span>\n      <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">hs_x</span><span class=\"o\">,</span>\n            <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n            <span class=\"n\">convert</span> <span class=\"n\">Top.presheaf.stalk_functor_map_germ_apply</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">}),</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">W</span><span class=\"o\">,</span> <span class=\"n\">hxW</span><span class=\"o\">,</span> <span class=\"n\">hWV</span><span class=\"o\">,</span> <span class=\"n\">hWU</span><span class=\"o\">,</span> <span class=\"n\">h_eq</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">key_W</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">W</span><span class=\"o\">,</span> <span class=\"n\">hWU</span><span class=\"o\">,</span> <span class=\"n\">hxW</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">s</span> <span class=\"bp\">|</span><span class=\"n\">_</span> <span class=\"n\">hWV</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">h_eq</span><span class=\"o\">,</span>\n\n    <span class=\"c1\">-- New finish</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">map_on_sections</span><span class=\"o\">,</span> <span class=\"n\">restrict_along</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"n\">nat_trans.naturality</span><span class=\"o\">],</span>\n    <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Using <code>erw</code> is not ideal -- that usually means that there is some missing <code>dsimp</code> lemma.</p>",
        "id": 289793531,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657926469
    },
    {
        "content": "<p>Hmm... on second thought it looks like all these defs/notations are just preventing the appropriate simp lemmas from firing.</p>",
        "id": 289794556,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657927297
    },
    {
        "content": "<p>Thanks Adam!! This is already a huge improvement.</p>",
        "id": 289794638,
        "sender_full_name": "Sam van G",
        "timestamp": 1657927345
    },
    {
        "content": "<p>Re your last comment, I may remember wrong and am not on computer right now but I <em>think</em> at one point yesterday <span class=\"user-mention\" data-user-id=\"391579\">@Jake Levinson</span> and I had the same thought and tried to just copy in the definitions for the notations and it did not help. Will check this later.</p>",
        "id": 289794729,
        "sender_full_name": "Sam van G",
        "timestamp": 1657927430
    },
    {
        "content": "<p>Should we mark those definitions <code>reducible</code> or something?</p>",
        "id": 289794839,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1657927505
    },
    {
        "content": "<p>I think the best approach would be to make the notation directly using the existing API without making any new defs</p>",
        "id": 289794942,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657927592
    },
    {
        "content": "<p>I'm no expert in making notation, so hopefully someone else can help with that</p>",
        "id": 289794950,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657927605
    },
    {
        "content": "<p>Oh I see. We can experiment a bit, defining the notation directly. The notation definitely made parts of the proof easier to think through, so it would be nice to keep it in some form.</p>",
        "id": 289795111,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1657927742
    },
    {
        "content": "<p>I agree the notation is very nice, but I think having working <code>simp</code> lemmas would be nicer ;)</p>",
        "id": 289795143,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657927781
    },
    {
        "content": "<p>it would be great if we can have both!</p>",
        "id": 289795206,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657927804
    },
    {
        "content": "<p>Here's a version of the file with all the notation and defs removed (plus some tricks using instances for concrete categories):<br>\n<a href=\"https://gist.github.com/adamtopaz/802c0ad2491ef63e37b0d040d85e9eef\">https://gist.github.com/adamtopaz/802c0ad2491ef63e37b0d040d85e9eef</a></p>",
        "id": 289795548,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657928153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"411579\">@Sam van G</span> Regarding your first comment, Is an iff rewriting the new sheaf condition with the old sheaf condition enough?<br>\nIf one really doesn't want to go near sites, one could rewrite it whenever they really want to use the sheaf condition.</p>",
        "id": 289797878,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1657930647
    },
    {
        "content": "<p>I think the bigger issue would be with sheafification.</p>",
        "id": 289798144,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657930937
    },
    {
        "content": "<p>By this, do you mean that people working on sheaves over spaces would want sheafifications with a better underlying implementation?</p>",
        "id": 289798276,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1657931148
    },
    {
        "content": "<p>I just mean that the current def of the non-sites shrafification uses this disjoint union of stalks. So if someone wants to rely on this precise construction, they would have to deal with isomorphisms to go back and forth with the site-theoretic definition</p>",
        "id": 289798706,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657931723
    },
    {
        "content": "<p>It's not that bad though. I don't think we have any defeq abuse in this part of the library.</p>",
        "id": 289798761,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657931774
    },
    {
        "content": "<p>In any case, I'm 100% in favor  of the refactor that you suggested (obviously ;-) )</p>",
        "id": 289798777,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657931831
    },
    {
        "content": "<p>It is fundamental for algebraic geometry to be able to switch seamlessly between sheaf-as-functor-on-opens and sheaf-as-bundle-of-stalks. If this requires passing through an isomorphism every time you do it, I am worried it would add a layer of complication to the already pretty complicated API. So for being able to do some algebraic geometry, I personally would be more interested in making the existing sheaf on space more easily usable before trying to generalize.<br>\nAs an alternative option, couldn’t one begin by making a separate notion called <code>sheaf_on_site</code>, leaving the current notion of sheaf on space untouched, and then prove that the current notion is a special case of the newly defined <code>sheaf_on_site</code>? (This may be a somewhat non trivial exercise in itself.)</p>",
        "id": 289799376,
        "sender_full_name": "Sam van G",
        "timestamp": 1657932720
    },
    {
        "content": "<p>The non-sites sheafification only applies to Types, and it has little API, so I don't think people should be encouraged to use that.<br>\nIn most cases people only only want a left adjoint to the forgetful functor, and in cases where people need the description on elements, knowing that the to sheafification map <code>is_locally_surjective</code> should be enough.</p>",
        "id": 289799436,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1657932746
    },
    {
        "content": "<p>The alternative approach is probably the current approach?<br>\nThe current approach is that A presheaf is a functor on opens, and <code>is_sheaf</code> is a predicate on it.<br>\nA sheaf is just a bundled functor with the <code>is_sheaf</code> predicate.<br>\nWe have a definition of sheaves on sites and sheaf on spaces, the difference is that the <code>is_sheaf</code> is different, but the presheaf is the same thing.</p>\n<p>What I am proposing is replacing the <code>is_sheaf</code> of spaces with the equivalent <code>is_sheaf</code> of sites. The functor should remain unchanged.</p>",
        "id": 289799612,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1657933009
    },
    {
        "content": "<p>I’m not so sure about that, it seems to me that there are several other local properties of sheaves beyond just local surjectivity that will require speaking about the description on stalks on the Set/Type level.<br>\nBut I will now leave it to others with more experience in (formalizations of) algebraic geometry to comment on that.</p>",
        "id": 289799613,
        "sender_full_name": "Sam van G",
        "timestamp": 1657933016
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"411579\">Sam van G</span> <a href=\"#narrow/stream/113488-general/topic/Refactoring.20sheaves/near/289799376\">said</a>:</p>\n<blockquote>\n<p>As an alternative option, couldn’t one begin by making a separate notion called <code>sheaf_on_site</code>, leaving the current notion of sheaf on space untouched, and then prove that the current notion is a special case of the newly defined <code>sheaf_on_site</code>? (This may be a somewhat non trivial exercise in itself.)</p>\n</blockquote>\n<p>See <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top.presheaf.Sheaf_spaces_equiv_sheaf_sites\">docs#Top.presheaf.Sheaf_spaces_equiv_sheaf_sites</a></p>",
        "id": 289799629,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657933066
    },
    {
        "content": "<p>We already have a substantial API around stalks of sheaves independent of the sheafification stuff, and I believe that is enough?</p>",
        "id": 289799679,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1657933096
    },
    {
        "content": "<p>Do we have the sheafification adjunction for the topological sheafification? I don''t see it in <code>topology/sheaves/sheafify</code></p>",
        "id": 289799713,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657933196
    },
    {
        "content": "<p>If we have that, then we would get the isomorphism with the site-theoretic sheafification (compatibly with the adjunction) for free</p>",
        "id": 289799769,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1657933238
    },
    {
        "content": "<p>No we don't. That file is all we have got for topological sheafifications, and no other file imports it.</p>",
        "id": 289799795,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1657933313
    },
    {
        "content": "<p>Maybe that could be another short-term goal.</p>",
        "id": 289808291,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1657946739
    },
    {
        "content": "<p>My stance is that we wouldn't need two versions of sheafification, but others may very well disagree.<br>\nIMHO an isomorphism as sheaves between them as a sanity check suffices.<br>\nI think the isomorphism would be more easily shown by</p>\n<ol>\n<li>the descent of an injective presheaf morphism onto its sheafification is injective.</li>\n<li>If <code>f &gt;&gt; g</code> is surjective, then so is <code>g</code>.</li>\n<li>An injective and surjective morphism between sheaves is bijective. </li>\n<li>The topological sheafification map is both injective and surjective.<br>\nAlso, the first three results are all useful and important on its own.</li>\n</ol>",
        "id": 289809850,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1657949106
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> , thanks so much for those nice proofs. I'm still fiddling with the file to get the hang of what you did. When I make a new commit, how do I acknowledge you? In the commit message I guess?</p>\n<p>Regarding notation: those two lines</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">concrete_category.has_coe_to_fun</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">concrete_category.has_coe_to_sort</span>\n</code></pre></div>\n<p>definitely make things easier to read and write. Is there a way to also coerce <code>opens X</code> into <code>(opens X).op</code>? or coerce the sheaf-related functions to take objects and morphisms from <code>opens X</code>? I imagine this is some broader question about contravariant functors, so maybe there's some reason why this isn't doable. But, it is confusing to have to write <code>.op</code> everywhere.</p>\n<p>On another note, I think it can be easy to forget how illegible these extra layers of abstraction and notation are, after you've gotten used to them. Actually, the reason <span class=\"user-mention\" data-user-id=\"411579\">@Sam van G</span> and I introduced those other notations in the first place is because, after reading <code>topology/presheaf.lean</code> and <code>stalks.lean</code> and so on, we still couldn't figure out how to write down the relevant variables for <code>is_locally_surjective</code> (which after all involved all the main sheaf-related objects: sections, germs, restriction maps, induced maps). We definitely found <code>s : (forget C).map (ℱ.obj (op U))</code> harder to read than <code>s : Γ_ ℱ U</code>, never mind a statement involving several of these objects. I think it would have been harder still if we had also had to unpack from sheaves on sites to sections on open sets.</p>\n<p>Generalizing to Grothendieck topologies might well make it easier to prove more categorical facts about sheaves. But will it make it harder to (e.g.) describe the structure sheaves and modules of varieties and schemes? What about proving local properties by passing to a local ring and using Nakayama's lemma? Or doing some kind of local calculation involving actual polynomials?</p>\n<p>I can recognize that presumably all of this stuff would be recoverable by specializing back to the ordinary Zariski topology, and I don't want to get in your way in developing this part of the library. Still, I am probably not the only algebraic geometer who barely knows what a Grothendieck topology is, so it would at least make it harder for me to use this library.</p>",
        "id": 289896539,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1658080883
    },
    {
        "content": "<p>No matter the sheaf condition is stated in terms of sieves or open covers, a presheaf will always be a <code>(opens X)ᵒᵖ ⥤ C</code>, and this refactor won't any difference in manipulating the elements on the presheaf. By checking the diff of the draft PR <a href=\"https://github.com/leanprover-community/mathlib/pull/15384\">#15384</a>, I think it should be evident that this PR is not as intrusive as you seem to imagine.</p>",
        "id": 289897339,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658082118
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"391579\">Jake Levinson</span> <a href=\"#narrow/stream/113488-general/topic/Refactoring.20sheaves/near/289896539\">said</a>:</p>\n<blockquote>\n<p>When I make a new commit, how do I acknowledge you? In the commit message I guess?</p>\n</blockquote>\n<p>Oh, don't worry about it. I was happy to help!</p>\n<p>The issue with op is indeed annoying, but there is really no good way around it (as far as I know). You may just need to learn to live with <code>op</code> and <code>unop</code>. </p>\n<p>We have the sheaf condition in terms of multiequalizers which should reduce directly to the usual sheaf condition on topological spaces. Maybe I'll try to write down a PR doing this later today.</p>",
        "id": 289897637,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658082482
    },
    {
        "content": "<p>On the other hand, the I agree that the type signatures are not that illegible. I think an idea worth exploring is to make a <code>has_sections</code> type class that enables a notation like <code>Γ(_, _)</code> so that we could write <code>Γ(ℱ, U)</code> for sheaves and presheaves, as well as <code>Γ(X, U)</code> for ringed spaces and schemes etc In place of <code>foo.presheaf.obj (op bar)</code></p>",
        "id": 289897662,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658082518
    },
    {
        "content": "<p>I have tried to write a bit on functoriality of sheafification. I managed to show that sheafification is functorial, but my proof isn't very nice. Here's what I added in <code>topology/sheafify.lean</code> (<a href=\"https://github.com/leanprover-community/mathlib/blob/d8974a346b09e05ad7f36c8200037521b7e076f6/src/topology/sheaves/sheafify.lean#L129\">https://github.com/leanprover-community/mathlib/blob/d8974a346b09e05ad7f36c8200037521b7e076f6/src/topology/sheaves/sheafify.lean#L129</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sheafify_map</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">⟶</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F.sheafify</span> <span class=\"bp\">⟶</span> <span class=\"n\">G.sheafify</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">stalk_functor</span> <span class=\"n\">_</span> <span class=\"n\">x.1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">f.1</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n     <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hxV</span><span class=\"o\">,</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f'</span><span class=\"o\">,</span> <span class=\"n\">hf'</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:=</span> <span class=\"n\">f.2</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n        <span class=\"c1\">-- notice that ι : V ⟶ unop U, I'm not sure why the API is mixing</span>\n        <span class=\"c1\">-- (opens X) and (opens X)ᵒᵖ here...</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hxV</span><span class=\"o\">,</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">T.app</span> <span class=\"n\">_</span> <span class=\"n\">f'</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x'</span><span class=\"o\">,</span>\n      <span class=\"kd\">begin</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.val_eq_coe</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span> <span class=\"n\">hf'</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">hf'</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">stalk_functor_map_germ_apply</span> <span class=\"n\">V</span> <span class=\"n\">x'</span> <span class=\"n\">T</span> <span class=\"n\">f'</span><span class=\"o\">,</span>\n      <span class=\"kd\">end</span><span class=\"o\">⟩,</span>\n    <span class=\"kd\">end</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">naturality'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">res</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">category_theory.types_comp_apply</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">change</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">stalk_functor</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">x.val</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">T</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">congr</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sheafify_id</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">X.presheaf</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">sheafify_map</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟙</span> <span class=\"n\">F.sheafify</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">U</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">sheafify_map</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sheafify_comp</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">X.presheaf</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">T1</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">⟶</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">T2</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">⟶</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">sheafify_map</span> <span class=\"o\">(</span><span class=\"n\">T1</span> <span class=\"bp\">≫</span> <span class=\"n\">T2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">sheafify_map</span> <span class=\"n\">T1</span> <span class=\"bp\">≫</span> <span class=\"n\">sheafify_map</span> <span class=\"n\">T2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">U</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">sheafify_map</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sheafification</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">X</span> <span class=\"bp\">⥤</span> <span class=\"n\">sheaf</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">F.sheafify</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">sheafify_map</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"n\">sheafify_id</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">T1</span> <span class=\"n\">T2</span><span class=\"o\">,</span> <span class=\"n\">sheafify_comp</span> <span class=\"n\">T1</span> <span class=\"n\">T2</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>It took me a while to figure out how to formulate the objects in question, and at some point I also found myself with a mix of <code>opens X</code> and <code>(opens X)ᵒᵖ</code>objects, which is a sign that I am using the API wrong. I guess I am still trying to write with sets and functions rather than the categorical language.</p>\n<p>With this the adjunction shouldn't be too bad either, since the lemma <code>sheafify_stalk_iso</code> should make it easy to show that when <code>G</code> is a sheaf, the natural map <code>G ⟶ G.1.sheafify</code>is an isomorphism.</p>",
        "id": 290003890,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1658168322
    },
    {
        "content": "<p>I'm imagining that the adjunction would be formulated as <code>T : F ⟶ G.1</code> becomes something like <code>(sheafify_map T) ≫ (G.sheafify_equiv.to_inv_fun) : F.sheafify ⟶ G</code> and conversely <code>T : F.sheafify ⟶ G</code> just goes to <code>F.to_sheafify ≫ T : F ⟶ G.1</code>.</p>",
        "id": 290004592,
        "sender_full_name": "Jake Levinson",
        "timestamp": 1658168702
    },
    {
        "content": "<p>The refactor <a href=\"https://github.com/leanprover-community/mathlib/pull/15384\">#15384</a> is now ready for review.</p>",
        "id": 290189431,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658287010
    }
]
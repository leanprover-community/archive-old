[
    {
        "content": "<p>I wanted to learn more about the options for Declarative Lean (e.g. like Isar or controlled natural language or Cezar <a href=\"https://kluedo.ub.uni-kl.de/frontdoor/deliver/index/docId/2100/file/B-065.pdf\" title=\"https://kluedo.ub.uni-kl.de/frontdoor/deliver/index/docId/2100/file/B-065.pdf\">https://kluedo.ub.uni-kl.de/frontdoor/deliver/index/docId/2100/file/B-065.pdf</a>). Any pointers? Does this exist for Lean?</p>",
        "id": 196667754,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588785676
    },
    {
        "content": "<p>Everything I see when skimming this pdf is already possible with the tactics we have.</p>",
        "id": 196669584,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786364
    },
    {
        "content": "<p>You don't need anything new , you only need to restrict to a subset of what is available</p>",
        "id": 196669690,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786401
    },
    {
        "content": "<p>If you want to enforce using only this subset then you can have a dedicated tactic mode where you only copy the subset you want to enforce</p>",
        "id": 196669837,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786466
    },
    {
        "content": "<p>For instance you can read the discussion at <a href=\"#narrow/stream/113488-general/topic/Proposal.3A.20.60fix.20x.60.20for.20.60assume.20x.60\" title=\"#narrow/stream/113488-general/topic/Proposal.3A.20.60fix.20x.60.20for.20.60assume.20x.60\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Proposal.3A.20.60fix.20x.60.20for.20.60assume.20x.60</a>. It will contains a lot of noise from your point of view, but also interesting things for you.</p>",
        "id": 196670257,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786642
    },
    {
        "content": "<p>Here's the example on p4 of the pdf, in Lean:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">hidden</span>\n\n<span class=\"n\">def</span> <span class=\"n\">div2</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">div2</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">def</span> <span class=\"n\">double</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">double_div2</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">double</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refl</span><span class=\"o\">},</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">double</span> <span class=\"n\">at</span> <span class=\"n\">hd</span> <span class=\"err\">⊢</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">succ_add</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"bp\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">div2</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">double_div2&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">double</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"k\">assume</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">n</span>\n  <span class=\"o\">(</span> <span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n    <span class=\"k\">from</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"k\">assume</span> <span class=\"n\">Hrec</span><span class=\"o\">,</span>\n   <span class=\"k\">calc</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">double</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">succ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n   <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">div2</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">congr_arg</span> <span class=\"bp\">_</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">succ_add</span><span class=\"o\">,</span> <span class=\"n\">add_succ</span><span class=\"o\">]</span>\n   <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">div2</span> <span class=\"o\">(</span><span class=\"n\">double</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">div2</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n   <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">Hrec</span>\n  <span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">hidden</span>\n</code></pre></div>\n\n\n<p>Both modes are already available.</p>",
        "id": 196670417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588786690
    },
    {
        "content": "<p>See also the example at <a href=\"#narrow/stream/116395-maths/topic/Lebesgue.20number.20lemma/near/194033514\" title=\"#narrow/stream/116395-maths/topic/Lebesgue.20number.20lemma/near/194033514\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lebesgue.20number.20lemma/near/194033514</a></p>",
        "id": 196670541,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786736
    },
    {
        "content": "<p>The main difference with Isar (beyond the additional flexibility) is the lack of sledgehammer to proving proofs of each small step.</p>",
        "id": 196670639,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786765
    },
    {
        "content": "<p>You can also mix Kevin's example, doing the structured tactic mode style.</p>",
        "id": 196670761,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588786806
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246156\">@Brando Miranda</span>’s interests are in AI, so I don’t think he is asking from the point of a Lean user (i.e. how can I do this in practice), but for some other purpose (e.g. is there a formal declarative specification I can use to interact with Lean).  Can you clarify your motivation Brando?  (Also it is good to hear from you again.)</p>",
        "id": 196671249,
        "sender_full_name": "Jason Rute",
        "timestamp": 1588787024
    },
    {
        "content": "<p>Wow. Thanks Jason, that was <em>very</em> hard to guess from his message and then disappearance.</p>",
        "id": 196673519,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588788028
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Thanks for your response. It's greatly appreciated. I'm curious, what do you mean by disappearance? I didn't know when I would get a response so I just closed the chat and would be back to it later as I have now. </p>\n<p>My question has many facets. One of them is trying to understand what is the best representation from an interactive theorem prover side for machine learning (ML) systems to do proof search. I won't lie but with so many Interactive Theorem Provers (ITPs) in existence, it's been very hard for me to commit to any of them in depth (though Isabelle is the one I know best because it's the one taught in my university) because I just don't know which one is the best (especially for Machine Learning). I am not even sure what are all the features I should be considering when choosing one (especially for ML).</p>\n<p>In addition, to discover that there is a declarative style ITP language added yet another layer of complexity that I didn't know existed. It's not entirely clear why to me what the main problem declarative proofs solve vs procedural (I will admit if I don't know if there are more styles I am not aware of). </p>\n<p>Though, it was a pleasant surprise to hear that Lean has declarative proofs embedded in the language naturally, so I wouldn't have to worry about that if I were to choose Lean it seems, though I'm not an expert in ITPs, but I find them fascinating (and fun to use!).</p>",
        "id": 196691120,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588796243
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>  Thanks for the kind message Jason. I plan to be very active this summer, as soon as classes end next week. Excited! :)</p>",
        "id": 196691565,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588796431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246156\">Brando Miranda</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196691120\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196691120\">said</a>:</p>\n<blockquote>\n<p>Thanks for your response. It's greatly appreciated. I'm curious, what do you mean by disappearance? I didn't know when I would get a response so I just closed the chat and would be back to it later as I have now. </p>\n</blockquote>\n<p>There is no problem. I was making fun of Kevin and I trying to answer very quickly without really knowing the question (but adding some context can often help)</p>",
        "id": 196696020,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1588798626
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  Thanks! I didn't want to overwhelm people with every question I had but I am happy to start with a few first (and hopefully get them all cleared!). What problem are declarative style proofs suppose to solve (why were they invented for ITPs in particular)? Are they a good representation for proof search with respect to classical search methods or ML methods? Are they good at all for proof search?</p>",
        "id": 196700328,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588800574
    },
    {
        "content": "<p>Declarative proof styles are intended for human readability. I think they are unlikely to be good for automatic search</p>",
        "id": 196700505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588800637
    },
    {
        "content": "<p>the idea is that you can get a formal proof that has the general structure of an informal maths proof</p>",
        "id": 196700592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588800684
    },
    {
        "content": "<p>Are the grammars for procedural ITPS vs declarative ITPS usually completely separate?</p>",
        "id": 196700717,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588800740
    },
    {
        "content": "<p>No, in fact they have significant overlap, which is what I think Kevin's original point was. Lean has tactics corresponding to all the different proof styles</p>",
        "id": 196700857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588800814
    },
    {
        "content": "<p>Why does Lean have such a feature embedded, apparently, so naturally in it? Was that a major design point for Lean? It seems other languages make a big deal out of this feature (e.g. Cezar for Coq, Miz3 for HOL Light, Isar for Isabelle perhaps more out there) so I am trying to understanding it better.</p>",
        "id": 196700892,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588800832
    },
    {
        "content": "<p>Lean was made with the benefit of hindsight, but I don't think it was a major design point, as much as the idea of having a dynamically extensible tactic language in the first place</p>",
        "id": 196701072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588800901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196700857\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196700857\">said</a>:</p>\n<blockquote>\n<p>No, in fact they have significant overlap, which is what I think Kevin's original point was. Lean has tactics corresponding to all the different proof styles</p>\n</blockquote>\n<p>But this isn't standard afaik. Otherwise why draw the distinction btw Isabelle vs Isar?</p>",
        "id": 196701098,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588800912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196701072\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196701072\">said</a>:</p>\n<blockquote>\n<p>Lean was made with the benefit of hindsight, but I don't think it was a major design point, as much as the idea of having a dynamically extensible tactic language in the first place</p>\n</blockquote>\n<p>you mean we already know much more about ITPs before Lean was designed?</p>",
        "id": 196701150,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588800941
    },
    {
        "content": "<p>Lean is only 5-6 years old. It's a baby compared to the others</p>",
        "id": 196701226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588800966
    },
    {
        "content": "<p>Maybe this the wrong place to ask this (since the answer might be biased), but is due to this hindsight Lean the best ITP out there?</p>",
        "id": 196701245,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588800977
    },
    {
        "content": "<p>That depends on what you mean by \"best\"</p>",
        "id": 196701316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801011
    },
    {
        "content": "<p>I think in terms of user interface lean gets a lot of things right</p>",
        "id": 196701356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196701316\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196701316\">said</a>:</p>\n<blockquote>\n<p>That depends on what you mean by \"best\"</p>\n</blockquote>\n<p>Is it possible to learn more about the way \"best\" was defined for Lean? e.g. the main decision that came around for the design of Lean?</p>",
        "id": 196701449,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588801071
    },
    {
        "content": "<p>There is a paper on metaprogramming in lean 3, that might be a good place to look for major design decisions</p>",
        "id": 196701550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801108
    },
    {
        "content": "<p>that was when lean 3 first came out and differentiated itself from lean 2 with its much expanded tactic grammar</p>",
        "id": 196701604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801136
    },
    {
        "content": "<p>I am curious, what do you think is Lean's major advantages compared to Coq &amp; Isabelle? (I will read that reference thanks!)</p>",
        "id": 196701703,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588801199
    },
    {
        "content": "<p>Different ITPs use different logics, e.g. some use higher order logic, some have the univalence axiom baked in, and so on. Hence it's difficult to say which is the \"best\" one -- it depends on what you plan on using it for. I have a hypothesis that Lean's particular choice of dependent type theory is the best one for doing a lot of different kinds of modern pure mathematics but it's difficult to \"prove\" this, other than by what we are doing, which is formalising lots of different kinds of pure mathematics and seeing what happens.</p>",
        "id": 196701809,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801256
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/papers/tactic.pdf\" title=\"https://leanprover.github.io/papers/tactic.pdf\">https://leanprover.github.io/papers/tactic.pdf</a></p>",
        "id": 196701813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801260
    },
    {
        "content": "<p>Coq takes the concerns of constructivists more seriously, but because most mathematicians aren't constructivists I regard this as a hindrance. I don't really understand this link <a href=\"https://artagnon.com/articles/leancoq\" title=\"https://artagnon.com/articles/leancoq\">https://artagnon.com/articles/leancoq</a> but perhaps you will.</p>",
        "id": 196701961,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801322
    },
    {
        "content": "<p>Isabelle/HOL is higher order logic, not dependent type theory, so the foundations are very different. What it does, it does very well, and very quickly. But my worries when it comes to mathematics are about what it can't do well at all.</p>",
        "id": 196702049,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801388
    },
    {
        "content": "<p>But these are just my personal opinions and they're highly skewed by my personal goal, which is to see e.g. an entire undergraduate pure maths degree in one system.</p>",
        "id": 196702120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801441
    },
    {
        "content": "<p>Which one is the easiest to write where things that are \"obvious\" or \"intuitive\" can be taken for granted? I am guessing Lean is the best at this from this quote from the link you sent <a href=\"https://artagnon.com/articles/leancoq\" title=\"https://artagnon.com/articles/leancoq\">https://artagnon.com/articles/leancoq</a></p>\n<blockquote>\n<p>Quotient-reasoning makes formalizing commutative algebra painless, and it's baked into the Lean kernel.</p>\n</blockquote>",
        "id": 196702677,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588801750
    },
    {
        "content": "<p>That's an eternal goal in any theorem prover</p>",
        "id": 196702912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801875
    },
    {
        "content": "<p>The way to prove an obvious thing is to apply the proof which someone else has already formalised in the maths library</p>",
        "id": 196702951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801888
    },
    {
        "content": "<p>however this only works for some values of obvious</p>",
        "id": 196702973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801897
    },
    {
        "content": "<p>and I've seen a lot of very complicated things being called obvious in research maths seminars in my time</p>",
        "id": 196703009,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801916
    },
    {
        "content": "<p>I was surprised to read that Lean is slow? I would have thought it's really fast because of the C++</p>\n<p>My inference is from this paragraph (<a href=\"https://artagnon.com/articles/leancoq\" title=\"https://artagnon.com/articles/leancoq\">https://artagnon.com/articles/leancoq</a>):</p>\n<blockquote>\n<p>One would think that Lean is an engineering feat, since it's written in C++: Coq's math-comp (90k loc) compares to Lean's mathlib (150k loc); math-comp builds in under ten minutes, while mathlib takes over thirty minutes to build! Indeed, due to their design decision to use a VM for computations, computation happens at a speed comparable to Python-bytecode evaluation — they seem to be overhauling this in Lean4 though, by compiling Lean code down to C before execution.</p>\n</blockquote>",
        "id": 196703014,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588801920
    },
    {
        "content": "<p>obvious can mean \"known to the people in the room\" sometimes.</p>",
        "id": 196703076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588801932
    },
    {
        "content": "<p>Got it. I was just guessing based on the comment from the blog you sent me.</p>",
        "id": 196703103,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588801956
    },
    {
        "content": "<p>Lean is <em>surprisingly</em> fast when you look at how much it is doing</p>",
        "id": 196703124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588801969
    },
    {
        "content": "<p>hmm...What is it doing?</p>",
        "id": 196703169,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588801995
    },
    {
        "content": "<p>The main slow things in lean are VM evaluation and typeclass inference</p>",
        "id": 196703197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802015
    },
    {
        "content": "<p>I guess from a proof search point of view (my interest mainly), I would be really happy if my ITP environment is fast. Very fast.</p>",
        "id": 196703215,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588802026
    },
    {
        "content": "<p>VM evaluation is used for running tactics, which does impact your ML bottom line</p>",
        "id": 196703239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802042
    },
    {
        "content": "<p>But perhaps to focus only on fast is a naive goal. Hence the discussion I started and my interest in learning about Lean more (&amp; declarative proofs).</p>",
        "id": 196703319,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588802080
    },
    {
        "content": "<p>Also, if proofs are going to be generated, it would be nice that they are human understandable, hence why I was curious about declarative style proofs (since that seems to be their main goal afaik).</p>",
        "id": 196703369,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588802112
    },
    {
        "content": "<p>I think that a fast ITP is a great goal (which is why <a href=\"https://github.com/digama0/mm0\" title=\"https://github.com/digama0/mm0\">I built one</a>). It's tough selling this to the community though</p>",
        "id": 196703395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802141
    },
    {
        "content": "<p>I still have hope for post processing arbitrary proofs to make them more human readable / navigable / understandable</p>",
        "id": 196703555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802239
    },
    {
        "content": "<p>the main downside of procedural proofs is that you have to have the proof state in your head at all times to read the proof, which in practice means they can't be read without the program running alongside</p>",
        "id": 196703739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196703124\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196703124\">said</a>:</p>\n<blockquote>\n<p>Lean is <em>surprisingly</em> fast when you look at how much it is doing</p>\n</blockquote>\n<p>Is there any evidence for this? Coq also does typeclasses and tactic-based metaprogramming, and while Lean is not particularly slow, it also hasn't struck me as particularly fast. The mathlib compile times aren't great, but there is no direct comparison, so it's hard to evaluate these claims.</p>",
        "id": 196703844,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1588802389
    },
    {
        "content": "<p>That at least is easy enough to fix post facto</p>",
        "id": 196703845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802389
    },
    {
        "content": "<p>The typeclass problems lean has to slog though are <em>gigantic</em></p>",
        "id": 196703941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802421
    },
    {
        "content": "<p>I don't think Coq does as much with dynamic tactics as lean</p>",
        "id": 196704130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802533
    },
    {
        "content": "<p>most tactics are implemented in ML, certainly any of the \"serious\" ones. This gives them a big performance advantage</p>",
        "id": 196704175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802571
    },
    {
        "content": "<p>Lean is definitely slow when you look at how many lines of source it goes through per second, but that is more reflective of the complexity of the problems it has set itself (dependent type theory, unification up to definitional reduction, typeclass searches all over the place, etc) than the implementation (which is quite efficient and well optimized)</p>",
        "id": 196704405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802720
    },
    {
        "content": "<p>Put another way, I think you would have a hard time beating lean at its own game, that is, an alternate lean typechecker. If you change the game then you can get huge (orders of magnitude) wins, but you won't see that with e.g. better allocation strategies</p>",
        "id": 196704571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588802826
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196703844\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196703844\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196703124\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196703124\">said</a>:</p>\n<blockquote>\n<p>Lean is <em>surprisingly</em> fast when you look at how much it is doing</p>\n</blockquote>\n<p>Is there any evidence for this? Coq also does typeclasses and tactic-based metaprogramming, and while Lean is not particularly slow, it also hasn't struck me as particularly fast. The mathlib compile times aren't great, but there is no direct comparison, so it's hard to evaluate these claims.</p>\n</blockquote>\n<p>Note that I include busywork in this sense of \"how much it is doing\". E.g. superman took 2 hours to cross the town, which doesn't sound fast until you realize he circled the world a hundred times first</p>",
        "id": 196705249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588803268
    },
    {
        "content": "<p>The gains in lean 4 for typeclass inference are solidly in the realm of \"eliminating busywork\"</p>",
        "id": 196705335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588803327
    },
    {
        "content": "<p>On typeclasses, it would be interesting to know how Coq fares on similarly sized problems. Afaict, their algorithms are very similar, at least until we get the tabled stuff.</p>\n<p>On tactics, Lean also delegates to C++ quite a bit; after all, the standard tactics library consists mainly of thin wrappers around C++. The big Coq projects (e.g. anything by Chiplala) also have a ton of custom Ltac, some of it very complex, so I'm not sure Lean is unique in this regard.</p>\n<p>I'm not saying that Lean is slow, and I certainly couldn't develop a faster Lean typechecker. But in the absence of evidence, I'll remain skeptical that it's significantly faster than the competition at similar tasks.</p>",
        "id": 196705440,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1588803394
    },
    {
        "content": "<p>Coq doesn't use typeclasses nearly as pervasively as mathlib. math-comp uses canonical instances instead, which solve the problem in a different way with more up front work for the user and a better asymptotic behavior for the problems generated</p>",
        "id": 196705571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588803495
    },
    {
        "content": "<p>I would bet that if you ported mathlib to coq, using coq typeclasses, lean would outperform coq</p>",
        "id": 196705654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588803564
    },
    {
        "content": "<p>Lean's tactic mode is also seemingly more flexible than Coq's. In Coq you just start every proof in tactic mode, term proofs seem to be rare, and they are built right into the grammar. By contrast, in lean a begin end block can be anywhere in the term, and when it hits one it translates the tactic block into a term (running the tactic parsers in the VM), typechecks the term, then evaluates the result (also in the VM), eventually calling back in to C++. This setup is a lot more flexible but it comes at a noticeable performance cost</p>",
        "id": 196706090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588803884
    },
    {
        "content": "<p>In any case, I'm just speculating, and I don't have enough experience with coq to make a strong argument</p>",
        "id": 196706229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588803979
    },
    {
        "content": "<p>Thanks for performance discussion! Very interesting for me as an ML person but back to declarative languages. </p>\n<p>I was asking because Isabelle has sledgehammers and they often suggest Isar proofs. Which seem to outline the general shape of proofs + are more readable which made me think that perhaps declarative languages are just as easy to proof search. Which lead to this discussion. Is that true for Lean too? Why are Isar proofs so readily avaiable by the sledgehammer?</p>",
        "id": 196707774,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1588805275
    },
    {
        "content": "<p>Sorry Brando, I'll stop hijacking your thread now. ;)</p>\n<p>For Sledgehammer, I'll try to summon <span class=\"user-mention\" data-user-id=\"121058\">@Jasmin Blanchette</span>; he can probably tell you whether Isar makes this sort of thing easier.</p>",
        "id": 196708183,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1588805568
    },
    {
        "content": "<p>As they say, when all you have is a hammer, everything looks like a nail. I think it finds declarative proofs because that's the way isabelle is designed to present proofs. The things the ATPs are solving are full proofs anyway; you can present those proofs however you like.</p>",
        "id": 196709087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588806406
    },
    {
        "content": "<p>Does <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span>'s Lean-hammer supply proofs?  What do those look like?</p>",
        "id": 196710438,
        "sender_full_name": "Jason Rute",
        "timestamp": 1588807569
    },
    {
        "content": "<p>I think from the point of view of AI, Lean has certain advantages and disadvantages:<br>\nAdvantages:</p>\n<ul>\n<li>It is very popular, partly because it has a lot of nice features which make proving things easy, and because it has a great active community.</li>\n<li>Lean has a lot of built in tools (like a tactic language, an io interface, a parser and a server) which make proof recording and interaction possible (not as nice as I'd like, but possible) without hacking the C++ code.</li>\n<li>It has a reasonable size library.</li>\n</ul>\n<p>Disadvanatages</p>\n<ul>\n<li>All those \"nice\" features make Lean hard to parse.  You can have <code>by</code> blocks in term mode in <code>calc</code> mode in <code>begin...end</code> blocks.  This makes proof recording and other data-gathering tasks difficult.  </li>\n<li>Also the behavior of tactics can change depending on attributes attached to theorems.</li>\n<li>There is nothing like it now, so it needs to be built from scratch.</li>\n<li>Everyone is telling me to wait for Lean 4 <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> but I don't listen.</li>\n</ul>",
        "id": 196711009,
        "sender_full_name": "Jason Rute",
        "timestamp": 1588808096
    },
    {
        "content": "<p>Also, this is really off-topic now, but as for speed and AI, I think I've found a performant way to interact with Lean as a gym environment and to call a trained AI from within Lean as a tactic.  I'm playing around with it more, but it requires some more engineering.  I think I'll have a prototype (only a subset of Lean tactics) in about 2 weeks.</p>",
        "id": 196711440,
        "sender_full_name": "Jason Rute",
        "timestamp": 1588808493
    },
    {
        "content": "<p>Ok, I think that last paragraph promises more than I intend.  I won't have DeepHOL for Lean (or even TacticToe for Lean) anytime soon, but I'm saying I think I've found a path to making them and I'll create a small demo of that path soon.</p>",
        "id": 196711679,
        "sender_full_name": "Jason Rute",
        "timestamp": 1588808652
    },
    {
        "content": "<p>Me when switching from <a href=\"#narrow/stream/113488-general/topic/Is.20.7B.2E.2E.2E.7D.20a.20tactic.3F\" title=\"#narrow/stream/113488-general/topic/Is.20.7B.2E.2E.2E.7D.20a.20tactic.3F\">Is {...} a tactic?</a> to this thread: <a href=\"https://i.gifer.com/7Cca.mp4\" title=\"https://i.gifer.com/7Cca.mp4\">https://i.gifer.com/7Cca.mp4</a></p>",
        "id": 196722939,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1588820911
    },
    {
        "content": "<p>Sledgehammer sometimes suggest Isar proofs because these can then follow the structure of the ATP proofs step by step. I don't see a good way to do this with only tactics -- you'd quickly get out of sync with the ATP proof. My JAR article \"Semi-intelligible ...\" shows some examples of ATP vs. Isar proofs.</p>",
        "id": 196728015,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1588828622
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196710438\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196710438\">said</a>:</p>\n<blockquote>\n<p>Does <span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span>'s Lean-hammer supply proofs?  What do those look like?</p>\n</blockquote>\n<p>I'm kind of waiting for Lean 4 at the moment, because I'm tired of the performance issues right now.  The tactic scripts it produces are of the form <code>by super [list, of, lemmas]</code> (where <code>super</code> is a first-order prover).  The proof terms produced by the tactic are semi-legible, at least you can make out the steps of the prover.</p>",
        "id": 196736933,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1588837830
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196711440\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196711440\">said</a>:</p>\n<blockquote>\n<p>Also, this is really off-topic now, but as for speed and AI, I think I've found a performant way to interact with Lean as a gym environment and to call a trained AI from within Lean as a tactic.  I'm playing around with it more, but it requires some more engineering.  I think I'll have a prototype (only a subset of Lean tactics) in about 2 weeks.</p>\n</blockquote>\n<p>I'd like to get involved in some way with your Lean + AI hacking (though I might miss messages in this stream because I'm can't figure out how to mute all the general things without muting this one).</p>",
        "id": 196996874,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1589038206
    },
    {
        "content": "<p>I'm trying to wrap my head around the discussion in the thread with respect to ATPs + Hammers + producing Declarative proofs in Lean. Is the consensus that it's not as straight forward as it is in Isabelle because Isabelle is by design intended to be a declarative ITP language?</p>",
        "id": 196996957,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1589038345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196711009\" title=\"#narrow/stream/113488-general/topic/Declarative.20Lean/near/196711009\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Lean has a lot of built in tools (like a tactic language, an io interface, a parser and a server) which make proof recording and interaction possible (not as nice as I'd like, but possible) without hacking the C++ code.</li>\n</ul>\n</blockquote>\n<p>This seems like a really big advantage from an ML perspective.</p>",
        "id": 196997213,
        "sender_full_name": "Brando Miranda",
        "timestamp": 1589038771
    }
]
[
    {
        "content": "<p>I'm trying to prove that \"P if and only if not P\" is a false statement without classical logic, but it's really kicking my [REDACTED]...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">iff.elim</span>\n        <span class=\"o\">(</span>\n            <span class=\"k\">assume</span> <span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n            <span class=\"k\">assume</span> <span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n            <span class=\"gr\">sorry</span> <span class=\"c1\">-- hmm...</span>\n        <span class=\"o\">)</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>It's <em>really easy</em> to do it with something like <code>by_cases</code> and stuff, but it's apparently possible without special functions like those? Not too sure; I'd like to see how it's done or at least a little nudge!</p>",
        "id": 251771899,
        "sender_full_name": "Kitty Gorey",
        "timestamp": 1630610645
    },
    {
        "content": "<p>Try proving not p</p>",
        "id": 251772802,
        "sender_full_name": "Anas Himmi",
        "timestamp": 1630611014
    },
    {
        "content": "<p>This is a popular question on Zulip, <a href=\"#narrow/stream/113489-new-members/topic/basics/near/185070320\">here's an old message</a> where I show how you can solve this one by \"chasing underscores\".</p>",
        "id": 251773024,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1630611114
    },
    {
        "content": "<p>Ah yes that's what I needed. I tried searching the problem up but not much came since this is a very specific problem.</p>",
        "id": 251775127,
        "sender_full_name": "Kitty Gorey",
        "timestamp": 1630611953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"435369\">Kitty Gorey</span> has marked this topic as resolved.</p>",
        "id": 251775136,
        "sender_full_name": "Notification Bot",
        "timestamp": 1630611956
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">iff.elim</span>\n        <span class=\"o\">(</span>\n            <span class=\"k\">assume</span> <span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n            <span class=\"k\">assume</span> <span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n            <span class=\"k\">have</span> <span class=\"n\">hnp</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n            <span class=\"k\">from</span>\n                <span class=\"k\">assume</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n                <span class=\"n\">hl</span> <span class=\"n\">hp</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n            <span class=\"n\">hnp</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"n\">hnp</span><span class=\"o\">)</span>\n        <span class=\"o\">)</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Got it!</p>",
        "id": 251775334,
        "sender_full_name": "Kitty Gorey",
        "timestamp": 1630612022
    },
    {
        "content": "<p>I'm curious though, how do we exactly determine whether or not a proof like \"<code>¬(p ∧ q) → ¬p ∨ ¬q</code>\" requires classical reasoning or not?</p>",
        "id": 251775698,
        "sender_full_name": "Kitty Gorey",
        "timestamp": 1630612177
    },
    {
        "content": "<p>One technique, which is sufficient but not necessary to prove that something can't be proved constructively, is to see if you can get it to fail in a topological model of logic where truth values are open sets and \"not\" is \"interior of complement\". For example you can see that not not p does not imply p constructively because there exists a topological space X and an open set U such that if V is the interior of the complement of U in X then the interior of the complement of V is not a subset of U (for example U could be open and dense but not all of X, then V is empty)</p>",
        "id": 251778435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630613269
    },
    {
        "content": "<p>That's very wacky; I didn't expect topology to be involved in this. I'll read some books, come back to this discussion month(s) later, and then finally be able to understand what all that meant!</p>",
        "id": 251781148,
        "sender_full_name": "Kitty Gorey",
        "timestamp": 1630614460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"435369\">Kitty Gorey</span> <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20How.20to.20prove.20.22.C2.AC.28p.20.E2.86.94.20.C2.ACp.29.22.20without.20classical.20reasoning.3F/near/251775698\">said</a>:</p>\n<blockquote>\n<p>I'm curious though, how do we exactly determine whether or not a proof like \"<code>¬(p ∧ q) → ¬p ∨ ¬q</code>\" requires classical reasoning or not?</p>\n</blockquote>\n<p>A relatively recent tactic that can answer this question is <code>itauto</code>: if a propositional formula is intuitionistically provable then <code>itauto</code> will find the proof</p>",
        "id": 251815392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630637248
    },
    {
        "content": "<p>it doesn't try to construct those wacky countermodels, but there is a paper proof that the algorithm is complete</p>",
        "id": 251815463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630637298
    },
    {
        "content": "<p>Besides topological models, Kripke frames are also used to model intuitionistic logic, and I believe that both finite and possibly-infinite Kripke frames are complete, meaning that a statement is intuitionistically valid iff it has no (finite) Kripke frame countermodel</p>",
        "id": 251815665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630637504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"435369\">@Kitty Gorey</span>  It might be worth mentioning that apart from specific models of constructive (i.e. intuisionistic, nonclassical) logic like topological models and Kripky frames, with statements like <code>¬(p ∧ q) → ¬p ∨ ¬q</code>, you can just use intuition about how constructive proofs work.  </p>\n<p>The main ideas are as follows for constructive proofs:</p>\n<ul>\n<li>A proof of <code>p ∧ q</code> is a proof of <code>p</code> and proof of <code>q</code>.</li>\n<li>A proof of <code>p ∨ q</code> is a proof of <code>p</code> or a proof of <code>q</code> and you know which one it is from the proof.  (This is different from classical logic where we can say have a proof of <code>p ∨ ¬p</code> without knowing anything about <code>p</code>.)</li>\n<li>A proof of  <code>p → q</code> is instructions on how to turn a proof of <code>p</code> into a proof of <code>q</code>.</li>\n<li>A proof of <code>¬p</code> is instructions on how to turn a proof of <code>p</code> into a proof of <code>false</code>.</li>\n<li>A proof of <code>false</code>... well there is no such thing, so if you can (vacuously) use a proof of <code>false</code> to prove anything.</li>\n</ul>\n<p>With this guidance, notice that <code>p ∨ q → q ∨ p</code> is constructively provable since from any proof of <code>p ∨ q</code> we get either a proof of <code>p</code> or a proof <code>q</code>.  Then we can use that to get a proof of <code>q ∨ p</code>.  But with <code>¬(p ∧ q) → ¬p ∨ ¬q</code>, if we have a proof of <code>¬(p ∧ q)</code>, then all we know is that <code>p</code> and <code>q</code> can't both have a proof (else we would prove <code>false</code>).  This won't help us in constructing a proof of <code>¬p</code> nor a proof of <code>¬q</code>.</p>\n<p>This is how I reason about these things in my head when I'm convincing myself that something requires classical logic to prove.</p>",
        "id": 251941312,
        "sender_full_name": "Jason Rute",
        "timestamp": 1630702814
    },
    {
        "content": "<p>But these general principles don't seem to tell me how to verify whether classically true statements such as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>can be proved constructively.</p>",
        "id": 251943856,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630704222
    },
    {
        "content": "<p>I think about it similarly to Jason, but I also look out for introduction and elimination. In your example, Kevin, the only way to introduce <code>Q</code> (<code>→ Q</code>) is the first hypothesis <code>P → P → Q</code>. So you apply it and you're left with <code>P</code> (twice, actually, but that doesn't matter), which can only be introduced (<code>→ P</code>) with the second hypothesis. So you apply it. You're left with <code>P → Q</code>, which is the first hypothesis once massaged. So you won.</p>",
        "id": 251944888,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1630704845
    },
    {
        "content": "<p>Hence solution is <code>λ h₁ h₂, h₁ (h₂ (λ p, h₁ p p)) (h₂ (λ p, h₁ p p))</code></p>",
        "id": 251945012,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1630704943
    },
    {
        "content": "<p>Exercise: <code>(P→Z)→(((P→Q)→Z)→Z)</code>. Is it constructive?</p>",
        "id": 251948915,
        "sender_full_name": "Jason Rute",
        "timestamp": 1630707266
    },
    {
        "content": "<p>My understanding about these systems of logic (if that's the right way to describe them) is still quite elementary. Is there a significant reason why we have constructive and classical logic \"separate\"?</p>",
        "id": 251953281,
        "sender_full_name": "Kitty Gorey",
        "timestamp": 1630710554
    },
    {
        "content": "<p>Practically, Lean’s foundations are naturally constructive.  Then we add a few axioms to make them classical.  Also, practically, the proof techniques that work for constructive reasoning also are the same techniques that you use for constructing elements of a type (this is the famous Curry-Howard isomorphism).  But other than that, I’d say it’s mostly an interesting tidbit, since the logic in Lean is fully classical.  (As for why constructive mathematics is interesting to some logicians, computer scientists, and mathematicians, that is a longer and more controversial subject.)</p>",
        "id": 251958047,
        "sender_full_name": "Jason Rute",
        "timestamp": 1630714736
    },
    {
        "content": "<p>I wouldn't say \"the logic in Lean is fully classical\", but rather \"the logic in mathlib is fully classical\".</p>",
        "id": 251959169,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1630715807
    },
    {
        "content": "<p>Proof irrelevance pushes Lean itself somewhat in the classical direction (i.e., HoTT is an undertaking).</p>",
        "id": 251959196,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1630715845
    },
    {
        "content": "<p>It seems like I've gotten myself into some hardcore math here. I originally just wanted to learn Lean so I can do the exercises in my topology and category theory book in a more rigorous way, but it looks like I'm going to have to dive into logic also. Any recommended resources like books or sites to nudge me in the right direction?</p>",
        "id": 251960032,
        "sender_full_name": "Kitty Gorey",
        "timestamp": 1630716713
    },
    {
        "content": "<p>(You only \"have to\" if you mean you're enjoying this deep dive into non-classical logic -- you don't need to know anything about it to use Lean/mathlib!)</p>",
        "id": 251960450,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630717059
    },
    {
        "content": "<p>I do not fear a challenge.</p>",
        "id": 251960511,
        "sender_full_name": "Kitty Gorey",
        "timestamp": 1630717099
    },
    {
        "content": "<p>That's fair. Just letting you know that it doesn't have to come first before working on formalizing topology or category theory.  There's a <em>lot</em> of math out there!</p>",
        "id": 251960658,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630717223
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20How.20to.20prove.20.22.C2.AC.28p.20.E2.86.94.20.C2.ACp.29.22.20without.20classical.20reasoning.3F/near/251948915\">said</a>:</p>\n<blockquote>\n<p>Exercise: <code>(P→Z)→(((P→Q)→Z)→Z)</code>. Is it constructive?</p>\n</blockquote>\n<p>If Q is false then we're asking if we can deduce Z from P-&gt;Z and (not P)-&gt;Z, and this sounds non-constructive to me. I guess I could write down a topological countermodel.</p>",
        "id": 252011529,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630773095
    },
    {
        "content": "<p>You can't intro P, so the first hypothesis <code>P → Z</code> is useless. Then you can only use the second hypothesis and the goal becomes <code>P → Q</code>. And you can't intro Q, so you're formally screwed.</p>",
        "id": 252014742,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1630776748
    },
    {
        "content": "<p>Yeah but that's just like saying \"I can't figure out how to do it, therefore it can't be done\". You can apply the same kind of arguments for the not (P iff not P) to \"prove\" it can't be done constructively.</p>",
        "id": 252016725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630778989
    },
    {
        "content": "<p>Considering open subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, setting <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo>∣</mo><mi>x</mi><mo>&gt;</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">P=\\{x\\mid x&gt;0\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">}</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi>x</mi><mo>∣</mo><mi>x</mi><mo>&lt;</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">Q=\\{x\\mid x &lt; 0\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">}</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi><mo>=</mo><mi mathvariant=\"normal\">∅</mi></mrow><annotation encoding=\"application/x-tex\">Z=\\emptyset</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.80556em;vertical-align:-0.05556em;\"></span><span class=\"mord\">∅</span></span></span></span>, then with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo lspace=\"0em\" rspace=\"0em\">∘</mo></msup></mrow><annotation encoding=\"application/x-tex\">A^{\\circ}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∘</span></span></span></span></span></span></span></span></span></span></span></span> denoting the interior and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mi>c</mi></msup></mrow><annotation encoding=\"application/x-tex\">A^c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span></span></span> denoting the complement:</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Z</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>P</mi><mi>c</mi></msup><mo>∪</mo><mi>Z</mi><msup><mo stretchy=\"false\">)</mo><mo>∘</mo></msup><mo>=</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">P\\to Z = (P^{c}\\cup Z)^\\circ = Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∘</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> is nonempty</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo>→</mo><mi>Q</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>Z</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><msup><mi>P</mi><mi>c</mi></msup><mo>∪</mo><mi>Q</mi><msup><mo stretchy=\"false\">)</mo><mrow><mo>∘</mo><mi>c</mi></mrow></msup><mo>∪</mo><mi>Z</mi><msup><mo stretchy=\"false\">)</mo><mo>∘</mo></msup><mo>=</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">(P \\to Q)\\to Z = ((P^c \\cup Q)^{\\circ c} \\cup Z)^\\circ = P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">((</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∘</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∘</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> is nonempty</li>\n<li>but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span> is empty.</li>\n</ul>",
        "id": 252016729,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630778992
    },
    {
        "content": "<p>That was a fun exercise -- for anyone who wants to look the relevant things up (as I needed to, to see how I'm supposed to interpret implication) some key words: Tarksi proved that logical formulae are intuitionistically valid if and only if there is no countermodel from a Heyting algebra of open sets of a topological space.</p>",
        "id": 252016929,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630779192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20How.20to.20prove.20.22.C2.AC.28p.20.E2.86.94.20.C2.ACp.29.22.20without.20classical.20reasoning.3F/near/252016725\">said</a>:</p>\n<blockquote>\n<p>\"I can't figure out how to do it, therefore it can't be done\".</p>\n</blockquote>\n<p>That sounds pretty intuitive to me! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 252016958,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630779233
    },
    {
        "content": "<p>The example I had in mind was P=Z open and dense, and Q empty.</p>",
        "id": 252017055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630779316
    },
    {
        "content": "<p>In this case just take Z to be \"P or not P\". Then the statement is equivalent to LEM so can't be proven.</p>\n<p>A similar trick works for \"not (p and q) =&gt; not p or nor q\" : take q to be not p and you get a weak form of LEM, namely \"not P or not not p\". This one is unprovable for the same reason as LEM (you can't determine the truth value of a general proposition).</p>\n<p>Indeed this is a general method for showing that mathematical statements are inherently non constructive: show that they prove some taboo like LEM.</p>",
        "id": 252017151,
        "sender_full_name": "David Wärn",
        "timestamp": 1630779421
    },
    {
        "content": "<p>It also works with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">}</span></span></span></span> with the discrete topology, letting <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">P=\\{1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mn>2</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">Q=\\{2\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">2</span><span class=\"mclose\">}</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi><mo>=</mo><mi mathvariant=\"normal\">∅</mi></mrow><annotation encoding=\"application/x-tex\">Z=\\emptyset</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.80556em;vertical-align:-0.05556em;\"></span><span class=\"mord\">∅</span></span></span></span>. (So plain old finite boolean algebras suffice here.)</p>",
        "id": 252017240,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630779514
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span>  does this imply a general hierarchy of \"weaker LEMs\"? ((n • ¬)p ∨ ([n + 1] • ¬)p) is what I have in my head); and are they all weaker than one another but not classically provable?</p>",
        "id": 252017444,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1630779728
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I took my example, removed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, since it didn't actually play a role, then quotiented both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> to a point, giving the two-point discrete topology.  Unless I made a mistake running through the equations (very possible), it seems to still work out.</p>",
        "id": 252017545,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630779842
    },
    {
        "content": "<p>We want P -&gt; Z, that is what's confusing me -- doesn't that mean \"P is a subset of Z\"?</p>",
        "id": 252017569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630779880
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/Heyting+algebra\">ncatlab</a> says it's translated as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>P</mi><mi>c</mi></msup><mo>∪</mo><mi>Z</mi><msup><mo stretchy=\"false\">)</mo><mo>∘</mo></msup></mrow><annotation encoding=\"application/x-tex\">(P^c\\cup Z)^\\circ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∘</span></span></span></span></span></span></span></span></span></span></span>, which I don't have much intuition for.  (I would have thought <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>P</mi><mrow><mi>c</mi><mo>∘</mo></mrow></msup><mo>∪</mo><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">P^{c \\circ}\\cup Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span><span class=\"mord mtight\">∘</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span>.)  It at least makes sense it's an open set.</p>",
        "id": 252017800,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630780131
    },
    {
        "content": "<p>Wikipedia helped with the intuition: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding=\"application/x-tex\">\\subseteq</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">⊆</span></span></span></span> is like the turnstile <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊢</mo></mrow><annotation encoding=\"application/x-tex\">\\vdash</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mrel\">⊢</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">P\\to Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> is supposed to satisfy the adjunction <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>⊆</mo><mo stretchy=\"false\">(</mo><mi>P</mi><mo>→</mo><mi>Q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R\\subseteq (P\\to Q)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\">)</span></span></span></span> iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>∩</mo><mi>P</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">R\\cap P\\subseteq Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span>, which if you squint looks like modus ponens.  The condition <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>∩</mo><mi>P</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">R\\cap P\\subseteq Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>⊆</mo><msup><mi>P</mi><mi>c</mi></msup><mo>∪</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">R\\subseteq P^c \\cup Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span>, so taking the union over all such open <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> that satisfy this, you get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">P \\to Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>P</mi><mi>c</mi></msup><mo>∪</mo><mi>Q</mi><msup><mo stretchy=\"false\">)</mo><mo>∘</mo></msup></mrow><annotation encoding=\"application/x-tex\">(P^c\\cup Q)^\\circ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∘</span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 252020057,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630782740
    },
    {
        "content": "<p>By the same logic/example <code>P -&gt; Q -&gt; (P and Q)</code> should be false, because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> are nonempty but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>∩</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">P \\cap Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> is empty.</p>",
        "id": 252022889,
        "sender_full_name": "Reid Barton",
        "timestamp": 1630785885
    },
    {
        "content": "<p>Instead what you want to do is take the denotation of the whole formula, and check whether it is all of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>.</p>",
        "id": 252022917,
        "sender_full_name": "Reid Barton",
        "timestamp": 1630785929
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20How.20to.20prove.20.22.C2.AC.28p.20.E2.86.94.20.C2.ACp.29.22.20without.20classical.20reasoning.3F/near/252017444\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span>  does this imply a general hierarchy of \"weaker LEMs\"? ((n • ¬)p ∨ ([n + 1] • ¬)p) is what I have in my head); and are they all weaker than one another but not classically provable?</p>\n</blockquote>\n<p>There is a general hierarchy of weaker LEMs, but this isn't it; it bottoms out at <code>¬p \\/ ¬¬p</code> because if you add one more not then it starts cancelling because <code>¬¬¬p &lt;-&gt; ¬p</code> intuitionistically</p>",
        "id": 252024476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630787593
    },
    {
        "content": "<p>See the <a href=\"https://en.wikipedia.org/wiki/Intuitionistic_logic#/media/File:Rieger-Nishimura.svg\">Rieger–Nishimura lattice</a>. Of the pictured nodes, all of them are classically true except for the bottom four nodes <code>bot</code>, <code>p</code>, <code> ¬p</code>, <code> ¬¬p</code>.</p>",
        "id": 252024545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630787664
    },
    {
        "content": "<p>That the lattice is infinite also shows that intuitionistic logic does not have any complete finite truth table semantics</p>",
        "id": 252024909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630788109
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, I hadn't grasped how modus ponens was supposed to work.  Correction, using <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s example:</p>\n<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\Sigma=\\{0,1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Σ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> be the Sierpinski space, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> is the nontrivial open set.  Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>=</mo><mi>Z</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">P=Z=\\{1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi><mo>=</mo><mi mathvariant=\"normal\">∅</mi></mrow><annotation encoding=\"application/x-tex\">Q=\\emptyset</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.80556em;vertical-align:-0.05556em;\"></span><span class=\"mord\">∅</span></span></span></span>.  Then</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Z</mi><mo>=</mo><mi mathvariant=\"normal\">Σ</mi></mrow><annotation encoding=\"application/x-tex\">P\\to Z = \\Sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Σ</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Q</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi>P</mi><mi>c</mi></msup><mo>∪</mo><mi>Q</mi><msup><mo stretchy=\"false\">)</mo><mo>∘</mo></msup><mo>=</mo><mo stretchy=\"false\">{</mo><mn>0</mn><msup><mo stretchy=\"false\">}</mo><mo>∘</mo></msup><mo>=</mo><mi mathvariant=\"normal\">∅</mi></mrow><annotation encoding=\"application/x-tex\">P \\to Q = (P^c\\cup Q)^\\circ = \\{0\\}^\\circ = \\emptyset</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∘</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mclose\"><span class=\"mclose\">}</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∘</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.80556em;vertical-align:-0.05556em;\"></span><span class=\"mord\">∅</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo>→</mo><mi>Q</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>Z</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi mathvariant=\"normal\">∅</mi><mi>c</mi></msup><mo>∪</mo><mi>Z</mi><msup><mo stretchy=\"false\">)</mo><mo>∘</mo></msup><mo>=</mo><mi mathvariant=\"normal\">Σ</mi></mrow><annotation encoding=\"application/x-tex\">(P \\to Q)\\to Z = (\\emptyset^c\\cup Z)^\\circ = \\Sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">∅</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∘</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Σ</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>P</mi><mo>→</mo><mi>Q</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>Z</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>Z</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi mathvariant=\"normal\">Σ</mi><mi>c</mi></msup><mo>∪</mo><mi>Z</mi><msup><mo stretchy=\"false\">)</mo><mo>∘</mo></msup><mo>=</mo><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">((P \\to Q)\\to Z) \\to Z = (\\Sigma^c\\cup Z)^\\circ = Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">((</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∘</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo>→</mo><mi>Z</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>P</mi><mo>→</mo><mi>Q</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>Z</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>Z</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msup><mi mathvariant=\"normal\">Σ</mi><mi>c</mi></msup><mo>∪</mo><mi>Z</mi><msup><mo stretchy=\"false\">)</mo><mo>∘</mo></msup><mo>=</mo><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">(P \\to Z) \\to ((P \\to Q)\\to Z) \\to Z = (\\Sigma^c \\cup Z)^\\circ = Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">((</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.674115em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∘</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span>, which isn't all of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi></mrow><annotation encoding=\"application/x-tex\">\\Sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Σ</span></span></span></span>.</li>\n</ul>",
        "id": 252025318,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630788600
    },
    {
        "content": "<p>Also, the <a href=\"https://en.wikipedia.org/wiki/Kuratowski%27s_closure-complement_problem\">Kuratowski 14-set theorem</a> implies that topological models of intuitionistic logic are also incomplete, since you can only get 14 distinct sets from topological operations on a single seed set</p>",
        "id": 252026301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630789654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20How.20to.20prove.20.22.C2.AC.28p.20.E2.86.94.20.C2.ACp.29.22.20without.20classical.20reasoning.3F/near/252016725\">said</a>:</p>\n<blockquote>\n<p>Yeah but that's just like saying \"I can't figure out how to do it, therefore it can't be done\". You can apply the same kind of arguments for the not (P iff not P) to \"prove\" it can't be done constructively.</p>\n</blockquote>\n<p>No, that's wrong. For <code>¬(p ↔ ¬p)</code>, you can definitely intro <code>false</code> using <code>p → p → false</code>. Then you need <code>p</code> (twice), and you go on. I'm explaining how to explore the proposition maze. And that's the same as a constructive proof.</p>",
        "id": 252059138,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1630828754
    },
    {
        "content": "<p>Your last sentence is precisely what's not clear to me (in the sense that I feel it needs proof). Just because you \"look stuck\" doesn't mean you <em>are</em> stuck because you can always proceed with \"have &lt;random new thing&gt;, from ...\"</p>",
        "id": 252060900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630830739
    },
    {
        "content": "<p>For example I would even argue that <code>example : P -&gt; Q</code> needs justification that it's not solvable constructively (eg with a countermodel) -- you seem to be saying it's \"obvious\" that this can't be proved and I'm saying that I want to see some sort of formal argument. For all I know <code>example : P</code> can be solved via some elaborate argument somehow -- it's your job to prove that it can't be, rather than just saying \"we obviously can't make progress here\" -- I don't think this is obvious.</p>",
        "id": 252061022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630830908
    },
    {
        "content": "<p>I'm assuming all we have is in the hypotheses. If we already have theorems having <code>P</code> and <code>Q</code>, fine. Take them as hypotheses and solve the maze from there.</p>",
        "id": 252061115,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1630831008
    },
    {
        "content": "<p>My main claim is that, if you can't introduce P, then you can't prove P.</p>",
        "id": 252061164,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1630831082
    },
    {
        "content": "<p>And I'm saying that this is not obvious to me because maybe you can start with <code>have h : P -&gt; Q -&gt; P</code> which you can prove and which implies P, and then maybe you can go on from there to <code>have h2 : &lt;gigantic term&gt;</code> and then maybe some miracle occurs later. We know it doesn't but if you had to formalise your argument you'd have to deal with this possibility. On the other hand, the countermodel argument can easily be formalised.</p>",
        "id": 252061769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630831774
    },
    {
        "content": "<p>Well what I'm saying is quite obvious: If no function goes <code>→ P</code>, then the only way to construct <code>p : P</code> is to already have <code>p : P</code>. What's not clear is which functions you should look after. I claim that looking at the hypotheses is enough for these simple logic puzzles, but this is already much less obvious.</p>",
        "id": 252062152,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1630832209
    },
    {
        "content": "<p>I think we should probably take this offline. What I'm saying is that formally I don't find it obvious that <code>example : P</code> cannot be proven constructively whereas as you seem to think this is somehow obvious. I can only prove this using a countermodel.</p>",
        "id": 252064216,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630834578
    },
    {
        "content": "<p>I assume you're saying you'd want the explicit proof <code>example : (∀ (P : Prop), P) → (∀ X, nonempty X → X) := λ f, (f false).elim</code></p>",
        "id": 252064337,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630834747
    },
    {
        "content": "<p>Yael's argumentation can be made formal using parametricity, e.g. as popularized by Wadler's \"Theorems for free!\" paper. Namely, a term in polymorphic lambda calculus of the type <code>∀ x, F x → G x</code> has to be natural in <code>x</code>. For example, taking <code>T x := x → x</code>, we have that any term <code>t : ∀ x, x → x</code> must be in fact equal to the identity function.</p>",
        "id": 252064953,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630835524
    },
    {
        "content": "<p>So up to normalization, the only thing that you can do to prove something of the form <code>∀ P, ... → P</code> constructively, is to find a hypothesis with conclusion <code>P</code> and apply it.</p>",
        "id": 252065080,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630835691
    },
    {
        "content": "<p>This is what I was missing..</p>",
        "id": 252065263,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630835884
    },
    {
        "content": "<p>But why can't you just prove a new hypothesis with conclusion P and some more complex hypotheses? This is the sticking point for me</p>",
        "id": 252065276,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630835915
    },
    {
        "content": "<p>Those more complex hypotheses must depend on <code>P</code>. Namely, suppose we have a term <code>t : ∀ P, Q → P</code>, where <code>Q</code> is an arbitrary type not depending on <code>P</code>. (BTW, this is still constructive! <code>Q</code> is a finite expression, so we can easily check if <code>P</code> appears.) Then <code>t</code> is a natural transformation from the functor <code>const Q</code> to the identity functor, therefore we have for all <code>P</code> and <code>f : P → P</code> that <code>t \\comp id = f \\circ t</code>. Take <code>P := Prop</code>, <code>f = not</code> and you get a contradiction.</p>",
        "id": 252065684,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630836366
    },
    {
        "content": "<p>So by induction on the structure of <code>Q</code> we can be sure there is some <code>_ → P</code> in there.</p>",
        "id": 252065746,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630836459
    },
    {
        "content": "<p>Here we really need that <code>Q</code> is finite, otherwise you can do general recursion, so your proofs don't terminate.</p>",
        "id": 252065832,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630836554
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 252065845,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1630836574
    },
    {
        "content": "<p>No problem! <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 252065934,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630836668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Another keyword to look for here is the \"subformula property\", which says that if a proof exists then there is also a proof that only uses intermediate steps whose statements are subformulas of the goal. Not all logics have the subformula property, but intuitionistic logic, presented i the right way, does. This yields a decision procedure where you just make a list of all subformulas, and mark all the axioms, then identify which follow from known true things and mark them as true as well, and keep going until you can't mark anything else as true based on what you know; if your goal is not true yet then it can't be proved.</p>",
        "id": 252073307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630844830
    },
    {
        "content": "<p>AFAIK, <a href=\"https://www.cs.cmu.edu/~fp/courses/atp/cmuonly/D92.pdf\">https://www.cs.cmu.edu/~fp/courses/atp/cmuonly/D92.pdf</a> describes another decision procedure in details</p>",
        "id": 252073581,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1630845061
    },
    {
        "content": "<p>LJT is a different algorithm, I'm describing one that works forward instead of backward</p>",
        "id": 252073663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630845132
    },
    {
        "content": "<p>s/the decision procedure/another decision procedure</p>",
        "id": 252073675,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1630845147
    },
    {
        "content": "<p>The key point that the subformula property tells you is that proving random lemmas in the middle of the proof is no help</p>",
        "id": 252073748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630845203
    },
    {
        "content": "<p>which is definitely not a priori obvious</p>",
        "id": 252073770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630845234
    },
    {
        "content": "<p>I admit I haven't followed this thread carefully enough to be clear about exactly what is being claimed so I hope this isn't a ridiculous question: isn't it necessary to assume consistency somewhere?</p>",
        "id": 252074107,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1630845561
    },
    {
        "content": "<p>It's clear to me where this is when we use a counterexample: we're assuming the (presumably stronger) logic in which the counterexample lives is consistent. But if we never step outside the intuitionistic logic and nevertheless deduce we cannot prove something (that happens to be true with LEM) do we just assume the intuitionistic logic itself is consistent somewhere?</p>",
        "id": 252074126,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1630845578
    },
    {
        "content": "<p>That intuitionistic propositional logic is consistent is a fairly uncontroversial statement because it is weaker than classical propositional logic and that has a model with two elements</p>",
        "id": 252074208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630845640
    },
    {
        "content": "<p>Right: to be clear, personally I have absolutely no doubt that it is consistent. I'm just wondering how we escape from Godel formally.</p>",
        "id": 252074232,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1630845678
    },
    {
        "content": "<p>all the proof theory about prop calc lives in a mathematical environment that can't help but validate the consistency of these theories outright</p>",
        "id": 252074305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630845735
    },
    {
        "content": "<p>It's <em>propositional</em> logic. Without predicates you can't really do induction, so no natural numbers, so no Gödel formula</p>",
        "id": 252074309,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630845739
    },
    {
        "content": "<p>Oh I see, thanks.</p>",
        "id": 252074315,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1630845754
    },
    {
        "content": "<p>At least, the polymorphic λ calculus is.</p>",
        "id": 252074323,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630845767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20How.20to.20prove.20.22.C2.AC.28p.20.E2.86.94.20.C2.ACp.29.22.20without.20classical.20reasoning.3F/near/252065684\">said</a>:</p>\n<blockquote>\n<p>Those more complex hypotheses must depend on <code>P</code>. Namely, suppose we have a term <code>t : ∀ P, Q → P</code>, where <code>Q</code> is an arbitrary type not depending on <code>P</code>. (BTW, this is still constructive! <code>Q</code> is a finite expression, so we can easily check if <code>P</code> appears.) Then <code>t</code> is a natural transformation from the functor <code>const Q</code> to the identity functor, therefore we have for all <code>P</code> and <code>f : P → P</code> that <code>t \\comp id = f \\circ t</code>. Take <code>P := Prop</code>, <code>f = not</code> and you get a contradiction.</p>\n</blockquote>\n<p>The remark about consistency reminded me I forgot to mention <code>Q</code> needs to be inhabited for this reasoning to work. If <code>Q := ⊥</code>, then of course all maps out of <code>Q</code> are the same so there is no contradiction. Which is why <code>∀ P, ⊥ → P</code> is still provable without \"really\" applying a hypothesis with conclusion <code>P</code>.</p>",
        "id": 252074667,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630846137
    },
    {
        "content": "<p>(But to even state that rule, we need to extend the λ calculus to a non-<code>→</code> fragment of logic. And you would still need to apply the axiom <code>exfalso : ∀ P, ⊥ → P</code>, again something with conclusion <code>P</code>.)</p>",
        "id": 252074967,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630846463
    },
    {
        "content": "<p>Oh wow, that's very interesting! Thanks Anne</p>",
        "id": 252097130,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1630870760
    }
]
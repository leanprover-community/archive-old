[
    {
        "content": "<p>Is there a good way to make a class which is just the intersection of two other classes?  For example here I have two classes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">left_unital</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span> <span class=\"n\">left_unit</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n  <span class=\"o\">(</span> <span class=\"n\">left_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">bin</span> <span class=\"n\">left_unit</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">right_unital</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span> <span class=\"n\">right_unit</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n  <span class=\"o\">(</span> <span class=\"n\">right_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">bin</span> <span class=\"n\">a</span> <span class=\"n\">right_unit</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">)</span>\n</code></pre></div>\n<p>Now since most things are both left and right unital, you get really tired of writing <code>left_unital</code>, and <code>right_unital</code> every-time you want to say that something is both.  So I would like to make a new class <code>unital</code> which encompasses both of them.  I can do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">unital</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">left_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">right_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">left_right_unital</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">left_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">right_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">unital</span> <span class=\"n\">bin</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨⟩</span>\n</code></pre></div>\n<p>But the compiler seems to have issues with inference here, and very few things using this new class compile at all.  Now in Haskell I can do something like</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"cm\">{-# Language ConstraintKinds #-}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">Unital</span> <span class=\"n\">a</span> <span class=\"ow\">=</span>\n  <span class=\"p\">(</span> <span class=\"kt\">LeftUnital</span> <span class=\"n\">a</span>\n  <span class=\"p\">,</span> <span class=\"kt\">RightUnital</span> <span class=\"n\">a</span>\n  <span class=\"p\">)</span>\n</code></pre></div>\n<p>where <code>unital</code> isn't really a class of it's own it's just a synonym for the two.  Is there a best practice or idiomatic way to do this?</p>",
        "id": 264207950,
        "sender_full_name": "É Olive",
        "timestamp": 1638991992
    },
    {
        "content": "<p>There are several ways to do it, with different consequences in terms of how much memory things take up internally. If this is just for a small project you could do <code>set_option old_structure_cmd true</code>, define a class <code>has_bin</code> which is just <code>bin</code>, let <code>left_unital</code> and <code>right_unital</code> both extend it, and then let <code>unital</code> extend both.</p>",
        "id": 264208444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1638992191
    },
    {
        "content": "<p>Oh sorry I've just seen that you've not bundled <code>bin</code> so what I said above was inaccurate -- in your case can't you just let <code>unital</code> <code>extend</code> <code>left_unital</code> and <code>right_unital</code>?</p>",
        "id": 264208671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1638992291
    },
    {
        "content": "<p>When I do that it seems to have trouble synthesizing the constituent instances every time I use it.  For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">unit</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">left_unit</span> <span class=\"n\">bin</span>\n</code></pre></div>\n<p>Has errors trying to synthesize both, and works fine when I split it up into requiring both separately.  Maybe this is not how I should invoke it?</p>",
        "id": 264208957,
        "sender_full_name": "É Olive",
        "timestamp": 1638992433
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>A complete mwe in case I am misunderstanding your suggestion</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">test</span>\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">left_unital</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span> <span class=\"n\">left_unit</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n  <span class=\"o\">(</span> <span class=\"n\">left_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">bin</span> <span class=\"n\">left_unit</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">left_unital</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">right_unital</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span> <span class=\"n\">right_unit</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n  <span class=\"o\">(</span> <span class=\"n\">right_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">bin</span> <span class=\"n\">a</span> <span class=\"n\">right_unit</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">right_unital</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">unital</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">left_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">right_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">left_right_unital</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">left_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">right_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">unital</span> <span class=\"n\">bin</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">unit</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">left_unit</span> <span class=\"n\">bin</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">test</span>\n</code></pre></div>\n</div></div>",
        "id": 264209882,
        "sender_full_name": "É Olive",
        "timestamp": 1638992844
    },
    {
        "content": "<p>Ah I am misunderstanding there is an <code>extends</code> keyword which does that.  I don't know what I was doing, but it wasn't extending.</p>",
        "id": 264210454,
        "sender_full_name": "É Olive",
        "timestamp": 1638993083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448275\">É Olive</span> has marked this topic as resolved.</p>",
        "id": 264210461,
        "sender_full_name": "Notification Bot",
        "timestamp": 1638993086
    },
    {
        "content": "<p>For the record, what you are doing is called \"unbundled typeclasses\", which work fine in principle, but you need to include all the parameters to <code>unital</code> when you reference it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">test</span>\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">left_unital</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span> <span class=\"n\">left_unit</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n  <span class=\"o\">(</span> <span class=\"n\">left_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">bin</span> <span class=\"n\">left_unit</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">left_unital</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">right_unital</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span> <span class=\"n\">right_unit</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n  <span class=\"o\">(</span> <span class=\"n\">right_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">bin</span> <span class=\"n\">a</span> <span class=\"n\">right_unit</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">right_unital</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">unital</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">left_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">right_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">left_right_unital</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">left_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">right_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">unital</span> <span class=\"n\">bin</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">unit</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">left_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">right_unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">unital</span> <span class=\"n\">bin</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">left_unit</span> <span class=\"n\">bin</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">test</span>\n</code></pre></div>\n<p>There are some technical reasons that <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> suggested to \"bundle\" <code>bin</code> into your classes, as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">test</span>\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">left_unital</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span> <span class=\"n\">left_unit</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span> <span class=\"n\">left_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">bin</span> <span class=\"n\">left_unit</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">left_unital</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">right_unital</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span> <span class=\"n\">right_unit</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span> <span class=\"n\">right_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">bin</span> <span class=\"n\">a</span> <span class=\"n\">right_unit</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">right_unital</span>\n\n<span class=\"c1\">-- For the conjunction we have two options:</span>\n<span class=\"c1\">-- Easy but slow on Mathlib's scale:</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n<span class=\"kd\">class</span> <span class=\"n\">unital</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">left_unital</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">right_unital</span> <span class=\"n\">α</span>\n\n<span class=\"c1\">-- More work but is faster for computing (at least, that's what they told me)</span>\n<span class=\"kd\">class</span> <span class=\"n\">unital'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">left_unital</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span> <span class=\"n\">right_unit</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span> <span class=\"n\">right_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">bin</span> <span class=\"n\">a</span> <span class=\"n\">right_unit</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">unital'.to_right_unital</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">unital</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">right_unital</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">bin</span> <span class=\"o\">:=</span> <span class=\"n\">left_unital.bin</span><span class=\"o\">,</span>\n  <span class=\"n\">right_unit</span> <span class=\"o\">:=</span> <span class=\"n\">right_unit</span><span class=\"o\">,</span>\n  <span class=\"n\">right_id</span> <span class=\"o\">:=</span> <span class=\"n\">right_id</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Making the following an instance will cause a loop `unital → left_unital → unital → ...`,</span>\n<span class=\"c1\">-- So we'll have to make `unital` instances manually.</span>\n<span class=\"kd\">def</span> <span class=\"n\">left_right_unital</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">left_unital</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">right_unital</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">left_unital.bin</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">right_unital.bin</span> <span class=\"n\">α</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">unital</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span> <span class=\"c1\">-- exercise for the reader :-)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">unit</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">unital</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">left_unit</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">test</span>\n</code></pre></div>\n<p>Reason 1 is that unbundled definitions cause an exponential growth in the size of expressions in certain circumstances (e.g. if you define a <code>unital ((+) : ℤ^n → ℤ^n → ℤ^n)</code> instance by recursion on <code>n</code>.)</p>\n<p>Reason 2 is that it becomes really hard to automatically apply lemmas like <code>right_id</code>: it has the shape <code>?f ?a right_unit = ?a</code>, where <code>?f</code> is an arbitrary function, this is extremely underdetermined!</p>",
        "id": 264233876,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639004601
    },
    {
        "content": "<p>So in practice, the mathlib community uses bundled instances whenever new notation is introduced (like your <code>bin</code>, <code>left_unit</code>, <code>right_unit</code>), and tries to do so when it doesn't cause too much extra work.</p>",
        "id": 264234104,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639004761
    },
    {
        "content": "<p>To be clear, I'm not saying you have to change your approach! Just wanted to warn you where the issues lie.</p>",
        "id": 264234239,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639004829
    },
    {
        "content": "<p>Yeah, I've noticed some issues with the unbundled definitions, including a rather nasty resolution loop.  But (correct me if I'm wrong) it seems that I need to unbundle them if I say want to define multiple instances over a structure, e.g. for a non-abelian group G and G^op.  It also just from a mathematical standpoint that unital is a property of a function rather than of a type, and I am want to value prettiness over efficiency.  I'm going to try to continue like this and see at least how feasible it is, I may already be meeting it's end before I'm even done with groups.</p>",
        "id": 264238472,
        "sender_full_name": "É Olive",
        "timestamp": 1639007760
    },
    {
        "content": "<p>I feel like a broken record saying this, but you can also just not use type classes at all (and instead use <code>structure</code>, say).</p>",
        "id": 264249198,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639017110
    },
    {
        "content": "<p>How would I use structures here?  If I understand structures they are basically records.  I feel like I would need like row polymorphism.  Is there any resource on how these can be used properly to emulate classes?</p>",
        "id": 264329476,
        "sender_full_name": "É Olive",
        "timestamp": 1639068466
    },
    {
        "content": "<p>Use <code>structure</code> instead of <code>class</code>, and explicit arguments instead of <code>[]</code> ones</p>",
        "id": 264338548,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639072000
    },
    {
        "content": "<p>Hm.  there's no way to enforce uniqueness on the structures though right?  That's kind of the point it would seem.</p>",
        "id": 264341513,
        "sender_full_name": "É Olive",
        "timestamp": 1639073137
    },
    {
        "content": "<p>Why does that matter?</p>",
        "id": 264343429,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639073800
    },
    {
        "content": "<p>I'd like to be able to distinguish between defining fields and derived fields.  Like for example when I define group <code>neg</code> should be dependent on other fields not independent.</p>",
        "id": 264343863,
        "sender_full_name": "É Olive",
        "timestamp": 1639073969
    },
    {
        "content": "<p>There are other issues with <code>structure</code> anyway.  I think I'll go back to classes for now, but maybe in the long term I need to switch over to something more mathematically oriented than Lean.</p>",
        "id": 264344023,
        "sender_full_name": "É Olive",
        "timestamp": 1639074031
    },
    {
        "content": "<p>You know that a field can have a default value, right? That way you can have a derived field, if I understand what you mean by that</p>",
        "id": 264350583,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639076666
    },
    {
        "content": "<p>Classes are structures, just with an extra attribute turned on. They are just made available to the typeclass search and cache system when that attribute is on.</p>",
        "id": 264350687,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639076708
    },
    {
        "content": "<p>I just don't think either option is really working.  I'm kind of tired with working with lean at this point tbh.  I'm just going to switch over to Agda which lets me do what I want without pain.</p>",
        "id": 264352764,
        "sender_full_name": "É Olive",
        "timestamp": 1639077629
    },
    {
        "content": "<p>What makes agda \"more mathematically oriented than lean\" to you? From my perspective there seems to be a huge amount of the type of mathematics you are looking at successfully formalized in lean</p>",
        "id": 264354099,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1639078265
    },
    {
        "content": "<p>My feeling is that Agda is more rooted in type theory.  I'm sure Lean is justified in type theory but Agda seems to put the mathematics first which makes constructing feel more mathematical.  he existing formalizations seem like they are tweaked so that they play nice with Lean's quirks.  I'm obviously not unbiased here, I like Agda quite a bit more than Lean so it's only natural that I find making things in Agda more straightforward in general.</p>",
        "id": 264355001,
        "sender_full_name": "É Olive",
        "timestamp": 1639078700
    },
    {
        "content": "<p>I'm struggling to work out what behavior you want here. What was unsatisfactory with the <code>class unital (bin) extends left_unital bin, right_unital bin</code> suggestion earlier?</p>",
        "id": 264358002,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639080002
    },
    {
        "content": "<p>(and can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> to demonstrate what you consider to be awkward)</p>",
        "id": 264358162,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639080037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20class.20synonyms/near/264358162\">said</a>:</p>\n<blockquote>\n<p>(and can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> to demonstrate what you consider to be awkward)</p>\n</blockquote>\n<p>So with the <code>structure</code> I keep running into diamond inheritance problems.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>mwe</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">magma</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span> <span class=\"n\">bin</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">magma</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">left_unital</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">magma</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span> <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n  <span class=\"o\">(</span> <span class=\"n\">left_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">bin</span> <span class=\"n\">unit</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">right_unital</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">magma</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span> <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">)</span>\n  <span class=\"o\">(</span> <span class=\"n\">right_id</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">bin</span> <span class=\"n\">a</span> <span class=\"n\">unit</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">unit_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">left_unital</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">right_unital</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">left.unit</span> <span class=\"bp\">=</span> <span class=\"n\">right.unit</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">conv</span>\n    <span class=\"o\">{</span> <span class=\"n\">to_rhs</span>\n    <span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">left.left_id</span> <span class=\"o\">(</span><span class=\"n\">right.unit</span><span class=\"o\">)</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">,</span> <span class=\"n\">conv</span>\n    <span class=\"o\">{</span> <span class=\"n\">to_lhs</span>\n    <span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">right.right_id</span> <span class=\"o\">(</span><span class=\"n\">left.unit</span><span class=\"o\">)</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n</div></div>\n<p>Of course this specific one I can resolve it by getting rid of the magma.  However when I get up to loop, monoid etc, I start getting diamond inheritance that is much more difficult to resolve.</p>\n<p>I'll try to produce a mwe for the class issues I was running into, but a big struggle with classes was just the notational hassle.</p>",
        "id": 264360674,
        "sender_full_name": "É Olive",
        "timestamp": 1639081213
    },
    {
        "content": "<p>The statement of <code>unit_eq</code> is false because the two <code>bin</code>s don't agree, which I guess is what you're saying is your problem</p>",
        "id": 264421646,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639128726
    },
    {
        "content": "<p>Either you need to add a <code>left.bin = right.bin</code> hypothesis, or you need to change <code>left_unital</code> and <code>right_unital</code> to take <code>bin</code> as part of the type, as you did in your earlier posts</p>",
        "id": 264421728,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639128785
    },
    {
        "content": "<p>Hm.  Adding <code>bin</code> to the type was what I meant by \"getting rid of the magma\", I just set it up like that for the purposes of mwe.  But <code>left.bin=right.bin</code> is interesting.  I've already moved over to Agda though so I probably won't be switching back.</p>",
        "id": 264523492,
        "sender_full_name": "É Olive",
        "timestamp": 1639178802
    },
    {
        "content": "<p>What does your version of that <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> in agda look like?</p>",
        "id": 264527208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639181164
    }
]
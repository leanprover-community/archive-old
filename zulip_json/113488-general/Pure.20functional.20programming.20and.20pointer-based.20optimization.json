[
    {
        "content": "<p>Hi all! Here's a shameless plug of a paper I wrote with <span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> and <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> about programming techniques that can sometimes get us exponential speedups on functional programs written on expressions. Comments and questions welcome.</p>\n<p><a href=\"https://arxiv.org/abs/2003.01685\" target=\"_blank\" title=\"https://arxiv.org/abs/2003.01685\">https://arxiv.org/abs/2003.01685</a></p>",
        "id": 189663010,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583300913
    },
    {
        "content": "<p>The techniques are more generally applicable than for writing theorem provers, I should add</p>",
        "id": 189663078,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583301017
    },
    {
        "content": "<p>Is there a reason that functions like <code>withPtrAddr</code> are written in CPS rather than returning a <code>Squash Addr</code>?</p>",
        "id": 189663746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583302096
    },
    {
        "content": "<p>In your <code>PtrCache</code> example, it appears to be impossible to prove that the item you placed is still in the same location when you retrieve it later</p>",
        "id": 189663884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583302219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189663884\" title=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189663884\">said</a>:</p>\n<blockquote>\n<p>In your <code>PtrCache</code> example, it appears to be impossible to prove that the item you placed is still in the same location when you retrieve it later</p>\n</blockquote>\n<p>That's true and we're going to get duplicates if looking up two objects encoding the same value. That's one possible trade-off we can choose and it can be very appealing to pay the price</p>",
        "id": 189663991,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583302328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189663746\" title=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189663746\">said</a>:</p>\n<blockquote>\n<p>Is there a reason that functions like <code>withPtrAddr</code> are written in CPS rather than returning a <code>Squash Addr</code>?</p>\n</blockquote>\n<p>I don't think we have considered <code>Squash Addr</code>. Do you see a benefit to encoding it that way?</p>",
        "id": 189664008,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583302369
    },
    {
        "content": "<p>it's more direct; it will probably get optimized away regardless of how it's written</p>",
        "id": 189664026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583302416
    },
    {
        "content": "<p>but with the <code>Squash Addr</code> approach it seems more likely that you could exploit common subexpression elimination</p>",
        "id": 189664087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583302463
    },
    {
        "content": "<p>In the context that we studied, we needed the value of the pointer at the same time that we were producing the value so we're pretty much merging <code>ptrAddr</code> and <code>Squash.lift</code></p>",
        "id": 189664229,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583302586
    },
    {
        "content": "<p>Sure, but in general you can do other things with the value rather than examine it immediately, e.g. you could store it in a data structure</p>",
        "id": 189664260,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583302639
    },
    {
        "content": "<p>Since <code>Squash Addr</code> is just an int, it lowers to C very directly</p>",
        "id": 189664270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583302665
    },
    {
        "content": "<p>What's the status of mutable cells in lean 4 (a la my lean 3 <code>cached</code> proposal)? This stuff looks really close to finally having proper thunks</p>",
        "id": 189664322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583302704
    },
    {
        "content": "<p>(BTW you can still use <code>withPtrAddr</code> as a \"get pointer value\" function if you call <code>withPtrAddr x Squash.mk</code>)</p>",
        "id": 189664369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583302785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189664270\" title=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189664270\">said</a>:</p>\n<blockquote>\n<p>Since <code>Squash Addr</code> is just an int, it lowers to C very directly</p>\n</blockquote>\n<p>I'd love to see an example of that if you find one. My intuition is that it's going to be hard to make use of the pointer long term because globally, we can't even prove that two objects are equal if their addresses are equal</p>",
        "id": 189664418,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583302822
    },
    {
        "content": "<p>You are right, it is subject to the same limitations as <code>PtrCache</code> that I mentioned above. This <code>getPtr</code> function has properties that can be exploited but cannot be expressed in lean, so it will be possible to write correct programs (using only safe code) that cannot be proven correct</p>",
        "id": 189664495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583302932
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189664322\" title=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189664322\">said</a>:</p>\n<blockquote>\n<p>What's the status of mutable cells in lean 4 (a la my lean 3 <code>cached</code> proposal)? This stuff looks really close to finally having proper thunks</p>\n</blockquote>\n<p>We were planning on including mutable cells in the paper but then we found this <a href=\"https://link.springer.com/chapter/10.1007/978-3-642-39634-2_24\" target=\"_blank\" title=\"https://link.springer.com/chapter/10.1007/978-3-642-39634-2_24\">paper</a> and noticed that they had all our examples and because they are extracting to OCaml, they did not have to deal with the issues of implementing it in a pure programming language</p>",
        "id": 189664503,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583302950
    },
    {
        "content": "<p>You should mention that it can be done (is being done?) and cite the paper then</p>",
        "id": 189664536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583303037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189664495\" title=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189664495\">said</a>:</p>\n<blockquote>\n<p>so it will be possible to write correct programs (using only safe code) that cannot be proven correct</p>\n</blockquote>\n<p>With <code>PtrCache</code> we still have a proof of functional correctness. We just can reason about duplicates, cache hits / miss. Also, the pointer itself doesn't give you anything that the value doesn't give you. With the value, you can use its pointer and you can dereference it (i.e. you look at the value itself). If you only have the address, you lose access to the value</p>",
        "id": 189664596,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583303103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189664536\" title=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189664536\">said</a>:</p>\n<blockquote>\n<p>You should mention that it can be done (is being done?) and cite the paper then</p>\n</blockquote>\n<p>That's really a separate project and a separate topic at this point so we gain nothing by including it in our discussion</p>",
        "id": 189664647,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583303167
    },
    {
        "content": "<p>Here's an example of an algorithm that is correct but not provably correct: <code>withPtrAddr x (\\u -&gt; withPtrAddr x (\\v -&gt; assert (u = v)))</code></p>",
        "id": 189664662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583303194
    },
    {
        "content": "<p>You can dress that up with a pointer cache, but it's ultimately the same problem. If you store x in a hash table at location <code>hash &amp;x</code>, then if you later look up the bucket for <code>hash &amp;x</code> you will get a bucket that contains x, but you can't prove that</p>",
        "id": 189664732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583303300
    },
    {
        "content": "<p>As I said, there's a whole area where we can't specify the properties. If your specification is about addresses (e.g. if you're writing a device driver), this won't cut it. If you want to write a program that computes a value but you want to go faster, you can get a proof of functional correctness with our approach</p>",
        "id": 189664747,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583303351
    },
    {
        "content": "<p>I'm saying that's not the case. The hash algorithm cannot be proven to <em>work at all</em> without knowing that addresses are stable</p>",
        "id": 189664809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583303420
    },
    {
        "content": "<p>unless it falls back on searching the whole table or something (which will not happen but lean can't tell)</p>",
        "id": 189664823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583303448
    },
    {
        "content": "<p>We have a proof of the examples in the paper. They type check</p>",
        "id": 189664828,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583303456
    },
    {
        "content": "<p>I don't see any proofs in the paper</p>",
        "id": 189664842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583303489
    },
    {
        "content": "<p>I see programs</p>",
        "id": 189664847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583303496
    },
    {
        "content": "<p>functional correctness has not been stated for <code>PtrCache</code>, and I am asserting that there are natural properties that you can assert that it satisfies, and you will not be able to prove them</p>",
        "id": 189664901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583303563
    },
    {
        "content": "<p>If you look at page 14, the proofs are in the types. We're using subsingleton's and subtypes which very neatly encapsulates them</p>",
        "id": 189664948,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583303643
    },
    {
        "content": "<p>The functional correctness is that <code>evalNatPtrCache</code> produces the same result as <code>evalNatNaive</code></p>",
        "id": 189664955,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583303683
    },
    {
        "content": "<blockquote>\n<p>natural properties that you can assert that it satisfies, and you will not be able to prove them</p>\n</blockquote>\n<p>We agree. There's a whole lot that you can't do. But you can optimize your programs and prove that you're producing the same behavior. Pointers have only a superficial presence in the logic even if you get a narrow window into the run-time with these features.</p>",
        "id": 189665052,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583303847
    },
    {
        "content": "<p>Why are pointer values stable in the first place? In haskell they definitely aren't</p>",
        "id": 189665104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583303910
    },
    {
        "content": "<p>Haskell has a moving garbage collector (but <a href=\"https://hackage.haskell.org/package/base-4.12.0.0/docs/System-Mem-StableName.html\" target=\"_blank\" title=\"https://hackage.haskell.org/package/base-4.12.0.0/docs/System-Mem-StableName.html\"><code>StableName</code></a> helps compensate). Lean's memory management doesn't move objects. It's malloc style plus reference counting</p>",
        "id": 189665238,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583304118
    },
    {
        "content": "<p>I saw that <code>Semidecidable</code> was recently added. I think that this type can be usable in these kind of contexts, but it has to be squashed (e.g. <code>isPtrEq x y : Squash (Semidecidable (x = y))</code>)</p>",
        "id": 189665289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304154
    },
    {
        "content": "<p>again, the nice thing being that the memory representation of this type is exactly the same as <code>bool</code></p>",
        "id": 189665300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304200
    },
    {
        "content": "<p>That's why it was added but then we judged the name wasn't right and we renamed it. It should be gone from git too now</p>",
        "id": 189665313,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583304220
    },
    {
        "content": "<p>what is it called now? <code>SemiDecidable</code>?</p>",
        "id": 189665356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304251
    },
    {
        "content": "<p>That I could imagine there's some use for</p>",
        "id": 189665359,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583304262
    },
    {
        "content": "<p><code>PtrEqResult</code></p>",
        "id": 189665360,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583304275
    },
    {
        "content": "<p>oh so it's just specialized on x = y?</p>",
        "id": 189665363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304298
    },
    {
        "content": "<p>I think semidecidable is a good type (modulo bikeshedding on the name)</p>",
        "id": 189665373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304324
    },
    {
        "content": "<p>Yes, that's right. I think so too but without a good name, it's awkward to add. <code>SemiDecidable</code> doesn't quite cut it</p>",
        "id": 189665444,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583304389
    },
    {
        "content": "<p>I don't see why semidecidable is even not accurate</p>",
        "id": 189665472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304444
    },
    {
        "content": "<p>As I recall, Coq has a special notation for this. I don't remember the name of the functions but I think you can write <code>{ some proof } + ErrorType</code></p>",
        "id": 189665483,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583304460
    },
    {
        "content": "<p>Sure, it's <code>option p</code></p>",
        "id": 189665487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304472
    },
    {
        "content": "<p>When you have an honestly semidecidable problem, you can run a program with a timeout and it will say <code>yes</code> or <code>unknown</code></p>",
        "id": 189665538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304520
    },
    {
        "content": "<p>If you have a value of <code>Decidable p</code>, that's a proof that <code>p</code> is decidable. If you have a value of type <code>SemiDecidable p</code> (if you call it that), it's not a proof that <code>p</code> is semi-decidable. You need to state separately that, if <code>p</code> is true and you try hard enough (for some notion of trying hard enough), you'll get a proof of <code>p</code></p>",
        "id": 189665551,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583304569
    },
    {
        "content": "<p>yeah but who cares about liveness</p>",
        "id": 189665606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304605
    },
    {
        "content": "<p>I encoded that separately as:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">SemiDecision</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">isTrue</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">SemiDecision</span>\n<span class=\"bp\">|</span> <span class=\"n\">unknown</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">SemiDecision</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">SemiDecision</span>\n\n<span class=\"n\">def</span> <span class=\"n\">IsSemiDecisionProcedure</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">SemiDecision</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">isTrue</span> <span class=\"n\">hp</span>\n\n<span class=\"n\">def</span> <span class=\"n\">SemiDecidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">SemiDecision</span> <span class=\"n\">p</span> <span class=\"bp\">//</span> <span class=\"n\">IsSemiDecisionProcedure</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 189665614,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583304614
    },
    {
        "content": "<p>I'm also hoping you guys discover the <code>roption</code> trick for doing general recursion without that fuel stuff</p>",
        "id": 189665642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304675
    },
    {
        "content": "<p>The usefulness of the fuel vs the <code>roption</code> trick are very different. The point of the fuel is to permit functions for which we don't bother proving that they terminate and still be able to run them. Not having an equation compiler yet and well-founded recursion, that's often useful for code we want to run but not prove anything about it</p>",
        "id": 189665720,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583304829
    },
    {
        "content": "<p>it's poisonous just like <code>meta</code></p>",
        "id": 189665775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304880
    },
    {
        "content": "<p>it's just a way of allowing those functions in without making the logic inconsistent</p>",
        "id": 189665778,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583304885
    },
    {
        "content": "<p>and I'm not even sure it is consistent</p>",
        "id": 189665779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304892
    },
    {
        "content": "<p>or rather, \"realistic\" in the sense of VM matching the logic</p>",
        "id": 189665795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583304919
    },
    {
        "content": "<p>We can't use the trick unless the return type is non-empty</p>",
        "id": 189665856,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583305001
    },
    {
        "content": "<p><code>roption</code> requires no such hack</p>",
        "id": 189665860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305016
    },
    {
        "content": "<p>You need to make your code monadic as soon as you use it though</p>",
        "id": 189665870,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583305057
    },
    {
        "content": "<p>equation compiler can do that</p>",
        "id": 189665874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305069
    },
    {
        "content": "<p>you just stick the <code>partial</code> keyword on and it does the magic</p>",
        "id": 189665913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305085
    },
    {
        "content": "<p>but yeah, it is a monad</p>",
        "id": 189665920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305112
    },
    {
        "content": "<p>if you want to cheat and get out of the monad, use <code>roption.unwrap</code></p>",
        "id": 189665923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305130
    },
    {
        "content": "<p>but it's the only method that actually allows you to write a general recursive function and prove it is defined later</p>",
        "id": 189665937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305169
    },
    {
        "content": "<p>It's inconvenient with the calling code. Right now, we don't have tactics to do a lot of proofs and we don't have an equation compiler but we still need to write the compiler and the prover itself. I don't know if partial is here to stay but at the moment, it's a good solution</p>",
        "id": 189665949,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583305194
    },
    {
        "content": "<p>just use <code>meta</code></p>",
        "id": 189665995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305214
    },
    {
        "content": "<p>It's not there anymore</p>",
        "id": 189666000,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583305223
    },
    {
        "content": "<p>is there a reason that approach is no longer possible</p>",
        "id": 189666004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305232
    },
    {
        "content": "<p>At least meta didn't add things into pure code where they could possibly cause unsoundness</p>",
        "id": 189666026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305307
    },
    {
        "content": "<p>all these \"pure primitives\" require a soundness justification</p>",
        "id": 189666077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305341
    },
    {
        "content": "<p>The idea is to separate it between <code>partial</code> and <code>unsafe</code>. <code>unsafe</code> is contagious while <code>partial</code> is not. We can restrict <code>unsafe</code> to very little code and use normal Lean to write automation</p>",
        "id": 189666083,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583305359
    },
    {
        "content": "<p>The justification is there</p>",
        "id": 189666091,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583305377
    },
    {
        "content": "<p>What you have a problem with is the difference between the logic and the code generated by the compiler</p>",
        "id": 189666101,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583305404
    },
    {
        "content": "<p>yes, this property needs a name</p>",
        "id": 189666107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305418
    },
    {
        "content": "<p>Reid suggested \"realism\" but this is also possibly confusing</p>",
        "id": 189666156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305449
    },
    {
        "content": "<p>How about faithfulness of the execution model?</p>",
        "id": 189666160,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583305465
    },
    {
        "content": "<p>sure, wordy I guess</p>",
        "id": 189666166,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305479
    },
    {
        "content": "<p>It becomes harder to prove this property when you are explicitly lying to pure code</p>",
        "id": 189666172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305500
    },
    {
        "content": "<p>like telling it that there is an infinite natural number, or saying that a function that returns 0xdeadbeef in practice always returns 0</p>",
        "id": 189666192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305539
    },
    {
        "content": "<p>I think the whole story is more complicated than you think</p>",
        "id": 189666235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305568
    },
    {
        "content": "<p>I don't think Lean is ready for that kind of proof</p>",
        "id": 189666241,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583305578
    },
    {
        "content": "<p>that's for sure</p>",
        "id": 189666245,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305586
    },
    {
        "content": "<p>or that it's the highest priority right now</p>",
        "id": 189666259,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583305622
    },
    {
        "content": "<p>I'm worried that lean 4 is taking a step away from full stack soundness because of all the new programming features, the proof stuff is being left behind</p>",
        "id": 189666266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305636
    },
    {
        "content": "<p>sure it's not <code>meta</code>/<code>unsafe</code> anymore, but being pure code means less now than it used to</p>",
        "id": 189666316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305686
    },
    {
        "content": "<p>all for very good reasons of course, but just try not to forget about full functional correctness proofs</p>",
        "id": 189666338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305741
    },
    {
        "content": "<p>all I ever wanted was fast and provably correct programs. Lean 3 fails on the first point, and lean 4 is so close to being able to satisfy this but might end up failing on the second</p>",
        "id": 189666419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583305814
    },
    {
        "content": "<p>I think regardless, Lean 4 is going to be a step forward. If you do manage to prove its correctness, that's going to be interesting.  Now that it's in large part written in Lean, that <code>Expr</code> is in safe code, that might be more accessible. At the very least, I think a lot of mistakes are being ruled out so we can make progress faster</p>",
        "id": 189666591,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583306049
    },
    {
        "content": "<p>Btw, here is the Coq construct I was referring to earlier:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Inductive</span> <span class=\"n\">sumor</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inleft</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"o\">{</span><span class=\"n\">B</span><span class=\"o\">}</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inright</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"o\">{</span><span class=\"n\">B</span><span class=\"o\">}</span>\n <span class=\"n\">where</span> <span class=\"s2\">&quot;A + { B }&quot;</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">sumor</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">type_scope</span><span class=\"bp\">.</span>\n</pre></div>",
        "id": 189666684,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583306172
    },
    {
        "content": "<p>I guess that's just <code>A + plift B</code> for us</p>",
        "id": 189669432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583309517
    },
    {
        "content": "<p>What is \"that fuel stuff\"? Is that a Lean 4 thing?</p>",
        "id": 189678814,
        "sender_full_name": "Anton Lorenzen",
        "timestamp": 1583318683
    },
    {
        "content": "<p>presumably passing in another parameter that dictates the maximum amount of steps that you run a function so that it always terminates. you run the function until it runs out of fuel.</p>",
        "id": 189681130,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1583320553
    },
    {
        "content": "<p>and then there is a magic value that you can pass that acts like infinity for unbounded recursions</p>",
        "id": 189681203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583320586
    },
    {
        "content": "<p>How do you pull that part off?</p>",
        "id": 189682348,
        "sender_full_name": "Chris B",
        "timestamp": 1583321566
    },
    {
        "content": "<p>I looked into it a while ago, and I forget the details, but I think this constant is marked such that you can't use it in proofs. It interacts with <code>partial</code> functions in a weird way though and having a \"largest natural number\" lying around doesn't make me happy</p>",
        "id": 189682889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583322102
    },
    {
        "content": "<p>It's a <code>constant</code>, it doesn't really have a value. <code>partial def</code>s are irreducible for all intents and purposes.</p>",
        "id": 189683140,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1583322349
    },
    {
        "content": "<p>Still, it is one more place where the logic and the VM disagree about something, and the constant can go in lots of places</p>",
        "id": 189683451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583322644
    },
    {
        "content": "<p>It doesn't matter what number it is, it's a <code>nat</code> and lean knows that <code>nat</code> has certain properties. For example if you evaluate a partial function at depth <code>infinity+1</code> then it will return none, even if in reality this is impossible</p>",
        "id": 189683552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583322790
    },
    {
        "content": "<p>In other words, every <code>partial</code> function is provably non-total, in the sense <code>\\ex n, f n = none</code></p>",
        "id": 189683728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583322957
    },
    {
        "content": "<p>even if the recursion equations are actually perfectly well defined</p>",
        "id": 189683794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583322990
    },
    {
        "content": "<p>Now I wonder if you can combind the pointer equality trick, which gives you true properties that you can't prove (two calls to <code>withPtrEq</code> give the same result), with the infinite recursion, which gives you true but not finitely observable properties that you can disprove (the <code>partial</code> function <code>f 0 = 1</code> and <code>f(n+1) = f n</code> never returns <code>0</code>), to get a true and finitely observable fact that is disprovable</p>",
        "id": 189684171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583323356
    },
    {
        "content": "<p>(I'm still reading through the discussion, I hope I didn't miss too much.  These are just my first thoughts after skimming the paper.)  I like that these features will be available in Lean 4.  However the paper comes across as unorganized and without a clear and uniform design.  There are two primitives for pointer equality tests, <code>withPtrEq</code> and <code>withPtrEqResult</code>.  (For some reason there's only one version of <code>withPtrAddr</code> and <em>of course</em> it works like <code>withPtrEqResult</code> and not like <code>withPtrEq</code>....)  And then there's squashes thrown in as yet another way to do the same thing: i.e., to control the elimination principle.  I think it would be good idea to reduce the number of primitive (concepts) here.  Why can't you just add <code>ptrAddr : α → ∥Addr∥</code> and <code>ptrEq : ∀ a b, ∥PtrEqResult a b∥</code> like <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> suggested?  Then it would be clear that all such \"implementation details\" like pointer equality are supposed to be in the squash monad.  And you only need to learn one elimination principle.  Or if that's too sophisticated, present at most one of the variants, i.e., only <code>withPtrEqResult</code> and not <code>withPtrEq</code>.</p>",
        "id": 189686491,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1583325511
    },
    {
        "content": "<p>The <code>Result</code> structure is also somewhat confusingly named.  1) It is not related to <code>PtrEqResult</code>.  2) It is not related to Rust's <code>Result</code> (= <code>Except</code> = <code>Either</code>).   3) Why does it even mention the function and argument separately?  <code>def Result (y : β) := { output // output = y }</code> works as well.  4) I like subtypes better, how about <code>{ output // output = f x }</code> instead of <code>Result f x</code>?</p>",
        "id": 189687405,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1583326396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110026\">Simon Hudon</span> <a href=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189666591\" title=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189666591\">said</a>:</p>\n<blockquote>\n<p>I think regardless, Lean 4 is going to be a step forward. If you do manage to prove its correctness, that's going to be interesting.  Now that it's in large part written in Lean, that <code>Expr</code> is in safe code, that might be more accessible. At the very least, I think a lot of mistakes are being ruled out so we can make progress faster</p>\n</blockquote>\n<p>I know that currently the only Lean 4 program is Lean itself but I don't really care that much about proving the correctness of Lean. I do care about writing other fast and provably correct programs like computer algebra systems and algorithms in number theory and algebraic topology and cryptography. Lean 4 is like 90% of the way to what I want but this <code>partial</code> stuff looks like a big headache.</p>",
        "id": 189691776,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583329960
    },
    {
        "content": "<p>Are we talking about proving the part of Lean that will be used to write tactics? If yes then why do we care? The kernel will still check the proofs in the end, right? And the story you discuss today doesn't require more trust in the kernel, right?</p>",
        "id": 189691974,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1583330084
    },
    {
        "content": "<p>I am talking about using Lean for more than theorem proving. For example writing a program to compute the number of points on an elliptic curve and proving it correct, and being able to compile the program to an executable which has similar performance to a C implementation.</p>",
        "id": 189692385,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583330340
    },
    {
        "content": "<p>The biggest reason we are using <code>partial</code> right now is because we can't do wellfoundedness proofs right now. If you want to prove your function total, that will of course continue to work.</p>",
        "id": 189692954,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1583330657
    },
    {
        "content": "<p><code>partial</code> is mostly for when you don't care about proofs</p>",
        "id": 189692981,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1583330679
    },
    {
        "content": "<p>But it has some special treatment with the equation compiler and general recursion, right?</p>",
        "id": 189693422,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583330942
    },
    {
        "content": "<p>It does, but it's really shallow. Add a new <code>Nat</code> param, recurse on it, and start it with <code>hugeFuel</code>.</p>",
        "id": 189695403,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1583331981
    },
    {
        "content": "<p>I guess my remaining question is whether a hand-rolled total function defined by general recursion plus a separate proof of termination can have zero overhead relative to the code I would get from <code>partial</code></p>",
        "id": 189708774,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583339703
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> The compiler output is independent of the mode of recursion: <a href=\"https://github.com/leanprover/lean4/blob/50207e2c5af73af8006f2f9652c6b90694066a50/src/library/util.h#L302-L304\" target=\"_blank\" title=\"https://github.com/leanprover/lean4/blob/50207e2c5af73af8006f2f9652c6b90694066a50/src/library/util.h#L302-L304\">https://github.com/leanprover/lean4/blob/50207e2c5af73af8006f2f9652c6b90694066a50/src/library/util.h#L302-L304</a><br>\nIf you want to encode general recursion in something custom like <code>roption</code>, I suppose it will depend on how customizable the equation compiler is.</p>",
        "id": 189712594,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1583341882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189691776\" title=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189691776\">said</a>:</p>\n<blockquote>\n<p>I know that currently the only Lean 4 program is Lean itself but I don't really care that much about proving the correctness of Lean. I do care about writing other fast and provably correct programs like computer algebra systems and algorithms in number theory and algebraic topology and cryptography. Lean 4 is like 90% of the way to what I want but this <code>partial</code> stuff looks like a big headache.</p>\n</blockquote>\n<p>What I was getting at is that, if 10% of Lean is implemented at all, that means that we have very few features to rely on to write Lean in Lean itself. When we go up to 20%, new features are available and we can make use of them in the implementation of Lean. Loops are something that we need from day 1 and well-founded recursion is not the first feature on the list. <code>partial</code> is a great way around that even if it is schedule to disappear after WF recursion comes in -- I don't know if it actually is scheduled but when we do have WF recursion or even general recursion, you don't have to care about <code>partial</code> in the programs that you write and prove</p>",
        "id": 189728457,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1583351675
    },
    {
        "content": "<p>There is a general mechanism to take the equations of the equation compiler and produce a relation that relates all input values to all calls (where it should be \"decreasing\"). You construct an inductive relation with these constructors and then <code>acc</code> applied to that is the unique most general well foundedness condition, that allows you to say \"a function with these equations computes here\". There are no constraints on this compilation procedure, assuming the arguments have been tupled up as in lean 3 wf recursive compilation.</p>\n<p>The upshot is that you can write any equations you want, and you can produce a function from some proposition, asserting that the particular input terminates, to the result value. If you don't want to prove well foundedness, you can either call it in the <code>roption</code> monad, or you can pass a fake proof. Writing the equations and proving termination become separated, and you don't need any magic at all.</p>",
        "id": 189730345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583352785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"258922\">Anton Lorenzen</span> <a href=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189678814\" title=\"#narrow/stream/113488-general/topic/Pure.20functional.20programming.20and.20pointer-based.20optimization/near/189678814\">said</a>:</p>\n<blockquote>\n<p>What is \"that fuel stuff\"? Is that a Lean 4 thing?</p>\n</blockquote>\n<p>This probably refers to \"petrol-driven computation\". If you have a computation whose halting behaviour you don't know, a total language might not let you run it (because it might not terminate); but you can still always run it for some maximum number of computation steps, unfolding the state of the computation as you go. After a thousand steps, maybe it's terminated or maybe it hasn't, but you can certainly unfold the computation up to that point. We say you've \"provided 1000 fuel\" to the computation, and this may or may not be enough to complete it.</p>",
        "id": 189766243,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1583393633
    }
]
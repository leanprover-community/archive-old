[
    {
        "content": "<p>I am trying to prove that a simple definition of a function over lists is doing the right thing. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">init.function</span>\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">splitAt</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span>                   <span class=\"mi\">0</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span>                   <span class=\"n\">_</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"o\">[])</span>\n <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>  <span class=\"k\">match</span> <span class=\"n\">splitAt</span> <span class=\"n\">n</span> <span class=\"n\">xs</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">zs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">zs</span><span class=\"o\">)</span>  <span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">splitAt</span> <span class=\"mi\">2</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">])</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n <span class=\"n\">rw</span> <span class=\"n\">splitAt</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">splitAt</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">splitAt</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">splitAt._match_1</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">splitAt._match_1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">prod.snd</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">==</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">splitAt</span> <span class=\"n\">n</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n <span class=\"n\">induction</span> <span class=\"n\">xs</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n <span class=\"n\">simp</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"n\">splitAt</span><span class=\"o\">,</span>    <span class=\"c1\">--  &lt;- ERROR</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<ol>\n<li>why <code>unfold</code> does not work in the proofs? </li>\n<li>why the <code>rw</code> is working in the first proof, but in the second it doesn't work.</li>\n<li>The definition looks ugly compared to the original Haskell code, is it possible to simplify it?</li>\n</ol>",
        "id": 228846925,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1614890561
    },
    {
        "content": "<p>If you look at the output of <code>#print prefix splitAt</code> you will see that there are four equation lemmas -- <code>0 []</code>, <code>0 (a :: L)</code>, <code>(succ n) []</code> and <code>(succ n) (a :: L)</code>. So you need to do <code>cases n</code> and then the rewrite will work.</p>",
        "id": 228852673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614892946
    },
    {
        "content": "<p>Thank you, I have never used the <code>#print prefix</code> before. But why the first proof works without the cases?</p>",
        "id": 228853513,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1614893286
    },
    {
        "content": "<p>Here's my effort to tidy up:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">splitAt</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span>              <span class=\"mi\">0</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span>              <span class=\"n\">_</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"o\">[])</span>\n <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">zs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">splitAt</span> <span class=\"n\">n</span> <span class=\"n\">xs</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">zs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">splitAt</span> <span class=\"mi\">2</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">])</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">splitAt</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Note: you don't need any imports. You never need <code>import init.function</code> -- this is not in mathlib, this is core Lean so already imported.</p>",
        "id": 228910281,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614930581
    },
    {
        "content": "<p>As for <code>==</code>, I think that you think that <code>==</code> means something different to what Lean means by it. It's heterogeneous equality, which is used to compare elements of different types in certain circumstances, and is not needed in situations like this.</p>",
        "id": 228911307,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614931427
    },
    {
        "content": "<p>Technically, not all of core Lean is imported automatically, only what is in <code>init</code>, but this doesn't change anything here.</p>",
        "id": 228912031,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1614931857
    },
    {
        "content": "<p>After some experimenting I realise that using either <code>let</code> or <code>match</code> in a recursive definition like this is a lousy idea. I think that this is best in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">splitAt</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">a</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span>              <span class=\"mi\">0</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span>              <span class=\"n\">_</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">([],</span> <span class=\"o\">[])</span>\n <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">splitAt</span> <span class=\"n\">n</span> <span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">splitAt</span> <span class=\"n\">n</span> <span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then the simplifier can prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">prod.fst</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">prod.snd</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">splitAt</span> <span class=\"n\">n</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>without too much trouble (I can post my proof if you want, but I don't know if it's a spoiler)</p>",
        "id": 228912448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614932106
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>I remembered Zulip does spoilers  now :-)</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import tactic\n\ndef splitAt {a : Type} : ℕ → (list a) → (list a × list a)\n |              0 xs := ([], xs)\n |              _ [] := ([], [])\n | (n + 1) (x :: xs) := (x :: (splitAt n xs).1, (splitAt n xs).2)\n\nexample : splitAt 2 [1,2,3,4] = ([1,2],[3,4]) :=\nbegin\n  simp [splitAt],\nend\n\nexample (a : Type) (n : ℕ) (xs : list a) :\n (λ x, (prod.fst x) ++ (prod.snd x) = xs) (splitAt n xs) :=\nbegin\n  induction xs with d hd IH generalizing n,\n  { induction n with m hm;\n    simp [splitAt] },\n  { induction n with m hm,\n    { simp [splitAt] },\n    { simp [splitAt, IH, hm] } }\nend\n</code></pre></div>\n</div></div>",
        "id": 228912826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614932339
    }
]
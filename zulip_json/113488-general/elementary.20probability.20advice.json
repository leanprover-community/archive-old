[
    {
        "content": "<p>I have a student with limited mathematical background -- the only proofs he has seen are in an intro to proof course for non-math majors. He wants to formalize some elementary probability, i.e. discrete spaces only. The mathlib API will force him to figure out measurability, ennreals, etc., and I am worried that he will have a hard time with all that. So instead I encouraged him to use a class that axiomatizes a discrete probability measure directly, i.e. the probability maps arbitrary sets to the reals. Dealing with countable additivity (with <code>tsum</code>) might also be too challenging, but it should be enough for him to use finite additivity.</p>\n<p>In short, I am advising him to ignore mathlib's notion of probability and roll his own simpler version to work with. Is there an easy way to get a similar effect using notions in mathlib? I know that <code>pmf.to_measure</code> should provide an instance of whatever he writes down, but I want him to have an API that is as simple as possible.</p>",
        "id": 306030991,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1666705244
    },
    {
        "content": "<p>There is an area called probabilistic graph theory, which uses the language of probability and proves theorems of the form \"a graph with the following properties must exist\" by arguing that if you fix a sufficiently vertex set and then define edges randomly, the probability that the graph has all the properties is positive, and hence such a graph must exist. This can all be translated down into concrete statements involving counting rather than probability, but my understanding is that when people tried this in the past mathlib's probability API was not particuarly well-equipped to deal with such arguments. The same might be true here. In a finite situation of course finite additivity is enough. I'm wondering whether you're just adding to the evidence that we need to either rethink or simply implement anew probability in this finite setting. <span class=\"user-mention\" data-user-id=\"243312\">@Jason KY.</span> <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> do you have any thoughts on this?</p>",
        "id": 306035920,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1666706636
    },
    {
        "content": "<p>I think Bhavik has the G(n,p) model formalized in a branch (am I correct?)</p>",
        "id": 306037104,
        "sender_full_name": "Jason KY.",
        "timestamp": 1666706981
    },
    {
        "content": "<p>Somewhat correct - I have the distribution on finite sets where each element is present iid, probability p with some basic api. But I didn't explicitly link this to mathlib graphs, though it's technically more general</p>",
        "id": 306038068,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1666707248
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Yes, I had that in mind. Such an API would be good for teaching, but it should also really helpful for proofs involving the probabilistic method.</p>",
        "id": 306038075,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1666707253
    },
    {
        "content": "<p>Most of the current finite probability stuff in mathlib is built on the measure theory sections (I don't know much about the <code>pmf</code> part of the library so maybe it's different there) so it might be difficult to avoid measure theory if they want to use mathlib. Doing probability without measure theory is certainly doable however (there are libraries in Coq and Mizar that only do discrete probability) and I think <span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span> was interested in fromalising finite probability without measure theory in Lean.</p>",
        "id": 306038702,
        "sender_full_name": "Jason KY.",
        "timestamp": 1666707443
    },
    {
        "content": "<p>I don't think it has to be linked to graphs per se. Just a nice library for calculating with finite probabilities, without all the side conditions, would be good. My students are doing a small project now and will do a bigger one after that. I'll see if I can sell it to one of them.</p>",
        "id": 306038882,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1666707498
    },
    {
        "content": "<p>Yes. I have less time currently for this stuff as I'm an internship but I do think it would be a good idea. The point is that a lot of fields use this fundamentally \"naive probability\" view and it's quite useful.</p>",
        "id": 306039004,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666707538
    },
    {
        "content": "<p>As it happens I'm currently on an internship at a quantum computing company and one thing I've been wondering is: what do we actually need to use the language of probabilities as featured in quantum physics/quantum information theory? If I'm entirely honest... I think it's a lot closer to the finite distributions case.</p>",
        "id": 306039256,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666707609
    },
    {
        "content": "<p>Or to pick another applied example that I'm familiar with, look at the use of probability in probabilistic relational Hoare logic.</p>",
        "id": 306039374,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666707649
    },
    {
        "content": "<p>All of the other probability things I've done were all avoiding the probability library, but I think it's possible to combine them - I can put together a basic example tomorrow of a proof in probabilistic graph theory if it'd be helpful?</p>",
        "id": 306039511,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1666707689
    },
    {
        "content": "<p>The point is not so much that we need any one of these things, or graphs, etc. (though it would be good). The point is that there are a number of fields, inside and outside probability, which use probability while not really expecting the user to have any kind of grasp of the true details of measure theory etc.</p>",
        "id": 306039643,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666707727
    },
    {
        "content": "<p>I am taking the Cambridge Extremal and Probabilistic Combinatorics course this term, and I would be very interested in applying the probability theory library in this finite setting.</p>",
        "id": 306039692,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666707744
    },
    {
        "content": "<p>It shouldn't be the case that you have to have that kind of background in order to use it, because as we see here with Jeremy's student, sometimes people don't. We are limiting the ability of mathlib to be a foundation for later work if we don't look at creating a good interface onto naïve probability theory/a \"theory of finite distributions\". Really a lot of it is \"theory of weighted finite non-negative sums where the sum of the weights is 1\".</p>",
        "id": 306040108,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666707875
    },
    {
        "content": "<p>My belief right now is that the current setup can be made to work without a good understanding of measure theory, just with a few examples of how to use it and perhaps a guide, but no need to explicitly talk about any measure theory</p>",
        "id": 306040534,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1666708000
    },
    {
        "content": "<p>I don't know anything about probability theory, but it seems it would be nice to have a bunch of lemmas relating the general theory to the elementary one, just like we have lemmas recasting all topology definitions in terms of epsilons and deltas when working with metric spaces.</p>",
        "id": 306040547,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1666708002
    },
    {
        "content": "<p>My longer-term suggestion for the health and future of the library is to get advice from different people who use probability in different ways when designing this (I have tried to sketch out a few above). I think it's a really good opportunity not simply to do interesting mathematics but to <em>make mathlib better</em> as a foundation for people to do mathematics and mathematical reasoning in a formal context.</p>",
        "id": 306040551,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666708002
    },
    {
        "content": "<p>Yeah agreed Patrick and that wouldn't surprise me Bhavik, but currently we don't have a way into that.</p>",
        "id": 306040761,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666708065
    },
    {
        "content": "<p>Jason and I will probably formalise some of the aforementioned course, and I am planning to take this as an opportunity to develop elementary probability theory in mathlib.</p>",
        "id": 306041009,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666708126
    },
    {
        "content": "<p>Ultimately most of the maths of QM, I think, isn't \"really\" probability but has a probabilistic interpretation. But that probability does keep coming up.</p>",
        "id": 306041056,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666708140
    },
    {
        "content": "<p>That would be really great Yaël.</p>",
        "id": 306041100,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666708151
    },
    {
        "content": "<p>Agreed all around. Bhavik, maybe hold off on experimenting? I have some talented students in my class, and this will be a good project if I can talk them into it.</p>",
        "id": 306041146,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1666708163
    },
    {
        "content": "<p>One notion I've seen in some areas of probabilistic logic/formal methods btw is the notion of \"subdistributions\", which are basically just probability distributions where the sum of the probabilities is at most 1 rather than being exactly 1. Quite nice to have the flexibility to allow for things like that if it's natural.</p>",
        "id": 306041459,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666708224
    },
    {
        "content": "<p>Oh, sorry, our messages are crossing. Yael, Jason, let me know if you are likely to do this within the next month or two.</p>",
        "id": 306041469,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1666708228
    },
    {
        "content": "<p>One thing to bear in mind is that even when working with explicit distributions on finite spaces, some arguments still use infinite spaces under the hood - consider the G(n, p) model of random graphs, and the random variable on it given by \"number of k-cliques in the graph\". Now the expectation of this rv would be increasing in p, and the easiest way of showing this is to instead assign a uniform [0,1] to each edge, and derive G(n, p) and G(n, p') on that, then the coupled variables give the result immediately</p>",
        "id": 306041486,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1666708232
    },
    {
        "content": "<p>Yes. I do worry about this - that there's often sneaky uses of infinite stuff.</p>",
        "id": 306041619,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666708269
    },
    {
        "content": "<p>And this is precisely what I did (in a more general form) in the branch I mentioned earlier</p>",
        "id": 306041629,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1666708272
    },
    {
        "content": "<p>(actually that's a slight lie - I did the probability of one existing, not the expected number, but the same principle applies!)</p>",
        "id": 306042006,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1666708377
    },
    {
        "content": "<p>(For reference: this is the paper I've been reading lately. The author has formalised this content in a tool built on top of Isabelle/HOL-Analysis, if you want a point of comparison of what other libraries can do.)</p>\n<p><a href=\"https://arxiv.org/abs/1802.03188#:~:text=This%20logic%20follows%20the%20spirit,proofs%20of%20classical%20cryptographic%20protocols\">https://arxiv.org/abs/1802.03188#:~:text=This%20logic%20follows%20the%20spirit,proofs%20of%20classical%20cryptographic%20protocols</a>.</p>",
        "id": 306042098,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666708410
    },
    {
        "content": "<p>See the definition of \"distributions\" on page 11 (which isn't actually finitary, but it's also not really a measure theory perspective either...).</p>",
        "id": 306042466,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666708510
    },
    {
        "content": "<p>Indeed in a footnote: \"we do not consider distributions over arbitrary measurable spaces, only discrete ones\".</p>",
        "id": 306042654,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666708560
    },
    {
        "content": "<p>Maybe this is totally off, but I was thinking  <em><a href=\"https://www.cs.ru.nl/B.Jacobs/PAPERS/ProbabilisticReasoning.pdf\">Structured probabilistic reasonning</a></em> by Bart Jacobs could be a good resource to formalize \"elementary\" probability theory ?</p>",
        "id": 306043363,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1666708782
    },
    {
        "content": "<p>That actually looks really really good.</p>",
        "id": 306045565,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666709427
    },
    {
        "content": "<p>Wow. Yeah no I think that could be a fantastic foundation.</p>",
        "id": 306045618,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666709446
    },
    {
        "content": "<p>Great :) Thought so too but one never knows!</p>",
        "id": 306045976,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1666709541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110865\">Jeremy Avigad</span> <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/306041469\">said</a>:</p>\n<blockquote>\n<p>Oh, sorry, our messages are crossing. Yael, Jason, let me know if you are likely to do this within the next month or two.</p>\n</blockquote>\n<p>I'm not sure what <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>'s timeframe for this is. I don't plan to write too much serious lean for a bit while I'm doing phd applications so I think your student's project won't conflict with us.</p>",
        "id": 306049104,
        "sender_full_name": "Jason KY.",
        "timestamp": 1666710411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/306039256\">said</a>:</p>\n<blockquote>\n<p>As it happens I'm currently on an internship at a quantum computing company and one thing I've been wondering is: what do we actually need to use the language of probabilities as featured in quantum physics/quantum information theory? If I'm entirely honest... I think it's a lot closer to the finite distributions case.</p>\n</blockquote>\n<p>I'd say the situation is quite similar to probability theory: the finite-dimensional case is easy like finite distributions, and in the infinite-dimensional case you have to get into much more complicated stuff like von Neumann algebras.</p>",
        "id": 306056163,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1666712404
    },
    {
        "content": "<p>I completely agree with <span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> , the problem is the lack of an API for finite probability spaces --- and the ideal solution would be an API. <span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span>'s innocent-looking coupling example about graph probability brilliantly illustrates that the API really needs to connect to mathlib's measure theoretic probability.</p>",
        "id": 306071922,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1666716175
    },
    {
        "content": "<p>Incidentally, there was a <a href=\"#narrow/stream/116395-maths/topic/.60nnreal.60.20vs.2E.20.60ennreal.60.20in.20.60pmf.60/near/303518183\">recent discussion</a> (and a PR <a href=\"https://github.com/leanprover-community/mathlib/pull/17032\">#17032</a>) about making probability mass functions (pmf) <code>ennreal</code>-valued, instead of <code>nnreal</code> valued. I did not weigh in, since I have had very little time to contribute, but my fear is such a design choice will make elementary uses of probability more painful. For instance, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> is a pmf on a finite set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width=\"0.1111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"/><mi>S</mi><mo>→</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">f \\colon S \\to \\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> is a function, one would like to write the expectation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> as</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"sans-serif\">E</mi><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">]</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow></munder><mi>f</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mtext> </mtext><mi>p</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">\\mathsf{E}[f] = \\sum_{s \\in S} f(s) \\, p(s) ,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathsf\">E</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.3717em;vertical-align:-1.3217em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.05em;\"><span style=\"top:-1.8557em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span style=\"top:-3.05em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3217em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span></span></span></span></span></p>\n<p>but with ennreal-valued pmfs one can't since there is no multiplication of <code>ℝ≥0∞</code> with <code>ℝ</code> (the summands don't <em>typecheck</em>). So favoring ennreals might be less painful now that there is no API for finite probabilities, but I'm afraid it will be a worse choice once an otherwise good API would be in place. (This had been my rationale for having <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.probability_measure\">docs#measure_theory.probability_measure</a> to have a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.probability_measure.has_coe_to_fun\">docs#measure_theory.probability_measure.has_coe_to_fun</a>, which is <code>nnreal</code>-valued instead of simply using the underlying <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.measure.has_coe_to_fun\">docs#measure_theory.measure.has_coe_to_fun</a>, but admittedly a lot of API is missing before this becomes anything more than a pain).</p>\n<p>Anyway, no API is a big problem either way!</p>",
        "id": 306071988,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1666716196
    },
    {
        "content": "<p>I'd just like to point out that for the Birthday problem, I recently tried to restate it as the probability of a function being injective (as opposed to the cardinality of the set of functions/cardinality of the set of injective functions) and it was a pain. Further, I'm told that doing something like turning that into the standard interpretation about <code>n</code> independent iid random variables would be \"a pain\"</p>",
        "id": 306091728,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1666721360
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/archive/100-theorems-list/93_birthday_problem.lean\">https://github.com/leanprover-community/mathlib/blob/master/archive/100-theorems-list/93_birthday_problem.lean</a></p>\n<p>This is the relevant code; there weas missing API that I needed to add for simple things, and also some of the lines are pretty \"magical\" if you don't know Lean</p>",
        "id": 306091901,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1666721419
    },
    {
        "content": "<p>I feel that we are really missing is a good notation for <code>(ℙ s).to_real</code> when <code>ℙ</code> is a probability measure (or a finite measure, or even a general measure maybe), and then a basic API around this notation. This would make it possible to avoid completely ennreals in a lot of natural situations.</p>",
        "id": 306099290,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1666723640
    },
    {
        "content": "<p>Is it clear <code>real</code> is better than <code>nnreal</code>?</p>\n<p>For a few reasons I had thought <code>ℝ≥0</code> would be better here (in particular <code>nnreal</code>s coerce automatically to <code>real</code>s, whereas the other way around one may need positivity proofs) (although an argument for the opposite is that arithmetic on <code>real</code>s is less pathological). Either way, for such a purpose, in my opinion a decent notation is provided by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.finite_measure.has_coe_to_fun\">docs#measure_theory.finite_measure.has_coe_to_fun</a> (and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.probability_measure.has_coe_to_fun\">docs#measure_theory.probability_measure.has_coe_to_fun</a>), which allows to write simply <code>ℙ s</code> (which gets pretty-printed as <code>⇑ℙ s</code>). I think making these coercions to functions a default spelling might be a good idea for elementary probability; either keeping them <code>nnreal</code>-valued as they are or <code>real</code>-valued if we prefer that. Then an acceptable notation would exist, but obviously API around that is still missing.</p>\n<p>(Just to clarify: <code>measure</code> obviously has an <code>ℝ≥0∞</code>-valued coe_to_fun, but <code>finite_measure</code> and <code>probability_measure</code> currently have an <code>ℝ≥0</code>-valued and could be changed to have <code>ℝ</code>-valued coe_to_funs.)</p>",
        "id": 306104405,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1666725385
    },
    {
        "content": "<p>Two advantages of <code>real</code>: more tactics work with it, and it's what it says in all the books</p>",
        "id": 306104564,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1666725455
    },
    {
        "content": "<p>Also, does someone have clear ideas about what the API should involve? I'm thinking: finite and countable additivity, monotonicity, complement probabilities, at least, maybe monotone increasing and decreasing convergence of measures. Anything connecting to expected values (integration) quite naturally remains <code>ennreal</code>-valued anyway. (Except on finite types with real-valued functions or more generally bounded measurable functions one could even have direct API for expected values with real values. Where real really in mathlib generality means <code>{R : Type*} [normed_add_comm_group R] [normed_space ℝ R] [complete_space R]</code>. But the elementary API choices start to get more complicated already here.)</p>\n<p>This means duplicating some amount of API from measure theory (of course proofs get shorter as they only involve coercions from <code>ennreal</code> to whichever of the two finite alternatives we'd choose).</p>",
        "id": 306108683,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1666727015
    },
    {
        "content": "<p>I have been intending to change the notations in <a href=\"https://leanprover-community.github.io/mathlib_docs/measure_theory/measure/finite_measure_weak_convergence.html#top\">this file</a> to <code>ℙ</code> and <code>Ω</code> instead of <code>μ</code> and <code>α</code>, so I think I could give the very basic API a go at the same time.</p>",
        "id": 306109047,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1666727131
    },
    {
        "content": "<p>I am not sure about the coercion business. My problem is that most probability measure will comes as <code>(ℙ : measure Ω ) [is_probability_measure ℙ]</code>, and for these the ennreal-valued coercion is already registered.</p>",
        "id": 306110437,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1666727679
    },
    {
        "content": "<p>But we could have something like <code>ℙ.real s</code>, which is not too long. And it is not hard to say to a newcomer that the probability of a set is denoted always by <code>ℙ.real s</code> (and please don't ask why).</p>",
        "id": 306110796,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1666727826
    },
    {
        "content": "<p>I'm definitely biased: I construct most of my probability measures as weak limits (thermodynamical limits, scaling limits) of something else, and then they are <code>probability_measure</code>s, since that's the type that has the topology of weak convergence.</p>\n<p>Also constructing anything from i.i.d. samples often involves infinite product measures, which don't make a lot of sense for <code>measure</code>s or even <code>finite_measure</code>s, do they?</p>\n<p>So I'm not yet sure most probability measures would come as <code>(ℙ : measure Ω) [is_probability_measure ℙ]</code> rather than as <code>(ℙ : probability_measure Ω)</code>.</p>",
        "id": 306111825,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1666728144
    },
    {
        "content": "<p>Per that link above, I'm not sure if it's finite or discrete probability distributions that we need an API to. Both, quite possibly.</p>",
        "id": 306114813,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666729213
    },
    {
        "content": "<p>The link that Rémi posted, to be clear.</p>",
        "id": 306114935,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666729272
    },
    {
        "content": "<p>I'm really struck by the formalism presented there.</p>",
        "id": 306114976,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666729288
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/ZCH8I94G6WW5aurzey8A1soG/c72144e3-3953-4632-8f68-0759b298c90d.jpg\">c72144e3-3953-4632-8f68-0759b298c90d.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ZCH8I94G6WW5aurzey8A1soG/c72144e3-3953-4632-8f68-0759b298c90d.jpg\" title=\"c72144e3-3953-4632-8f68-0759b298c90d.jpg\"><img src=\"/user_uploads/3121/ZCH8I94G6WW5aurzey8A1soG/c72144e3-3953-4632-8f68-0759b298c90d.jpg\"></a></div>",
        "id": 306117144,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666730061
    },
    {
        "content": "<p>It's a serious formalism but it doesn't use a measure-based approach at all, it's doing quite a different thing for different reasons. But I think there could be a place for it.</p>",
        "id": 306117249,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666730100
    },
    {
        "content": "<p>But to me this points to something built on top of multiset.</p>",
        "id": 306117944,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666730370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/306056163\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/306039256\">said</a>:</p>\n<blockquote>\n<p>As it happens I'm currently on an internship at a quantum computing company and one thing I've been wondering is: what do we actually need to use the language of probabilities as featured in quantum physics/quantum information theory? If I'm entirely honest... I think it's a lot closer to the finite distributions case.</p>\n</blockquote>\n<p>I'd say the situation is quite similar to probability theory: the finite-dimensional case is easy like finite distributions, and in the infinite-dimensional case you have to get into much more complicated stuff like von Neumann algebras.</p>\n</blockquote>\n<p>Yeah - in quantum information theory one seems to only encounter finite dimensions, but I'm sure there are exceptions to that even there.</p>",
        "id": 306189328,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666773327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/306104564\">said</a>:</p>\n<blockquote>\n<p>Two advantages of <code>real</code>: more tactics work with it, and it's what it says in all the books</p>\n</blockquote>\n<p>Also <code>ℝ</code> has a well-behaved subtraction. For example I recently added <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.prob_compl_eq_one_sub\">docs#measure_theory.prob_compl_eq_one_sub</a> but as I explain in the doc string, it's not really the lemma I wanted.</p>",
        "id": 306196839,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1666775781
    },
    {
        "content": "<p>Aye.</p>",
        "id": 306199571,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666776784
    },
    {
        "content": "<p>And sometimes you do subtract probabilities</p>",
        "id": 306199604,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666776797
    },
    {
        "content": "<p>(and expect negative results)</p>",
        "id": 306199637,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666776806
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/306189328\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/306056163\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/306039256\">said</a>:</p>\n<blockquote>\n<p>As it happens I'm currently on an internship at a quantum computing company and one thing I've been wondering is: what do we actually need to use the language of probabilities as featured in quantum physics/quantum information theory? If I'm entirely honest... I think it's a lot closer to the finite distributions case.</p>\n</blockquote>\n<p>I'd say the situation is quite similar to probability theory: the finite-dimensional case is easy like finite distributions, and in the infinite-dimensional case you have to get into much more complicated stuff like von Neumann algebras.</p>\n</blockquote>\n<p>Yeah - in quantum information theory one seems to only encounter finite dimensions, but I'm sure there are exceptions to that even there.</p>\n</blockquote>\n<p>(I should say: as in, \"in the basic or practical approaches I've read\".)</p>",
        "id": 306202122,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666777706
    },
    {
        "content": "<p>From <code>probability/notation.lean</code>,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">`</span><span class=\"n\">ℙ</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"kd\">notation</span> <span class=\"n\">for</span> <span class=\"bp\">`</span><span class=\"n\">volume</span><span class=\"bp\">`</span> <span class=\"n\">on</span> <span class=\"n\">a</span> <span class=\"n\">measured</span> <span class=\"n\">space</span>\n</code></pre></div>\n<p>so calling an explicit probability measure <code>ℙ</code> feels a bit dangerous. But on the other hand, one could change the meaning of the notation to instead take real values (so it would be notation for <code>λ s, (volume s).to_real</code>). I'm guessing that this particular notation is almost never used outside probability spaces anyway? Then, newcomers would say <code>ℙ</code> and have their expected behavior, and more experienced users can still use <code>volume</code> explicitly if needed to fit within the general measurable space API.</p>",
        "id": 306221765,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1666785058
    },
    {
        "content": "<p><a href=\"https://arxiv.org/pdf/1804.01193.pdf\">https://arxiv.org/pdf/1804.01193.pdf</a> - This (essentially similar to the other Brett Jacobs pdf above in its approach) proposes a different notation/concept for probability. It has a lot of advantages as I see it, though the disadvantage of being unfamiliar notation. But at least it would avoid a confusion with the measure-theoretic interpretation of probability.</p>",
        "id": 306249559,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666793739
    },
    {
        "content": "<p>I have two small concerns about <span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span>'s proposal of having <code>ℙ</code> be notation for <code>λ s, (volume s).to_real</code> for elementary probability purposes.</p>",
        "id": 306328146,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1666817396
    },
    {
        "content": "<p>The first is that even in elementary probability one often has multiple probability measures around, so <code>volume</code> might not be a very universal spelling even under the hood (for example conditional probability versions of some original probability measure, coin tosses with different probability of heads, other parametric distributions such as Poisson, Geometric, ...).</p>",
        "id": 306328210,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1666817408
    },
    {
        "content": "<p>The second concern is a technicality and it might not be an issue at all. Would <code>ℙ</code> as notation for <code>λ s, (volume s).to_real</code> allow for natural development of API that would be convenient for elementary probability theory? I'm thinking in particular of rewrite lemmas and especially <code>@[simp]</code>-lemmas. Is it reasonable to find good simp normal forms for expression that involve <code>(volume s).to_real</code> under the hood (although perhaps with type class <code>[is_probability_measure volume]</code> floating around)? Sorry, I'm just not experienced enough with notations; I don't know if the simp normal form with the notation can be different from the simp normal form of the unfolded notation... ...so this might or might not be an issue at all.</p>",
        "id": 306328237,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1666817426
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/306328210\">said</a>:</p>\n<blockquote>\n<p>The first is that even in elementary probability one often has multiple probability measures around, so <code>volume</code> might not be a very universal spelling even under the hood (for example conditional probability versions of some original probability measure, coin tosses with different probability of heads, other parametric distributions such as Poisson, Geometric, ...).</p>\n</blockquote>\n<p>Not sure I would worry too much about this, because the usual theoretical setup is one probability space <code>\\Omega</code> equipped with one probability measure <code>P</code> (a.k.a <code>volume</code>) and many random variables defined on <code>\\Omega</code> with values in <code>\\R</code>, <code>\\N</code> and so on. The image measures are different for sure, but they are not <code>volume</code> : to get the probability that a r.v. <code>X</code> is in <code>s</code> we would not say  <code>\\bbP s</code> but <code>\\bbP {\\omega | X \\omega \\in s}</code>. There are certainly the usual issues of constructing conditioned random variables and so on on the same probability space, but I believe we will have these in any case independent of the notation issue.</p>\n<p>But come to think of it, <code>\\bbP {\\omega | X \\omega \\in s}</code> is definitely not usual probability notation, we would need something closer to <code>\\bbP [X \\in s]</code> and <code>\\bbP [0 &lt; X]</code> and <code>\\bbP [X^2 &lt; 1 \\and Y \\le X]</code> and ... and I have no idea if this is at all feasible.</p>",
        "id": 306338703,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1666820716
    },
    {
        "content": "<p>For conditioning in elementary probability I have in mind for example the fan favorite <em>\"covid home test\"</em> from freshman proba. I don't think such applications would be rare, especially if Lean were ever used for teaching elementary proba.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">probability.martingale.borel_cantelli</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measure.finite_measure_weak_convergence</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"n\">localized</span> <span class=\"s2\">\"notation (name := measure_space.volume.to_real)</span>\n<span class=\"s2\">  `ℙ` := (λ s, (measure_theory.measure_space.volume s).to_real)\"</span> <span class=\"k\">in</span> <span class=\"n\">elementary_probability</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">elementary_probability</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span> <span class=\"n\">ennreal</span> <span class=\"n\">nnreal</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">ennreal</span> <span class=\"n\">nnreal</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">covid_test</span>\n\n<span class=\"kd\">inductive</span> <span class=\"bp\">Ω</span>\n<span class=\"bp\">|</span> <span class=\"n\">true_pos</span>\n<span class=\"bp\">|</span> <span class=\"n\">true_neg</span>\n<span class=\"bp\">|</span> <span class=\"n\">false_pos</span>\n<span class=\"bp\">|</span> <span class=\"n\">false_neg</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"bp\">⊤</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">measure.count</span> <span class=\"bp\">..</span> <span class=\"o\">}</span> <span class=\"c1\">-- a better example would really use something interesting here, but...</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sick</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"bp\">Ω.</span><span class=\"n\">true_pos</span><span class=\"o\">,</span> <span class=\"bp\">Ω.</span><span class=\"n\">false_neg</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">healthy</span> <span class=\"o\">:=</span> <span class=\"n\">sick</span><span class=\"bp\">ᶜ</span>\n<span class=\"kd\">def</span> <span class=\"n\">home_test_pos</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"bp\">Ω.</span><span class=\"n\">true_pos</span><span class=\"o\">,</span> <span class=\"bp\">Ω.</span><span class=\"n\">false_pos</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">home_test_neg</span> <span class=\"o\">:=</span> <span class=\"n\">home_test_pos</span><span class=\"bp\">ᶜ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">measure_theory.measure.conditioned</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">μ.restrict</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ℙ₁</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"n\">volume.conditioned</span> <span class=\"n\">home_test_pos</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℙ</span> <span class=\"n\">sick</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">ℙ</span> <span class=\"n\">healthy</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- 1 ∈ ℝ</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℙ₁</span> <span class=\"n\">sick</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">ℙ₁</span> <span class=\"n\">healthy</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- 1 ∈ ℝ≥0∞</span>\n\n<span class=\"n\">localized</span> <span class=\"s2\">\"notation (name := measure_space.volume.conditioned.to_real)</span>\n<span class=\"s2\">  `ℙcond` := (λ s c, (measure_theory.measure_space.volume.conditioned c s).to_real)\"</span> <span class=\"k\">in</span> <span class=\"n\">elementary_probability</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℙcond</span> <span class=\"n\">sick</span> <span class=\"n\">home_test_pos</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">ℙcond</span> <span class=\"n\">healthy</span> <span class=\"n\">home_test_pos</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- 1 ∈ ℝ again</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">covid_test</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">elementary_probability</span>\n</code></pre></div>\n<p>It is of course possible (like above) to define yet another specialized notation for conditional probabilities (assuming they are always conditional versions of <code>volume</code>), but this is definitely not my favorite route. My preferred approach would have the conditioning <code>probability_measure Ω → set Ω → probability_measure Ω</code> with junk value <code>default</code> when conditioning on zero probability events or non-measurable sets. And API around <code>probability_measure.has_coe_to_fun</code>. But Sébastien was not convinced of this coe_to_fun approach...</p>\n<p>(<code>measure_theory.measure.conditioned</code> above is not well implemented for instance because it doesn't provide the junk values and can't automatically get the <code>[is_probability_measure]</code> type class, but that's beside the point)</p>",
        "id": 306346716,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1666824874
    },
    {
        "content": "<p>Incidentally I also failed to make simp lemmas hit the notation, but this may be just my incompetence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">probability.martingale.borel_cantelli</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measure.finite_measure_weak_convergence</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"n\">localized</span> <span class=\"s2\">\"notation (name := measure_space.volume.to_real)</span>\n<span class=\"s2\">  `ℙ` := (λ s, (measure_theory.measure_space.volume s).to_real)\"</span> <span class=\"k\">in</span> <span class=\"n\">elementary_probability</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">elementary_probability</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span> <span class=\"n\">ennreal</span> <span class=\"n\">nnreal</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">ennreal</span> <span class=\"n\">nnreal</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measure_space</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_probability_measure</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">complement_proba</span>\n  <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">E_event</span> <span class=\"o\">:</span> <span class=\"n\">measurable_set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">ℙ</span> <span class=\"n\">E</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">ℙ</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">measure_compl</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">volume</span> <span class=\"n\">_</span> <span class=\"n\">E_event</span> <span class=\"o\">(</span><span class=\"n\">measure_ne_top</span> <span class=\"n\">volume</span> <span class=\"n\">E</span><span class=\"o\">),</span>\n  <span class=\"n\">apply_fun</span> <span class=\"n\">ennreal.to_real</span> <span class=\"n\">at</span> <span class=\"n\">key</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">function.comp_app</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">measure_univ</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ennreal.to_real_sub_of_le</span> <span class=\"n\">_</span> <span class=\"n\">ennreal.one_ne_top</span><span class=\"o\">,</span> <span class=\"n\">ennreal.one_to_real</span><span class=\"o\">],</span>\n  <span class=\"n\">convert</span> <span class=\"n\">measure_mono</span> <span class=\"n\">E.subset_univ</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">measure_mono</span> <span class=\"n\">E.subset_univ</span><span class=\"o\">,</span> <span class=\"n\">measure_univ</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">Ω</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A_event</span> <span class=\"o\">:</span> <span class=\"n\">measurable_set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B_event</span> <span class=\"o\">:</span> <span class=\"n\">measurable_set</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">ℙ</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">ℙ</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">--rw [complement_proba], -- makes progress as intended.</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">A_event</span><span class=\"o\">],</span> <span class=\"c1\">-- doesn't trigger the simp lemma `complement_proba`</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">elementary_probability</span>\n</code></pre></div>",
        "id": 306346827,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1666824963
    },
    {
        "content": "<p>As a follow-up to this discussion, Jason and I will start formalising the Extremal and Probabilistic Combinatorics Cambridge course content next week, <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span>.</p>",
        "id": 308960934,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668076952
    },
    {
        "content": "<p>I have little idea how much elementary probability we will need.</p>",
        "id": 308961171,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1668077049
    },
    {
        "content": "<p>Excellent! One of my students is working on a proof of the Lovasz Local Lemma. If he succeeds and you don't do it independently, maybe he can work his proof into whatever framework you develop. Please do keep me posted.</p>",
        "id": 309015318,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1668094711
    },
    {
        "content": "<p>Ah Lovasz Local Lemma is a great choice of project!</p>",
        "id": 309017817,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1668095397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/308960934\">said</a>:</p>\n<blockquote>\n<p>As a follow-up to this discussion, Jason and I will start formalising the Extremal and Probabilistic Combinatorics Cambridge course content next week, <span class=\"user-mention silent\" data-user-id=\"110865\">Jeremy Avigad</span>.</p>\n</blockquote>\n<p>cc <span class=\"user-mention\" data-user-id=\"506168\">@John Talbot</span>, since he has proved some extremal combinatorics results too</p>",
        "id": 309051727,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1668105098
    },
    {
        "content": "<p><strong>Jeremy Avigad|110865</strong> <a href=\"#narrow/stream/113488-general/topic/elementary.20probability.20advice/near/309015318\">said</a>:</p>\n<blockquote>\n<p>Excellent! One of my students is working on a proof of the Lovasz Local Lemma. If he succeeds and you don't do it independently, maybe he can work his proof into whatever framework you develop. Please do keep me posted.</p>\n</blockquote>\n<p>I was a bit late on finishing the proof by the course deadline, but I did eventually get it done! Here it is: <a href=\"https://github.com/nsglover/lean-lovasz-local-lemma\">https://github.com/nsglover/lean-lovasz-local-lemma</a></p>",
        "id": 319713800,
        "sender_full_name": "Nathan Glover",
        "timestamp": 1672976020
    },
    {
        "content": "<p>If anyone has any general suggestions I'd be happy to hear them; this is my first time doing anything with Lean. I hear the community is currently switching to Lean 4 so I'll try to do the same for this proof at some point</p>",
        "id": 319713876,
        "sender_full_name": "Nathan Glover",
        "timestamp": 1672976087
    },
    {
        "content": "<p>I shall have a look! On our side, <a href=\"https://github.com/YaelDillies/LeanCamCombi\">LeanCamCombi</a> has been on hold for the holidays, but there is already some interesting API developed there.</p>",
        "id": 319818366,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673023571
    },
    {
        "content": "<p>Good to know thanks, I'll take a more in-depth look at some point. It seems really cool at a glance!</p>",
        "id": 319868232,
        "sender_full_name": "Nathan Glover",
        "timestamp": 1673041391
    }
]
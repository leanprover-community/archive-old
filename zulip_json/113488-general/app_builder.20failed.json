[
    {
        "content": "<p>Hi all! I have a question regarding mutual inductive definitions. The following definition:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">app_builder</span> <span class=\"n\">true</span>\n<span class=\"n\">mutual</span> <span class=\"kn\">inductive</span> <span class=\"n\">pexp</span><span class=\"o\">,</span> <span class=\"n\">farglist</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">tenv</span> <span class=\"n\">self</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">pexp</span><span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">const</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constant_name</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">pexp</span> <span class=\"o\">(</span><span class=\"n\">result_type</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">function_name</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n    <span class=\"n\">farglist</span> <span class=\"o\">(</span><span class=\"n\">args_type</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">pexp</span> <span class=\"o\">(</span><span class=\"n\">result_type</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">lookup</span> <span class=\"o\">{</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"n\">α</span><span class=\"o\">}:</span> <span class=\"n\">rvar</span> <span class=\"n\">e</span> <span class=\"n\">ty</span> <span class=\"bp\">→</span> <span class=\"n\">pexp</span> <span class=\"n\">ty</span>\n<span class=\"bp\">|</span> <span class=\"n\">requal</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">class_name</span> <span class=\"n\">α</span><span class=\"o\">}:</span>\n    <span class=\"n\">pexp</span> <span class=\"o\">(</span><span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">ref</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">pexp</span> <span class=\"o\">(</span><span class=\"n\">type</span><span class=\"bp\">.</span><span class=\"n\">ref</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">pexp</span> <span class=\"o\">(</span><span class=\"n\">boolean</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">farglist</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">type</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span><span class=\"o\">:</span> <span class=\"n\">farglist</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">type</span> <span class=\"n\">α</span><span class=\"o\">)}:</span>\n    <span class=\"n\">pexp</span> <span class=\"n\">ty</span> <span class=\"bp\">→</span> <span class=\"n\">farglist</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">farglist</span> <span class=\"o\">(</span><span class=\"n\">ty</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Fails with the message:</p>\n<div class=\"codehilite\"><pre><span></span>[app_builder] failed to create an &#39;psigma&#39;-application, failed to solve unification constraint for #2 argument (?x_0 → Sort ? =?= type α → Type)\n</pre></div>\n\n\n<p>What can I do to resolve this error?</p>",
        "id": 158875743,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1550577779
    },
    {
        "content": "<p>The same error occurs with a smaller definition too:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">app_builder</span> <span class=\"n\">true</span>\n<span class=\"n\">mutual</span> <span class=\"kn\">inductive</span> <span class=\"n\">pexp</span><span class=\"o\">,</span> <span class=\"n\">farglist</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">tenv</span> <span class=\"n\">self</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">pexp</span><span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">const</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constant_name</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">pexp</span> <span class=\"o\">(</span><span class=\"n\">result_type</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">function_name</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">pexp</span> <span class=\"o\">(</span><span class=\"n\">result_type</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">farglist</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">type</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span><span class=\"o\">:</span> <span class=\"n\">farglist</span> <span class=\"o\">[]</span>\n</pre></div>",
        "id": 158875895,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1550577950
    },
    {
        "content": "<p>What about the definition of <code>type</code>?</p>",
        "id": 158898246,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1550596200
    },
    {
        "content": "<p><code>type</code> is an inductive type:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">type</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">names</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">ref</span><span class=\"o\">:</span> <span class=\"n\">class_name</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">type</span>\n<span class=\"bp\">|</span> <span class=\"n\">data</span><span class=\"o\">:</span> <span class=\"n\">record_name</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">type</span>\n</pre></div>\n\n\n<p>To work around, I have continued the formalisation with the \"do it yourself\" suggestion of Mario, without using nested/mutual. This works out quite well!</p>",
        "id": 158902768,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1550599314
    },
    {
        "content": "<p>The following even smaller example does work for me:</p>\n<div class=\"codehilite\"><pre><span></span>variable {α : Type}\nconstant type : Type → Type\nconstant constant_name : Type → Type\nconstant result_type : constant_name α → type α\nnoncomputable def function_name := constant_name\nconstant unknown : Type\nconstant self : unknown\nconstant tenv : unknown → Type\n\nset_option trace.app_builder true\nmutual inductive pexp, farglist (e : tenv self)\nwith pexp : type α → Type 1\n| const (c : constant_name α): pexp (result_type c)\n| app (f : function_name α) : pexp (result_type f)\nwith farglist: list (type α) → Type 1\n| nil: farglist []\n</pre></div>\n\n\n<p>Is the type of any of these definitions very different than what you have? I don't know how robust mutual inductive types are, maybe there is a bug there. One thing you might want to double check is whether there is a universe error? Does any of the definitions already land in <code>Type 1</code> (instead of <code>Type</code>/<code>Type 0</code>)?</p>",
        "id": 158928167,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1550617510
    },
    {
        "content": "<p>If it's a bug within the compilation of mutual inductive types, then manually indexing the inductive type over <code>type α ⊕ list (type α)</code> is indeed the way to go, although probably a bit more annoying to work with.</p>",
        "id": 158928376,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1550617680
    },
    {
        "content": "<p>Hmm... I can reproduce your error with the following setup:</p>\n<div class=\"codehilite\"><pre><span></span>constant names : Type → Type\nattribute [class] names\nconstant type (α : Type) [names α] : Type\nconstant constant_name : Type → Type\nconstant result_type {α : Type} [names α] (c : constant_name α) : type α\nnoncomputable def function_name := constant_name\nconstant unknown : Type\nconstant self : unknown\nconstant tenv : unknown → Type\n\nvariables {α : Type} [names α]\nset_option trace.app_builder true\nmutual inductive pexp, farglist (e : tenv self)\nwith pexp: type α → Type\n| const (c : constant_name α): pexp (result_type c)\n| app (f : function_name α): pexp (result_type f)\nwith farglist: list (type α) → Type\n| nil: farglist []\n</pre></div>",
        "id": 158928758,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1550617950
    },
    {
        "content": "<p>In my last minimal example (where I reproduced the error), I can do another workaround for this mutual inductive type, by giving all arguments to <code>type</code> explicitly:</p>\n<div class=\"codehilite\"><pre><span></span>variables {α : Type} [n : names α]\nmutual inductive pexp, farglist (e : tenv self)\nwith pexp: @type α n → Type\n| const (c : constant_name α): pexp (result_type c)\n| app (f : function_name α): pexp (result_type f)\nwith farglist: list (@type α n) → Type\n| nil: farglist []\n</pre></div>\n\n\n<p>I suspect that this workaround will also work in your case. There indeed seems to be a bug with type class inference in mutual inductive types.</p>",
        "id": 158929174,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1550618303
    },
    {
        "content": "<p>Yes, I have indeed used class instances. Previously, I also encountered a problem with nested inductive definitions. Next time, I will remember to supply all implicit arguments. Thanks a lot, Floris!</p>",
        "id": 158959974,
        "sender_full_name": "Hans-Dieter Hiep",
        "timestamp": 1550654065
    }
]
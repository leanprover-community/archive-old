[
    {
        "content": "<p>So I know how I can provide default arguments to fields of a class, but how can I provide default proofs <em>about them</em>? I know that for <code>nsmul</code> we use a tactic, which makes me fear I can't write a default as I would have wanted to.</p>\n<p>Here's what I'm working on (wink wink Anne):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">locally_finite_order</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"o\">((</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">finset_Icc</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finset_Ico</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">finset_Ioc</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">finset_Ioo</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">finset_mem_Icc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finset_mem_Ico</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Ico</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>  <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"c1\">-- I would like to replace `finset_Ico` by `(finset_Icc a b).filter (λ x, ¬a ≤ x)`</span>\n<span class=\"kd\">end</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finset_mem_Ioc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Ioc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finset_mem_Ioo</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Ioo</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 253161425,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631567665
    },
    {
        "content": "<p>Indeed, you can only use <code>:= default_val</code> syntax if <code>default_val</code> works always, not only for default arguments.</p>",
        "id": 253162424,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1631568045
    },
    {
        "content": "<p>You can create a bunch of lemmas, write a tactic <code>meta def mytac := </code>[apply_rules [my_lemmas]]<code>, then use </code>. mytac`.</p>",
        "id": 253162544,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1631568099
    },
    {
        "content": "<p>Should be pretty easy here!</p>",
        "id": 253162917,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631568246
    },
    {
        "content": "<p>But that's disappointing Lean doesn't allow that. Is there any technical limitation?</p>",
        "id": 253162936,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631568254
    },
    {
        "content": "<p>Yes, the field has to be type correct</p>",
        "id": 253163827,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631568659
    },
    {
        "content": "<p>I suppose you could call that a technical limitation</p>",
        "id": 253163852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631568673
    },
    {
        "content": "<p>Hmm... <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 253163912,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631568706
    },
    {
        "content": "<p>The standard workaround for this is to use tactics instead, like Yury says. For example see the lt fields in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/preorder\">docs#preorder</a></p>",
        "id": 253163989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631568728
    },
    {
        "content": "<p>The technical limitation rather sounds like you can't \"undefault\" a field that depends on another default field that's been provided by the user.</p>",
        "id": 253164030,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631568750
    },
    {
        "content": "<p><code>order_laws_tac</code> is just <code>intros; refl</code></p>",
        "id": 253164052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631568760
    },
    {
        "content": "<p>Exactly; you would be in trouble if you have <code>def foo (a := 1) (b : a = 1 := rfl)</code> and then decided to use <code>foo 2 _</code></p>",
        "id": 253164164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631568824
    },
    {
        "content": "<p>or more to the point, <code>@foo 2</code></p>",
        "id": 253164236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631568846
    },
    {
        "content": "<p>which has the type <code>\\forall  (b : 2 = 1 := rfl), ...</code> which doesn't typecheck</p>",
        "id": 253164274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631568868
    },
    {
        "content": "<p>I guess I don't know how default arguments work.</p>",
        "id": 253164286,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631568875
    },
    {
        "content": "<p>A default argument <code>(a : nat := 1)</code> is just sugar for <code>(a : opt_param nat 1)</code></p>",
        "id": 253164384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631568929
    },
    {
        "content": "<p>I guess I don't know how <code>out_param</code> works <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 253164424,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631568954
    },
    {
        "content": "<p>and the type signature of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/opt_param\">docs#opt_param</a> makes it clear that you can't put a default value that doesn't match the type</p>",
        "id": 253164426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631568956
    },
    {
        "content": "<p>that is, <code>opt_param (2 = 1) rfl</code> doesn't typecheck because <code>rfl : 2 = 1</code> fails</p>",
        "id": 253164527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631569003
    },
    {
        "content": "<p>this is before we've even used the definition, mind</p>",
        "id": 253164559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631569019
    },
    {
        "content": "<p>Urf, yeah</p>",
        "id": 253164587,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631569033
    },
    {
        "content": "<p>using tactics (\"auto_param\") works around this because we don't try to elaborate it until the definition is used</p>",
        "id": 253164654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631569080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Default.20proofs/near/253164424\">said</a>:</p>\n<blockquote>\n<p>I guess I don't know how <code>out_param</code> works <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[reducible]</span> <span class=\"kd\">def</span> <span class=\"n\">out_param</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>What could be simpler? It's just <code>id</code>!</p>",
        "id": 253164888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631569185
    },
    {
        "content": "<p>unfortunately you can't actually specify a tactic block in lean 3 (lean 4 lets you do this) because <code>tactic</code> is <code>meta</code> so terms of that type can't appear in definitions, so instead you have to specify the name of a tactic like <code>order_laws_tac</code></p>",
        "id": 253164897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631569192
    },
    {
        "content": "<p>which is the reason for all the indirection</p>",
        "id": 253164971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631569206
    },
    {
        "content": "<p>actually that's <code>out_param</code>, not <code>opt_param</code></p>",
        "id": 253165007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631569222
    },
    {
        "content": "<p><code>opt_param</code> is only slightly more complicated:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[reducible]</span> <span class=\"kd\">def</span> <span class=\"n\">opt_param</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">default</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 253165067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631569252
    },
    {
        "content": "<p>In maths we call that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">pr_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>",
        "id": 253165247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631569330
    },
    {
        "content": "<p>It was when you were working on modules a few years ago that it all dawned on me that stuff like id can be harder than it looks.</p>",
        "id": 253165355,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631569387
    },
    {
        "content": "<p>When does the elaborator populate an opt_param with its default vs leaving it as a binder?</p>",
        "id": 253178465,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631577458
    },
    {
        "content": "<p>If it is a regular application <code>f a b</code> and the third argument is <code>c := ...</code> then it will insert the default value</p>",
        "id": 253179699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631578133
    },
    {
        "content": "<p>basically, if there are any pis left over in a regular application and they are auto/opt params then it will insert them</p>",
        "id": 253179751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631578189
    },
    {
        "content": "<p>Unlike implicits and typeclass args, they don't work if used out of order:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"k\">#check</span> <span class=\"n\">foo</span> <span class=\"n\">_</span> <span class=\"mi\">3</span> <span class=\"c1\">-- foo ?M_1 3 : ℕ</span>\n</code></pre></div>",
        "id": 253179868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631578276
    },
    {
        "content": "<p>If you use <code>@foo</code> or <code>@@foo</code> then it will disable all argument insertion</p>",
        "id": 253179896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631578306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Default.20proofs/near/253164654\">said</a>:</p>\n<blockquote>\n<p>using tactics (\"auto_param\") works around this because we don't try to elaborate it until the definition is used</p>\n</blockquote>\n<p>Why can't this be the default behavior?</p>",
        "id": 253215380,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631608085
    },
    {
        "content": "<p>Also, I tried the customized tactic trick, but I'm stuck because I can't reproduce the state that the tactic must solve. With the same example as above, if I do not provide <code>finset_Ico</code>, I get in <code>finset_mem_Ico</code> the goal I expect except for the fact that <code>finset_Icc</code> has been replaced by its definition (which stops me from using <code>finset_mem_Icc</code>). But when I do not provide <code>finset_mem_Ico</code> either, my tactic sees a goal where <code>finset_Ico</code> nor  <code>finset_Icc</code> have been replaced by their definitions, but <code>unfold locally_finite_order.finset_Ico</code> or <code>rw locally_finite_order.finset_Ico</code>won't do anything.</p>",
        "id": 253216746,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631608859
    },
    {
        "content": "<p>/me is writing a MWE</p>",
        "id": 253216868,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631608929
    },
    {
        "content": "<p>I don't understand what's happening in either case.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">finset_Ico_laws_tac</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">whnf_target</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">intros</span> <span class=\"bp\">&gt;&gt;</span> <span class=\"n\">to_expr</span><span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">locally_finite_order.finset_Ico</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_filter</span><span class=\"o\">,</span> <span class=\"n\">finset_mem_Icc</span><span class=\"o\">,</span> <span class=\"n\">and_assoc</span><span class=\"o\">,</span> <span class=\"n\">lt_iff_le_not_le</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">exact</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">locally_finite_order</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"o\">((</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">finset_Icc</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finset_Ico</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">finset_mem_Icc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finset_mem_Ico</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Ico</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">.</span> <span class=\"n\">finset_Ico_laws_tac</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"o\">((</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">locally_finite_order_of_finite_Icc'</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">locally_finite_order</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">finset_Icc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span>\n  <span class=\"n\">finset_mem_Icc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set.finite.mem_to_finset</span><span class=\"o\">,</span> <span class=\"n\">set.mem_Icc</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"c\">/-</span><span class=\"cm\">simplify tactic failed to simplify</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">α : Type u_1,</span>\n<span class=\"cm\">_inst_1 : preorder α,</span>\n<span class=\"cm\">_inst_2 : decidable_rel has_le.le,</span>\n<span class=\"cm\">h : ∀ (a b : α), (set.Icc a b).finite,</span>\n<span class=\"cm\">a b x : α</span>\n<span class=\"cm\">⊢ ?m_1</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">α : Type u_1,</span>\n<span class=\"cm\">_inst_1 : preorder α,</span>\n<span class=\"cm\">_inst_2 : decidable_rel has_le.le,</span>\n<span class=\"cm\">h : ∀ (a b : α), (set.Icc a b).finite,</span>\n<span class=\"cm\">a b x : α</span>\n<span class=\"cm\">⊢ x ∈ filter (λ (x : α), ¬preorder.le b x) _.to_finset ↔ a ≤ x ∧ x &lt; b-/</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">locally_finite_order_of_finite_Icc</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">locally_finite_order</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">finset_Icc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span>\n  <span class=\"n\">finset_mem_Icc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set.finite.mem_to_finset</span><span class=\"o\">,</span> <span class=\"n\">set.mem_Icc</span><span class=\"o\">],</span>\n  <span class=\"n\">finset_mem_Ico</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_filter</span><span class=\"o\">,</span> <span class=\"n\">finset_mem_Icc</span><span class=\"o\">,</span> <span class=\"n\">and_assoc</span><span class=\"o\">,</span> <span class=\"n\">lt_iff_le_not_le</span><span class=\"o\">],</span> <span class=\"c1\">-- finset_mem_Icc</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 253225307,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631613626
    },
    {
        "content": "<p>Bump! Has anybody ideas?</p>",
        "id": 253288816,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631640109
    },
    {
        "content": "<p>I switched to <code>change</code> and it seems more reliable, but I'm still blindcoding</p>",
        "id": 253289313,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631640289
    },
    {
        "content": "<p>Why don't you just write a lemma instead of reproving the lemma every time someone uses your theorem?</p>",
        "id": 253306704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631646851
    },
    {
        "content": "<p>Hm, this has the unfortunate requirement that it needs <code>finset_mem_Icc</code> to be a hypothesis in scope, so you have to write the thing a little weirdly if you want to avoid repeating yourself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">locally_finite_order.mem_Ico_of_mem_Icc</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"o\">((</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span>\n  <span class=\"o\">{</span><span class=\"n\">finset_Icc</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">finset_mem_Icc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_filter</span><span class=\"o\">,</span> <span class=\"n\">finset_mem_Icc</span><span class=\"o\">,</span> <span class=\"n\">and_assoc</span><span class=\"o\">,</span> <span class=\"n\">lt_iff_le_not_le</span><span class=\"o\">]</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">finset_Ico_laws_tac</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">locally_finite_order.mem_Ico_of_mem_Icc</span> <span class=\"n\">finset_mem_Icc</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">locally_finite_order</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"o\">((</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">finset_Icc</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finset_Ico</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">finset_mem_Icc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finset_mem_Ico</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Ico</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">.</span> <span class=\"n\">finset_Ico_laws_tac</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"o\">((</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">locally_finite_order_of_finite_Icc'</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">locally_finite_order</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">finset_mem_Icc</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">{</span> <span class=\"n\">finset_Icc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span>\n          <span class=\"n\">finset_mem_Icc</span> <span class=\"o\">:=</span> <span class=\"n\">finset_mem_Icc</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set.finite.mem_to_finset</span><span class=\"o\">,</span> <span class=\"n\">set.mem_Icc</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 253309509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631647875
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span></p>",
        "id": 253309671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631647914
    },
    {
        "content": "<p>Why can <code>order_laws_tac</code> work using the definition of <code>≤</code> while<code>finset_Ico_laws_tac</code> can't use <code>finset_mem_Icc</code>?</p>",
        "id": 253312289,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631648828
    },
    {
        "content": "<p>Is what I'm trying to achieve that exotic?</p>",
        "id": 253312640,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631648975
    },
    {
        "content": "<p>Because <code>order_laws_tac</code> doesn't need to reference anything outside its own statement for the proof, the proof is just <code>rfl</code> if you leave the default alone</p>",
        "id": 253313168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631649166
    },
    {
        "content": "<p>In your case, the proof for <code>finset_mem_Ico</code> depends on the proof of <code>finset_mem_Icc</code></p>",
        "id": 253313240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631649188
    },
    {
        "content": "<p>I have a very hackish idea to get around this that would look for the current goal metavariable in the \"result\" (the term under construction), and hunt around in the parent of that expression to find the sibling proof of <code>finset_mem_Ico</code></p>",
        "id": 253313726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631649372
    },
    {
        "content": "<p>That's the behavior I would have expected <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 253313982,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631649487
    },
    {
        "content": "<p>because you can make fields dependent on others anyway, so that makes sense to be able to reference them.</p>",
        "id": 253314092,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631649532
    },
    {
        "content": "<p>Here's a way to use spurious dependencies to make it work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">id_annotate</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">locally_finite_order.mem_Ico_of_mem_Icc</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"o\">((</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span>\n  <span class=\"o\">{</span><span class=\"n\">finset_Icc</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">finset_mem_Icc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">id_annotate</span> <span class=\"n\">finset_mem_Icc</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_filter</span><span class=\"o\">,</span> <span class=\"n\">finset_mem_Icc</span><span class=\"o\">,</span> <span class=\"n\">and_assoc</span><span class=\"o\">,</span> <span class=\"n\">lt_iff_le_not_le</span><span class=\"o\">]</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">finset_Ico_laws_tac</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">locally_finite_order.mem_Ico_of_mem_Icc</span> <span class=\"n\">_</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">locally_finite_order</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"o\">((</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">finset_Icc</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finset_Ico</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">finset_mem_Icc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finset_mem_Ico</span> <span class=\"o\">:</span> <span class=\"n\">id_annotate</span> <span class=\"n\">finset_mem_Icc</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Ico</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">finset_Ico_laws_tac</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"o\">((</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">locally_finite_order_of_finite_Icc'</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">set.Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">locally_finite_order</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">finset_Icc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span>\n  <span class=\"n\">finset_mem_Icc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set.finite.mem_to_finset</span><span class=\"o\">,</span> <span class=\"n\">set.mem_Icc</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 253314421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631649634
    },
    {
        "content": "<p>Ahah! The trick is to force <code>finset_mem_Icc</code> to appear in the context?</p>",
        "id": 253315053,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631649847
    },
    {
        "content": "<p>You're a wizard, Mario. Thank you.</p>",
        "id": 253315114,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631649869
    },
    {
        "content": "<p>in this case, we aren't putting it in the context, we're putting it in the <em>type</em> of the goal</p>",
        "id": 253315117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631649871
    },
    {
        "content": "<p>so lean can figure it out by unification</p>",
        "id": 253315208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631649903
    },
    {
        "content": "<p>I'm not sure I understand, but I'll keep that in mind for when I'll learn more about metaprogramming.</p>",
        "id": 253315284,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631649941
    },
    {
        "content": "<p>If you actually want to prove <code>finset_mem_Ico</code> it is now uglified a bit, but autoparams also uglify the goal so I guess it's not that much worse</p>",
        "id": 253315370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631649968
    },
    {
        "content": "<p>this is actually pretty light on actual metaprogramming, this is more like elaborator-programming</p>",
        "id": 253315470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631650009
    },
    {
        "content": "<p>Can the abbreviation be made local?</p>",
        "id": 253315481,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631650015
    },
    {
        "content": "<p>Actually I would probably want to lift it to <code>init.core</code> or <code>logic.basic</code> or so</p>",
        "id": 253315546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631650043
    },
    {
        "content": "<p>as you can see it's quite general</p>",
        "id": 253315559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631650050
    },
    {
        "content": "<p>But I didn't see an exact match among the annotation identity functions that lean has already</p>",
        "id": 253315709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631650100
    },
    {
        "content": "<p>Ah yeah, why not (even though it probably already exists?), but I was more thinking about stopping it from appearing in the goal.</p>",
        "id": 253315720,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631650104
    },
    {
        "content": "<p>it's reducible so probably breathing lightly on it will make it go away</p>",
        "id": 253315776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631650133
    },
    {
        "content": "<p>in particular, if you want to prove that goal the first thing you do will probably be <code>intros a b x</code> and that will get rid of the junk</p>",
        "id": 253315855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631650167
    },
    {
        "content": "<p>What a metaphor. What else is there to scare it away?</p>",
        "id": 253315859,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631650169
    },
    {
        "content": "<p>Ah yeah! then that's probably fine.</p>",
        "id": 253315893,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631650185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Default.20proofs/near/253315546\">said</a>:</p>\n<blockquote>\n<p>Actually I would probably want to lift it to <code>init.core</code> or <code>logic.basic</code> or so</p>\n</blockquote>\n<p>Do <em>you</em> want to do that? I have no idea how to name it nor where to put it further than what you said.</p>",
        "id": 253316167,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631650294
    },
    {
        "content": "<p>Put it in the <code>miscellaneous</code> section of <code>logic.basic</code> for now, if you are working on a PR</p>",
        "id": 253316916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631650585
    },
    {
        "content": "<p>Perhaps it's possible to use something like <code>ite</code> to make the dependent field only take a default value if the base field is the default value? Something that looks roughly like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">finset_mem_Ico</span> <span class=\"o\">:</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">finset_Ico</span> <span class=\"bp\">=</span> <span class=\"n\">default_value</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">opt_param</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">finset_Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I don't think <code>ite</code> is definitionally equal to the <code>opt_param</code> option and even if it is I'm worried the optional parameter mechanism won't evaluate the type to recognize <code>opt_param</code>, but maybe some modification of this (perhaps with the \". tactic\" system that I haven't learned yet) can be used for a general mechanism for dependent optional parameters.</p>",
        "id": 253414120,
        "sender_full_name": "Itai Bar-Natan",
        "timestamp": 1631712954
    },
    {
        "content": "<p>This can't work like that because <code>finset_Ico = default_value</code> is always true for correct <code>locally_finite_order</code> declarations. <code>=</code> can't distinguish between propositional and definitional equality. But maybe you can instead put in a tactic that tries <code>refl</code> and changes branch depending on its success or failure?<br>\nAlso note that an <code>ite</code>can't do it because you need the hypothesis <code>finset_Ico = default_value</code> to fill in the <code>(...)</code>. You must use <code>dite</code> instead.</p>",
        "id": 253419164,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631714615
    }
]
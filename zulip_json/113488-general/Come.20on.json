[
    {
        "content": "<p>Come on Lean :-)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"bp\">@</span><span class=\"n\">approximates_linear_on.image_mem_nhds.</span><span class=\"o\">{</span><span class=\"n\">u_1</span> <span class=\"n\">u_2</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"bp\">ùïú</span> <span class=\"n\">_inst_1</span> <span class=\"n\">E</span> <span class=\"n\">_inst_2</span> <span class=\"n\">_inst_3</span> <span class=\"n\">F</span> <span class=\"n\">_inst_4</span> <span class=\"n\">_inst_5</span> <span class=\"n\">cs</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">c</span> <span class=\"n\">f'</span>\n    <span class=\"n\">f'symm</span>\n    <span class=\"n\">hf</span>\n    <span class=\"n\">x</span>\n    <span class=\"n\">hs</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">hs</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">has_mem.mem.</span><span class=\"o\">{</span><span class=\"n\">u_2</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">set.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">filter.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">filter.has_mem.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">s</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nhds.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_space.to_topological_space.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">metric_space.to_uniform_space'.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">normed_group.to_metric_space.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span> <span class=\"n\">_inst_2</span><span class=\"o\">)))</span>\n       <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">has_mem.mem.</span><span class=\"o\">{</span><span class=\"n\">u_2</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">set.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">filter.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">filter.has_mem.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">s</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nhds.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">uniform_space.to_topological_space.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">metric_space.to_uniform_space'.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">normed_group.to_metric_space.</span><span class=\"o\">{</span><span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"n\">E</span> <span class=\"n\">_inst_2</span><span class=\"o\">)))</span>\n       <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm sure I'll find a way to help Lean, but I am still amazed at how well it works like 99.9% of the time, and how sometimes it chokes for no reason I can spot.</p>",
        "id": 226294894,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1613294513
    },
    {
        "content": "<p>There were two things named <code>s</code>. So the stupid one here wasn't Lean ;-)</p>",
        "id": 226295014,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1613294718
    },
    {
        "content": "<p>I think, lean (editor integration) should warn users when they have two variables with the same name in tactic context.</p>",
        "id": 226299288,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1613301280
    },
    {
        "content": "<p>This occasionally catches me out too. I know there's some technical reason why it's hard to spot duplicate names but there are so many smart people here, there must be a trick. Recently I've started to try and be really principled about variable names, calling things <code>hxS</code> if they say <code>x \\in S</code> rather than just h and this was partly the reason. I even try to name all variables after things like <code>split_ifs</code> rather than just getting a bunch of <code>h</code>s. I was rather proud when a student asked me in my class why they could not name a hypothesis <code>h\\notP</code> because they even thought that lean demanded such principled choices. I think tactics like <code>split_ifs</code> should arguably fail if the user doesn't give variable names (I know the CS people will disagree but didn't someone say that this will be the default in lean 4?) and I'm wondering whether the system should tell us what to write here and generally try and keep us more honest with variable naming eg by checking for dupes. On a blackboard I can't just say \"now introduce this nameless variable\" and students and lecturers both get confused if lecturers call two things X. It should be banned!</p>",
        "id": 226301348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613304479
    },
    {
        "content": "<p>But \"now introduce this nameless hypothesis\" is reasonably on a blackboard, right?</p>",
        "id": 226303100,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613307303
    },
    {
        "content": "<p>\"Let's assume that...\"</p>",
        "id": 226303393,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1613307792
    },
    {
        "content": "<p>If you're going to use it again you call it (*), right?</p>",
        "id": 226303674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613308280
    },
    {
        "content": "<p>Lean 4 suffixes shadowed variables with a cross<span aria-label=\"cross\" class=\"emoji emoji-271d\" role=\"img\" title=\"cross\">:cross:</span> to show It's Dead, Jim</p>\n<blockquote>\n<p>I think tactics like split_ifs should arguably fail if the user doesn't give variable names (I know the CS people will disagree but didn't someone say that this will be the default in lean 4?)</p>\n</blockquote>\n<p><em>By default</em>, anonymously introduced hypotheses are inaccessible in Lean 4. They also get a cross (out of the door, line on the left).</p>",
        "id": 226307180,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1613313306
    },
    {
        "content": "<p>There have been times with some tactics (<code>rcases</code>?) when I have been literally unable to name the variables it spits out :-/</p>",
        "id": 226308246,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613314813
    },
    {
        "content": "<p>For hypotheses spit out by things like split cases, french quotes have been useful in the cases where I don't want to worry about name tracking, or where restructuring of goals would have changed the auto-generated names anyway. So like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The second simplicial identity -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Œ¥_comp_œÉ_of_le</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">‚â§</span> <span class=\"n\">j.cast_succ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Œ¥</span> <span class=\"n\">i.cast_succ</span> <span class=\"bp\">‚â´</span> <span class=\"n\">œÉ</span> <span class=\"n\">j.succ</span> <span class=\"bp\">=</span> <span class=\"n\">œÉ</span> <span class=\"n\">j</span> <span class=\"bp\">‚â´</span> <span class=\"n\">Œ¥</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">Œ¥</span><span class=\"o\">,</span> <span class=\"n\">œÉ</span><span class=\"o\">,</span> <span class=\"n\">fin.succ_above</span><span class=\"o\">,</span> <span class=\"n\">fin.pred_above</span><span class=\"o\">],</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">i</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">j</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">k</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.mk_le_mk</span><span class=\"o\">,</span> <span class=\"n\">fin.cast_succ_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"k\">with</span> <span class=\"n\">push_cast</span><span class=\"o\">,</span> <span class=\"c1\">-- `simp?` doesn't work here</span>\n  <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Hope for the best from `linarith`:</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">linarith</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- Two of the goals need special handling:</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">nat.le_of_pred_lt</span> <span class=\"o\">‚Äπ</span><span class=\"n\">fin.cast_succ</span> <span class=\"o\">(</span><span class=\"n\">fin.pred</span> <span class=\"o\">‚ü®</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">k_property</span><span class=\"o\">‚ü©</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">‚ü®</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i_property</span><span class=\"o\">‚ü©‚Ä∫,</span>\n    <span class=\"n\">change</span> <span class=\"n\">k</span> <span class=\"bp\">‚â§</span> <span class=\"n\">i</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">linarith</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">nat.succ_pred_eq_of_pos</span> <span class=\"o\">(</span><span class=\"n\">lt_of_le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">‚Äπ</span><span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span><span class=\"o\">‚Ä∫))</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226309733,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1613316657
    }
]
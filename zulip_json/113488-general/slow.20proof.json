[
    {
        "content": "<p>I am in the process of speeding up proofs that fail when <code>gsmul</code> is made into data, on my branch <code>gsmul_data</code>. First incredible example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">forget₂_AddCommGroup_preserves_limits_aux</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">Ring</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_limit</span> <span class=\"o\">((</span><span class=\"n\">forget₂</span> <span class=\"n\">Ring</span> <span class=\"n\">AddCommGroup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_cone</span> <span class=\"o\">(</span><span class=\"n\">limit_cone</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">AddCommGroup.limit_cone_is_limit</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"n\">forget₂</span> <span class=\"n\">Ring</span> <span class=\"n\">AddCommGroup</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Takes 35s on my branch. Changing it to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">forget₂_AddCommGroup_preserves_limits_aux</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">Ring</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_limit</span> <span class=\"o\">((</span><span class=\"n\">forget₂</span> <span class=\"n\">Ring</span> <span class=\"n\">AddCommGroup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_cone</span> <span class=\"o\">(</span><span class=\"n\">limit_cone</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">AddCommGroup.limit_cone_is_limit</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"n\">forget₂</span> <span class=\"n\">Ring</span> <span class=\"n\">AddCommGroup</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>goes down to 185ms. I haven't found a term-mode way to achieve this (even with <code>(... : _)</code> or <code>id</code> insertion or whatever).</p>",
        "id": 234979594,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618656477
    },
    {
        "content": "<p>I have a silly question:  What is the term proof you get by <code>#print forget₂_AddCommGroup_preserves_limits_aux</code> (tactic version), and how long does it take to run that term proof?</p>",
        "id": 234980904,
        "sender_full_name": "Jason Rute",
        "timestamp": 1618657861
    },
    {
        "content": "<p>Wow. That's really terrible, and largely my fault. (I don't know a fix, I guess I just have too high tolerance for slow-to-compile proofs.)</p>",
        "id": 234981501,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618658522
    },
    {
        "content": "<p>That's not your fault, that's Lean's fault, obviously.</p>",
        "id": 234981565,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618658554
    },
    {
        "content": "<p>The question is whether there is some way to let it switch automatically to the other elaboration procedure that makes the proof essentially instant.</p>",
        "id": 234981582,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618658589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/113488-general/topic/slow.20proof/near/234980904\">said</a>:</p>\n<blockquote>\n<p>I have a silly question:  What is the term proof you get by <code>#print forget₂_AddCommGroup_preserves_limits_aux</code> (tactic version), and how long does it take to run that term proof?</p>\n</blockquote>\n<p>The proof term is the same for the tactic mode and the term mode version. Even using the <code>pp.all</code> output, like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">yet_another_try</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">small_category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">Ring</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_limit</span> <span class=\"o\">((</span><span class=\"n\">forget₂</span> <span class=\"n\">Ring</span> <span class=\"n\">AddCommGroup</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_cone</span> <span class=\"o\">(</span><span class=\"n\">limit_cone</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">AddCommGroup.limit_cone_is_limit.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">J</span> <span class=\"n\">_inst_1</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">category_theory.functor.comp.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">u</span> <span class=\"n\">u</span> <span class=\"n\">u</span> <span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">J</span> <span class=\"n\">_inst_1</span> <span class=\"n\">Ring.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">Ring.large_category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">AddCommGroup.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n       <span class=\"n\">AddCommGroup.large_category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n       <span class=\"n\">F</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">category_theory.forget₂.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"n\">u</span> <span class=\"n\">u</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">Ring.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">AddCommGroup.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">Ring.large_category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n          <span class=\"n\">Ring.concrete_category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n          <span class=\"n\">AddCommGroup.large_category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n          <span class=\"n\">AddCommGroup.concrete_category.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n          <span class=\"n\">Ring.has_forget_to_AddCommGroup.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}))</span>\n</code></pre></div>\n<p>This takes 21s to compile (so, a little bit faster than the original term mode, but still 150 times slower than the tactic mode version, that gives exactly the same proof). I don't understand how this is possible.</p>",
        "id": 234982214,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618659263
    },
    {
        "content": "<p>Does the @ trick work? (<code>:= @AddCommGroup.limit_cone_is_limit _ _ ...</code>)This changes default elaboration procedure</p>",
        "id": 234982649,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618659736
    },
    {
        "content": "<p>The <code>pp.all</code> version I gave uses <code>@</code> versions for everything, and it is super-slow.</p>",
        "id": 234982697,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618659804
    },
    {
        "content": "<p>This is very strange. Can I see it in action on some branch?</p>",
        "id": 234982959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618660084
    },
    {
        "content": "<p>Yes, on <a href=\"https://github.com/leanprover-community/mathlib/tree/gsmul_data\">branch#gsmul_data</a>, in the file algebra/category/CommRing/limits.lean, line 282. Should be the same in master, by the way (although a little bit faster, so a little bit easier to investigate).</p>",
        "id": 234983136,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618660241
    },
    {
        "content": "<p>There is a motive here. Next super-slow proof in the file is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Auxiliary construction for the `creates_limit` instance below. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_limit_lifted_cone</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">CommRing</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_limit</span> <span class=\"o\">(</span><span class=\"n\">lifted_cone</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_limit.of_faithful</span> <span class=\"o\">(</span><span class=\"n\">forget₂</span> <span class=\"n\">_</span> <span class=\"n\">Ring.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">Ring.limit_cone_is_limit</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Ring.limit_cone_is_limit</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"o\">((</span><span class=\"n\">forget₂</span> <span class=\"n\">_</span> <span class=\"n\">Ring.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">map_cone</span> <span class=\"n\">s</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>taking 38s seconds. Changing it to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Auxiliary construction for the `creates_limit` instance below. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_limit_lifted_cone</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">CommRing</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_limit</span> <span class=\"o\">(</span><span class=\"n\">lifted_cone</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"o\">:=</span> <span class=\"n\">Ring.limit_cone_is_limit</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"n\">forget₂</span> <span class=\"n\">CommRing</span> <span class=\"n\">Ring</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">is_limit.of_faithful</span> <span class=\"o\">(</span><span class=\"n\">forget₂</span> <span class=\"n\">_</span> <span class=\"n\">Ring.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"n\">this</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Ring.limit_cone_is_limit</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"o\">((</span><span class=\"n\">forget₂</span> <span class=\"n\">_</span> <span class=\"n\">Ring.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">map_cone</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>it takes 250 ms.</p>",
        "id": 234984348,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618661424
    },
    {
        "content": "<p>Just understanding what is going on here and giving some good practice rules could be extremely helpful (I just found this by random trial and error!)</p>",
        "id": 234984407,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618661468
    },
    {
        "content": "<p>I wonder could we have a job that maintains a list of the slowest proofs (and defs) in Mathlib and publishes the slowest 100 somewhere, not to apply pressure to anyone, but just to give some visibility.</p>",
        "id": 234990361,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1618668021
    },
    {
        "content": "<p>I'm starting to investigate. The problem seems to be that the type of the <code>def</code> is not fully elaborated before the term gets elaborated. <br>\nJust adding <code>by exact</code> at the start of the proof speeds it up (so far I'm only investigating <code>yet_another_try</code>)</p>",
        "id": 235003249,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1618679519
    },
    {
        "content": "<p>Oh, but that doesn't necessarily help in other examples.</p>",
        "id": 235004089,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1618680248
    },
    {
        "content": "<p>Fwiw, in <a href=\"#narrow/stream/267928-condensed-mathematics/topic/thm95.2Ehomotopy/near/234983175\">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/thm95.2Ehomotopy/near/234983175</a> we needed <code>by convert</code></p>",
        "id": 235004301,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618680468
    },
    {
        "content": "<p>Yeah <code>by apply</code> or <code>by convert</code> work better. They have basically the same effect as what Sebastien did in the first post (<code>by { have := foo, exact foo }</code>)</p>",
        "id": 235005373,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1618681462
    },
    {
        "content": "<p>I don't have much to report after investigating. The elaborator has to do <em>a lot</em> of definitional unfolding to make sense of these proofs, and presumably it starts unfolding the wrong things to try to make two types definitionally equal.</p>",
        "id": 235007098,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1618683138
    },
    {
        "content": "<p>I really like the <code>by convert</code> strategy. It really means: build this term as you like, and afterwards try to match it up with the required type. And it works more efficiently than putting <code>( : _)</code> (which is supposed to do the same) or adding an <code>id</code> somewhere. I just used it to speed up another proof, by the way, from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">refine</span> <span class=\"n\">jacobson_bot_of_integral_localization</span> <span class=\"o\">(</span><span class=\"n\">quotient_map</span> <span class=\"n\">P</span> <span class=\"n\">C</span> <span class=\"n\">le_rfl</span><span class=\"o\">)</span> <span class=\"n\">quotient_map_injective</span>\n      <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">localization.of</span> <span class=\"o\">(</span><span class=\"n\">submonoid.powers</span> <span class=\"o\">(</span><span class=\"n\">p.map</span> <span class=\"o\">(</span><span class=\"n\">quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">P.comap</span> <span class=\"n\">C</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">leading_coeff</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">localization.of</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is_integral_localization_map_polynomial_quotient</span> <span class=\"n\">P</span> <span class=\"n\">_</span> <span class=\"n\">pP</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">refine</span> <span class=\"n\">jacobson_bot_of_integral_localization</span> <span class=\"o\">(</span><span class=\"n\">quotient_map</span> <span class=\"n\">P</span> <span class=\"n\">C</span> <span class=\"n\">le_rfl</span><span class=\"o\">)</span> <span class=\"n\">quotient_map_injective</span>\n      <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">localization.of</span> <span class=\"o\">(</span><span class=\"n\">submonoid.powers</span> <span class=\"o\">(</span><span class=\"n\">p.map</span> <span class=\"o\">(</span><span class=\"n\">quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">P.comap</span> <span class=\"n\">C</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">leading_coeff</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">localization.of</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">is_integral_localization_map_polynomial_quotient</span> <span class=\"n\">P</span> <span class=\"n\">_</span> <span class=\"n\">pP</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)),</span>\n</code></pre></div>\n<p>(goes down from 20s to 1s).</p>",
        "id": 235009318,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618685464
    },
    {
        "content": "<p>I just notice and fix these along the way because the build fails otherwise, but I think it's great to force us to do this, because otherwise these would get unnoticed.</p>",
        "id": 235009408,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618685567
    },
    {
        "content": "<p>(And I am afraid this PR will globally add a few minutes again, because all the basic structures we use all the time get more complicated).</p>",
        "id": 235009450,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618685623
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> has (rightly!) raised in <a href=\"https://github.com/leanprover-community/mathlib/issues/7253\">#7253</a> the concern that <code>by convert</code> proofs are not suitable for defs, because they introduce additional <code>eq.mpr</code>. On the other hand, the pattern</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>produces exactly the same <code>pp.all</code> output as <code>...</code> (so in particular <code>have</code> does not forget the data it is given, which is surprising to me), and in the situations of interest it is much faster than just <code>...</code> (ratio 1 to 100)! Its main problem is that it is too verbose compared to <code>by convert ...</code>. A tactic <code>speedup</code> (or <code>unusual_elaboration</code> or whatever) doing this would be better, but I am completely unable to write this (which should normally be a one-liner). I tried something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.subring</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"n\">setup_tactic_parser</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">interactive</span>\n\n<span class=\"sd\">/-- Try another elaboration tactic -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">speedup</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">texpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"bp\">`</span><span class=\"o\">[</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">interactive</span>\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n</code></pre></div>\n<p>but of course it doesn't work since <code>have := q</code> is not referring to <code>parse texpr</code>. Anyone know how to do this?</p>",
        "id": 235084730,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618764510
    },
    {
        "content": "<p>Do you have an example lemma where you want to apply this tactic?</p>",
        "id": 235084861,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618764696
    },
    {
        "content": "<p>I mean a MWE, not the snippets from this thread</p>",
        "id": 235084913,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618764730
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.category.CommRing.limits</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SemiRing</span>\n<span class=\"kn\">open</span> <span class=\"n\">has_limits</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">small_category</span> <span class=\"n\">J</span><span class=\"o\">]</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"n\">SemiRing</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_limit</span> <span class=\"o\">((</span><span class=\"n\">forget₂</span> <span class=\"n\">SemiRing</span> <span class=\"n\">AddCommMon</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_cone</span> <span class=\"o\">(</span><span class=\"n\">limit_cone</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">AddCommMon.limit_cone_is_limit</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"n\">forget₂</span> <span class=\"n\">SemiRing</span> <span class=\"n\">AddCommMon</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">SemiRing</span>\n</code></pre></div>\n<p>takes 2s on my computer. With <code>by convert</code> or the <code>begin have := ..., exact this end</code>, it goes down to 100ms.</p>",
        "id": 235085232,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618765154
    },
    {
        "content": "<p>(on mathlib master)</p>",
        "id": 235085247,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618765189
    },
    {
        "content": "<p>Could you try the naive </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">speedup</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">texpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">to_expr</span> <span class=\"n\">q</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">tactic.exact</span>\n</code></pre></div>",
        "id": 235085393,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618765287
    },
    {
        "content": "<p>I see</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elaboration</span><span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">compilation</span> <span class=\"n\">took</span> <span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">09</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">30</span><span class=\"o\">:</span><span class=\"mi\">3</span>\n<span class=\"n\">elaboration</span><span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">execution</span> <span class=\"n\">took</span> <span class=\"mi\">38</span><span class=\"n\">ms</span>\n<span class=\"n\">num.</span> <span class=\"n\">allocated</span> <span class=\"n\">objects</span><span class=\"o\">:</span>  <span class=\"mi\">76</span>\n<span class=\"n\">num.</span> <span class=\"n\">allocated</span> <span class=\"n\">closures</span><span class=\"o\">:</span> <span class=\"mi\">270</span>\n   <span class=\"mi\">38</span><span class=\"n\">ms</span>   <span class=\"mi\">100</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"bp\">%</span>   <span class=\"n\">tactic.interactive.speedup</span>\n   <span class=\"mi\">38</span><span class=\"n\">ms</span>   <span class=\"mi\">100</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"bp\">%</span>   <span class=\"n\">_interaction._lambda_2</span>\n   <span class=\"mi\">38</span><span class=\"n\">ms</span>   <span class=\"mi\">100</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"bp\">%</span>   <span class=\"n\">tactic.step</span>\n   <span class=\"mi\">38</span><span class=\"n\">ms</span>   <span class=\"mi\">100</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"bp\">%</span>   <span class=\"n\">_interaction</span>\n   <span class=\"mi\">38</span><span class=\"n\">ms</span>   <span class=\"mi\">100</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"bp\">%</span>   <span class=\"n\">tactic.istep</span>\n   <span class=\"mi\">38</span><span class=\"n\">ms</span>   <span class=\"mi\">100</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"bp\">%</span>   <span class=\"n\">tactic.istep._lambda_1</span>\n   <span class=\"mi\">38</span><span class=\"n\">ms</span>   <span class=\"mi\">100</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"bp\">%</span>   <span class=\"n\">scope_trace</span>\n   <span class=\"mi\">35</span><span class=\"n\">ms</span>    <span class=\"mi\">92</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">%</span>   <span class=\"n\">tactic.exact</span>\n    <span class=\"mi\">3</span><span class=\"n\">ms</span>     <span class=\"mi\">7</span><span class=\"bp\">.</span><span class=\"mi\">9</span><span class=\"bp\">%</span>   <span class=\"n\">tactic.to_expr</span>\n</code></pre></div>",
        "id": 235085572,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618765446
    },
    {
        "content": "<p>Works like a charm! Thanks!</p>",
        "id": 235085594,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618765460
    },
    {
        "content": "<p>Can you give us the figures you get with <code>by exact</code>, to compare?</p>",
        "id": 235085687,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618765521
    },
    {
        "content": "<p>I know you're busy, but one day you should take  one hour to read <a href=\"https://leanprover-community.github.io/extras/tactic_writing.html\">https://leanprover-community.github.io/extras/tactic_writing.html</a>. I'm sure you'll enjoy being able to write such a basic tactic yourself (and that one is totally covered by this simple minded tutorial).</p>",
        "id": 235085760,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618765566
    },
    {
        "content": "<p>Without any tactic I read</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">parsing</span> <span class=\"n\">took</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">337</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">elaboration</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">53</span><span class=\"n\">s</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">type</span> <span class=\"n\">checking</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">23</span><span class=\"bp\">.</span><span class=\"mi\">3</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">decl</span> <span class=\"n\">post</span><span class=\"bp\">-</span><span class=\"n\">processing</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">21</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"n\">ms</span>\n</code></pre></div>",
        "id": 235085789,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618765606
    },
    {
        "content": "<p>Sorry, this is not quite the same trace.</p>",
        "id": 235085806,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618765632
    },
    {
        "content": "<p>With the tactic I get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">parsing</span> <span class=\"n\">took</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">09</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">elaboration</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">48</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">type</span> <span class=\"n\">checking</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">22</span><span class=\"bp\">.</span><span class=\"mi\">3</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">decl</span> <span class=\"n\">post</span><span class=\"bp\">-</span><span class=\"n\">processing</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">22</span><span class=\"bp\">.</span><span class=\"mi\">6</span><span class=\"n\">ms</span>\n</code></pre></div>",
        "id": 235085809,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618765639
    },
    {
        "content": "<p>So I guess the comparison you are interested in is the 1.53s  vs 48.1ms</p>",
        "id": 235085841,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618765681
    },
    {
        "content": "<p>But of course parsing takes away a tiny bit of this gain.</p>",
        "id": 235085929,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618765711
    },
    {
        "content": "<p>And with <code>by exact</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">parsing</span> <span class=\"n\">took</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">13</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">elaboration</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">37</span><span class=\"n\">s</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">type</span> <span class=\"n\">checking</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">22</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">decl</span> <span class=\"n\">post</span><span class=\"bp\">-</span><span class=\"n\">processing</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">20</span><span class=\"bp\">.</span><span class=\"mi\">8</span><span class=\"n\">ms</span>\n</code></pre></div>",
        "id": 235085963,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618765776
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> <code>apply q</code> does almost the same as <code>have := q, exact this</code>. Does that work instead?</p>",
        "id": 235086023,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1618765816
    },
    {
        "content": "<p>And yet another one, with <code>(stuff  : _)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">parsing</span> <span class=\"n\">took</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">481</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">elaboration</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">847</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">type</span> <span class=\"n\">checking</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">20</span><span class=\"bp\">.</span><span class=\"mi\">3</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">decl</span> <span class=\"n\">post</span><span class=\"bp\">-</span><span class=\"n\">processing</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">20</span><span class=\"n\">ms</span>\n</code></pre></div>",
        "id": 235086074,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618765883
    },
    {
        "content": "<p>And another for Floris, with <code>by apply stuff</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">parsing</span> <span class=\"n\">took</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">32</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">elaboration</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">50</span><span class=\"bp\">.</span><span class=\"mi\">3</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">type</span> <span class=\"n\">checking</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">21</span><span class=\"bp\">.</span><span class=\"mi\">7</span><span class=\"n\">ms</span>\n<span class=\"n\">scratch.lean</span><span class=\"o\">:</span><span class=\"mi\">28</span><span class=\"o\">:</span><span class=\"mi\">18</span>\n<span class=\"n\">decl</span> <span class=\"n\">post</span><span class=\"bp\">-</span><span class=\"n\">processing</span> <span class=\"n\">of</span> <span class=\"n\">forget₂_AddCommMon_preserves_limits_aux'</span> <span class=\"n\">took</span> <span class=\"mi\">21</span><span class=\"bp\">.</span><span class=\"mi\">4</span><span class=\"n\">ms</span>\n</code></pre></div>",
        "id": 235086137,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618765933
    },
    {
        "content": "<p>Yes, <code>by apply</code> is perfect, thanks (and it takes less characters to type than <code>by speedup</code>).</p>",
        "id": 235086281,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618766118
    },
    {
        "content": "<p>If someone could explain to me what is going on under the hood, I'd be extremely happy. My impression was that a tactic proof was creating a term proof, and that at the end of the proof this term proof was checked by the kernel. So I don't get how a tactic proof can be so much faster than the <code>pp.all</code> term it generates, for which there is no elaboration do be done.</p>",
        "id": 235086403,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618766235
    },
    {
        "content": "<p>I know nothing about how Lean really works, but my only guesses are some kind of cache or subterm sharing is involved.</p>",
        "id": 235086496,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1618766352
    },
    {
        "content": "<p>If you give the <code>pp.all</code> term for the type also, then all examples (that I've tried) are really quick. The problem with <code>yet_another_try</code> above is that there are still implicit arguments in the type of the definition, which is being elaborated simultaneously with the term. Even though you give the term explicitly, because of all the definitional unfolding required to unify the term with the type (which still has implicit information), presumably the Lean elaborator goes into a wrong rabbit hole of unfolding the wrong thing and getting huge terms.<br>\nNote that for example making <code>yet_another_try</code> a <code>lemma</code> forces Lean to first elaborate the type before even looking at the term. That is also quick.</p>",
        "id": 235086728,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1618766570
    },
    {
        "content": "<p>Ah, I had not imagined it could come from the type of the definition, thanks!</p>",
        "id": 235086967,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618766810
    },
    {
        "content": "<p>Unrelated question: it looks like fixing the nsmul diamond has been a huge performance hit for leanchecker (doubling its time, roughly from 30 minutes to 1 hour). Is this something we should worry about, or that should not surprise us?</p>",
        "id": 235087057,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618766913
    },
    {
        "content": "<p>Does fixing the gsmul diamond make things even worse?</p>",
        "id": 235087460,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618767257
    },
    {
        "content": "<p>I don't know, as this PR hasn't reached the leanchecker step yet.</p>",
        "id": 235087583,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618767371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/slow.20proof/near/235087057\">said</a>:</p>\n<blockquote>\n<p>Unrelated question: it looks like fixing the nsmul diamond has been a huge performance hit for leanchecker (doubling its time, roughly from 30 minutes to 1 hour). Is this something we should worry about, or that should not surprise us?</p>\n</blockquote>\n<p>I think there is a serious bug here, that I posted about on the PR about switching nat mul recursion order, but might be related to this as well. The issue that came up there is that the kernel is unfolding numerals, like <code>int.add 23 45 = 23 + 45</code> will go and unfold <code>23</code> instead of the typeclass for <code>+</code>.</p>",
        "id": 235110196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618788659
    },
    {
        "content": "<p>The leanchecker step on <a href=\"https://github.com/leanprover-community/mathlib/issues/7255\">#7255</a> fixing the gsmul diamonds is indeed taking 1h27...</p>",
        "id": 235137564,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618816473
    }
]
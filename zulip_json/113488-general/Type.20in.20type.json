[
    {
        "content": "<p>My son tells me that the type of type is type in python. I asked him if nat was equal to int in python and he said there wasn't a nat, but that int == string was false. I told him that if the type of type was type then he could probably prove that false was equal to true anyway. But I don't know the proof in lean. How do I prove false from Type : Type? This is Giraud's paradox right?</p>",
        "id": 233041033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617492890
    },
    {
        "content": "<p>Yes this is girard's paradox. It's a little hard to construct in lean because <code>Type : Type</code> doesn't typecheck</p>",
        "id": 233041275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617493192
    },
    {
        "content": "<p>I don't know any very easy proof. The usual proof is to construct something equivalent to ordinals and run the burali-forti paradox on the result</p>",
        "id": 233041362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617493277
    },
    {
        "content": "<p>I found <a href=\"http://www.cs.cmu.edu/~kw/research/hurkens95tlca.elf\">http://www.cs.cmu.edu/~kw/research/hurkens95tlca.elf</a>, although you have to read LF to follow it</p>",
        "id": 233041430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617493353
    },
    {
        "content": "<p>(Things in Python get quite fun when you also consider <code>type</code> is an instance (== term) and subclass of <code>object</code>, and <code>object</code> is an instance of <code>type</code>)</p>",
        "id": 233043047,
        "sender_full_name": "Julian Berman",
        "timestamp": 1617495285
    },
    {
        "content": "<p>If there were a <code>nat</code> in python though, it would not be equal to <code>int</code>. (E.g. there's a rational number type, and it's not equal to <code>int</code>.) In general the default in Python is objects compare for equality by identity by default, and it'd be silly to consider <code>int</code> and rational (or nat) equal to each other under the language semantics, there wouldn't be a reason to.</p>",
        "id": 233043293,
        "sender_full_name": "Julian Berman",
        "timestamp": 1617495614
    },
    {
        "content": "<p>We have an abstract base class (== gross version of a typeclass) that is the base of the number hierarchy: <a href=\"https://docs.python.org/3/library/numbers.html#numbers.Number\">https://docs.python.org/3/library/numbers.html#numbers.Number</a> -- so you are free to do <code>class Natural(numbers.Number)</code> if you truly felt like it.</p>",
        "id": 233043424,
        "sender_full_name": "Julian Berman",
        "timestamp": 1617495751
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kd\">constant</span> <span class=\"n\">pi</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">lam</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">pi</span> <span class=\"n\">A</span>\n<span class=\"kd\">constant</span> <span class=\"n\">app</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">pi</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">x</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">axiom</span> <span class=\"n\">beta</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">lam</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">pi</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">app</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">girard</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">pi</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">τ</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">univ</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span>\n<span class=\"n\">lam</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"bp\">|</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">univ</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">app</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"bp\">∈</span> <span class=\"n\">T</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">app</span> <span class=\"n\">S</span> <span class=\"n\">_</span> <span class=\"n\">τ</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">τ_σ_def</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">univ</span> <span class=\"bp\">|</span> <span class=\"n\">τ</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">,</span> <span class=\"n\">τ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">paradox</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"n\">τ</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">univ</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">},</span>\n  <span class=\"k\">let</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"bp\">¬</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">univ</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">τ</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ω</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"n\">ω</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ω</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"n\">this</span> <span class=\"n\">δ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">e</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">δ</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">f</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"n\">τ</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">τ_σ_def</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"n\">τ</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">ω</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">girard</span>\n</code></pre></div>",
        "id": 233044380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617497050
    },
    {
        "content": "<p>I can't honestly say I understand the proof, but it typechecks</p>",
        "id": 233044415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617497119
    },
    {
        "content": "<p>Here's one way you can do this in Lean without new constants: We can show that Type isn't small, ie it's not possible for a type to be equivalent to Type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">logic.small</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cast_helper</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">),</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">yx</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">A</span> <span class=\"n\">yx</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">subst</span> <span class=\"n\">yx</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">no_type_in_type</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">introI</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">pi</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">shrink</span> <span class=\"kt\">Type</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">((</span><span class=\"n\">equiv_shrink</span> <span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n  <span class=\"k\">let</span> <span class=\"n\">lam</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">pi</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">p</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">},</span> <span class=\"n\">pi</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">A</span> <span class=\"n\">p</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">A</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">equiv_shrink</span> <span class=\"kt\">Type</span> <span class=\"n\">t</span><span class=\"o\">)),</span>\n    <span class=\"n\">apply</span> <span class=\"o\">((</span><span class=\"n\">equiv_shrink</span> <span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left_inv</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">beta</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">lam</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">A</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">cast</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">cast_helper</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">},</span>\n\n  <span class=\"c1\">-- insert Mario's proof here</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>From here the environment has the constants and axioms in Mario's proof and that should then go through</p>",
        "id": 233047498,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1617500759
    },
    {
        "content": "<p>And in contrast we have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">type_in_type_one</span> <span class=\"o\">:</span> <span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">small_self</span> <span class=\"kt\">Type</span>\n</code></pre></div>",
        "id": 233047557,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1617500807
    },
    {
        "content": "<p>I added this in <a href=\"https://github.com/leanprover-community/mathlib/issues/7026\">#7026</a>, using a structure for the axioms so that we don't have to add false axioms to mathlib</p>",
        "id": 233047695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617500973
    },
    {
        "content": "<p>This is great -- thanks to both of you. I've seen Girard's paradox mentioned a few times but the references I've seen usually just mention that it's some kind of standard diagonal argument without giving further details.</p>",
        "id": 233066659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617525411
    },
    {
        "content": "<p>Here's a simple (?) argument. Any  <code>α : Type</code> embeds in the type <code>K := Σ α : Type, α</code> of pointed types via <code>a =&gt; (_, a)</code>. This is injective by UIP. If <code>Type</code> itself is small, then so is <code>K</code>. So <code>set K</code> embeds in <code>K</code>, contradicting Cantor</p>",
        "id": 233070556,
        "sender_full_name": "David Wärn",
        "timestamp": 1617530676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span> Actually I've been thinking about how to prove this by cantor for a while, it's surprisingly tricky. In particular, I don't think Girard follows directly from Cantor, and Bhavik's statement about smallness of <code>Type</code> might be provable by cantor but I haven't found a way yet. I don't think this proof works, because the assumptions aren't enough to know that <code>K</code> exists with the required properties. (It might be, if you actually change the type theory so that <code>K : Type</code>, but with only Bhavik's bijection assumption I don't think this is enough.) In particular, \"If <code>Type</code> itself is small, then so is <code>K</code>\" is intuitively obvious but has no easy proof</p>",
        "id": 233135170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617596188
    },
    {
        "content": "<p>In set theory, this is relatively straightforward, since the equivalent of <code>Type</code> will be a universe which is a superset of any of its members, so one can conclude <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo>⊆</mo><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">K\\subseteq U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span> from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo>∈</mo><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">K\\in U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span> and hence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span> is larger than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>. But type theory universes are not transitive sets, and so there might be only a few types that are themselves quite large. In lean, we know the set of types has to be at least as large as the set of all cardinals, which we know is large using some of Cantor's other observations, but I think a proof along these lines boils down to the burali-forti paradox so probably isn't any simpler than <code>girard.paradox</code> above</p>",
        "id": 233135451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617596548
    },
    {
        "content": "<p>actually, nevermind, that proof actually does go through</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">not_small_type</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨⟨</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">⟩⟩⟩</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">e.symm</span> <span class=\"n\">α</span> <span class=\"k\">in</span>\n  <span class=\"bp\">@</span><span class=\"n\">function.cantor_injective</span> <span class=\"n\">K</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">K</span><span class=\"o\">),</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">e.3</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">a</span><span class=\"o\">⟩)</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">cast_inj</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">$</span> <span class=\"n\">eq_of_heq</span> <span class=\"o\">(</span><span class=\"n\">sigma.mk.inj</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 233136265,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617597553
    },
    {
        "content": "<p>Very nice!</p>\n<p>Golfed slightly from there, and with the last line made perhaps a bit clearer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">not_small_type</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨⟨</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">⟩⟩⟩</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">e.symm</span> <span class=\"n\">α</span> <span class=\"k\">in</span>\n  <span class=\"bp\">@</span><span class=\"n\">function.cantor_injective</span> <span class=\"n\">K</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">e.left_inv</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">a</span><span class=\"o\">⟩)</span>\n    <span class=\"o\">(</span><span class=\"n\">sigma_mk_injective.comp</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">cast_bijective</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 233137731,
        "sender_full_name": "Greg Price",
        "timestamp": 1617599382
    },
    {
        "content": "<p>Or for such a nice proof, perhaps it's worth letting it stretch out a bit and giving a few more labels to things, in the interest of making it easy to see what's happening. Here's a version in that direction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">not_small_type</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">assume</span> <span class=\"o\">⟨⟨(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">),</span> <span class=\"o\">⟨(</span><span class=\"n\">repr</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">S</span><span class=\"o\">)⟩⟩⟩,</span>\n<span class=\"k\">let</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">repr.symm</span> <span class=\"n\">α</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">sK</span> <span class=\"o\">:=</span> <span class=\"n\">repr</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"n\">function.cantor_injective</span>\n  <span class=\"o\">(</span><span class=\"n\">sigma.mk</span> <span class=\"n\">sK</span> <span class=\"bp\">∘</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">repr.left_inv</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">sigma_mk_injective.comp</span> <span class=\"o\">(</span><span class=\"n\">cast_bijective</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 233138645,
        "sender_full_name": "Greg Price",
        "timestamp": 1617600499
    },
    {
        "content": "<p>There's another version of this on the Girard PR btw</p>",
        "id": 233138684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617600589
    },
    {
        "content": "<p>Nice! Here's another version, using some lemmas not yet in <code>small.lean</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">logic.small</span>\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">small.sigma</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨⟨</span><span class=\"bp\">Σ</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">shrink</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">shrink</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">((</span><span class=\"n\">equiv_shrink</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">a'</span><span class=\"o\">)),</span>\n  <span class=\"o\">⟨</span><span class=\"n\">equiv.sigma_congr</span> <span class=\"o\">(</span><span class=\"n\">equiv_shrink</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">equiv_shrink</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">))⟩⟩⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">small.set</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨⟨</span><span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">shrink</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">⟨</span><span class=\"n\">equiv.set.congr</span> <span class=\"o\">(</span><span class=\"n\">equiv_shrink</span> <span class=\"n\">α</span><span class=\"o\">)⟩⟩⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">not_small_type</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">introI</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">function.cantor_injective</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">equiv_shrink</span> <span class=\"n\">_</span> <span class=\"n\">x</span><span class=\"o\">⟩),</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 233149615,
        "sender_full_name": "David Wärn",
        "timestamp": 1617611676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113488-general/topic/Type.20in.20type/near/233149615\">said</a>:</p>\n<blockquote>\n<p>Nice! Here's another version, using some lemmas not yet in <code>small.lean</code></p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">logic.small</span>\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">small.sigma</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨⟨</span><span class=\"bp\">Σ</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">shrink</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">shrink</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">((</span><span class=\"n\">equiv_shrink</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">a'</span><span class=\"o\">)),</span>\n  <span class=\"o\">⟨</span><span class=\"n\">equiv.sigma_congr</span> <span class=\"o\">(</span><span class=\"n\">equiv_shrink</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">equiv_shrink</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">))⟩⟩⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">small.set</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨⟨</span><span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">shrink</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">⟨</span><span class=\"n\">equiv.set.congr</span> <span class=\"o\">(</span><span class=\"n\">equiv_shrink</span> <span class=\"n\">α</span><span class=\"o\">)⟩⟩⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">not_small_type</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">introI</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">function.cantor_injective</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">equiv_shrink</span> <span class=\"n\">_</span> <span class=\"n\">x</span><span class=\"o\">⟩),</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"o\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>If these first two aren't in small.lean I think they're worth a PR</p>",
        "id": 233160042,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1617621089
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7042\">#7042</a></p>",
        "id": 233164389,
        "sender_full_name": "David Wärn",
        "timestamp": 1617624924
    }
]
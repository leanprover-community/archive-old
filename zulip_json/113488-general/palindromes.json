[
    {
        "content": "<p>For recreational reasons I was interested in working with lists which were palindromes, i.e. lists <code>G</code> satisfying <code>G = list.reverse G</code>. I wanted to prove a bunch of stuff about these things but I couldn't prove anything by induction because lists don't decompose like that. I wanted to write a general <code>G</code> of length 2 or more as <code>G=[head G] ++ middle G ++ [head G]</code> and have a recursor of the form <code>C [] -&gt; C [x] -&gt; forall palindromes H, C H -&gt; C ([a] ++ H ++ [a]) -&gt; forall palindromes G, C G</code></p>",
        "id": 124591860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522786982
    },
    {
        "content": "<p>What is the idiomatic way to do this in Lean? I am at the stage now where I could probably get several methods to go through</p>",
        "id": 124591884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522787015
    },
    {
        "content": "<p>but I would like to choose the one with the least pain.</p>",
        "id": 124591886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522787025
    },
    {
        "content": "<p>Should I actually make a new inductive type?</p>",
        "id": 124591890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522787035
    },
    {
        "content": "<p>You should look at <code>list.reverse_rec_on</code> for a similar eliminator. You could encode it as an inductive predicate, and then prove that it is equivalent to <code>g = list.reverse g</code>, or you could prove the eliminator you wrote with <code>palindromes</code> defined using reverse</p>",
        "id": 124593010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522788619
    },
    {
        "content": "<p>I stopped as soon as it got hard</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span>  <span class=\"n\">palindrome</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span>  <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">palindrome</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">singleton</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">palindrome</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">),</span> <span class=\"n\">palindrome</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">palindrome</span> <span class=\"o\">([</span><span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"bp\">++</span> <span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">])</span>\n\n<span class=\"kn\">lemma</span>  <span class=\"n\">palindrome_iff_eq_reverse</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">palindrome</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">reverse</span> <span class=\"n\">l</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">palindrome</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">conv</span> <span class=\"o\">{</span><span class=\"n\">to_lhs</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">h₂</span><span class=\"o\">},</span>\n<span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">reverse_singleton</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span><span class=\"o\">),</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">palindrome</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">begin</span> <span class=\"n\">apply</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">reverse_rec_on</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"kn\">end</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n</pre></div>",
        "id": 124593011,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1522788621
    },
    {
        "content": "<p>In the cons case you have <code>a::l = list.reverse (a::l) = l.reverse ++ [a]</code>. By cases on <code>l.reverse</code>, if <code>l.reverse = []</code> then <code>a::l = [a]</code> is a palindrome, and if <code>l.reverse = b::l'</code> then <code>a::l = b::l'++[a]</code> so <code>a = b</code> and <code>l = l' ++ [a]</code>, so <code>a :: l'.reverse = l.reverse = a::l'</code> and hence <code>l' = l'.reverse</code>, so <code>l'</code> is a palindrome by IH and hence <code>a::l</code> is a palindrome</p>",
        "id": 124593343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522789103
    },
    {
        "content": "<p>Is there a lemma saying <code>a :: l = b :: m -&gt; a = b</code>?</p>",
        "id": 124594253,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1522790330
    },
    {
        "content": "<p>no_confusion</p>",
        "id": 124594260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522790339
    },
    {
        "content": "<p>or cons_inj or whatever</p>",
        "id": 124594271,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522790352
    },
    {
        "content": "<p>cons_inj tells me about the lists being equal.</p>",
        "id": 124594377,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1522790446
    },
    {
        "content": "<p>or the <code>injection</code> tactic</p>",
        "id": 124594398,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1522790492
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> I'd never used injection successfully before.</p>",
        "id": 124594462,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1522790555
    },
    {
        "content": "<p><code>example {β : Type*} (a b : β) (l m : list β) : a :: l = b :: m -&gt; a = b :=  λ H, (list.cons.inj H).1</code></p>",
        "id": 124595081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522791342
    },
    {
        "content": "<p>I feel confident with this sort of stuff now I've seen how it all works.</p>",
        "id": 124595142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522791393
    },
    {
        "content": "<p><code>example {β : Type*} (a b : β) (l m : list β) : a :: l = b :: m -&gt; a = b := λ H, @list.no_confusion _ _ (a::l) (b::m) H (λ x y,x)</code></p>",
        "id": 124595241,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522791527
    },
    {
        "content": "<p>Chris, it was your questioning a week last Thurs which pushed me to learn this stuff. We didn't quite go as far as we should have done. We looked at no_confusion for bool and nat, but if you look at it for list you see how all the terms involved in the constructors are used.</p>",
        "id": 124595265,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522791594
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>variables {a b : β} {L M : list β} {P : Type}\n#reduce list.no_confusion_type P (a::L) (b::M) -- (a = b → L = M → P) → P\n</pre></div>",
        "id": 124595342,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522791691
    },
    {
        "content": "<p>You use no_confusion to make an instance of that type.</p>",
        "id": 124595391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522791738
    },
    {
        "content": "<blockquote>\n<p>In the cons case you have <code>a::l = list.reverse (a::l) = l.reverse ++ [a]</code>. By cases on <code>l.reverse</code>, if <code>l.reverse = []</code> then <code>a::l = [a]</code> is a palindrome, and if <code>l.reverse = b::l'</code> then <code>a::l = b::l'++[a]</code> so <code>a = b</code> and <code>l = l' ++ [a]</code>, so <code>a :: l'.reverse = l.reverse = a::l'</code> and hence <code>l' = l'.reverse</code>, so <code>l'</code> is a palindrome by IH and hence <code>a::l</code> is a palindrome</p>\n</blockquote>\n<p>For me, I can prove l' = l'.reverse but the inductive hypothesis doesn't let me conclude l' is a palindrome, the inductive hypothesis the way I've set it up says at this point that if (a::l') is its own reverse then (a::l') is a palindrome.</p>",
        "id": 124595732,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522792240
    },
    {
        "content": "<p>Somehow this is exactly the issue I keep running into: list has the wrong recursor for me.</p>",
        "id": 124595764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522792322
    },
    {
        "content": "<p>I can see that because I have <code>list.rec_on</code> and <code>list.reverse_rec_on</code> I should have all I need, but I don't know what <code>C</code> should be in some sense (what is <code>C</code> called? The motive?)</p>",
        "id": 124595820,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522792388
    },
    {
        "content": "<p>I've been struggling with this too. I think the best would be some sort of strong induction on the list.</p>",
        "id": 124596524,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1522793371
    },
    {
        "content": "<p>You should do strong induction on the length of the list</p>",
        "id": 124597147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522794226
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> you could use a custom recursor</p>",
        "id": 124597485,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522794786
    },
    {
        "content": "<p>see <a href=\"https://github.com/kckennylau/Lean/blob/master/recursion.lean\" target=\"_blank\" title=\"https://github.com/kckennylau/Lean/blob/master/recursion.lean\">https://github.com/kckennylau/Lean/blob/master/recursion.lean</a></p>",
        "id": 124597486,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522794796
    },
    {
        "content": "<p>for an example</p>",
        "id": 124597487,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522794798
    },
    {
        "content": "<p>The trick to prove the lemma Chris wants to prove is to consider the two cases (a) length l = 2<em>n and (b) length l = 2</em>n + 1 separately and then use induction on n in each case.</p>",
        "id": 124599343,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1522797998
    },
    {
        "content": "<p>omg someone from hong kong</p>",
        "id": 124599350,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522798018
    },
    {
        "content": "<p>Finally did it. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">palindrome</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span>       <span class=\"o\">:</span> <span class=\"n\">palindrome</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">singleton</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">palindrome</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span>      <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">),</span> <span class=\"n\">palindrome</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">palindrome</span> <span class=\"o\">([</span><span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"bp\">++</span> <span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">])</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">eq_reverse_of_palindrome</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">palindrome</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">reverse</span> <span class=\"n\">l</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">palindrome</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">conv</span> <span class=\"o\">{</span><span class=\"n\">to_lhs</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">h₂</span><span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">reverse_singleton</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">list</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">palindrome_of_eq_reverse</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">reverse</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">palindrome</span> <span class=\"n\">l</span>\n<span class=\"bp\">|</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">palindrome</span><span class=\"bp\">.</span><span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">reverse_cons&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">hl&#39;</span> <span class=\"o\">:</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">reverse</span> <span class=\"bp\">=</span> <span class=\"n\">l&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">l&#39;</span>  <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">l&#39;</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"k\">assume</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">palindrome</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"bp\">_</span>  <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">assume</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">injection</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">l&#39;</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">injection</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span>  <span class=\"n\">b</span> <span class=\"bp\">::</span> <span class=\"n\">l&#39;</span> <span class=\"bp\">=</span> <span class=\"n\">reverse</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"bp\">++</span> <span class=\"n\">reverse</span> <span class=\"n\">l&#39;</span> <span class=\"o\">:=</span>\n      <span class=\"k\">by</span> <span class=\"n\">rwa</span>  <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">reverse_inj</span><span class=\"o\">,</span> <span class=\"n\">hl&#39;</span><span class=\"o\">,</span> <span class=\"n\">reverse_append</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">l&#39;</span> <span class=\"bp\">=</span> <span class=\"n\">l&#39;</span><span class=\"bp\">.</span><span class=\"n\">reverse</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">injection</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">length</span> <span class=\"n\">l&#39;</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">length</span> <span class=\"n\">l</span> <span class=\"o\">:=</span>\n      <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">length_append</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n        <span class=\"n\">exact</span> <span class=\"n\">lt_trans</span> <span class=\"o\">(</span><span class=\"n\">lt_succ_self</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lt_succ_self</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">palindrome</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">palindrome_of_eq_reverse</span> <span class=\"n\">this</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span><span class=\"n\">rel_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">measure_wf</span> <span class=\"n\">length</span><span class=\"bp\">⟩</span><span class=\"o\">]}</span>\n</pre></div>",
        "id": 124638255,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1522870901
    },
    {
        "content": "<p>Yes, I did it too. Here's the reason I was asking: Q1(c) of <a href=\"http://www.olympiad.org.uk/papers/2015/bio/round_one.html\" target=\"_blank\" title=\"http://www.olympiad.org.uk/papers/2015/bio/round_one.html\">http://www.olympiad.org.uk/papers/2015/bio/round_one.html</a></p>",
        "id": 124638434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522871220
    },
    {
        "content": "<p>My son wrote code to do Q1(a) so I thought I'd write code to do Q1(c) because I thought that the idea of writing code to do 1c would be interesting to him.</p>",
        "id": 124638445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522871263
    },
    {
        "content": "<p>FWIW:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span>\n<span class=\"kn\">open</span> <span class=\"n\">list</span>\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">palindrome</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">palindrome</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">palindrome</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">palindrome</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"n\">palindrome</span> <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">])</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">palindrome</span>\n<span class=\"kn\">open</span> <span class=\"n\">palindrome</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_rev_self</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">L</span> <span class=\"bp\">=</span> <span class=\"n\">reverse</span> <span class=\"n\">L</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">rev_aux</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_rev_self</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]))</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">is_rev_self</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">unfold</span> <span class=\"n\">is_rev_self</span><span class=\"o\">,</span><span class=\"n\">intro</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">reverse_cons&#39;</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">reverse_append</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">H2</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">L</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">reverse</span> <span class=\"n\">L</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">],</span>\n  <span class=\"n\">simpa</span> <span class=\"kn\">using</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n<span class=\"n\">split</span><span class=\"o\">,</span><span class=\"n\">exact</span> <span class=\"n\">H2</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">H2</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">at</span> <span class=\"n\">H2</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">H3</span> <span class=\"o\">:=</span> <span class=\"n\">H2</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">H2</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">at</span> <span class=\"n\">H3</span><span class=\"o\">,</span>\n<span class=\"n\">exact</span> <span class=\"n\">append_inj_left&#39;</span> <span class=\"n\">H3</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n\n<span class=\"kn\">theorem</span> <span class=\"n\">palindrome_of_is_rev_self</span><span class=\"bp\">.</span><span class=\"n\">aux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">is_rev_self</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"n\">palindrome</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">is_rev_self</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">strong_induction_on</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">clear</span> <span class=\"n\">n</span><span class=\"o\">,</span><span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">IH</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">L</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">L</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"n\">exact</span> <span class=\"n\">nil</span> <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">reverse_rec_on</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">one</span> <span class=\"n\">a</span><span class=\"o\">},</span>\n  <span class=\"n\">intros</span> <span class=\"n\">L</span> <span class=\"n\">b</span> <span class=\"n\">X</span><span class=\"o\">,</span><span class=\"n\">clear</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">HLL</span> <span class=\"n\">HRL</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H2</span> <span class=\"o\">:=</span> <span class=\"n\">rev_aux</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">L</span> <span class=\"n\">HRL</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">cons_append</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">H2</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">cons</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H3</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">length</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"kn\">using</span> <span class=\"n\">HLL</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"n\">add_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H3</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H4</span> <span class=\"o\">:</span> <span class=\"n\">length</span> <span class=\"n\">L</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">H3</span><span class=\"o\">,</span><span class=\"n\">exact</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">lt_add_of_zero_lt_left</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"mi\">2</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">IH</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">H4</span> <span class=\"n\">L</span> <span class=\"n\">rfl</span> <span class=\"n\">H2</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">palindrome_of_rev_self</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_rev_self</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"n\">palindrome</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n  <span class=\"n\">palindrome_of_is_rev_self</span><span class=\"bp\">.</span><span class=\"n\">aux</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">is_rev_self_of_palindrome</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">palindrome</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"n\">is_rev_self</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">H</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">M</span> <span class=\"n\">HPM</span> <span class=\"n\">HRM</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">is_rev_self</span><span class=\"o\">,</span><span class=\"n\">refl</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">is_rev_self</span><span class=\"o\">,</span><span class=\"n\">refl</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">is_rev_self</span><span class=\"o\">,</span><span class=\"n\">unfold</span> <span class=\"n\">is_rev_self</span> <span class=\"n\">at</span> <span class=\"n\">HRM</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">reverse_append</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">reverse_singleton</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">cons_append</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">reverse_cons&#39;</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">HRM</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n<span class=\"kn\">end</span> <span class=\"n\">palindrome</span>\n</pre></div>",
        "id": 124639841,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522873146
    },
    {
        "content": "<p>My code didn't get highlighted. Possibly because the FWIW was in the same post.</p>",
        "id": 124639896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522873222
    },
    {
        "content": "<p>No wait Chris also didn't post a pure code post</p>",
        "id": 124639900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522873242
    },
    {
        "content": "<p>Aah got it, you have to write <code>lean</code> after the three backticks</p>",
        "id": 124639914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522873272
    },
    {
        "content": "<p>Oh Chris you didn't use strong induction for the main theorem! (<code>palindrome_of_eq_reverse</code>). I made an aux lemma saying \"forall n, if list length is n then blah\" and applied strong induction to n, and then deduced the statement we wanted as a trivial corollary.</p>",
        "id": 124640132,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522873591
    },
    {
        "content": "<p>I did use strong induction, note <code> using_well_founded {rel_tac := λ _ _, ``[exact ⟨_, measure_wf length⟩]} </code></p>\n<p>I also did question 1a, although in 2^(2^n) time, so I might lose some points for that.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">palindrome</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">decidable_of_iff</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"o\">)</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">palindrome_of_eq_reverse</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">eq_reverse_of_palindrome</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span>  <span class=\"n\">block_palindromes</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">sublists</span> <span class=\"o\">(</span><span class=\"n\">sublists</span> <span class=\"n\">l</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">filter</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">palindrome</span> <span class=\"n\">m</span> <span class=\"bp\">∧</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">foldl</span> <span class=\"o\">(</span><span class=\"bp\">++</span><span class=\"o\">)</span> <span class=\"n\">nil</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 124640484,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1522874091
    },
    {
        "content": "<p>haha that solution</p>",
        "id": 124641990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522876418
    },
    {
        "content": "<p>You should write the deterministic bogosort, which enumerates permutations until it finds the sorted one</p>",
        "id": 124642031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522876448
    },
    {
        "content": "<p>The mark scheme is just a bunch of tests, and you have to pass each one in under a second to get the marks.</p>",
        "id": 124642035,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522876478
    },
    {
        "content": "<p>So I finished the proof that the word has to have an even number of letters.</p>",
        "id": 124644819,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522880964
    },
    {
        "content": "<p>My proof was 240 lines, longer than my son's program to do 1(a).</p>",
        "id": 124644823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522880997
    },
    {
        "content": "<p>But I had to develop some concepts from scratch; in a parallel universe they would have already been in some library.</p>",
        "id": 124644873,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522881022
    },
    {
        "content": "<p>It was quite an interesting task. The question is about the following definition:</p>",
        "id": 124644889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522881080
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">definition</span>  <span class=\"n\">listunfold</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">listunfold</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 124644891,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522881098
    },
    {
        "content": "<p>but then I had to write <code>listunfold_append : listunfold (G1 ++ G2) = listunfold G1 ++ listunfold G2</code> and <code>listunfold_singleton</code>and so on</p>",
        "id": 124644939,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522881152
    },
    {
        "content": "<p>And similarly for <code>palindrome</code> (the inductive prop) I had to prove palindrome iff L = reverse L</p>",
        "id": 124644960,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522881201
    },
    {
        "content": "<p>Listunfold could also be defined as a fold. Then those two lemmas are probably there already because of associativity</p>",
        "id": 124644967,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1522881232
    },
    {
        "content": "<p>Is that right?</p>",
        "id": 124645013,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522881288
    },
    {
        "content": "<p>I feel like if I defined it as a fold then I would then have to prove the two things I've used for my definition immediately afterwards</p>",
        "id": 124645022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522881316
    },
    {
        "content": "<p>Not in that exact form, but they'd be quite easy.</p>",
        "id": 124645024,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1522881325
    },
    {
        "content": "<p>and then the same proof for my append and singleton :-)</p>",
        "id": 124645025,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522881326
    },
    {
        "content": "<p>Oh everything was easy, but of course because this was recreational I did it all in tactic mode so my proofs go on for ages :-)</p>",
        "id": 124645031,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522881346
    },
    {
        "content": "<p>Those two things are lemmas about fold probably</p>",
        "id": 124645032,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1522881348
    },
    {
        "content": "<p>You might well be right. I feel like I know enough Lean to write the definitions and basic properties of these new concepts like listunfold or palindrome</p>",
        "id": 124645079,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522881390
    },
    {
        "content": "<p>but</p>",
        "id": 124645080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522881391
    },
    {
        "content": "<p>I feel like if I really knew everything that was already there, properly, then I would write things far more efficiently.</p>",
        "id": 124645084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522881411
    },
    {
        "content": "<p>It's not about knowing what's there, it's knowing what's probably there.</p>",
        "id": 124645097,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1522881452
    },
    {
        "content": "<p>Your <code>listunfold</code> is defined in core and proven in mathlib, by the name <code>list.join</code>. It is the monad \"flattening\" operation for lists</p>",
        "id": 124650234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522891318
    }
]
[
    {
        "content": "<p>I'm wondering whether it's intended that the new <code>classical</code> tactic adds the <code>instance</code> attribute to <code>classical.prop_decidable</code> globally. The tactic is adding it non-persistently, but that only means that it's scoped to the <code>section</code>/<code>namespace</code> (it's the difference between the <code>local attribute</code> and <code>attribute</code> commands.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.interactive</span>\n\n<span class=\"c1\">-- Fails</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Succeeds</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Succeeds?</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo3</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n</code></pre></div>\n<p>(ping <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>)</p>",
        "id": 282726128,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652834793
    },
    {
        "content": "<p>Oh darn, I wasn't sure what persistent meant (I don't think there's a docstring), and thought I'd tested it as ok</p>",
        "id": 282726224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652834909
    },
    {
        "content": "<p>I would guess we want to use <del>docs#bracket</del> <em>whatever the spelling of try/finally is</em> to add and remove the attribute</p>",
        "id": 282726246,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652834949
    },
    {
        "content": "<p>Yeah, I was just trying to write <code>by_classical { ... }</code> that'd do that</p>",
        "id": 282726477,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652835175
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.finally\">docs#tactic.finally</a> is what I meant</p>",
        "id": 282726502,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652835214
    },
    {
        "content": "<p>I wonder if there's ever a situation where with nested tactic blocks, the inner tactic block executes <em>after</em> the outer one.</p>",
        "id": 282726560,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652835265
    },
    {
        "content": "<p>In that case the inner one won't get the instances</p>",
        "id": 282726566,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652835279
    },
    {
        "content": "<p>I don't follow; can't you just restore the previous attribute?</p>",
        "id": 282726588,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652835309
    },
    {
        "content": "<p>Or do nothing if the attribute is already there</p>",
        "id": 282726601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652835329
    },
    {
        "content": "<p>Regarding the notation, I was thinking about something slightly different; a <code>classical! expr</code> notation  to allow <code>classical! if p then y else n</code></p>",
        "id": 282726663,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652835387
    },
    {
        "content": "<p>Although actually for that, maybe</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">classically</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">classically</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">classical.dec</span>\n</code></pre></div>\n<p>is a better spelling</p>",
        "id": 282726923,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652835638
    },
    {
        "content": "<p>Here's a seemingly working <code>with_classical { ... }</code> block:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.interactive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n\n<span class=\"sd\">/-- Temporarily give the `instance` attribute to a declaration with</span>\n<span class=\"sd\">a given priority then restore the original attribute settings. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">with_instance</span> <span class=\"o\">(</span><span class=\"n\">c_name</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prio</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">tac</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">old</span> <span class=\"bp\">←</span> <span class=\"n\">try_core</span> <span class=\"o\">(</span><span class=\"n\">tactic.has_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span><span class=\"o\">),</span>\n   <span class=\"n\">tactic.set_basic_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span> <span class=\"n\">ff</span> <span class=\"n\">prio</span><span class=\"o\">,</span>\n   <span class=\"n\">tactic.finally</span> <span class=\"n\">tac</span> <span class=\"bp\">$</span>\n     <span class=\"k\">match</span> <span class=\"n\">old</span> <span class=\"k\">with</span>\n     <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.unset_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span>\n     <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">persistent</span><span class=\"o\">,</span> <span class=\"n\">prio</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.set_basic_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span> <span class=\"n\">persistent</span> <span class=\"n\">prio</span>\n     <span class=\"kd\">end</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">interactive</span>\n<span class=\"n\">setup_tactic_parser</span>\n\n<span class=\"sd\">/-- Have the effect of `open_locale classical` for the duration of</span>\n<span class=\"sd\">the given tactic block. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">with_classical</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">parser.itactic</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">with_instance</span> <span class=\"bp\">`</span><span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"mi\">9</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n<span class=\"n\">with_instance</span> <span class=\"bp\">`</span><span class=\"n\">decidable_eq_of_decidable_le</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"mi\">8</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n<span class=\"n\">t</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">interactive</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"c1\">-- Succeeds</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">with_classical</span> <span class=\"o\">{</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span> <span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Fails (good!)</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 282727284,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652836018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/.60classical.60.20attribute.20leakage/near/282726923\">said</a>:</p>\n<blockquote>\n<p>Although actually for that, maybe</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">classically</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">classically</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">classical.dec</span>\n</code></pre></div>\n<p>is a better spelling</p>\n</blockquote>\n<p>That's an interesting idea for classical <code>if</code>, though it might get in the way rewrites... Making it <code>@[reducible]</code> might help somewhat.</p>",
        "id": 282727492,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652836218
    },
    {
        "content": "<p>Could you use <code>bracket</code>? e.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.with_local_reducibility/src\">src#tactic.with_local_reducibility</a></p>",
        "id": 282727550,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652836278
    },
    {
        "content": "<p>It looks like <code>bracket a b c = a &gt;&gt; finally b c</code> so yes -- is there a reason to?</p>",
        "id": 282728076,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652836894
    },
    {
        "content": "<p>I guess I would have said it is the more idiomatic way to express this kind of intent, but otherwise I suppose not</p>",
        "id": 282728788,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652837803
    },
    {
        "content": "<p>Is it possible to create a tactic block in a <code>pexpr</code>? I wanted to see if it was possible to implement Eric's <code>classical!</code> user notation.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.interactive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n\n<span class=\"sd\">/-- Temporarily give the `instance` attribute to a declaration with</span>\n<span class=\"sd\">a given priority then restore the original attribute settings. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">with_instance</span> <span class=\"o\">(</span><span class=\"n\">c_name</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prio</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">tac</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">old</span> <span class=\"bp\">←</span> <span class=\"n\">try_core</span> <span class=\"o\">(</span><span class=\"n\">tactic.has_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span><span class=\"o\">),</span>\n   <span class=\"n\">bracket</span> <span class=\"o\">(</span><span class=\"n\">tactic.set_basic_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span> <span class=\"n\">ff</span> <span class=\"n\">prio</span><span class=\"o\">)</span> <span class=\"n\">tac</span> <span class=\"bp\">$</span>\n     <span class=\"k\">match</span> <span class=\"n\">old</span> <span class=\"k\">with</span>\n     <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.unset_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span>\n     <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">persistent</span><span class=\"o\">,</span> <span class=\"n\">prio</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.set_basic_attribute</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"n\">c_name</span> <span class=\"n\">persistent</span> <span class=\"n\">prio</span>\n     <span class=\"kd\">end</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">interactive</span>\n<span class=\"n\">setup_tactic_parser</span>\n\n<span class=\"sd\">/-- Have the effect of `open_locale classical` for the duration of</span>\n<span class=\"sd\">the given tactic block. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">with_classical</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">parser.itactic</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">with_instance</span> <span class=\"bp\">`</span><span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"mi\">9</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n<span class=\"n\">with_instance</span> <span class=\"bp\">`</span><span class=\"n\">decidable_eq_of_decidable_le</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"mi\">8</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n<span class=\"n\">t</span>\n\n<span class=\"kd\">reserve</span> <span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">classical</span><span class=\"bp\">!`</span><span class=\"o\">:</span><span class=\"mi\">0</span>\n\n<span class=\"kd\">@[user_notation]</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">by_classical_notation</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"bp\">$</span> <span class=\"n\">tk</span> <span class=\"s2\">\"classical!\"</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">parser.pexpr</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">parser</span> <span class=\"n\">pexpr</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">trace</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"n\">return</span> <span class=\"n\">t</span>\n  <span class=\"c1\">-- is it possible to do something that does what it seems like this should mean?</span>\n  <span class=\"c1\">--return ``(by with_classical { exact %%t })</span>\n  <span class=\"c1\">-- it appears that tactics inside quotations execute immediately</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">interactive</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n</code></pre></div>\n</div></div>",
        "id": 282729342,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652838417
    },
    {
        "content": "<p>Where is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bracket\">docs#bracket</a> defined?</p>",
        "id": 282746777,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652857168
    },
    {
        "content": "<p>I looked for it and couldn't find it</p>",
        "id": 282746799,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652857187
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/interaction_monad.bracket\">docs#interaction_monad.bracket</a> (btw, <code>with_instance</code> in the code block just above is using it)</p>",
        "id": 282749111,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652858897
    },
    {
        "content": "<p>(I was going to use it in the original PR but couldn't see the effect; I just thought I imagined it when the doc link didn't work!)</p>",
        "id": 282749837,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652859455
    },
    {
        "content": "<p>Hmm, <code>bracket</code> doesn't work here as it would nee dto modify the syntax of <code>classical</code></p>",
        "id": 283239984,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653236600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, do you have any opinions about what we should do here?</p>",
        "id": 284194373,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653692845
    },
    {
        "content": "<p>Maybe there's some \"at end of tactic\" hook we can use like the \"step\" hook?</p>",
        "id": 284194393,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653692872
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Interesting idea. I've been reading through the tactic parser source code to see what features we might be able to use.</p>\n<p>The extent of a tactic appears to be handled by the <code>execute_with</code> field of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/interactive.executor\">docs#interactive.executor</a>, where the default implementation for plain old tactic blocks is doing nothing. So, if we could inject cleanup routines here then that would probably work, but we probably shouldn't touch the main interactive tactic... (But if we were ok with doing that, we could add state to the <code>config_type</code> field recording whether we need to do clean up for <code>classical</code>.)</p>\n<p>One option is that we could make a custom <code>classical</code> tactic class, so then you would write <code>begin [classical] ... end</code>, and then <code>execute_with</code> would be responsible for bracketing the attribute manipulation. However, as far as I can tell custom tactic classes have their own namespace for interactive tactics and there's no way to include interactive tactics from another tactic class, short of copying them all over. That's what the natural number game does (but we don't want to do that since the tactic set changes depending on what you've got imported).</p>\n<p>Maybe there could be a systematic way to let one tactic class use interactive tactics from another tactic class. This seems to be the place where name lookup happens: <a href=\"https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/tactic_notation.cpp#L136\">https://github.com/leanprover-community/lean/blob/master/src/frontends/lean/tactic_notation.cpp#L136</a></p>\n<p>I thought that perhaps it could be made to respect aliases similar to how name lookup works in the elaborator (\"aliases\" are not to be confused with the <code>alias</code> command -- these are the aliases used to implement <code>open</code> and <code>export</code>). You can <code>export</code> names from one namespace to another, but you probably would need to refresh the aliases to the <code>classical.interactive</code> namespace when you import more tactics...</p>",
        "id": 284204481,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653705478
    },
    {
        "content": "<blockquote>\n<p>So, if we could inject cleanup routines here then that would probably work, but we probably shouldn't touch the main interactive tactic...</p>\n</blockquote>\n<p>It's a hack, but we can even do it from within mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">my_executor</span> <span class=\"o\">:</span> <span class=\"n\">interactive.executor</span> <span class=\"n\">tactic</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">config_type</span> <span class=\"o\">:=</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n  <span class=\"n\">execute_with</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">block</span><span class=\"o\">,</span> <span class=\"k\">do</span>\n    <span class=\"n\">tactic.trace</span> <span class=\"s2\">\"record state of classical\"</span><span class=\"o\">,</span>\n    <span class=\"n\">block</span><span class=\"o\">,</span>\n    <span class=\"n\">tactic.trace</span> <span class=\"s2\">\"restore initial state\"</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">vm_override</span> <span class=\"n\">my_executor</span><span class=\"o\">]</span> <span class=\"n\">interactive.executor_tactic</span>\n</code></pre></div>",
        "id": 284215960,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1653723153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Gabriel's hack seems to work perfectly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n\n<span class=\"sd\">/-- Execute a tactic that might modify the given attribute for hte given declaration and then</span>\n<span class=\"sd\">restore the original attribute state. -/</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">with_local_attribute</span> <span class=\"o\">(</span><span class=\"n\">c_name</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">attr</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">tac</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">do</span> <span class=\"n\">old</span> <span class=\"bp\">←</span> <span class=\"n\">try_core</span> <span class=\"o\">(</span><span class=\"n\">tactic.has_attribute</span> <span class=\"n\">attr</span> <span class=\"n\">c_name</span><span class=\"o\">),</span>\n   <span class=\"n\">finally</span> <span class=\"n\">tac</span> <span class=\"bp\">$</span> <span class=\"k\">do</span>\n     <span class=\"c\">/-</span><span class=\"cm\"> I haven't checked, but I think it might be more efficient to only</span>\n<span class=\"cm\">        change it back if it's different... -/</span>\n     <span class=\"n\">new</span> <span class=\"bp\">←</span> <span class=\"n\">try_core</span> <span class=\"o\">(</span><span class=\"n\">tactic.has_attribute</span> <span class=\"n\">attr</span> <span class=\"n\">c_name</span><span class=\"o\">),</span>\n     <span class=\"n\">when</span> <span class=\"o\">(</span><span class=\"n\">new</span> <span class=\"bp\">≠</span> <span class=\"n\">old</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"k\">do</span>\n       <span class=\"k\">match</span> <span class=\"n\">old</span> <span class=\"k\">with</span>\n       <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.unset_attribute</span> <span class=\"n\">attr</span> <span class=\"n\">c_name</span>\n       <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">persistent</span><span class=\"o\">,</span> <span class=\"n\">prio</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tactic.set_basic_attribute</span> <span class=\"n\">attr</span> <span class=\"n\">c_name</span> <span class=\"n\">persistent</span> <span class=\"n\">prio</span>\n       <span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mathlib_tactic_executor</span> <span class=\"o\">:</span> <span class=\"n\">interactive.executor</span> <span class=\"n\">tactic</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">config_type</span> <span class=\"o\">:=</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n  <span class=\"n\">execute_with</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">block</span><span class=\"o\">,</span>\n    <span class=\"n\">tactic.with_local_attribute</span> <span class=\"bp\">`</span><span class=\"n\">classical.prop_decidable</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"bp\">$</span>\n    <span class=\"n\">tactic.with_local_attribute</span> <span class=\"bp\">`</span><span class=\"n\">classical.decidable_eq_of_decidable</span> <span class=\"bp\">`</span><span class=\"kd\">instance</span> <span class=\"bp\">$</span>\n    <span class=\"n\">block</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">vm_override</span> <span class=\"n\">mathlib_tactic_executor</span><span class=\"o\">]</span> <span class=\"n\">interactive.executor_tactic</span>\n\n<span class=\"c1\">-- Fails</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Succeeds</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Fails! (good!)</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo3</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 284243466,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653764481
    },
    {
        "content": "<p>Incidentally, I remember someone had the idea a couple months ago of experimenting with a version of tactic blocks that would automatically do <code>assumption</code> or <code>refl</code> at the end -- this is a way you could try taking that idea for a spin.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">mathlib_tactic_executor'</span> <span class=\"o\">:</span> <span class=\"n\">interactive.executor</span> <span class=\"n\">tactic</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">config_type</span> <span class=\"o\">:=</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n  <span class=\"n\">execute_with</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">block</span><span class=\"o\">,</span>\n    <span class=\"k\">do</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">block</span><span class=\"o\">,</span> <span class=\"n\">tactic.assumption</span><span class=\"o\">,</span> <span class=\"n\">return</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">vm_override</span> <span class=\"n\">mathlib_tactic_executor'</span><span class=\"o\">]</span> <span class=\"n\">interactive.executor_tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"kd\">end</span> <span class=\"c1\">-- tada!</span>\n</code></pre></div>",
        "id": 284243625,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653764677
    },
    {
        "content": "<p>Presumably something like <code>try {classical, tactic.fail}, apply_instance</code> still picks up the classical instance?</p>",
        "id": 284243727,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653764804
    },
    {
        "content": "<p>Nope, the inner tactic block seems to get its own <code>execute_with</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo3</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">classical</span> <span class=\"o\">},</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"kd\">end</span> <span class=\"c1\">-- fails at `apply_instance`</span>\n</code></pre></div>",
        "id": 284243813,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653764896
    },
    {
        "content": "<p>Even if it didn't get its own <code>execute_with</code>, <code>try</code> would discard the tactic state with the classical instances.  A better challenge would be <code>have : 1 = 1, { classical, refl }, apply_instance</code>.</p>",
        "id": 284243827,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1653764950
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  You can see the nested <code>execute_explicit</code> if you do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">tactic.trace</span> <span class=\"o\">(</span><span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">classical</span> <span class=\"o\">},</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}))</span>\n</code></pre></div>",
        "id": 284243911,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653765027
    },
    {
        "content": "<p>This is a complicated way of saying:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">raw</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">classical</span> <span class=\"o\">},</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 284243928,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1653765062
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> Success:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">foo3</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">classical</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span> <span class=\"n\">apply_instance</span> <span class=\"kd\">end</span> <span class=\"c1\">-- fails at `apply_instance`</span>\n</code></pre></div>",
        "id": 284243931,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1653765066
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, did you ever get around to PRing this?</p>",
        "id": 323012486,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674478541
    },
    {
        "content": "<p>I noticed that the leakage is worse than I thought; it leaks out of proof fields within <code>def</code>s too, not just out of definitions that use <code>by classical; exact</code></p>",
        "id": 323012647,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674478576
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I didn't. I wasn't comfortable being responsible for doing a <code>vm_override</code> for the tactic executor!</p>\n<p>Maybe it's worth setting it up locally and periodically seeing how bad the leakage is and fix up any errors, but then create a PR with only these fixes?</p>",
        "id": 323029856,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674483190
    },
    {
        "content": "<p>The fix is usually pretty ugly though, it involves either;</p>\n<ul>\n<li>Adding <code>async</code> around the proof term to contain the leakage</li>\n<li>Replacing <code>classical</code> with <code>letI := ...</code></li>\n</ul>",
        "id": 323030060,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674483241
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span></p>",
        "id": 323204084,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674553226
    },
    {
        "content": "<p>I think we want this hack in place because it brings the behavior closed to that of mathlib4</p>",
        "id": 323205890,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674553829
    },
    {
        "content": "<p>Which will ease porting</p>",
        "id": 323205901,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674553834
    },
    {
        "content": "<p>Do we really need to have it in place on master, or is it enough to enable it locally on a branch, fix the build, and then remove it?</p>",
        "id": 323209187,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1674554817
    },
    {
        "content": "<p>What's the downside of having it on master?</p>",
        "id": 323213454,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674556071
    },
    {
        "content": "<p>It's ugly?</p>",
        "id": 323215350,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1674556583
    },
    {
        "content": "<p>Having <code>classical</code> leaking is arguably more ugly, and unless the workaround is on master we have nothing to detect future leakage in CI</p>",
        "id": 323217128,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674557155
    },
    {
        "content": "<p>It also causes a pervasive slowdown of all tactic blocks in mathlib, though I haven't measured exactly how much it costs.</p>",
        "id": 323217229,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674557182
    },
    {
        "content": "<p>What causes this slowdown? The fix or the non-fix?</p>",
        "id": 323217352,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1674557230
    },
    {
        "content": "<p>The fix</p>",
        "id": 323217367,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674557235
    },
    {
        "content": "<p>Because it runs a tiny bit of code at the start and end of every tactic blocks</p>",
        "id": 323217404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674557249
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/18275\">https://github.com/leanprover-community/mathlib/pull/18275</a></p>",
        "id": 323219425,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674557822
    },
    {
        "content": "<p>A lot of these fixes seem very close to the tide (if not already underwater); should I PR those without the meta change or downstream fixes, so that they're available to mathlib3port asap?</p>",
        "id": 323236699,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674562919
    },
    {
        "content": "<p>People might already be aware, but since it wasn't mentioned: in mathlib4 <code>classical</code> is actually a scoping tactic, and mathport has to do heroics to rewrite it because it's not written as a scoping tactic in lean 3. This would be a lot simpler if the syntax was just <code>classical { tacs }</code></p>",
        "id": 323267616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674570909
    },
    {
        "content": "<p>and that would also avoid the need to hack the interactive mode to do the cleanup action after the block</p>",
        "id": 323267810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674570959
    },
    {
        "content": "<p>Do scoping tactics have new syntax in Lean 4?</p>",
        "id": 323267970,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674570992
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">try</span> <span class=\"n\">tac</span>\n<span class=\"n\">try</span>\n  <span class=\"n\">tac</span>\n<span class=\"n\">try</span> <span class=\"n\">tac1</span><span class=\"bp\">;</span> <span class=\"n\">tac2</span>\n<span class=\"n\">try</span>\n  <span class=\"n\">tac1</span>\n  <span class=\"n\">tac2</span>\n</code></pre></div>",
        "id": 323268109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571030
    },
    {
        "content": "<p>these are the equivalent of <code>try { tac }</code> and <code>try { tac1, tac2 }</code> respectively</p>",
        "id": 323268235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571058
    },
    {
        "content": "<p>I'm confused then, because I've seen mathlib4 proofs that seem to use <code>classical</code> like a regular tactic.</p>",
        "id": 323268238,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571058
    },
    {
        "content": "<p>And <code>{ }</code> still exists but it always(?) means <code>focus1</code>, so watch out for that!</p>",
        "id": 323268341,
        "sender_full_name": "Reid Barton",
        "timestamp": 1674571078
    },
    {
        "content": "<p>in particular</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">try</span>\n<span class=\"n\">tac</span>\n</code></pre></div>\n<p>is also <code>try { tac }</code></p>",
        "id": 323268360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571082
    },
    {
        "content": "<p>so if you don't indent it <code>classical</code> can kind of look like a non-scoping tactic</p>",
        "id": 323268494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571104
    },
    {
        "content": "<p>Is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">try</span>\n<span class=\"n\">tac</span>\n<span class=\"n\">tac2</span>\n</code></pre></div>\n<p><code>try { tac, tac2 }</code> or <code> try {tac}, tac2</code></p>",
        "id": 323268551,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571117
    },
    {
        "content": "<p>the first</p>",
        "id": 323268588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571124
    },
    {
        "content": "<p>if you don't indent the block then you can't put anything after the block</p>",
        "id": 323268691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571147
    },
    {
        "content": "<p>I think I rejected the \"use <code>classical { }</code> everywhere\" approach because changing ~850 uses is really painful</p>",
        "id": 323268767,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571163
    },
    {
        "content": "<p>which happens to be the desired behavior for <code>classical</code> usually</p>",
        "id": 323268794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571168
    },
    {
        "content": "<p>is living with the status quo an option? Or using <code>classical!</code> which is not a scoping tactic</p>",
        "id": 323269003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571206
    },
    {
        "content": "<blockquote>\n<p>is living with the status quo an option?</p>\n</blockquote>\n<p>We should apply the fixes (<a href=\"https://github.com/leanprover-community/mathlib/pull/18277\">#18277</a>) whether or not we decide to keep the hack</p>",
        "id": 323269114,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571236
    },
    {
        "content": "<p><code>classical!</code> had its own problems</p>",
        "id": 323269138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571242
    },
    {
        "content": "<p>the problems with <code>classical!</code> are all local though</p>",
        "id": 323269253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571274
    },
    {
        "content": "<p>Yes, but <code>classical!</code> can make things very annoying to prove, and make people say \"why can't everything just be classical\"</p>",
        "id": 323269544,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571336
    },
    {
        "content": "<p>??</p>",
        "id": 323269579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571346
    },
    {
        "content": "<p>as a porting mechanism, we can just speculatively add <code>!</code> to all the classical proofs and revert the ones that break</p>",
        "id": 323269689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571380
    },
    {
        "content": "<p>That's not the problem though</p>",
        "id": 323269731,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571391
    },
    {
        "content": "<p>and use a scoping tactic for those that remain</p>",
        "id": 323269758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571399
    },
    {
        "content": "<p>The problem is that there are proofs in mathlib3 that need <code>classical</code>, but don't actually have it</p>",
        "id": 323269771,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571402
    },
    {
        "content": "<p>And they get by because the use of <code>classical</code> leaked from the previous lemma</p>",
        "id": 323269809,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571413
    },
    {
        "content": "<p>Mathlib4 plugs that leak, and now the subsequent <code>classical</code>-less proofs are broken</p>",
        "id": 323269930,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571443
    },
    {
        "content": "<p>it seems like this is the fault of the mathlib3 <code>classical</code> tactic, and we should avoid it</p>",
        "id": 323270049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571472
    },
    {
        "content": "<p><code>classical!</code> works as a substitute in the majority of cases, and <code>with_classical</code> will solve the rest</p>",
        "id": 323270170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571501
    },
    {
        "content": "<p>Does <code>with_classical</code> exist?</p>",
        "id": 323270274,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571526
    },
    {
        "content": "<p>that is to say <code>classical</code> but as a scoping tactic</p>",
        "id": 323270323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571539
    },
    {
        "content": "<p>containing the cleanup actions discussed up-thread</p>",
        "id": 323270379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571553
    },
    {
        "content": "<p>so you don't need to do the cleanup actions as part of every interactive block</p>",
        "id": 323270511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571573
    },
    {
        "content": "<p>Yes, I think the following strategy works:</p>\n<ul>\n<li>Finish up adding the missing classicals in my PR</li>\n<li>Replace all uses of <code>classical</code> with <code>classical!</code></li>\n<li>Replace the ones that don't work with <code>with_classical</code></li>\n<li>Make it a lint error to use <code>classical</code> or <code>classical!</code> in any new mathlib3 code; the former is bad for porting, the latter is bad for mathematicians</li>\n</ul>",
        "id": 323270759,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571633
    },
    {
        "content": "<p>I think after steps 1-3 we can just rename <code>with_classical</code> to <code>classical</code> and make <code>classical,</code> a parse error</p>",
        "id": 323270924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571681
    },
    {
        "content": "<p>I don't have a feel for how much work step 3 is</p>",
        "id": 323271112,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571724
    },
    {
        "content": "<p>I think we won't know until we see the fallout from steps 1-2</p>",
        "id": 323271302,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674571778
    },
    {
        "content": "<p>Absolutely, and thankfully step 2 is easy</p>",
        "id": 323271334,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674571789
    }
]
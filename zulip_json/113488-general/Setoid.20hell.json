[
    {
        "content": "<p>I don't think it's what the term usually refers to, but in my opinion there's still a setoid-based hell centered around implicit vs typeclass arguments:</p>\n<ul>\n<li><code>a ≈ b</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/setoid_has_equiv\">docs#setoid_has_equiv</a>) vs <code>some_setoid.rel a b</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/setoid.rel\">docs#setoid.rel</a>) vs <code>setoid.r a b</code>  (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/setoid.r\">docs#setoid.r</a>)</li>\n<li><code>quot.mk</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/quot.mk\">docs#quot.mk</a>) vs <code>quotient.mk</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient.mk\">docs#quotient.mk</a>) vs <code>quotient.mk'</code>(<a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient.mk'\">docs#quotient.mk'</a>) vs <code>submodule.quotient.mk</code> (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.quotient.mk\">docs#submodule.quotient.mk</a>) vs ...</li>\n</ul>\n<p>The end result is that you can almost never apply the lemma you want to with <code>rw</code>, because the spelling in the lemma never seems to match the spelling that ends up in the goal view. Is there any way we can make this less bad? Perhaps by splitting <code>setoid</code> into <code>structure setoid</code> and <code>class has_canonical_setoid</code>, so that we can't accidentally write lemmas that mix the conventions?</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>, since you brought this to my attention in <a href=\"https://github.com/leanprover-community/mathlib/issues/7910\">#7910</a></p>",
        "id": 243323132,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624225432
    },
    {
        "content": "<p>(Shoutout to the lost soul of that hell which is the tautological lemma <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.quotient.mk_eq_mk\">docs#submodule.quotient.mk_eq_mk</a>)</p>",
        "id": 243323274,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624225592
    },
    {
        "content": "<p>The only advantage I see for preferring <code>setoid</code> quotients over <code>quot</code>s by an arbitrary relation is easier automation on <code>quotient</code>: since <code>quotient</code> assumes the relation is an equivalence relation, it might be a bit easier to create <code>simp</code> lemmas. I feel that <code>quotient</code> is essentially just adding on proofs where we only need the data (namely the relation).</p>",
        "id": 243354776,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1624265673
    },
    {
        "content": "<p>Moreover, we have classes like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_refl\">docs#is_refl</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_equiv\">docs#is_equiv</a> so for <code>simp</code> there's no need to bundle that information into the constructor of the quotient type.</p>",
        "id": 243354940,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1624265788
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.mkq\">docs#submodule.mkq</a> makes sense to have as a definition, since it specifies the quotient map is indeed linear, so why do we also have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.quotient.mk\">docs#submodule.quotient.mk</a>? (To help inferring implicit arguments like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.quotient_rel\">docs#submodule.quotient_rel</a>?)</p>",
        "id": 243355156,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1624265952
    },
    {
        "content": "<p>So basically, I'm wondering whether it's not a good idea to choose <code>quot.mk</code> as the <code>simp</code> normal form for all quotient-like operators and try to replace <code>quotient</code> with <code>quot</code> everywhere.</p>",
        "id": 243355783,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1624266367
    },
    {
        "content": "<p>Related: Kenny Lau has often suggested that the mathlib approach of localising a ring at a submonoid should just be replaced by localising a ring at [the submonoid generated by] an arbitrary subset.</p>",
        "id": 243357482,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624267373
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> for removing the setoid typeclass and the quotient wrapper.</p>",
        "id": 243357539,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1624267417
    },
    {
        "content": "<p>(Ah, I think I figured out a good reason for having <code>submodule.quotient.mk</code>: if we just wrote <code>quot.mk</code> then <code>submodule.quotient</code> has to be reducible for automation to work well.)</p>",
        "id": 243357940,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1624267673
    },
    {
        "content": "<p>The intent has been to have each quotient define its own <code>mk</code> wrapper function, which has the correct type, and use that as the simp normal form. The downside is that you have to duplicate the quotient API, and if you get lazy and use quot lemmas instead then you enter this coercion hell</p>",
        "id": 243368692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624274894
    },
    {
        "content": "<p>I think the original sin here was that <code>setoid</code> should never have been a class, and <code>setoid.r</code> shouldn't exist</p>",
        "id": 243368759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624274948
    },
    {
        "content": "<p>If the basic quotient lemmas just used <code>r</code> directly, it would be the user's relation and no rewriting would be needed</p>",
        "id": 243368808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624274980
    },
    {
        "content": "<p>I'm not sure what your suggestion regarding <code>setoid.r</code> is</p>",
        "id": 243369492,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624275400
    },
    {
        "content": "<p>Any theorem about a type with a setoid structure that refers to <code>setoid.r</code> should instead be a theorem about a type with a relation <code>r</code> (possibly with <code>equivalence r</code> as a typeclass arg) and refer to <code>r</code> in the statement</p>",
        "id": 243369670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624275520
    },
    {
        "content": "<p>with that, we wouldn't even need <code>quotient</code></p>",
        "id": 243369749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624275584
    },
    {
        "content": "<p>I've used <code>quotient</code> over <code>quot</code> before to get the <code>⟦...⟧</code> notation, which has been nice to use even if it's occasionally frustrating due to setoids.  Arguably each quotient type should have its own bespoke constructor or notation, though.</p>\n<p>Maybe having an opt-in notation typeclass would be a good alternative?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">quot_notation</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"sd\">/-- Representing terms of `β` by terms of `α` -/</span>\n<span class=\"c1\">-- It might make sense for one of these parameters to be an out_param</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_repr</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">from_repr</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`⟦`</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"n\">a</span> <span class=\"bp\">`⟧`</span><span class=\"o\">:</span><span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">has_repr.from_repr</span> <span class=\"n\">a</span>\n\n\n<span class=\"c1\">-- Example of unordered pairs</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">swap</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">r</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">p</span> <span class=\"bp\">==</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">swap</span> <span class=\"n\">p</span> <span class=\"bp\">==</span> <span class=\"n\">q</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">unordered_pair</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">quot</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">unordered_pair.has_repr</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_repr</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">unordered_pair</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">quot.mk</span> <span class=\"n\">r</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">unordered_pair</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">quot_notation</span>\n</code></pre></div>",
        "id": 243404502,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624291323
    },
    {
        "content": "<p>Here <code>\\beta</code> has to be an out-param, right?</p>",
        "id": 243404642,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624291382
    },
    {
        "content": "<p>Or α in case you want to write <code>⟦42⟧</code>?</p>",
        "id": 243404902,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1624291495
    },
    {
        "content": "<p>Using a notation typeclass causes the same issues around having to unfold <code>has_repr.from_repr</code> for each particular quotient though</p>",
        "id": 243405258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624291654
    },
    {
        "content": "<p>I think it makes more sense for alpha to be the out param for quotients</p>",
        "id": 243405456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624291726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Setoid.20hell/near/243404642\">said</a>:</p>\n<blockquote>\n<p>Here <code>\\beta</code> has to be an out-param, right?</p>\n</blockquote>\n<p>what is an out-param? I saw them in the defn of the notation typeclasses</p>",
        "id": 243406745,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1624292370
    },
    {
        "content": "<p>It's a type parameter of a class that we can let Lean infer. But the experts will know better than me.</p>",
        "id": 243406864,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1624292418
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/out_param\">docs#out_param</a>, not that that will help much</p>",
        "id": 243407467,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624292717
    },
    {
        "content": "<p>yeah, I've seen it before for a very unhelpful docstring :b</p>",
        "id": 243407885,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1624292918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Setoid.20hell/near/243405258\">said</a>:</p>\n<blockquote>\n<p>Using a notation typeclass causes the same issues around having to unfold <code>has_repr.from_repr</code> for each particular quotient though</p>\n</blockquote>\n<p>Isn't this essentially the same issue as defining your own <code>mk</code> wrapper function per type, though?  I might have misunderstood what you were proposing.</p>",
        "id": 243409978,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624293976
    },
    {
        "content": "<p>If you have your own wrapper function then there is nothing to unfold, because it's already in the correct form</p>",
        "id": 243410716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624294328
    },
    {
        "content": "<p>The problem with using raw <code>quot.mk</code> directly is that it has type <code>quot r</code> instead of <code>my_quot</code>, which means that if <code>my_quot</code> has e.g. an addition structure because it's a ring or something then the typeclass will get confused</p>",
        "id": 243410992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624294465
    },
    {
        "content": "<p><code>has_repr</code> doesn't have that issue, but it's not clear to be whether we can have generalized lemmas over it for all quotients without writing the type as <code>quot r</code></p>",
        "id": 243411127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624294546
    },
    {
        "content": "<p>Is there a reason the addition structure can't be put directly on <code>quot r</code> instead of <code>my_quot</code> in that case?</p>",
        "id": 243411389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624294652
    },
    {
        "content": "<p>If <code>my_quot</code> is <code>@[reducible]</code> then that would still work, right?</p>",
        "id": 243411418,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624294667
    },
    {
        "content": "<p>you could, but I would worry about conflicts because <code>quot r</code> isn't \"your\" type</p>",
        "id": 243411522,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624294702
    },
    {
        "content": "<p>the relation <code>r</code> is \"yours\" but I don't think that's sufficient because relations can be all sorts of things and they are generally not newtyped</p>",
        "id": 243411799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624294826
    },
    {
        "content": "<p>\"newtyping\" the relation feels like it would be less annoying than newtyping the quotient</p>",
        "id": 243412294,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624295049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> Usually, if you have a <code>class foo (X : Type) (Y : Type)</code>, then we want a unique instance for <code>foo X Y</code> for every pair <code>X, Y</code>. Now if you have <code>class foo (X : Type) (Y : out_param $ Type)</code>, then we want a unique instance for <code>foo X Y</code> for every <code>X</code>. This way, typeclass inference can determine <code>Y</code>, once <code>X</code> is known.</p>",
        "id": 243413521,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1624295653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I'm still not quite understanding the difference between a wrapper function and a <code>has_repr</code> instance.  My idea with the typeclass is just to give a canonical name to the wrapper function, and I didn't mean to suggest it would let you have generalized quotient lemmas.  I just figured that if you're wanting to abolish <code>quotient</code>, then this might be a nice alternative that's more controllable than the old notation.</p>",
        "id": 243416234,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1624296916
    }
]
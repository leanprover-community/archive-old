[
    {
        "content": "<p>Hi, I have a simple wrapper </p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">decidable_eq</span><span class=\"o\">]</span>\n  <span class=\"kn\">structure</span> <span class=\"n\">Address</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>but want to assign some properties for it already defined for ints (e.g. <code>linear_order</code>) . Is there a straightforward way of defining  instances  like this beyond duplicating all the code for ints?</p>",
        "id": 206223914,
        "sender_full_name": "Kris Brown",
        "timestamp": 1596775762
    },
    {
        "content": "<p>We have quite a few <code>def</code>s/<code>lemma</code>s that transfer instances along equivalences.</p>",
        "id": 206225755,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1596778838
    },
    {
        "content": "<p>E.g., look at <code>data/equiv/transfer_instance</code> for algebraic types and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_order.lift\">docs#linear_order.lift</a> etc for <code>order</code>.</p>",
        "id": 206225771,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1596778892
    },
    {
        "content": "<p>Thanks, that puts me on track to solve this!  It feels basic but  I'm going in circles trying to prove the  equivalence. I can prove a bijection from int to Address but cannot prove an injection from Address to int, which is what I need</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"c1\">-- linear_order.lift needs an injective function TO the type that already has</span>\n  <span class=\"c1\">-- a linear_order instance</span>\n  <span class=\"n\">def</span> <span class=\"n\">cast_address</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Address</span><span class=\"o\">):</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n  <span class=\"c1\">-- needed to prove bij below</span>\n  <span class=\"kn\">lemma</span> <span class=\"n\">val_mk_inverse</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">Address</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Address</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span>\n  <span class=\"c1\">-- That the inverse of cast_address is surjective might be useful?</span>\n  <span class=\"kn\">lemma</span> <span class=\"n\">bij</span><span class=\"o\">:</span>  <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">bijective</span> <span class=\"n\">Address</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">bijective</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">finish</span><span class=\"o\">},</span> <span class=\"c1\">-- injectivity handled automatically</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">surjective</span><span class=\"o\">,</span> <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">Address</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">val_mk_inverse</span>  <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"bp\">⟩</span>\n  <span class=\"kn\">end</span>\n\n  <span class=\"kn\">lemma</span> <span class=\"n\">inj</span><span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"n\">cast_address</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"o\">,</span> <span class=\"n\">intros</span> <span class=\"n\">a1</span> <span class=\"n\">a2</span> <span class=\"n\">castEq</span><span class=\"o\">,</span>\n   <span class=\"n\">unfold</span> <span class=\"n\">cast_address</span> <span class=\"n\">at</span> <span class=\"n\">castEq</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">Hinj</span><span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"n\">Address</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">:=</span> <span class=\"n\">bij</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"n\">at</span> <span class=\"n\">Hinj</span><span class=\"o\">,</span>\n\n      <span class=\"c1\">-- have Hsur: function.surjective Address.mk := bij.2,</span>\n\n      <span class=\"c1\">-- unfold function.surjective at Hsur,</span>\n\n    <span class=\"n\">cases</span> <span class=\"n\">Address</span><span class=\"bp\">.</span><span class=\"n\">decidable_eq</span> <span class=\"n\">a1</span> <span class=\"n\">a2</span><span class=\"o\">,</span>\n\n\n    <span class=\"c1\">-- have Hsur: function.surjective Address.mk := bij.2,</span>\n    <span class=\"c1\">-- unfold function.surjective at Hsur,</span>\n    <span class=\"c1\">-- have h1 := Hsur a1, have h2 := Hsur a2,</span>\n    <span class=\"c1\">-- cases eq1: h1 with h1v h1&#39;, cases eq2: h2 with h2v h2&#39;,</span>\n    <span class=\"c1\">-- rw &lt;-h1&#39;, rw &lt;-h2&#39;, simp,</span>\n    <span class=\"c1\">-- have Hinj: function.injective Address.mk := bij.1,</span>\n    <span class=\"c1\">-- unfold function.injective at Hinj,</span>\n    <span class=\"c1\">-- have Hinj&#39; := @Hinj h1v h2v,</span>\n    <span class=\"c1\">-- apply Hinj&#39;,</span>\n    <span class=\"c1\">-- simp,</span>\n  <span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Is there an easy way to do this for a simple wrapper?</p>",
        "id": 206228361,
        "sender_full_name": "Kris Brown",
        "timestamp": 1596782659
    },
    {
        "content": "<p>Also not having luck trying to extract the the inverse from the bijection</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"n\">def</span> <span class=\"n\">inverse_of_bijection_is_injective</span><span class=\"o\">:</span> <span class=\"err\">Σ&#39;</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Address</span> <span class=\"bp\">→</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n    <span class=\"c1\">-- Error right at the start: &quot;induction tactic failed,</span>\n    <span class=\"c1\">-- recursor &#39;Exists.dcases_on&#39; can only eliminate into Prop&quot;</span>\n    <span class=\"k\">match</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">bijective_iff_has_inverse</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">bij</span> <span class=\"k\">with</span>\n     <span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span> <span class=\"o\">,</span><span class=\"n\">b</span> <span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span>\n     <span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Different error which I also don't fully grasp when I try this in tactic mode:</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"n\">def</span> <span class=\"n\">cast_to_int&#39;</span><span class=\"o\">:</span> <span class=\"err\">Σ&#39;</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">Address</span> <span class=\"bp\">→</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">bijective_iff_has_inverse</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">bij</span><span class=\"o\">,</span>\n    <span class=\"n\">existsi</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"c1\">-- existsi tactic failed, type mismatch between given</span>\n               <span class=\"c1\">--term witness and expected type</span>\n\n    <span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 206233763,
        "sender_full_name": "Kris Brown",
        "timestamp": 1596788626
    },
    {
        "content": "<p>You shouldn't be proving things like <code>bijective</code>, you should be writing down functions in each direction and proving they're inverses of each other, ie making a term of type <code>equiv Address int</code></p>",
        "id": 206239347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596793377
    },
    {
        "content": "<p>To get an inverse operation from a bijection you need the axiom of choice -- why not just build the inverse explicitly and use that</p>",
        "id": 206239483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596793503
    },
    {
        "content": "<p>To explain your error: <code>bijective</code> is defined as a Prop (does not contain data). But <code>Σ</code> is a Type (contains data) and so needs a concrete witness to construct. (Technically your code uses <code>Σ'</code> but the principle is the same.)</p>",
        "id": 206240635,
        "sender_full_name": "Chris Wong",
        "timestamp": 1596794459
    },
    {
        "content": "<p>I see now - thanks for explaining the error and connection to choice. And eventually was able to prove the injectivity (don't know why it took me so many attempts):</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"kn\">structure</span> <span class=\"n\">Address</span><span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n  <span class=\"n\">def</span> <span class=\"n\">to_z</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Address</span><span class=\"o\">):</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n  <span class=\"kn\">lemma</span> <span class=\"n\">to_z_inj</span><span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"n\">to_z</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span>  <span class=\"n\">t1</span> <span class=\"n\">t2</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e1</span><span class=\"o\">:</span><span class=\"n\">t1</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">e2</span><span class=\"o\">:</span><span class=\"n\">t2</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"n\">unfold</span> <span class=\"n\">to_z</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">e1</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">e2</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 206240896,
        "sender_full_name": "Kris Brown",
        "timestamp": 1596794702
    },
    {
        "content": "<p>The <code>equiv</code> is easier to make and all the lemmas which you're proving are already proved for general <code>equiv</code>s.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">decidable_eq</span><span class=\"o\">]</span>\n<span class=\"kn\">structure</span> <span class=\"n\">Address</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">cast_address</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Address</span><span class=\"o\">):</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"n\">def</span> <span class=\"n\">inv_fun</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Address</span> <span class=\"o\">:=</span> <span class=\"n\">Address</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">n</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bij</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">Address</span> <span class=\"bp\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">cast_address</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">inv_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">intro</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">val_mk_inverse</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">Address</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Address</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">z</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">bij</span><span class=\"bp\">.</span><span class=\"n\">left_inv</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">bij&#39;</span> <span class=\"o\">:</span>  <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">bijective</span> <span class=\"n\">Address</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">:=</span> <span class=\"n\">bij</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">bijective</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">inj</span><span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"n\">cast_address</span> <span class=\"o\">:=</span> <span class=\"n\">bij</span><span class=\"bp\">.</span><span class=\"n\">injective</span>\n</code></pre></div>",
        "id": 206243301,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596796931
    },
    {
        "content": "<p>If you are in a situation where you can write down the inverse, rather than just abstractly proving that a function is bijective (a weaker statement because it's a Prop rather than data) then you should write down the inverse; it makes your objects much easier to work with.</p>",
        "id": 206243354,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596797020
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312852\">@Kris Brown</span> what do you need this for? (<a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>)</p>",
        "id": 206245038,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596798518
    },
    {
        "content": "<p>I'll interpret that question pretty broadly. I'm working on a project for formally verified Go code.  My initial work was modeling Hoare logic based on this resource (<a href=\"https://github.com/coq-community/hoare-tut\">https://github.com/coq-community/hoare-tut</a>) , and lately I've switched to modeling separation logic based on this resource (<a href=\"https://github.com/affeldt-aist/seplog/blob/master/seplog/seplog.v\">https://github.com/affeldt-aist/seplog/blob/master/seplog/seplog.v</a>). </p>\n<p>I've copied definitions of some of the core data structures to give a feel for the project.</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"kn\">inductive</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n   <span class=\"bp\">|</span> <span class=\"n\">gInt</span><span class=\"o\">:</span>  <span class=\"n\">GoTypeDecl</span>\n   <span class=\"bp\">|</span> <span class=\"n\">gStr</span><span class=\"o\">:</span>  <span class=\"n\">GoTypeDecl</span>\n   <span class=\"bp\">|</span> <span class=\"n\">gErr</span><span class=\"o\">:</span>  <span class=\"n\">GoTypeDecl</span>\n   <span class=\"bp\">|</span> <span class=\"n\">gBool</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span>\n   <span class=\"bp\">|</span> <span class=\"n\">gPtr</span><span class=\"o\">:</span>  <span class=\"n\">GoTypeDecl</span> <span class=\"bp\">→</span> <span class=\"n\">GoTypeDecl</span>\n   <span class=\"bp\">|</span> <span class=\"n\">gRef</span><span class=\"o\">:</span>  <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">GoTypeDecl</span>\n\n  <span class=\"kn\">inductive</span> <span class=\"n\">GoPrimType</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n   <span class=\"bp\">|</span> <span class=\"n\">pInt</span><span class=\"o\">:</span>  <span class=\"bp\">ℤ</span>  <span class=\"bp\">→</span> <span class=\"n\">GoPrimType</span>\n   <span class=\"bp\">|</span> <span class=\"n\">pStr</span><span class=\"o\">:</span>  <span class=\"n\">string</span>  <span class=\"bp\">→</span> <span class=\"n\">GoPrimType</span>\n   <span class=\"bp\">|</span> <span class=\"n\">pErr</span><span class=\"o\">:</span>  <span class=\"n\">string</span>  <span class=\"bp\">→</span> <span class=\"n\">GoPrimType</span>\n   <span class=\"bp\">|</span> <span class=\"n\">pBool</span><span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">GoPrimType</span>\n   <span class=\"bp\">|</span> <span class=\"n\">pPt</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span> <span class=\"bp\">→</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">GoPrimType</span>\n   <span class=\"bp\">|</span> <span class=\"n\">pStruct&#39;</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fields</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"n\">vals</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">fields</span><span class=\"o\">,</span> <span class=\"n\">GoPrimType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">GoPrimType</span>\n\n  <span class=\"kn\">structure</span> <span class=\"n\">GoStruct</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">):=</span>\n     <span class=\"o\">(</span><span class=\"n\">fields</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vals</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">fields</span><span class=\"o\">,</span> <span class=\"n\">GoPrimType</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">type_dict</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n    <span class=\"bp\">|</span> <span class=\"n\">gStr</span>    <span class=\"o\">:=</span> <span class=\"n\">string</span>\n    <span class=\"bp\">|</span> <span class=\"n\">gErr</span>    <span class=\"o\">:=</span> <span class=\"n\">string</span>\n    <span class=\"bp\">|</span> <span class=\"n\">gInt</span>    <span class=\"o\">:=</span> <span class=\"bp\">ℤ</span>\n    <span class=\"bp\">|</span> <span class=\"n\">gBool</span>   <span class=\"o\">:=</span> <span class=\"n\">bool</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">gPtr</span> <span class=\"bp\">_</span><span class=\"o\">):=</span> <span class=\"bp\">ℤ</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">gRef</span> <span class=\"n\">s</span><span class=\"o\">):=</span> <span class=\"n\">GoStruct</span> <span class=\"n\">s</span>\n\n  <span class=\"kn\">structure</span> <span class=\"n\">Address</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n  <span class=\"kn\">structure</span> <span class=\"n\">Heap</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">vals</span><span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">:</span> <span class=\"n\">Address</span><span class=\"o\">,</span> <span class=\"err\">Σ</span> <span class=\"n\">dt</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">,</span> <span class=\"n\">type_dict</span> <span class=\"n\">dt</span><span class=\"o\">))</span>\n  <span class=\"kn\">structure</span> <span class=\"n\">Store</span> <span class=\"o\">:=</span>   <span class=\"o\">(</span><span class=\"n\">vals</span><span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">,</span> <span class=\"err\">Σ</span> <span class=\"n\">dt</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">,</span> <span class=\"n\">type_dict</span> <span class=\"n\">dt</span><span class=\"o\">))</span>\n  <span class=\"kn\">structure</span> <span class=\"n\">Var</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n\n  <span class=\"kn\">inductive</span> <span class=\"n\">Expr</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n   <span class=\"bp\">|</span> <span class=\"n\">const</span>  <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}:</span> <span class=\"n\">type_dict</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span>\n   <span class=\"bp\">|</span> <span class=\"n\">getvar</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}:</span> <span class=\"n\">Var</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span>\n   <span class=\"bp\">|</span> <span class=\"n\">relop</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}:</span>\n      <span class=\"n\">Relop</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">gBool</span>\n   <span class=\"bp\">|</span> <span class=\"n\">binop</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}:</span>\n      <span class=\"n\">Binop</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span>\n   <span class=\"bp\">|</span> <span class=\"n\">unop</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}:</span>\n      <span class=\"n\">Unop</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">get_field</span> <span class=\"o\">{</span><span class=\"n\">struct</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}:</span>\n      <span class=\"n\">Expr</span> <span class=\"o\">(</span><span class=\"n\">gRef</span> <span class=\"n\">struct</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">update_field</span> <span class=\"o\">{</span><span class=\"n\">struct</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}:</span> <span class=\"c1\">-- pure update/not mutation</span>\n      <span class=\"n\">Expr</span> <span class=\"o\">(</span><span class=\"n\">gRef</span> <span class=\"n\">struct</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"o\">(</span><span class=\"n\">gRef</span> <span class=\"n\">struct</span><span class=\"o\">)</span>\n\n  <span class=\"kn\">inductive</span> <span class=\"n\">cmd</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n    <span class=\"bp\">|</span> <span class=\"n\">skip</span><span class=\"o\">:</span> <span class=\"n\">cmd</span>\n    <span class=\"bp\">|</span> <span class=\"n\">assign</span>   <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}:</span> <span class=\"n\">Var</span> <span class=\"n\">α</span>         <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span>        <span class=\"bp\">→</span> <span class=\"n\">cmd</span>\n    <span class=\"bp\">|</span> <span class=\"n\">lookup</span>   <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}:</span> <span class=\"n\">Var</span> <span class=\"n\">α</span>         <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"o\">(</span><span class=\"n\">gPtr</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">cmd</span>\n    <span class=\"bp\">|</span> <span class=\"n\">mutation</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}:</span> <span class=\"n\">Expr</span> <span class=\"o\">(</span><span class=\"n\">gPtr</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span>        <span class=\"bp\">→</span> <span class=\"n\">cmd</span>\n    <span class=\"bp\">|</span> <span class=\"n\">while</span><span class=\"o\">:</span>                    <span class=\"n\">Expr</span> <span class=\"n\">gBool</span>    <span class=\"bp\">→</span> <span class=\"n\">cmd</span>           <span class=\"bp\">→</span> <span class=\"n\">cmd</span>\n    <span class=\"bp\">|</span> <span class=\"n\">seq</span><span class=\"o\">:</span>                      <span class=\"n\">cmd</span>           <span class=\"bp\">→</span> <span class=\"n\">cmd</span>           <span class=\"bp\">→</span> <span class=\"n\">cmd</span>\n    <span class=\"bp\">|</span> <span class=\"n\">ifte</span><span class=\"o\">:</span>                     <span class=\"n\">Expr</span> <span class=\"n\">gBool</span>    <span class=\"bp\">→</span> <span class=\"n\">cmd</span>           <span class=\"bp\">→</span> <span class=\"n\">cmd</span> <span class=\"bp\">→</span> <span class=\"n\">cmd</span>\n    <span class=\"bp\">|</span> <span class=\"n\">declare</span>  <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}:</span> <span class=\"n\">Var</span> <span class=\"o\">(</span><span class=\"n\">gPtr</span> <span class=\"n\">α</span><span class=\"o\">)</span>  <span class=\"bp\">→</span> <span class=\"n\">cmd</span>\n    <span class=\"bp\">|</span> <span class=\"n\">isnil</span>    <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}:</span> <span class=\"n\">Expr</span> <span class=\"o\">(</span><span class=\"n\">gPtr</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Var</span> <span class=\"n\">gBool</span>     <span class=\"bp\">→</span> <span class=\"n\">cmd</span>\n    <span class=\"bp\">|</span> <span class=\"n\">call</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">struct</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">}</span>\n           <span class=\"o\">(</span><span class=\"n\">callee</span><span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"o\">(</span><span class=\"n\">gRef</span> <span class=\"n\">struct</span><span class=\"o\">))</span> <span class=\"c1\">-- object whose method is called</span>\n           <span class=\"o\">(</span><span class=\"n\">method</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span>             <span class=\"c1\">-- Name of method</span>\n           <span class=\"o\">(</span><span class=\"n\">arg</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"err\">Σ</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span><span class=\"o\">))</span>    <span class=\"c1\">-- Values we want to pass to the func</span>\n           <span class=\"o\">(</span><span class=\"n\">result</span><span class=\"o\">:</span> <span class=\"n\">Var</span> <span class=\"n\">β</span><span class=\"o\">)</span>              <span class=\"c1\">-- store result in this variable</span>\n           <span class=\"o\">:</span> <span class=\"n\">cmd</span><span class=\"bp\">.</span>\n\n  <span class=\"kn\">structure</span> <span class=\"n\">Sig</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">×</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">return</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">×</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">receiver</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is_ptr</span><span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n\n  <span class=\"kn\">structure</span> <span class=\"n\">GoStructDecl</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">fields</span><span class=\"o\">:</span> <span class=\"n\">pairmap</span> <span class=\"n\">string</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">methods</span><span class=\"o\">:</span> <span class=\"n\">pairmap</span> <span class=\"n\">string</span> <span class=\"o\">(</span><span class=\"n\">Sig</span> <span class=\"bp\">×</span> <span class=\"n\">cmd</span><span class=\"o\">))</span>\n\n  <span class=\"kn\">structure</span> <span class=\"n\">Decls</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">structs</span><span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">,</span> <span class=\"err\">Σ</span> <span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"n\">unit</span><span class=\"o\">,</span> <span class=\"n\">GoStructDecl</span> <span class=\"n\">s</span><span class=\"o\">)))</span>\n\n  <span class=\"n\">def</span> <span class=\"n\">Ctx</span> <span class=\"o\">:=</span> <span class=\"n\">Store</span> <span class=\"bp\">×</span> <span class=\"n\">Heap</span> <span class=\"bp\">×</span>  <span class=\"n\">Decls</span>\n\n <span class=\"c1\">-- semantics of expressions</span>\n  <span class=\"n\">def</span> <span class=\"kn\">eval</span><span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"n\">GoTypeDecl</span><span class=\"o\">},</span> <span class=\"n\">Expr</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Store</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">type_dict</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Semantics of program commands</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">exec</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">Ctx</span> <span class=\"bp\">→</span> <span class=\"n\">cmd</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">Ctx</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"c1\">-- [A bunch of lemmas related to separation logic, weakest preconditions]</span>\n</code></pre></div>\n\n\n<p>To answer the question narrowly, I want to define a <code>to_string</code> method for <code>Heap</code> and I need to convert the map into a list of pairs that can be printed, which requires a decidable linear order on the keys. I could just use raw integers instead of defining <code>Address</code>, but I like the type-safety since integers are used in lots of places.</p>",
        "id": 206321277,
        "sender_full_name": "Kris Brown",
        "timestamp": 1596844522
    }
]
[
    {
        "content": "<p>For the sake of demonstration I would like to simplify expressions involving +, eg.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span>  <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">add</span><span class=\"o\">]</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>but this doesn't work How do I refer to add? It is defined in init.core</p>",
        "id": 210864616,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600778914
    },
    {
        "content": "<p><code>has_add.add</code></p>",
        "id": 210864856,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600779060
    },
    {
        "content": "<p><code>has_add.add</code>, or more conveniently <code>(+)</code></p>",
        "id": 210864859,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1600779061
    },
    {
        "content": "<p>Hmm,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span>  <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">has_add.add</span><span class=\"o\">],</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>doesn't work for me (it doesn't reduce). But</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span>  <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[(</span><span class=\"bp\">+</span><span class=\"o\">),</span><span class=\"n\">nat.add</span><span class=\"o\">],</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>does work.</p>",
        "id": 210866019,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600779618
    },
    {
        "content": "<p>typo, maybe?: <code>has_add.add</code> (not <code>,</code>)</p>",
        "id": 210866180,
        "sender_full_name": "Carl Friedrich Bolz-Tereick",
        "timestamp": 1600779688
    },
    {
        "content": "<p>And <code>,</code> at the end of the line</p>",
        "id": 210866213,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1600779706
    },
    {
        "content": "<p>conservation of punctuation ;-)</p>",
        "id": 210866448,
        "sender_full_name": "Carl Friedrich Bolz-Tereick",
        "timestamp": 1600779827
    },
    {
        "content": "<p>Also, don't unfold definitions!</p>",
        "id": 210871580,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1600782364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/210871580\">said</a>:</p>\n<blockquote>\n<p>Also, don't unfold definitions!</p>\n</blockquote>\n<p>How do you explain your students what is going on if you don't reduce definitions?</p>",
        "id": 210881638,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600786508
    },
    {
        "content": "<p>You can just tell them that it's defined recursively, so it comes with two \"axioms\" m + 0 = m and m + (n + 1) = (m + n) + 1</p>",
        "id": 210882001,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1600786631
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271218\">Thorsten Altenkirch</span> <a href=\"#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/210881638\">said</a>:</p>\n<blockquote>\n<p>How do you explain your students what is going on if you don't reduce definitions?</p>\n</blockquote>\n<p>fwiw you can see (and use) the unfolded forms without actually unfolding it by printing the definition's prefix. The output of<code>#print prefix nat.add</code> will include the lemmas : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">nat.add.equations._eqn_1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a.add</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n<span class=\"n\">nat.add.equations._eqn_2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a.add</span> <span class=\"n\">b.succ</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a.add</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n</code></pre></div>",
        "id": 210884057,
        "sender_full_name": "Chris B",
        "timestamp": 1600787314
    },
    {
        "content": "<p>But I don't even have to apply these \"axioms\" which are actually just the definition.</p>",
        "id": 210884082,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600787323
    },
    {
        "content": "<p>This is what I mentioned <a href=\"#narrow/stream/113489-new-members/topic/band.2C.20bor/near/210763945\">earlier</a> about lean automatically generating a basic API for every definition. Please don't use defeq if you can avoid it. Yes you can prove these by refl but that's bad practice because it makes your proof sensitive to the definition</p>",
        "id": 210888973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600789170
    },
    {
        "content": "<p>and to stress: these equation lemmas are not always true by refl. They are for simple structural recursions but there are definitions you can write where refl doesn't work</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">log2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n    <span class=\"k\">have</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">nat.div_lt_self</span> <span class=\"n\">h</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n    <span class=\"n\">log2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">log2.equations._eqn_1</span>\n<span class=\"c1\">-- theorem log2.equations._eqn_1 : ∀ (n : ℕ), log2 n = ite (0 &lt; n) (log2 (n / 2) + 1) 0 :=</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">log2</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">log2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 210889675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600789471
    },
    {
        "content": "<p>If you actually really want to see the definition you will get something impenetrable for a beginner</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">log2</span> <span class=\"bp\">=</span> <span class=\"n\">has_well_founded.wf.fix</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span>\n    <span class=\"n\">id_rhs</span> <span class=\"o\">((</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">_y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">has_well_founded.r</span> <span class=\"n\">_y</span> <span class=\"n\">_x</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">_y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">has_well_founded.r</span> <span class=\"n\">_y</span> <span class=\"n\">_x</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span>\n        <span class=\"n\">dite</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">_x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">_x</span><span class=\"o\">),</span>\n            <span class=\"k\">have</span> <span class=\"n\">this</span> <span class=\"o\">:</span> <span class=\"n\">_x</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">_x</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">nat.div_lt_self</span> <span class=\"n\">h</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n            <span class=\"n\">_F</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">this</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">_x</span><span class=\"o\">),</span> <span class=\"mi\">0</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 210890164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600789686
    },
    {
        "content": "<p>the whole point of equation lemmas is so that the equation compiler is allowed to generate these horrendous terms without them getting in the way of proving simple properties about the definition</p>",
        "id": 210890325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600789765
    },
    {
        "content": "<p>Ok, I can see your point. However, <code>nat.add.equations._eqn_1 </code> is quite a mouth full compared to <code>refl</code>.</p>",
        "id": 210891006,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600790061
    },
    {
        "content": "<p>that's why you write <code>rw nat.add</code> instead</p>",
        "id": 210891083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790098
    },
    {
        "content": "<p>Certainly when using well founded recursion you don't want to use the actual definition.</p>",
        "id": 210891139,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600790123
    },
    {
        "content": "<p>when you use the name of a definition directly in <code>rw</code>, it means \"rewrite with one of the equation lemmas for the definition\"</p>",
        "id": 210891155,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790127
    },
    {
        "content": "<p>Even for structural recursions the compilation is not at all what you would expect, and I don't think we want to guarantee the equation lemmas are defeq although they generally are</p>",
        "id": 210891291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790173
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nat.succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">add</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span>\n  <span class=\"n\">nat.brec_on</span> <span class=\"n\">a_1</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_F</span> <span class=\"o\">:</span> <span class=\"n\">nat.below</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">a_1</span><span class=\"o\">),</span>\n       <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_F</span> <span class=\"o\">:</span> <span class=\"n\">nat.below</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">a_1</span><span class=\"o\">),</span>\n          <span class=\"bp\">@</span><span class=\"n\">nat.cases_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">nat.below</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">a_1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_F</span> <span class=\"o\">:</span> <span class=\"n\">nat.below</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">id_rhs</span> <span class=\"n\">ℕ</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_F</span> <span class=\"o\">:</span> <span class=\"n\">nat.below</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">a_1</span><span class=\"o\">)),</span> <span class=\"n\">id_rhs</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">_F.fst.fst</span><span class=\"o\">))</span>\n            <span class=\"n\">_F</span><span class=\"o\">)</span>\n         <span class=\"n\">a_1</span>\n         <span class=\"n\">_F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">delta</span> <span class=\"n\">add</span> <span class=\"n\">add._main</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n</code></pre></div>\n\n<p>In this case I can't even use <code>rfl</code> to prove it because the definition <code>add._main</code> is marked irreducible. Lean is really strongly trying to encourage you not to do this</p>",
        "id": 210891910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790405
    },
    {
        "content": "<p>Ok, just tried it. Here is the <em>bad</em> proof with <code>refl</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">add_succ_lem</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n'</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">congr_arg</span> <span class=\"n\">succ</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">m</span> <span class=\"k\">with</span> <span class=\"n\">m'</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">lneutr</span><span class=\"o\">,</span>\n  <span class=\"k\">calc</span>\n    <span class=\"n\">succ</span> <span class=\"n\">m'</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">m'</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">add_succ_lem</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">congr_arg</span> <span class=\"n\">succ</span> <span class=\"n\">ih</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">succ</span> <span class=\"n\">m'</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>but if I replace <code>refl</code> as you suggest:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">m</span> <span class=\"k\">with</span> <span class=\"n\">m'</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">lneutr</span><span class=\"o\">,</span>\n  <span class=\"k\">calc</span>\n    <span class=\"n\">succ</span> <span class=\"n\">m'</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">m'</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">add_succ_lem</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">congr_arg</span> <span class=\"n\">succ</span> <span class=\"n\">ih</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">succ</span> <span class=\"n\">m'</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rewrite</span> <span class=\"n\">nat.add</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>It doesn't work?</p>",
        "id": 210892078,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600790468
    },
    {
        "content": "<p>By the way, <code>delta</code> is a tactic which unfolds anything along the primitive delta reduction. You usually don't want to do this for equation compiler definitions because the result is big and scary as you can see</p>",
        "id": 210892196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790515
    },
    {
        "content": "<p>um can you <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> that example?</p>",
        "id": 210892324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790551
    },
    {
        "content": "<p>what's <code>lneutr</code></p>",
        "id": 210892342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790558
    },
    {
        "content": "<p>sorry <a href=\"/user_uploads/3121/LSJWBMWWL8aFppvFVtlwO_dj/nat.lean\">nat.lean</a></p>",
        "id": 210892428,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600790598
    },
    {
        "content": "<p>eh, code blocks are better than uploads</p>",
        "id": 210892476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790621
    },
    {
        "content": "<p>also I assume the example is just missing one theorem, so you don't need the whole file</p>",
        "id": 210892577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790653
    },
    {
        "content": "<p>that's the M in <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 210892593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790658
    },
    {
        "content": "<p>Yes, I forgot that I used lneutr.</p>",
        "id": 210892628,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600790678
    },
    {
        "content": "<p>Here's an mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">nat</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">add_succ_lem</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">lneutr</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">m</span> <span class=\"k\">with</span> <span class=\"n\">m'</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">lneutr</span><span class=\"o\">,</span>\n  <span class=\"k\">calc</span>\n    <span class=\"n\">succ</span> <span class=\"n\">m'</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">m'</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">add_succ_lem</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">congr_arg</span> <span class=\"n\">succ</span> <span class=\"n\">ih</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">succ</span> <span class=\"n\">m'</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 210892664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790696
    },
    {
        "content": "<p>Fair enough.</p>",
        "id": 210892735,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600790729
    },
    {
        "content": "<p>You can't just use <code>rw nat.add</code> here because you have to unfold <code>+</code> too</p>",
        "id": 210892854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790774
    },
    {
        "content": "<p>Usually we write manual equation lemmas in terms of <code>+</code> for this case</p>",
        "id": 210892890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790788
    },
    {
        "content": "<p>but in this case you can first unfold + then nat.add:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">m</span> <span class=\"k\">with</span> <span class=\"n\">m'</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">lneutr</span><span class=\"o\">,</span>\n  <span class=\"k\">calc</span>\n    <span class=\"n\">succ</span> <span class=\"n\">m'</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">m'</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">add_succ_lem</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">congr_arg</span> <span class=\"n\">succ</span> <span class=\"n\">ih</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">succ</span> <span class=\"n\">m'</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">dsimp</span> <span class=\"o\">[(</span><span class=\"bp\">+</span><span class=\"o\">)]</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">nat.add</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 210892916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790802
    },
    {
        "content": "<p>so the official way to do this would be to <code>rw add_succ</code></p>",
        "id": 210893014,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790856
    },
    {
        "content": "<p>where</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">add_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 210893069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790881
    },
    {
        "content": "<p>and yes you can argue that using rfl here is a double standard, but as long as it is sufficiently close to the definition you can consider it within the API barrier, like the proof of <code>add.equations._eqn_1</code> itself</p>",
        "id": 210893264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600790954
    },
    {
        "content": "<p>OK this is a good point (explicitly referring to definitions instead of refl). It is a shame that lean just copied the syntax declaration from Coq instead of agda whose mixfix definitions work much more smoothly.</p>",
        "id": 210893559,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600791074
    },
    {
        "content": "<p>indeed, it is a bit unfortunate that <code>+</code> is considered a separate definition from <code>nat.add</code>, at least in these cases</p>",
        "id": 210893652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600791119
    },
    {
        "content": "<p>In other cases it is an advantage since it makes it easier to state generic theorems that match by typeclass inference, for example <code>add_assoc</code> which is a theorem about additive semigroups and unifies with the nat case</p>",
        "id": 210893816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600791177
    },
    {
        "content": "<p>I'm not familiar with agda. Does it have an analogue of <code>add_assoc</code> that works for natural numbers and also random other additive semigroups?</p>",
        "id": 210894370,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600791412
    },
    {
        "content": "<p>Afaict the Agda stdlib has a structure (\"record\") for semigroups and an instance of that structure for naturals with addition. Not sure whether the thing is ready to use as a type class. The stdlib does not overload <code>+</code>, so <code>n + m</code> only works for naturals <code>n</code> and <code>m</code>. In general, the library is not really focused on mathematics, which shows in design decisions like this.</p>",
        "id": 211008028,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1600870014
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271218\">@Thorsten Altenkirch</span> if the price to pay for getting + to work the way you want it to is that you can't use + to add e.g. vectors in a vector space over an arbitrary field, that's not a price that mathematicians are going to be willing to pay.</p>",
        "id": 211009227,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600870446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211009227\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271218\">Thorsten Altenkirch</span> if the price to pay for getting + to work the way you want it to is that you can't use + to add e.g. vectors in a vector space over an arbitrary field, that's not a price that mathematicians are going to be willing to pay.</p>\n</blockquote>\n<p>Where did I suggest this?  I completely agree that mathematical conventions and notations should be reflected and rationalised in a system like Lean. Having said this not every notational convention is good, e.g. the use of variables in conventional Mathematics is often confusing.</p>",
        "id": 211031681,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600880338
    },
    {
        "content": "<p>heh you know how to find interesting battles to pick</p>",
        "id": 211031808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600880397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211008028\">said</a>:</p>\n<blockquote>\n<p>Afaict the Agda stdlib has a structure (\"record\") for semigroups and an instance of that structure for naturals with addition. Not sure whether the thing is ready to use as a type class. The stdlib does not overload <code>+</code>, so <code>n + m</code> only works for naturals <code>n</code> and <code>m</code>. In general, the library is not really focused on mathematics, which shows in design decisions like this.</p>\n</blockquote>\n<p>Indeed, agda has got a mechanism for instance arguments and this can be used to implement overloading. The standard library is quite old and should be refactored along those lines.</p>",
        "id": 211031916,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600880429
    },
    {
        "content": "<p>lean 3 has a mechanism for overloading but it's not very good</p>",
        "id": 211031979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600880462
    },
    {
        "content": "<p>the notation typeclass approach scales better, at least with the current implementation</p>",
        "id": 211032028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600880484
    },
    {
        "content": "<p>Here is a description of Agda's mechanism: <a href=\"https://agda.readthedocs.io/en/v2.5.2/language/instance-arguments.html#instance-resolution\">https://agda.readthedocs.io/en/v2.5.2/language/instance-arguments.html#instance-resolution</a><br>\nIt should be possible to design a library which better reflects Mathematical practice. Indeed, I think the use of mixfix notation is orthogonal and actually would help here.</p>",
        "id": 211033403,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600881073
    },
    {
        "content": "<p>In many ways the syntax of lean seems antiquated to me, it seems influenced by Coq which already was cumbersome. For example the syntax of pattern matching is weird, why not writing the definitional equations you mean. Also I do think that a syntax which is aware of intention as it is available not only in Haskell but also in Python is preferable. I have already mentioned the Agda's mixfix syntax which is much more flexible and avoids the \"notation\" directives and the extra step to have to unfold notations.</p>",
        "id": 211034875,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600881757
    },
    {
        "content": "<p>We all have our hopes up for Lean 4. It should be a lot better in this respect. (But I don't know enough to make a solid statement.)</p>",
        "id": 211035477,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600882038
    },
    {
        "content": "<p>I think that agda has too many notations though, it makes things hard to read when they are overused</p>",
        "id": 211045154,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600886470
    },
    {
        "content": "<p>In particular I don't think it is a good idea to have the only name of a certain operation be an unpronounceable symbol</p>",
        "id": 211045218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600886506
    },
    {
        "content": "<p>\"the operator formerly known as bind\"</p>",
        "id": 211045232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600886514
    },
    {
        "content": "<blockquote>\n<p>For example the syntax of pattern matching is weird, why not writing the definitional equations you mean.</p>\n</blockquote>\n<p>Can you elaborate?</p>",
        "id": 211045370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600886573
    },
    {
        "content": "<p>probably the Haskell style <code>map f (x :: xs) = f x :: map f xs</code> rather than all the <code>|</code> stuff</p>",
        "id": 211046064,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600886883
    },
    {
        "content": "<p>FWIW, as a long-time Haskell programmer (and GHC developer) and now Lean user, I find Agda's pattern matching syntax pretty difficult to understand, especially the <code>with</code> or whatever thing</p>",
        "id": 211046505,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600887086
    },
    {
        "content": "<p>I wouldn't be opposed to sticking the name of the defined function left of the patterns</p>",
        "id": 211046764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600887186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271218\">Thorsten Altenkirch</span> <a href=\"#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211034875\">said</a>:</p>\n<blockquote>\n<p>and the extra step to have to unfold notations.</p>\n</blockquote>\n<p>It's not the notation that causes the extra unfolding step (use of notation is equivalent to its definition in most contexts), it's the indirection through a type class.</p>",
        "id": 211047140,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600887337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271218\">Thorsten Altenkirch</span> <a href=\"#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211034875\">said</a>:</p>\n<blockquote>\n<p>For example the syntax of pattern matching is weird, why not writing the definitional equations you mean</p>\n</blockquote>\n<p>I would find that quite misleading - pattern matching equations are <em>not</em> identical to the definitional equations of a function because of their sequential semantics. If I write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">not</span> <span class=\"n\">True</span> <span class=\"bp\">=</span> <span class=\"n\">False</span>\n<span class=\"n\">not</span> <span class=\"n\">b</span>    <span class=\"bp\">=</span> <span class=\"n\">True</span>\n</code></pre></div>\n\n<p>it doesn't follow that <code>not b = True</code>.</p>\n<blockquote>\n<p>Also I do think that a syntax which is aware of intention as it is available not only in Haskell but also in Python is preferable</p>\n</blockquote>\n<p>I am assuming you mean \"indentation\", though intention-aware syntax would be even better :) . We are embracing light indentation awareness in Lean 4 (in the sense that no one should accidentally be able to get it wrong), but full-on awareness a la Haskell has always struck me as far too controversial and confusing for beginners to copy. Indentation should help people, not hinder them.</p>",
        "id": 211056586,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1600892163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211056586\">said</a>:</p>\n<blockquote>\n<p>I would find that quite misleading - pattern matching equations are <em>not</em> identical to the definitional equations of a function because of their sequential semantics.</p>\n</blockquote>\n<p>Agda warns in this case (if an equation is not definitional) and has an option to forbid it outright.</p>",
        "id": 211056984,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1600892393
    },
    {
        "content": "<p>Then I'll gladly take the more concise syntax. Lean is trying to be a programming language as well after all.</p>",
        "id": 211057288,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1600892531
    },
    {
        "content": "<blockquote>\n<p>We are embracing light indentation awareness in Lean 4 (in the sense that no one should accidentally be able to get it wrong)</p>\n</blockquote>\n<p>Could you elaborate? AFAIK in lean 3 the only indentation awareness is the relatively recent addition of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">file</span>\n<span class=\"n\">user_cmd</span>\n</code></pre></div>\n\n<p>vs</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">file</span>\n <span class=\"n\">another_file</span>\n</code></pre></div>",
        "id": 211059002,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600893460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211057288\">said</a>:</p>\n<blockquote>\n<p>Then I'll gladly take the more concise syntax. Lean is trying to be a programming language as well after all.</p>\n</blockquote>\n<p>Oh yeah absolutely. I think Lean's pattern matching syntax is pretty much a straight upgrade over Agda's. No need to repeat a function name <code>n</code> times.</p>",
        "id": 211059961,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1600893873
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Right now it's that</p>\n<ul>\n<li>all <code>match</code> branches need to have the same indentation level</li>\n<li>all <code>do</code> and tactic block items (of a single block) need to have the same indentation level</li>\n</ul>\n<p>See e.g. <a href=\"https://github.com/leanprover/lean4/blob/6fe8a0e1793a2e75ca6c655fee8e6d090c2dc370/src/Init/Core.lean#L1139-L1142\">https://github.com/leanprover/lean4/blob/6fe8a0e1793a2e75ca6c655fee8e6d090c2dc370/src/Init/Core.lean#L1139-L1142</a></p>",
        "id": 211101861,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1600935930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211056586\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271218\">Thorsten Altenkirch</span> <a href=\"#narrow/stream/113488-general/topic/what.20is.20the.20name.20of.20.2B.3F/near/211034875\">said</a>:</p>\n<blockquote>\n<p>For example the syntax of pattern matching is weird, why not writing the definitional equations you mean</p>\n</blockquote>\n<p>I would find that quite misleading - pattern matching equations are <em>not</em> identical to the definitional equations of a function because of their sequential semantics. If I write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">not</span> <span class=\"n\">True</span> <span class=\"bp\">=</span> <span class=\"n\">False</span>\n<span class=\"n\">not</span> <span class=\"n\">b</span>    <span class=\"bp\">=</span> <span class=\"n\">True</span>\n</code></pre></div>\n\n<p>it doesn't follow that <code>not b = True</code>.</p>\n<blockquote>\n<p>Also I do think that a syntax which is aware of intention as it is available not only in Haskell but also in Python is preferable</p>\n</blockquote>\n<p>I am assuming you mean \"indentation\", though intention-aware syntax would be even better :) . We are embracing light indentation awareness in Lean 4 (in the sense that no one should accidentally be able to get it wrong), but full-on awareness a la Haskell has always struck me as far too controversial and confusing for beginners to copy. Indentation should help people, not hinder them.</p>\n</blockquote>\n<p>You would get a warning in agda.</p>",
        "id": 211105408,
        "sender_full_name": "Thorsten Altenkirch",
        "timestamp": 1600938420
    }
]
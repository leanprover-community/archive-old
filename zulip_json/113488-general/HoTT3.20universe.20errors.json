[
    {
        "content": "<p>I started to port my Lean2 - HoTT files to HoTT3, but run almost immediately into trouble:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">hott</span><span class=\"bp\">.</span><span class=\"n\">init</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n<span class=\"n\">hott_theory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">hott</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">hott</span><span class=\"o\">,</span> <span class=\"n\">hsimp</span><span class=\"o\">,</span> <span class=\"kn\">reducible</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">id</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">hott</span><span class=\"o\">,</span> <span class=\"n\">hsimp</span><span class=\"o\">,</span> <span class=\"kn\">reducible</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">id_map</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"n\">A</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">hott</span><span class=\"o\">]</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">id_map_is_right_neutral</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">map</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"n\">id_map</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">hsimp</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">hott</span>\n</code></pre></div>\n\n\n<p>says <code>goals accomplished</code> at the last <code>}</code> but attaches a problem to the equality sign in <code>id_map_is_right_neutral</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">kernel</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">type</span> <span class=\"kn\">check</span> <span class=\"n\">declaration</span> <span class=\"err\">&#39;</span><span class=\"n\">id_map_is_right_neutral&#39;</span> <span class=\"n\">this</span> <span class=\"n\">is</span> <span class=\"n\">usually</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">a</span> <span class=\"n\">buggy</span> <span class=\"n\">tactic</span> <span class=\"n\">or</span> <span class=\"n\">a</span> <span class=\"n\">bug</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">builtin</span> <span class=\"n\">elaborator</span>\n<span class=\"n\">elaborated</span> <span class=\"n\">type</span><span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"err\">↥</span><span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">map</span> <span class=\"err\">∘</span> <span class=\"n\">id_map</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">map</span>\n<span class=\"n\">elaborated</span> <span class=\"n\">value</span><span class=\"o\">:</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"err\">↥</span><span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">cast</span> <span class=\"n\">idp</span><span class=\"bp\">⁻¹</span> <span class=\"n\">rfl</span>\n<span class=\"n\">nested</span> <span class=\"n\">exception</span> <span class=\"n\">message</span><span class=\"o\">:</span>\n<span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"bp\">@</span><span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"err\">↥</span><span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"err\">↥</span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"err\">↥</span><span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"err\">↥</span><span class=\"n\">B</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u_1</span> <span class=\"n\">u_2</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">u_3</span>\n</code></pre></div>\n\n\n<p>I never understand these universe error messages. Why is <code>↥A → ↥B</code> expected to have type <code>Type u_3</code>? Why can't <code>u_3</code> be unified with <code>max u_1 u_2</code>? You get more or less the same message when replacing <code>exact rfl</code> by <code>exact @hott.eq.refl (A -&gt; B) map</code>. I also wonder why you can't use <code>reflexivity</code> for <code>hott.eq</code>.</p>",
        "id": 208430836,
        "sender_full_name": "Thomas Eckl",
        "timestamp": 1598703282
    },
    {
        "content": "<p>I also have some fundamental questions about the implementation of HoTT in Lean 3: Why can't you just check whether terms use objects of type <code>Prop</code> in their construction? Isn't that the only way how HoTT and Lean 3 can produce contradiction?</p>",
        "id": 208430921,
        "sender_full_name": "Thomas Eckl",
        "timestamp": 1598703468
    },
    {
        "content": "<p>The error happens, as the error message explains, because the tactic is probably buggy (because it generates an incorrect proof term).  But I don't have time to debug that right now.  Feel free to file an issue though.</p>",
        "id": 208434181,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1598707949
    },
    {
        "content": "<p>You can definitely use <code>reflexivity</code> for <code>hott.eq</code>, we use it all over the place.  If it doesn't work here, then that might be related to same issue as above.</p>",
        "id": 208434216,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1598708028
    },
    {
        "content": "<blockquote>\n<p>Why can't you just check whether terms use objects of type Prop in their construction?</p>\n</blockquote>\n<p>That is, very generally speaking, exactly what the <code>@[hott]</code> attribute does.  It is a bit more permissive though, it allows everything except <code>eq.rec</code>, <code>acc.rec</code>, <code>heq.rec</code> and <code>choice</code> (those are the only recursors/axioms that produce something outside of Prop).</p>",
        "id": 208434378,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1598708171
    },
    {
        "content": "<p>My guess would be the bug in the builtin elaborator, because the issue remains when you replace <code>by ...</code> with <code>sorry</code>. Is it then a Lean 3 problem?</p>",
        "id": 208450732,
        "sender_full_name": "Thomas Eckl",
        "timestamp": 1598730492
    },
    {
        "content": "<p>This is strange. I have minimized the problem, and here is a code snippet that fails in the latest version of Lean, without using anything HoTT-specific:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">-- set_option trace.elaborator_detail true</span>\n\n<span class=\"n\">def</span> <span class=\"n\">my_eq</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">id_map_is_right_neutral</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_eq</span> <span class=\"o\">(</span><span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"bp\">_</span><span class=\"o\">}</span> <span class=\"n\">map</span> <span class=\"n\">map</span><span class=\"o\">)</span> <span class=\"n\">map</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 208458556,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1598742541
    },
    {
        "content": "<p>Does changing <code>Type*</code> to <code>Type u</code> help?</p>",
        "id": 208458703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598742783
    },
    {
        "content": "<p>no (changing it to <code>Type</code>/<code>Sort*</code>/<code>Sort u</code> does)</p>",
        "id": 208459154,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1598743517
    },
    {
        "content": "<p>It is strange that <span class=\"user-mention\" data-user-id=\"126734\">@Thomas Eckl</span> runs into this problem, but apparently it wasn't a problem for the rest of the HoTT library.</p>",
        "id": 208459225,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1598743663
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"n\">def</span> <span class=\"n\">my_eq</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">id_map_is_right_neutral</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">maap</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">my_eq</span> <span class=\"o\">(</span><span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">maap</span> <span class=\"n\">maap</span><span class=\"o\">)</span> <span class=\"n\">maap</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span>\n</code></pre></div>\n\n\n<p>-&gt;</p>\n<div class=\"codehilite\"><pre><span></span><code>kernel failed to type check declaration &#39;id_map_is_right_neutral&#39; this is usually due to a buggy tactic or a bug in the builtin elaborator\nelaborated type:\n  ∀ {A : Type} (maap : A → A), my_eq (maap ∘ maap) maap\nelaborated value:\n  λ {A : Type} (maap : A → A), trivial\nnested exception message:\ntype mismatch at application\n  @my_eq (A → A)\nterm\n  A → A\nhas type\n  Type\nbut is expected to have type\n  Type u_1\n</code></pre></div>\n\n\n<p>Interesting!</p>",
        "id": 208459269,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598743726
    },
    {
        "content": "<p>I've got the same error message when stating the universal property of injective maps (of sets):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">hott</span><span class=\"o\">]</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">univ_prop_of_inj</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i_inj</span> <span class=\"o\">:</span> <span class=\"n\">is_set_injective</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"err\">∘</span> <span class=\"n\">g</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>I hope <code>is_set_injective</code> is self-explaining, but you can produce the error message also by omitting the parameter<code>i_inj</code>.<br>\nThe scientist in me immediately induces from these two observations that the problem might be related to the composition of functions. Hovering over the <code>∘</code> shows that composition is taken from the general Lean3 library (<code>init.function</code>), not from HoTT3. And in Lean3, all the domains and codomains of the maps are sorts, not types - maybe that clashes with <code>=</code> of maps between types?</p>\n<p>Since I did not find a definition of <code>∘</code> in <code>hott.init.function</code>, I guess it does not exist anywhere. Should it be added to <code>hott.init.function</code>?</p>",
        "id": 208715981,
        "sender_full_name": "Thomas Eckl",
        "timestamp": 1598979074
    },
    {
        "content": "<p>Just tried: Inserting in my file</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">function</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">inline</span><span class=\"o\">,</span> <span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">comp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">infixr</span>  <span class=\"bp\">`</span> <span class=\"err\">∘ʰ</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">80</span>      <span class=\"o\">:=</span> <span class=\"n\">hott</span><span class=\"bp\">.</span><span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">comp</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">function</span>\n</code></pre></div>\n\n\n<p>solves the problem. The new symbol is not perfect, but also not too bad ...</p>",
        "id": 208717905,
        "sender_full_name": "Thomas Eckl",
        "timestamp": 1598980029
    },
    {
        "content": "<p>Yes, it has to do with the interaction of <code>Sort</code> and <code>Type</code> between <code>hott.eq</code> and <code>function.comp</code>. I don't know why though, I feel like Lean should be able to figure it out. Moreover, Lean managed to figure out all the occurrences of composition in init.</p>",
        "id": 208718191,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1598980186
    },
    {
        "content": "<p>If in the <code>hott</code> namespace you write</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"n\">hott_theory_cmd</span> <span class=\"s2\">&quot;local infix ` ∘ ` := hott.function.comp&quot;</span>\n</code></pre></div>\n\n\n<p>then you override the notation <code>∘</code> to mean <code>hott.function.comp</code> (so you can use the same symbol)</p>",
        "id": 208718323,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1598980244
    }
]
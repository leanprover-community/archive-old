[
    {
        "content": "<p>Hi, I'm working through the \"Logical Verification\" course materials from VU. I'm working on the first exercises and came upon this section: <a href=\"https://github.com/blanchette/logical_verification_2022/blob/main/lean/love01_definitions_and_statements_exercise_sheet.lean#L29\">https://github.com/blanchette/logical_verification_2022/blob/main/lean/love01_definitions_and_statements_exercise_sheet.lean#L29</a><br>\n11 <code>#check</code> statements with instructions to mouse over each and check that the value is correct. Shopping around for other examples, I found the idea of changing each of the <code>#check</code> statements to a <code>lemma</code> proven using <code>refl</code>. So I can test the first line automatically like so:<br>\n<code>lemma test_sub00: sub 0 0 = 0 := rfl</code></p>",
        "id": 322862391,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674395852
    },
    {
        "content": "<p>Programmer that I am, I want to be able to put all of the test data into its own structure.</p>",
        "id": 322862505,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674395896
    },
    {
        "content": "<p>The idea behind data-driven testing is that you have one piece of testing logic that gets repeatedly applied to some list of cases. This gives you fewer points of potential bugs because you're not copy-pasting logic around.</p>",
        "id": 322862666,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674395967
    },
    {
        "content": "<p>I'm not sure how to proceed here, though; I moved all of the test cases into a list like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test_data</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">[[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">],</span>\n <span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">]]</span>\n</code></pre></div>",
        "id": 322862792,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396009
    },
    {
        "content": "<p>Note that those two are not the same. a lemma proved by <code>rfl</code> is evaluated by the kernel, while <code>#eval</code> evaluates in the interpreter/compiler. The latter is unverified but often much faster or even may succeed where the other fails</p>",
        "id": 322862810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396018
    },
    {
        "content": "<p>There isn't any particular reason to organize the tests beyond having a bunch of lemmas because lemma correctness is evaluated at compile time</p>",
        "id": 322862928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396074
    },
    {
        "content": "<p>Interesting. I guess that makes <code>#eval</code> doubly dangerous as a unit-test drop-in then, right?</p>",
        "id": 322862957,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396093
    },
    {
        "content": "<p>it depends on what you want to test</p>",
        "id": 322862977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396105
    },
    {
        "content": "<p>you can turn the eval into a test by evaluating something like <code>#eval guard (sub 0 0 = 0)</code></p>",
        "id": 322863082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396139
    },
    {
        "content": "<p>I forget the exact syntax but there are ways to set it up so that the eval line itself fails if the test is wrong, and this is still being evaluated at compile time</p>",
        "id": 322863202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396182
    },
    {
        "content": "<p>I don't see guard in the manual</p>",
        "id": 322863215,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396187
    },
    {
        "content": "<p>and it's giving me <code>don't know how to synthesize placeholder\ncontext:\n⊢ Type → Type ?</code></p>",
        "id": 322863392,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396251
    },
    {
        "content": "<p>for <code>#eval guard (sub 0 0 = 0)</code></p>",
        "id": 322863433,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396271
    },
    {
        "content": "<p>try <code>(guard ... : tactic unit)</code></p>",
        "id": 322863449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396275
    },
    {
        "content": "<p>I don't think the manual has an exhaustive list of functions, you are more likely to find it in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/guard\">docs#guard</a></p>",
        "id": 322863486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396299
    },
    {
        "content": "<p><code>#eval (guard (sub 0 0 = 0): tactic unit)</code> works :) Thanks. So guard is like an assert statement.</p>",
        "id": 322863607,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396356
    },
    {
        "content": "<p>yeah</p>",
        "id": 322863626,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396362
    },
    {
        "content": "<p>Okay, so back to the list-based one...</p>",
        "id": 322863692,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396380
    },
    {
        "content": "<p>this is like <code>static_assert</code> in C++, not sure what your background is</p>",
        "id": 322863700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396384
    },
    {
        "content": "<p>Cool, makes sense</p>",
        "id": 322863745,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396398
    },
    {
        "content": "<p>I'm not sure what the numbers represent</p>",
        "id": 322863777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396412
    },
    {
        "content": "<p>I'm really brand new at lean</p>",
        "id": 322863787,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396417
    },
    {
        "content": "<p>Right, so the idea is that I want to take the arguments and expected output for each test case and put them together ina collection</p>",
        "id": 322863840,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396441
    },
    {
        "content": "<p>I don't really like list for this, but it was the only thing I could get to compile</p>",
        "id": 322863923,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396471
    },
    {
        "content": "<p>I would rather have tuples of a pre-defined length, or an object/struct with named fields</p>",
        "id": 322864057,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396501
    },
    {
        "content": "<p>But the idea here is that I want to do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">for</span> <span class=\"n\">case</span> <span class=\"k\">in</span> <span class=\"n\">test_data</span>\n    <span class=\"n\">assert</span> <span class=\"n\">sub</span> <span class=\"n\">case</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"n\">case</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">case</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 322864167,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396554
    },
    {
        "content": "<p>I think this would work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test_data</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">[(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">),</span>\n <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">)]</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n  <span class=\"n\">test_data.mmap'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">⟩,</span> <span class=\"n\">guard</span> <span class=\"o\">(</span><span class=\"n\">sub</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 322864358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396623
    },
    {
        "content": "<p>untested as I don't have a lean 3 on hand</p>",
        "id": 322864400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396645
    },
    {
        "content": "<p>Ah, that's how you make tuples!</p>",
        "id": 322864439,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396664
    },
    {
        "content": "<p>intuitive. Just couldn't find it by searching</p>",
        "id": 322864471,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396682
    },
    {
        "content": "<p>the underlying function this is notation for is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.mk\">docs#prod.mk</a></p>",
        "id": 322864498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396701
    },
    {
        "content": "<p>Cool, this works. Thank you!</p>",
        "id": 322864619,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396746
    },
    {
        "content": "<p>There is one issue...</p>",
        "id": 322864628,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396751
    },
    {
        "content": "<p>Not sure if it can be fixed</p>",
        "id": 322864648,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396763
    },
    {
        "content": "<p>but if you change one of the test cases so that it fails</p>",
        "id": 322864678,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396779
    },
    {
        "content": "<p>Lean just underlines the <code>#eval</code> and says \"fail\". No info on which case failed or how it failed.</p>",
        "id": 322864714,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674396805
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n  <span class=\"n\">test_data.mmap'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">guard</span> <span class=\"o\">(</span><span class=\"n\">sub</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">\"sub {a} {b} wasn't {c}, it was {sub a b}\"</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 322864781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674396840
    },
    {
        "content": "<p>Do I need to import <code>fail</code> from somewhere?</p>",
        "id": 322865608,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674397260
    },
    {
        "content": "<p>I get <code>unknown identifier 'fail'</code></p>",
        "id": 322865992,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674397425
    },
    {
        "content": "<p><code>tactic.fail</code> maybe</p>",
        "id": 322866247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674397545
    },
    {
        "content": "<p>or <code>open tactic</code> beforehand</p>",
        "id": 322866396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674397596
    },
    {
        "content": "<p><code>tactic.fail</code> works!</p>",
        "id": 322866416,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674397605
    },
    {
        "content": "<p><code>guard</code> uses <code>failure</code>, which doesn't take a message argument</p>",
        "id": 322866444,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674397618
    },
    {
        "content": "<p>Okay so one last question</p>",
        "id": 322866472,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674397625
    },
    {
        "content": "<p>If I want to re-use this logic</p>",
        "id": 322866501,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674397633
    },
    {
        "content": "<p>can I put this in a function that takes <code>sub</code> (or other binary function) as an argument?</p>",
        "id": 322866659,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674397693
    },
    {
        "content": "<p>I'm just unsure about <code>#eval</code>, because it's compile time... will I hit a wall somewhere because some things cannot be computed at compile-time, or is everything computable at compile-time?</p>",
        "id": 322866761,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674397747
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">test_binop</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_to_format</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_to_format</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_to_format</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">test_data</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">test_data.mmap'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">guard</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">\"{name} {a} {b} wasn't {c}, it was {f a b}\"</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">test_binop</span> <span class=\"s2\">\"sub\"</span> <span class=\"n\">sub</span>\n  <span class=\"o\">[(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">),</span>\n   <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">5</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>still untested</p>",
        "id": 322867041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674397862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311255\">Nathan Glenn</span> <a href=\"#narrow/stream/113488-general/topic/data-driven.20unit.20tests/near/322866761\">said</a>:</p>\n<blockquote>\n<p>I'm just unsure about <code>#eval</code>, because it's compile time... will I hit a wall somewhere because some things cannot be computed at compile-time, or is everything computable at compile-time?</p>\n</blockquote>\n<p>No, basically everything that lean can evaluate it can also run in the interpreter</p>",
        "id": 322867129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674397917
    },
    {
        "content": "<p>There are some things that cannot be evaluated, these are marked <code>noncomputable</code>, but you can't run them at run time either. (You can use them in <code>rfl</code> proofs however, although usually that won't work either, depending on how the function is defined.)</p>",
        "id": 322867335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674398002
    },
    {
        "content": "<p>stuff like \"use the axiom of choice to pick an even number\" is not computable</p>",
        "id": 322867467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674398062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/data-driven.20unit.20tests/near/322867129\">said</a>:</p>\n<blockquote>\n<p>No, basically everything that lean can evaluate it can also run in the interpreter</p>\n</blockquote>\n<p>This is something you will notice that is unusual about lean compared to other programming languages - almost everything is done at compile time, and in many cases compiling a lean file already extracts all the benefit we intend to get out of the file, for example if it contains a bunch of theorems then those theorems can't be run, their only purpose is to be compiled and typechecked in order to prove the theorem</p>",
        "id": 322867876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674398292
    },
    {
        "content": "<p>taking me a moment to parse this...</p>",
        "id": 322868243,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674398429
    },
    {
        "content": "<p>I get <code>invalid definition, it uses untrusted declaration 'has_to_format'</code> for the code you pasted</p>",
        "id": 322868384,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674398497
    },
    {
        "content": "<p>I also tried this less general version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test_binary</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">data</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">data.mmap'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">guard</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">tactic.fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">\"{name} {a} {b} wasn't {c}, it was {f a b}\"</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And it gives me <code>invalid definition, it uses untrusted declaration 'tactic'</code></p>",
        "id": 322868850,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674398733
    },
    {
        "content": "<p>use <code>meta def</code> instead of <code>def</code></p>",
        "id": 322869413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674398960
    },
    {
        "content": "<p><span aria-label=\"magic\" class=\"emoji emoji-1fa84\" role=\"img\" title=\"magic\">:magic:</span></p>",
        "id": 322869768,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674399106
    },
    {
        "content": "<p>Thanks :D</p>",
        "id": 322869783,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674399114
    },
    {
        "content": "<p>I've found the programming_in_lean document, so I'll give that a read-through.</p>",
        "id": 322870139,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674399276
    },
    {
        "content": "<p>Follow-up question regarding abstracting over attributes in Lean</p>",
        "id": 322899605,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674416298
    },
    {
        "content": "<p>I'm on to the homework assignment, and this time I need to test that a <code>reverse</code> function works properly.</p>",
        "id": 322899642,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674416329
    },
    {
        "content": "<p>Reverse is defined like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">reverse</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>        <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">reverse</span> <span class=\"n\">xs</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 322899668,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674416350
    },
    {
        "content": "<p>And I've adapted your test_binop code for a unary function like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">test_unary_op</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_to_format</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_to_format</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">test_data</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">test_data.mmap'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">guard</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">tactic.fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">\"{name} {a} wasn't {b}, it was {f a}\"</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 322899713,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674416390
    },
    {
        "content": "<p>Now, I can test with a list containing one type, no problem: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">test_unary_op</span> <span class=\"s2\">\"reverse\"</span> <span class=\"n\">reverse</span>\n  <span class=\"o\">[(([]</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">[]),</span> <span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">])]</span>\n</code></pre></div>",
        "id": 322899796,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674416426
    },
    {
        "content": "<p>But I would love to be able to try this with multiple list types at once, like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">test_unary_op</span> <span class=\"s2\">\"reverse\"</span> <span class=\"n\">reverse</span>\n  <span class=\"o\">[(([</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">])),</span> <span class=\"o\">([</span><span class=\"s2\">\"h\"</span><span class=\"o\">,</span><span class=\"s2\">\"e\"</span><span class=\"o\">,</span><span class=\"s2\">\"l\"</span><span class=\"o\">,</span><span class=\"s2\">\"l\"</span><span class=\"o\">,</span><span class=\"s2\">\"o\"</span><span class=\"o\">],[</span><span class=\"s2\">\"o\"</span><span class=\"o\">,</span> <span class=\"s2\">\"l\"</span><span class=\"o\">,</span><span class=\"s2\">\"l\"</span><span class=\"o\">,</span><span class=\"s2\">\"e\"</span><span class=\"o\">,</span><span class=\"s2\">\"h\"</span><span class=\"o\">])]</span>\n</code></pre></div>",
        "id": 322899832,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674416467
    },
    {
        "content": "<p>This code gives me \"failed to synthesize type class\", because it can't tell what type of list I'm giving it (the tuples have multiple types). But for the purposes of testing, all that matters to me is that each tuple has a consistent type among its elements. For the entire list, all I care about is that all each of the tuples satisfies <code>decidable_eq</code>. Is it possible to model this?</p>",
        "id": 322899973,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674416560
    },
    {
        "content": "<p>You can use a list of sigma types</p>",
        "id": 322905712,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674420256
    },
    {
        "content": "<p>But that turns out to be really annoying to write, especially since you have decidability constraints to encode.</p>",
        "id": 322906388,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674420728
    },
    {
        "content": "<p>Why do you need this? Why not just write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">do</span>\n    <span class=\"n\">test_unary_op</span> <span class=\"s2\">\"reverse\"</span> <span class=\"n\">reverse</span> <span class=\"o\">(([</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">])),</span>\n    <span class=\"n\">test_unary_op</span> <span class=\"s2\">\"reverse\"</span> <span class=\"n\">reverse</span> <span class=\"o\">([</span><span class=\"s2\">\"h\"</span><span class=\"o\">,</span><span class=\"s2\">\"e\"</span><span class=\"o\">,</span><span class=\"s2\">\"l\"</span><span class=\"o\">,</span><span class=\"s2\">\"l\"</span><span class=\"o\">,</span><span class=\"s2\">\"o\"</span><span class=\"o\">],[</span><span class=\"s2\">\"o\"</span><span class=\"o\">,</span> <span class=\"s2\">\"l\"</span><span class=\"o\">,</span><span class=\"s2\">\"l\"</span><span class=\"o\">,</span><span class=\"s2\">\"e\"</span><span class=\"o\">,</span><span class=\"s2\">\"h\"</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 322906413,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674420766
    },
    {
        "content": "<p>\"need\" not so much, \"want\" is more like it. It's just the way I'm used to programming. The requirement that I can only test one type of list at a time is just awkward to me. This particular application happens to be really simple, but I'm not so sure I won't find a larger impediment to me later, so this seemed like a good time to ask how this is done. But I can wait until I get to sigma types in the tutorials.</p>",
        "id": 322906684,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674420996
    },
    {
        "content": "<p>I don't think sigma types are going to help you here</p>",
        "id": 322907513,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674421646
    },
    {
        "content": "<p>You're trying to generalize over a lot of things at once:</p>\n<ul>\n<li>Elements of the list</li>\n<li>Things which aren't lists at all</li>\n<li>Algorithms for printing a family of types</li>\n<li>Algorithms for deciding equality of a family of types</li>\n</ul>",
        "id": 322907677,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674421749
    },
    {
        "content": "<p>It can certainly be done:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Note: this only works if `f` places no requirements on the family of types</span>\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">test_unary_op</span>  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"o\">[</span><span class=\"n\">has_to_format</span> <span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">has_to_format</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"o\">[</span><span class=\"n\">has_to_format</span> <span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">has_to_format</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span>  <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">decidable_eq</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">test_data</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_to_format</span> <span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">α</span> <span class=\"n\">i</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">test_data.mmap'</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">h1</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">guard</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">tactic.fail</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">h2</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">\"{name} {a} wasn't {b}, it was {f _ a}\"</span><span class=\"o\">))</span>\n\n<span class=\"k\">#eval</span> <span class=\"bp\">@</span><span class=\"n\">test_unary_op</span> <span class=\"n\">list</span> <span class=\"n\">list</span>\n  <span class=\"c1\">-- typeclass inference can't handle this type of thing automatically</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">resetI</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">resetI</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">resetI</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span>\n  <span class=\"s2\">\"reverse\"</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">list.reverse</span><span class=\"o\">)</span>\n  <span class=\"o\">[⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span> <span class=\"o\">([</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">],</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">])⟩,</span>\n   <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span> <span class=\"o\">([</span><span class=\"s2\">\"h\"</span><span class=\"o\">,</span><span class=\"s2\">\"e\"</span><span class=\"o\">,</span><span class=\"s2\">\"l\"</span><span class=\"o\">,</span><span class=\"s2\">\"l\"</span><span class=\"o\">,</span><span class=\"s2\">\"o\"</span><span class=\"o\">],[</span><span class=\"s2\">\"o\"</span><span class=\"o\">,</span> <span class=\"s2\">\"l\"</span><span class=\"o\">,</span><span class=\"s2\">\"l\"</span><span class=\"o\">,</span><span class=\"s2\">\"e\"</span><span class=\"o\">,</span><span class=\"s2\">\"h\"</span><span class=\"o\">])⟩]</span>\n</code></pre></div>",
        "id": 322908056,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674422034
    },
    {
        "content": "<p>But the amount of boilerplate you have to write to fight lean make it not worth it</p>",
        "id": 322908116,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674422058
    },
    {
        "content": "<p>And even the above doesn't work if you want to test <code>reverse</code> on types in different universes</p>",
        "id": 322908124,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674422073
    },
    {
        "content": "<p>Probably a more reasonable option is to write a metaprogram to generate the repeative code I linked above</p>",
        "id": 322908269,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674422204
    },
    {
        "content": "<p>As an engineering professor who teaches test-driven design to my students learning Python, I thought I’d chime in.</p>\n<p>In Python, you write tests alongside your code to make sure it does what you want, to facilitate continuous integration, etc. A good programmer writes good, informative tests, but you’re limited to things like “check the output of this function is correct on inputs 5, 10, and 15.” What makes Lean unique is you can write proofs alongside your code, to essentially say “prove the output of this function is correct for all natural numbers, while also restricting the function to only accept natural numbers as input.” Lean checks all proofs at compile time, and in mathlib. I believe this paradigm is stronger than the old test-driven design paradigm.</p>\n<p>But, one gap in the proofs approach is, “even if I’ve defined an object and proved something about it, how can I be sure I e defined the right thing?” Our current answer to this is to use examples, see this blog post: <a href=\"https://leanprover-community.github.io/blog/posts/lte-examples/\">https://leanprover-community.github.io/blog/posts/lte-examples/</a> </p>\n<p>I don’t know if anyone has consolidated examples in a structure before with the intent on checking them along the lines of test driven development.</p>",
        "id": 322908761,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1674422601
    },
    {
        "content": "<p>I'm still brand-new to this, so it's really helpful to get your perspectives here. The code above is quite beyond my comprehension right now :D The point about constructing proofs being a better option than extensive tests is a good one. Thanks for the help!</p>",
        "id": 323141619,
        "sender_full_name": "Nathan Glenn",
        "timestamp": 1674519023
    }
]
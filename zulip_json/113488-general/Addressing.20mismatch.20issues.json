[
    {
        "content": "<p>I am working with a bunch of calculations with expressions that depend on fintype, and mismatch issues are happening. From what I understand, avoiding the mismatches arising is not feasible, but I'm looking for a non-painful way to handle them.</p>\n<p>Each individual mismatch can generally be handled with <code>convert rfl</code>,  and indeed sometimes this will kill the problems if there is more than one. But it can be hard to handle these issues when they occur in a complicated context and the pretty-printer makes differences invisible. For instance, suppose that <code>a</code> and <code>a'</code> are complicated expressions in <code>int</code>, indistinguishable without diving into implicit parameters, and hiding different <code>fintype</code> instances. Let <code>b</code> and <code>b'</code> be another such pair.  Now <code>a = a'</code> and <code>b = b'</code> can be proved with <code>convert rfl</code> (or maybe <code>congr'</code>), but how would I prove, say, that <code>-b + x + a + b' + y + z - a'  = x + y + z</code>, where <code>x</code>, <code>y</code> and <code>z</code> are themselves long and complicated enough that copy-pasting them into a proof would double its length? </p>\n<p>This is clearly possible, but quite awkard  in the middle of a proof. Of course, a proof somehow isomorphic to <code>rw [(by convert rfl : a = a'), (by convert rfl : b = b')], linarith</code> is what I would like. But I can't do this without hundreds of characters and underscores, because <code>a</code> and <code>a'</code> are syntactically identical! </p>\n<p>Unfortunately it is hard to come up with an mwe because the nature of my gripe is 'in a complicated context', but I hope I've communicated my question. </p>\n<p>(Of course, what I would really like is a way to seamlessly replace <code>fintype</code> with a similar typeclass that is purely propositional, in a way that doesn't involve remaking half the API from scratch, but I don't know how to do that, either).</p>",
        "id": 227039620,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613773636
    },
    {
        "content": "<p>If you can't rewrite with a lemma due to a mismatching fintypes instance, that usually means that the lemma is written badly, and only applies to a specific instance</p>",
        "id": 227052403,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613782229
    },
    {
        "content": "<p>I teach my mathematician students to use <code>set.finite</code> and [finite X] where none of these problems occur. I have no interest in constructive finiteness</p>",
        "id": 227052891,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613782630
    },
    {
        "content": "<p>oh apparently mathlib doesn't have <code>finite X</code> -- hard luck.</p>",
        "id": 227053440,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613783076
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> These issues sound quite similar to the issues that we have been facing in homological algebra. Where you have a complex of (say) vector spaces, indexed by <code>int</code> or <code>nat</code>. And now you fact the issues that <code>V i</code> is not the same vector space as <code>V (i - 1 + 1)</code>. Which is of course ridiculous. We are still experimenting to find the best solution.</p>",
        "id": 227073233,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613805284
    },
    {
        "content": "<p>But more on topic, I think that you provide another strong datapoint for the need of a propositional analogue of <code>fintype</code>.</p>",
        "id": 227073256,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613805315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> let's first get one thing clear -- are we talking about finite types, or finite subsets of types? We already have <code>set.finite</code> in mathlib, which is an \"I am finite\" predicate on a set which does not suffer from all the constructivist problems you're seeing.</p>",
        "id": 227097066,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613833971
    },
    {
        "content": "<p>We're talking about finite types. I'm not using finset directly at all, except where I'm being forced to. Here is some code - one of the problems occurs in the last lemma. </p>\n<p>(Related to the fact that I'm not using finset, what I'm trying to do here is to make the shorthand <code>∑ (a : X), f a</code> easier to work with, since most of the <code>finset.sum</code> API is instead written in terms of <code>∑ a in X, f a</code>.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"c1\">----------------------------------------------------------------</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">][</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">β</span><span class=\"o\">](</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">set.to_finset_insert'</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">X.to_finset</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">or_comm</span><span class=\"o\">]}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin_sum_eq</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n  <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">X.to_finset</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">↪</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">coe</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_injective</span><span class=\"o\">⟩</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">finset.sum_map</span> <span class=\"o\">(</span><span class=\"n\">finset.univ</span><span class=\"o\">)</span> <span class=\"n\">φ</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin_sum_insert</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}:</span>\n  <span class=\"n\">e</span> <span class=\"bp\">∉</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hdj</span> <span class=\"o\">:</span><span class=\"n\">disjoint</span> <span class=\"n\">X.to_finset</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.disjoint_iff_inter_eq_empty</span><span class=\"o\">],</span> <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset.not_mem_empty</span><span class=\"o\">,</span> <span class=\"n\">not_and</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_singleton</span><span class=\"o\">,</span> <span class=\"n\">iff_false</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_inter</span><span class=\"o\">,</span> <span class=\"n\">mem_to_finset</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">haX</span> <span class=\"n\">hae</span><span class=\"o\">,</span> <span class=\"n\">false.elim</span> <span class=\"o\">(</span><span class=\"n\">he</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rwa</span> <span class=\"bp\">←</span><span class=\"n\">hae</span><span class=\"o\">})),},</span>\n\n  <span class=\"c1\">-- this next claim causes instance mismatch problems if fin_sum_eq is invoked directly,</span>\n  <span class=\"c1\">-- due to two competing instances of fintype for X ∪ {e}</span>\n  <span class=\"k\">have</span> <span class=\"n\">hXe</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span><span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})</span> <span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">fin_sum_eq</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hXe</span><span class=\"o\">,</span> <span class=\"n\">fin_sum_eq</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">set.to_finset_insert'</span> <span class=\"n\">X</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_union</span> <span class=\"n\">hdj</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 227097531,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613834466
    },
    {
        "content": "<p>Why don't you just use finsets here? it shouldn't be hard to have analogues of all the sets you could want with <code>open_locale classical</code></p>",
        "id": 227097915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613834904
    },
    {
        "content": "<p>The <code>set</code> API is just more complete.</p>",
        "id": 227098209,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613835205
    },
    {
        "content": "<p>Only when it comes to equality of sets. The finset API is a lot more complete when it comes to summation; you can do the summation stuff on finsets and pull back to sets for the set algebra</p>",
        "id": 227098374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613835415
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">fin_sum_insert</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}:</span>\n  <span class=\"n\">e</span> <span class=\"bp\">∉</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">finite.of_fintype</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">exists_finset_coe</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">fin_sum_eq</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">finset.sum_insert</span><span class=\"o\">],</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">fin_sum_eq</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">congr'</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 227098783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613835880
    },
    {
        "content": "<p><code>set.to_finset</code> doesn't seem to have many lemmas about it, although it does have <code>mem_to_finset</code> which is why the <code>ext, simp</code> works</p>",
        "id": 227098892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613835983
    },
    {
        "content": "<p>so the trick is <code>exists_finset_coe</code>?</p>",
        "id": 227098907,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613836012
    },
    {
        "content": "<p>That's how you make everything use finsets</p>",
        "id": 227098943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613836047
    },
    {
        "content": "<p>Good to know - thanks!</p>",
        "id": 227099011,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613836107
    },
    {
        "content": "<p>Unfortunately it seems like the problem cascades. Here's an attempted consequence of the above where a mismatch issue carries forward, with either of our proofs of <code>fin_sum_insert</code>. The context is a little contrived - is is the problematic part of a proof by induction. The proof that works involves reducing to a case where a single <code>convert</code> resolves the goal, but rewriting earlier fails. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">subadditive</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"n\">X</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">Y</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)){</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">}{</span><span class=\"n\">X₀</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}(</span><span class=\"n\">hX₀</span> <span class=\"o\">:</span> <span class=\"n\">X₀</span> <span class=\"bp\">∉</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">subadditive</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">⋃₀</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"n\">X</span><span class=\"o\">):</span>\n  <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">⋃₀</span><span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">X₀</span><span class=\"o\">}))</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">X₀</span><span class=\"o\">})),</span> <span class=\"n\">g</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- rw fin_sum_insert g hX₀,</span>\n  <span class=\"c1\">-- Doesn't work</span>\n\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">sUnion_union</span><span class=\"o\">,</span> <span class=\"n\">sUnion_singleton</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hS</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n\n  <span class=\"n\">refine</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">int.add_le_add_right</span> <span class=\"n\">hS</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">X₀</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">le_of_eq</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">fin_sum_insert</span> <span class=\"n\">g</span> <span class=\"n\">hX₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- works</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 227100994,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613837358
    },
    {
        "content": "<p>So you can't use <code>S : finset (set \\a)</code>?</p>",
        "id": 227101170,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613837508
    },
    {
        "content": "<p>I probably could, but I would be worried that this will just move the problem further upwards. In the case I want to invoke, <code>S</code> has type <code>set (set \\a)</code> because it's a collection of equivalence classes, so I would have to use some type of equivalence between <code>set</code> and <code>finset</code> to get to <code>finset (set \\a)</code>.</p>",
        "id": 227101285,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613837635
    },
    {
        "content": "<p>Yes, that's <code>exists_finset_coe</code> as you saw</p>",
        "id": 227101844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613838177
    },
    {
        "content": "<p>or <code>set.to_finset</code></p>",
        "id": 227101853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613838187
    },
    {
        "content": "<p>So I guess you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">obtain</span> <span class=\"bp\">\\&lt;</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">\\&gt;</span> <span class=\"o\">:=</span> <span class=\"n\">exists_finset_coe</span> <span class=\"n\">S</span>\n</code></pre></div>\n<p>or something like that, as first line of the proof</p>",
        "id": 227101991,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613838328
    },
    {
        "content": "<p>Right, as Mario suggested upstairs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">finite.of_fintype</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">exists_finset_coe</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 227102011,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613838354
    },
    {
        "content": "<p>After that, the proof should be \"smooth\"</p>",
        "id": 227102059,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613838376
    },
    {
        "content": "<p>it wasn't completely smooth, there seem to be some missing simp lemmas</p>",
        "id": 227102075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613838403
    },
    {
        "content": "<p>Yeah, that last proof is something where I want things from both APIs at the same time.</p>",
        "id": 227102737,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613839108
    },
    {
        "content": "<p>of course, what I actually want is that <code>fintype</code> be propositional.</p>",
        "id": 227103036,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613839464
    },
    {
        "content": "<p>If you use <code>convert ... using 1</code>, does it show what doesn't match?</p>",
        "id": 227109003,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613845912
    },
    {
        "content": "<p>The first instance of <code>fintype ↥(S ∪ {X₀})</code> is this : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">subtype.fintype</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.decidable_mem</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">a</span><span class=\"o\">)))</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.fintype</span> <span class=\"n\">α</span> <span class=\"n\">_inst_1</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.fintype_pure</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">X₀</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and the second is this : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">set.fintype_union</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n     <span class=\"bp\">@</span><span class=\"n\">fintype.decidable_pi_fintype</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n       <span class=\"n\">_inst_1</span>\n       <span class=\"n\">a</span>\n       <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"n\">S</span>\n  <span class=\"o\">{</span><span class=\"n\">X₀</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">subtype.fintype</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">set.decidable_mem</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.fintype</span> <span class=\"n\">α</span> <span class=\"n\">_inst_1</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.fintype_pure</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">X₀</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 227114245,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613851350
    },
    {
        "content": "<p>Ah, so it's actually <code>decidable_eq</code> that is the culprit! The difference between the above is :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fintype.decidable_pi_fintype</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n<span class=\"n\">_inst_1</span>\n<span class=\"n\">a</span>\n<span class=\"n\">b</span>\n</code></pre></div>\n<p>vs </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">classical.prop_decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I don't know if that makes any of these problems easier to address....</p>",
        "id": 227114591,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613851630
    },
    {
        "content": "<p>What should propositional finiteness be called? <code>[is_finite alpha]</code>?</p>",
        "id": 227118320,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613855694
    },
    {
        "content": "<p>My assumption is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin_sum_insert\">docs#fin_sum_insert</a> is stated poorly</p>",
        "id": 227122813,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613859604
    },
    {
        "content": "<p>But that link doesn't work - where is that lemma?</p>",
        "id": 227122854,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613859624
    },
    {
        "content": "<p>It was proved earlier in this thread: <a href=\"#narrow/stream/113488-general/topic/Addressing.20mismatch.20issues/near/227098783\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Addressing.20mismatch.20issues/near/227098783</a></p>",
        "id": 227122949,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1613859732
    },
    {
        "content": "<p>Is there a full mwe?</p>",
        "id": 227123571,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613860344
    },
    {
        "content": "<p>I think the lemma needs <code>[fintype X]</code> and <code>[fintype (X \\union {e})]</code> to avoid this problem</p>",
        "id": 227123738,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613860512
    },
    {
        "content": "<p>This mwe is a union of things earlier, but here is all of it in one place: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"c1\">----------------------------------------------------------------</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">][</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">β</span><span class=\"o\">](</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">set.to_finset_insert'</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">X.to_finset</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">or_comm</span><span class=\"o\">]}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin_sum_eq</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n  <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">X.to_finset</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">↪</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">coe</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_injective</span><span class=\"o\">⟩</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">finset.sum_map</span> <span class=\"o\">(</span><span class=\"n\">finset.univ</span><span class=\"o\">)</span> <span class=\"n\">φ</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin_sum_insert</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}:</span>\n  <span class=\"n\">e</span> <span class=\"bp\">∉</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">finite.of_fintype</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">exists_finset_coe</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">fin_sum_eq</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">finset.sum_insert</span><span class=\"o\">],</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">fin_sum_eq</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">congr'</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">subadditive</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"n\">X</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">Y</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)){</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">}{</span><span class=\"n\">X₀</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}(</span><span class=\"n\">hX₀</span> <span class=\"o\">:</span> <span class=\"n\">X₀</span> <span class=\"bp\">∉</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">subadditive</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">⋃₀</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"n\">X</span><span class=\"o\">):</span>\n  <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">⋃₀</span><span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">X₀</span><span class=\"o\">}))</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">X₀</span><span class=\"o\">})),</span> <span class=\"n\">g</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">sUnion_union</span><span class=\"o\">,</span> <span class=\"n\">sUnion_singleton</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hS</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n\n  <span class=\"c1\">--would like to rw here with fin_sum_insert but can't.</span>\n\n  <span class=\"n\">refine</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">int.add_le_add_right</span> <span class=\"n\">hS</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">X₀</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">le_of_eq</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">fin_sum_insert</span> <span class=\"n\">g</span> <span class=\"n\">hX₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 227125108,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613861719
    },
    {
        "content": "<p>Thanks, I'll try my idea out myself tomorrow</p>",
        "id": 227125300,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613861919
    },
    {
        "content": "<p>Is this just not going to work because subadditive is defined in a classical context?</p>",
        "id": 227131817,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1613869857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Addressing.20mismatch.20issues/near/227123738\">said</a>:</p>\n<blockquote>\n<p>I think the lemma needs <code>[fintype X]</code> and <code>[fintype (X \\union {e})]</code> to avoid this problem</p>\n</blockquote>\n<p>Yes, this fixes it, in conjuction with removing <code>fintype α</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"c1\">----------------------------------------------------------------</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">β</span><span class=\"o\">](</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">set.to_finset_insert'</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})]:</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">X.to_finset</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">or_comm</span><span class=\"o\">]}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin_sum_eq</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">X.to_finset</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">↪</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">coe</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_injective</span><span class=\"o\">⟩</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">finset.sum_map</span> <span class=\"o\">(</span><span class=\"n\">finset.univ</span><span class=\"o\">)</span> <span class=\"n\">φ</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin_sum_insert</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})]:</span>\n  <span class=\"n\">e</span> <span class=\"bp\">∉</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n  <span class=\"n\">unfreezingI</span> <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">X'</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">finite.exists_finset_coe</span> <span class=\"o\">⟨‹</span><span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">›⟩</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">fin_sum_eq</span><span class=\"o\">,</span> <span class=\"n\">fin_sum_eq</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">finset.sum_insert</span><span class=\"o\">],</span>\n  <span class=\"o\">{</span> <span class=\"n\">congr'</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">subadditive</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"n\">X</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">Y</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">X₀</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">X₀</span><span class=\"o\">})]</span> <span class=\"o\">(</span><span class=\"n\">hX₀</span> <span class=\"o\">:</span> <span class=\"n\">X₀</span> <span class=\"bp\">∉</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">subadditive</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">⋃₀</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"n\">X</span><span class=\"o\">):</span>\n  <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">⋃₀</span><span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">X₀</span><span class=\"o\">}))</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">X₀</span><span class=\"o\">})),</span> <span class=\"n\">g</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">sUnion_union</span><span class=\"o\">,</span> <span class=\"n\">sUnion_singleton</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hS</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">fin_sum_insert</span> <span class=\"n\">_</span> <span class=\"n\">hX₀</span><span class=\"o\">,</span>  <span class=\"c1\">-- rw works</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 227171527,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613918184
    },
    {
        "content": "<p>You should never assume a more general <code>fintype</code> instance than the one the lemma actually requires and let the specific one be derived, because then the lemma won't match again terms which obtain the specific one via a different means</p>",
        "id": 227171548,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613918245
    },
    {
        "content": "<p>Thank you! What if I want to invoke <code>fin_sum_insert</code> in the middle of a larger proof where there is already a <code>fintype α</code> instance hanging around?</p>",
        "id": 227188243,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613935421
    },
    {
        "content": "<p>It should work fine</p>",
        "id": 227189118,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613936298
    },
    {
        "content": "<p>When you rewrite, the instances on the left-hand side of the eq / iff will already be present in the goal, while typeclass instances will try to deduce the ones on the right-hand-side</p>",
        "id": 227189176,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613936402
    },
    {
        "content": "<p>Ok. I've run into a curiosity that results from this solution when I'm applying it in an inductive proof. The below is the smallest example where I can reproduce the issue. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"c1\">----------------------------------------------------------------</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin_sum_empty</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∅</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset.sum_empty</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin_sum_eq</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)[</span><span class=\"n\">fintype</span> <span class=\"n\">X</span><span class=\"o\">]:</span>\n  <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">X.to_finset</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">↪</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">coe</span><span class=\"o\">,</span> <span class=\"n\">subtype.coe_injective</span><span class=\"o\">⟩</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">finset.sum_map</span> <span class=\"o\">(</span><span class=\"n\">finset.univ</span><span class=\"o\">)</span> <span class=\"n\">φ</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin_sum_insert</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">){</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}(</span><span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∉</span> <span class=\"n\">X</span><span class=\"o\">)[</span><span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">][</span><span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})]:</span>\n   <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfreezingI</span> <span class=\"o\">{</span><span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">X'</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">finite.exists_finset_coe</span> <span class=\"o\">⟨‹</span><span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">›⟩</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">fin_sum_eq</span><span class=\"o\">,</span> <span class=\"n\">fin_sum_eq</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">finset.sum_insert</span><span class=\"o\">],</span>\n  <span class=\"o\">{</span> <span class=\"n\">congr'</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">induction_foo</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">](</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">):</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">e</span> <span class=\"bp\">∉</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">}))</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fin_sum_one_eq_card</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">](</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">):</span>\n  <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">X.to_finset.card</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">revert</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">induction_foo</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">to_finset_card</span><span class=\"o\">,</span> <span class=\"n\">empty_card'</span><span class=\"o\">],</span> <span class=\"n\">convert</span> <span class=\"n\">fin_sum_empty</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n\n  <span class=\"n\">intros</span> <span class=\"n\">X</span> <span class=\"n\">e</span> <span class=\"n\">he</span> <span class=\"n\">hX</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- rw fin_sum_insert _ he,</span>\n  <span class=\"c1\">-- doesn't work</span>\n\n  <span class=\"n\">rw</span> <span class=\"n\">fin_sum_insert</span><span class=\"o\">,</span> <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n  <span class=\"c1\">--works</span>\n\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>In the proof of <code>fin_sum_one_eq_card</code>, I am able to rw with <code>fin_sum_insert</code> if I don't pass it the term <code>he</code>, but if I pass it <code>he</code>, the rewrite fails, even though <code>he</code> is exactly the term it needs, and resolving the goal later using <code>he</code> works fine . The <code>swap, assumption</code> handles this cleanly enough in practice, but I'd still like to understand what is happening, and can't figure it out.</p>",
        "id": 227189910,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613937142
    },
    {
        "content": "<p>I don't know the answer to your question, but <code>convert</code> works so it's some type class inference issue again. Independent of that, why have you got such a horrible <code>∑ (a : ↥X), 1 ↑a</code> term? Why not just some over <code>a \\in X</code>? Oh! Because it's not a finset :-( I think your fabulous questions are just indicating that we need some API. We solved this with <code>finsum_in</code> when we were doing finite groups: see <a href=\"https://github.com/ImperialCollegeLondon/group-theory-game/blob/152ec4a92ad67b6174a3d240c63fa56a6df6017e/src/finsum/basic.lean#L54\">here</a>.</p>",
        "id": 227190523,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613937820
    },
    {
        "content": "<p>I totally agree with you, all this constructive stuff is hard to work with but as you can see there are now sufficiently many experts around going \"no it's fine, just think about it this way and there's a trick\" that we've all just got used to it and learnt the tricks. Why not just write your own API and sorry it all out? <code>finsum_in</code> will solve all your problems. The proofs are just hacks to reduce everything to finset.sum and are very ugly but you don't care about those, you just reap the benefits.</p>",
        "id": 227190656,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613937957
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> I hesitated to introduce these new definitions because some people pointed out to me that the tools we have are enough for the job as long as you continually jump over the traps you're running into, and hence because such a nonconstructive approach is not strictly necessary (it all _can_ be done with what we have) I was just in danger of adding to the noise a la <a href=\"https://xkcd.com/927/\">xkcd#927</a>. However your situation I think just makes it clear that we need them. If this sort of stuff is deterring beginners then it's clear that there's an argument for it. I've suggested these before but here we go again:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_finite</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">finsum</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"c1\">-- zero if support infinite</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">finsum_in</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"c1\">-- zero if support intersect s is infinite</span>\n<span class=\"kd\">def</span> <span class=\"n\">fincard</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"c1\">-- zero if X is infinite</span>\n</code></pre></div>\n<p>Why don't you switch to these, sorry all the lemmas you need and feed them back, and we can just make the API? I've done it once before and it was quite fun, I just didn't get round to PR'ing it because some people weren't convinced this stuff was needed. In some sense they might be right -- jump through some hoops, use <code>convert</code> and woo-hoo, it's all computable! I am losing my patience with this approach.</p>",
        "id": 227191231,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613938511
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">intros</span> <span class=\"n\">X</span> <span class=\"n\">e</span> <span class=\"n\">he</span> <span class=\"n\">hX</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">fin_sum_insert</span> <span class=\"n\">_</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"c1\">-- this works</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">((</span><span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">to_finset.card</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"c1\">-- the goal!</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"c1\">-- stupid typeclass fail</span>\n</code></pre></div>",
        "id": 227191355,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613938634
    },
    {
        "content": "<p>With my approach there will be no up-arrows</p>",
        "id": 227191429,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613938698
    },
    {
        "content": "<p>I wonder if it is worthwhile just pr <a href=\"https://github.com/leanprover-community/mathlib/blob/fincard/src/data/fincard.lean#L91\">finsum</a>. All of the APIs are already done. I don't think too many standards is an issue if we can easily convert between the standards and I feel that this has come up often enough to warrant a separate definition.</p>",
        "id": 227194037,
        "sender_full_name": "Jason KY.",
        "timestamp": 1613941594
    },
    {
        "content": "<p>I like this idea. I do see the perspective of the more constructively inclined, and am even (on some level) enjoying how much these subtle issues  teach me about the language. I'm grateful for all the help, patience and expertise I've been getting here. </p>\n<p>However, I am planning to give a talk in the near future to fellows combinatorialists about how great/fun formalization is, and these types of problems are among the downsides on my mind. 'Traps' is the right word - none of the problems are insurmountable, but they are barriers to entry. Being someone very interested in theorems about finite structures, I suspect that this stuff happens more frequently for me than many others, and it would be good to have a solution that can be explained in terms an average mathematician can immediately understand. </p>\n<p>Regarding an API, I would love to have such a thing available in mathlib. Likely not much would be needed - I suspect the existing one is all I would need to work with.</p>",
        "id": 227196168,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613944038
    },
    {
        "content": "<p>A linter to catch the type of <code>decidable</code> / <code>fintype</code> instance problems I resolved above would likely help with avoiding some of these traps</p>",
        "id": 227199082,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613946130
    },
    {
        "content": "<p>Yes but I think the time has come now to do this -- and I'm about to sit down and do it -- because there are some people who simply never ever want to #eval anything and simply do not need the trouble which things like <code>fintype </code> and <code>finset.sum</code> can cause, especially if they open_locale classical on line 1 and then occasionally use types which have got decidable equality. It's just one extra hassle which doesn't need to be dealt with. Avigad told me that Isabelle has finsum and it works fine.</p>",
        "id": 227200100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613947327
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243312\">@Jason KY.</span> I'll put you as co-author, I'll do it on the discord.</p>",
        "id": 227200247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613947551
    },
    {
        "content": "<p>It's not just <code>#eval</code>, when it comes to facts about small matrices or something <code>dec_trivial</code> can sometimes be the most powerful tool at our disposal</p>",
        "id": 227208904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613956775
    },
    {
        "content": "<p>That's not a great situation, since that approach has a host of limitations, but it is what it is</p>",
        "id": 227208953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613956807
    },
    {
        "content": "<p>That said I'm in agreement on the introduction of <code>fincard</code> and <code>finsum</code> FWIW. There are just a lot of lemmas that are needed to make this nice - I found at least two or three in my proof above, regarding the interaction between <code>set.to_finset</code> and all of the finset API; with a finsum API we also need lemmas relating it to finset sum, and also copies of everything in the finset sum API.</p>",
        "id": 227209160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613957082
    },
    {
        "content": "<p>First attempt to make a <code>finsum</code> API is <a href=\"https://github.com/leanprover-community/mathlib/issues/6355\">#6355</a>. Many thanks to <span class=\"user-mention\" data-user-id=\"243312\">@Jason KY.</span> who did most of the work.</p>",
        "id": 227211278,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613959730
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> we don't make propositional finite types because we can just use <code>nonempty (fintype α)</code>. We don't do cardinality yet, that is some work we have prepared but haven't got into PR shape yet. This might take some time to get through the system.</p>",
        "id": 227211348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613959806
    },
    {
        "content": "<p>That sounds great - I look forward to tinkering tomorrow. </p>\n<p>Might there be a case for also adding <code>finmax</code> to the API? It is a special case of <code>finsum</code> (and could be defined as such), but API lemmas in which maxima are taken over subsets etc could be useful. Something I'm currently doing uses <code>fintype.exists_max</code> + choice  to define a maximum, and I haven't run into any mismatch issues so far, but who knows what will happen in the future.</p>",
        "id": 227212808,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613961386
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}[</span><span class=\"n\">linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">finmax</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- some default value if no max exists, otherwise the max</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finmax_is_max</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">][</span><span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">)](</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">finmax</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_argmax</span>  <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">][</span><span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">)](</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span>  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">finmax</span> <span class=\"n\">f</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>etc etc</p>",
        "id": 227213393,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613962074
    },
    {
        "content": "<p>That seems very near to what <code>supr</code> already does</p>",
        "id": 227213587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613962289
    },
    {
        "content": "<p>we just need a version of <code>supr</code> that works on any preorder</p>",
        "id": 227213673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613962375
    },
    {
        "content": "<p>The existence of an argmax following from (propositional) finiteness is what I'm after.  I can't see anything about finiteness in the <code>supr</code> API, but maybe I'm missing something?</p>",
        "id": 227213770,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613962472
    },
    {
        "content": "<p>finite lattices are complete</p>",
        "id": 227213778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613962488
    },
    {
        "content": "<p>Is there a <code>fintype</code> hiding there somewhere?</p>",
        "id": 227213863,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613962570
    },
    {
        "content": "<p>My point is that for the <code>finmax</code> function, you don't need any inputs except for <code>preorder B</code> and <code>nonempty A</code>, and it can be well defined whenever anything like it makes sense; you can then prove that it makes sense when A is finite to make use of it in your scenario</p>",
        "id": 227213907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613962671
    },
    {
        "content": "<p>there's no need to bake finiteness into the definition though</p>",
        "id": 227213955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613962694
    },
    {
        "content": "<p>actually <code>nonempty B</code> is probably better than <code>nonempty A</code> here, that way it can default to the zero of the codomain instead of a random value</p>",
        "id": 227214054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613962826
    },
    {
        "content": "<p><code>inhabited B</code> is probably better</p>",
        "id": 227214091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613962885
    },
    {
        "content": "<p>Ah, it looks like <code>set.finite.exists_maximal_wrt</code> already does what I want , without any <code>fintype</code>. Here it is: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">set.finite.exists_maximal_wrt</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">s.nonempty</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a'</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">a'</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a'</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Or not quite, but it's easy to get a <code>linear_order</code> version.</p>",
        "id": 227214319,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1613963124
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <span class=\"user-mention\" data-user-id=\"243312\">@Jason KY.</span>  I've started incorporating <code>finsum</code> into my project, as well as rolling my own <code>fincard</code> by finsumming ones (I'm assuming the intended implementation of <code>fincard</code> is more principled, but mine will do for now). It's great avoiding the mismatches, and what's more, not to have to regularly descend into finset coercion hell in the first place! </p>\n<p>I have a question about intended usage. For most of my interaction with <code>finsum</code>, everything will be happening with <code>variables {\\a : Type} [nonempty (fintype \\a)]</code> at the top of files. But this will mean that for each of the <code>finsum</code> and <code>finsum_in</code> lemmas that require explicit finiteness assumptions (which already each come in a few different flavours) , there will be yet another version that takes a nonempty fintype instance. For example, here are statements of a lemma I proved and its version that takes an instance. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">finsum_le_finsum</span> <span class=\"o\">[</span><span class=\"n\">ordered_add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">](</span><span class=\"n\">hfg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">function.support</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">)(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">function.support</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"o\">):</span>\n  <span class=\"bp\">∑ᶠ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑ᶠ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finsum_le_finsum'</span> <span class=\"o\">[</span><span class=\"n\">ordered_add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">][</span><span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">)]</span>\n<span class=\"o\">(</span><span class=\"n\">hfg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">):</span>\n  <span class=\"bp\">∑ᶠ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"bp\">∑ᶠ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Is doing this for every such lemma a reasonable solution? I can't even think of a good naming convention.</p>",
        "id": 228975133,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1614959363
    },
    {
        "content": "<p>I think the idea is you prove the different versions if you are writing APIs (e.g. your example) while if you are simply using <code>finsum</code> you can just stick to one version (or the most general version, i.e. the support is finite.). <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> suggest a naming scheme <a href=\"https://github.com/leanprover-community/mathlib/pull/6355#discussion_r579925163\">here</a></p>",
        "id": 228988888,
        "sender_full_name": "Jason KY.",
        "timestamp": 1614964168
    }
]
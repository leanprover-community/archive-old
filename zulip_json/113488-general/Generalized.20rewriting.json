[
    {
        "content": "<p>How can I get <code>rewrite</code> tactic working with a setoid? In Coq, I usually define an instance of <code>Setoid</code> and also add new morphisms with <code>Add Parametric Morphism</code>.  What am I supposed to do in Lean? I have defined an instance of <code>Setoid</code>, but when I'm trying to use rewrite tactic I get an error: <code>rewrite tactic failed, lemma is not an equality nor a iff state</code>.</p>",
        "id": 211513775,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1601309633
    },
    {
        "content": "<p>I'm not sure what feature you're looking for, but I don't think it exists.</p>",
        "id": 211514884,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601310200
    },
    {
        "content": "<p>I suspect the Lean equivalent is just to work with the quotient type.</p>",
        "id": 211515337,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601310446
    },
    {
        "content": "<p>Like Reid says, Lean does not support generalised rewriting a la Coq. Using a quotient instead of a setoid would probably be the idiomatic solution. If you don't want to do that, you'll have to reason with your equivalence relation directly, Agda-style.</p>",
        "id": 211515671,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1601310597
    },
    {
        "content": "<p>That is unfortunate, that generalized rewriting is not supported. However, I do not know how quotients work, they might be a better way of doing what I'm doing.</p>",
        "id": 211518252,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1601311795
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients\">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients</a><br>\nBasically, we never use <code>setoid</code> other than to form <code>quotient</code>s, and then I guess what Coq calls \"generalized rewriting\" just becomes ordinary rewriting.</p>",
        "id": 211521454,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601313214
    },
    {
        "content": "<p>And instead of proving theorems like <code>a ≈ b</code> I would rather prove <code>⟦a⟧ = ⟦b⟧</code>.</p>",
        "id": 211522009,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1601313438
    },
    {
        "content": "<p>I have done some quick testing and it seems to work as I would expect.</p>",
        "id": 211522067,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1601313467
    },
    {
        "content": "<p>Speaking only for myself, I prefer using quotients to using generalized rewriting. With quotients, when you define <code>f</code> in terms of a quotient type and if you look at the internal representation, you have to prove that it preserves the equivalence relation. Then, you can define <code>g</code> in terms of <code>f</code> and you don't have anything to prove unless you use the internals of the quotient. With generalized rewriting, you have to prove that both <code>f</code> and <code>g</code> are valid morphisms. The proof for <code>g</code> is easy but it still means that you need one proof per function that you use. I find quotients to be more modular.</p>",
        "id": 211523848,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1601314317
    },
    {
        "content": "<p>I got into a problem when I know that a function is a valid morphism but is not defined in terms of the quotient. I know that <code>⟦f y⟧ = ⟦z⟧</code>,  <code>⟦g x⟧ = ⟦y⟧ </code> and that <code>f</code> is a valid morphism. How can I easily prove that <code>⟦f (g x)⟧ = ⟦z⟧</code>?</p>\n<p>Complete example: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n<span class=\"kd\">constant</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n<span class=\"kd\">constant</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span>\n<span class=\"kd\">constant</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span>\n<span class=\"kd\">constant</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fy</span> <span class=\"o\">:</span> <span class=\"bp\">⟦</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"n\">z</span><span class=\"bp\">⟧</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">gx</span> <span class=\"o\">:</span> <span class=\"bp\">⟦</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"n\">y</span><span class=\"bp\">⟧</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">fmor</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟦</span><span class=\"n\">x</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"n\">y</span><span class=\"bp\">⟧</span> <span class=\"bp\">→</span> <span class=\"bp\">⟦</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"bp\">⟧</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fgx</span> <span class=\"o\">:</span> <span class=\"bp\">⟦</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"n\">z</span><span class=\"bp\">⟧</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">rewrite</span> <span class=\"n\">gx</span><span class=\"o\">,</span> <span class=\"c1\">-- how to get this working?</span>\n<span class=\"n\">rewrite</span> <span class=\"n\">fy</span><span class=\"o\">,</span>\n<span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211525182,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1601315015
    },
    {
        "content": "<p>Don't use <code>f</code> directly, but rather <code>quotient.map f</code></p>",
        "id": 211525344,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601315105
    },
    {
        "content": "<p>e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.quot</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n<span class=\"kd\">constant</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n<span class=\"kd\">constant</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span>\n<span class=\"kd\">constant</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span>\n<span class=\"kd\">constant</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fmor'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≈</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≈</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">f'</span> <span class=\"o\">:=</span> <span class=\"n\">quotient.map</span> <span class=\"n\">f</span> <span class=\"n\">fmor'</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fy</span> <span class=\"o\">:</span> <span class=\"n\">f'</span> <span class=\"bp\">⟦</span><span class=\"n\">y</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"n\">z</span><span class=\"bp\">⟧</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">gx</span> <span class=\"o\">:</span> <span class=\"bp\">⟦</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"n\">y</span><span class=\"bp\">⟧</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fgx</span> <span class=\"o\">:</span> <span class=\"n\">f'</span> <span class=\"bp\">⟦</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"bp\">⟧</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"n\">z</span><span class=\"bp\">⟧</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">rewrite</span> <span class=\"n\">gx</span><span class=\"o\">,</span>\n<span class=\"n\">rewrite</span> <span class=\"n\">fy</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 211525724,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601315293
    },
    {
        "content": "<p>I'm afraid that in my application this is not possible or very cumbersome, but I will think about it more.</p>",
        "id": 211525798,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1601315334
    },
    {
        "content": "<p>Generally we would work entirely with <code>f'</code> and wouldn't bother making <code>f</code> and <code>fmor'</code> into top-level definitions, unless they were rather complicated.</p>",
        "id": 211526085,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601315499
    },
    {
        "content": "<p>The problem is that I care about <code>f</code>. I really care about the actual representative, but usually prove theorems only about its equivalence class.</p>",
        "id": 211526702,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1601315789
    },
    {
        "content": "<p>I often work with functions like <code>(compose f (compose g h))</code>. When I want to prove something I would have to convert it to <code>(compose f' (compose g' h'))</code></p>",
        "id": 211526941,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1601315886
    },
    {
        "content": "<p>I'm really struggling with this. As an example I want to prove that <code>(f∘f∘f)[x] ≈ f[f[f[x]]]</code> by  subsequently applying <code>compose.app {...} : (f∘g)[x] ≈ f[g[x]]</code>. I would like the proof to be <code>repeat {rewrite compose.app}</code>, but I do not know how to do this. Currently I have to manually invoke transitivity of <code>≈</code> over <code>f[(f∘f)[x]])</code>.</p>\n<p>Complete example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">reserve</span> <span class=\"kd\">infixr</span> <span class=\"bp\">`</span> <span class=\"bp\">⟶</span> <span class=\"bp\">`</span> <span class=\"o\">:</span> <span class=\"mi\">50</span>\n<span class=\"kd\">reserve</span> <span class=\"kd\">infixr</span> <span class=\"bp\">`</span> <span class=\"bp\">×</span> <span class=\"bp\">`</span>  <span class=\"o\">:</span> <span class=\"mi\">60</span>\n<span class=\"kd\">reserve</span> <span class=\"kd\">infixr</span> <span class=\"bp\">`</span> <span class=\"bp\">∘</span> <span class=\"bp\">`</span>  <span class=\"o\">:</span> <span class=\"mi\">60</span>\n<span class=\"kd\">reserve</span> <span class=\"kd\">infix</span>  <span class=\"bp\">`</span> <span class=\"bp\">≅</span> <span class=\"bp\">`</span>  <span class=\"o\">:</span> <span class=\"mi\">26</span>\n\n<span class=\"c1\">--- Types</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">type</span>\n<span class=\"bp\">|</span> <span class=\"n\">sym</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">type</span>\n<span class=\"bp\">|</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"bp\">→</span> <span class=\"n\">type</span> <span class=\"bp\">→</span> <span class=\"n\">type</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">type.fspace</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">type.op</span> <span class=\"s2\">\"fspace\"</span> <span class=\"n\">X</span> <span class=\"n\">Y</span>\n<span class=\"kd\">infixr</span> <span class=\"bp\">⟶</span> <span class=\"o\">:=</span> <span class=\"n\">type.fspace</span>\n\n<span class=\"c1\">--- Expressions</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Expr</span> <span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">sym</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"n\">T</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Expr</span> <span class=\"n\">Y</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">f</span> <span class=\"o\">[</span> <span class=\"n\">x</span> <span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.app</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">type.coercion_to_Type</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"n\">has_coe_to_sort.mk</span> <span class=\"kt\">Type</span> <span class=\"n\">Expr</span>\n\n<span class=\"c1\">--- Equality: Postulate an existence of equality</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">ceq</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">infix</span> <span class=\"bp\">≅</span> <span class=\"o\">:=</span> <span class=\"n\">ceq</span>\n<span class=\"kd\">@[refl]</span>  <span class=\"kd\">axiom</span> <span class=\"n\">ceq.refl</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≅</span> <span class=\"n\">x</span>\n<span class=\"kd\">@[symm]</span>  <span class=\"kd\">axiom</span> <span class=\"n\">ceq.symm</span>  <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≅</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">≅</span> <span class=\"n\">x</span>\n<span class=\"kd\">@[trans]</span> <span class=\"kd\">axiom</span> <span class=\"n\">ceq.trans</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≅</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">≅</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">≅</span> <span class=\"n\">z</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ceq.iseqv</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">equivalence</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ceq</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">ceq.refl</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">ceq.symm</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">ceq.trans</span> <span class=\"kd\">end</span>\n<span class=\"kd\">instance</span> <span class=\"n\">type.setoid</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">setoid.mk</span> <span class=\"n\">ceq</span> <span class=\"n\">ceq.iseqv</span>\n\n<span class=\"c1\">--- Postulate function extensionality and all functions are proper</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">ceq.ext</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"bp\">⟶</span><span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">≈</span> <span class=\"n\">f'</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">])</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">≈</span> <span class=\"n\">f'</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">ceq.mor</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"bp\">⟶</span><span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≈</span> <span class=\"n\">x'</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">≈</span> <span class=\"n\">f'</span> <span class=\"bp\">→</span> <span class=\"n\">f</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">≈</span> <span class=\"n\">f'</span><span class=\"o\">[</span><span class=\"n\">x'</span><span class=\"o\">]</span>\n\n<span class=\"c1\">--- Composition combinator</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">compose</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">Expr.sym</span> <span class=\"o\">((</span><span class=\"n\">X</span><span class=\"bp\">⟶</span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">⟶</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"bp\">⟶</span><span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"bp\">⟶</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">⟶</span><span class=\"n\">Z</span><span class=\"o\">))</span> <span class=\"s2\">\"compose\"</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">compose</span><span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">][</span><span class=\"n\">f</span><span class=\"o\">]</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">compose.app</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"bp\">⟶</span><span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"bp\">⟶</span><span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">∘</span><span class=\"n\">g</span><span class=\"o\">)[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">≈</span> <span class=\"n\">f</span><span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]]</span>\n\n<span class=\"c1\">--- What I want to prove the following</span>\n\n<span class=\"kd\">lemma</span> <span class=\"kd\">example</span><span class=\"bp\">.</span><span class=\"n\">compose</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"bp\">⟶</span><span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">∘</span><span class=\"n\">f</span><span class=\"bp\">∘</span><span class=\"n\">f</span><span class=\"o\">)[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"bp\">≈</span> <span class=\"n\">f</span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]]]</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">ceq.trans</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">[(</span><span class=\"n\">f</span><span class=\"bp\">∘</span><span class=\"n\">f</span><span class=\"o\">)[</span><span class=\"n\">x</span><span class=\"o\">]])</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">apply</span> <span class=\"n\">compose.app</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">ceq.mor</span><span class=\"o\">,</span>\n<span class=\"n\">apply</span> <span class=\"n\">compose.app</span><span class=\"o\">,</span> <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">refl</span><span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">--- The ideal proof should be  \"repeat {rewrite compose.app}\"</span>\n</code></pre></div>",
        "id": 211787341,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1601483753
    },
    {
        "content": "<p><code>rw</code> only rewrites along equalities, not along general equivalence relations.</p>",
        "id": 211813787,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601496733
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#equiv_rw\">tactic#equiv_rw</a> (specifically for <code>equiv</code>s), but I've never used it before.</p>",
        "id": 211818543,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1601498985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Generalized.20rewriting/near/211813787\">said</a>:</p>\n<blockquote>\n<p><code>rw</code> only rewrites along equalities, not along general equivalence relations.</p>\n</blockquote>\n<p>I'm aware of this. My the problem is basically how can I state <code>(f∘f∘f)[x] ≈ f[f[f[x]]]</code> and <code>(f∘g)[x] ≈ f[g[x]]</code> with quotients and equalities such that the proof can be <code>repeat {rewrite compose.app}</code>.</p>",
        "id": 211880989,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1601540648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/113488-general/topic/Generalized.20rewriting/near/211818543\">said</a>:</p>\n<blockquote>\n<p>There is <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#equiv_rw\">tactic#equiv_rw</a> (specifically for <code>equiv</code>s), but I've never used it before.</p>\n</blockquote>\n<p>Nice, I will try that once I manage to install mathlib successfully.</p>",
        "id": 211881095,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1601540752
    },
    {
        "content": "<p>I hope it's okay to bring back this older thread, but I just want to make sure I understand: If I make an equivalence relation like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set</span> <span class=\"n\">data.stream</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">stream</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inf_word</span> <span class=\"o\">(</span><span class=\"n\">AP</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n<span class=\"n\">stream</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">AP</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">formulae</span> <span class=\"o\">(</span><span class=\"n\">AP</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">formulae</span>\n<span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">AP</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formulae</span>\n<span class=\"bp\">|</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"bp\">Φ₁</span> <span class=\"bp\">Φ₂</span> <span class=\"o\">:</span> <span class=\"n\">formulae</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formulae</span>\n<span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"bp\">Φ</span> <span class=\"o\">:</span> <span class=\"n\">formulae</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">formulae</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">words</span> <span class=\"o\">{</span><span class=\"n\">AP</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">Φ</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"n\">AP</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">inf_word</span> <span class=\"n\">AP</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"bp\">|</span> <span class=\"n\">true</span><span class=\"o\">}</span> <span class=\"c1\">-- in reality, set of words which satisfy Φ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_equiv</span> <span class=\"o\">{</span><span class=\"n\">AP</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">Φ</span> <span class=\"bp\">Ψ</span><span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"n\">AP</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">words</span> <span class=\"bp\">Φ</span> <span class=\"bp\">=</span> <span class=\"n\">words</span> <span class=\"bp\">Ψ</span>\n</code></pre></div>\n\n<p>and I want to be able to use <code>rw</code> on goals/hypotheses of the form <code>my_equiv Φ Ψ</code>, should I be registering  <code>formula</code> as a quotient?</p>\n<p>Or more precisely defining a quotient type over formula I guess</p>",
        "id": 214992627,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1603989030
    },
    {
        "content": "<p>yes, you define a quotient of <code>formula</code> and then use <code>rw</code> on the resulting type</p>",
        "id": 214993734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603989494
    },
    {
        "content": "<p>Great, thank you Mario!</p>",
        "id": 214993792,
        "sender_full_name": "Logan Murphy",
        "timestamp": 1603989526
    }
]
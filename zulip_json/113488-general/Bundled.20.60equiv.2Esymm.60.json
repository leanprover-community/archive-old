[
    {
        "content": "<p>Since <code>fun_like</code> seems to work out well, why not do the same for equivs? Well, it turns out it's hard to correctly deal with the <code>symm</code> maps. But after a couple days of tinkering, I think I have the solution: the <code>symm</code> maps should be bundled morphisms!</p>\n<p>For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A `symm_fun E E'` sends a bundled morphism in `E` to its two-sided inverse in `E'` -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">symm_fun</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">E'</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">fun_like</span> <span class=\"n\">E</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">B</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">fun_like</span> <span class=\"n\">E'</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">)]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">E'</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm_apply_apply'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">to_fun</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">apply_symm_apply'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">e</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"bp\">...</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">equiv.symm</span> <span class=\"o\">:</span> <span class=\"n\">symm_fun</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">≃</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">e.inv_fun</span><span class=\"o\">,</span> <span class=\"n\">e.to_fun</span><span class=\"o\">,</span> <span class=\"n\">e.right_inv</span><span class=\"o\">,</span> <span class=\"n\">e.left_inv</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">symm_apply_apply'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">e.left_inv</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_symm_apply'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">e.right_inv</span> <span class=\"n\">x</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">e</span> <span class=\"bp\">`⁻¹ₑ`</span><span class=\"o\">:</span><span class=\"mi\">1035</span> <span class=\"o\">:=</span> <span class=\"n\">equiv.symm</span> <span class=\"n\">e</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">apply_eq_iff_eq_symm_apply</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">⁻¹ₑ</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"n\">equiv.symm.apply_eq_iff_eq_symm_apply</span> <span class=\"n\">f</span>\n\n<span class=\"c1\">-- Copy over the lemmas to the `equiv` namespace for now, can be deleted later:</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">symm_apply_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">e</span><span class=\"bp\">⁻¹ₑ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">symm_fun.symm_apply_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">eq_symm_apply</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"bp\">⁻¹ₑ</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">e</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">symm_fun.eq_symm_apply</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">symm_symm</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">e.symm.symm</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">symm_fun.symm_symm</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>(Full code on <a href=\"https://github.com/leanprover-community/mathlib/tree/bundled-refl-symm-trans\">branch#bundled-refl-symm-trans</a>)</p>\n<p>The main drawback is that parsing of <code>e.symm x</code> is too hard since it has to insert two <code>coe_fn</code>s to resolve the dot notation correctly. My proposed solution is to add the <code>e ⁻¹ₑ</code> notation as in the code sample.</p>\n<p>What do you think? Have the bundled morphisms gone to my head?</p>",
        "id": 265007252,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639573896
    },
    {
        "content": "<p>Thanks to <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> and <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> for pushing me to do ... whatever this is.</p>",
        "id": 265007422,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639573971
    },
    {
        "content": "<p>Doesn't this prevent e.symm.symm = e from being rfl later, once eta expansion for defeq hits?</p>",
        "id": 265022157,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639580686
    },
    {
        "content": "<p><code>e.symm.symm = e</code> is not <code>rfl</code> unless you coerce both sides to functions.</p>",
        "id": 265023745,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1639581357
    },
    {
        "content": "<p>I think that we should have some kind of concrete category theory on top of <code>fun_like</code>.</p>",
        "id": 265023855,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1639581396
    },
    {
        "content": "<p>Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">fun_like.has_id</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fun_like</span> <span class=\"n\">F</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">B</span><span class=\"o\">)]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">id_apply</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">id</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 265024124,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1639581523
    },
    {
        "content": "<p>You mean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The class `has_id F A` states the bundled `A`-endomorphisms of type `I` include an</span>\n<span class=\"sd\">identity map `has_id.id`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_id</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fun_like</span> <span class=\"n\">I</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">id_apply</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">id</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">has_id</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fun_like</span> <span class=\"n\">I</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">has_id</span> <span class=\"n\">I</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kn\">include</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">coe_fn</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">_root_.id</span> <span class=\"o\">:=</span> <span class=\"n\">funext</span> <span class=\"o\">(</span><span class=\"n\">id_apply</span> <span class=\"n\">I</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">has_id</span>\n</code></pre></div>\n<p>:)</p>",
        "id": 265024245,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639581577
    },
    {
        "content": "<p>What if <code>symm</code> becomes a typeclass (defined as your structure but <code>E'</code> is an <code>out_param</code>)?</p>",
        "id": 265024292,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1639581595
    },
    {
        "content": "<p>Then we can have <code>has_symm</code>.</p>",
        "id": 265024457,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1639581646
    },
    {
        "content": "<p>I tried that, but <code>equiv</code> being <code>Sort</code>-typed makes the universe params slightly too hard to infer:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">has_id.id</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">α</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Sort</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Sort</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">imax</span> <span class=\"bp\">?</span> <span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">imax</span> <span class=\"bp\">?</span> <span class=\"bp\">?</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">imax</span> <span class=\"bp\">?</span> <span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">imax</span> <span class=\"bp\">?</span> <span class=\"bp\">?</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 265024806,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639581761
    },
    {
        "content": "<p>(The details of the error depend on whether I choose <code>Type u</code> or <code>Sort u</code> for <code>has_id</code>, but the error remains.)</p>",
        "id": 265024900,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639581793
    },
    {
        "content": "<p>I forgot about <code>Sort</code></p>",
        "id": 265024907,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1639581795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113488-general/topic/Bundled.20.60equiv.2Esymm.60/near/265024292\">said</a>:</p>\n<blockquote>\n<p>What if <code>symm</code> becomes a typeclass (defined as your structure but <code>E'</code> is an <code>out_param</code>)?</p>\n</blockquote>\n<p>This might work, I haven't looked into it too much because there's a <code>_root_.symm</code> confusing matters and I don't feel like manually replacing all the usages of <code>e.symm</code> with <code>(symm e)</code>.</p>",
        "id": 265025301,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639581933
    },
    {
        "content": "<p>I also tried a class as a predicate on <code>equiv.symm</code>, but that's too hard to infer (and doesn't work with <code>simp</code>) for basically the same reason as <code>is_ring_hom</code> is too hard.</p>",
        "id": 265025563,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639582034
    },
    {
        "content": "<p>Idea for the future: make <code>e.abc</code> look in <code>fun_like.abc</code> if <code>@{some_attr fun_like] def e_type := ...</code>, <code>e : e_type</code>.</p>",
        "id": 265025624,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1639582060
    }
]
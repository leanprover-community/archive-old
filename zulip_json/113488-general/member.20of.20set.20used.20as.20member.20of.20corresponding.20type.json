[
    {
        "content": "<p>I'm a bit unclear about working with sets which are coerced to types. For instance, I have a <code>finset</code> which can be coerced to a <code>set</code> which can be coerced to a <code>Type</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">finset_to_type</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"err\">↑</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>I'm interested in this because I have an inductive type which would ideally look like this :</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"k\">with</span> <span class=\"n\">Struct</span><span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n   <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fields</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">×</span> <span class=\"n\">PrimitiveType</span><span class=\"o\">)):</span>  <span class=\"n\">Struct</span> <span class=\"n\">name</span>\n</code></pre></div>\n\n\n<p>This won't compile, since the <code>PrimitiveType</code> is  being mutually inductively defined and therefore cannot be inside a non-inductive-type like <code>finset</code>. So instead I could just have some finite type of string keys and a map from those to values.</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"k\">with</span> <span class=\"n\">Struct</span><span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n   <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fields</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">vals</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">finset_to_type</span> <span class=\"n\">fields</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">PrimitiveType</span><span class=\"o\">):</span> <span class=\"n\">Struct</span> <span class=\"n\">name</span>\n</code></pre></div>\n\n\n<p>In order for me to actually use this, I need a function like the following:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">finset_str_map</span><span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">string</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">},</span>\n  <span class=\"o\">(</span><span class=\"n\">finset_to_type</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span>  <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span>\n    <span class=\"bp\">|</span> <span class=\"n\">s</span> <span class=\"n\">α</span> <span class=\"n\">f</span> <span class=\"n\">key</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">key</span> <span class=\"err\">∈</span> <span class=\"n\">s</span>\n      <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">has_lift</span><span class=\"o\">,</span>\n                        <span class=\"k\">have</span> <span class=\"n\">h&#39;</span><span class=\"o\">:</span> <span class=\"n\">key</span> <span class=\"err\">∈</span> <span class=\"err\">↑</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">sorry</span><span class=\"o\">},</span>\n                     <span class=\"c1\">-- I don&#39;t actually know what to do here</span>\n                       <span class=\"c1\">-- rw set.mem_def at h&#39;,</span>\n                       <span class=\"c1\">--rw set.has_coe_to_sort.coe ↑s at h&#39;,</span>\n                        <span class=\"c1\">--exact h&#39;</span>\n                         <span class=\"n\">sorry</span><span class=\"o\">}))</span>\n      <span class=\"k\">else</span> <span class=\"n\">none</span>\n</code></pre></div>\n\n\n<p>Is there a simple way to express that, if I have an element of a finite set, that I can treat it as a member of the corresponding type?</p>",
        "id": 205570946,
        "sender_full_name": "Kris Brown",
        "timestamp": 1596185987
    },
    {
        "content": "<p>MWE </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n  <span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">finset_to_type</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"err\">↑</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n  <span class=\"n\">mutual</span> <span class=\"kn\">inductive</span> <span class=\"n\">PrimType</span><span class=\"o\">,</span> <span class=\"n\">Struct</span>\n  <span class=\"k\">with</span> <span class=\"n\">PrimType</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n   <span class=\"bp\">|</span> <span class=\"n\">pBool</span><span class=\"o\">:</span>  <span class=\"n\">bool</span>  <span class=\"bp\">→</span> <span class=\"n\">PrimType</span>\n   <span class=\"bp\">|</span> <span class=\"n\">pInt</span><span class=\"o\">:</span>  <span class=\"bp\">ℤ</span>  <span class=\"bp\">→</span> <span class=\"n\">PrimType</span>\n   <span class=\"bp\">|</span> <span class=\"n\">pStruct</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">}:</span> <span class=\"n\">Struct</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">PrimType</span>\n  <span class=\"k\">with</span> <span class=\"n\">Struct</span><span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n   <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fields</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">vals</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">finset_to_type</span> <span class=\"n\">fields</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">PrimType</span><span class=\"o\">):</span> <span class=\"n\">Struct</span> <span class=\"n\">name</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">finset_str_map</span><span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">string</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">},</span>\n  <span class=\"o\">(</span><span class=\"n\">finset_to_type</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span>  <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">α</span>\n    <span class=\"bp\">|</span> <span class=\"n\">s</span> <span class=\"n\">α</span> <span class=\"n\">f</span> <span class=\"n\">key</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">key</span> <span class=\"err\">∈</span> <span class=\"n\">s</span>\n      <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">sorry</span><span class=\"o\">}))</span>\n      <span class=\"k\">else</span> <span class=\"n\">none</span>\n</code></pre></div>",
        "id": 205571668,
        "sender_full_name": "Kris Brown",
        "timestamp": 1596186619
    },
    {
        "content": "<p>To slightly <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> your problem, I suggest using two foralls instead of a function over the subtype in the mutual inductive. You can do something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">mutual</span> <span class=\"kn\">inductive</span> <span class=\"n\">PrimType</span><span class=\"o\">,</span> <span class=\"n\">Struct</span>\n<span class=\"k\">with</span> <span class=\"n\">PrimType</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">pBool</span> <span class=\"o\">:</span> <span class=\"n\">bool</span>  <span class=\"bp\">→</span> <span class=\"n\">PrimType</span>\n<span class=\"bp\">|</span> <span class=\"n\">pInt</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">PrimType</span>\n<span class=\"bp\">|</span> <span class=\"n\">pStruct</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">PrimType</span>\n<span class=\"k\">with</span> <span class=\"n\">Struct</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fields</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">vals</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">fields</span><span class=\"o\">,</span> <span class=\"n\">PrimType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span> <span class=\"n\">name</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">fields</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">},</span> <span class=\"n\">Struct</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">string</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">_</span> <span class=\"n\">f</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">vals</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">fields</span><span class=\"o\">),</span> <span class=\"n\">PrimType</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">v</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">PrimType</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">key</span> <span class=\"err\">∈</span> <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">fields</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">vals</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n</code></pre></div>",
        "id": 205573707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596188201
    },
    {
        "content": "<p>in the original question though you can replace the <code>by {sorry}</code> with <code>⟨key, h⟩</code></p>",
        "id": 205573840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596188315
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 205576255,
        "sender_full_name": "Kris Brown",
        "timestamp": 1596190302
    },
    {
        "content": "<p>Does this strategy make it impossible to show that two <code>Struct</code>s are decidably equal? The amount of data in the mapping is finite, but it looks like I have to prove equality for a function ranging over a (seemingly) infinite domain.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">mutual</span> <span class=\"n\">def</span> <span class=\"n\">primtype_eq</span><span class=\"o\">,</span> <span class=\"n\">struct_eq</span>\n<span class=\"k\">with</span> <span class=\"n\">primtype_eq</span><span class=\"o\">:</span> <span class=\"bp\">...</span>\n\n<span class=\"k\">with</span> <span class=\"n\">struct_eq</span><span class=\"o\">:</span> <span class=\"bp\">Π</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">),</span> <span class=\"n\">decidable_eq</span> <span class=\"o\">(</span><span class=\"n\">Struct</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">(</span> <span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">d</span> <span class=\"n\">e</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span>\n        <span class=\"n\">simp</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">=</span><span class=\"n\">d</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">string</span><span class=\"bp\">.</span><span class=\"n\">has_decidable_eq</span> <span class=\"n\">a</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">q</span><span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">=</span><span class=\"n\">e</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">has_decidable_eq</span> <span class=\"n\">b</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n        <span class=\"n\">cases</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">pf</span> <span class=\"n\">pt</span><span class=\"o\">,</span>\n            <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">pf</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">false</span><span class=\"o\">},</span> <span class=\"c1\">-- different names</span>\n        <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">pt</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">q</span> <span class=\"k\">with</span> <span class=\"n\">qf</span> <span class=\"n\">qt</span><span class=\"o\">,</span>\n            <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">qf</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">false</span><span class=\"o\">},</span> <span class=\"c1\">-- different fields</span>\n        <span class=\"n\">subst</span> <span class=\"n\">qt</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">=</span><span class=\"n\">f</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- TODO prove maps are equal (will need primtype_eq)</span>\n        <span class=\"n\">cases</span> <span class=\"n\">r</span> <span class=\"k\">with</span> <span class=\"n\">rf</span> <span class=\"n\">rt</span><span class=\"o\">,</span>\n            <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">rf</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">false</span><span class=\"o\">},</span> <span class=\"c1\">-- different values</span>\n\n        <span class=\"n\">subst</span> <span class=\"n\">rt</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"o\">}}</span> <span class=\"c1\">--</span>\n</code></pre></div>\n\n\n<p>Right now the strategy seems like I should prove some lemmas saying that functions from a finite domain into a codomain (w/ decidable equality) have  decidable equality, and then convince Lean that (due to the constraint imposed by the argument) that <code>Struct.vals</code> is effectively a function from a type with a finite domain. I didn't see anything directly related to these two goals in mathlib,  but it seems in principle do-able.</p>",
        "id": 205654433,
        "sender_full_name": "Kris Brown",
        "timestamp": 1596240870
    },
    {
        "content": "<p>May I introduce you to <code>classical.prop_decidable</code>? <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 205654744,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596241258
    },
    {
        "content": "<p>This definitely should be possible though</p>",
        "id": 205655116,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596241771
    },
    {
        "content": "<p>I think I should probably mention my usual advice at this point, which is that if you want to do nontrivial proofs with the type you should avoid <code>mutual inductive</code> and roll your own</p>",
        "id": 205655481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596242365
    },
    {
        "content": "<p>I'm interested but don't know what rolling my own would entail. Is there an example of what you mean by this?</p>",
        "id": 205656076,
        "sender_full_name": "Kris Brown",
        "timestamp": 1596243192
    },
    {
        "content": "<p>I managed this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">PrimType</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">pBool</span> <span class=\"o\">:</span> <span class=\"n\">bool</span>  <span class=\"bp\">→</span> <span class=\"n\">PrimType</span>\n<span class=\"bp\">|</span> <span class=\"n\">pInt</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">PrimType</span>\n<span class=\"bp\">|</span> <span class=\"n\">pStruct&#39;</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fields</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">vals</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">fields</span><span class=\"o\">,</span> <span class=\"n\">PrimType</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">PrimType</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">PrimType</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">induction</span> <span class=\"n\">a</span> <span class=\"n\">generalizing</span> <span class=\"n\">b</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"bp\">;</span>\n  <span class=\"n\">try</span> <span class=\"o\">{{</span> <span class=\"n\">apply</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">is_false</span><span class=\"o\">,</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨⟩</span> <span class=\"o\">}},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">decidable_of_iff</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">decidable_of_iff</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a_name</span> <span class=\"bp\">=</span> <span class=\"n\">b_name</span> <span class=\"k\">then</span> <span class=\"bp\">_</span> <span class=\"k\">else</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]),</span>\n    <span class=\"n\">refine</span> <span class=\"k\">if</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">a_fields</span> <span class=\"bp\">=</span> <span class=\"n\">b_fields</span> <span class=\"k\">then</span> <span class=\"bp\">_</span> <span class=\"k\">else</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]),</span>\n    <span class=\"n\">resetI</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"n\">decidable_of_iff</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">a_vals</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">=</span> <span class=\"n\">b_vals</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rwa</span> <span class=\"err\">←</span> <span class=\"n\">h2</span><span class=\"o\">))</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">subst</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">funext_iff</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">decidable_eq</span><span class=\"o\">]</span>\n<span class=\"kn\">structure</span> <span class=\"n\">Struct</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">fields</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vals</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">fields</span><span class=\"o\">,</span> <span class=\"n\">PrimType</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">PrimType</span><span class=\"bp\">.</span><span class=\"n\">pStruct</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">},</span> <span class=\"n\">Struct</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">PrimType</span>\n<span class=\"bp\">|</span> <span class=\"n\">s</span> <span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">PrimType</span><span class=\"bp\">.</span><span class=\"n\">pStruct&#39;</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"n\">v</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Struct</span><span class=\"bp\">.</span><span class=\"n\">get</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Struct</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">PrimType</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">key</span> <span class=\"err\">∈</span> <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">fields</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">vals</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n</code></pre></div>",
        "id": 205656554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596243923
    },
    {
        "content": "<p>In this case it's pretty easy to avoid a mutual inductive because <code>Struct</code> is just a package around the arguments of <code>pStruct</code></p>",
        "id": 205656601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596243963
    }
]
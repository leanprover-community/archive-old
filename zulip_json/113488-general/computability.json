[
    {
        "content": "<p>It's about time I understood what Lean means by computability.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n\n<span class=\"c1\">-- lean forces me to write noncomputable</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">g</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">bijective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">choose</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"kn\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">g</span> <span class=\"c1\">-- it&#39;s supposed to be noncomputable but it looks like a computer program to me</span>\n\n<span class=\"c1\">-- Here I don&#39;t need to write noncomputable</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">g_property</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">bijective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">axioms</span> <span class=\"n\">g_property</span> <span class=\"c1\">-- classical.choice</span>\n<span class=\"c1\">-- I used the axiom of choice but I&#39;m computable anyway.</span>\n\n<span class=\"c1\">-- and this is computable</span>\n<span class=\"n\">def</span> <span class=\"n\">lem</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">em</span> <span class=\"n\">P</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">axioms</span> <span class=\"n\">lem</span> <span class=\"c1\">-- all the axioms</span>\n</pre></div>\n\n\n<p>In the definition of <code>g</code>, I am forced to mark it as noncomputable, but what does that mean? I thought proofs were programs. Is my definition of <code>g </code>not a program? My proof of g_property uses the axiom of choice according to <code>#print axioms</code> -- and yet it's computable anyway (in the sense that I was not asked to mark it as noncomputable). And I was not asked to mark my definition of <code>lem</code> as computable, but that's a definition which apparently uses the axiom of choice too. What is going on? It all still looks totally random to me but I think I might understand things enough to actually begin to see what this <code>noncomputable</code> thing which I'm randomly asked to put in front of definitions and possibly theorems (does that happen?) actually means, if someone tries to explain it to me...</p>",
        "id": 168155405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560533651
    },
    {
        "content": "<blockquote>\n<p>Lean’s standard library defines an additional axiom, propositional extensionality, and a quotient construction which in turn implies the principle of function extensionality. These extensions are used, for example, to develop theories of sets and finite sets. We will see below that using these theorems can block evaluation in Lean’s kernel, so that closed terms of type ℕ no longer evaluate to numerals. But Lean erases types and propositional information when compiling definitions to bytecode for its virtual machine evaluator, and since these axioms only add new propositions, they are compatible with that computational interpretation. Even computationally inclined users may wish to use the classical law of the excluded middle to reason about computation. This also blocks evaluation in the kernel, but it is compatible with compilation to bytecode.</p>\n</blockquote>\n<p>This is from TPIL and it's one of very few parts of the book which I still do not understand. But I don't understand this paragraph at all. I don't know what bytecode is or the virtual machine. I need to be told something easier first.</p>",
        "id": 168155754,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560533938
    },
    {
        "content": "<p>What I do understand is that there are conjectures I know such as Waring's problem, where there is a number which I regard as \"well-defined\", but for which no mathematician knows an algorithm for working them out. I can see that these aren't \"computable\". I guess I don't see why the other things are computable.</p>",
        "id": 168155900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560534046
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Waring%27s_problem\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Waring%27s_problem\">https://en.wikipedia.org/wiki/Waring%27s_problem</a></p>\n<p>It's known that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>4</mn><mo>≤</mo><mi>G</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>≤</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">4\\leq G(3)\\leq 7</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathrm\">4</span><span class=\"mrel\">≤</span><span class=\"mord mathit\">G</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">3</span><span class=\"mclose\">)</span><span class=\"mrel\">≤</span><span class=\"mord mathrm\">7</span></span></span></span>.</p>",
        "id": 168155976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560534108
    },
    {
        "content": "<p>It's okay to use choice to make a <code>Sort u</code>, or a proof. If you use it for anything else it's noncomputable.</p>",
        "id": 168157550,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560535289
    },
    {
        "content": "<p>I think the rules are simply<br>\n1. Types and propositions and proofs are always computable (because they are not actually represented at all at runtime). That is, anything whose type is <code>Sort u</code> for some <code>u</code>. This also extends to Pi-types ending in <code>Sort u</code>.<br>\n2. Axioms are not computable (because they have no definition). Normally I think this only applies to <code>choice</code> because the other standard axioms are propositions.<br>\n3. Anything that uses something noncomputable is noncomputable, except that rule 1 always takes priority.</p>",
        "id": 168157572,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560535301
    },
    {
        "content": "<p>Maybe I've confused myself and rule 1 is really two separate rules (type erasure and proof irrelevance), not sure.</p>",
        "id": 168157809,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560535449
    },
    {
        "content": "<p>Ok so perhaps some examples of things which I might want to define are noncomputable <code>nat</code>s and noncomputable functions <code>f : X -&gt; Y</code>. So then my next, and I think my last, question is: what am I losing by having these things marked as noncomputable? Is the only difference that I am basically guaranteed not to be able to prove anything about these noncomputable gadgets using <code>rfl</code>? Is that it? I can just reason about these objects perfectly well using exactly the same sort of reasoning I would use in a maths paper. I would never want to use <code>rfl</code> on these objects anyway because I know they've been defined using some choice function.</p>\n<p>With things like the perfectoid project I would work constructively by default, and would just write <code>noncomputable</code> in front of a definition every time Lean told me to. I could instead have just written <code>noncomputable theory</code> at the top of every file. What would I have lost if I'd done that? I am struggling to find any reason at all why I would ever care about computability. Let's say my goal was to define a perfectoid space and then state Scholze's tilting correspondence (this is feasible but would take a fair bit more work), and then let's say my next goal was to prove it (this would take an unfeasibly large amount of work unless I had a big team). Would I ever care about computability ever?</p>",
        "id": 168198303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560586382
    },
    {
        "content": "<p>Lean produces code for everything that's not marked <code>noncomputable</code></p>",
        "id": 168198845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560587436
    },
    {
        "content": "<p>you can look at this code, although it's not very intelligible</p>",
        "id": 168198852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560587450
    },
    {
        "content": "<p><code>noncomputable theory</code> has no downsides except that it makes computability less obvious (which itself may not be a downside depending on your POV). It actually means \"please infer <code>noncomputable</code> for me\"</p>",
        "id": 168198880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560587522
    },
    {
        "content": "<p>As I'm sure you've noticed, lean knows perfectly well which definitions are computable and which aren't, and without <code>noncomputable theory</code> it nags you until you put the markings it knows you should put. <code>noncomputable theory</code>just says to do this automatically without user interaction</p>",
        "id": 168198921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560587594
    },
    {
        "content": "<p>I just don't get why computability is important to me if I just want to make mathematical objects and state and prove theorems about them.</p>",
        "id": 168198970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560587651
    },
    {
        "content": "<p>It's not, unless you are Anrdej Bauer</p>",
        "id": 168198977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560587674
    },
    {
        "content": "<p>and we're already long past that point since <code>choice</code> appears as an axiom so early in the development that it's difficult to do without</p>",
        "id": 168198995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560587718
    },
    {
        "content": "<p>You can still prove stuff about noncomputable gadgets using <code>rfl</code>, as long as you are doing some definition unfolding and such</p>",
        "id": 168199051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560587866
    },
    {
        "content": "<p>you won't be able to do large scale rfl proofs like \"compute the class number of this field\", but I think you know when to use the word \"compute\" in this context</p>",
        "id": 168199094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560587913
    },
    {
        "content": "<p>I think \"noncomputable by default, computable for computations\" is a reasonable stance for doing pure maths in lean</p>",
        "id": 168199103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560587965
    },
    {
        "content": "<p>I am not sure I know what \"computations\" mean. Kenny pointed out to me on Thursday at Xena that mathematicians and computer scientists use the term in two different ways.</p>",
        "id": 168199151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560588017
    },
    {
        "content": "<p>I think we use it incorrectly, and I think that the fact that I've been exposed to decades of incorrect usage of the term has clouded my thinking over the issue.</p>",
        "id": 168199155,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560588058
    },
    {
        "content": "<p>roughly speaking, if you would open up GAP or a CAS to do it</p>",
        "id": 168199206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560588140
    },
    {
        "content": "<p>then you need a computable model of say Q-bar</p>",
        "id": 168199215,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560588166
    },
    {
        "content": "<p>sure, that's what I mean by \"computable for computations\"</p>",
        "id": 168199225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560588204
    },
    {
        "content": "<p>unless you need that, computability does you no favors</p>",
        "id": 168199229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560588217
    },
    {
        "content": "<p>The Curry-Howard correspondence says that \"proofs are programs\". Is there a program corresponding to the proof of the theorem that a product of non-empty sets is non-empty? What is a program? What language is this program supposed to be in?</p>",
        "id": 168199603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589024
    },
    {
        "content": "<p>Yes. It's the program that returns (x,y), when x is the witness to X being nonempty, and y is the witness to Y being nonempty.</p>",
        "id": 168199646,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560589084
    },
    {
        "content": "<p>infinite product!</p>",
        "id": 168199650,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589098
    },
    {
        "content": "<p>Then you want to give me a function.</p>",
        "id": 168199654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589117
    },
    {
        "content": "<p>Is there a program corresponding to the proof of the theorem that the Riemann Hypothesis is either true or false?</p>",
        "id": 168199659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589143
    },
    {
        "content": "<p>I was thinking about this the other day</p>",
        "id": 168199663,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560589167
    },
    {
        "content": "<p>Or maybe the Continuum Hypothesis would be a better example (something which is known not to be provable or disprovable from the axioms of maths)</p>",
        "id": 168199710,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589206
    },
    {
        "content": "<p>I think you can do this computably</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 168199717,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560589212
    },
    {
        "content": "<p>If I have <code>P : Prop</code> and then I have some Lean file which makes <code>hP : P</code>, is that <em>definitely</em> a program?</p>",
        "id": 168199726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589264
    },
    {
        "content": "<p>Even if somewhere along the way, the construction of the term <code>hP</code> uses something <code>noncomputable</code>?</p>",
        "id": 168199733,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589297
    },
    {
        "content": "<p>In fact you could define this computably in <code>meta</code> using <code>quot.unquot</code> I think, and you would still have a function (even though you used <code>quot.unquot</code> which isn't a mathematical function</p>",
        "id": 168199775,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560589326
    },
    {
        "content": "<p>There is something completely fundamental here which I don't understand. A <code>.lean</code> file looks to me like a program, because I can compile it using Lean on my computer. Does this have anything to do with computability though?</p>",
        "id": 168199779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589352
    },
    {
        "content": "<p>And this is basically choice if all the quotients are true.</p>",
        "id": 168199781,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560589357
    },
    {
        "content": "<p>I guess it depends what you mean by computable.</p>",
        "id": 168199790,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560589397
    },
    {
        "content": "<p>Lean seems to have a perfectly well-defined notion of what it means for something to be computable.</p>",
        "id": 168199794,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589420
    },
    {
        "content": "<p><code>.lean</code> files aren't in the domain of that particular <code>computable</code> predicate.</p>",
        "id": 168199836,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560589464
    },
    {
        "content": "<p>My understanding is that the initial interpretation of \"proof = program\" was that a proof was supposed to be interpreted as some sort of proof using only constructive logic or intuitionistic logic or whatever. As we all know, this is not what is going on maths departments across the world -- they have a more powerful notion of proof. Does this just <em>break</em> Curry-Howard, or is there a rigorous but wider interpretation of \"program\" which I can use which fixes it?</p>",
        "id": 168199857,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589550
    },
    {
        "content": "<p>The quotient product example is one place where lean's syntactic notion of \"computable\" is overly restrictive</p>",
        "id": 168199893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560589563
    },
    {
        "content": "<p>just use Haskell's setoid-without-quotient philosophy</p>",
        "id": 168199901,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560589587
    },
    {
        "content": "<p>then the quotient.choice is computable</p>",
        "id": 168199903,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560589595
    },
    {
        "content": "<p>aka setoid hell</p>",
        "id": 168199904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560589598
    },
    {
        "content": "<p>I learnt about that from Nicola Gambini last week.</p>",
        "id": 168199909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589619
    },
    {
        "content": "<p>There are curry howard interpretations of LEM but they are a bit weird</p>",
        "id": 168199917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560589663
    },
    {
        "content": "<p>So Curry-Howard is a lie?</p>",
        "id": 168199923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589679
    },
    {
        "content": "<p>Constructive proofs are programs</p>",
        "id": 168199964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560589695
    },
    {
        "content": "<p>What I don't quite get is if I have computable choice and computable univalence, shouldn't I be able to get computable em. Obviously I can't, but I don't see where the proof breaks down.</p>",
        "id": 168199971,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560589721
    },
    {
        "content": "<p>C-H is pithy, alliterative, beautiful-looking, but not actually true in maths departments because we have a different definition of proof and there is no corresponding definition of program.</p>",
        "id": 168199979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589741
    },
    {
        "content": "<p>I have heard it argued that for most of history mathematics was constructive</p>",
        "id": 168199993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560589789
    },
    {
        "content": "<p>I don't live in the past.</p>",
        "id": 168199996,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589801
    },
    {
        "content": "<p>it wasn't until dedekind and such that we started getting a more general notion of function that doesn't readily admit \"execution\"</p>",
        "id": 168200042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560589841
    },
    {
        "content": "<p>You don't need to convince me that you don't see the point in constructivity</p>",
        "id": 168200055,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560589881
    },
    {
        "content": "<p>Maybe we can say that the age of Curry-Howard is passed. What I am confused about is the fact that I can prove Tychonoff's theorem (or some other theorem equivalence to the mathematician's axiom of choice) in Lean and make a text file called <code>tykonov.lean</code> which looks to a mathematician like a computer program.</p>",
        "id": 168200059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589890
    },
    {
        "content": "<p>Is it not a computer program?</p>",
        "id": 168200100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589928
    },
    {
        "content": "<p>It is not</p>",
        "id": 168200104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560589942
    },
    {
        "content": "<p>But I can compile it and it runs.</p>",
        "id": 168200105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589955
    },
    {
        "content": "<p>It produces no output.</p>",
        "id": 168200108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589964
    },
    {
        "content": "<p>it is input to a computer program that analyzes the information in the file</p>",
        "id": 168200109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560589965
    },
    {
        "content": "<p>There are many computer programs in the world, not all of them are compilers</p>",
        "id": 168200119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560589984
    },
    {
        "content": "<p>Aah, so Lean is the program, but my .lean file is not a program?</p>",
        "id": 168200120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560589985
    },
    {
        "content": "<p>I thought Lean compiled my .lean file into an .olean file</p>",
        "id": 168200130,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560590016
    },
    {
        "content": "<p>Just like when you write TeX code it's input to a program but it's not a program itself, it's just a data representation</p>",
        "id": 168200133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560590036
    },
    {
        "content": "<p>unless you write esoteric TeX macros which would be analogous to lean metaprograms which are actually programs</p>",
        "id": 168200177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560590066
    },
    {
        "content": "<p>But the key point is this: when you write a proof that is <code>computable</code> in lean, it is literally both a proof and a program</p>",
        "id": 168200193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560590127
    },
    {
        "content": "<p>you can run it with <code>#eval</code></p>",
        "id": 168200196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560590139
    },
    {
        "content": "<p>and that's the main idea behind the computability interpretation of intuitionistic math</p>",
        "id": 168200239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560590173
    },
    {
        "content": "<p>macros: I did this in my thesis, which was written in plain TeX (which has no theorem numbering macros); I wrote the macros myself. I think my confusion is now resolved. I don't want to lose track of Chris' question above about computable <code>em</code>, I know he's been thinking a lot about univalence recently. <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> do you know anything about </p>\n<blockquote>\n<p>What I don't quite get is if I have computable choice and computable univalence, shouldn't I be able to get computable em. Obviously I can't, but I don't see where the proof breaks down.</p>\n</blockquote>\n<p>Mario -- thanks as ever.</p>",
        "id": 168200248,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560590207
    },
    {
        "content": "<p>Wait -- I thought the whole problem with HoTT was that univalence wasn't computable? And I have this vague idea that cubical type theory was an attempt to fix this.</p>",
        "id": 168200269,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560590270
    },
    {
        "content": "<p>that's right</p>",
        "id": 168200315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560590287
    },
    {
        "content": "<p>So Chris it seems to me that you have to become an expert in cubical type theory now.</p>",
        "id": 168200319,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560590312
    },
    {
        "content": "<p>univalence is not a nonconstructive principle, meaning that we have long believed that it has a constructive interpretation, but as defined in book HoTT it's an axiom, meaning that when you have to \"call\" it like a function you don't know what to do</p>",
        "id": 168200329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560590348
    },
    {
        "content": "<p>In cubical type theory it's a theorem, so the implementation of that function (in terms of new primitives not in HoTT) is now known</p>",
        "id": 168200382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560590407
    },
    {
        "content": "<p>Re: univalence and choice, I would try going through DIaconescu with a constructive mindset to see what happens</p>",
        "id": 168200393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560590452
    },
    {
        "content": "<p>I have this uncomfortable feeling about this (univalence axiom). When I was moaning about having built a bunch of structure on a ring R and then wanting to move it onto an isomorphic ring S,  people were saying \"use HoTT\". Now I wonder whether some of the terms I'd get out of this HoTT strategy would just be useless in practice because they have been created using an axiom. On the other hand I guess I make terms using the axiom of choice and seem to get away with it.</p>",
        "id": 168200404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560590493
    },
    {
        "content": "<p>It is an open question whether all the consequences of univalence computability are provable in book HoTT. AFAIK it's true</p>",
        "id": 168200456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560590556
    },
    {
        "content": "<p>So you wouldn't actually get stuck, but you would need to prove lemmas about how transport works on different structures</p>",
        "id": 168200467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560590594
    },
    {
        "content": "<p>(transport is the function <code>a = b -&gt; P a -&gt; P b</code>)</p>",
        "id": 168200472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560590614
    },
    {
        "content": "<blockquote>\n<p>But the key point is this: when you write a proof that is <code>computable</code> in lean, it is literally both a proof and a program</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"n\">X</span> <span class=\"c1\">-- #0</span>\n</pre></div>",
        "id": 168200733,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560591047
    },
    {
        "content": "<p>Wait, I am confused again. I thought every proof was computable in Lean, in the sense that you don't have to mark it noncomputable because it's a proof?</p>",
        "id": 168201060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560591665
    },
    {
        "content": "<blockquote>\n<p>But the key point is this: when you write a proof that is <code>computable</code> in lean, it is literally both a proof and a program</p>\n</blockquote>\n<p>I'm still amazed by how fast</p>\n<div class=\"codehilite\"><pre><span></span>import data.zmod.quadratic_reciprocity\n#eval (zmodp.legendre_sym 1111 3119 (by sorry))\n</pre></div>\n\n\n<p>runs.</p>",
        "id": 168201061,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1560591670
    },
    {
        "content": "<p>The caveat is that lean doesn't run what we normally call proofs, i.e. elements of elements of Prop. These are erased in the VM, so they are trivially computable</p>",
        "id": 168201168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560591873
    },
    {
        "content": "<p>It is possible to build a theorem prover such that these proofs are executable, and actually lean will reduce proofs if you use <code>#reduce</code>, but there are some efficiency problems with doing this at large scale</p>",
        "id": 168201189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560591952
    },
    {
        "content": "<p>What about my proof that the noncomputable inverse of a bijection was indeed an inverse?</p>",
        "id": 168201363,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560592246
    },
    {
        "content": "<p>That's computable to a function if you didn't use any axioms</p>",
        "id": 168202106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560593699
    },
    {
        "content": "<p>Here's Diaconescu's proof reinterpreted with everything in Type:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">open</span> <span class=\"n\">classical</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">eq&#39;</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">eq&#39;</span> <span class=\"n\">a</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">eq&#39;</span>\n\n<span class=\"n\">def</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">c</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">f</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span>\n\n<span class=\"n\">def</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"n\">def</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">unit</span> <span class=\"err\">⊕</span> <span class=\"n\">p</span>\n<span class=\"n\">def</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">empty</span> <span class=\"err\">⊕</span> <span class=\"n\">p</span>\n\n<span class=\"n\">def</span> <span class=\"n\">exU</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">unit</span><span class=\"o\">,</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n<span class=\"n\">def</span> <span class=\"n\">exV</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">empty</span><span class=\"o\">,</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">exU</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fst</span>\n<span class=\"n\">def</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">exV</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fst</span>\n\n<span class=\"n\">def</span> <span class=\"n\">u_def</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">exU</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span>\n<span class=\"n\">def</span> <span class=\"n\">v_def</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">exV</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span>\n\n<span class=\"n\">def</span> <span class=\"n\">not_uv_or_p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">p</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">empty</span><span class=\"o\">)</span> <span class=\"err\">⊕</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">u_def</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">hu</span> <span class=\"n\">hu</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">v_def</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">hv</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hu</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">hv</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">()</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">hv</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">hu</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">axiom</span> <span class=\"n\">funext&#39;</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">f₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f₁</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">f₂</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">p_implies_uv</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"n\">p</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">v</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"n\">p</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">V</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">funext&#39;</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">refine</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"err\">⊕</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> provable by univalence, I&#39;ll ignore this -/</span> <span class=\"o\">},</span>\n  <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">exU</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">exV</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n    <span class=\"n\">exU</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">exV</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">@</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">W</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">exU</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">exV</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">W</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n      <span class=\"n\">exU</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">exV</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">this</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">assume</span> <span class=\"o\">(</span><span class=\"n\">exU</span> <span class=\"n\">exV</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">),</span> <span class=\"n\">U</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"k\">show</span> <span class=\"n\">exU</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">exV</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span> <span class=\"c1\">-- We can&#39;t prove this. In the original proof</span>\n        <span class=\"c1\">-- exU and exV were proofs and we used proof irrel here,</span>\n        <span class=\"c1\">-- but now it&#39;s definitely false; if we reduce everything</span>\n        <span class=\"c1\">-- else (and don&#39;t revert exU and exV) we find that</span>\n        <span class=\"c1\">-- exU.fst is unit and exV.fst is empty, so this is false.</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">em</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"err\">⊕</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">empty</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"o\">(</span><span class=\"n\">not_uv_or_p</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">p_implies_uv</span> <span class=\"n\">p</span> <span class=\"n\">e</span><span class=\"o\">)))</span>\n  <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span>\n</pre></div>",
        "id": 168202119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560593733
    },
    {
        "content": "<p>So this discussion has revealed the fact that I don't really know what a \"program\" is. I want to define a program as a \"computer file\" (a lean file, an olean file, a range of memory addresses) which can be turned by a compiler into something which can be run by my CPU. Is that a reasonable definition? Is that Curry-Howard's definition?</p>\n<p>I am also a bit confused about definitions. Are definitions also sometimes programs?</p>\n<p>Here are two theorems and two definitions.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">D1</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">T1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">D2</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">T2</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">D2</span> <span class=\"n\">hf</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Which of those things can be turned into \"programs\" in the sense of Curry and Howard?</p>",
        "id": 168205958,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560601339
    },
    {
        "content": "<p>I think I proved <code>trunc (p ⊕ (p → empty))</code>. This is good enough for decidability of all props? Is there any stuff here that doesn't work in HoTT?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">quot</span>\n<span class=\"kn\">open</span> <span class=\"n\">classical</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">eq&#39;</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">eq&#39;</span> <span class=\"n\">a</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">eq&#39;</span>\n\n<span class=\"n\">def</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">c</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">f</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span>\n\n<span class=\"n\">def</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"n\">def</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">unit</span> <span class=\"err\">⊕</span> <span class=\"n\">p</span>\n<span class=\"n\">def</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">empty</span> <span class=\"err\">⊕</span> <span class=\"n\">p</span>\n\n<span class=\"n\">def</span> <span class=\"n\">exU</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"err\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">⟨</span><span class=\"n\">unit</span><span class=\"o\">,</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n<span class=\"n\">def</span> <span class=\"n\">exV</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"err\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">⟨</span><span class=\"n\">empty</span><span class=\"o\">,</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">axiom</span> <span class=\"n\">choice&#39;</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">not_uv_or_p</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">trunc</span> <span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">trunc</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">→</span> <span class=\"n\">empty</span><span class=\"o\">)</span> <span class=\"err\">⊕</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">assume</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">with</span> <span class=\"n\">hu</span> <span class=\"n\">hu</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">with</span> <span class=\"n\">hv</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"n\">unit</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">trunc</span> <span class=\"n\">empty</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">hu</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">hv</span> <span class=\"n\">e</span><span class=\"o\">),</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"n\">empty</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">()),</span>\n      <span class=\"n\">refine</span> <span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">lift_on</span> <span class=\"n\">this</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">hv</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">hu</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">axiom</span> <span class=\"n\">funext&#39;</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">f₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f₁</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">f₂</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">p_implies_uv</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">trunc</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"n\">p</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">V</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">funext&#39;</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">refine</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"err\">⊕</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> provable by univalence, I&#39;ll ignore this -/</span> <span class=\"o\">},</span>\n  <span class=\"n\">revert</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">this</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">assume</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"c\">/-</span><span class=\"cm\"> Should be provable by univalence. Both types are inhabited -/</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">em</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"err\">⊕</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">empty</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">have</span> <span class=\"n\">fU</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">choice&#39;</span> <span class=\"n\">exU</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">fV</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">choice&#39;</span> <span class=\"n\">exV</span><span class=\"o\">,</span>\n<span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">rec_on_subsingleton</span> <span class=\"n\">fU</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">fU</span><span class=\"o\">,</span> <span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">rec_on_subsingleton</span> <span class=\"n\">fV</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">fV</span><span class=\"o\">,</span>\n  <span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"k\">begin</span>\n    <span class=\"n\">refine</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"o\">(</span><span class=\"n\">not_uv_or_p</span> <span class=\"n\">p</span><span class=\"o\">(</span><span class=\"n\">fU</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fV</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"k\">assume</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">p_implies_uv</span> <span class=\"n\">p</span> <span class=\"n\">hp</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 168206297,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560602057
    },
    {
        "content": "<p><code>choice'</code> is the actual axiom of choice</p>",
        "id": 168206378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560602264
    },
    {
        "content": "<p>What's the weaker computable version?</p>",
        "id": 168206478,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560602414
    },
    {
        "content": "<p>no <code>trunc</code></p>",
        "id": 168206480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560602448
    },
    {
        "content": "<p>it's trivial</p>",
        "id": 168206482,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560602458
    },
    {
        "content": "<p>People call it the axiom of choice sometimes but it's just moving sigmas around</p>",
        "id": 168206488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560602489
    },
    {
        "content": "<p>The thing which is more like the real AC, which is equivalent in power to AC, puts a trunc on each side like you did</p>",
        "id": 168206492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560602517
    },
    {
        "content": "<p>Without <code>trunc</code> it's the identity function. what do you mean exactly?</p>",
        "id": 168206539,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560602560
    },
    {
        "content": "<p>Usually people state it as in <code>\\forall x, \\exists y, p x y -&gt; \\exists f, \\forall x, p x (f x)</code></p>",
        "id": 168206547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560602618
    },
    {
        "content": "<p>in your form it's particularly simple</p>",
        "id": 168206548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560602636
    },
    {
        "content": "<blockquote>\n<p>So this discussion has revealed the fact that I don't really know what a \"program\" is. I want to define a program as a \"computer file\" (a lean file, an olean file, a range of memory addresses) which can be turned by a compiler into something which can be run by my CPU. Is that a reasonable definition? Is that Curry-Howard's definition?</p>\n</blockquote>\n<p>Yes, that's a reasonable definition. The church turing thesis says that basically any reasonable definition of \"program\" lands on the exact same class of functions, which are the computable functions. A more traditional definition would use turing machines or reduction of lambda terms</p>",
        "id": 168206590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560602693
    },
    {
        "content": "<p>But my version is still computable</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">choice2</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">unquot</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 168206644,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560602772
    },
    {
        "content": "<blockquote>\n<p>I am also a bit confused about definitions. Are definitions also sometimes programs?</p>\n</blockquote>\n<p>When you write <code>def</code> in lean, it goes through that compiling bit and produces something that can be run by the CPU, i.e. a program</p>",
        "id": 168206646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560602777
    },
    {
        "content": "<p>the <code>choice'</code> isn't needed</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">em</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"err\">⊕</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">empty</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">rec_on_subsingleton</span> <span class=\"o\">(</span><span class=\"n\">exU</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">fU</span><span class=\"o\">,</span>\n  <span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">rec_on_subsingleton</span> <span class=\"o\">(</span><span class=\"n\">exV</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">fV</span><span class=\"o\">,</span>\n    <span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"k\">begin</span>\n      <span class=\"n\">refine</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"o\">(</span><span class=\"n\">not_uv_or_p</span> <span class=\"n\">p</span> <span class=\"n\">fU</span> <span class=\"n\">fV</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"k\">assume</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">p_implies_uv</span> <span class=\"n\">p</span> <span class=\"n\">hp</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 168206819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560603188
    },
    {
        "content": "<p>The nice thing about the computability interpretation is that you can just \"inline functions\" to find out what happens and maybe end up proving something much stronger:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">em</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">empty</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">unit</span><span class=\"o\">,</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">empty</span><span class=\"o\">,</span> <span class=\"n\">sum</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">trunc</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">→</span> <span class=\"n\">empty</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"n\">unit</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">trunc</span> <span class=\"n\">empty</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"n\">empty</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">()),</span>\n    <span class=\"n\">refine</span> <span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">lift_on</span> <span class=\"n\">this</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"k\">assume</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">p_implies_uv</span> <span class=\"n\">p</span> <span class=\"n\">hp</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 168207060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560603696
    },
    {
        "content": "<p>Okay, it's completely self contained now. Clearly something is odd</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">quot</span>\n<span class=\"kn\">open</span> <span class=\"n\">classical</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">eq&#39;</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">eq&#39;</span> <span class=\"n\">a</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">eq&#39;</span>\n\n<span class=\"n\">def</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">c</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">):</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">f</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span>\n\n<span class=\"n\">def</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kn\">axiom</span> <span class=\"n\">funext&#39;</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f₁</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">f₂</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f₁</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">f₂</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">empty</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">unit</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">empty</span> <span class=\"k\">in</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">unit</span><span class=\"o\">,</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">empty</span><span class=\"o\">,</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">trunc</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">funext&#39;</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">],</span>\n      <span class=\"n\">sorry</span> <span class=\"c\">/-</span><span class=\"cm\"> provable by univalence, I&#39;ll ignore this -/</span> <span class=\"o\">},</span>\n    <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">u&#39;</span><span class=\"o\">,</span> <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">v&#39;</span><span class=\"o\">,</span>\n    <span class=\"n\">clear</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">revert</span> <span class=\"n\">u&#39;</span> <span class=\"n\">v&#39;</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">unit</span><span class=\"o\">),</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"c\">/-</span><span class=\"cm\"> Should be provable by univalence. Both types are inhabited -/</span>\n  <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"n\">empty</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">()),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">lift_on</span> <span class=\"n\">this</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 168207496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560604585
    },
    {
        "content": "<p>Aha, of course:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">unit</span><span class=\"o\">)</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"err\">&#39;</span> <span class=\"n\">empty</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">empty</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"n\">H</span> <span class=\"n\">unit</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">eq&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">()</span>\n</pre></div>",
        "id": 168207718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560605081
    },
    {
        "content": "<p>So does that mean <code>axiom univalence {α β : Sort*} : α ≃ β → α = β</code> is inconsistent with Lean?</p>",
        "id": 168207720,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560605102
    },
    {
        "content": "<p>because <code>funext'</code> is provable in Lean</p>",
        "id": 168207729,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560605127
    },
    {
        "content": "<p>the first <code>sorry</code> is false</p>",
        "id": 168207730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560605130
    },
    {
        "content": "<p>I don't understand how you intend to prove <code>x =' unit =' (x =' empty)</code></p>",
        "id": 168207731,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560605131
    },
    {
        "content": "<p>Yeah</p>",
        "id": 168207733,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560605134
    },
    {
        "content": "<p>I didn' check that one</p>",
        "id": 168207784,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560605215
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>I am also a bit confused about definitions. Are definitions also sometimes programs?</p>\n</blockquote>\n<p>When you write <code>def</code> in lean, it goes through that compiling bit and produces something that can be run by the CPU, i.e. a program</p>\n</blockquote>\n<p>So D1 and T1 (the definition and theorem which worked in vanilla Lean with no classical or anything) are turned into programs by the Lean executable, and D2 is probably not (because it's not computable), and I'm still a bit confused about T2.</p>",
        "id": 168207966,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560605572
    },
    {
        "content": "<p>Hey that univalence axiom looks really useful! Maybe someone should ask Leo to add it.</p>",
        "id": 168208028,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560605671
    },
    {
        "content": "<p>Only <code>D1</code> actually gets associated bytecode</p>",
        "id": 168208040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560605707
    },
    {
        "content": "<p>I don't know what bytecode is. I want to know which ones become programs, or perhaps can become programs.</p>",
        "id": 168208051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560605737
    },
    {
        "content": "<p>that's CS speak for \"the thing the computer runs\"</p>",
        "id": 168208059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560605757
    },
    {
        "content": "<p>TeX -- you can write a file, but it's not a program. Is bytecode always a program?</p>",
        "id": 168208104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560605783
    },
    {
        "content": "<p>bytecode is stuff that gets run by an interpreter. It's the equivalent of compilation for interpreted languages</p>",
        "id": 168208121,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560605824
    },
    {
        "content": "<p>like python</p>",
        "id": 168208124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560605834
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> I can make a term of type <code>equiv nat int</code>. If I can deduce nat = int and I have <code>-1 : int</code>, can I then make <code>-1 : nat</code>?</p>",
        "id": 168208128,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560605848
    },
    {
        "content": "<p>no</p>",
        "id": 168208130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560605857
    },
    {
        "content": "<p>you get <code>cast _ (-1) : nat</code></p>",
        "id": 168208131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560605871
    },
    {
        "content": "<p>If I make two different equivs from nat to int, deduce nat = int twice, and use both deductions to move from int to nat, can I deduce <code>cast _ (-1) : nat = cast _ (-1) : nat</code>?</p>",
        "id": 168208177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560605919
    },
    {
        "content": "<p>Is the <code>_</code> a missing proof or missing data?</p>",
        "id": 168208181,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560605937
    },
    {
        "content": "<p>missing proof, but proofs are data in HoTT</p>",
        "id": 168208187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560605949
    },
    {
        "content": "<p>in lean the proofs are defeq and so you would get in trouble at this point</p>",
        "id": 168208189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560605971
    },
    {
        "content": "<blockquote>\n<p>So does that mean <code>axiom univalence {α β : Sort*} : α ≃ β → α = β</code> is inconsistent with Lean?</p>\n</blockquote>\n<p>This was the question I was interested in. Is it inconsistent?</p>",
        "id": 168208191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560605986
    },
    {
        "content": "<p>no</p>",
        "id": 168208193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560605992
    },
    {
        "content": "<p>That's actually weak univalence; I think it's consistent</p>",
        "id": 168208234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560606055
    },
    {
        "content": "<blockquote>\n<p>bytecode is stuff that gets run by an interpreter. It's the equivalent of compilation for interpreted languages</p>\n</blockquote>\n<p>So the bytecode made with <code>D1</code> is a program. And there's no bytecode made for <code>T1</code> but if we weren't so proof-impredicative then there could be a program made for <code>T1</code>. And there's no program for <code>D2</code>, and there's no program for <code>T2</code> but that's for two reasons -- firstly because the VM forgets all proofs, and secondly because even if it didn't, it wouldn't be able to make the program because there's no program for <code>D2</code>. Have I finally got this straight?</p>",
        "id": 168208287,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560606142
    },
    {
        "content": "<p>In HoTT there could be a program for <code>T1</code> but not for <code>T2</code></p>",
        "id": 168208303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560606197
    },
    {
        "content": "<p>Yes. More precisely, it could try to make programs for D2 and T2, but somewhere in there there would be a call to the function <code>choice()</code></p>",
        "id": 168208304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560606198
    },
    {
        "content": "<p>and that function has no definition</p>",
        "id": 168208306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560606205
    },
    {
        "content": "<p>like we have no clue how to write a function that works</p>",
        "id": 168208313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560606218
    },
    {
        "content": "<p><code>nat.zero</code> has no definition.</p>",
        "id": 168208315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560606224
    },
    {
        "content": "<p>it is defined to return 0</p>",
        "id": 168208319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560606234
    },
    {
        "content": "<p>in the bytecode</p>",
        "id": 168208360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560606246
    },
    {
        "content": "<p>we know how to implement inductive types, by using tagged unions</p>",
        "id": 168208365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560606278
    },
    {
        "content": "<p>I think I would like to see some simple examples of what bytecode looks like. How do I do this? I've inspected it in the past with a text editor and that didn't end well.</p>",
        "id": 168208373,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560606297
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">compiler</span><span class=\"bp\">.</span><span class=\"n\">optimize_bytecode</span> <span class=\"n\">true</span>\n</pre></div>",
        "id": 168208384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560606313
    },
    {
        "content": "<p>don't ask why the name of the option is so not obvious</p>",
        "id": 168208390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560606340
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">D1</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">[compiler.optimize_bytecode]  D1 0</span>\n<span class=\"cm\">0: scnstr #2</span>\n<span class=\"cm\">1: ret</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>and is there somewhere which gives me some idea of what these commands like <code>scnstr</code> mean?</p>",
        "id": 168208436,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560606375
    },
    {
        "content": "<p>no, you have to guess but I can take a stab</p>",
        "id": 168208502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560606504
    },
    {
        "content": "<p>I think it is \"simple constructor <a href=\"https://github.com/leanprover-community/mathlib/issues/2\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/2\">#2</a>\" which builds a simple atom (a nat) with value 2</p>",
        "id": 168208515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560606552
    },
    {
        "content": "<p>ret is return</p>",
        "id": 168208519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560606569
    },
    {
        "content": "<p>I'm stuck on this one:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">compiler</span><span class=\"bp\">.</span><span class=\"n\">optimize_bytecode</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">A</span>\n\n<span class=\"n\">def</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">[compiler.optimize_bytecode]  D 0</span>\n<span class=\"cm\">0: scnstr #0</span>\n<span class=\"cm\">1: scnstr #1</span>\n<span class=\"cm\">2: scnstr #0</span>\n<span class=\"cm\">3: scnstr #0</span>\n<span class=\"cm\">4: cnstr #1 2</span>\n<span class=\"cm\">5: cnstr #1 2</span>\n<span class=\"cm\">6: cnstr #1 2</span>\n<span class=\"cm\">7: ret</span>\n<span class=\"cm\">-/</span>\n</pre></div>",
        "id": 168208607,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560606722
    },
    {
        "content": "<p>Hey, wait a minute! This code has line numbers! It's like BBC Basic! It's like the old days! Hey this is a program, right?</p>",
        "id": 168208642,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560606757
    },
    {
        "content": "<p>this is a very low level program indeed</p>",
        "id": 168208785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560607063
    },
    {
        "content": "<p>and it has line numbers because there is a goto</p>",
        "id": 168208820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560607083
    },
    {
        "content": "<p>\\me remembers the old days</p>",
        "id": 168208913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560607267
    },
    {
        "content": "<p>darn it, I'm sure some variant of that works</p>",
        "id": 168208917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560607281
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">compiler</span><span class=\"bp\">.</span><span class=\"n\">optimize_bytecode</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">A</span>\n\n<span class=\"n\">def</span> <span class=\"n\">D1</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">[compiler.optimize_bytecode]  D1 0</span>\n<span class=\"cm\">0: scnstr #0</span>\n<span class=\"cm\">1: ret</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">D2</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">[compiler.optimize_bytecode]  D2 0</span>\n<span class=\"cm\">0: scnstr #0</span>\n<span class=\"cm\">1: scnstr #0</span>\n<span class=\"cm\">2: cnstr #1 2</span>\n<span class=\"cm\">3: ret</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">D3</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">[compiler.optimize_bytecode]  D3 0</span>\n<span class=\"cm\">0: scnstr #1</span>\n<span class=\"cm\">1: scnstr #0</span>\n<span class=\"cm\">2: scnstr #0</span>\n<span class=\"cm\">3: cnstr #1 2</span>\n<span class=\"cm\">4: cnstr #1 2</span>\n<span class=\"cm\">5: ret</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">D4</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">[compiler.optimize_bytecode]  D4 0</span>\n<span class=\"cm\">0: scnstr #0</span>\n<span class=\"cm\">1: scnstr #1</span>\n<span class=\"cm\">2: scnstr #0</span>\n<span class=\"cm\">3: scnstr #0</span>\n<span class=\"cm\">4: cnstr #1 2</span>\n<span class=\"cm\">5: cnstr #1 2</span>\n<span class=\"cm\">6: cnstr #1 2</span>\n<span class=\"cm\">7: ret</span>\n<span class=\"cm\">-/</span>\n</pre></div>",
        "id": 168208962,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560607361
    },
    {
        "content": "<p>That makes it much clearer.</p>",
        "id": 168208977,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560607393
    },
    {
        "content": "<p>oh wait actually it does make it clearer.</p>",
        "id": 168208982,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560607422
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">[compiler.optimize_bytecode]  D 0</span>\n<span class=\"cm\">0: scnstr #1</span>\n<span class=\"cm\">1: scnstr #1</span>\n<span class=\"cm\">2: scnstr #0</span>\n<span class=\"cm\">3: scnstr #0</span>\n<span class=\"cm\">4: cnstr #1 2</span>\n<span class=\"cm\">5: cnstr #1 2</span>\n<span class=\"cm\">6: cnstr #1 2</span>\n<span class=\"cm\">7: ret</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>The code is backwards or something.</p>",
        "id": 168209024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560607456
    },
    {
        "content": "<p>It works like a stack machine. Here's what the stack looks like, pushing items from the right:</p>\n<div class=\"codehilite\"><pre><span></span>   []\n0: [#0]\n1: [#0, #1]\n2: [#0, #1, #0]\n3: [#0, #1, #0, #0]\n4: [#0, #1, #1 #0 #0]\n5: [#0, #1 #1 (#1 #0 #0)]\n6: [#1 #0 (#1 #1 (#1 #0 #0))]\n</pre></div>\n\n\n<p>the final line returns the value on the stack, which is <code>#1 #0 (#1 #1 (#1 #0 #0))</code></p>",
        "id": 168209025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560607457
    },
    {
        "content": "<p>if you squint, you can read <code>#0</code> and <code>#1</code> as the constructors of both list and A, and see <code>cons a (cons b (cons a nil))</code></p>",
        "id": 168209035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560607522
    },
    {
        "content": "<p>aah of course I'd forgotten about <code>list.nil</code></p>",
        "id": 168209039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560607546
    },
    {
        "content": "<p>So <code>cons</code> and <code>list</code> and stuff are all being turned into bytecode. And the point is that <code>choice</code> cannot be turned into bytecode. So here is a proof</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">g</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">g_prop</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">has_right_inverse_of_surjective</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">g</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">g_prop</span> <span class=\"n\">hf</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>which cannot be made into a program and which is hence a counterexample to a completely naive interpretation of the Curry-Howard correspondence that \"proofs equal programs\".</p>",
        "id": 168209153,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560607771
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">compiler</span><span class=\"bp\">.</span><span class=\"n\">optimize_bytecode</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">b</span> <span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">sandbox3.lean:5:0: information trace output</span>\n<span class=\"cm\">[compiler.optimize_bytecode]  E 0</span>\n<span class=\"cm\">0: scnstr #0</span>\n<span class=\"cm\">1: cnstr #1 1</span>\n<span class=\"cm\">2: cnstr #1 1</span>\n<span class=\"cm\">3: ret</span>\n\n<span class=\"cm\">sandbox3.lean:6:0: information trace output</span>\n<span class=\"cm\">[compiler.optimize_bytecode]  F 0</span>\n<span class=\"cm\">0: scnstr #1</span>\n<span class=\"cm\">1: cfun nat.succ</span>\n<span class=\"cm\">2: ret</span>\n\n<span class=\"cm\">sandbox3.lean:7:0: information trace output</span>\n<span class=\"cm\">[compiler.optimize_bytecode]  G 0</span>\n<span class=\"cm\">0: scnstr #2</span>\n<span class=\"cm\">1: ret</span>\n<span class=\"cm\">-/</span>\n</pre></div>",
        "id": 168209268,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560607958
    },
    {
        "content": "<p>why are F and G different?</p>",
        "id": 168209270,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560607963
    },
    {
        "content": "<p>for some reason <code>nat.succ</code> was not optimized away in <code>F</code></p>",
        "id": 168209280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608000
    },
    {
        "content": "<p>why are all of them different?</p>",
        "id": 168209294,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560608031
    },
    {
        "content": "<p>Obviously the VM does not represent natural numbers as unary, so <code>succ (succ zero)</code> and <code>2</code> are not the same thing</p>",
        "id": 168209314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608042
    },
    {
        "content": "<p><code>2</code> is stored as a 2 in memory</p>",
        "id": 168209349,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608073
    },
    {
        "content": "<p>This <code>trace.compiler.optimize_bytecode</code> should win <code>set_option</code> option of the week.</p>",
        "id": 168209354,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560608086
    },
    {
        "content": "<p>lol</p>",
        "id": 168209357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608094
    },
    {
        "content": "<blockquote>\n<p>\\me remembers the old days</p>\n</blockquote>\n<p>In the old days it was <code>/me</code>...</p>",
        "id": 168209369,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560608124
    },
    {
        "content": "<p>/me thinks it still is</p>",
        "id": 168209373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608143
    },
    {
        "content": "<p>why is E and F different at all?</p>",
        "id": 168209378,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560608159
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">N</span> <span class=\"o\">:=</span> <span class=\"mi\">100000000</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">[compiler.optimize_bytecode]  N 0</span>\n<span class=\"cm\">0: scnstr #100000000</span>\n<span class=\"cm\">1: ret</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">def</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"mi\">10000000000</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">[compiler.optimize_bytecode]  M 0</span>\n<span class=\"cm\">0: num 10000000000</span>\n<span class=\"cm\">1: ret</span>\n<span class=\"cm\">-/</span>\n</pre></div>",
        "id": 168209379,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560608161
    },
    {
        "content": "<p><code>num</code> is for really big numbers that don't fit in the size of a small nat</p>",
        "id": 168209428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608203
    },
    {
        "content": "<p>which is something like 2^30</p>",
        "id": 168209433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608212
    },
    {
        "content": "<p>/me thinks <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is from the old days...</p>",
        "id": 168209434,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560608216
    },
    {
        "content": "<p>/me doesn't know how to use status messages properly</p>",
        "id": 168209443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608263
    },
    {
        "content": "<p>In the old days one used <code>.plan</code></p>",
        "id": 168209446,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560608281
    },
    {
        "content": "<p><code>#help options</code></p>\n<p>So much still to learn!</p>",
        "id": 168209489,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560608303
    },
    {
        "content": "<p>I remember disabling finger by creating a pipe called .plan somehow.</p>",
        "id": 168209494,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560608329
    },
    {
        "content": "<p>In the old days you could see if your friend had read your email to them by just fingering them.</p>",
        "id": 168209502,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560608352
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> E and F are different because lean has special support for the <code>nat</code> inductive type</p>",
        "id": 168209507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608393
    },
    {
        "content": "<p>Can we see the state of the stack machine easily?</p>",
        "id": 168209556,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560608429
    },
    {
        "content": "<p>One of the ideas in 3.5c is to make such overrides more obvious</p>",
        "id": 168209560,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608441
    },
    {
        "content": "<p>[I mean, in the middle of some calculation]</p>",
        "id": 168209566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560608453
    },
    {
        "content": "<p>I think there is a debugger but I've never used it</p>",
        "id": 168209568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608461
    },
    {
        "content": "<p>it's written in lean</p>",
        "id": 168209577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608483
    },
    {
        "content": "<p>I thought you wrote some code which somehow \"read\" olean files? Oh -- olean files are yet another thing somehow?</p>",
        "id": 168209579,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560608499
    },
    {
        "content": "<p>We're looking at the bytecode expressed in a far more sane way.</p>",
        "id": 168209583,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560608518
    },
    {
        "content": "<p>this is all actually somewhat unrelated to olean files</p>",
        "id": 168209626,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608569
    },
    {
        "content": "<p>olean files are basically a compressed representation of everything that goes in a lean file and all the stuff that is generated as a result of running it</p>",
        "id": 168209636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608603
    },
    {
        "content": "<p>the idea is that you can read an olean file and it will be just as good as reading the lean file but without having to run all the tactics</p>",
        "id": 168209641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608634
    },
    {
        "content": "<p>Wikipedia says that <a href=\"https://en.wikipedia.org/wiki/Lambda-mu_calculus\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Lambda-mu_calculus\">Lambda-mu</a> calculus has classical proofs as programs, where AoC and double-negation elimination map to continuations</p>",
        "id": 168209646,
        "sender_full_name": "Olli",
        "timestamp": 1560608642
    },
    {
        "content": "<p>right, that's the \"a bit weird\" part I mentioned. Double negation elimination has a computational implementation</p>",
        "id": 168209692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560608689
    },
    {
        "content": "<p>I know continuations are useful for implementing control flow / concurrency, so I suppose if a constructive proof describes an algorithm, then a classical proof is one that contains a step that says \"yes, let me get back to you on that\", in which case you could think of <code>sorry</code> as a type of continuation</p>",
        "id": 168210012,
        "sender_full_name": "Olli",
        "timestamp": 1560609223
    },
    {
        "content": "<p>I like to think of call/cc for LEM via oracles and time travel. You ask the oracle \"Is RH true?\" and it says NO, and gives you a token that says RH -&gt; false. You celebrate the resolution of the long standing problem, until one day when someone finds that RH is actually true. But when you confront the oracle with your proof of falsity, it takes your proof of RH, destroys the universe and rewinds to the original question, and when asked \"Is RH true?\" it says YES and gives you a bloodstained proof of RH, and you celebrate the resolution of the long standing problem.</p>",
        "id": 168210379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560609760
    },
    {
        "content": "<p>What about <code>choice()</code>?</p>",
        "id": 168212097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560612653
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2019/06/15/proofs-are-not-programs/\" target=\"_blank\" title=\"https://xenaproject.wordpress.com/2019/06/15/proofs-are-not-programs/\">https://xenaproject.wordpress.com/2019/06/15/proofs-are-not-programs/</a></p>\n<p>Hopefully I haven't garbled too much of this conversation.</p>",
        "id": 168216183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560619676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I think this is possible because of computable code:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">witt_add_zero</span> <span class=\"o\">:</span> <span class=\"n\">witt_add</span> <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">dec_trivial</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">witt_mul_zero</span> <span class=\"o\">:</span> <span class=\"n\">witt_mul</span> <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">dec_trivial</span>\n</pre></div>",
        "id": 168219453,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560625565
    },
    {
        "content": "<p>Lean is computing the addition and multiplication on the zeroth truncation of Witt vectors</p>",
        "id": 168219459,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560625596
    },
    {
        "content": "<p>Would rfl work?</p>",
        "id": 168219585,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560625857
    },
    {
        "content": "<p>Let me try.</p>",
        "id": 168219641,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560625951
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"n\">term</span>\n  <span class=\"n\">rfl</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"err\">?</span><span class=\"n\">m_2</span> <span class=\"bp\">=</span> <span class=\"err\">?</span><span class=\"n\">m_2</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">witt_add</span> <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 168219649,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560625978
    },
    {
        "content": "<p>Nope (-;</p>",
        "id": 168219654,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560625983
    },
    {
        "content": "<p>And that's not surprising. Because it isn't even close to being the definition of <code>witt_add</code>.</p>",
        "id": 168219667,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560626023
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> This is one reason (quite small, I agree) to keep polynomials computable.</p>",
        "id": 168219705,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560626043
    },
    {
        "content": "<p>I answered my own question about computable choice. The definition I suggested for computable choice is very much inconsistent. The definition was</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">choice</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">unquot</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>I claimed that this was a function, but it isn't. Using choice on `(id : trunc bool -&gt; trunc bool) gives nonsense</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">quot</span> <span class=\"n\">logic</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">choice</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">unquot</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">decidable_true</span> <span class=\"o\">(</span><span class=\"n\">choice</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)),</span> <span class=\"n\">trunc</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">rec_on_subsingleton</span> <span class=\"o\">(</span><span class=\"n\">choice</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">trunc</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">trunc</span> <span class=\"n\">bool</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">decidable_of_iff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">tt</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">ff</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">subsingleton</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">tt</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">ff</span><span class=\"o\">)]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">eq_self_iff_true</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"n\">decidable_true</span> <span class=\"bp\">@</span><span class=\"n\">choice</span> <span class=\"c1\">--ff</span>\n</pre></div>",
        "id": 170805335,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1563052175
    }
]
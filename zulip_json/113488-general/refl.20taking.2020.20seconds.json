[
    {
        "content": "<p>On my branch <a href=\"https://github.com/leanprover-community/mathlib/blob/spec_functor/src/algebraic_geometry/Spec.lean\">spec_functor</a>, I have a working version of the spectrum functor, from commutative rings to sheafed spaces (see below). Unfortunately, it is very slow and I don't know how to optimize it further... The bulk of the time is consumed by the very last <code>refl</code> in the proof of <code>map_comp</code>, which takes almost 20 seconds on my machine. I included a <code>change</code> right before to match up the terms, without that, it takes almost 40 seconds!</p>\n<p>One problem is that I can't use <code>rw</code> with the involved definitional equalities directly (mainly <code>Spec.Top_functor.map_comp</code>), because the <code>motive is not type correct</code>. My questions are: Can I trace what <code>refl</code> is doing somehow? And can I \"give some hints\" to the unifier to speed things up somehow? Thanks in advance for any help!</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Spec.functor_to_SheafedSpace</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">SheafedSpace</span> <span class=\"n\">CommRing</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">{</span>\n    <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">Spec.Top_functor.obj</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n    <span class=\"bp\">..</span><span class=\"n\">structure_sheaf</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span><span class=\"o\">)</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">{</span>\n    <span class=\"n\">base</span> <span class=\"o\">:=</span> <span class=\"n\">Spec.Top_functor.map</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n      <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">structure_sheaf.comap</span> <span class=\"n\">f.unop</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n        <span class=\"o\">((</span><span class=\"n\">topological_space.opens.map</span> <span class=\"o\">(</span><span class=\"n\">Spec.Top_functor.map</span> <span class=\"n\">f</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">U</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">iff.rfl</span><span class=\"o\">),</span>\n      <span class=\"n\">naturality'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ring_hom.ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">subtype.eq</span> <span class=\"bp\">$</span> <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n      <span class=\"kd\">begin</span>\n        <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">PresheafedSpace.mk_coe</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">category_theory.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">structure_sheaf.comap_apply</span><span class=\"o\">],</span>\n        <span class=\"n\">refl</span><span class=\"o\">,</span>\n      <span class=\"kd\">end</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">},</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">PresheafedSpace.ext</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Spec.Top_functor.map_id</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n    <span class=\"n\">category_theory.nat_trans.ext</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">$</span> <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">PresheafedSpace.mk_coe</span><span class=\"o\">,</span>\n      <span class=\"n\">Top.presheaf.pushforward_obj_obj</span><span class=\"o\">,</span> <span class=\"n\">Top.presheaf.pushforward_obj_map</span><span class=\"o\">,</span>\n      <span class=\"n\">functor.op_obj</span><span class=\"o\">,</span> <span class=\"n\">functor.op_map</span><span class=\"o\">,</span> <span class=\"n\">functor.comp_obj</span><span class=\"o\">,</span>\n      <span class=\"n\">nat_trans.comp_app</span><span class=\"o\">,</span> <span class=\"n\">nat_trans.op_app</span><span class=\"o\">,</span>\n      <span class=\"n\">SheafedSpace.id_base</span><span class=\"o\">,</span> <span class=\"n\">SheafedSpace.id_c_app</span><span class=\"o\">,</span>\n      <span class=\"n\">whisker_right_app</span><span class=\"o\">,</span> <span class=\"n\">topological_space.opens.map_iso_inv_app</span><span class=\"o\">,</span>\n      <span class=\"n\">unop_op</span><span class=\"o\">,</span> <span class=\"n\">unop_id</span><span class=\"o\">],</span>\n    <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">PresheafedSpace.id_c_app</span><span class=\"o\">,</span> <span class=\"n\">structure_sheaf.comap_id</span><span class=\"o\">],</span> <span class=\"n\">swap</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Spec.Top_functor.map_id</span><span class=\"o\">,</span> <span class=\"n\">topological_space.opens.map_id_obj_unop</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_to_hom_op</span><span class=\"o\">,</span> <span class=\"n\">eq_to_hom_map</span><span class=\"o\">,</span> <span class=\"n\">eq_to_hom_trans</span><span class=\"o\">],</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"n\">PresheafedSpace.ext</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Spec.Top_functor.map_comp</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n    <span class=\"n\">category_theory.nat_trans.ext</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">$</span> <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">PresheafedSpace.mk_coe</span><span class=\"o\">,</span>\n      <span class=\"n\">Top.presheaf.pushforward_obj_obj</span><span class=\"o\">,</span> <span class=\"n\">Top.presheaf.pushforward_obj_map</span><span class=\"o\">,</span>\n      <span class=\"n\">functor.op_obj</span><span class=\"o\">,</span> <span class=\"n\">functor.op_map</span><span class=\"o\">,</span> <span class=\"n\">functor.comp_obj</span><span class=\"o\">,</span>\n      <span class=\"n\">nat_trans.comp_app</span><span class=\"o\">,</span> <span class=\"n\">nat_trans.op_app</span><span class=\"o\">,</span>\n      <span class=\"n\">SheafedSpace.comp_base</span><span class=\"o\">,</span> <span class=\"n\">SheafedSpace.comp_c_app</span><span class=\"o\">,</span>\n      <span class=\"n\">whisker_right_app</span><span class=\"o\">,</span> <span class=\"n\">topological_space.opens.map_iso_inv_app</span><span class=\"o\">,</span>\n      <span class=\"n\">unop_op</span><span class=\"o\">,</span> <span class=\"n\">unop_comp</span><span class=\"o\">,</span> <span class=\"n\">eq_to_hom_refl</span><span class=\"o\">,</span> <span class=\"n\">category_theory.op_id</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Top.presheaf.pushforward.comp_inv_app</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">category.assoc</span><span class=\"o\">],</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Top.presheaf.pushforward_obj_obj</span><span class=\"o\">,</span> <span class=\"n\">functor.op_obj</span><span class=\"o\">,</span> <span class=\"n\">unop_op</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">structure_sheaf</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">presheaf.map_id</span><span class=\"o\">,</span>\n    <span class=\"n\">erw</span> <span class=\"n\">structure_sheaf.comap_comp</span> <span class=\"n\">g.unop</span> <span class=\"n\">f.unop</span> <span class=\"n\">_</span>\n      <span class=\"o\">((</span><span class=\"n\">topological_space.opens.map</span> <span class=\"o\">(</span><span class=\"n\">Spec.Top_functor.map</span> <span class=\"n\">g</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">U</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">≫</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">≫</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">≫</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n</div></div>",
        "id": 240452427,
        "sender_full_name": "Justus Springer",
        "timestamp": 1622115548
    },
    {
        "content": "<p>Does using <code>dsimp</code> before <code>refl</code> help?</p>",
        "id": 240452470,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622115581
    },
    {
        "content": "<p>Unfortunately not, <code>dsimp</code> fails, nothing gets simplified...</p>",
        "id": 240452833,
        "sender_full_name": "Justus Springer",
        "timestamp": 1622115759
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> What I usually do is to split the definition into smaller pieces. So I would start by giving</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span>  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">Spec.Top_functor.obj</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n    <span class=\"bp\">..</span><span class=\"n\">structure_sheaf</span> <span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n</code></pre></div>\n<p>it's own name. And if you stick <code>@[simps]</code> above that definition, Lean will automatically generate some useful simp-lemmas.</p>",
        "id": 240456289,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622117254
    },
    {
        "content": "<p>Then I would define <code>map</code> separately, and again stick <code>@[simps]</code> above it.</p>",
        "id": 240456312,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622117272
    },
    {
        "content": "<p>Those freshly generated <code>simp</code>-lemmas will then hopefully help to make the proofs of <code>map_id'</code> and <code>map_comp'</code> more manageable</p>",
        "id": 240456437,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622117322
    },
    {
        "content": "<p>Don't we have something on the website about this so-called <code>heavy refl</code>?</p>",
        "id": 240479646,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1622127152
    },
    {
        "content": "<p>For tracing what Lean is doing in a <code>rfl</code> proof (which should also work with <code>refl</code>), you can use:</p>\n<ul>\n<li><code>set_option trace.type_context.is_def_eq true</code></li>\n<li><code>set_option trace.type_context.is_def_eq_detail true</code></li>\n</ul>\n<p>(<span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> posted a list of helpful options here: <a href=\"#narrow/stream/113488-general/topic/your.20favourite.20set_option.20option/near/201825547\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/your.20favourite.20set_option.20option/near/201825547</a>)</p>",
        "id": 240488684,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1622130618
    },
    {
        "content": "<p>It would be good to add some of this info to our website too!</p>",
        "id": 240488716,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1622130630
    },
    {
        "content": "<p>Thanks for the replies!<br>\nI did not know about these options. As soon as I turn on <code>trace.type_context.is_def_eq_detail</code>, I get a timeout, which is probably not a good sign...</p>",
        "id": 240503319,
        "sender_full_name": "Justus Springer",
        "timestamp": 1622136739
    },
    {
        "content": "<p>I will try to split things up into smaller pieces, as Johan suggested.</p>",
        "id": 240503348,
        "sender_full_name": "Justus Springer",
        "timestamp": 1622136753
    }
]
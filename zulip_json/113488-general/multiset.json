[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120469\">@Ellen Arlt</span> and I are putting <code>multiset.lean</code> through its paces.</p>\n<p>Q1) This is perhaps a question about general lean/mathlib conventions disguised as a question about multisets. We have been working with multisets of size 0 and 1 and proving basic API lemmas. Initially I was using <code>∅</code> to denote the empty multiset (this is defined in mathlib, it's not my definition). I was surprised to find that <code>multiset.card (∅ : multiset α) = 0</code> was not a simp lemma (its proof is <code>rfl</code> but it can still be a simp lemma, right?) so I went to data.multiset to decide where to add it. And there I found that <code>multiset.card (0  : multiset α) = 0</code> <em>was</em> a simp lemma:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">multiset</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kn\">example</span>  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"err\">∅</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"err\">∅</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"c1\">-- fails</span>\n</pre></div>\n\n\n<p>Is this an example of the \"pecking order\" CS thing? Does it say \"yes, <code>∅</code> and <code>0</code> are the same multiset, but if you need to refer to this multiset then mathlib asks that you use <code>0</code>\"? If I'm right, how is one supposed to figure this sort of thing out? The hard way, like I did?</p>\n<p>Q2) <code>multiset.strong_induction_on</code> gives me a way of defining functions on multisets. But I am having trouble proving anything at all about such functions. I think I need some sensible eliminators for <code>multiset.strong_induction_on</code>, ideally the one that says that the function defined by <code>multiset.strong_induction_on</code> can be computed on a multiset if I can tell you its values on all proper subsets of the multiset. No doubt this eliminator is \"there already\" in some form -- but I don't know how to get to it.</p>",
        "id": 129522842,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531382540
    },
    {
        "content": "<p>This is a \"pecking order\" thing. I was remiss in not including a simp lemma <code>(∅ : multiset α) = 0</code> but it would have conveyed this intent well</p>",
        "id": 129522923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531382698
    },
    {
        "content": "<p>Alternatively, in hindsight perhaps it would have been better to make <code>∅</code> the primary one, since multisets have \"set\" in the name (as opposed to calling them <code>free_abelian_group</code> where <code>0</code> would be more natural)</p>",
        "id": 129522982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531382787
    },
    {
        "content": "<p>Just idle speculation, I suppose in a future unbundled class hierarchy we would rather have an instance <code>is_zero ∅ (multiset a)</code> instead of <code>has_zero (multiset a)</code>?</p>",
        "id": 129523047,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1531382908
    },
    {
        "content": "<p>So that there is no <code>(0  : multiset α)</code></p>",
        "id": 129523056,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1531382933
    },
    {
        "content": "<p>I suppose that depends on whether we want to use <code>0</code> as notation</p>",
        "id": 129523067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531382957
    },
    {
        "content": "<p>like I said, it makes sense if you want to use <code>multiset</code> as a free group generator</p>",
        "id": 129523070,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531382977
    },
    {
        "content": "<p>A related question is what I should be using for <code>{c}</code> = <code>c :: 0</code> = <code>c :: ∅</code>. Who is top of the tree here?</p>",
        "id": 129523118,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531383019
    },
    {
        "content": "<p><code>c::0</code> is used exclusively for singleton on <code>multiset</code></p>",
        "id": 129523122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531383045
    },
    {
        "content": "<p>For Q2, you can use this theorem:</p>\n<div class=\"codehilite\"><pre><span></span>theorem strong_induction_eq {p : multiset α → Sort*}\n  (s : multiset α) (H) : @strong_induction_on _ p s H =\n    H s (λ t h, @strong_induction_on _ p t H) :=\nby rw [strong_induction_on]\n</pre></div>\n\n\n<p>but the built in equation is also usable, as I did in the proof here</p>",
        "id": 129523196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531383138
    },
    {
        "content": "<p><code>c :: 0</code> -- Yes, I had spotted this. So I should always use this notation? I noticed in practice that if one sticks to the notation which is top of the tree, then random stuff just \"worked better\", e.g. I had a <code>split_ifs</code> nightmare scenario when all of a sudden I had four goals; I traced this back to \"sometimes using 0 and sometimes emptyset\" and when I started being consistent (initially with the wrong choice!) things got better.</p>",
        "id": 129523214,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531383195
    },
    {
        "content": "<p>yes, that's the name of the game</p>",
        "id": 129523222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531383219
    },
    {
        "content": "<p>These conventions are debatable, but the most important thing is to be consistent about them</p>",
        "id": 129523226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531383239
    },
    {
        "content": "<p>As for built in equations for arbitrary definitions, I only noticed that they existed about 20 minutes ago ;-) Thanks <span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> !</p>",
        "id": 129523266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531383256
    },
    {
        "content": "<p>the built in equations are much more important for wf definitions, since they are often not by <code>rfl</code></p>",
        "id": 129523271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531383295
    },
    {
        "content": "<p>(they are by rfl in theory, but this is where lean breaks from the theory so it proves them automatically instead)</p>",
        "id": 129523288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531383346
    },
    {
        "content": "<p>Conventions: I guess the second most important thing is to convey the conventions to your users. I am beginning to realise that these subtleties can actually be read off relatively easily by just reading the source. Presumably sometimes there is a genuine CS reason for choosing one over the other and sometimes it's just a fairly arbitrary choice.</p>",
        "id": 129523333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531383378
    },
    {
        "content": "<p>I currently spend three days a week surrounded by about 10 students most of whom know no Lean at all, and I am still amazed by how much their completely basic questions can teach me.</p>",
        "id": 129523337,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531383414
    },
    {
        "content": "<p>Does it give more momentum to your book writing effort?</p>",
        "id": 129524684,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531385330
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">v_empty</span> <span class=\"o\">:</span> <span class=\"n\">value_aux</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">value_aux</span><span class=\"o\">,</span> <span class=\"c1\">-- strong_induction hell</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span> <span class=\"c1\">-- goal now one page long</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span> <span class=\"c1\">-- goal now two pages long</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"c1\">-- goal now one line long and doesn&#39;t mention induction</span>\n  <span class=\"bp\">...</span>\n</pre></div>",
        "id": 129524832,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531385552
    },
    {
        "content": "<p>:-)</p>",
        "id": 129524833,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531385553
    },
    {
        "content": "<p>No -- in fact I spend all my time trying to answer their questions :-) What gives me momentum is that I give one Lean talk per week, and figuring out what to talk about seems to be the same as figuring out what I need to write about next. I am a terrible writer :-/ I am far too verbose. I need a good editor.</p>",
        "id": 129525185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531386124
    },
    {
        "content": "<p>The main function (<code>value_aux</code>) that I'm dealing with here is defined using two applications of <code>multiset.strong_induction_on</code>. The above lemma evaluates it on the empty set. To evaluate it on a singleton my code looks like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">v_one_chain</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">value_aux</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">::</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">value_aux</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- sanity prevails</span>\n</pre></div>\n\n\n<p>I am just over the moon that I can actually do things now, although I'm not entirely sure I like my <code>simp</code> style and the intermediate goals are huge.</p>",
        "id": 129525186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531386124
    },
    {
        "content": "<p>Do you know if <code>simp</code> always does the same thing here?</p>",
        "id": 129525210,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531386212
    },
    {
        "content": "<p><code>set_option trace.simplify.rewrite true</code> is your friend.</p>",
        "id": 129525257,
        "sender_full_name": "Sean Leather",
        "timestamp": 1531386294
    },
    {
        "content": "<p>If it happens to do always the same thing you can either write a new lemma or a specialized tactic</p>",
        "id": 129525281,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1531386352
    },
    {
        "content": "<p>I love the way that at 9:02am (UK time) I was <em>completely stuck</em> and now at 10:06am I have made huge progress in both my understanding of Lean and of the dots and boxes API. <span class=\"user-mention\" data-user-id=\"110045\">@Sean Leather</span> and <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I'm sure you're right -- I should figure out exactly what <code>simp</code> is doing. But I am now too busy excitedly proving all the trivial lemmas that Ellen wanted :-)</p>",
        "id": 129525381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531386489
    },
    {
        "content": "<p>You want to write an equation lemma for <code>value_aux</code>, similar to <code>strong_induction_eq</code></p>",
        "id": 129525383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531386492
    },
    {
        "content": "<p>How do I write an equation lemma? Is that just a useful lemma, possibly tagged simp, and called something like <code>value_aux.equation_37</code>?</p>",
        "id": 129525411,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531386586
    },
    {
        "content": "<p>Nothing special, you don't get to write equation lemmas like lean does</p>",
        "id": 129525459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531386628
    },
    {
        "content": "<p>you just give it a regular name and refer to it directly</p>",
        "id": 129525460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531386645
    },
    {
        "content": "<p>I would probably call it <code>value_aux_eq</code></p>",
        "id": 129525466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531386670
    },
    {
        "content": "<p>As I understand it, an equation lemma would be what you get (or want) naturally for each constructor of an inductive data type. The equation lemma spells out the equation to reduce/simplify the constructor application. Of course, your type doesn't have to be inductive, nor does it need to have more than one constructor, for you to have an equation lemma. It's really just a name for a particular kind of equality.</p>",
        "id": 129525525,
        "sender_full_name": "Sean Leather",
        "timestamp": 1531386839
    },
    {
        "content": "<p>Well, more precisely, you get an equation lemma for each branch of a definition. If it's a straight definition X = Y then you get just one equation, but if it is defined by cases or induction on an inductive type then you get an equation for each constructor, as you say</p>",
        "id": 129525911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531387346
    },
    {
        "content": "<p>Right, forgot about about that.</p>",
        "id": 129525924,
        "sender_full_name": "Sean Leather",
        "timestamp": 1531387376
    },
    {
        "content": "<p>So I had real trouble emulating <code>simp</code> and removing it from the middle of my proofs -- I think it was even rewriting things like <code>lam (h : a \\in c :: 0)</code> to <code>lam (h : a = c)</code> and my conv-fu wasn't strong enough. Chris convinced me to try rolling my own inductive definition -- he said it was so that my equation lemmas would be nicer, but I was motivated because I'd never done this sort of thing before. But I'm using induction twice: I am defining a function <code>value : multiset nat -&gt; multiset nat -&gt; nat</code> with the idea being that if I input <code>C</code> and <code>L</code> then I should be able to assume I can evaluate <code>value</code> at <code>C.erase c L</code> and <code>C L.erase l</code> with c in C and l in L. I should say that Chris' docs in the mathlib docs dir were invaluable.</p>\n<p>So I got it working, but here's the epilogue: I think the equation compiler might be performing a dangerous simp which I have no way of stopping. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> am I right? (this was the theory Chris and I came up with). Here's something which doesn't work:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">multiset</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">N_min</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"n\">def</span> <span class=\"n\">value_aux&#39;</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">multiset</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">C</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">N_min</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">pmap</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">C</span><span class=\"o\">),</span>\n<span class=\"c1\">--        have multiset.card (C.erase a) &lt; multiset.card C,</span>\n<span class=\"c1\">--          from multiset.card_lt_of_lt (multiset.erase_lt.2 h),</span>\n        <span class=\"k\">have</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">L</span> <span class=\"bp\">&lt;</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">C</span> <span class=\"bp\">+</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">L</span><span class=\"o\">,</span>\n          <span class=\"k\">from</span> <span class=\"n\">add_lt_add_right</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card_lt_of_lt</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">erase_lt</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n        <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">value_aux&#39;</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">))</span>\n        <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">pmap</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n<span class=\"c1\">--        have multiset.card (L.erase a) &lt; multiset.card L,</span>\n<span class=\"c1\">--          from multiset.card_lt_of_lt (multiset.erase_lt.2 h),</span>\n        <span class=\"k\">have</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">C</span> <span class=\"bp\">+</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">L</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">C</span> <span class=\"bp\">+</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">L</span><span class=\"o\">,</span>\n          <span class=\"k\">from</span> <span class=\"n\">add_lt_add_left</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card_lt_of_lt</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">erase_lt</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n        <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"mi\">4</span> <span class=\"bp\">+</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">-</span> <span class=\"n\">value_aux&#39;</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">a</span><span class=\"o\">)))</span>\n        <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"n\">id</span><span class=\"o\">))</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span><span class=\"n\">rel_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">measure_wf</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">CL</span><span class=\"o\">,</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">CL</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">+</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">CL</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">]}</span>\n</pre></div>\n\n\n<p>This is mostly noise -- the key thing to see is that I am taking as input two multisets, I am defining <code>value_aux</code> on the pair <code>C L</code> by a function which involves evaluating it on pairs <code>C' L</code> and <code>C L'</code> with <code>C'&lt;C</code> and <code>L'&lt;L</code> resp. The tactic I tell Lean to use to prove well-foundedness is, I think, the function sending <code>C L</code> to <code>card C + card L</code> (there's a <code>psigma</code> type involved, hopefully I got it right). The not-commented-out <code>have</code>s insert precisely what Lean needs to see a proof of, if I've understood things correctly. However the code above does not compile -- the equation compiler complains:</p>\n<div class=\"codehilite\"><pre><span></span>The nested exception contains the failure state for the decreasing tactic.\nnested exception message:\nfailed\nstate:\nvalue_aux&#39; : (Σ&#39; (a : multiset ℕ), multiset ℕ) → ℕ,\nC L : multiset ℕ,\na : ℕ,\nh : a ∈ C,\nthis : multiset.card (multiset.erase C a) + multiset.card L &lt; multiset.card C + multiset.card L\n⊢ multiset.card (multiset.erase C a) &lt; multiset.card C\n</pre></div>\n\n\n<p>Now that looks strange to me, because if I've understood correctly, <code>this</code> is <em>precisely</em> what the equation compiler wanted to see a proof of. Chris conjectures that <code>simp</code> got applied before <code>assumption</code>.  If I comment out the <code>have/from</code> pairs and replace with the commented-out ones, the code compiles fine (and my equation lemmas don't mention <code>multiset.rec</code> :-) ). Chris points out that if the behaviour of <code>simp</code> changes in the future, then my code breaks in a really obscure way and there's little I can do about it. Have we understood what's going on correctly?</p>",
        "id": 129566679,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531434178
    },
    {
        "content": "<p>Here's a method that avoids the simplifier</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">value_aux&#39;</span> <span class=\"o\">(</span><span class=\"n\">N_min</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">multiset</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">C</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">N_min</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">pmap</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">C</span><span class=\"o\">),</span>\n<span class=\"c1\">--        have multiset.card (C.erase a) &lt; multiset.card C,</span>\n<span class=\"c1\">--          from multiset.card_lt_of_lt (multiset.erase_lt.2 h),</span>\n        <span class=\"k\">have</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">L</span> <span class=\"bp\">&lt;</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">C</span> <span class=\"bp\">+</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">L</span><span class=\"o\">,</span>\n          <span class=\"k\">from</span> <span class=\"n\">add_lt_add_right</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card_lt_of_lt</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">erase_lt</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n        <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">value_aux&#39;</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">))</span>\n        <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">pmap</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n<span class=\"c1\">--        have multiset.card (L.erase a) &lt; multiset.card L,</span>\n<span class=\"c1\">--          from multiset.card_lt_of_lt (multiset.erase_lt.2 h),</span>\n        <span class=\"k\">have</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">C</span> <span class=\"bp\">+</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">L</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">C</span> <span class=\"bp\">+</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">L</span><span class=\"o\">,</span>\n          <span class=\"k\">from</span> <span class=\"n\">add_lt_add_left</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card_lt_of_lt</span> <span class=\"o\">(</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">erase_lt</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n        <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"mi\">4</span> <span class=\"bp\">+</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">-</span> <span class=\"n\">value_aux&#39;</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">a</span><span class=\"o\">)))</span>\n        <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"n\">id</span><span class=\"o\">))</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span><span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"n\">rel_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">measure_wf</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">CL</span><span class=\"o\">,</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">CL</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">+</span> <span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">CL</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">]}</span>\n</pre></div>",
        "id": 129568895,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1531436819
    },
    {
        "content": "<p>I changed the <code>dec_tac</code> at the bottom</p>",
        "id": 129568913,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1531436857
    },
    {
        "content": "<p>Yes, the standard fix when the default dec_tac is being stupid is to replace it with <code>tactic.assumption</code> like chris did</p>",
        "id": 129575356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531447158
    },
    {
        "content": "<p>Actually the default dec_tac doesn't use simp, it is a custom tactic that does a few heuristic rules to do with <a href=\"http://nat.lt\" target=\"_blank\" title=\"http://nat.lt\">nat.lt</a></p>",
        "id": 129575360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531447202
    },
    {
        "content": "<p>it is <code>default_dec_tac</code> in <code>well_founded_tactics.lean</code></p>",
        "id": 129575413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531447241
    },
    {
        "content": "<p>But I'm confused what the issue was that caused you to move away from the original version</p>",
        "id": 129575582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531447597
    },
    {
        "content": "<p>Short answer: I wanted to get rid of the dangerous simps and this approach (\"start again\") would have the advantage that it (a) might solve this and (b) would also teach me something (slightly complicated use of equation compiler). </p>\n<p>Long technical answer: Your original fix was fine modulo these dangerous simps. I was just talking to Chris about it and he said \"why did you even use <code>multiset.strong_induction_on</code> when you could use the equation compiler?\" and because I couldn't get rid of my dangerous <code>simp</code> and because I'd never used <code>using_well_founded</code> before I thought I'd give it a go to teach myself something (which turns out to be pretty easy to understand modulo the <code>lam _ _, </code>[exact` bit, which I'm leaving as a black box). Chris pointed out that one only had to use the equation compiler once, whereas I was using strong induction twice, so I felt that rewriting this was somehow going in the right direction.</p>\n<p>An example (two examples) of the dangerous simp in my original code looks like this: note that this is with <code>value_aux</code>, the version of my function which uses strong induction twice per application (as opposed to <code>value_aux'</code> above). </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">v_one_chain</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">≥</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">value_aux</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">::</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">value_aux</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"c1\">-- irritating-to-Patrick goal (c is a nat)</span>\n  <span class=\"n\">rw</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span><span class=\"n\">refine</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">sub_add_cancel</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>This uses Mario's eliminator for <code>strong_induction_on</code> and compiles fine. The issue of course is with the simps in the middle. Replacing the first <code>simp</code> with <code>dsimp</code> breaks the code. Before the first simp is applied, the goal is <a href=\"https://gist.github.com/kbuzzard/d9f70ae02b5861bbce0f8d958e16619a\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/d9f70ae02b5861bbce0f8d958e16619a\">https://gist.github.com/kbuzzard/d9f70ae02b5861bbce0f8d958e16619a</a> and after it's applied, the goal becomes (the still quite long) <a href=\"https://gist.github.com/kbuzzard/07495e93ed94b3d4e5bfd4015a52914f\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/07495e93ed94b3d4e5bfd4015a52914f\">https://gist.github.com/kbuzzard/07495e93ed94b3d4e5bfd4015a52914f</a> . These goals are too big for my liking and the direct approach seemed like it would be likely to make them smaller. There are <code>strong_induction_on</code>s around in these goals but the rewrites won't work without the first <code>simp</code>. Sean suggested <code>set_option trace.simplify.rewrite true</code> and the output of that on the first dangerous <code>simp</code> is <a href=\"https://gist.github.com/kbuzzard/1a01ad2bc29aad1c257452c4d2d894d5\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/1a01ad2bc29aad1c257452c4d2d894d5\">https://gist.github.com/kbuzzard/1a01ad2bc29aad1c257452c4d2d894d5</a> . I am certainly not a world expert in trace outputs, but I was interpreting the first line <code>0. [simplify.rewrite] [multiset.mem_singleton]: a ∈ c :: 0 ==&gt; a = c</code> of that trace output as meaning \"first we replace that <code>mem</code> term with an <code>eq</code> term\" but as far as I could see the only occurrences of <code>a ∈ c :: 0</code> were in terms like <code>(λ (a : ℕ) (h : a ∈ c :: 0), ...</code> and I could not do that rewrite with my bare hands (maybe I am just lame at <code>conv</code> but OTOH rewriting the type of a term is probably a dangerous business). In short, I couldn't remove the dangerous simp so I thought I'd try another approach.</p>",
        "id": 129585358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531466545
    },
    {
        "content": "<blockquote>\n<p>Actually the default dec_tac doesn't use simp, it is a custom tactic that does a few heuristic rules to do with <a href=\"http://nat.lt\" target=\"_blank\" title=\"http://nat.lt\">nat.lt</a></p>\n</blockquote>\n<p>PS that's good to know. Thanks. <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> it wasn't using <code>simp</code> after all. PPS I think <a href=\"https://nat.lt\" target=\"_blank\" title=\"https://nat.lt\">https://nat.lt</a> is in Lithuanian.</p>",
        "id": 129585364,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531466581
    },
    {
        "content": "<p>I think you may not have understood my suggestion to write an equation lemma</p>",
        "id": 129586991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469019
    },
    {
        "content": "<p>Here is a version of <code>value_aux'</code> that uses <code>strong_induction_on</code> for its definition (presumably this looks like your original definition, although you didn't show it here):</p>\n<div class=\"codehilite\"><pre><span></span>def value_aux (N_min : multiset ℕ → ℕ) (C : multiset ℕ) : multiset ℕ → ℕ :=\nmultiset.strong_induction_on C $ λ C IH₁ L,\nmultiset.strong_induction_on L $ λ L IH₂,\nN_min (\n  multiset.pmap\n    (λ a (h : a ∈ C),\n      a - 2 + int.nat_abs (2 - IH₁ (C.erase a) (multiset.erase_lt.2 h) L))\n    C (λ _, id) +\n  multiset.pmap\n    (λ a (h : a ∈ L),\n      a - 4 + int.nat_abs (4 - IH₂ (L.erase a) (multiset.erase_lt.2 h)))\n    L (λ _,id))\n</pre></div>",
        "id": 129587226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469408
    },
    {
        "content": "<p>[equation lemma] For sure that is true. Probably my question immediately after your comment indicated this. Sometimes I do stuff to learn more</p>",
        "id": 129587227,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469411
    },
    {
        "content": "<p>Yes, it looks pretty much like that</p>",
        "id": 129587233,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469430
    },
    {
        "content": "<p>except I used <code>C2</code> instead of <code>C</code> and <code>L2</code> instead of <code>L</code> because I am scared of free and bound variables having the same name</p>",
        "id": 129587242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469457
    },
    {
        "content": "<p>This is the equation lemma corresponding to that definition</p>\n<div class=\"codehilite\"><pre><span></span>theorem value_aux_eq (N_min : multiset ℕ → ℕ) (C L : multiset ℕ) :\n  value_aux N_min C L = N_min (\n    multiset.pmap\n      (λ a (h : a ∈ C),\n        a - 2 + int.nat_abs (2 - value_aux N_min (C.erase a) L))\n      C (λ _, id) +\n    multiset.pmap\n      (λ a (h : a ∈ L),\n        a - 4 + int.nat_abs (4 - value_aux N_min C (L.erase a)))\n      L (λ _,id)) := sorry\n</pre></div>",
        "id": 129587260,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469521
    },
    {
        "content": "<p>I don't understand your application of the \"equation lemma\" function.</p>",
        "id": 129587306,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469547
    },
    {
        "content": "<p>(Actually, you can simplify the <code>pmap</code> away the way it's been written here, since <code>h</code> is no longer used)</p>",
        "id": 129587310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469560
    },
    {
        "content": "<p>Is there an equation lemma corresponding to every definition?</p>",
        "id": 129587311,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469561
    },
    {
        "content": "<p>What is \"the equation lemma corresponding to nat\"?</p>",
        "id": 129587317,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469569
    },
    {
        "content": "<p>or \"the equation lemma corresponding to quotient.sound\" etc etc.</p>",
        "id": 129587323,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469584
    },
    {
        "content": "<p>Informally, an \"equation lemma\" says that a definition is what it was defined to be</p>",
        "id": 129587327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469588
    },
    {
        "content": "<p><code>nat</code> and <code>quotient.sound</code> don't have equation lemmas because they are constants, not defs</p>",
        "id": 129587334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469614
    },
    {
        "content": "<p><code>real</code>?</p>",
        "id": 129587341,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469623
    },
    {
        "content": "<p><code>def f : nat -&gt; nat := lam x, x + 3</code>?</p>",
        "id": 129587346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469637
    },
    {
        "content": "<p>It has an equation lemma, although you would rarely use it</p>",
        "id": 129587347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469638
    },
    {
        "content": "<p>that definitely does</p>",
        "id": 129587388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469645
    },
    {
        "content": "<p>it's something like \"forall x , f x = x + 3\"?</p>",
        "id": 129587394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469665
    },
    {
        "content": "<p>yes</p>",
        "id": 129587398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469669
    },
    {
        "content": "<p>Maybe I don't understand the _point_ then.</p>",
        "id": 129587400,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469680
    },
    {
        "content": "<p>Is it tagged as a simp lemma?</p>",
        "id": 129587403,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469686
    },
    {
        "content": "<p>Who is using these equation lemmas?</p>",
        "id": 129587406,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469693
    },
    {
        "content": "<p>sometimes it's a simp lemma</p>",
        "id": 129587407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469699
    },
    {
        "content": "<p>?!</p>",
        "id": 129587410,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469704
    },
    {
        "content": "<p>Who makes the decision?</p>",
        "id": 129587415,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469711
    },
    {
        "content": "<p>it gets used whenever you \"unfold the definition\"</p>",
        "id": 129587416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469713
    },
    {
        "content": "<p>Aah!</p>",
        "id": 129587420,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469721
    },
    {
        "content": "<p>When I use unfold, sometimes it says that <code>simp</code> failed</p>",
        "id": 129587425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469733
    },
    {
        "content": "<p>some definitions are marked <code>@[simp]</code> meaning that their equation lemmas are simp lemmas</p>",
        "id": 129587427,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469739
    },
    {
        "content": "<p>You can tag a definition with simp? I am not sure I ever internalised that</p>",
        "id": 129587434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469760
    },
    {
        "content": "<p>like list.append</p>\n<div class=\"codehilite\"><pre><span></span>@[simp] protected def append : list α → list α → list α\n| []       l := l\n| (h :: s) t := h :: (append s t)\n</pre></div>",
        "id": 129587478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469777
    },
    {
        "content": "<p>This marks this definition's two (!) equation lemmas as simp lemmas</p>",
        "id": 129587481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469800
    },
    {
        "content": "<p>I can see all the equation lemmas with <code>#print prefix list.append</code> perhaps</p>",
        "id": 129587493,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469826
    },
    {
        "content": "<p>yes</p>",
        "id": 129587498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469833
    },
    {
        "content": "<p>So I must confess that I've never really understood the output of that sort of command.</p>",
        "id": 129587503,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469852
    },
    {
        "content": "<p>We have <code>_main</code>, <code>_main._meta_aux</code> etc</p>",
        "id": 129587504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469860
    },
    {
        "content": "<p>it's quite intimidating</p>",
        "id": 129587506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469863
    },
    {
        "content": "<p>But sometimes lean doesn't generate equation lemmas the way you would like them, so you have to write your own, and that's my point</p>",
        "id": 129587508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469864
    },
    {
        "content": "<p>I am still missing a big issue</p>",
        "id": 129587596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469909
    },
    {
        "content": "<p>OK so I wrote my function</p>",
        "id": 129587600,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469918
    },
    {
        "content": "<p>and the equation lemmas are all wrong</p>",
        "id": 129587603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469925
    },
    {
        "content": "<p>so I need to write another one.</p>",
        "id": 129587606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469929
    },
    {
        "content": "<p>For example, here's another way to write list.append</p>\n<div class=\"codehilite\"><pre><span></span>def list.append&#39; {α} (l₁ l₂ : list α) : list α :=\nlist.rec_on l₁ l₂ (λ a l₁ IH, a :: IH)\n</pre></div>",
        "id": 129587613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469954
    },
    {
        "content": "<p>OK so I wrote one: \"<code>theorem X : f x = g x -- this is the equation lemma I want</code>\"</p>",
        "id": 129587614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469957
    },
    {
        "content": "<p>that's a lemma</p>",
        "id": 129587617,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469975
    },
    {
        "content": "<p>Is it an equation lemma?</p>",
        "id": 129587618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531469980
    },
    {
        "content": "<p>the equation lemmas are not what we would like</p>\n<div class=\"codehilite\"><pre><span></span>#print prefix list.append&#39;\n-- list.append&#39; : Π {α : Type u_1}, list α → list α → list α\n-- list.append&#39;.equations._eqn_1 : ∀ {α : Type u_1} (l₁ l₂ : list α),\n--   list.append&#39; l₁ l₂ = list.rec_on l₁ l₂ (λ (a : α) (l₁ IH : list α), a :: IH)\n</pre></div>",
        "id": 129587620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531469987
    },
    {
        "content": "<p>why not?</p>",
        "id": 129587662,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470007
    },
    {
        "content": "<p>What's wrong with them?</p>",
        "id": 129587669,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470010
    },
    {
        "content": "<p>I don't understand several things</p>",
        "id": 129587672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470013
    },
    {
        "content": "<p>\"equation lemmas are used in unfold\"</p>",
        "id": 129587680,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470026
    },
    {
        "content": "<p>\"sometimes they're simp lemmas\"</p>",
        "id": 129587681,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470029
    },
    {
        "content": "<p>While it is true that append is equal to that rec_on mess, that's not what I want to see</p>",
        "id": 129587684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470033
    },
    {
        "content": "<p>\"they're generated automatically\"</p>",
        "id": 129587687,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470038
    },
    {
        "content": "<p>that's about all I know</p>",
        "id": 129587692,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470044
    },
    {
        "content": "<p>about equation lemmas</p>",
        "id": 129587693,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470048
    },
    {
        "content": "<p>I am missing some fundamental point about why they exist and why they're important</p>",
        "id": 129587694,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470059
    },
    {
        "content": "<p>\"if you write a definition, Lean generates a bunch of lemmas with obscure names\"</p>",
        "id": 129587705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470077
    },
    {
        "content": "<p>what I want to see are the things that the definition is trying to say, namely <code>list.append [] l = l</code> and <code>list.append (a::l) l' = a :: list.append l l'</code></p>",
        "id": 129587706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470083
    },
    {
        "content": "<p>This is really important for controlling the complexity of statements</p>",
        "id": 129587710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470105
    },
    {
        "content": "<p>\"if you write the definition differently, you might get different lemmas, and Mario can see that this might cause problems but Kevin still has no understanding of when equation lemmas are used so doesn't care what these auto-generated lemmas are\"</p>",
        "id": 129587714,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470116
    },
    {
        "content": "<p>if every time you used <code>nat.add</code> it unfolded to its definition it would be utterly unreadable</p>",
        "id": 129587753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470124
    },
    {
        "content": "<p>it can't unfold</p>",
        "id": 129587756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470136
    },
    {
        "content": "<p>oh wit</p>",
        "id": 129587760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470141
    },
    {
        "content": "<p>oh wait</p>",
        "id": 129587761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470144
    },
    {
        "content": "<p>is <code>nat.add</code> one of these things whose definition is not what I think it is?</p>",
        "id": 129587766,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470155
    },
    {
        "content": "<p>Is it not 0 -&gt; x, succ y -&gt; succ (x+y)?</p>",
        "id": 129587771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470169
    },
    {
        "content": "<p>really making progress in this proof:</p>\n<div class=\"codehilite\"><pre><span></span>example (x : ℕ) : 0 + x = 0 :=\nbegin\n  dsimp only [(+)], delta nat.add,\n-- ⊢ nat.brec_on x\n--       (λ (a : ℕ) (_F : nat.below (λ (a : ℕ), ℕ → ℕ) a) (a_1 : ℕ),\n--          (λ (a a_1 : ℕ) (_F : nat.below (λ (a : ℕ), ℕ → ℕ) a_1),\n--             nat.cases_on a_1 (λ (_F : nat.below (λ (a : ℕ), ℕ → ℕ) 0), id_rhs ℕ a)\n--               (λ (a_1 : ℕ) (_F : nat.below (λ (a : ℕ), ℕ → ℕ) (nat.succ a_1)),\n--                  id_rhs ℕ (nat.succ ((_F.fst).fst a)))\n--               _F)\n--            a_1\n--            a\n--            _F)\n--       0 =\n--     0\nend\n</pre></div>",
        "id": 129587783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470196
    },
    {
        "content": "<p>I'm already lost, apparently it's <code>nat.add._main</code></p>",
        "id": 129587788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470208
    },
    {
        "content": "<p>that does not look good</p>",
        "id": 129587790,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470217
    },
    {
        "content": "<p>If <code>simp</code> did this Leo would be fired by now</p>",
        "id": 129587794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470236
    },
    {
        "content": "<p>The problem has occurred because <code>nat.add</code> is for some reason defined in a stupid way</p>",
        "id": 129587847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470263
    },
    {
        "content": "<p>I fixed this up in my blog IIRC</p>",
        "id": 129587858,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470281
    },
    {
        "content": "<p>no, the problem has occurred because I unfolded the definition without folding it back up again</p>",
        "id": 129587861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470285
    },
    {
        "content": "<p>Does the equation compiler create that monstrosity?</p>",
        "id": 129587877,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470313
    },
    {
        "content": "<p>Even if I defined <code>nat.add</code> the simple way, it would still not be pretty to look at</p>",
        "id": 129587879,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470314
    },
    {
        "content": "<p>oh holy moley</p>",
        "id": 129587885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470331
    },
    {
        "content": "<p>I want to see <code>0 + x</code> not <code>nat.rec bla bla</code></p>",
        "id": 129587887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470332
    },
    {
        "content": "<p><code>nat.add</code> is defined sensibly in <code>core.lean</code></p>",
        "id": 129587893,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470352
    },
    {
        "content": "<p>what has the equation compiler done??</p>",
        "id": 129587913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470362
    },
    {
        "content": "<p>The equation lemmas say things like <code>x + succ y = succ (x + y)</code></p>",
        "id": 129587936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470366
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">nat</span>\n  <span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span>  <span class=\"n\">zero</span>     <span class=\"o\">:=</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span>  <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 129587941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470378
    },
    {
        "content": "<p>That got turned into the monstrosity</p>",
        "id": 129587945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470388
    },
    {
        "content": "<p>this is true by rfl, but the really important thing is that the RHS does not have <code>nat.rec</code> in it</p>",
        "id": 129587949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470397
    },
    {
        "content": "<p>or <code>nat.brec_on</code> or its cousins</p>",
        "id": 129587960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470412
    },
    {
        "content": "<p>Right -- Chris was stressing the importance of getting away from <code>multiset.rec</code></p>",
        "id": 129587973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470423
    },
    {
        "content": "<p>which I had in my initial equation lemmas for the value function</p>",
        "id": 129587994,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470436
    },
    {
        "content": "<p>In fact, you could say that's the main purpose of equation lemmas, to hide recursors</p>",
        "id": 129587998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470444
    },
    {
        "content": "<p>actually it's even worse, my equation lemmas for value have strong induction in</p>",
        "id": 129588018,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470475
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>value_aux.equations._eqn_1 : ∀ (C : multiset ℕ),\n  value_aux C =\n    multiset.strong_induction_on C\n      (λ (C2 : multiset ℕ) (HC : Π (t : multiset ℕ), t &lt; C2 → multiset ℕ → ℕ) (L : multiset ℕ),\n         multiset.strong_induction_on L\n           (λ (L2 : multiset ℕ) (HL : Π (t : multiset ℕ), t &lt; L2 → ℕ),\n              multiset.N_min\n                (multiset.pmap\n                     (λ (a : ℕ) (h : a ∈ C2), a - 2 + int.nat_abs (2 - ↑(HC (multiset.erase C2 a) _ L2)))\n                     C2\n                     _ +\n                   multiset.pmap\n                     (λ (a : ℕ) (h : a ∈ L2), a - 4 + int.nat_abs (4 - ↑(HL (multiset.erase L2 a) _)))\n                     L2\n                     _)))\n</pre></div>",
        "id": 129588062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470488
    },
    {
        "content": "<p>Can you tell me a formal definition of which parts of the output of <code>#print prefix value_aux</code> are the equation lemmas?</p>",
        "id": 129588080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470528
    },
    {
        "content": "<p>Is it precisely those which start <code>value_aux.equation...</code>?</p>",
        "id": 129588084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470538
    },
    {
        "content": "<p>yes, those are the automatically generated equation lemmas</p>",
        "id": 129588095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470554
    },
    {
        "content": "<p>because I have other things like the stunning observation <code>value_aux._proof_4 : ∀ (L2 : multiset ℕ) (_x : ℕ), _x ∈ L2 → _x ∈ L2</code></p>",
        "id": 129588097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470560
    },
    {
        "content": "<p>Is that an equation lemma?</p>",
        "id": 129588103,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470572
    },
    {
        "content": "<p>I don't know what I'd do without that lemma</p>",
        "id": 129588109,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470592
    },
    {
        "content": "<p>those are extracting proof terms inside non-proof terms for performance</p>",
        "id": 129588114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470601
    },
    {
        "content": "<p>but not equation lemmas.</p>",
        "id": 129588166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470629
    },
    {
        "content": "<p>the extraction code isn't so bright</p>",
        "id": 129588167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470629
    },
    {
        "content": "<p>equation lemmas are equations</p>",
        "id": 129588176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470648
    },
    {
        "content": "<p>OK so when I make a new definition, Lean makes some equation lemmas, and we've seen examples where these lemmas are in some sense unusable</p>",
        "id": 129588181,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470653
    },
    {
        "content": "<p>right</p>",
        "id": 129588183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470662
    },
    {
        "content": "<p>so now all I need to know is</p>",
        "id": 129588189,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470666
    },
    {
        "content": "<p>(1) what is actually using them and (2) how to write better ones</p>",
        "id": 129588193,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470676
    },
    {
        "content": "<p>When you write a definition you should already have in mind what its equation lemmas are</p>",
        "id": 129588196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470695
    },
    {
        "content": "<p>In this case, you knew you wanted <code>value_aux</code> to depend on itself at other values</p>",
        "id": 129588202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470719
    },
    {
        "content": "<p>If we go back to <code>nat.add</code> I can see <code>x + succ y = succ (x + y)</code> would be the sort of thing that as an end user I would simply _assume_ was true by <code>rfl</code>, given the definition</p>",
        "id": 129588203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470720
    },
    {
        "content": "<p>which is where something like this comes from</p>\n<div class=\"codehilite\"><pre><span></span>theorem value_aux_eq (N_min : multiset ℕ → ℕ) (C L : multiset ℕ) :\n  value_aux N_min C L = N_min (\n    C.map (λ a, a - 2 + int.nat_abs (2 - value_aux N_min (C.erase a) L)) +\n    C.map (λ a, a - 4 + int.nat_abs (4 - value_aux N_min C (L.erase a)))) := sorry\n</pre></div>",
        "id": 129588249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470733
    },
    {
        "content": "<p>Right -- I feel like I want that theorem to be true by <code>rfl</code></p>",
        "id": 129588256,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470760
    },
    {
        "content": "<p>because in my non-CS mathematical mind that is \"exactly how I defined the function\"</p>",
        "id": 129588258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470775
    },
    {
        "content": "<p>that theorem is \"true by definition\"</p>",
        "id": 129588265,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470792
    },
    {
        "content": "<p>exactly</p>",
        "id": 129588266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470795
    },
    {
        "content": "<p>but funnily enough I don't see it in my list of equation lemmas</p>",
        "id": 129588272,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470807
    },
    {
        "content": "<p>Half of the work is taking your \"definition\" and turning it into something lean will accept, and the other half is getting back to the original thing you wanted to call the definition</p>",
        "id": 129588277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470835
    },
    {
        "content": "<p>that latter step is the equation lemma</p>",
        "id": 129588318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470844
    },
    {
        "content": "<p>I had never remotely comprehended this.</p>",
        "id": 129588327,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470855
    },
    {
        "content": "<p>I thought that \"Lean did the second part automatically\"</p>",
        "id": 129588329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470865
    },
    {
        "content": "<p>it does, for the most part</p>",
        "id": 129588331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470872
    },
    {
        "content": "<p>but it's not perfect, it doesn't accept every definitionesque thing mathematicians dream up</p>",
        "id": 129588351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470898
    },
    {
        "content": "<p>OK so let's say I can prove the lemma which I thought should be <code>rfl</code> but which wasn't.</p>",
        "id": 129588352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470903
    },
    {
        "content": "<p>Is it just a case of making sure that lemma is called <code>value_aux.equations._eqn_2</code>?</p>",
        "id": 129588361,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470921
    },
    {
        "content": "<p>Unfortunately, lean doesn't let you install your own equation lemmas like that</p>",
        "id": 129588373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470947
    },
    {
        "content": "<p>OK so we're back to (1) I don't know how to make a lemma into an equation lemma and (2) I don't know exactly what is using the equation lemmas and when</p>",
        "id": 129588414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470967
    },
    {
        "content": "<p>when you right your own equation lemma, it's just a theorem, an equality you can use in rewrite and simp</p>",
        "id": 129588416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470972
    },
    {
        "content": "<p>and rfl</p>",
        "id": 129588417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470981
    },
    {
        "content": "<p>because equation lemmas are true by definition, right? :-)</p>",
        "id": 129588420,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531470989
    },
    {
        "content": "<p>If you prove it by <code>rfl</code> you can also use it in <code>dsimp</code></p>",
        "id": 129588421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531470995
    },
    {
        "content": "<p>Sometimes it's <code>rfl</code> sometimes not</p>",
        "id": 129588424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471010
    },
    {
        "content": "<p>If it's not <code>rfl</code> then Lean made a mistake</p>",
        "id": 129588425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471020
    },
    {
        "content": "<p>because the equation lemmas are the things which are true by definition</p>",
        "id": 129588430,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471031
    },
    {
        "content": "<p>for more elaborate definitional mechanisms, DTT doesn't recognize it as definitional but you can still prove it with some work</p>",
        "id": 129588433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471052
    },
    {
        "content": "<p>OK</p>",
        "id": 129588436,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471062
    },
    {
        "content": "<p>so now I proved a lemma, the proof unfortunately wasn't <code>rfl</code>, I want to use it everywhere because in my brain the lemma is \"true by definition of the object\".</p>",
        "id": 129588478,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471083
    },
    {
        "content": "<p>Now what?</p>",
        "id": 129588480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471085
    },
    {
        "content": "<p>In particular, I doubt <code>value_aux_eq</code> is true by <code>rfl</code>, particularly when I changed the <code>pmap</code> to <code>map</code></p>",
        "id": 129588483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471092
    },
    {
        "content": "<p>Yes i can quite believe it's not</p>",
        "id": 129588488,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471103
    },
    {
        "content": "<p>not least because <code>value_aux</code> uses <code>multiset.strong_induction_on</code> <em>twice</em></p>",
        "id": 129588493,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471117
    },
    {
        "content": "<p>but it is nevertheless \"the way we want it to unfold\" so we treat it as the equation lemma</p>",
        "id": 129588497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471128
    },
    {
        "content": "<p>\"so we treat it as the equation lemma\" is the bit I don't get</p>",
        "id": 129588499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471140
    },
    {
        "content": "<p>Are you just saying \"prove a lemma and then occasionally <code>rw</code> with it\"?</p>",
        "id": 129588508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471154
    },
    {
        "content": "<p>It just means we use that theorem when we would otherwise \"unfold <code>value_aux</code>\"</p>",
        "id": 129588512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471165
    },
    {
        "content": "<p>So </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">v_one_chain</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">≥</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">value_aux</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">::</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">value_aux</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">strong_induction_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"bp\">...</span>\n</pre></div>\n\n\n<p>is not the right approach?</p>",
        "id": 129588521,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471196
    },
    {
        "content": "<p>no</p>",
        "id": 129588566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471208
    },
    {
        "content": "<p>even though I have the right equation lemma?</p>",
        "id": 129588568,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471211
    },
    {
        "content": "<p>(I assume I do, I think you wrote it)</p>",
        "id": 129588570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471219
    },
    {
        "content": "<p>you want to use the equation lemma for <code>value_aux</code>, not the equation lemma for <code>strong_induction_on</code></p>",
        "id": 129588588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471245
    },
    {
        "content": "<p>you will use the latter to prove the former</p>",
        "id": 129588593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471252
    },
    {
        "content": "<p>aah</p>",
        "id": 129588597,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471261
    },
    {
        "content": "<p>aah I was thinking \"Mario said to use an equation lemma, I don't know what that is, I think Mario wrote it for me, I'll just use that\"</p>",
        "id": 129588613,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471311
    },
    {
        "content": "<p>So an equation lemma is just a lemma, with no magic properties, it doesn't have to have a weird name like <code>foo._equation_7_main_sunfold</code></p>",
        "id": 129588682,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471363
    },
    {
        "content": "<p>no, that's just the usual name for lean's autogenerated equation lemmas</p>",
        "id": 129588688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471384
    },
    {
        "content": "<p>what makes it an equation lemma is that it represents a fact which the end user would like to think was \"true by definition\"</p>",
        "id": 129588691,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471390
    },
    {
        "content": "<p>if they were a wooly thinker, like e.g. a pure mathematician</p>",
        "id": 129588696,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471408
    },
    {
        "content": "<p>those get some special magic, like being able to write <code>simp [f]</code> instead of <code>simp [f.equations_1]</code></p>",
        "id": 129588701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471413
    },
    {
        "content": "<p>Yes, I learnt that yesterday</p>",
        "id": 129588706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471424
    },
    {
        "content": "<p>OK so let me step back and try to wrap up</p>",
        "id": 129588752,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471448
    },
    {
        "content": "<p>When I write a definition, I might want to consider what the fundamental properties of that definition are -- the things which <em>should</em> be \"true by definition\"</p>",
        "id": 129588761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471476
    },
    {
        "content": "<p>or \"true because it's completely obvious\"</p>",
        "id": 129588768,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471492
    },
    {
        "content": "<p>and then I might want to look at the subset of the output of <code>#print prefix foo</code> consisting only of things which have the string \"equation\" in them</p>",
        "id": 129588781,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471520
    },
    {
        "content": "<p>and I might want to just check that everything I want to be \"true by definition\" is there</p>",
        "id": 129588789,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471536
    },
    {
        "content": "<p>The autogenerated equation lemmas are easy to predict without looking at them like that</p>",
        "id": 129588797,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471551
    },
    {
        "content": "<p>and if it's not then I might want to make a note of this, prove the remaining facts, and then spend the rest of my life rewriting with them</p>",
        "id": 129588801,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471559
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Perhaps “true by the definition you wished it had”? “True because it's obvious” is maybe too generous in what it allows.</p>",
        "id": 129588845,
        "sender_full_name": "Sean Leather",
        "timestamp": 1531471579
    },
    {
        "content": "<blockquote>\n<p>The autogenerated equation lemmas are easy to predict without looking at them like that</p>\n</blockquote>\n<p>says someone who has probably looked at the code which generates them</p>",
        "id": 129588846,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471583
    },
    {
        "content": "<p>for each branch of the definition, each <code>:=</code>, you get a lemma saying your definition applied to those arguments gives the RHS</p>",
        "id": 129588847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471583
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110045\">@Sean Leather</span> that's a better way of phrasing it. My definition of value by \"induction on (induction on ...)\" was never going to create the lemma I wanted</p>",
        "id": 129588859,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471622
    },
    {
        "content": "<p>but on the other hand there was clearly a definition which in some sense I \"wished I had written\"</p>",
        "id": 129588880,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471656
    },
    {
        "content": "<p>and that was precisely the definition I _did_ write yesterday, using the equation compiler</p>",
        "id": 129588887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471666
    },
    {
        "content": "<p>So all this stinks. There are things which should be true by <code>rfl</code> but which I can't prove with <code>rfl</code></p>",
        "id": 129588931,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471697
    },
    {
        "content": "<p>One place where you might be surprised is in definitions with wildcards</p>\n<div class=\"codehilite\"><pre><span></span>def X {α} : list α → list α → list α\n| [] _ := []\n| _ [] := []\n| x y := x\n#print prefix X\n-- X.equations._eqn_1 : ∀ {α : Type u_1}, X list.nil list.nil = list.nil\n-- X.equations._eqn_2 : ∀ {α : Type u_1} (hd : α) (tl : list α), X list.nil (hd :: tl) = list.nil\n-- X.equations._eqn_3 : ∀ {α : Type u_1} (hd : α) (tl : list α), X (hd :: tl) list.nil = list.nil\n-- X.equations._eqn_4 : ∀ {α : Type u_1} (hd : α) (tl : list α) (hd_1 : α) (tl_1 : list α), X (hd :: tl) (hd_1 :: tl_1) = hd :: tl\n</pre></div>",
        "id": 129588932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471699
    },
    {
        "content": "<p>notice that <code>X x y = x</code> is not an equation lemma since it has to do some case splits first</p>",
        "id": 129588944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471735
    },
    {
        "content": "<p>right</p>",
        "id": 129588952,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471751
    },
    {
        "content": "<p>that all makes sense to me</p>",
        "id": 129588953,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471754
    },
    {
        "content": "<p>that's a lemma, that X x y = x</p>",
        "id": 129588957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471765
    },
    {
        "content": "<p>actually it's perhaps not even true but I see your point whether or not this example is exactly right</p>",
        "id": 129588976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471802
    },
    {
        "content": "<p>So I prove this lemma by cases on x</p>",
        "id": 129589020,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471823
    },
    {
        "content": "<p>and then I decree in my head that this is an equation lemma</p>",
        "id": 129589033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471839
    },
    {
        "content": "<p>Maybe a better example of an equation lemma for this one is <code>X [] y = []</code> and <code>X x [] = []</code></p>",
        "id": 129589045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471861
    },
    {
        "content": "<p>Neither of these is true by rfl</p>",
        "id": 129589054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471876
    },
    {
        "content": "<p>yes</p>",
        "id": 129589055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471876
    },
    {
        "content": "<p>both proof by cases</p>",
        "id": 129589063,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471883
    },
    {
        "content": "<p>These look like simp lemmas to me</p>",
        "id": 129589069,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471890
    },
    {
        "content": "<p>They are that too</p>",
        "id": 129589076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471899
    },
    {
        "content": "<p>So an equation lemma seems to me to have no formal definition</p>",
        "id": 129589080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471910
    },
    {
        "content": "<p>equation lemmas are often good simp lemmas</p>",
        "id": 129589082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471917
    },
    {
        "content": "<p>it's \"something which the user is clearly going to need again and again\"</p>",
        "id": 129589123,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471929
    },
    {
        "content": "<p>so should probably be proved immediately after the definition</p>",
        "id": 129589129,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471940
    },
    {
        "content": "<p>but sometimes they would lead to infinite unfolding, like the equation lemma for <code>value_aux</code></p>",
        "id": 129589134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471945
    },
    {
        "content": "<p>I think nat is well-founded</p>",
        "id": 129589143,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531471963
    },
    {
        "content": "<p>equation lemmas for wf definitions often have that problem</p>",
        "id": 129589148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471965
    },
    {
        "content": "<p><code>gcd x y</code> unfolds forever when given <em>variable</em> <code>x</code> and <code>y</code></p>",
        "id": 129589161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531471984
    },
    {
        "content": "<p>Oh!</p>",
        "id": 129589173,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531472005
    },
    {
        "content": "<p>it doesn't matter that nat is well founded</p>",
        "id": 129589177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531472008
    },
    {
        "content": "<p>Oh you're absolutely right!</p>",
        "id": 129589180,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531472010
    },
    {
        "content": "<p>because these are open terms</p>",
        "id": 129589195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531472020
    },
    {
        "content": "<p>We're not doing case splits on constructors for multiset or whatever</p>",
        "id": 129589197,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531472023
    },
    {
        "content": "<p>oh so that lemma is actually quite dangerous!</p>",
        "id": 129589205,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531472037
    },
    {
        "content": "<p>Shall I make it a simp lemma?</p>",
        "id": 129589246,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531472044
    },
    {
        "content": "<p>yes, you only want to use it with <code>rw</code> or <code>simp {single_pass := tt}</code></p>",
        "id": 129589257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531472059
    },
    {
        "content": "<p>right</p>",
        "id": 129589266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531472065
    },
    {
        "content": "<p>it should definitely not be a simp lemma</p>",
        "id": 129589273,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531472073
    },
    {
        "content": "<p>right!</p>",
        "id": 129589278,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531472077
    },
    {
        "content": "<p>I gave an entire lecture on functions last Monday</p>",
        "id": 129589302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531472109
    },
    {
        "content": "<p>I feel like I could give another one now</p>",
        "id": 129589305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531472113
    },
    {
        "content": "<p>:)</p>",
        "id": 129589309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1531472118
    },
    {
        "content": "<p>Many thanks as ever Mario.</p>",
        "id": 129589315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531472129
    },
    {
        "content": "<p>What's nice about zulip rather than IRL meetings is that now I understand much better I can just read through the thread again with the benefit of hindsight and try to catch extra subtleties.</p>",
        "id": 129589518,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531472365
    },
    {
        "content": "<blockquote>\n<p>Half of the work is taking your \"definition\" and turning it into something lean will accept, and the other half is getting back to the original thing you wanted to call the definition</p>\n</blockquote>\n<p>This is somehow the key point. I have quite a flexible way of thinking about definitions and their basic properties, I guess because mathematicians are trained like that. Some properties of a definition are so completely basic that I think I've got into the habit of simply <em>assuming</em> that they will be (a) true and (b) <code>rfl</code>. For simple functions this might well be the case. For more complex definitions which need some bending to shove into Lean, life might not be so easy. I have a definition by induction on two variables, and Mario's equation lemma is exactly how I am thinking the definition \"works\". I shove the definition into Lean in perhaps an inelegant way (\"Mario wrote <code>multiset.strong_induction_on</code> and I can apply it twice, that'll do\") and now I need to be aware of the fact that Lean's understanding of the function is now quite far from my intuitive idea of how it works, and it should now be a top priority to sort this situation out by proving the lemmas which say that the definition behaves the way I expect it to. If I'm writing some API then I might want to consider proving these so-called \"equation lemmas\" -- this is an informal definition and it seems to mean \"the lemmas which an end user might expect to be true by definition, whether or not they are true by <code>rfl</code>\" -- immediately after the definition of the function. Some might already be there with exotic names with <code>_</code>s in, and the ones that are not should be written as a matter of priority or other mathematicians will not be able to use the function in the intuitive way which they would like to.</p>",
        "id": 129590094,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1531473162
    }
]
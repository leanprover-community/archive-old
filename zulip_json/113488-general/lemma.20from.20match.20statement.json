[
    {
        "content": "<p>Are there any lemmas that tie the matched variables to the particular case it was matched with?</p>\n<p>I have a term constructor, and I am trying to define a function on it as follows:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">sort</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"n\">clause</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">option</span> <span class=\"n\">term</span><span class=\"o\">)</span>\n<span class=\"kn\">infixl</span> <span class=\"bp\">`</span> <span class=\"err\">•</span> <span class=\"bp\">`</span> <span class=\"o\">:</span><span class=\"mi\">20</span>  <span class=\"o\">:=</span> <span class=\"n\">app</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">reduce_not_and_aux</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">clause</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"s2\">&quot;and&quot;</span> <span class=\"bp\">_</span> <span class=\"err\">•</span> <span class=\"n\">t₀</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"s2\">&quot;and&quot;</span> <span class=\"bp\">_</span> <span class=\"err\">•</span> <span class=\"n\">t₁</span> <span class=\"err\">•</span> <span class=\"n\">t₂</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n    <span class=\"n\">mkNot</span> <span class=\"n\">t₀</span> <span class=\"bp\">::</span> <span class=\"n\">mkNot</span> <span class=\"n\">t₁</span> <span class=\"bp\">::</span> <span class=\"n\">reduce_not_and_aux</span> <span class=\"n\">t₂</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"s2\">&quot;and&quot;</span> <span class=\"bp\">_</span> <span class=\"err\">•</span> <span class=\"n\">t₀</span> <span class=\"err\">•</span> <span class=\"n\">t₁</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">mkNot</span> <span class=\"n\">t₀</span><span class=\"o\">,</span> <span class=\"n\">mkNot</span> <span class=\"n\">t₁</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">mkNot</span> <span class=\"n\">t</span><span class=\"o\">]</span>\n</code></pre></div>\n\n\n<p>However the equation compiler fails, and when I try to set_option for additional details, emacs crashes.<br>\nI believe that lean is not inferring that t₂ is smaller than the full term. I have constructed a 'term_size' function, and I am trying to prove that it decreases. </p>\n<p>This brings me to the original question -- can the match statement give me a lemma about what it matched?<br>\nSpecifically I would like to say that if the reduce_not_and_aux takes a term t, then t =(const \"and\" _ • t₀ • (const \"and\" _ • t₁ • t₂)) in the first case.</p>\n<p>Thank You,<br>\nScott</p>",
        "id": 206086770,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1596667302
    },
    {
        "content": "<p>A simp attribute works only on lemmas (and theorems), as far as I know.</p>",
        "id": 206093143,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1596673415
    },
    {
        "content": "<p>woops thx</p>",
        "id": 206093285,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1596673580
    },
    {
        "content": "<p>No, @[simp] works on definitions too.</p>",
        "id": 206096153,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596676943
    },
    {
        "content": "<p>It means that <code>simp</code> will happily unfold the definition itself. In my experience it's rarely what you want, and it's better to write custom simp lemmas yourself in nearly every circumstance.</p>",
        "id": 206096178,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596676981
    },
    {
        "content": "<p>The attribute <code>@[simps]</code> is extremely useful when defining structures: it will automatically create <code>@[simp]</code> lemmas for each of the projections.</p>",
        "id": 206096187,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596677003
    },
    {
        "content": "<p>I appreciate the comments here, but I would still be interested in an answer to the original question if possible.</p>",
        "id": 206490840,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597081692
    },
    {
        "content": "<p>Nevermind!</p>",
        "id": 206505704,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597089264
    },
    {
        "content": "<p>Hm, there seems to be a weird bug here:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">constant</span> <span class=\"n\">sort</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">sort</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n<span class=\"kn\">open</span> <span class=\"n\">term</span>\n\n<span class=\"n\">def</span> <span class=\"n\">reduce_not_and_aux</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">unit</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">app</span> <span class=\"bp\">_</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">reduce_not_and_aux</span> <span class=\"n\">t</span>\n<span class=\"bp\">|</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"o\">()</span>\n</code></pre></div>\n\n\n<p>If you replace <code>constant sort : Type</code> with <code>def sort : Type := sorry</code> it works, which suggests somehow the noncomputable marker is interfering with the equation compiler</p>",
        "id": 206506938,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597089913
    },
    {
        "content": "<p>But even after fixing that, it seems the equation compiler still has an issue with the definition, which I assume is what you are seeing. The problem has to do with the way string matches are compiled. Here's an implementation that will work:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">sort</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">sort</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n<span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span>\n<span class=\"kn\">open</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"n\">clause</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">option</span> <span class=\"n\">term</span><span class=\"o\">)</span>\n<span class=\"kn\">infixl</span> <span class=\"bp\">`</span> <span class=\"err\">•</span> <span class=\"bp\">`</span> <span class=\"o\">:</span><span class=\"mi\">20</span>  <span class=\"o\">:=</span> <span class=\"n\">app</span>\n\n<span class=\"n\">def</span> <span class=\"n\">mkNot</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">term</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_and</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"s2\">&quot;and&quot;</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n\n<span class=\"n\">def</span> <span class=\"n\">reduce_not_and_aux</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">clause</span>\n<span class=\"bp\">|</span> <span class=\"n\">t</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">A1</span> <span class=\"err\">•</span> <span class=\"n\">t₀</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">A2</span> <span class=\"err\">•</span> <span class=\"n\">t₁</span> <span class=\"err\">•</span> <span class=\"n\">t₂</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">is_and</span> <span class=\"n\">A1</span> <span class=\"bp\">∧</span> <span class=\"n\">is_and</span> <span class=\"n\">A2</span> <span class=\"k\">then</span>\n    <span class=\"n\">mkNot</span> <span class=\"n\">t₀</span> <span class=\"bp\">::</span> <span class=\"n\">mkNot</span> <span class=\"n\">t₁</span> <span class=\"bp\">::</span> <span class=\"n\">reduce_not_and_aux</span> <span class=\"n\">t₂</span>\n  <span class=\"k\">else</span> <span class=\"o\">[</span><span class=\"n\">mkNot</span> <span class=\"n\">t</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">t</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"n\">A1</span> <span class=\"err\">•</span> <span class=\"n\">t₀</span> <span class=\"err\">•</span> <span class=\"n\">t₁</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">is_and</span> <span class=\"n\">A1</span> <span class=\"k\">then</span> <span class=\"o\">[</span><span class=\"n\">mkNot</span> <span class=\"n\">t₀</span><span class=\"o\">,</span> <span class=\"n\">mkNot</span> <span class=\"n\">t₁</span><span class=\"o\">]</span>\n  <span class=\"k\">else</span> <span class=\"o\">[</span><span class=\"n\">mkNot</span> <span class=\"n\">t</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">mkNot</span> <span class=\"n\">t</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 206507425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597090189
    },
    {
        "content": "<p>(it's about now that I wish lean had pattern guards)</p>",
        "id": 206507562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597090255
    },
    {
        "content": "<p>If you are doing meta code, then the original version will work fine:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">reduce_not_and_aux</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">clause</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"s2\">&quot;and&quot;</span> <span class=\"bp\">_</span> <span class=\"err\">•</span> <span class=\"n\">t₀</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"s2\">&quot;and&quot;</span> <span class=\"bp\">_</span> <span class=\"err\">•</span> <span class=\"n\">t₁</span> <span class=\"err\">•</span> <span class=\"n\">t₂</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mkNot</span> <span class=\"n\">t₀</span> <span class=\"bp\">::</span> <span class=\"n\">mkNot</span> <span class=\"n\">t₁</span> <span class=\"bp\">::</span> <span class=\"n\">reduce_not_and_aux</span> <span class=\"n\">t₂</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"s2\">&quot;and&quot;</span> <span class=\"bp\">_</span> <span class=\"err\">•</span> <span class=\"n\">t₀</span> <span class=\"err\">•</span> <span class=\"n\">t₁</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">mkNot</span> <span class=\"n\">t₀</span><span class=\"o\">,</span> <span class=\"n\">mkNot</span> <span class=\"n\">t₁</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">mkNot</span> <span class=\"n\">t</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 206507778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597090382
    },
    {
        "content": "<p>Thanks Mario! <br>\nI had written the full definitions using term.rec_on to unblock myself, but this is much nicer.</p>\n<p>On a separate note, is there a way to pattern match using functions?<br>\nIn other places I have definitions like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">reduce_iff_aux</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">clause</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"s2\">&quot;iff&quot;</span> <span class=\"bp\">_</span> <span class=\"err\">•</span> <span class=\"n\">t₀</span> <span class=\"err\">•</span> <span class=\"n\">t₁</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">mkNot</span> <span class=\"n\">t₀</span><span class=\"o\">,</span> <span class=\"n\">t₁</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"s2\">&quot;iff&quot;</span> <span class=\"bp\">_</span> <span class=\"err\">•</span> <span class=\"n\">t₀</span> <span class=\"err\">•</span> <span class=\"n\">t₁</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">t₀</span><span class=\"o\">,</span> <span class=\"n\">mkNot</span> <span class=\"n\">t₁</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span>           <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"o\">]</span>\n <span class=\"bp\">```</span>\n<span class=\"n\">But</span> <span class=\"n\">I</span> <span class=\"n\">would</span> <span class=\"n\">much</span> <span class=\"n\">rather</span> <span class=\"n\">define</span> <span class=\"n\">something</span> <span class=\"n\">like</span>\n</code></pre></div>\n\n\n<p>def iff (t₁ t₂ : term) : term := const \"iff\" _ • t₁ • t₂<br>\ndef reduce_iff_aux : term → nat → clause<br>\n| (iff • t₀ • t₁) 0 := [mkNot t₀, t₁]<br>\n| (iff • t₀ • t₁) 1 := [t₀, mkNot t₁]<br>\n| _           _ := [option.none]</p>\n<div class=\"codehilite\"><pre><span></span><code>\n</code></pre></div>",
        "id": 206622858,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597175618
    },
    {
        "content": "<p>Try putting <code>@[pattern]</code> before <code>def iff</code></p>",
        "id": 206623111,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597175733
    },
    {
        "content": "<p>that worked, thanks!</p>",
        "id": 206623289,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597175803
    },
    {
        "content": "<p>Investigating the cause of the string pattern match issue, I find that<br>\n<code>#reduce (string.has_decidable_eq \"hi\" \"hi\")</code><br>\nyields</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"mi\">619</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">excessive</span> <span class=\"n\">memory</span> <span class=\"n\">consumption</span> <span class=\"n\">detected</span> <span class=\"n\">at</span> <span class=\"err\">&#39;</span><span class=\"n\">replace&#39;</span> <span class=\"o\">(</span><span class=\"n\">potential</span> <span class=\"n\">solution</span><span class=\"o\">:</span> <span class=\"n\">increase</span> <span class=\"n\">memory</span> <span class=\"n\">consumption</span> <span class=\"n\">threshold</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 207045936,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597536588
    },
    {
        "content": "<p>The same statement with #eval works correctly.<br>\nDigging a bit deeper,  I receive the same error with</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">reduce</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">has_dec_eq</span> <span class=\"s2\">&quot;hi&quot;</span><span class=\"bp\">.</span><span class=\"n\">data</span> <span class=\"s2\">&quot;hi&quot;</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 207046033,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597536727
    },
    {
        "content": "<p>(side note: why are the has_dec_eq statements named inconsistently?)</p>",
        "id": 207046042,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597536824
    },
    {
        "content": "<p><code>#reduce</code> doesn't work well with strings, see e.g. <a href=\"#narrow/stream/113489-new-members/topic/deep.20recursion.20with.20append\">this thread</a> and <a href=\"#narrow/stream/113489-new-members/topic/deep.20recursion.20error.20reducing.20strings\">this thread</a>.</p>",
        "id": 207046161,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1597537017
    },
    {
        "content": "<p>Ok, but then what is the reason that Mario's is_and function works?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">is_and</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"s2\">&quot;and&quot;</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n</code></pre></div>",
        "id": 207046982,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597538499
    },
    {
        "content": "<p><code>#reduce (is_and (const \"and\" boolsort))</code><br>\nworks fine</p>",
        "id": 207047028,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597538570
    },
    {
        "content": "<p>The kernel can see that <code>\"and\" = \"and\"</code> without doing much work</p>",
        "id": 207047038,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597538611
    },
    {
        "content": "<p>in particular, without computing the entire normal form of <code>\"and\"</code></p>",
        "id": 207047087,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597538658
    },
    {
        "content": "<p>so pattern matching uses the kernel to check string equality?</p>",
        "id": 207047104,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597538720
    },
    {
        "content": "<p><code>#reduce</code> uses the kernel to reduce things to normal form</p>",
        "id": 207047111,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597538743
    },
    {
        "content": "<p>in this case, that thing is whatever the equation compiler turned <code>is_and</code> into, applied to its argument</p>",
        "id": 207047172,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597538850
    },
    {
        "content": "<p>is the issue with normal form on natural numbers that the normal form is written in unary representation or something?</p>",
        "id": 207047173,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597538852
    },
    {
        "content": "<p>yes but it's worse than that: the proof that <code>'a'</code> is a valid Unicode character is also encoded in unary</p>",
        "id": 207047194,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597538882
    },
    {
        "content": "<p>where does this notation come from?<br>\nn &lt; 0xd800 ∨ (0xdfff &lt; n ∧ n &lt; 0x110000)</p>",
        "id": 207047237,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597538960
    },
    {
        "content": "<p>namely the hexadecimal</p>",
        "id": 207047243,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597538987
    },
    {
        "content": "<p>I would presume it's built-in just like ordinary decimal numeric literals.</p>",
        "id": 207047313,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597539075
    },
    {
        "content": "<p>When I write <code>#check 123</code> should I think of that as a unary nat?</p>",
        "id": 207047380,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597539216
    },
    {
        "content": "<p>I would think of it as 123</p>",
        "id": 207047383,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597539232
    },
    {
        "content": "<p>Because it infers the type is nat</p>",
        "id": 207047421,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597539246
    },
    {
        "content": "<p>the representation and whether you care what the representation is depends on the context</p>",
        "id": 207047425,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597539261
    },
    {
        "content": "<p>the inferred type also depends on the context, but with no context it's indeed nat</p>",
        "id": 207047427,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597539274
    },
    {
        "content": "<p>oh really</p>",
        "id": 207047430,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597539283
    },
    {
        "content": "<p>so there is some code to do this context inference somewhere in the c++?</p>",
        "id": 207047443,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597539322
    },
    {
        "content": "<p>Writing <code>#check 2000000000000000</code> works fine, so obviously in this situation Lean did not build a unary representation of the number behind the scenes</p>",
        "id": 207047498,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597539396
    },
    {
        "content": "<p>haha right</p>",
        "id": 207047514,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597539459
    },
    {
        "content": "<p>It can't be so hard to rewrite char using hexadecimal nat explicitly written as an inductive datatype, no?</p>",
        "id": 207047558,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597539531
    },
    {
        "content": "<p>It would be possible but there's no real application I can think of</p>",
        "id": 207047619,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597539669
    },
    {
        "content": "<p>and it would complicate making <code>#eval</code> treat them efficiently</p>",
        "id": 207047624,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597539702
    },
    {
        "content": "<p>for syntax trees you shouldn't really be using <code>string</code> in the first place--make an inductive type with the values you care about</p>",
        "id": 207047678,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597539797
    },
    {
        "content": "<p>In this context I want to simulate an open type</p>",
        "id": 207047683,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597539819
    },
    {
        "content": "<p>I'm adding smt theories dynamically</p>",
        "id": 207047713,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597539843
    },
    {
        "content": "<p>I really don't want support them all in one big inductive term/sort datastructure, and then edit any def that uses them upon each addition</p>",
        "id": 207047748,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597539911
    },
    {
        "content": "<p>Now I could replace string matching with nat here, but that will make things more difficult to read</p>",
        "id": 207047796,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597539967
    },
    {
        "content": "<p>or use a type variable</p>",
        "id": 207047803,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597540004
    },
    {
        "content": "<p>but I agree this is a bit more complicated</p>",
        "id": 207047811,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597540051
    },
    {
        "content": "<p>do you mean if I set the different sorts up as types?</p>",
        "id": 207047813,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540056
    },
    {
        "content": "<p>and pattern match on which type</p>",
        "id": 207047855,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540096
    },
    {
        "content": "<p>Actually I am unsure what you mean</p>",
        "id": 207047859,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540105
    },
    {
        "content": "<p>well, I'd have to think about it more but I'm pretty sure there is always a better option than <code>string</code></p>",
        "id": 207047864,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597540130
    },
    {
        "content": "<p>fair enough</p>",
        "id": 207047871,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540149
    },
    {
        "content": "<p>this is the kind of example that I am looking at</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">sortof_aux</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">sort</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">str</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">str</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">&quot;bot&quot;</span> <span class=\"o\">:=</span> <span class=\"n\">boolsort</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">&quot;not&quot;</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">boolsort</span> <span class=\"n\">boolsort</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">&quot;or&quot;</span>  <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">boolsort</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">boolsort</span> <span class=\"n\">boolsort</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">&quot;and&quot;</span>  <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">boolsort</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">boolsort</span> <span class=\"n\">boolsort</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">&quot;implies&quot;</span>  <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">boolsort</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">boolsort</span> <span class=\"n\">boolsort</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">&quot;xor&quot;</span>  <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">boolsort</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">boolsort</span> <span class=\"n\">boolsort</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"s2\">&quot;iff&quot;</span>  <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">boolsort</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">boolsort</span> <span class=\"n\">boolsort</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">_</span>      <span class=\"o\">:=</span> <span class=\"n\">s</span>\n  <span class=\"kn\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">str</span> <span class=\"o\">(</span><span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">constructor</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">t₁</span> <span class=\"err\">•</span> <span class=\"n\">t₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">str</span> <span class=\"bp\">=</span> <span class=\"s2\">&quot;eq&quot;</span> <span class=\"k\">then</span>\n    <span class=\"n\">do</span> <span class=\"n\">s₁</span> <span class=\"err\">←</span> <span class=\"n\">sortof_aux</span> <span class=\"n\">t₁</span><span class=\"o\">,</span> <span class=\"n\">s₂</span> <span class=\"err\">←</span> <span class=\"n\">sortof_aux</span> <span class=\"n\">t₂</span><span class=\"o\">,</span>\n      <span class=\"k\">if</span> <span class=\"n\">s₁</span> <span class=\"bp\">=</span> <span class=\"n\">s₂</span> <span class=\"k\">then</span> <span class=\"n\">boolsort</span> <span class=\"k\">else</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">none</span>\n  <span class=\"k\">else</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">const</span> <span class=\"n\">str</span> <span class=\"o\">(</span><span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">constructor</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">t₁</span> <span class=\"err\">•</span> <span class=\"n\">t₂</span> <span class=\"err\">•</span> <span class=\"n\">t₃</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">str</span> <span class=\"bp\">=</span> <span class=\"s2\">&quot;f_ite&quot;</span> <span class=\"k\">then</span>\n    <span class=\"o\">(</span><span class=\"n\">do</span> <span class=\"n\">s₁</span> <span class=\"err\">←</span> <span class=\"n\">sortof_aux</span> <span class=\"n\">t₁</span><span class=\"o\">,</span> <span class=\"n\">s₂</span> <span class=\"err\">←</span> <span class=\"n\">sortof_aux</span> <span class=\"n\">t₂</span><span class=\"o\">,</span> <span class=\"n\">s₃</span> <span class=\"err\">←</span> <span class=\"n\">sortof_aux</span> <span class=\"n\">t₂</span><span class=\"o\">,</span>\n        <span class=\"k\">if</span> <span class=\"n\">s₁</span> <span class=\"bp\">=</span> <span class=\"n\">boolsort</span> <span class=\"bp\">∧</span> <span class=\"n\">s₂</span> <span class=\"bp\">=</span> <span class=\"n\">s₃</span> <span class=\"k\">then</span> <span class=\"n\">s₂</span> <span class=\"k\">else</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"err\">•</span> <span class=\"n\">t</span><span class=\"o\">)</span>  <span class=\"o\">:=</span>\n  <span class=\"n\">do</span> <span class=\"n\">sf</span> <span class=\"err\">←</span> <span class=\"n\">sortof_aux</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"err\">←</span> <span class=\"n\">sortof_aux</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"k\">match</span> <span class=\"n\">sf</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">s1</span> <span class=\"n\">s2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">s1</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"n\">s2</span> <span class=\"k\">else</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">none</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">none</span>\n    <span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sortof</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">term</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">sort</span> <span class=\"o\">:=</span>\n <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">bind</span><span class=\"o\">)</span> <span class=\"n\">sortof_aux</span>\n\n<span class=\"n\">def</span> <span class=\"n\">x₁</span> <span class=\"o\">:=</span> <span class=\"n\">const</span> <span class=\"s2\">&quot;x₁&quot;</span> <span class=\"n\">boolsort</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span> <span class=\"o\">(</span><span class=\"n\">sortof</span> <span class=\"n\">x₁</span><span class=\"o\">)</span> <span class=\"c1\">-- recursion error</span>\n</code></pre></div>",
        "id": 207047925,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540208
    },
    {
        "content": "<p>doesn't work because comparing strings</p>",
        "id": 207047929,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540242
    },
    {
        "content": "<p>does <code>#eval</code> work?</p>",
        "id": 207047939,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597540273
    },
    {
        "content": "<p>yes</p>",
        "id": 207047949,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540299
    },
    {
        "content": "<p><code>#eval (sortof x₁)</code> -- (some bool)</p>",
        "id": 207047953,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540313
    },
    {
        "content": "<p>Another option to represent an \"open type\" would be <code>num</code></p>",
        "id": 207047956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597540317
    },
    {
        "content": "<p>just define <code>bot := 0</code> and <code>not := 1</code> and so on</p>",
        "id": 207047994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597540332
    },
    {
        "content": "<p>You should be able to handle at least a few thousand constructors that way in the kernel</p>",
        "id": 207048006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597540382
    },
    {
        "content": "<p>Ok I'm looking at num now</p>",
        "id": 207048020,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540415
    },
    {
        "content": "<p>it is zero or pos, and if pos seems to have a binary encoding of nat</p>",
        "id": 207048061,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540444
    },
    {
        "content": "<p>why is this better than using nat</p>",
        "id": 207048064,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540458
    },
    {
        "content": "<p>efficiency?</p>",
        "id": 207048069,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540473
    },
    {
        "content": "<p>Yes, you can <code>#reduce (200000000000000 : num)</code> in the kernel without too much trouble</p>",
        "id": 207048133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597540572
    },
    {
        "content": "<p>I could use a map from strings to their corresponding nums to make it more readable, but I feel like this runs into the same issues as before</p>",
        "id": 207048142,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540620
    },
    {
        "content": "<p>actually I lied, lean can only go up to about <code>(20000 : num)</code>, although this is farther than you can go on <code>nat</code></p>",
        "id": 207048151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597540673
    },
    {
        "content": "<p>In Coq it's pretty common to use <code>pos_num</code> for maps and things in the kernel</p>",
        "id": 207048196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597540730
    },
    {
        "content": "<p>I mean 20000 is good enough</p>",
        "id": 207048197,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540731
    },
    {
        "content": "<p>basically you should think of a function out of <code>pos_num</code> as an infinite binary tree</p>",
        "id": 207048206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597540793
    },
    {
        "content": "<p>whereas a function out of <code>nat</code> is more like a list</p>",
        "id": 207048246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597540807
    },
    {
        "content": "<p>so it is easier to store more data, more easily accessible, on the tree representation</p>",
        "id": 207048252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597540841
    },
    {
        "content": "<p>can you pattern match on <code>num</code>?</p>",
        "id": 207048271,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597540913
    },
    {
        "content": "<p>I don't see why not</p>",
        "id": 207048308,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540940
    },
    {
        "content": "<p>it will be a nested pattern match if it is pos</p>",
        "id": 207048309,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540956
    },
    {
        "content": "<p>does pattern match not work on all inductive types?</p>",
        "id": 207048311,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597540982
    },
    {
        "content": "<p>right, I guess it should work fine</p>",
        "id": 207048363,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597541049
    },
    {
        "content": "<p>in that case, you don't need to make a fancy map or anything, you can just write <code>@[pattern] def bot : num = 1</code> like Mario suggested</p>",
        "id": 207048368,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597541089
    },
    {
        "content": "<p>Oh</p>",
        "id": 207048384,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597541158
    },
    {
        "content": "<p>I didn't understand the suggestion</p>",
        "id": 207048422,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597541166
    },
    {
        "content": "<p>that makes total sense</p>",
        "id": 207048425,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597541176
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 207048426,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597541179
    },
    {
        "content": "<p>actually <code>pos_num</code> is better than <code>num</code> for this</p>",
        "id": 207048428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597541192
    },
    {
        "content": "<p>you don't need 0 here so the pure tree structure is simpler</p>",
        "id": 207048440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597541226
    },
    {
        "content": "<p>yeah</p>",
        "id": 207048448,
        "sender_full_name": "Scott Viteri",
        "timestamp": 1597541253
    }
]
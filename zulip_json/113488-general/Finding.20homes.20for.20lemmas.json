[
    {
        "content": "<p>With the new <a href=\"https://eric-wieser.github.io/mathlib-import-graph/\">import graph</a> and the corresponding <a href=\"https://leanprover-community.github.io/mathlib_docs/import.gexf\">data file</a> hosted on the mathlib docs, it's now not too hard to answer the question \"which file can my lemma go in\":</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">networkx</span> <span class=\"k\">as</span> <span class=\"nn\">nx</span>\n<span class=\"kn\">import</span> <span class=\"nn\">requests</span>\n<span class=\"kn\">import</span> <span class=\"nn\">io</span>\n<span class=\"kn\">import</span> <span class=\"nn\">operator</span>\n<span class=\"kn\">from</span> <span class=\"nn\">functools</span> <span class=\"kn\">import</span> <span class=\"n\">reduce</span>\n\n<span class=\"k\">with</span> <span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"https://leanprover-community.github.io/mathlib_docs/import.gexf\"</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">r</span><span class=\"p\">:</span>\n    <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">read_gexf</span><span class=\"p\">(</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">StringIO</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># where you need the lemma, and which files it needs</span>\n<span class=\"n\">needed_in</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'mathlib:ring_theory.finiteness'</span><span class=\"p\">,)</span>\n<span class=\"n\">needs</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'mathlib:data.mv_polynomial.basic'</span><span class=\"p\">,</span> <span class=\"s1\">'mathlib:ring_theory.ideal.basic'</span><span class=\"p\">)</span>\n\n<span class=\"n\">ok</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">reduce</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">and_</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">ancestors</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">needs</span><span class=\"p\">])</span> <span class=\"o\">&amp;</span>\n      <span class=\"n\">reduce</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">and_</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">descendants</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">needed_in</span><span class=\"p\">]))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">ok</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>This prints out</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span><span class=\"bp\">'</span><span class=\"n\">mathlib</span><span class=\"o\">:</span><span class=\"n\">ring_theory.algebra_tower'</span><span class=\"o\">,</span> <span class=\"bp\">'</span><span class=\"n\">mathlib</span><span class=\"o\">:</span><span class=\"n\">ring_theory.polynomial.basic'</span><span class=\"o\">,</span> <span class=\"bp\">'</span><span class=\"n\">mathlib</span><span class=\"o\">:</span><span class=\"n\">ring_theory.adjoin.polynomial'</span><span class=\"o\">,</span> <span class=\"bp\">'</span><span class=\"n\">mathlib</span><span class=\"o\">:</span><span class=\"n\">ring_theory.adjoin.fg'</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 260255746,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636024447
    },
    {
        "content": "<p>That's awesome! Can this become part of LP?</p>",
        "id": 260256060,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636024697
    },
    {
        "content": "<p>LP already has python API for this, but the problem is that it has to compute the import graph from scratch, and that's really slow</p>",
        "id": 260256081,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636024720
    },
    {
        "content": "<p>It could have a flag to use the online <code>gexf</code> file, instead of computing it from scratch.</p>",
        "id": 260256111,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636024746
    },
    {
        "content": "<p>Alternative, maybe we should output a gexf file or similar as part of the cache</p>",
        "id": 260256134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636024766
    },
    {
        "content": "<p>Maybe not as part of the same bundle, but it certainly makes sense to host them and reuse the caching mechanism.</p>",
        "id": 260256239,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636024822
    },
    {
        "content": "<p>(also, note that the <code>gexf</code> file is incorrect, as it doesn't know about files with transitive imports but no definitions or docstrings, xref <a href=\"https://github.com/leanprover-community/lean/issues/645\">leanprover-community/lean#645</a>)</p>",
        "id": 260256242,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636024826
    },
    {
        "content": "<p>I think it's fine to only compute these <code>gexf</code> files for master.</p>",
        "id": 260256391,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636024943
    },
    {
        "content": "<p>I guess to me <code>leanproject</code> is a tool for working on local projects, so any command line feature that ignores the local project name and revision and just looks at mathlib master is a bad fit</p>",
        "id": 260256740,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636025182
    },
    {
        "content": "<p>We could also put this in a web UI somewhere (swapping <code>networkx</code> for <code>graphology</code> which is what the ball of yarn visualization uses), depending on people's attachment to the command line</p>",
        "id": 260256914,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636025343
    },
    {
        "content": "<p>Most of all, I just want a very easy way to use this script. Web or cmdline, I don't care</p>",
        "id": 260259781,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636027282
    },
    {
        "content": "<p>So maybe we can put it in <code>scripts/</code> for now?</p>",
        "id": 260259809,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636027301
    },
    {
        "content": "<p>That's wonderful!!</p>",
        "id": 260260241,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1636027574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Finding.20homes.20for.20lemmas/near/260259781\">said</a>:</p>\n<blockquote>\n<p>Most of all, I just want a very easy way to use this script. Web or cmdline, I don't care</p>\n</blockquote>\n<p>We should really implement this as a lean user command!</p>",
        "id": 260260281,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1636027617
    },
    {
        "content": "<p>Is the import graph accessible to lean in an easy way?</p>",
        "id": 260260322,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636027653
    },
    {
        "content": "<p>Iirc scott wrote a version called home_finder a while ago, that doesn't do any actual graph theory</p>",
        "id": 260260325,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1636027653
    },
    {
        "content": "<p>Actually <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> wrote the one I was thinking of, I think that <a href=\"#narrow/stream/239415-metaprogramming-.2F.20tactics/topic/lemma.20distribution/near/212269975\">https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming-.2F.20tactics/topic/lemma.20distribution/near/212269975</a> could be combined with something like <a href=\"https://github.com/alexjbest/lean-generalisation/blob/main/src/dag.lean#L247\">https://github.com/alexjbest/lean-generalisation/blob/main/src/dag.lean#L247</a> to implement this in lean itself</p>",
        "id": 260260498,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1636027788
    },
    {
        "content": "<p>Where should those three lemmas about linear maps and topology go?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">ùïú</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">continuous_at_of_exists_open</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí‚Çó</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"bp\">ùïú</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">Œµ</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Œµ</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">‚àÉ</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">‚àà</span> <span class=\"n\">U</span> <span class=\"bp\">‚àß</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span> <span class=\"bp\">‚àß</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">y</span> <span class=\"bp\">‚àà</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">‚à•</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"bp\">‚à•</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Œµ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">continuous_at</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">U</span> <span class=\"n\">hU</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">metric.nhds_basis_ball.1</span> <span class=\"n\">at</span> <span class=\"n\">hU</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hU</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">Œµ</span><span class=\"o\">,</span> <span class=\"n\">hŒµ‚ÇÅ</span><span class=\"o\">,</span> <span class=\"n\">hŒµ‚ÇÇ</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">filter.mem_map</span><span class=\"o\">],</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hV‚ÇÅ</span><span class=\"o\">,</span> <span class=\"n\">hV‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">hV‚ÇÉ</span><span class=\"o\">‚ü©</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"n\">Œµ</span> <span class=\"n\">hŒµ‚ÇÅ</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_nhds_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">‚ü®</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">Œª</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hŒµ‚ÇÇ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hV‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">hV‚ÇÅ</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">metric.mem_ball</span><span class=\"o\">,</span> <span class=\"n\">f.map_zero</span><span class=\"o\">,</span> <span class=\"n\">dist_zero_right</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hV‚ÇÉ</span> <span class=\"n\">_</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">continuous_at_of_exists_open'</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí‚Çó</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"bp\">ùïú</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">Œµ</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Œµ</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">‚àÉ</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">U</span> <span class=\"bp\">‚àß</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span> <span class=\"bp\">‚àß</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">y</span> <span class=\"bp\">‚àà</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">‚à•</span><span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">‚à•</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Œµ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">continuous_at</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">U</span> <span class=\"n\">hU</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">metric.nhds_basis_ball.1</span> <span class=\"n\">at</span> <span class=\"n\">hU</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hU</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">Œµ</span><span class=\"o\">,</span> <span class=\"n\">hŒµ‚ÇÅ</span><span class=\"o\">,</span> <span class=\"n\">hŒµ‚ÇÇ</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">filter.mem_map</span><span class=\"o\">],</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hV‚ÇÅ</span><span class=\"o\">,</span> <span class=\"n\">hV‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">hV‚ÇÉ</span><span class=\"o\">‚ü©</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"n\">Œµ</span> <span class=\"n\">hŒµ‚ÇÅ</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_nhds_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">‚ü®</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">Œª</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hŒµ‚ÇÇ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hV‚ÇÇ</span><span class=\"o\">,</span> <span class=\"n\">hV‚ÇÅ</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">metric.mem_ball</span><span class=\"o\">,</span> <span class=\"n\">dist_eq_norm</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hV‚ÇÉ</span> <span class=\"n\">_</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- A nonzero continuous linear functional is open. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">nonzero_linear_map_is_open_map</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">division_ring</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_add_group</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_continuous_smul</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"bp\">ùïú</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">‚â†</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_open_map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">x‚ÇÄ</span><span class=\"o\">,</span> <span class=\"n\">hx‚ÇÄ</span><span class=\"o\">‚ü©</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">x‚ÇÄ</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x‚ÇÄ</span> <span class=\"bp\">‚â†</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">by_contra</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hf</span> <span class=\"o\">(</span><span class=\"n\">continuous_linear_map.ext</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span> <span class=\"o\">)},</span>\n  <span class=\"n\">intros</span> <span class=\"n\">A</span> <span class=\"n\">hA</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_open_iff_mem_nhds</span><span class=\"o\">,</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©,</span>\n  <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">ùïú</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x‚ÇÄ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">x‚ÇÄ</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">continuous</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">continuity</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_open_preimage</span> <span class=\"n\">_</span> <span class=\"o\">‚Äπ</span><span class=\"n\">is_open</span> <span class=\"n\">A</span><span class=\"o\">‚Ä∫,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_open_iff_mem_nhds</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">filter.sets_of_superset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">set.mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">]))</span>\n    <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx‚ÇÄ</span><span class=\"o\">]‚ü©),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I'm happy to hear any golf.</p>",
        "id": 260797768,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1636464974
    },
    {
        "content": "<p>I would say the first two lemmas probably shouldn't go anywhere. Why do you want them?</p>",
        "id": 260800823,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1636466461
    },
    {
        "content": "<p>They are used in <a href=\"https://github.com/leanprover-community/mathlib/issues/7288\">#7288</a> but I can probably inline them.</p>",
        "id": 260800973,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1636466512
    },
    {
        "content": "<p><del>I think I'm not parsing your statement right, can you help me?  Why is projection from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> onto the first coordinate an open map?  Or why does the last statement not apply to that function?</del> oh i see</p>",
        "id": 260801263,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636466632
    },
    {
        "content": "<p>OK, can't you get the last result from the Banach open mapping theorem? <a href=\"https://leanprover-community.github.io/mathlib_docs/find/open_mapping\">docs#open_mapping</a></p>",
        "id": 260801391,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636466678
    },
    {
        "content": "<p>You just need to establish that a nonzero functional onto <code>ùïú</code> is surjective ...</p>",
        "id": 260801502,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636466739
    },
    {
        "content": "<p>Hmm... that's an interesting result.</p>",
        "id": 260802075,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1636466976
    },
    {
        "content": "<p>Sorry, I got interrupted. You can rewrite a cleaner proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A nonzero continuous linear functional is open. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">nonzero_linear_map_is_open_map</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">division_ring</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_ring</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_add_group</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_continuous_smul</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"bp\">ùïú</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">‚â†</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_open_map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">x‚ÇÄ</span><span class=\"o\">,</span> <span class=\"n\">hx‚ÇÄ</span><span class=\"o\">‚ü©</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">x‚ÇÄ</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x‚ÇÄ</span> <span class=\"bp\">‚â†</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">by_contra</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hf</span> <span class=\"o\">(</span><span class=\"n\">continuous_linear_map.ext</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span> <span class=\"o\">)},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">is_open_map.of_nhds_le</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">ùïú</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x‚ÇÄ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">x‚ÇÄ</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">cont_g</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">continuity</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">comp</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">‚àò</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx‚ÇÄ</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">comp_a</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx‚ÇÄ</span><span class=\"o\">],</span>\n  <span class=\"k\">calc</span> <span class=\"bp\">ùìù</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"bp\">$</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_map</span><span class=\"o\">,</span> <span class=\"n\">comp</span><span class=\"o\">,</span> <span class=\"n\">map_id</span><span class=\"o\">]</span>\n           <span class=\"bp\">...</span> <span class=\"bp\">‚â§</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"bp\">$</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span>      <span class=\"o\">:</span> <span class=\"n\">map_mono</span> <span class=\"n\">cont_g.continuous_at</span>\n           <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"n\">a</span><span class=\"o\">)</span>              <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">comp_a</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260808390,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1636469590
    },
    {
        "content": "<p>I'll have a look at what you try to do with the other two lemmas later.</p>",
        "id": 260808437,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1636469608
    },
    {
        "content": "<p>In the mean time you can extract two lemmas from the above proof (one for the obtain and one from the calc block which has clearly nothing to do with linear maps).</p>",
        "id": 260808666,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1636469687
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I think it's easier to use the open mapping theorem, though.</p>",
        "id": 260808966,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636469796
    },
    {
        "content": "<p>I agree but OTOH Patrick's proof doesn't require completeness (or indeed any structure beyond a topology).</p>",
        "id": 260810105,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1636470159
    },
    {
        "content": "<p>Heather, I don't see why you would want a completeness assumption here.</p>",
        "id": 260819495,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1636473812
    },
    {
        "content": "<p>Ya√´l, I had a look at the proof where you use <code>continuous_at_of_exists_open</code> and I don't understand why it's so complicated. Since C is open and contains zero, it contains some <code>ball 0 r</code> for a positive <code>r</code>. Hence <code>gauge X &lt;= gauge (ball 0 r) = norm/r</code>, right? Then your assumption on <code>phi</code> implies that phi is a bounded linear map hence continuous. Am I missing something?</p>",
        "id": 260821820,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1636474696
    },
    {
        "content": "<p>I'm pretty sure we've all written proofs that used unnecessary assumptions or started out more complicated than they needed to be.</p>",
        "id": 260822035,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1636474821
    },
    {
        "content": "<p>By the way, what is this <code>seminorm.lean</code> which seems completely unrelated to our <code>semi_normed_group</code>?</p>",
        "id": 260822069,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1636474840
    },
    {
        "content": "<p>Is it because you typically want to study a family of seminorms on a given type?</p>",
        "id": 260822101,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1636474870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Finding.20homes.20for.20lemmas/near/260821820\">said</a>:</p>\n<blockquote>\n<p>Ya√´l, I had a look at the proof where you use <code>continuous_at_of_exists_open</code> and I don't understand why it's so complicated. Since C is open and contains zero, it contains some <code>ball 0 r</code> for a positive <code>r</code>. Hence <code>gauge X &lt;= gauge (ball 0 r) = norm/r</code>, right? Then your assumption on <code>phi</code> implies that phi is a bounded linear map hence continuous. Am I missing something?</p>\n</blockquote>\n<p>I think I wrote the original version of some of these proofs, the answer is that it's complicated because I didn't understand how to use analysis in mathlib properly, I just needed some version of that result for later things</p>",
        "id": 260822228,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1636474950
    },
    {
        "content": "<p>It is not <em>completely</em> unrelated. The situation is the same as between <code>ring_hom</code> and <code>algebra</code>. <code>semi_normed_group</code> gives a distinguished seminorm through TC inference (although it's not using <code>seminorm</code> currently because Riccardo didn't know about <code>analysis.seminorm</code> at the time, so we could probably use a refactor) while <code>seminorm</code> is a way to create and consume several seminorms on the same group. That's what the proof does.</p>",
        "id": 260822481,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1636475088
    },
    {
        "content": "<p>Problem is, up to first order approximation I'm the only one aware of that file.</p>",
        "id": 260822553,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1636475133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/113488-general/topic/Finding.20homes.20for.20lemmas/near/260822035\">said</a>:</p>\n<blockquote>\n<p>I'm pretty sure we've all written proofs that used unnecessary assumptions or started out more complicated than they needed to be.</p>\n</blockquote>\n<p>Yes, of course. I'm not blaming anyone, I'm still trying to answer Ya√´l's question about those lemmas.</p>",
        "id": 260823840,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1636475816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Finding.20homes.20for.20lemmas/near/260822101\">said</a>:</p>\n<blockquote>\n<p>Is it because you typically want to study a family of seminorms on a given type?</p>\n</blockquote>\n<p>My internet is pretty bad, hadn't seen that message. Yes, you're exactly right.</p>",
        "id": 260824642,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1636476208
    },
    {
        "content": "<p>I tried splitting your proof into 3 lemmas but I am not convinced.</p>",
        "id": 261195245,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1636672779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Finding.20homes.20for.20lemmas/near/260821820\">said</a>:</p>\n<blockquote>\n<p>Ya√´l, I had a look at the proof where you use <code>continuous_at_of_exists_open</code> and I don't understand why it's so complicated. Since C is open and contains zero, it contains some <code>ball 0 r</code> for a positive <code>r</code>. Hence <code>gauge X &lt;= gauge (ball 0 r) = norm/r</code>, right? Then your assumption on <code>phi</code> implies that phi is a bounded linear map hence continuous. Am I missing something?</p>\n</blockquote>\n<p>Aren't we missing some API for that?</p>",
        "id": 262188722,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1637421793
    },
    {
        "content": "<p>Have you seen <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.mk_continuous\">docs#linear_map.mk_continuous</a></p>",
        "id": 262189352,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637422564
    },
    {
        "content": "<p>Oh interesting! But my assumption is <code>‚àÄ x, œÜ x ‚â§ gauge C x</code>, so I somehow need to prove that <code>gauge C</code> is continuous?</p>",
        "id": 262189565,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1637422850
    },
    {
        "content": "<p>Should this lemma be provided? If so, where should it go? Should it go in one of the four imports (which?), or should it go into a new file containing this lemma only?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.constructions.finite_products_of_binary_products</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.constructions.equalizers</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.constructions.binary_products</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.constructions.limits_of_products_and_equalizers</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory.limits</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory.limits</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_finite_limits_of_has_terminal_has_pullbacks</span>\n  <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_terminal</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_pullbacks</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_finite_limits</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@@</span><span class=\"n\">finite_limits_from_equalizers_and_finite_products</span> <span class=\"n\">_</span>\n  <span class=\"o\">(</span><span class=\"bp\">@@</span><span class=\"n\">has_finite_products_of_has_binary_and_terminal</span> <span class=\"n\">_</span>\n    <span class=\"o\">(</span><span class=\"n\">has_binary_products_of_terminal_and_pullbacks</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">@@</span><span class=\"n\">has_equalizers_of_pullbacks_and_binary_products</span> <span class=\"n\">_</span>\n    <span class=\"o\">(</span><span class=\"n\">has_binary_products_of_terminal_and_pullbacks</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">category_theory.limits</span>\n</code></pre></div>",
        "id": 269854026,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1643450962
    },
    {
        "content": "<p>IMO in the same file that provides finite limits from binary products and equalizers.</p>",
        "id": 269854693,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643451823
    },
    {
        "content": "<p>The analogous lemma for preserving finite limits would also be useful.</p>",
        "id": 269854762,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643451873
    }
]
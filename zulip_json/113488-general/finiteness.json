[
    {
        "content": "<p>Do mathlib have something that behaves like:</p>\n<div class=\"codehilite\"><pre><span></span>class  Finite (α : Type u) :=\n  (cardinality : nat)\n  (bijection : trunc (equiv α (fin cardinality)))\n</pre></div>",
        "id": 124610398,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1522822200
    },
    {
        "content": "<p>Is this gross for some reason, and should be avoided?</p>",
        "id": 124610440,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1522822214
    },
    {
        "content": "<p>It is in my category theory repo (the category “set”)</p>",
        "id": 124610449,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522822274
    },
    {
        "content": "<p>and it’s called fintype</p>",
        "id": 124610450,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522822282
    },
    {
        "content": "<p>It can't be called fintype, because mathlib already has a fintype which is slightly different (but equivalent, of course).</p>",
        "id": 124610479,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1522822323
    },
    {
        "content": "<p>I guess I'm asking if there is a strong reason to (bite the bullet and learn how to use multisets and) use mathlib's fintype, or if it's okay to use something like this.</p>",
        "id": 124610492,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1522822358
    },
    {
        "content": "<p>oops i meant the category is called set and uses fintype</p>",
        "id": 124610554,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522822549
    },
    {
        "content": "<p>but I guess I didn’t notice that you used trunc</p>",
        "id": 124610595,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522822566
    },
    {
        "content": "<p>That's <code>fintype</code>. If you want to use such an interface to it, prove it and use it</p>",
        "id": 124610881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522823264
    },
    {
        "content": "<p>Okay, I  guess that's a good point. In the meantime I'm discovering <code>fintype</code> is pretty easy to use anyway.</p>",
        "id": 124610925,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1522823304
    },
    {
        "content": "<p>What is the lemma that says <code>fintype</code> gives <code>decidable_eq</code>?</p>",
        "id": 124611257,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1522824094
    },
    {
        "content": "<p>I don't think it's true. So your formulation is a bit stronger, since it equips the set with a function to <code>fin</code>; in mathlib's <code>fintype</code>, this function is <code>index_of</code>, but it requires a separate proof of <code>decidable_eq</code></p>",
        "id": 124611576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522824763
    },
    {
        "content": "<p>your <code>Finite</code> should be equivalent to the conjunction of <code>fintype</code> and <code>decidable_eq</code></p>",
        "id": 124611584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522824789
    },
    {
        "content": "<p>ah, okay.</p>",
        "id": 124611585,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1522824800
    },
    {
        "content": "<p>Is there any way we could get to a world in which</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">finite</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"c1\">-- any definition of finiteness</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 206179081,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596738588
    },
    {
        "content": "<p>cons: all <code>big_operators</code> stuff becomes noncomputable<br>\npros: API becomes comprehensible by humans, and no more instance diamonds for <code>fintype</code></p>",
        "id": 206181704,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596739871
    },
    {
        "content": "<p>(I also dream of a world where <code>decidable</code>would disappear, but I know this won't happen)</p>",
        "id": 206182245,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1596740134
    },
    {
        "content": "<p>Up to <del>proof irrelevance</del> propositional equivalence, none of these definitions are different except you replaced <code>fintype A</code> with <code>nonempty (fintype A)</code>. Maybe we should just have a class for that, replacing <code>set.finite</code></p>",
        "id": 206182616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596740316
    },
    {
        "content": "<p>actually do we lose anything by just changing <code>fintype</code> to the nonempty version of what it currently is? <code>fintype.univ</code> becomes noncomputable but it fixes the instance diamonds</p>",
        "id": 206182980,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596740470
    },
    {
        "content": "<p><code>fintype.card</code> also becomes noncomputable</p>",
        "id": 206183036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596740499
    },
    {
        "content": "<p>My bigger issue is that I find it really difficult to find what I'm looking for in <code>data.finset</code>/<code>data.fintype</code>/<code>data.set.finite</code>; it's possible this could be improved without any representation changes</p>",
        "id": 206183487,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596740688
    },
    {
        "content": "<p>But a related issue is that there are three different ways to express the same ideas and they are connected by constructions that are not that simple</p>",
        "id": 206183748,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596740800
    },
    {
        "content": "<p>It's my completely unsubstantiated opinion that if we proved a bunch of things for <code>finite</code>, say, we could systematically deduce the consequences for <code>finset</code> and <code>fintype</code> and end up with a more organized API</p>",
        "id": 206183881,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596740869
    },
    {
        "content": "<p>Here is some pure fantasy: a universe level for only finite types</p>",
        "id": 206184647,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596741294
    },
    {
        "content": "<p><code>Type (1/2:\\Q)</code></p>",
        "id": 206185310,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596741674
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span></p>",
        "id": 206211134,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596758013
    },
    {
        "content": "<p>We must make finiteness easier for mathematicians. Counting is all over Sylow's theorems and if people can't knock them off in Lean using what we have, then I think we don't have the right things. I recently had two distinct proofs that the trivial subgroup of a group was a fintype and it was annoying.</p>",
        "id": 206214294,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596761421
    },
    {
        "content": "<p>OK I have just spent some time trying to understand the issues here. I'm trying to prove Sylow's theorems with students. Sylow's theorems are theorems about finite groups with no mention of decidable equality or ever explicitly attempting to write down elements -- they apply to all finite groups. Hence it seems to me that computability is irrelevant, so <code>fintype</code> and <code>finset</code> are not the right classes. But <code>set.finite</code> isn't either, because it is unbundled finiteness. Reid is proposing a bundled version of finiteness which he also calls <code>finset</code> but how about for now we call it <code>finset2</code>.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">finset2</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>Is there an argument for developing an API for this? It is bundled noncomputable finiteness which seems to me to be the best for Lean and the best for Sylow. Have I understood things correctly? Are people just going to tell me to go ahead and try?</p>",
        "id": 206450031,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597058278
    },
    {
        "content": "<p>As for cardinality some non-cardinal options would be finset2.card, <code>set.fincard : set X -&gt; nat</code> or <code>fincard : Type u -&gt; nat</code>. These are all functions we don't have, right? <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> you were complaining about fintype in another thread and it's got to the point where I just want to fix it. Sylow's theorems are about finite groups and I don't care whether they have decidable equality, I just want to be able to count subsets and not run into diamonds -- this is not an unreasonable request I don't think but perhaps the infrastructure is not yet there for this kind of thing.</p>",
        "id": 206451212,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597059392
    },
    {
        "content": "<p>More thoughts about finiteness and cardinality for sets and types.</p>\n<p>Let's start with sets. Now <code>set.finite</code> exists in mathlib already; its definition is</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">fintype</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>. It's not a class. Why is <code>set.finite</code> not a class? <code>is_subgroup</code> was a class. Could both <code>set.finite</code> and <code>set.infinite</code> be classes? This would be unbundled finiteness for sets (<code>normal</code> is unbundled Prop-valued normality for subgroups and we tried bundling it in the group theory game but it's quite inconvenient because you either reproduce a bunch of <code>subgroup.*</code> in <code>normal.*</code> or you put <code>to_subgroup</code> everywhere). The definition of bundled finiteness for sets I'm working with is</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">finset2</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">finite</span> <span class=\"n\">S</span><span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>The idea would be to develop some API for <code>set.finite</code> and encourage mathematicians who don't <code>#eval</code> to either use <code>set.finite</code> or <code>finset2</code> as their standard concept of finiteness for sets depending on whether they like bundled or unbundled -- and in particular to avoid <code>finset</code> completely because this is constructible finiteness.</p>\n<p>For set cardinality the issue is that I don't know whether unbundled or bundled will be best, so I have had to introduce two nat-valued cardinalities -- firstly note that we have</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">equiv_finset</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset2</span> <span class=\"n\">X</span> <span class=\"err\">≃</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n\n\n<p>and so we can define</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">finset2</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">finset2</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"n\">finset2</span><span class=\"bp\">.</span><span class=\"n\">equiv_finset</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n</code></pre></div>\n\n\n<p>i.e. finset2.card is just finset.card but ported over the canonical bijection. This is cardinality for bundled finite sets. For unbundled finite sets there is the issue of trying to find the <code>finite</code> instance, and experience seems to show that this can be hard work, so I introduce</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">sum</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">f</span> <span class=\"k\">else</span> <span class=\"mi\">37</span>\n</code></pre></div>\n\n\n<p>and then define</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>These functions are really easy to apply because they don't check finiteness. Under finiteness conditions you can relate the card to finset2.card and this is your route back to finset.card if you want to port API.</p>\n<p>Earlier on in my Lean career I was concerned about all this <code>noncomputable</code> stuff because I didn't really know how important computability was. The thing to understand about noncomputable cards is that you can still prove Sylow's theorems which are all about cards, you just can't <code>#eval</code>, and because I never <code>#eval</code> anyway I'm not bothered.</p>\n<hr>\n<p>Now onto types. For unbundled finiteness for types I'm using</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">is_finite</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">fintype</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"n\">is_finite</span>\n</code></pre></div>\n\n\n<p>and again the idea is to encourage non-#eval mathematicians to use <code>is_finite</code> instead of <code>fintype</code>, because using it is strictly easier, modulo the fact that of course a whole load of the <code>fintype</code> library needs to be ported over. </p>\n<p>Bundling finite types seems like the sort of thing that the category theory library might want to do, but I'm not doing it right now.</p>\n<p>For cardinality again I follow the principle that the fewer inputs your function has, the easier it is to use it, so I have gone for </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">fincard</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_finite</span> <span class=\"n\">X</span> <span class=\"k\">then</span> <span class=\"bp\">@</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>\n\n\n<p>and of course there's a route back to fintype.card in the <code>is_finite</code> setting, which enables noncomputational API (e.g. all theorems) to be ported.</p>\n<p>All this work is piling up in the group-theory-game repo because we have got to the point where we want to prove Sylow's theorems. I think it might be sensible to start sending some of it to mathlib. Before I start, does anyone have any comments about the proposal, naming conventions, or anything else? I feel bad adding more definitions of finiteness but I think these are the things we need for reasoning. When I was refactoring subgroups I ran into an issue in the proof of Sylow's theorem where we are proving there are subgroups of order p^n for all n&lt;=v_p(G); the n=0 case used <code>bot</code> and at some point I wanted to rewrite <code>card_bot</code> but unfortunately there are two proofs that the bot subgroup of a finite group is finite in mathlib -- one coming from the fact that it's the trivial group and one coming from the fact that a subset of a finite type is finite. This is just silly -- we don't need these subsingleton diamonds getting in the way when we are reasoning.</p>",
        "id": 206614920,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597171685
    },
    {
        "content": "<p>What ever happened to definition irrelevance / API making? Instead of defining <code>finset2</code>, make an api that lets you treat a <code>finset</code> like a <code>finset2</code></p>",
        "id": 206618412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597173328
    },
    {
        "content": "<p>Agree with Mario here, nothing about finset forces you to be constructive.</p>",
        "id": 206618856,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1597173586
    },
    {
        "content": "<p>I think my definition of <code>finsum</code> is strictly more powerful than your <code>sum</code> too. If you are going to have no well definedness assumptions, you may as well have it give a reasonable result on the widest possible domain</p>",
        "id": 206619038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597173639
    },
    {
        "content": "<p>Oops, it appears this is a thread-spanning topic now. I'm referring to <a href=\"#narrow/stream/116395-maths/topic/universe.20hell.20in.20linear.20algebra/near/206415746\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/universe.20hell.20in.20linear.20algebra/near/206415746</a></p>",
        "id": 206619278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597173773
    },
    {
        "content": "<p>Yeah sorry, I had to choose whether to go with this thread or that one.</p>",
        "id": 206619862,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597174077
    },
    {
        "content": "<p>finsum is fine by me -- I was just using something Jeremy knocked up for MIL. I'm not sure I understand the finset2 thing though. I was 100% sure I used finset2 to make is_finite but I just removed the import and don't use it at all. So should I ditch finset2? I'm not sure I even need it now.</p>",
        "id": 206621224,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597174745
    },
    {
        "content": "<p>So is the point that we just don't define <code>finset2</code> at all, prove that <code>{S : set X // finite S} ≃ (finset X)</code> and then for every lemma about finsets I prove some analogous lemma for set.finite?</p>",
        "id": 206621416,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597174840
    },
    {
        "content": "<p>In what sense is that not already done in mathlib?</p>",
        "id": 206621784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597175030
    },
    {
        "content": "<p>set.finite has lots of lemmas generated exactly that way, and they are all very easy</p>",
        "id": 206621847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597175049
    },
    {
        "content": "<p>so you can add more if something is missing without too much trouble</p>",
        "id": 206621865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597175065
    },
    {
        "content": "<p>I am confused about why we don't want <code>finset2</code>. What were the problems with <code>is_subgroup</code> which made us switch to <code>subgroup</code>? Were there actually no problems and we just decided that we wanted the cool dot notation?</p>",
        "id": 206622282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597175314
    },
    {
        "content": "<p>it was a class</p>",
        "id": 206622352,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597175360
    },
    {
        "content": "<p>So <code>set.finite</code> and <code>set.infinite</code> should not be classes? Here's the current definitions (mostly due to other people):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finsupp</span>\n\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">infinite</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">finsum</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span><span class=\"err\">₀</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f&#39;</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">finsum_in</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">finsum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"n\">localized</span> <span class=\"s2\">&quot;notation `∑` binders `, ` r:(scoped:67 f, finsum f) := r&quot;</span> <span class=\"k\">in</span> <span class=\"n\">finsum</span>\n<span class=\"n\">localized</span> <span class=\"s2\">&quot;notation `∑` binders ` in ` s `, ` r:(scoped:67 f, finsum_in s f) := r&quot;</span> <span class=\"k\">in</span> <span class=\"n\">finsum</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"err\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_finite</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">fintype</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"n\">is_finite</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">fincard</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_finite</span> <span class=\"n\">X</span> <span class=\"k\">then</span> <span class=\"bp\">@</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 206630145,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597179353
    },
    {
        "content": "<p>I think <code>set.card</code> should be defined directly rather than by summing ones, but the definition will be equivalent regardless so it's not that important</p>",
        "id": 206630312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597179434
    },
    {
        "content": "<p><code>set.card s := fincard (\\u s)</code> for example</p>",
        "id": 206630380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597179471
    },
    {
        "content": "<p>also <code>set.finite</code> can be refactored on top of <code>is_finite</code></p>",
        "id": 206630474,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597179503
    },
    {
        "content": "<p>As for making <code>is_finite</code> a class, I think it will work okay, but it will be about as good as <code>fintype</code> for what it does</p>",
        "id": 206630585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597179586
    },
    {
        "content": "<p>In particular, AFAICT all the gripes about <code>fintype</code> are eliminated if it is excised from definitions such as <code>fincard</code></p>",
        "id": 206630713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597179638
    },
    {
        "content": "<p>wait -- are you telling me that the def of <code>fincard</code> should be rethought?</p>",
        "id": 206630869,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597179711
    },
    {
        "content": "<p>no, I'm saying that it solves the bulk of the problems on its own</p>",
        "id": 206630935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597179730
    },
    {
        "content": "<p>As long as the <code>fintype</code> instance doesn't occur in the statement of theorems using finiteness, it should be fine to appear as a hypothesis</p>",
        "id": 206631019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597179780
    },
    {
        "content": "<p>so perhaps the <code>is_finite</code> class isn't so important</p>",
        "id": 206631103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597179829
    },
    {
        "content": "<p>This is not just navel-gazing for its own sake -- I'm trying to use finiteness to prove results in group theory. The idea of decreeing that \"we will only take sizes of sets\" or \"...of types\" sounded appealing to me, but I've seen explicit examples today where you really have to move between sets and types.</p>",
        "id": 206631172,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597179847
    },
    {
        "content": "<p>I'm still not convinced that you can't just use <code>fintype (\\u s)</code> for talking about sets in a world of classes on types</p>",
        "id": 206631258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597179894
    },
    {
        "content": "<p>The main use of <code>is_finite</code> is not as a class but as a hypothesis, a proposition to be used however you use propositions</p>",
        "id": 206631338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597179944
    },
    {
        "content": "<p>How are you proposing saying things like \"if p is a partition of the finite type X then the sum of the sizes of the blocks of p equals the size of X\"?</p>",
        "id": 206631364,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597179958
    },
    {
        "content": "<p><code>theorem foo [fintype X] : ... fincard X</code></p>",
        "id": 206631452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597179998
    },
    {
        "content": "<p>But you need to count all the subsets too</p>",
        "id": 206631499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597180030
    },
    {
        "content": "<p>you have a set of subsets -- you don't really want to convert all of these to types, do you?</p>",
        "id": 206631530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597180051
    },
    {
        "content": "<p><code>finsum (\\lam p, fincard p) = fincard X</code></p>",
        "id": 206631532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597180053
    },
    {
        "content": "<p>it's fine, let coercion do its magic</p>",
        "id": 206631550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597180072
    },
    {
        "content": "<p>In practice I was using <code>is_finite</code> in the fincard proofs because most of them are case splits on whether something is finite or not. So it was very convenient to have <code>is_finite</code> as a class because i could just dump it into the inference system and then not worry about it. But I guess that given that I had it, I could just feed it into the theorems I need rather than doing the <code>resetI</code> dance</p>",
        "id": 206631698,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597180196
    },
    {
        "content": "<p>Amusing thing: when doing some set lemmas I realised I was constantly splitting on whether something was finite or infinite, and they were both classes, so I proved that every set was finite or infinite and then was doing <code>cases; resetI</code>. I then joked that I should just be doing <code>casesI</code> so I wrote it for a joke and then it turned out that it existed :P</p>",
        "id": 206631843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597180278
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">partition</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∃!</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"err\">∈</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">p</span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">partition_sum</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">partition</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">finsum_in</span> <span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">fincard</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">fincard</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>easy peasy</p>",
        "id": 206632005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597180325
    },
    {
        "content": "<p>(I won't prove it right now because <code>fincard</code> et al don't have an API yet)</p>",
        "id": 206632046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597180360
    },
    {
        "content": "<p>that's a bad theorem, it uses the forbidden fintype</p>",
        "id": 206632059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597180378
    },
    {
        "content": "<p>No, the fintype does not appear in the statement of the theorem, so you can just get it from wherever you like</p>",
        "id": 206632084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597180399
    },
    {
        "content": "<p>you won't have unification problems as a result</p>",
        "id": 206632124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597180422
    },
    {
        "content": "<p>Oh I see. But you should prove this for <code>is_finite</code> because it's more general</p>",
        "id": 206632150,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597180438
    },
    {
        "content": "<p>it's (constructively, even) equivalent</p>",
        "id": 206632225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597180462
    },
    {
        "content": "<p>then you should prove it for <code>is_finite</code> because fintype is deprecated?</p>",
        "id": 206632330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597180512
    },
    {
        "content": "<p>the idea with this proposal is that you use <code>fintype</code> for your typeclass needs and reserve <code>is_finite</code> as a regular hypothesis that you can pop open when you want to teach the typeclass system</p>",
        "id": 206632338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597180518
    },
    {
        "content": "<p>I thought I never wanted to use <code>fintype</code> ever again?</p>",
        "id": 206632435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597180566
    },
    {
        "content": "<p>It already has all the \"structural\" instances you want</p>",
        "id": 206632463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597180587
    },
    {
        "content": "<p>the bad thing about fintype is that because it is a Type, you can get into unification issues like patrick mentioned at the start of the other thread</p>",
        "id": 206632512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597180626
    },
    {
        "content": "<p>but as long as you use <code>fincard</code> instead of <code>fintype.card</code> that problem goes away</p>",
        "id": 206632545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597180646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/finiteness/near/206631843\">said</a>:</p>\n<blockquote>\n<p>I then joked that I should just be doing <code>casesI</code> so I wrote it for a joke and then it turned out that it existed :P</p>\n</blockquote>\n<p>on a related note, I just discovered <code>fconstructor</code></p>",
        "id": 206735086,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597258349
    },
    {
        "content": "<p>Jason wanted to make an API for <code>finsum</code> (which was defined by Mario to be)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">finsum</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span><span class=\"err\">₀</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f&#39;</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>\n\n\n<p>and he realised that what he wanted was to prove that it equalled finset.sum. This would be easier if we used the following definition:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">finsum2</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"k\">then</span> <span class=\"err\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>\n\n\n<p>Are there disadvantages to <code>finsum2</code> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> ?</p>",
        "id": 206839142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597336897
    },
    {
        "content": "<p>which one has less imports?</p>",
        "id": 206843947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597339421
    },
    {
        "content": "<p>Either way you want to prove both definitions are the same</p>",
        "id": 206843977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597339438
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finsupp</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">support</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">finsum</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span><span class=\"err\">₀</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f&#39;</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">finsum2</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"k\">then</span> <span class=\"err\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">finsum_eq_finsum2</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finsum</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">finsum2</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">finsum</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">finsum2</span><span class=\"o\">,</span>\n  <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"o\">,</span>\n    <span class=\"n\">congr&#39;</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">mem_support_iff</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"n\">h1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">mem_to_finset</span><span class=\"o\">,</span>\n      <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"n\">h1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"n\">clear</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">h1</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">finite_supp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n    <span class=\"n\">clear</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span><span class=\"err\">₀</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">support</span> <span class=\"o\">:=</span> <span class=\"n\">h3</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span>\n      <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n      <span class=\"n\">mem_support_to_fun</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n        <span class=\"n\">intro</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">mem_support</span><span class=\"o\">,</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"bp\">.</span><span class=\"n\">mem_to_finset</span><span class=\"o\">],</span>\n      <span class=\"kn\">end</span> <span class=\"o\">},</span>\n    <span class=\"n\">use</span> <span class=\"n\">f&#39;</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span> <span class=\"bp\">.</span>\n</code></pre></div>",
        "id": 206844082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597339478
    },
    {
        "content": "<p>what is <code>finiteness.is_finite</code>?</p>",
        "id": 206844370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597339615
    },
    {
        "content": "<p>wow, I thought <code>function.support</code> would have an easy definition but the file that defines it has a ton of imports</p>",
        "id": 206844810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597339828
    },
    {
        "content": "<p>I thought we stopped caring about the import hierarchy 37 days ago</p>",
        "id": 206845842,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597340317
    },
    {
        "content": "<p>This file has many imports because it was added after these imports</p>",
        "id": 206859914,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1597347323
    },
    {
        "content": "<p>It's easy to remove all imports if you move lemmas to other files</p>",
        "id": 206860011,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1597347373
    },
    {
        "content": "<p>Another insight from Chris at Xena this evening; how about this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ&#39;</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n  <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elems</span> <span class=\"k\">else</span> <span class=\"err\">∅</span>\n\n<span class=\"n\">def</span> <span class=\"n\">fincard&#39;</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"err\">$</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ&#39;</span> <span class=\"n\">X</span>\n</code></pre></div>\n\n\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> you had suggested</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">fincard</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">fintype</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"bp\">@</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>\n\n\n<p>-- does this variant meet with your approval?</p>",
        "id": 206867649,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597350875
    },
    {
        "content": "<p>ha, clever</p>",
        "id": 206871712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597352821
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I would go as far as saying that the <code>finset.univ</code> in mathlib should be replaced with your new <code>finset.univ'</code> etc.</p>",
        "id": 206871749,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597352844
    },
    {
        "content": "<p>that finset.univ' could be useful for many things</p>",
        "id": 206871752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597352846
    },
    {
        "content": "<p>(etc. = the same for other definitions depending <strong>directly</strong> on fintype)</p>",
        "id": 206871817,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597352876
    },
    {
        "content": "<p>OK so <span class=\"user-mention\" data-user-id=\"243312\">@Jason KY.</span> and I have been hacking away on this stuff, and we ran into something which presumably has been run into before. Recall we've been talking about these definitions (either will do for me but the finset one is easier to port with):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">finsum</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span><span class=\"err\">₀</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f&#39;</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">finsum2</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"k\">then</span> <span class=\"err\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>\n\n\n<p>Jason pointed out that we should probably do products too -- but then we run into the following issue: finsupp and support both want a zero. Is there an analogous construction in Lean which does either of these things but with a 1?</p>",
        "id": 207073922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597588432
    },
    {
        "content": "<p>We can make <code>one_support</code> or whatever -- <code>function.one_support f</code> is the things which don't get mapped to one -- but then <code>to_additive</code> will turn this into <code>zero_support</code>. Presumably we can work around this? But do we want <code>one_support</code> at all?</p>",
        "id": 207074096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597588691
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/finiteness/near/206631843\">said</a>:</p>\n<blockquote>\n<p>so I proved that every set was finite or infinite and then was doing <code>cases; resetI</code>. I then joked that I should just be doing <code>casesI</code> so I wrote it for a joke and then it turned out that it existed :P</p>\n</blockquote>\n<p>I also just learned you can use it instead of unfreezing local instances.</p>",
        "id": 207733621,
        "sender_full_name": "Reid Barton",
        "timestamp": 1598116735
    },
    {
        "content": "<p>We can define <code>set.to_finset</code> using the same trick, then <code>finset.univ = univ.to_finset</code>, <code>fincard = finset.univ.card</code></p>",
        "id": 207735502,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1598119787
    },
    {
        "content": "<p>There's a <code>fincard</code> branch of mathlib by the way.</p>",
        "id": 207736793,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598121596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/finiteness/near/206179081\">said</a>:</p>\n<blockquote>\n<p>Is there any way we could get to a world in which</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finite</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"c1\">-- any definition of finiteness</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n</code></pre></div>\n\n</blockquote>\n<p>I hereby sign this petition.</p>",
        "id": 212431131,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601992720
    },
    {
        "content": "<p>I sign any petition that could make finiteness manageable.</p>",
        "id": 212431901,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1601993039
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/finiteness/near/206183881\">said</a>:</p>\n<blockquote>\n<p>It's my completely unsubstantiated opinion that if we proved a bunch of things for <code>finite</code>, say, we could systematically deduce the consequences for <code>finset</code> and <code>fintype</code> and end up with a more organized API</p>\n</blockquote>\n<p>What would this systematic deduction look like? It should be possible to do that with current definitions, right?</p>\n<p>I think the only design choice that is not trivial upto Prop-eq is whether <code>fintype</code> is Type or Prop valued.</p>",
        "id": 212432715,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601993404
    },
    {
        "content": "<p>Otoh, I do wish quite often that we had</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">t</span>\n<span class=\"c1\">-- instead of</span>\n<span class=\"kd\">def</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">fintype</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 212432826,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601993451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> If you want to start with <code>set.finite</code> instead of <code>finset</code>, I guess</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finite'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n</code></pre></div>\n\n<p>would be an obvious way to start.</p>",
        "id": 212432951,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601993497
    },
    {
        "content": "<p>But it's not yet clear to me how <code>set.finite</code> and <code>finset</code> would become much easier to handle than with what we have now. (Not saying the current setup is easy.)</p>",
        "id": 212433090,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601993541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/finiteness/near/212432951\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> If you want to start with <code>set.finite</code> instead of <code>finset</code>, I guess</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finite'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n</code></pre></div>\n\n<p>would be an obvious way to start.</p>\n</blockquote>\n<p>You don't even need an if and only if, only that <code>l</code> surjects onto <code>s</code>.</p>",
        "id": 212433238,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601993613
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finite'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span>\n</code></pre></div>",
        "id": 212433561,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601993748
    },
    {
        "content": "<p>This makes it easier to prove that the intersection / union of two finite sets are finite.</p>",
        "id": 212433847,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601993855
    },
    {
        "content": "<p>It really doesn't matter how you define <code>finite</code>. The right place to start would be <code>constant finite : set \\a -&gt; Prop</code>. At some point you'll have collected a bunch of proof obligations like <code>finite_union</code>, <code>finite_fin</code>, ... and then you can think about what definition would be best to prove them all.<br>\nA more important question might be whether <code>finite</code> or <code>fintype</code> should be the primitive one, with the other one defined in terms of it. But I think it doesn't matter too much.</p>",
        "id": 212435137,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601994348
    },
    {
        "content": "<p>Currently <code>finset</code> is the primitive one. Is that bad?</p>",
        "id": 212435370,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601994447
    },
    {
        "content": "<p>Oh? Why isn't <code>set.finite</code> defined as \"there exists a finset such that...\"?</p>",
        "id": 212435687,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601994566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/finiteness/near/212433090\">said</a>:</p>\n<blockquote>\n<p>But it's not yet clear to me how <code>set.finite</code> and <code>finset</code> would become much easier to handle than with what we have now. (Not saying the current setup is easy.)</p>\n</blockquote>\n<p>One advantage is everything just becomes more straightforward.</p>\n<ul>\n<li>If you have <code>(s : set T) (h : finite s)</code>, you don't need to go hunt down <code>finite.to_finset</code>. You can just write <code>⟨s, h⟩</code>.</li>\n<li>More importantly, when you extract the underlying <code>set</code> of this <code>finset</code>, it's now defeq to what you started with.</li>\n<li>That means if we define all the <code>has_mem</code>, <code>has_union</code> etc. on <code>finset</code> using the corresponding <code>set</code> definition on the first component, then everything becomes defeq. You don't even really need to prove a theorem like <code>(s t : finset α) : s ⊆ s ∪ t</code> because you can just apply the <code>set</code> version. All lemmas about bounded quantification over <code>set</code> also apply to bounded quantification over <code>finset</code>, etc.</li>\n</ul>",
        "id": 212435729,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601994585
    },
    {
        "content": "<p>(The other, more substantial advantage is that all the <code>decidable_eq</code> stuff disappears, but that comes with tradeoffs.)</p>",
        "id": 212435916,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601994639
    },
    {
        "content": "<p>I think the current definition of <code>finset</code> probably comes from Coq or something but it doesn't fit the mathematician's idea of a finite set, which is first and foremost a <strong>set</strong>, that happens to be finite.</p>",
        "id": 212436240,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601994784
    },
    {
        "content": "<p>Actually, we could probably achieve much of these \"everything becomes more straightforward\" advantages just by changing the definition of <code>finset</code>to have an underlying <code>set</code> field, without simultaneously making things classical.</p>",
        "id": 212436432,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601994858
    },
    {
        "content": "<p>So it would have a <code>set</code> field and a <code>multiset</code> and a proof that they are \"equal\"?</p>",
        "id": 212437183,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601995142
    },
    {
        "content": "<p>But I guess that breaks the \"everything is straightforward\" part of the multiset-finset interface</p>",
        "id": 212437386,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601995218
    },
    {
        "content": "<p>Not saying that's a dealbreaker</p>",
        "id": 212437410,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601995231
    },
    {
        "content": "<p>I guess if you wanted to do the constructive version of this then you would consider <code>s : set</code> together with a \"finiteness structure\" on <code>s</code>, which would be some kind of subsingleton (e.g. <code>trunc (\\Sigma n, s \\~- fin n)</code>)</p>",
        "id": 212437663,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601995328
    },
    {
        "content": "<p>But yeah, you could also do what you suggested.</p>",
        "id": 212438163,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601995545
    },
    {
        "content": "<p>But I'd rather go completely classical. I'm just worried about what the story is going to be for computing, say, <code>finset.sum</code> over a singleton.</p>",
        "id": 212438299,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601995605
    },
    {
        "content": "<p>As far as I can tell, effectively the only purpose of this <code>decidable_eq</code> stuff in <code>finset</code>/<code>fintype</code> is so that <code>finset.sum</code>+relatives will reduce on things like empty sets and singletons (is that it? I thought about <code>finset.insert</code> too but <code>finset.sum_insert</code> doesn't seem to be true by <code>rfl</code> actually).</p>",
        "id": 212438798,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601995822
    },
    {
        "content": "<p>To my mind, the reason <code>finset</code> has a separate name is because it's not just the same as a finite set. If you want a finite set you can say that - a <code>set</code> that is <code>finite</code></p>",
        "id": 212444791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601998138
    },
    {
        "content": "<p>But in that case we should port all the <code>finset.sum</code>, <code>finset.min</code> etc stuff to <code>set</code> + <code>finite</code> where it would be used</p>",
        "id": 212444876,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601998188
    },
    {
        "content": "<p>Well yes, I thought we had made plans about that as well (c.f. <code>finsum</code>)</p>",
        "id": 212445003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601998243
    },
    {
        "content": "<p>In particular I think that in most cases you can leave off the finiteness assumptions in the definitions</p>",
        "id": 212445065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601998278
    },
    {
        "content": "<p>I still really hate this style.</p>",
        "id": 212445223,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601998336
    },
    {
        "content": "<p>I don't think that partial functions does anyone any favors</p>",
        "id": 212445283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601998368
    },
    {
        "content": "<p>particularly when they get involved in stating structures and things, and you need to write proofs inline</p>",
        "id": 212445351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601998400
    },
    {
        "content": "<p>I don't understand how the proposed changes (change argument of <code>sum</code> from <code>finset</code> to <code>set</code> and pass finiteness assumptions to lemmas) won't make long <code>calc</code> manipulations of sums <em>a lot</em> messier.</p>",
        "id": 212445835,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601998630
    },
    {
        "content": "<p>Particularly when the indexing set of the sum is changing through the calculation</p>",
        "id": 212446040,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601998718
    },
    {
        "content": "<p>If each index set is \"structurally\" finite, then we can use a typeclass on <code>set.finite</code> to discharge it</p>",
        "id": 212446476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601998935
    },
    {
        "content": "<p>Oh boy you might have found something I hate even more <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 212446501,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601998951
    },
    {
        "content": "<p>importantly, we won't have to worry about carrying the original finiteness proof through all the manipulations and getting a mismatch when a new proof also applies</p>",
        "id": 212446594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601998996
    },
    {
        "content": "<p>Then again, in a case like this it seems like <code>finset</code> might be more your cup of tea. So why the use of sets?</p>",
        "id": 212446751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601999072
    },
    {
        "content": "<p>Well, for example, because I have a <code>set R</code> which is definable in an o-minimal structure and so I know either it's finite or contains an interval. If it's finite I want to take the smallest element (I also know it's nonempty), if it contains an interval I want to do something else.</p>",
        "id": 212447051,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601999206
    },
    {
        "content": "<p>Currently I think what I do is: if it's finite then I use <code>set.finite.to_finset</code> to get a <code>finset</code>, then take the <code>min</code> of that, and then I need to do a bit of arguing to show how it relates to my original set.</p>",
        "id": 212447369,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601999323
    },
    {
        "content": "<p><code>simp</code>?</p>",
        "id": 212447404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601999339
    },
    {
        "content": "<p>I don't remember exactly what I had to do, but it was effort that served no apparent real purpose.</p>",
        "id": 212448105,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601999670
    },
    {
        "content": "<p>In this case it was just a local <code>let</code> inside a proof, so <code>simp</code> wouldn't be too bad, but if it was an auxiliary top-level definition, then the \"no partial functions\" style is really annoying because the proof of finiteness now becomes a second top-level thing that you have to pass around as well</p>",
        "id": 212448183,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601999713
    },
    {
        "content": "<p>I mean you could use <code>{s // finite s}</code> in some of these applications, but I don't know about giving this type the full mathlib treatment because it is isomorphic to <code>finset</code> and the API is the same</p>",
        "id": 212449060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602000106
    },
    {
        "content": "<p>Replacing <code>finset</code> with this is exactly what I want to do, and I don't agree that the API is the same.</p>",
        "id": 212449205,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602000168
    },
    {
        "content": "<p>the functions are the same, the lemmas are the same</p>",
        "id": 212449226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602000185
    },
    {
        "content": "<p>don't come to me about defeq</p>",
        "id": 212449247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602000198
    },
    {
        "content": "<p>For <code>&lt;s, h&gt;</code> I'd rather see that as a lean limitation that we can't customize the function that this invokes</p>",
        "id": 212449386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602000272
    },
    {
        "content": "<p>Well this is very frustrating. All I can say is that I find <code>finset</code> consistently more difficult to deal with than the <code>set</code> equivalent. For a long time I thought it was just me, but finally I realized that it doesn't have to be this way.</p>",
        "id": 212449515,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602000332
    },
    {
        "content": "<p>If you really want to do it, the API would have to be at least as large as <code>finset.lean</code>. Half baked APIs make me sad</p>",
        "id": 212450217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602000626
    },
    {
        "content": "<p>Of course, my intention was to replace <code>finset</code> entirely</p>",
        "id": 212450293,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602000668
    },
    {
        "content": "<p>so that's why I'm more interested in the question: what will break?</p>",
        "id": 212450346,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602000693
    },
    {
        "content": "<p>But I don't see that as an option, because <code>finset</code> has its place as a nodups <code>multiset</code></p>",
        "id": 212450347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602000693
    },
    {
        "content": "<p>Perhaps that's a niche thing, but it's distinct</p>",
        "id": 212450439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602000723
    },
    {
        "content": "<p>we can change the name if it makes it easier</p>",
        "id": 212450509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602000759
    },
    {
        "content": "<p>As I said: the API is the same, so nothing should break, in particular if <code>fintype</code> remains based on the old <code>finset</code></p>",
        "id": 212450581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602000801
    },
    {
        "content": "<p><code>fintype</code> instances need to compute</p>",
        "id": 212450624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602000822
    },
    {
        "content": "<p>and they are occasionally defeq-forced, so replacing them with something noncomputable isn't going to fly</p>",
        "id": 212450747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602000860
    },
    {
        "content": "<p>Ideally <code>fintype</code> would become a proposition as well, and where something computational is really needed, we would use <code>fin_enum</code>. However I'm not sure how important this is.</p>",
        "id": 212450851,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602000919
    },
    {
        "content": "<p>That seems reasonable; the fact that <code>fintype</code> instances lose the order is occasionally problematic</p>",
        "id": 212451051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602000981
    },
    {
        "content": "<p>so what would be the typeclass for finiteness of sets? would you reuse <code>fintype (\\u s)</code> or would <code>set.finite s</code> be a class?</p>",
        "id": 212451351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602001137
    },
    {
        "content": "<p>I wasn't intending to change the status quo in terms of having <code>finite</code> as an unbundled predicate and <code>finset</code> as a bundled structure for <code>set</code>, and <code>fintype</code> as a class for types... it seems fairly reasonable to me</p>",
        "id": 212451690,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602001302
    },
    {
        "content": "<p>in particular finiteness of sets is often non-structural, e.g., if <code>s ⊆ t</code> and <code>t</code> is finite then <code>s</code> is finite... I guess the same thing can happen with an injective map of types but maybe it's less important there?</p>",
        "id": 212452099,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602001472
    },
    {
        "content": "<p>I mean would the type in instances be <code>[fintype (\\u s)] : fintype (\\u (s \\cap t))</code> or <code>[set.finite s] : set.finite (s \\cap t)</code></p>",
        "id": 212452191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602001517
    },
    {
        "content": "<p>I think injective maps are important enough to please let <code>set.finite</code> not be a class.</p>",
        "id": 212452200,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1602001524
    },
    {
        "content": "<p>both would work I think, the second one requires <code>set.finite</code> to be a class which has occasional consequences for freezing which are sometimes undesirable for a proposition</p>",
        "id": 212452311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602001573
    },
    {
        "content": "<p>I see, I think the first one is okay. But now I also realize I think I haven't had so much experience with <code>fintype</code> directly.</p>",
        "id": 212452389,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602001606
    },
    {
        "content": "<p>If you want <code>fintype</code> on <code>\\u</code> of some set though then it makes sense to have structural instances for this that are parallel to <code>finite.union</code>, ... I guess.</p>",
        "id": 212452564,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602001687
    },
    {
        "content": "<p>but now maybe we're losing the whole <code>{s // finite s}</code> thing this way</p>",
        "id": 212452722,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602001769
    },
    {
        "content": "<p>I'm not sure what these instances would bottom out to though</p>",
        "id": 212452737,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602001781
    },
    {
        "content": "<p>I would still prefer that <code>finite s</code> be defined as it is now, in terms of old <code>finset</code></p>",
        "id": 212452915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602001851
    },
    {
        "content": "<p>Like why would you have any instance of <code>fintype (\\u s)</code> in the first place (aside from if <code>s : set t</code> where <code>fintype t</code>)</p>",
        "id": 212452930,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602001863
    },
    {
        "content": "<p>you might have <code>finite s</code> and <code>haveI</code> a <code>fintype (\\u s)</code> instance</p>",
        "id": 212452977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602001901
    },
    {
        "content": "<p>maybe that's too much trouble?</p>",
        "id": 212452999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602001918
    },
    {
        "content": "<p>Working with finite sets in this way is probably always going to be a little brittle. It's easy to misplace the finiteness proofs</p>",
        "id": 212453273,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602002061
    },
    {
        "content": "<p>I have always found it very easy to work with <code>finset</code> as currently defined because of its robust API, but that's only when dealing with them as <code>finset</code>s and not necessarily when interfacing with sets</p>",
        "id": 212453414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602002154
    },
    {
        "content": "<p>aagh I hate defeq</p>",
        "id": 212453600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602002269
    },
    {
        "content": "<p>I think <code>finite</code> would end up sort of like <code>is_subgroup</code> in that (besides maybe being used to implement <code>finset</code>) it ends up getting used mainly to mediate between the <code>set</code> world and the <code>finset</code> world</p>",
        "id": 212453766,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602002354
    },
    {
        "content": "<p>like in the definable set example I gave before, where you have a <code>set</code> and then later you acquire the information that it's finite</p>",
        "id": 212453792,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602002372
    },
    {
        "content": "<p>I mean you can do all that with the current API</p>",
        "id": 212454142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602002551
    },
    {
        "content": "<p>I'm sorry the function that does it has a name</p>",
        "id": 212454175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602002571
    },
    {
        "content": "<p>right, and you end up with 100-character long <code>simp only</code>s instead of nothing</p>",
        "id": 212454214,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602002598
    },
    {
        "content": "<p>nothing, he says</p>",
        "id": 212454236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602002612
    },
    {
        "content": "<p>I guess I don't understand the apparent opposition. Like is it a problem that <code>(x, y).fst</code> is defeq to <code>x</code>? Should we have only a propositional equality?</p>",
        "id": 212454377,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602002675
    },
    {
        "content": "<p>Why would it be unreasonable to think \"finite set\" = <code>subtype set.finite</code>?</p>",
        "id": 212454440,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602002720
    },
    {
        "content": "<p>I really hate this aspect of lean, that it makes one look so much worse than the other even though they are about the same complexity</p>",
        "id": 212454456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602002729
    },
    {
        "content": "<p>If defeq wasn't a thing then they would be the same, and you could set up the \"refl\"-equivalent tactic to work with whatever you say</p>",
        "id": 212454578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602002786
    },
    {
        "content": "<p>in lean that tool is <code>simp</code> but it does just a bit too much</p>",
        "id": 212454624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602002818
    },
    {
        "content": "<p>Right, I agree that this whole conversation  is somehow an artifact of DTT</p>",
        "id": 212454635,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602002826
    },
    {
        "content": "<p>Is there a way we can fix this with more notation?</p>",
        "id": 212454871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602002980
    },
    {
        "content": "<p>like make the constructor easier to call, and add a custom simp set to make the <code>simp only</code> more palatable</p>",
        "id": 212454985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602003031
    },
    {
        "content": "<p>I think if we start bending over backwards to make all the defeqs work out we will lose, because it is impossible to please everyone</p>",
        "id": 212455114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602003113
    },
    {
        "content": "<p>all equalities should be defeqs</p>",
        "id": 212455177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602003127
    },
    {
        "content": "<p>Already Johan's suggestion of adding \"... and a <code>set</code>, such that it's equal to the <code>multiset</code>\" would be an improvement. Then all the lemmas that say that union commutes with taking the underlying sets get baked into the definitions of those operations.</p>",
        "id": 212455675,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602003393
    },
    {
        "content": "<p>But since (independently of this issue) it's also quite annoying to deal with <code>finset.inter</code> and so on having these <code>decidable_eq</code> instances which may or may not be coherent, and considering that in the end, it's unclear how much working constructively really buys us, it seems to me that doing things classically would be better anyways. And at that point just using <code>subtype set.finite</code> seems like a welcome simplification.</p>",
        "id": 212456961,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602004048
    },
    {
        "content": "<p>I wonder if this might be a good setup. It lets you reuse all the <code>fintype</code> machinery, so it might make fleshing out the interface easier.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">new_finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_set</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finite</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">to_set</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">set.to_new_finset</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">new_finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">new_finset.mk</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">new_finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">new_finset.to_set</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">new_finset.coe</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">new_finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.to_set</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">new_finset.fintype</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">new_finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"n\">s.finite</span>\n</code></pre></div>",
        "id": 212462420,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1602006931
    },
    {
        "content": "<p>The current <code>finset</code> would still exist somewhere but with a new name.</p>",
        "id": 212462576,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1602007001
    },
    {
        "content": "<p>You also get a fairly nice <code>new_finset.univ</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">new_finset.univ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">new_finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_set</span> <span class=\"o\">:=</span> <span class=\"n\">set.univ</span><span class=\"o\">,</span>\n  <span class=\"n\">finite</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 212463166,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1602007253
    },
    {
        "content": "<p>Wouldn't this get annoying because you would have to deal with the coercion from the set to the associated subtype?</p>",
        "id": 212463333,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1602007323
    },
    {
        "content": "<p>If you want to go between <code>set</code> and <code>finset</code> you already have to use <code>set.to_finset</code> and <code>finset</code>'s lift to <code>set</code>.</p>\n<p>But something that would likely be a problem is that there are non-defeq <code>fintype</code> instances... so I retract this proposal.  (Maybe it'd be ok with <code>nonempty (fintype to_set)</code>.)</p>",
        "id": 212464263,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1602007835
    },
    {
        "content": "<p>Reviving this thread, I'm wondering whether there's a reason the first definition was chosen over the second:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">set.finite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">fintype</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"c1\">-- versus</span>\n<span class=\"kd\">def</span> <span class=\"n\">set.finite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">t</span>\n</code></pre></div>",
        "id": 252102661,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630876881
    },
    {
        "content": "<p>Also, in case it changes the calculus of including a noncomputable finset, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set_like\">docs#set_like</a> would be a way to implement one with a little less boilerplate (but still, it would be an undertaking to do it this way):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">finset'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finite'</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finset'</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">set_like</span> <span class=\"o\">(</span><span class=\"n\">finset'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">finset'.s</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">congr'</span> <span class=\"o\">}⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">mem_coe</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s.s</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">@[ext]</span> <span class=\"kd\">theorem</span> <span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">set_like.ext</span> <span class=\"n\">h</span>\n\n<span class=\"sd\">/-- Copy of a `finset'` with a new `s` equal to the old one. Useful to fix definitional</span>\n<span class=\"sd\">equalities. See See Note [range copy pattern]. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">copy</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"n\">finite'</span> <span class=\"o\">:=</span> <span class=\"n\">hs.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">s.finite'</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finite</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">s.finite'</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">finset'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s.finite.some</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_set_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"n\">s.finite.some_spec.symm</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">set.finite_mem_finset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">fintype</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finset'</span>\n</code></pre></div>",
        "id": 252102755,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630876991
    }
]
[
    {
        "content": "<p>What's the best way to prove a theorem about a mutual type where the induction should use both types?</p>",
        "id": 127212172,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1527523806
    },
    {
        "content": "<p>I know that there is <code>mutual def</code> but that's really not good to work with when you're not into pattern matching but instead use tactics...</p>",
        "id": 127212388,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1527524256
    },
    {
        "content": "<p>There must be a recursion theorem somewhere that does what <code>mutual def</code> does, right?</p>",
        "id": 127212435,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1527524335
    },
    {
        "content": "<p>The usual approach is to use <code>mutual def</code>. Internally it is implemented by well founded recursion, so you can also do that yourself but the equation compiler does all the hard work. If you must do it manually (or if the default well founded recursion is not strong enough), you will probably want to state a custom induction principle, and prove it by unfolding the underlying <code>._mut_</code> type. Here's an example:</p>\n<div class=\"codehilite\"><pre><span></span>mutual inductive even, odd\nwith even : ℕ → Prop\n| zero : even 0\n| succ {n} : odd n → even (n+1)\nwith odd : ℕ → Prop\n| succ {n} : even n → odd (n+1)\n\ntheorem even_mut_induction {E : ℕ → Prop} {O : ℕ → Prop}\n  (H0 : E 0)\n  (H1 : ∀ n, odd n → O n → E (n+1))\n  (H2 : ∀ n, even n → E n → O (n+1)) :\n  (∀ n, even n → E n) ∧ (∀ n, odd n → O n) :=\nbegin\n  suffices : ∀ i, even._mut_ i →\n    (match i with\n    | psum.inl ⟨n, ()⟩ := E n\n    | psum.inr ⟨n, ()⟩ := O n\n    end : Prop),\n  { exact ⟨λ n, this _, λ n, this _⟩ },\n  intros i h,\n  induction h with n h IH n h IH,\n  { exact H0 },\n  { exact H1 n h IH },\n  { exact H2 n h IH }\nend\n</pre></div>",
        "id": 127219962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527538756
    },
    {
        "content": "<p>Thanks for the example :)</p>",
        "id": 127224740,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1527548954
    },
    {
        "content": "<p>Too bad that the recursor you're proving there is not generated automatically</p>",
        "id": 127224789,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1527549010
    },
    {
        "content": "<p>I don't think we have a good story for what mutual induction principles look like in general</p>",
        "id": 127225223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527550031
    },
    {
        "content": "<p>There is some weak induction principle generated by default,</p>\n<div class=\"codehilite\"><pre><span></span>#print even.rec\n-- protected def even.rec : ∀ (C : Π (a : ℕ), even a → Prop),\n--  C 0 even.zero → (∀ {n : ℕ} (a : odd n), C (n + 1) _) → ∀ (a : ℕ) (x : even a), C a x\n#print odd.rec\n-- protected def odd.rec : ∀ (C : Π (a : ℕ), odd a → Prop),\n--  (∀ {n : ℕ} (a : even n), C (n + 1) _) → ∀ (a : ℕ) (x : odd a), C a x\n</pre></div>\n\n\n<p>but as you can see they are non-mutual</p>",
        "id": 127225269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527550140
    },
    {
        "content": "<p>lean 4 will have mutual inductives built in the kernel, so this problem will have to be addressed</p>",
        "id": 127225277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527550191
    },
    {
        "content": "<p>I'm not sure how to best express the induction principle (using <code>and</code> seems a bit of a hack)</p>",
        "id": 127259598,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1527610214
    },
    {
        "content": "<p>What do you mean by \"good story\"? I don't have a reference at hand, but I'm pretty sure that problem is solved in theory</p>",
        "id": 127259636,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1527610284
    },
    {
        "content": "<p>That's how it's done in Isabelle, no? Except they have a nice meta and.</p>",
        "id": 127259641,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1527610297
    },
    {
        "content": "<p>One could argue that since we got propositions as types, Lean's normal and is at least as nice as Isabelles meta and <span class=\"emoji emoji-1f600\" title=\"grinning\">:grinning:</span></p>",
        "id": 127268128,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1527620972
    },
    {
        "content": "<p>there isn't really any dichotomy between ands in lean, so it's not a big problem. The one thing is that and only works on Props, while mutual inductions in general are mutual recursion, in which case you want a data type like <code>pprod</code></p>",
        "id": 127268228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1527621078
    },
    {
        "content": "<p>Oh right... <code>pprod</code> then</p>",
        "id": 127268297,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1527621166
    }
]
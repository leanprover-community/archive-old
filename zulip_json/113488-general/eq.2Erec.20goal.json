[
    {
        "content": "<p>If my goal is</p>\n<div class=\"codehilite\"><pre><span></span>eq.rec (finsupp.prod g₂ (λ (r : R) (n : ℤ), minimal_value_group.mk v₂ r ^ n)) _ =\n    finsupp.prod g₂ (λ (r : R) (n : ℤ), minimal_value_group.mk v₂ r ^ n)\n</pre></div>\n\n\n<p>then did I take a wrong turn or is there some easy way to finish this?</p>",
        "id": 157593938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549359433
    },
    {
        "content": "<p>If both sides are definitional equal then you can just apply <code>refl</code>. Proof irrelevance in definitional equality allows<code>eq.rec</code> to compute as long as the data fits.</p>",
        "id": 157594186,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1549359756
    },
    {
        "content": "<p>So the <code>_</code> (before <code>=</code>) may be an arbitrary proof, even a variable. Still <code>eq.rec</code> can reduce by computation, Lean will interpret an arbitrary proof as <code>refl _</code> as this always fits</p>",
        "id": 157594266,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1549359846
    },
    {
        "content": "<p>I tried <code>refl</code> and it didn't work, that's why I posted here :-/</p>",
        "id": 157594847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549360586
    },
    {
        "content": "<p><code>dsimp</code> takes me to</p>\n<div class=\"codehilite\"><pre><span></span>⊢ eq.rec (finsupp.prod g₂ (λ (r : R), pow (minimal_value_group.mk v₂ r))) _ =\n    finsupp.prod g₂ (λ (r : R), pow (minimal_value_group.mk v₂ r))\n</pre></div>",
        "id": 157594962,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549360723
    },
    {
        "content": "<p>I haven't got my head around the goal really.</p>",
        "id": 157594973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549360745
    },
    {
        "content": "<p>There are no weird variable names occurring twice:</p>\n<div class=\"codehilite\"><pre><span></span>R : Type u₁,\n_inst_4 : comm_ring R,\nΓ₁ : Type u₂,\n_inst_5 : linear_ordered_comm_group Γ₁,\nΓ₂ : Type u₃,\n_inst_6 : linear_ordered_comm_group Γ₂,\nv₁ : valuation R Γ₁,\nv₂ : valuation R Γ₂,\nh : is_equiv v₁ v₂,\ng₁ g₂ : multiplicative (R →₀ ℤ),\nh12 :\n  (λ (f : multiplicative (R →₀ ℤ)),\n       finsupp.prod f (λ (r : R) (n : ℤ), (λ (r : R), option.get_or_else (⇑v₁ r) 1) r ^ n))\n      (g₁⁻¹ * g₂) =\n    1,\nthis :\n  finsupp.prod g₁ (λ (r : R) (n : ℤ), minimal_value_group.mk v₂ r ^ n) =\n    finsupp.prod g₂ (λ (r : R) (n : ℤ), minimal_value_group.mk v₂ r ^ n)\n⊢ eq.rec (finsupp.prod g₂ (λ (r : R), pow (minimal_value_group.mk v₂ r))) _ =\n    finsupp.prod g₂ (λ (r : R), pow (minimal_value_group.mk v₂ r))\n</pre></div>",
        "id": 157594991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549360797
    },
    {
        "content": "<p>There might be universe issues. Is this possible?</p>",
        "id": 157595134,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549360930
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I am scared I am running into problems because of that structure with a new type in the data.</p>",
        "id": 157595141,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549360958
    },
    {
        "content": "<p>you haven't really said all that is needed to identify the problem</p>",
        "id": 157595249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361109
    },
    {
        "content": "<p><code>eq.rec</code> hides a lot of info</p>",
        "id": 157595252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361116
    },
    {
        "content": "<p><a href=\"https://gist.github.com/kbuzzard/75f316bccc64cb17f5217e02e364b4e8\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/75f316bccc64cb17f5217e02e364b4e8\">https://gist.github.com/kbuzzard/75f316bccc64cb17f5217e02e364b4e8</a></p>",
        "id": 157595267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361158
    },
    {
        "content": "<p>what is the type of the argument in the <code>_</code>?</p>",
        "id": 157595319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361205
    },
    {
        "content": "<p>What's an easy way to find this out?</p>",
        "id": 157595322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361218
    },
    {
        "content": "<p>I don't understand the goal.</p>",
        "id": 157595333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361227
    },
    {
        "content": "<p>possibly <code>suffices h, change eq.rec (finsupp.prod g₂ (λ (r : R), pow (minimal_value_group.mk v₂ r))) h = _</code></p>",
        "id": 157595347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361269
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>invalid &#39;eq.rec&#39; application, elaborator has special support for this kind of application (it is handled as an &quot;eliminator&quot;), but expected type must not contain metavariables\n  ?m_1\n</pre></div>",
        "id": 157595447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361378
    },
    {
        "content": "<p>If you can explain what the goal means then I can think about the maths and try and figure out what I have done.</p>",
        "id": 157595522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361441
    },
    {
        "content": "<p>The goal appeared when I had a term in a quotient group and I applied the <code>induction</code> tactic on the term.</p>",
        "id": 157595544,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361476
    },
    {
        "content": "<p>well this is the problem with <code>eq.rec</code> terms, they don't give enough information to be reconstructible</p>",
        "id": 157595546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361478
    },
    {
        "content": "<p>Hmm.</p>",
        "id": 157595548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361479
    },
    {
        "content": "<p>Maybe <code>cases</code> would have been a better tactic.</p>",
        "id": 157595555,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361487
    },
    {
        "content": "<p>this is the fault of a <code>simp</code> or <code>rw</code> somewhere</p>",
        "id": 157595567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361510
    },
    {
        "content": "<p>does <code>@@eq.rec (λ\n        (g :\n          @valuation.minimal_valuation.parametrized_subgroup.Γ.{u₁ u₂} Γ₁ _inst_5\n            (@valuation.minimal_value_group.{u₁ u₂} R _inst_4\n               (λ (a b : R), classical.prop_decidable (@eq.{u₁+1} R a b))\n               Γ₁\n               _inst_5\n               v₁)),\n          @valuation.minimal_valuation.parametrized_subgroup.Γ.{u₁ u₃} Γ₂ _inst_6\n            (@valuation.minimal_value_group.{u₁ u₃} R _inst_4\n               (λ (a b : R), classical.prop_decidable (@eq.{u₁+1} R a b))\n               Γ₂\n               _inst_6\n               v₂)) _ h = _</code> work?</p>",
        "id": 157595624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361538
    },
    {
        "content": "<p><code>cases</code> doesn't work but perhaps I need to think about the moment the term appeared and try something less naive.</p>",
        "id": 157595632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361550
    },
    {
        "content": "<p>for the term in the <code>change</code></p>",
        "id": 157595642,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361561
    },
    {
        "content": "<p>That looks like a constant function, meaning you tried to cast a term across an equality of types</p>",
        "id": 157595672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361634
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  eq.rec ?m_2 h\nterm\n  h\nhas type\n  is_equiv v₁ v₂\nbut is expected to have type\n  ?m_1 = ?m_2\n</pre></div>",
        "id": 157595718,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361655
    },
    {
        "content": "<p>did you <code>suffices h,</code>?</p>",
        "id": 157595725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361678
    },
    {
        "content": "<p>So the goal originally had an <code>eq.rec</code> with one of the g2's replaced by a g1, and I thought \"I don't understand that goal, maybe it's just a stupid way of saying the two terms are equal\". So I wrote</p>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"n\">g₁</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">minimal_value_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">v₂</span> <span class=\"n\">r</span> <span class=\"err\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n             <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"n\">g₂</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">minimal_value_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">v₂</span> <span class=\"n\">r</span> <span class=\"err\">^</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n</pre></div>\n\n\n<p>because I fancied my chances at proving this. So I did a rewrite inside an eq.rec and that's what has burnt me.</p>",
        "id": 157595750,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361746
    },
    {
        "content": "<p>can you show more context? What's the proof</p>",
        "id": 157595809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361790
    },
    {
        "content": "<p>that goal doesn't look that bad, you are just proving an equality</p>",
        "id": 157595834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361830
    },
    {
        "content": "<p>This was the goal:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"n\">g₁</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">minimal_value_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">v₂</span> <span class=\"n\">r</span> <span class=\"err\">^</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span>\n    <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"n\">g₂</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">minimal_value_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">v₂</span> <span class=\"n\">r</span> <span class=\"err\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>and then I wrote the \"suffices\" stuff above</p>",
        "id": 157595836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361836
    },
    {
        "content": "<p>no no, like 6 steps before this</p>",
        "id": 157595839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361845
    },
    {
        "content": "<p>how did we get here</p>",
        "id": 157595844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361856
    },
    {
        "content": "<p>this isn't very MWE so give some more context</p>",
        "id": 157595858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361880
    },
    {
        "content": "<p><code>induction g</code> was where things started to go wrong.</p>",
        "id": 157595899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361890
    },
    {
        "content": "<p><code>g</code> is an element of a quotient group.</p>",
        "id": 157595904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361912
    },
    {
        "content": "<p>I have no idea what <code>g</code> is or what <code>induction</code> is proving</p>",
        "id": 157595905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361913
    },
    {
        "content": "<p>but I wanted to get an element of the top group</p>",
        "id": 157595908,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361930
    },
    {
        "content": "<p>and the <code>eq.rec</code> is the assertion that my argument is independent of the choice of lift.</p>",
        "id": 157595923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549361952
    },
    {
        "content": "<p>The <code>_</code> argument is a <code>quot.sound</code> according to your pp.all</p>",
        "id": 157595929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549361965
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Post the entire lemma + proof-attempt + tactic state. I guess that will help more.</p>",
        "id": 157595932,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1549361976
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- Notes: if v1 equiv v2 then we need a bijection from the image of v1 to the</span>\n<span class=\"c1\">-- image of v2; we need that the supports are the same; we need that</span>\n<span class=\"c1\">-- the minimal_value_group for v2 is isomorphic to the subgroup of Gamma_2 generated</span>\n<span class=\"c1\">-- by the image of the stuff not in the support.</span>\n\n<span class=\"c1\">-- Theorem we almost surely need -- two equivalence valuations have isomorphic</span>\n<span class=\"c1\">-- value groups.</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">minimal_valuations_biject_of_equiv</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"err\">Γ₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ₁</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"err\">Γ₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₃</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_comm_group</span> <span class=\"err\">Γ₂</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">v₁</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v₂</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_equiv</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">minimal_value_group</span> <span class=\"n\">v₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"err\">Γ</span>  <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">minimal_value_group</span> <span class=\"n\">v₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"err\">Γ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">g</span> <span class=\"k\">with</span> <span class=\"n\">g</span> <span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"n\">h12</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">n</span><span class=\"o\">,(</span><span class=\"n\">minimal_value_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">v₂</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"err\">^</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h12</span> <span class=\"k\">with</span> <span class=\"n\">h12</span> <span class=\"n\">hoops</span><span class=\"o\">,</span>\n    <span class=\"n\">swap</span><span class=\"o\">,</span><span class=\"n\">cases</span> <span class=\"n\">hoops</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- If φ1 is the function from R to Γ1 which is v1 away from the support and</span>\n  <span class=\"c1\">-- sends the support to 1, then φ1 extends to a group hom Z[R] -&gt; Γ1 (free ab group on R)</span>\n  <span class=\"c1\">-- and h12 is the hypothesis that g₁⁻¹g₂ is in the kernel, so g₁ and g₂ get sent to</span>\n  <span class=\"c1\">-- the same element of Γ1. We need the analogous result for φ2.</span>\n  <span class=\"n\">convert</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"n\">g₁</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">minimal_value_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">v₂</span> <span class=\"n\">r</span> <span class=\"err\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n             <span class=\"n\">finsupp</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"n\">g₂</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">minimal_value_group</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">v₂</span> <span class=\"n\">r</span> <span class=\"err\">^</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n   <span class=\"n\">subst</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">swap</span><span class=\"o\">,</span><span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- I am in eq.rec hell</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 157596007,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362052
    },
    {
        "content": "<p>Instead of <code>induction g</code> I could perhaps have used some more suitable approach for working with quotient groups.</p>",
        "id": 157596022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362075
    },
    {
        "content": "<p>you are constructing a function by tactics?</p>",
        "id": 157596030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362090
    },
    {
        "content": "<p>oh oops</p>",
        "id": 157596034,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362100
    },
    {
        "content": "<p>this isn't a lemma</p>",
        "id": 157596037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362101
    },
    {
        "content": "<p>oh yeah</p>",
        "id": 157596043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362106
    },
    {
        "content": "<p>good catch. It used to be a lemma.</p>",
        "id": 157596045,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362111
    },
    {
        "content": "<p>dammit</p>",
        "id": 157596089,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362129
    },
    {
        "content": "<p>I see, you should have used quotient.lift instead of this induction/cases business</p>",
        "id": 157596091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362134
    },
    {
        "content": "<p>even if this worked I wouldn't be able to prove anything about it.</p>",
        "id": 157596093,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362138
    },
    {
        "content": "<p>Yes. Do you remember that a few weeks ago I constructed my own quotient types just by using sets of equivalence classes?</p>",
        "id": 157596111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362170
    },
    {
        "content": "<p>And I said \"look what I did, what's all this quot axiom stuff?\"</p>",
        "id": 157596113,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362179
    },
    {
        "content": "<p>and people made comments about computability that I didn't understand.</p>",
        "id": 157596121,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362190
    },
    {
        "content": "<p>What is <code>(minimal_value_group v₁).Γ</code>?</p>",
        "id": 157596128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362240
    },
    {
        "content": "<p>is it a quotient?</p>",
        "id": 157596168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362245
    },
    {
        "content": "<p>or more to the point, shouldn't it be hidden behind an API?</p>",
        "id": 157596176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362269
    },
    {
        "content": "<p>Yes</p>",
        "id": 157596177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362270
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/why.20is.20quot.20an.20axiom.3F\" title=\"#narrow/stream/113488-general/topic/why.20is.20quot.20an.20axiom.3F\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why.20is.20quot.20an.20axiom.3F</a></p>",
        "id": 157596179,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362273
    },
    {
        "content": "<p>Can you see that the proof...erm...construction is full of comments? I was just trying to run at it and make notes to see what API I need.</p>",
        "id": 157596188,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362303
    },
    {
        "content": "<p>The top down approach, frowned upon by you guys.</p>",
        "id": 157596198,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362316
    },
    {
        "content": "<p>I'm not as good as you at working out what API I need, I just try and prove the thing I want and let the API come later when I get stuck.</p>",
        "id": 157596205,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362331
    },
    {
        "content": "<p>well, <code>minimal_value_group</code> sounds like a thing you want to have an abstract characterization of</p>",
        "id": 157596212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362350
    },
    {
        "content": "<p>if it's defined as a quotient, then probably there is a lift like theorem about it, possibly slightly different than the one lean gives you</p>",
        "id": 157596266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362387
    },
    {
        "content": "<p>what's the math story here?</p>",
        "id": 157596275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362418
    },
    {
        "content": "<p>The notes above the theorem are intermediate results which I realised I needed precisely because I was getting stuck. There is more than one sorry in the proof.</p>",
        "id": 157596276,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362420
    },
    {
        "content": "<p>There is a set-theoretic issue in the definition of a perfectoid space and it is one that we have already talked about at length.</p>",
        "id": 157596287,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362438
    },
    {
        "content": "<p>right</p>",
        "id": 157596289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362445
    },
    {
        "content": "<p><code>minimal_value_group</code> is the resolution, and it has a UMP that you put some blood/sweat/tears into</p>",
        "id": 157596292,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362474
    },
    {
        "content": "<p>use it</p>",
        "id": 157596336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362486
    },
    {
        "content": "<p>A valuation on a ring R is a pair consisting of an abelian group G in an arbitrary universe and, lying slightly, a map from R to G.</p>",
        "id": 157596338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362491
    },
    {
        "content": "<p>The blood sweat and tears was replacing G by a group G' in the same universe as R and proving that the new valuation was equivalent to the old one.</p>",
        "id": 157596357,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362543
    },
    {
        "content": "<p>I am trying to prove a random thing about this equivalence that I am not ready for, but my idea is that proving it tells me more about the API I need.</p>",
        "id": 157596370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362561
    },
    {
        "content": "<p>So G' is <code>minimal_value_group</code> right?</p>",
        "id": 157596390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362581
    },
    {
        "content": "<p>You say replacing G by G', what is the relation between them</p>",
        "id": 157596395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362598
    },
    {
        "content": "<p>Let's say two valuations on R are <em>isomorphic</em> if the G's are isomorphic and the diagram commutes.</p>",
        "id": 157596396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362600
    },
    {
        "content": "<p>I am trying to prove that if two valuations are equivalent, then the associated minimal valuations are isomorphic.</p>",
        "id": 157596457,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362628
    },
    {
        "content": "<p>aha, okay, that sounds like an easy consequence of the right UMP</p>",
        "id": 157596472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362656
    },
    {
        "content": "<p>If R were a group and v were a group homomorphism (which it may as well be for the purposes of this discussion) then the minimal valuation group would be the image of R under v</p>",
        "id": 157596486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362678
    },
    {
        "content": "<p>wait that's exactly wrong</p>",
        "id": 157596498,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362695
    },
    {
        "content": "<p>the minimal valuation group would be the quotient of R by the kernel of v</p>",
        "id": 157596504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362710
    },
    {
        "content": "<p>which is in R's universe</p>",
        "id": 157596511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362714
    },
    {
        "content": "<p>there should be some kind of commutative diagram here</p>",
        "id": 157596513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362717
    },
    {
        "content": "<p>like a map factors through this minimal valuation</p>",
        "id": 157596559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362733
    },
    {
        "content": "<p>I think what I need is a second \"minimal\" valuation which is the thing I just said, replace G with the subgroup which is the image of R</p>",
        "id": 157596569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362755
    },
    {
        "content": "<p>didn't you already do that?</p>",
        "id": 157596574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362769
    },
    {
        "content": "<p>I never introduced the second one.</p>",
        "id": 157596578,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362781
    },
    {
        "content": "<p>Given R,G,v I made G1 := R/ker(v)</p>",
        "id": 157596588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362800
    },
    {
        "content": "<p>(here R is a group)</p>",
        "id": 157596591,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362803
    },
    {
        "content": "<p>(and v a group hom)</p>",
        "id": 157596594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362806
    },
    {
        "content": "<p>but I never made G2 := im(v)</p>",
        "id": 157596597,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362814
    },
    {
        "content": "<p>and I think that I must need it.</p>",
        "id": 157596601,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362824
    },
    {
        "content": "<p>we don't need it</p>",
        "id": 157596603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362827
    },
    {
        "content": "<p>Oh great!</p>",
        "id": 157596606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362832
    },
    {
        "content": "<p>they are iso, right?</p>",
        "id": 157596607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362832
    },
    {
        "content": "<p>Yes</p>",
        "id": 157596609,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362836
    },
    {
        "content": "<p>what we need is the UMP associated to G1</p>",
        "id": 157596657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362852
    },
    {
        "content": "<p>I see.</p>",
        "id": 157596668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362863
    },
    {
        "content": "<p>if you have a suitable map out of R, it factors through the valuation to make a map out of G1</p>",
        "id": 157596675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362877
    },
    {
        "content": "<p>I proved that (v,G) and (v1,G1) were equivalent</p>",
        "id": 157596681,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362882
    },
    {
        "content": "<p>or something like that</p>",
        "id": 157596682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362882
    },
    {
        "content": "<p>but I need more.</p>",
        "id": 157596690,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362888
    },
    {
        "content": "<p>This is really annoying. I might need G2.</p>",
        "id": 157596697,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362902
    },
    {
        "content": "<p>this should all be a consequence of the fact that you defined G1 := R/ker(v), just unfold what those things mean</p>",
        "id": 157596718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362928
    },
    {
        "content": "<p>The definition of equivalent is really crappy. v:R-&gt;G and w:R-&gt;H are equivalent if the image of v and the image of w are isomorphic via an isomorphism that makes the diagram commute.</p>",
        "id": 157596724,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362939
    },
    {
        "content": "<p>sounds fine to me</p>",
        "id": 157596731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362959
    },
    {
        "content": "<p>the problem is that this involves images</p>",
        "id": 157596777,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549362970
    },
    {
        "content": "<p>although maybe it might be good to have the one directional version, make a category kind of setup</p>",
        "id": 157596792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362988
    },
    {
        "content": "<p>because then you can talk about initiality</p>",
        "id": 157596795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549362999
    },
    {
        "content": "<p>Actually, another problem is that not even this is the definition, this is a lemma which I am only now realising I need.</p>",
        "id": 157596797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363001
    },
    {
        "content": "<p>Dammit the underlying problem is exactly this \"mathematicians don't know how to write an API\" issue. I write something down and then because so many things are trivially true and their proof does not even need mentioning, I can lecture on it assuming a whole bunch of stuff (like the first isomorphism theorem) and not even notice what I am using.</p>",
        "id": 157596840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363069
    },
    {
        "content": "<p>I can see exactly which lemmas have content and it's those that I prove in a lecture</p>",
        "id": 157596889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363093
    },
    {
        "content": "<p>You have a category of valuations and valuation morphisms, where the homs v -&gt; w are ordered group homs f : G-&gt;H such that v o f = w</p>",
        "id": 157596891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363100
    },
    {
        "content": "<p>but you want me to prove all the content-free ones.</p>",
        "id": 157596893,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363103
    },
    {
        "content": "<p>Is there an issue with this approach because the valuations can take values in an arbitrary universe?</p>",
        "id": 157596900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363125
    },
    {
        "content": "<p>you don't have to define this category explicitly, but you should keep it in mind to state the facts</p>",
        "id": 157596906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363139
    },
    {
        "content": "<p>But you're right, this is exactly the thing I should be thinking about. I have not defined a morphism of valuations.</p>",
        "id": 157596925,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363157
    },
    {
        "content": "<p>as long as you don't try to define the category, the universe thing shouldn't matter</p>",
        "id": 157596927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363159
    },
    {
        "content": "<p>But I need to define the morphisms because I am using them again and again.</p>",
        "id": 157596937,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363175
    },
    {
        "content": "<p>and an iso in this category should be an equivalence of valuations</p>",
        "id": 157596945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363193
    },
    {
        "content": "<p>It's worse than that</p>",
        "id": 157596997,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363214
    },
    {
        "content": "<p>and the minimal valuation is an initial object in the category</p>",
        "id": 157596998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363215
    },
    {
        "content": "<p>An iso in this category is an isomorphism of valuations</p>",
        "id": 157597015,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363228
    },
    {
        "content": "<p>The equivalences are the ones for which the underlying map G -&gt; H is an injection</p>",
        "id": 157597020,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363246
    },
    {
        "content": "<p>no it's not even that</p>",
        "id": 157597022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363249
    },
    {
        "content": "<p>the equivalences are ones for which the underlying map G -&gt; H induces an isomorphism v(R) -&gt; w(R)</p>",
        "id": 157597034,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363266
    },
    {
        "content": "<p>The problem is that these groups are \"too big\" in general</p>",
        "id": 157597041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363280
    },
    {
        "content": "<p>so isomorphism is too strong</p>",
        "id": 157597043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363283
    },
    {
        "content": "<p>We only care about the image of R</p>",
        "id": 157597050,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363287
    },
    {
        "content": "<p>hence the notion of equivalence</p>",
        "id": 157597054,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363293
    },
    {
        "content": "<p>why isn't that the same as I said?</p>",
        "id": 157597055,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363293
    },
    {
        "content": "<p>Because if G=R and H is a far larger group containing R and both v and w are the obvious maps</p>",
        "id": 157597069,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363321
    },
    {
        "content": "<p>for the condition v o f = w only the value on elements of R matters</p>",
        "id": 157597108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363323
    },
    {
        "content": "<p>but there's no map H -&gt; G</p>",
        "id": 157597117,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363333
    },
    {
        "content": "<p>which is the identity on G. Groups are harder than that.</p>",
        "id": 157597121,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363345
    },
    {
        "content": "<p>I see, so you want f : v(R) -&gt; w(R) but otherwise it should be the same</p>",
        "id": 157597129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363365
    },
    {
        "content": "<p>is v(R) a subgroup?</p>",
        "id": 157597146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363391
    },
    {
        "content": "<p>yes</p>",
        "id": 157597151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363400
    },
    {
        "content": "<p>I am talking about a toy model where R is a group and v is a group hom</p>",
        "id": 157597157,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363414
    },
    {
        "content": "<p>The truth is that R is a ring, G is an ordered group, v goes from R to G union {0} and satisfies some axioms</p>",
        "id": 157597168,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363433
    },
    {
        "content": "<p>but that's not the problem as far as I am concerned.</p>",
        "id": 157597171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363441
    },
    {
        "content": "<p>I think the underlying problems I have are all present in the toy model.</p>",
        "id": 157597221,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363463
    },
    {
        "content": "<p>so does it work like I said? Homs are f : v(R) -&gt; w(R) such that v o f = w</p>",
        "id": 157597231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363491
    },
    {
        "content": "<p>Yes! But you said homs are f : G -&gt; H such that v o f = w I think</p>",
        "id": 157597244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363509
    },
    {
        "content": "<p>and now isos are equivalences of valuations</p>",
        "id": 157597245,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363516
    },
    {
        "content": "<p>yes</p>",
        "id": 157597247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363521
    },
    {
        "content": "<p>It's a strange category because the f's are not defined on the full groups but this is the way to think about it I think</p>",
        "id": 157597257,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363547
    },
    {
        "content": "<p>now there are some issues because functions on images are not nice in lean</p>",
        "id": 157597318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363576
    },
    {
        "content": "<p>I think it's important to let G and H be as big as you like, because we don't want to write \"WLOG v is surjective\" everywhere.</p>",
        "id": 157597322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363591
    },
    {
        "content": "<p>that's fine, I think, as long as the homs take this into account</p>",
        "id": 157597337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363614
    },
    {
        "content": "<p>[in the real model, the \"image\" is actually the subgroup of G generated by v(R') where R' is the subset of R consisting of elements r such that v(r) is not zero]</p>",
        "id": 157597348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363645
    },
    {
        "content": "<p>But I have never once used this image, or even defined it.</p>",
        "id": 157597350,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363660
    },
    {
        "content": "<p>then what is f?</p>",
        "id": 157597357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363673
    },
    {
        "content": "<p>do you let it be 0 outside or something?</p>",
        "id": 157597406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363689
    },
    {
        "content": "<p>I consistently use the quotient of the free abelian group on R -- the thing in the right universe.</p>",
        "id": 157597407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363692
    },
    {
        "content": "<p>There's an auxiliary function v' which is defined to be v on R' and if v(r)=0 then v'(r)=1.</p>",
        "id": 157597419,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363718
    },
    {
        "content": "<p>I then look at the map from the free abelian group on R to G extending v' and the minmal value group is the quotient of the free abelian group on R by the kernel of this map.</p>",
        "id": 157597433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363755
    },
    {
        "content": "<p>I only mention these technicalities because you mentioned the image as being hard to work with and actually we have something more complicated than the image. But note that I never constructed the image. We can look at the subgroup of G generated by v' but this object, which is isomorphic to the minimal value group, has never been mentioned before.</p>",
        "id": 157597499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363817
    },
    {
        "content": "<p>in a lot of ways the coimage is actually easier to work with</p>",
        "id": 157597512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363842
    },
    {
        "content": "<p>The coimage is what we have, right?</p>",
        "id": 157597515,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363854
    },
    {
        "content": "<p>The quotient of the free ab group by the kernel?</p>",
        "id": 157597519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363860
    },
    {
        "content": "<p>yes, seems like</p>",
        "id": 157597529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363866
    },
    {
        "content": "<p>When I was saying \"pretend R is a group\" earlier I was thinking \"replace R by the free abelian group on R'\"</p>",
        "id": 157597537,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363885
    },
    {
        "content": "<p>so it sounds like now instead of f : v(R) -&gt; w(R) we have <code>f : R*/ker(v) -&gt; R*/ker(w)</code> where <code>R*</code> is the free ab group</p>",
        "id": 157597545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549363908
    },
    {
        "content": "<p>So we need the coimage because it's in the right universe.</p>",
        "id": 157597547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363913
    },
    {
        "content": "<p>yes that's it</p>",
        "id": 157597593,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363924
    },
    {
        "content": "<p>We should make <code>R*</code> the free abelian group on <code>R</code>, because R' depends on v, but this is OK.</p>",
        "id": 157597633,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549363987
    },
    {
        "content": "<p>and now v o f = w becomes what?</p>",
        "id": 157597646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549364000
    },
    {
        "content": "<p>the obvious diagram commutes</p>",
        "id": 157597669,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364017
    },
    {
        "content": "<p>wait that's true by definition</p>",
        "id": 157597677,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364034
    },
    {
        "content": "<p>no it isn't</p>",
        "id": 157597681,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364041
    },
    {
        "content": "<p>There's a canonical map from <code>R*</code> to <code>R*/ker(v)</code></p>",
        "id": 157597732,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364064
    },
    {
        "content": "<p>and one from <code>R*</code> to <code>R*/ker(w)</code></p>",
        "id": 157597736,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364072
    },
    {
        "content": "<p>and that's the diagram we want to commute</p>",
        "id": 157597737,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364077
    },
    {
        "content": "<p>Before, we had v : R -&gt; G which restricts to v : R -&gt; v(R). Now we are using the coimage, which is isomorphic, so there should be another canonical construction</p>",
        "id": 157597738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549364078
    },
    {
        "content": "<p>we are only allowed to write down maps from <code>R*/ker(v)</code> to <code>R*/ker(w)</code> which commute with the two canonical projections</p>",
        "id": 157597768,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364112
    },
    {
        "content": "<p>(projection the way mathematicians use the word)</p>",
        "id": 157597776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364125
    },
    {
        "content": "<p>oh, I see, and that's all that's necessary?</p>",
        "id": 157597785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549364142
    },
    {
        "content": "<p>I think so</p>",
        "id": 157597790,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364153
    },
    {
        "content": "<p>okay, so now initiality says that we have <code>v1</code> such that for any other <code>v</code> there is a map <code>R*/ker(v1) -&gt; R*/ker(v)</code></p>",
        "id": 157597853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549364220
    },
    {
        "content": "<p>and that should be min_value_group</p>",
        "id": 157597866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549364246
    },
    {
        "content": "<p>I don't think it's quite like that.</p>",
        "id": 157597886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364268
    },
    {
        "content": "<p>Given v, the min-value-group for v is <code>R*/ker(v)</code></p>",
        "id": 157597933,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364286
    },
    {
        "content": "<p>there's an induced valuation <code>v_min:R-&gt;(R*/ker(v)) union 0</code></p>",
        "id": 157597956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364319
    },
    {
        "content": "<p>that's the min valuation associated to v. We love it because it lives in a sensible universe.</p>",
        "id": 157597962,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364340
    },
    {
        "content": "<p>What I want is that if v and w are equivalent</p>",
        "id": 157597983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364365
    },
    {
        "content": "<p>which means that the images <code>v(R*)</code> and <code>w(R*)</code> are isomorphic in a way that makes the diagram commute</p>",
        "id": 157598000,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364387
    },
    {
        "content": "<p>then <code>v_min</code> and <code>w_min</code> are now <em>equal</em></p>",
        "id": 157598052,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364405
    },
    {
        "content": "<p>and it was in proving this that I got my <code>eq.rec</code> goal</p>",
        "id": 157598068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364439
    },
    {
        "content": "<p>No!</p>",
        "id": 157598073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364448
    },
    {
        "content": "<p>I wasn't proving anything.</p>",
        "id": 157598075,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364456
    },
    {
        "content": "<p>You are telling me that what I should be proving is that <code>ker(v)=ker(w)</code></p>",
        "id": 157598090,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364472
    },
    {
        "content": "<p>but if I follow my nose then I end up proving that the images are isomorphic</p>",
        "id": 157598109,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364499
    },
    {
        "content": "<p>So if v : R -&gt; G and w : R -&gt; H, we have the min-value-group <code>R*/ker(v)</code>, and another valuation <code>vmin : R -&gt; R*/ker(v)</code>. Initiality is saying that if w respects v in some sense, then there is a group hom <code>lift w : R*/ker(v) -&gt; H</code></p>",
        "id": 157598112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549364512
    },
    {
        "content": "<p>This should translate into a proof that the coimages are isomorphic</p>",
        "id": 157598116,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364518
    },
    {
        "content": "<p>I think w respects v should be something like <code>ker(v) &lt;= ker(w)</code>, which can be translated to something about w and v directly</p>",
        "id": 157598177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549364546
    },
    {
        "content": "<p>yes</p>",
        "id": 157598180,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364554
    },
    {
        "content": "<p><code>&lt;=</code> is a set-theoretic containment I assume</p>",
        "id": 157598191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364572
    },
    {
        "content": "<p>in this free abelian group <code>R*</code></p>",
        "id": 157598209,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364587
    },
    {
        "content": "<p>in the lattice of subgroups, yes</p>",
        "id": 157598210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549364588
    },
    {
        "content": "<p>right</p>",
        "id": 157598215,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364594
    },
    {
        "content": "<p>So this more general notion of \"respecting v\" is defintely not in the repo.</p>",
        "id": 157598224,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364615
    },
    {
        "content": "<p>I don't think it needs to be given a name and everything, it's just the side condition on <code>lift</code></p>",
        "id": 157598233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549364640
    },
    {
        "content": "<p>The paper says \"two valuations are equivalent if im(v) is isomorphic to im(w) in a way that makes the diagrams commute\"</p>",
        "id": 157598277,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364650
    },
    {
        "content": "<p>I'm not thinking about equivalent valuations just yet here</p>",
        "id": 157598285,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549364666
    },
    {
        "content": "<p>No you're working with a general morphism</p>",
        "id": 157598288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364677
    },
    {
        "content": "<p>once you have this lift function, it should be easy to prove the thing about equivalent valuations, just lift <code>wmin</code></p>",
        "id": 157598313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549364713
    },
    {
        "content": "<p>I read the paper and I read it as \"coim(v) is isomorphic to coim(w) in a way that makes the diagrams commute\" because I can rewrite canonical isomorphisms -- the mathematician's superpower.</p>",
        "id": 157598315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364722
    },
    {
        "content": "<p>and \"isomorphic in a way that makes the diagrams commute\" is the same as \"equal\"</p>",
        "id": 157598320,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364735
    },
    {
        "content": "<p>It's incredible how much of a kerfuffle it is to get this into dependent type theory. I need to disassociate images and coimages in my mind. Because the coimage is a quotient you have specific tools for writing functions on it and I should use these tools.</p>",
        "id": 157598498,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549364974
    },
    {
        "content": "<p>It's like the category of open subsets of a topological space again. It's extremely similar in fact. I regard <code>id' U</code> and <code>U</code> as _equal_ but you regard them as distinct but isomorphic elements of this category.</p>",
        "id": 157598576,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549365036
    },
    {
        "content": "<p>I am not sure that making this distinction ever helps you in mathematics</p>",
        "id": 157598581,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549365054
    },
    {
        "content": "<p>but it certainly helps you in dependent type theory.</p>",
        "id": 157598590,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549365065
    },
    {
        "content": "<p>You can write down maps <code>U -&gt; id' U</code> and <code>id' U -&gt; U</code> and prove that they're isomorphisms and two-sided inverses of each other, whilst I watch incredulously.</p>",
        "id": 157598609,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549365114
    },
    {
        "content": "<p>Then I try to use the fact that they're _equal_ when defining a map on sheaves and get into all kinds of trouble in dependent type theory, which I do not see in mathematics.</p>",
        "id": 157598667,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549365155
    },
    {
        "content": "<p>This has been very helpful, many thanks Mario. I am back thinking seriously about the perfectoid project now and goodness knows how long I would have spent stuck on this issue had your comments not clarified how someone who knows type theory properly thinks about these questions.</p>",
        "id": 157598760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549365269
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I think my fears are unfounded. I just don't have enough API yet.</p>",
        "id": 157598807,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549365338
    },
    {
        "content": "<p>The problem with things being <em>equal</em> in the material set theory sense is that it tends to make the <em>wrong</em> distinctions, like id' U = U but coimage(v) != image(v)</p>",
        "id": 157599578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549366251
    },
    {
        "content": "<p>If you want to be able to talk about equality when you mean isomorphism, you have to have some kind of background formalism that mimics DTT in some ways</p>",
        "id": 157599609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549366306
    },
    {
        "content": "<p>because isomorphism doesn't mean unique isomorphism, and there are plenty of examples where the collection of all isomorphisms X -&gt; Y has interesting structure</p>",
        "id": 157599659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1549366358
    },
    {
        "content": "<p>oh god what hell is this discussion</p>",
        "id": 157602405,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1549369480
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> If you gave me an MWE then I might be able to solve it</p>",
        "id": 157602462,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1549369544
    },
    {
        "content": "<p>It's all pushed to the perfectoid project, in valuations.lean. But I know what I have to do, and it doesn't really involve solving this problem. It involves making more API and not typing <code>induction g</code> to get an element of G from an element of G/H.</p>",
        "id": 157626265,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549390042
    },
    {
        "content": "<p>Do you know that <code>rintro</code> is very useful when working with quotients?</p>",
        "id": 157632487,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1549394352
    },
    {
        "content": "<p>This is a complete XY problem. You only got to eq.rec because you used <code>induction</code> on a quotient.</p>",
        "id": 157896450,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1549662726
    },
    {
        "content": "<p>I know</p>",
        "id": 157896476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549662759
    },
    {
        "content": "<p>but I knew that I needed some more API so I've been working on that instead.</p>",
        "id": 157896513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549662807
    },
    {
        "content": "<p>great</p>",
        "id": 157896531,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1549662834
    },
    {
        "content": "<p>Patrick suggested using rintro which I'm sure is better, but I could see that there was no point proceeding anyway because I couldn't prove the thing which reduced me to the eq.rec hell anyway, so I thought I'd work on that instead (Huber 1.27 or so)</p>",
        "id": 157896732,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549662967
    },
    {
        "content": "<p>Is this true? I was hoping <code>simp</code> would deal with it in my use case but it doesn't. I want to fill in the sorry.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.subgroup</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hx'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">how_to_prove_this</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">eq.rec</span> <span class=\"o\">(⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx'</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"n\">trivial</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The state at the sorry is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">M</span>\n<span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">M</span>\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span>\n<span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"n\">n</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span>\n<span class=\"n\">hx'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">eq.rec</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx'</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 237903763,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620429440
    },
    {
        "content": "<p>[background: all I did was make A n an A 0-module by observing that multiplication sends A 0 x A n to A (0 + n)...]</p>",
        "id": 237904531,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620430002
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.subgroup</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subtype_heq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hq</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">subtype</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">==</span> <span class=\"o\">(⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hq</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">subtype</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">heq_of_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hx'</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">how_to_prove_this</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">eq.rec</span> <span class=\"o\">(⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx'</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">eq_of_heq</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">heq.trans</span> <span class=\"o\">(</span><span class=\"n\">eq_rec_heq</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">apply</span> <span class=\"n\">subtype_heq</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">trivial</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>here's my ungolfed solution, probably can be done better</p>",
        "id": 237904868,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620430288
    },
    {
        "content": "<p><code>eq_rec_heq</code>! Thanks!</p>",
        "id": 237905330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620430635
    },
    {
        "content": "<p>Oh excellent, this also works in my use case. So the moral is to use <code>heq</code> when dealing with <code>eq.rec</code>?</p>",
        "id": 237905767,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620430991
    },
    {
        "content": "<p>In my opinion, yeah; and also that separate lemmas with the equality of types abstracted can be helpful</p>",
        "id": 237905794,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620431028
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <a href=\"https://github.com/leanprover-community/mathlib/blob/5cfcb6a0d598b25b1d8441bbd82ade52a64e9865/src/algebra/direct_sum_graded.lean#L470-L471\">This</a> innocuous-looking definition of a module hides a nasty <code>eq.rec</code> which is causing me trouble :-( In the internal direct sum you don't need an eq.rec because you just prove the product is in the right piece. I'm not sure there's much we can do about it though!</p>",
        "id": 237907099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620432036
    },
    {
        "content": "<p>I'm not sure it's so innocuous looking when it's data constructed with eq.rec :-)</p>",
        "id": 237907862,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1620432599
    },
    {
        "content": "<p><code>subtype_heq</code> already exists with another name</p>",
        "id": 237932636,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620457320
    },
    {
        "content": "<p>Perhaps <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype.heq_of_coe_eq\">docs#subtype.heq_of_coe_eq</a>?</p>",
        "id": 237932691,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620457350
    },
    {
        "content": "<p>Ah, it's <a href=\"https://github.com/leanprover-community/mathlib/issues/6259\">#6259</a></p>",
        "id": 237932838,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620457508
    },
    {
        "content": "<p>I think the only way to eliminate that eq.rec would be to allow a second <code>smul</code> data field in gmonoid</p>",
        "id": 237932970,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1620457634
    }
]
[
    {
        "content": "<p>I was just reading the proof that all classical circuits/Boolean functions can be generated by AND and XOR gates along with FANOUT and CROSSOVER operations and the like - and I was wondering how you would prove this in Lean. I was thinking maybe you would want to define some suitable inductive type for circuits, and then show that you have some map from that to Boolean functions and then show that the map is surjective.</p>\n<p>But I'm not sure how such a type should be properly defined. Does anyone have any thoughts? Surely something like this has been done before?</p>",
        "id": 305771186,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666600674
    },
    {
        "content": "<p>I would guess something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">gate</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">xor</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">gate</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">gate</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">input</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">gate.eval</span> <span class=\"o\">(</span><span class=\"n\">args</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">gate</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"n\">input</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">args</span> <span class=\"n\">i</span>\n<span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">band</span> <span class=\"o\">(</span><span class=\"n\">x.eval</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y.eval</span> <span class=\"n\">args</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">xor</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">bxor</span> <span class=\"o\">(</span><span class=\"n\">x.eval</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y.eval</span> <span class=\"n\">args</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">gate.eval</span>\n</code></pre></div>",
        "id": 305772233,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1666601130
    },
    {
        "content": "<p>In that example, fanouts and crossovers are encoded in lean's expression tree to make things easier</p>",
        "id": 305772502,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1666601262
    },
    {
        "content": "<p>What about functions with multiple outputs? Potentially I guess you could do that as a general case of this...</p>",
        "id": 305775169,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666602291
    },
    {
        "content": "<p>Also I think it wants to be <code>fin n</code> instead of general sigma as the argument I know does an induction.</p>",
        "id": 305776465,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666602770
    },
    {
        "content": "<p>At the very least a fintype (I can't recall if doing an induction on fintypes is a good idea).</p>",
        "id": 305776541,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666602795
    },
    {
        "content": "<p>I'm also pretty sure that FANOUT and CROSSOVER want to be explicit gates because they are part of the content of the circuit (and FANOUT in particular can't exist in a quantum circuit, so it's good to make the distinction explicit).</p>",
        "id": 305780560,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666604330
    },
    {
        "content": "<p>A function with multiple outputs is just a collection of single-output functions</p>",
        "id": 305795433,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1666610237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/113488-general/topic/Defining.20circuits.20.2B.20proving.20circuit.20generation/near/305776465\">said</a>:</p>\n<blockquote>\n<p>Also I think it wants to be <code>fin n</code> instead of general sigma as the argument I know does an induction.</p>\n</blockquote>\n<p>You can always prove the surjectivity for <code>σ = fin n</code> or <code>fintype σ</code>, there's no need to restrict the definition</p>",
        "id": 305795513,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1666610272
    },
    {
        "content": "<p>You also need to be able to feed in dummy values.</p>",
        "id": 305894110,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666637972
    },
    {
        "content": "<p>I think that's ok currently</p>",
        "id": 305894155,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666637988
    },
    {
        "content": "<p>You might be interested in the description in terms of monoidal categories (circuits with FANOUT and CROSSOVER \"live\" in a cartesian monoidal category, circuits with CROSSOVER \"live\" in a symmetric monoidal category, circuits with neither live in a monoidal category). In some sense your inductive type is going to be the construction of the free [cartesian|symmetric| ] monoidal category, but before quotienting by all the relations making the axioms true. (e.g. that CROSSOVER squares to the identity, etc)</p>",
        "id": 305923489,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1666650506
    },
    {
        "content": "<p>Yes, I believe this is true.</p>",
        "id": 305999064,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666693875
    },
    {
        "content": "<p>I guess what I'm most struggling with is how you define the operation that is, you know, \"I have some circuit with 5 outputs and I want to stick 3 of those outputs into another circuit with 4 inputs, get an input from another circuit, and let the other outputs extend\"</p>",
        "id": 305999543,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666694090
    },
    {
        "content": "<p>Which I can't picture with Eric's construction.</p>",
        "id": 305999575,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666694104
    },
    {
        "content": "<p>You can do that by adding what amounts to a monad instance on <code>gate</code>: Given a <code>gate X</code> and a function from <code>X</code> to <code>gate Y</code> you can construct a <code>gate Y</code> by composition</p>",
        "id": 306000440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666694518
    },
    {
        "content": "<p>In Eric's construction circuits only have one output. A circuit with multiple outputs would be a <code>Output -&gt; gate Input</code> function (a Kleisli arrow).</p>",
        "id": 306000784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666694691
    },
    {
        "content": "<p>Aha</p>",
        "id": 306000794,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666694699
    },
    {
        "content": "<p>where Output and Input are both themselves kinds of gate?</p>",
        "id": 306000869,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666694747
    },
    {
        "content": "<p>In the last bit <code>Output</code> and <code>Input</code> are finite types that range over the set of wires coming in/out</p>",
        "id": 306000947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666694775
    },
    {
        "content": "<p>so the input value of type <code>Output</code> is selecting which wire you want to sample</p>",
        "id": 306001017,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666694810
    },
    {
        "content": "<p>You can use Eric's <code>eval</code> function to apply a <code>Output -&gt; gate Input</code> to a <code>Input -&gt; bool</code> function to get an <code>Output -&gt; bool</code> function (this might help explain why everything seems turned around, the input and output are contravariant)</p>",
        "id": 306001296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666694943
    },
    {
        "content": "<p><code>Output</code> and <code>Input</code> can be thought of as types that hold the names of the wires. Most like you will want to set them to <code>fin n</code> so that you can use <code>![ ... ]</code> notation, but there's no reason to do so in the definition</p>",
        "id": 306002298,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1666695429
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">gate.bind</span> <span class=\"o\">(</span><span class=\"n\">blocks</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">gate</span> <span class=\"n\">σ2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">gate</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">gate</span> <span class=\"n\">σ2</span>\n<span class=\"bp\">|</span> <span class=\"n\">input</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">blocks</span> <span class=\"n\">i</span>\n<span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">band</span> <span class=\"o\">(</span><span class=\"n\">x.bind</span> <span class=\"n\">blocks</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y.bind</span> <span class=\"n\">blocks</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">xor</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">bxor</span> <span class=\"o\">(</span><span class=\"n\">x.bind</span> <span class=\"n\">blocks</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y.bind</span> <span class=\"n\">blocks</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I couldn't work it out from your initial description; do you want to allow constant values? if so, you can implement <code>eval</code> in terms of <code>bind</code> composed with <code>gate.const</code>. If you only want to permit \"dummy\" wires with indeterminate values, then I think you can still do this but you'll need to make the return type of <code>eval</code> <code>option bool</code></p>",
        "id": 306002898,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1666695694
    },
    {
        "content": "<p>Yes, I want to allow constant values.</p>",
        "id": 306006148,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666697054
    },
    {
        "content": "<p>So oddly enough, entirely separately to the above I was looking today at this Coq definition (for a different context, but similar context). How would I replicate this in Lean 3/Lean 4?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Inductive</span> <span class=\"n\">ZX</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Empty</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">X_Spider</span> <span class=\"n\">nIn</span> <span class=\"n\">nOut</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nIn</span> <span class=\"n\">nOut</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Z_Spider</span> <span class=\"n\">nIn</span> <span class=\"n\">nOut</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nIn</span> <span class=\"n\">nOut</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Cap</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Cup</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"mi\">2</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Swap</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"mi\">2</span> <span class=\"mi\">2</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Stack</span> <span class=\"o\">{</span><span class=\"n\">nIn0</span> <span class=\"n\">nIn1</span> <span class=\"n\">nOut0</span> <span class=\"n\">nOut1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">zx0</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nIn0</span> <span class=\"n\">nOut0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zx1</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nIn1</span> <span class=\"n\">nOut1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"n\">ZX</span> <span class=\"o\">(</span><span class=\"n\">nIn0</span> <span class=\"bp\">+</span> <span class=\"n\">nIn1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nOut0</span> <span class=\"bp\">+</span> <span class=\"n\">nOut1</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Compose</span> <span class=\"o\">{</span><span class=\"n\">nIn</span> <span class=\"n\">nMid</span> <span class=\"n\">nOut</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">zx0</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nIn</span> <span class=\"n\">nMid</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zx1</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nMid</span> <span class=\"n\">nOut</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nIn</span> <span class=\"n\">nOut.</span>\n</code></pre></div>",
        "id": 306622693,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666952165
    },
    {
        "content": "<p>I'm not sure what <code>R</code> is (though I recognize the inductive type as being for the ZX graphical calculus), but here's Lean 3:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ZX</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℕ</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">Empty</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">X_Spider</span> <span class=\"n\">nIn</span> <span class=\"n\">nOut</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nIn</span> <span class=\"n\">nOut</span>\n<span class=\"bp\">|</span> <span class=\"n\">Z_Spider</span> <span class=\"n\">nIn</span> <span class=\"n\">nOut</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nIn</span> <span class=\"n\">nOut</span>\n<span class=\"bp\">|</span> <span class=\"n\">Cap</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"mi\">0</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"n\">Cup</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"mi\">2</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">Swap</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"mi\">2</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"n\">Stack</span> <span class=\"o\">{</span><span class=\"n\">nIn0</span> <span class=\"n\">nIn1</span> <span class=\"n\">nOut0</span> <span class=\"n\">nOut1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">zx0</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nIn0</span> <span class=\"n\">nOut0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zx1</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nIn1</span> <span class=\"n\">nOut1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">ZX</span> <span class=\"o\">(</span><span class=\"n\">nIn0</span> <span class=\"bp\">+</span> <span class=\"n\">nIn1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nOut0</span> <span class=\"bp\">+</span> <span class=\"n\">nOut1</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">Compose</span> <span class=\"o\">{</span><span class=\"n\">nIn</span> <span class=\"n\">nMid</span> <span class=\"n\">nOut</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">zx0</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nIn</span> <span class=\"n\">nMid</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zx1</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nMid</span> <span class=\"n\">nOut</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ZX</span> <span class=\"n\">nIn</span> <span class=\"n\">nOut</span>\n</code></pre></div>",
        "id": 306623237,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666952386
    },
    {
        "content": "<p>Ah right, <code>R</code> should be the real numbers, recording the phase for the X/Z spider</p>",
        "id": 306623825,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1666952574
    },
    {
        "content": "<p>Right I thought it should just work in place.</p>",
        "id": 306623905,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666952601
    },
    {
        "content": "<p>And aye it's the ZX Calculus.</p>",
        "id": 306623973,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666952626
    },
    {
        "content": "<p>Yeah, alright, that does appear to work in Lean 3 - not sure about Lean 4 though.</p>",
        "id": 306625610,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1666953252
    },
    {
        "content": "<p>Is there any intuition as to why ZX calculus is used over more traditional representations of circuits?</p>",
        "id": 315422950,
        "sender_full_name": "Lev Stambler",
        "timestamp": 1670866823
    }
]
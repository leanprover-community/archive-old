[
    {
        "content": "<p>strangely I can't find an answer to this: why do we care about proof irrelevance?<br>\ni've found a few arguments referring to program extraction - those make sense. if you're going to extract, you don't want all the \"evidence\".<br>\nbut why do we care about it mathematically? what are some examples of how this makes theorem proving easier?<br>\ni guess one of the things i've found is that it allows you to quantify over all propositions. but I don't quite see why that's worth the complexity.</p>\n<p>edit: I guess my real question is: can someone give me an idea about what is hard/impossible without proof irrelevance?</p>",
        "id": 271768629,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1644790770
    },
    {
        "content": "<p>One answer is that if <code>s : set α</code>, then elements of <code>s</code> are in one-to-one correspondence with terms of <code>subtype (∈ s)</code> (that's <code>s</code> coerced to a type). If there weren't proof irrelevance, then in principle every element of <code>s</code> could correspond to more than one term of <code>subtype (∈ s)</code> (one for each membership proof).  Irrelevance seems to make it easier to blur the distinction between sets and types.</p>",
        "id": 271768901,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644791101
    },
    {
        "content": "<p>I think one of the low hanging fruits is that you get definitional equality for any two <code>p p' : P</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"456923\">Leonard Wiechmann</span> <a href=\"#narrow/stream/113488-general/topic/why.20proof.20irrelevance.3F/near/271768629\">said</a>:</p>\n<blockquote>\n<p>I don't quite see why that's worth the complexity.</p>\n</blockquote>\n<p>Is it more complex? I'm not a type theory expert, but most of the stuff I've read about proof relevance has to do with higher inductive types, which certainly seem more complex than proof irrelevance.</p>",
        "id": 271769864,
        "sender_full_name": "Chris B",
        "timestamp": 1644792408
    },
    {
        "content": "<p>ok, i'm kind of getting a feeling for why it might be useful: sometimes you only want something to have a property and don't really care <em>why</em> it has that property. you can still use that property to derive other properties, just not if the proof is relevant. which appears to be very common. i think i'll get a better understanding for this by eg trying to prove some stuff without proof irrelevance.</p>\n<p>re <span class=\"user-mention\" data-user-id=\"228466\">@Chris B</span> \"Is it more complex?\": i'm judging complexity by the number of typing rules, roughly. so the number of things that my type theory implementation needs to get right. also I don't really want to add rules that I don't understand too well, especially because it seems to be pretty easy to make a system inconsistent.</p>",
        "id": 271770297,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1644793025
    },
    {
        "content": "<p>Ah, I see where you're coming from. Mario's thesis on the type theory of lean has a section that discusses proof irrelevance and has some references to some other sources: <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">https://github.com/digama0/lean-type-theory/releases/tag/v1.0</a></p>",
        "id": 271770852,
        "sender_full_name": "Chris B",
        "timestamp": 1644793572
    },
    {
        "content": "<p>oh that sounds promising, thanks!!</p>",
        "id": 271770907,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1644793640
    },
    {
        "content": "<p>I messed around with a proof-relevant identity type.<br>\nBut I couldn't prove symmetry. I'm getting the feeling that it is impossible with proof relevance.<br>\nI tried the same trick you use for <code>eq</code>: <code>eq_helper</code> in the code below.<br>\nBut the recursor requires a much more complicated type: <code>Π (a1 a2 : A), Eq a1 a2 → Sort l</code><br>\nWhen trying to apply <code>Eq_helper</code> to <code>Eq.rec</code> anyway, I had to give an instance of <code>Π (a_1 : A), Eq a_1 a</code>, which of course doesn't exist in general.<br>\nMaybe I'm missing something. Surely you can do rewrites in something like HoTT, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Eq</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Sort</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n\n\n<span class=\"kd\">@[reducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">eq_helper</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">eq_symm</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">ab</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">aa</span> <span class=\"o\">:=</span> <span class=\"n\">eq.refl</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">ba</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">eq.rec</span> <span class=\"n\">A</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">eq_helper</span> <span class=\"n\">A</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">aa</span> <span class=\"n\">b</span> <span class=\"n\">ab</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ba</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n\n\n<span class=\"kd\">def</span> <span class=\"n\">Eq_helper</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x1</span> <span class=\"n\">x2</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">x1</span> <span class=\"n\">x2</span><span class=\"o\">)),</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">x2</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Eq_symm</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">ab</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">aa</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">ba</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Eq.rec</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">Eq_helper</span> <span class=\"n\">A</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"kd\">variable</span> <span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span>\n<span class=\"kd\">variable</span> <span class=\"n\">a_1</span><span class=\"o\">:</span> <span class=\"n\">A</span>\n<span class=\"kd\">variable</span> <span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">A</span>\n<span class=\"k\">#reduce</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">Eq_helper</span> <span class=\"n\">A</span> <span class=\"n\">a</span> <span class=\"n\">a_1</span> <span class=\"n\">a_1</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">a_1</span><span class=\"o\">))</span>   <span class=\"c1\">-- Π (a_1 : A), Eq a_1 a</span>\n</code></pre></div>",
        "id": 271849359,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1644855350
    },
    {
        "content": "<p>It seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Eq</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Sort</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Eq_symm</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">_</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">refl</span><span class=\"o\">]</span> <span class=\"n\">Eq.refl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Eq_symm'</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 271850812,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644855927
    },
    {
        "content": "<p>Here's a direct use of the recursor:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Eq_symm''</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">Eq.refl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The <code>by exact</code> is because something's not elaborating correctly and that fixed it for reasons unknown.</p>",
        "id": 271851056,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644856048
    },
    {
        "content": "<p>hmm yeah, that works. i'll have to study that a bit more.<br>\nhere's the proof with an explicit motive:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Eq_helper</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x1</span> <span class=\"n\">x2</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">x1</span> <span class=\"n\">x2</span><span class=\"o\">)),</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">x2</span> <span class=\"n\">x1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Eq_symm''''</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">Eq</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)),</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">Eq.rec</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">Eq_helper</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>also needs that by exact for some reason.</p>\n<p>btw is there a way to have lean tell me what motive it inferred?</p>",
        "id": 271853388,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1644857014
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Eq_symm''</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">Eq</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">Eq.refl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.implicit</span> <span class=\"n\">true</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">Eq_symm''</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">23:1: def Eq_symm'' : Π (A : Sort u) (a b : A), @Eq A a b → @Eq A b a :=</span>\n<span class=\"cm\">λ (A : Sort u) (a b : A), @Eq.rec A (λ (a b : A) (n : @Eq A a b), @Eq A b a) (@Eq.refl A) a b</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 271854269,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644857388
    },
    {
        "content": "<p>oh, that's awesome, thanks!</p>",
        "id": 271854363,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1644857417
    },
    {
        "content": "<p>here's a random question: what are some interesting Props <em>besides</em> equality?<br>\nbackground: i'm interested in proofs from a program correctness perspective, not so much from a \"pure math\" perspective.<br>\ni can't really think of any important relations besides equality, less/greater than; perhaps prime and equal-modulo. but all these seem to be defined in terms of equality.<br>\nif there were no other interesting prop, a uniqueness of identity proofs axiom could be an alternative to <code>Prop</code> for me. (though I'd have to learn about possible paradoxes, and whether i care about them)</p>",
        "id": 271870595,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1644864638
    },
    {
        "content": "<p>now that i think about it, quantification could be a problem.<br>\nif equality proofs are treated equally, quantification over equality should probably be treated in the same way.<br>\ni guess, now i've ended up at Prop?</p>",
        "id": 271871007,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1644864841
    },
    {
        "content": "<p>Any mathematical proposition is a <code>Prop</code> in Lean, \"does this turing machine halt\", \"is this thing a member of a set\" etc. What you are describing is the special case where a relation is modeled using a function that takes two things and maps them onto <code>Prop</code></p>",
        "id": 271872389,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1644865358
    },
    {
        "content": "<p>ok, i've found an example that answers my original question (title of this thread):<br>\n\"\"\"<br>\nFor example, in a dependent type theory, one may use dependent<br>\ntypes of pairs to represent CNs modified by intersective adjectives [35]: for instance,<br>\na handsome man is a pair of a man and a proof that the man is handsome. Then,<br>\nfor such representations, one can ask: what is the identity criterion for handsome<br>\nman? An obvious answer should be that it is the same as that for man: two handsome<br>\nmen are the same if, and only if, they are the same man. But this is not what the<br>\nformal interpretation gives us since it also requires that the proofs of the man being<br>\nhandsome be the same. Obviously, this would not be a correct identity criterion for<br>\nthe modified CN handsome man.<br>\n\"\"\" from Proof Irrelevance in Type-Theoretical Semantics∗ by Zhaohui Luo<br>\nas I understand it, it comes down to the \"basic\" type theory not accurately modelling the <em>expected semantics</em> of propositions. namely, that only their truth value matters (with respect to identity), not their proof.</p>",
        "id": 271876954,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1644867206
    },
    {
        "content": "<p>In case I was being too opaque when I mentioned <code>subtype (∈ s)</code> earlier (explaining the mechanics and not the point), this is a dependent pair of types. Terms consist of a pair of <code>x : α</code> and a proof <code>h : x ∈ s</code>. With the example you brought up, <code>α</code> is \"man\" and <code>s</code> is the set (i.e. a predicate on <code>α</code>) of handsome men.  With proof irrelevance, <code>⟨x, h⟩ = ⟨y, h'⟩</code> if and only if <code>x = y</code>.</p>",
        "id": 271878232,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644867712
    },
    {
        "content": "<p>oh, ok, that makes a lot of sense now, thanks!<br>\ni didn't know that <code>subtype</code> terms were such pairs.</p>",
        "id": 271880190,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1644868666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456923\">Leonard Wiechmann</span> <a href=\"#narrow/stream/113488-general/topic/why.20proof.20irrelevance.3F/near/271870595\">said</a>:</p>\n<blockquote>\n<p>here's a random question: what are some interesting Props <em>besides</em> equality?<br>\nbackground: i'm interested in proofs from a program correctness perspective, not so much from a \"pure math\" perspective.</p>\n</blockquote>\n<p>For program verification, Hoare triples and operational/denotational semantics come to mind.</p>",
        "id": 271883489,
        "sender_full_name": "Chris B",
        "timestamp": 1644870370
    },
    {
        "content": "<p>Any inductively defined predicate (e.g. well-typedness) can be useful to use as an inductive data type for further definitions, I think, and that requires these proofs to be relevant. (This is similar to what Chris may allude to.)</p>",
        "id": 271886182,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1644871756
    }
]
[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> </p>\n<blockquote>\n<p>I made a repository of examples of type class failures in Lean 3. Most of them depend on using some old commit of mathlib. The respository is <a href=\"https://github.com/ChrisHughes24/type_class\" target=\"_blank\" title=\"https://github.com/ChrisHughes24/type_class\">here</a></p>\n</blockquote>\n<p>Thanks, this is a good first step. If we want to get serious about analyzing and fixing these issues in Lean 4 (I hope nobody expects a solution for Lean 3), it would help tremendously to reduce them to minimized examples in stand-alone files (we want to port mathlib to Lean 4 <em>after</em> fixing these issues after all). If they are already valid Lean 4, even better. We may even want to port them to other systems to analyze their behavior.</p>",
        "id": 175192998,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1567964788
    },
    {
        "content": "<p>It's not hard to cook up artificial examples, but I thought you wanted real examples</p>",
        "id": 175193324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1567965453
    },
    {
        "content": "<p>In short it checks the same typeclass problem many times. This causes issues with looping instances, and exponential worst case behavior on dags</p>",
        "id": 175193380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1567965533
    },
    {
        "content": "<p>We'd like to have realistic examples, but we'll still need to extract them if we want to test them in Lean 4</p>",
        "id": 175199193,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1567976130
    },
    {
        "content": "<p>Here is an unrealistic example which shows that diamonds cause an exponential blow-up in the type class inference search:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- Lean 3 code</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n<span class=\"n\">class</span> <span class=\"n\">bottom</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n<span class=\"n\">class</span> <span class=\"n\">left</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">bottom</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n<span class=\"n\">class</span> <span class=\"n\">right</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">bottom</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n<span class=\"n\">class</span> <span class=\"n\">top</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">left</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">right</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n\n\n<span class=\"kn\">instance</span> <span class=\"n\">unrealistic_loop</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">bottom</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">top</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">.._</span><span class=\"n\">inst_1</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">class_instances</span> <span class=\"n\">true</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">top</span> <span class=\"n\">unit</span> <span class=\"mi\">10</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- fails, but slowly</span>\n</pre></div>\n\n\n<p>Even though this example is unrealistic, diamonds occur all over the algebraic hierarchy, and I don't think there is a way avoiding diamonds from the algebraic hierarchy. And this is not a large amount of diamonds, there is already a significant slowdown with 11 diamonds on top of each other. I think mathlib has more diamonds (more parallel instead of serial).</p>",
        "id": 175205903,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1567988582
    },
    {
        "content": "<p>In the stream <a href=\"#narrow/stream/113488-general/topic/more.20type.20class.20inference.20issues\" title=\"#narrow/stream/113488-general/topic/more.20type.20class.20inference.20issues\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/more.20type.20class.20inference.20issues</a> I suggested:</p>\n<blockquote>\n<p>There should really be a different algorithm for these \"forgetful instances\". Make a graph of all instances that change the class but not the type (like <code>add_comm_group \\a -&gt; add_group \\a</code>) and when you have searched through all structural instances (or all instances with priority &gt;= default priority), then use a graph reachability algorithm to quickly search for a path to any instance in the local context.</p>\n</blockquote>",
        "id": 175205975,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1567988683
    },
    {
        "content": "<p>I don't know if that is the best way to deal with diamonds, but it should avoid the exponential blowup.</p>",
        "id": 175206555,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1567989707
    },
    {
        "content": "<p>Thanks Floris. So are repeated (metavariable-free) instance problems the only big issue? Are <code>out_param</code>s more or less well behaved or were there fundamental issues as well?</p>",
        "id": 175222358,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1568016671
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> do you think the category theory morphism problems deserve a mention here?</p>",
        "id": 175225959,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1568020840
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110111\">@Keeley Hoek</span> which did you have in mind?</p>",
        "id": 175226803,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1568021768
    },
    {
        "content": "<p>I meant the whole business with having to specify the morphism universe everywhere because the resolver can't be coerced into being more aggressive.</p>",
        "id": 175226897,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1568021870
    },
    {
        "content": "<p>Oh, I see. Yes, it would be lovely if instance resolution would specialise universes in preference to failing.</p>",
        "id": 175226982,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1568021957
    },
    {
        "content": "<p>I'm not so familiar with <code>out_param</code>, but maybe an annotation like that saying to aggressively unify could be a fix.</p>",
        "id": 175227201,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1568022204
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> I don't feel confident to judge whether this is the only issue. My gut feeling is that there are more issues, but it's not always easy to say which problem is causing a type class search to time out.<br>\nI have not worked with <code>out_param</code>s myself, so I cannot judge judge them.</p>",
        "id": 175307681,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1568093116
    },
    {
        "content": "<p>What's your timeline for collecting examples here? I'm limiting my Zulip time right now because I have too much else going on. But there are some bad instance searches I half-remember, and probably have saved on my office computer, I can try to write up once I get back there.</p>",
        "id": 175308232,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1568093998
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> There are always other things to work on for us, so I'd say take your time</p>",
        "id": 175314585,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1568102567
    },
    {
        "content": "<p><code>out_param</code> is finicky to use correctly, but AFAIK it doesn't cause any performance problems other than the preexisting ones</p>",
        "id": 175315402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1568103351
    },
    {
        "content": "<p>I would say as long as you can make it not asymptotically exponential everything else will be minor</p>",
        "id": 175315475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1568103410
    },
    {
        "content": "<p>TBH it's surprisingly fast considering how much work it is currently doing</p>",
        "id": 175315579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1568103516
    },
    {
        "content": "<p>I wonder if just looking through the 53 current instances of <code>set_option class.instance_max_depth ...</code> in mathlib would provide some interesting examples.</p>",
        "id": 175316835,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1568104780
    },
    {
        "content": "<p>Orthogonal to instance failures, but the following has been painful for me in manifolds.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">my_source</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">source</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">my_source</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span>\n</pre></div>\n\n\n<p>is not understood by Lean, as it is not able to infer the type of <code>e</code> in the statement of <code>foo</code> (even though <code>e ∈ A</code> should tell everything). So I have to give explicitly the type of <code>e</code>, which is not bad here but can be bad in more complicated instances. I know unification is complicated, but still...</p>",
        "id": 175325702,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1568114254
    },
    {
        "content": "<p>I think the issue is that you shouldn't use projection with class.</p>",
        "id": 175325955,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1568114501
    },
    {
        "content": "<p>Sorry, I shouldn't have used <code>class</code>. Same outcome with <code>structure</code> instead.</p>",
        "id": 175326366,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1568114843
    },
    {
        "content": "<p>Here is a pretty egregious failure:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">class_instances</span> <span class=\"n\">true</span>\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">t</span>\n</pre></div>\n\n\n<p>Obviously the search <code>has_scalar ℚ T</code> cannot succeed, but this is not obvious to Lean</p>",
        "id": 175477582,
        "sender_full_name": "Reid Barton",
        "timestamp": 1568236940
    },
    {
        "content": "<p>I know I keep going on about GHC, but in GHC this kind of thing will fail in constant* time<br>\n(* okay, probably logarithmic in something)</p>",
        "id": 175477662,
        "sender_full_name": "Reid Barton",
        "timestamp": 1568237025
    },
    {
        "content": "<p>regardless of the number of classes or instances in the system or the depth of the class hierarchy</p>",
        "id": 175477724,
        "sender_full_name": "Reid Barton",
        "timestamp": 1568237049
    },
    {
        "content": "<p>I just stumbled on a behavior I don't understand. Involving out_params, structures and typeclasses, so something a little bit exotic and probably the behavior will be completely different in Lean 4, but still let me record it here. Everything is fine with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">local_homeomorph</span><span class=\"bp\">.</span><span class=\"n\">is_mdifferentiable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M</span> <span class=\"n\">M&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mdifferentiable_on</span> <span class=\"err\">𝕜</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">mdifferentiable_on</span> <span class=\"err\">𝕜</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">inv_fun</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">target</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">mdifferentiable_atlas</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">atlas</span> <span class=\"n\">M</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">is_mdifferentiable</span> <span class=\"err\">𝕜</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">mdifferentiable_on_atlas_to_fun</span> <span class=\"err\">𝕜</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">mdifferentiable_on_atlas_inv_fun</span> <span class=\"err\">𝕜</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>But if I switch the definition to a structure, with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">local_homeomorph</span><span class=\"bp\">.</span><span class=\"n\">is_mdifferentiable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M</span> <span class=\"n\">M&#39;</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">diff_to_fun</span> <span class=\"o\">:</span> <span class=\"n\">mdifferentiable_on</span> <span class=\"err\">𝕜</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">diff_inv_fun</span> <span class=\"o\">:</span> <span class=\"n\">mdifferentiable_on</span> <span class=\"err\">𝕜</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">inv_fun</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">target</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>then the lemma is not accepted any more, failing with 4 messages</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">don&#39;t</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">placeholder</span>\n<span class=\"kn\">context</span><span class=\"o\">:</span>\n<span class=\"err\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">nondiscrete_normed_field</span> <span class=\"err\">𝕜</span><span class=\"o\">,</span>\n<span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">normed_space</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n<span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_4</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n<span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n<span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_5</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_6</span> <span class=\"o\">:</span> <span class=\"n\">manifold</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_7</span> <span class=\"o\">:</span> <span class=\"n\">smooth_manifold_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">atlas</span> <span class=\"n\">M</span> <span class=\"n\">H</span>\n<span class=\"err\">⊢</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span>\n</pre></div>\n\n\n<p>I have several typeclass variables in scope, and I guess the main missing piece of information is the only exotic typeclass definition with outparams, i.e.,</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\"> Specialization to the case of smooth manifolds with corners, over a field 𝕜 and with infinite</span>\n<span class=\"cm\">smoothness to simplify.</span>\n<span class=\"cm\">The set E is a vector space, and H is a model with corners based on E.</span>\n<span class=\"cm\">When 𝕜 is fixed, the model space with corners (E, H) should always be the same for a</span>\n<span class=\"cm\">given manifold M. Therefore, we register it as an out_param: it will not be necessary to write</span>\n<span class=\"cm\">it out explicitely when talking about smooth manifolds. This is the main point of this definition. -/</span>\n<span class=\"n\">class</span> <span class=\"n\">smooth_manifold_with_corners</span> <span class=\"o\">(</span><span class=\"err\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">nondiscrete_normed_field</span> <span class=\"err\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">normed_space</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">manifold</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"kn\">extends</span>\n  <span class=\"n\">has_groupoid</span> <span class=\"n\">H</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">times_cont_diff_groupoid</span> <span class=\"err\">⊤</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</pre></div>",
        "id": 175529388,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1568295310
    },
    {
        "content": "<blockquote>\n<p>I know I keep going on about GHC, but in GHC this kind of thing will fail in constant* time<br>\n(* okay, probably logarithmic in something)</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Is this still true with overlapping/incoherent instances?</p>",
        "id": 175620443,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1568379335
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Why are your <code>out_param</code>s instance implicit? That looks very suspicious to me.</p>",
        "id": 175620690,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1568379501
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> Why are your <code>out_param</code>s instance implicit? That looks very suspicious to me.</p>\n</blockquote>\n<p>Probably because I am not using them properly. I did not find any doc, and hardly any example, so I tried some things until it worked. With my current setup, it works very well: with the definition</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"err\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">nondiscrete_normed_field</span> <span class=\"err\">𝕜</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">manifold</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">E&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"err\">𝕜</span> <span class=\"n\">E&#39;</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">H&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">I&#39;</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E&#39;</span> <span class=\"n\">H&#39;</span><span class=\"o\">]</span>\n<span class=\"o\">{</span><span class=\"n\">M&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">manifold</span> <span class=\"n\">H&#39;</span> <span class=\"n\">M&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"err\">𝕜</span> <span class=\"n\">E&#39;</span> <span class=\"n\">H&#39;</span> <span class=\"n\">M&#39;</span><span class=\"o\">]</span>\n<span class=\"n\">include</span> <span class=\"n\">I</span> <span class=\"n\">I&#39;</span>\n\n<span class=\"n\">def</span> <span class=\"n\">mdifferentiable_at</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">continuous_at</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span>\n<span class=\"n\">differentiable_within_at</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">written_in_ext_chart_at</span> <span class=\"err\">𝕜</span> <span class=\"n\">x</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span><span class=\"o\">)</span>\n  <span class=\"o\">((</span><span class=\"n\">ext_chart_at</span> <span class=\"err\">𝕜</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I can write <code>mdifferentiable_at 𝕜 f x</code> (where <code>𝕜</code> is a normed field and <code>f : M → M'</code> and <code>x : M</code>), and Lean will infer by itself that it needs a manifold with corners structure on <code>M</code> and <code>M'</code>, and it will find all by itself about <code>E</code> and <code>H</code> and <code>I</code> and <code>E'</code> and <code>H'</code> and <code>I'</code>. Which is what I want to do differential geometry: when I want to talk about the derivative of a function, I just want to specify the field, and I am happy to let Lean fill in the gaps by itself.</p>\n<p>As far as I understand, this is the goal of <code>out_param</code>s, and with my current setup it works well. But maybe there is a better syntax, or outparams are not designed for this. I would be super happy to hear your thoughts about this!  And I guess it could be useful to other people on this forum (I remember <span class=\"user-mention\" data-user-id=\"210574\">@Patrick Massot</span> asking naive questions on outparams too).</p>",
        "id": 175642412,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1568393459
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>I know I keep going on about GHC, but in GHC this kind of thing will fail in constant* time<br>\n(* okay, probably logarithmic in something)</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> Is this still true with overlapping/incoherent instances?</p>\n</blockquote>\n<p>Well, what is true in general is that instance search in GHC never backtracks</p>",
        "id": 175643554,
        "sender_full_name": "Reid Barton",
        "timestamp": 1568394162
    },
    {
        "content": "<blockquote>\n<p>Well, what is true in general is that instance search in GHC never backtracks</p>\n</blockquote>\n<p>Sure. But that is not compatible with Lean's current model of instances from child to parent classes.</p>",
        "id": 175703966,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1568471779
    },
    {
        "content": "<blockquote>\n<p>As far as I understand, this is the goal of <code>out_param</code>s, and with my current setup it works well.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Yes, <code>out_param</code>s are made for situations like this, at least for parameters like <code>E</code>. Does it still work if you remove the <code>out_param</code>s from the instance parameters like <code>normed_group E</code>? Is there any difference?</p>",
        "id": 175704121,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1568472028
    },
    {
        "content": "<p>If I remove the <code>out_param</code> from the instance parameter, replacing <code>[out_param $ normed_group E]</code> with <code>[normed_group E]</code>, then it doesn't work any more: I get errors <code>don't know how to synthesize placeholder</code> whenever I mention a <code>smooth_manifold_with_corners</code>.</p>",
        "id": 175707773,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1568477503
    },
    {
        "content": "<p>Why does Lean fail to synthesize a typeclass after I name it in a <code>variables</code> block?  That is, given the prelude</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">monad</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"n\">universes</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"n\">v₃</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span> <span class=\"n\">u₃</span> <span class=\"c1\">-- declare the `v`&#39;s first; see `category_theory.category` for an explanation</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"err\">𝒞</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"n\">include</span> <span class=\"err\">𝒞</span>\n</pre></div>\n\n\n<p>the following fails</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"err\">𝕋</span> <span class=\"o\">:</span> <span class=\"n\">monad</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">T</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">forget_right</span> <span class=\"o\">:</span> <span class=\"n\">is_right_adjoint</span> <span class=\"o\">(</span><span class=\"n\">monad</span><span class=\"bp\">.</span><span class=\"n\">forget</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"n\">monad</span><span class=\"bp\">.</span><span class=\"n\">free</span> <span class=\"n\">T</span>\n<span class=\"o\">,</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">monad</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">T</span> <span class=\"o\">}</span>\n<span class=\"c\">/-</span><span class=\"cm\"> algebras.lean:12:42: error</span>\n<span class=\"cm\">failed to synthesize type class instance for</span>\n<span class=\"cm\">C : Type u₁,</span>\n<span class=\"cm\">𝒞 : category C,</span>\n<span class=\"cm\">T : C ⥤ C</span>\n<span class=\"cm\">⊢ monad T -/</span>\n</pre></div>\n\n\n<p>while this works</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"c1\">--[monad.{v₁} T]</span>\n<span class=\"kn\">instance</span> <span class=\"n\">forget_right</span> <span class=\"o\">[</span><span class=\"err\">𝕋</span> <span class=\"o\">:</span> <span class=\"n\">monad</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_right_adjoint</span> <span class=\"o\">(</span><span class=\"n\">monad</span><span class=\"bp\">.</span><span class=\"n\">forget</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"n\">monad</span><span class=\"bp\">.</span><span class=\"n\">free</span> <span class=\"n\">T</span>\n<span class=\"o\">,</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">monad</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">T</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>as does this</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monad</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"kn\">instance</span> <span class=\"n\">forget_right</span> <span class=\"o\">:</span> <span class=\"n\">is_right_adjoint</span> <span class=\"o\">(</span><span class=\"n\">monad</span><span class=\"bp\">.</span><span class=\"n\">forget</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"n\">monad</span><span class=\"bp\">.</span><span class=\"n\">free</span> <span class=\"n\">T</span>\n<span class=\"o\">,</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">monad</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">T</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>What does adding the name do that breaks inference?</p>",
        "id": 191756677,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1585147926
    },
    {
        "content": "<p>The category theory stuff is a distraction! The auto-inclusion of <code>[]</code> variables only occurs for ones that are not named, I think.</p>",
        "id": 191758294,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585148518
    },
    {
        "content": "<p>Do you know why that is? Is it to make sure I don't refer to the particular instance?</p>",
        "id": 191759167,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1585148880
    },
    {
        "content": "<p>It is just a design choice I think. I mean, the default is to not include variables.</p>",
        "id": 191765882,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585150994
    },
    {
        "content": "<p>For unnamed <code>[]</code> variables the rule is just always include all those that mention an included variable. It doesn't include them only if they are actually needed or anything like that.</p>",
        "id": 191766054,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585151048
    },
    {
        "content": "<p>Ah right, so that's why we need <code>include 𝒞</code>. Thanks!</p>",
        "id": 191767714,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1585151601
    },
    {
        "content": "<p>The business with 𝒞 is a specific Lean bug related to the fact that <code>category C</code> has a universe variable which doesn't appear in the type of <code>C</code>. Otherwise we wouldn't name 𝒞 either.</p>",
        "id": 191770363,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585152445
    },
    {
        "content": "<p>Can this bug be fixed in community lean?</p>",
        "id": 191771066,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585152690
    },
    {
        "content": "<p>I think it should be easy.</p>",
        "id": 191771130,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585152722
    },
    {
        "content": "<p>Is it already an issue?</p>",
        "id": 191771262,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585152767
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/issues/146\" title=\"https://github.com/leanprover-community/lean/issues/146\">lean#146</a></p>",
        "id": 191771286,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1585152774
    },
    {
        "content": "<p>Oh nice, will hopefully be fixed in 3.8</p>",
        "id": 191771466,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1585152844
    },
    {
        "content": "<p>when I looked at this originally (long before the community fork) it seemed that the elaborator basically already had the machinery to do this, it just wasn't being used in this particular case</p>",
        "id": 191771612,
        "sender_full_name": "Reid Barton",
        "timestamp": 1585152900
    }
]
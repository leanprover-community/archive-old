[
    {
        "content": "<p>Dear All,</p>\n<p>I am about to start preparing a PR to push the <code>ordered</code> refactor across types with <code>add</code> <em>and</em> <code>mul</code>.  This essentially involves asserting that multiplication by <em>strictly positive</em> elements be monotone (on top of what is already there for monotonicity of addition).  While this is relatively easy to implement, there are two possible approaches that I have played with.  I think that, in the long run, maybe we should implement both, but, for the moment, I would start with one.  Below are the two approaches that I have in mind: let me know if you have a preference for either one of them or if you see problems/benefits with one or the other!</p>\n<p>Thanks!</p>\n<p>Approach 1: <em>monotone multiplication</em>.  Simply introduce new typeclasses asserting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>with various layers according to whether the inequality is strict or not, or whether multiplication is on the left or on the right.  This is relatively straightforward.  The main drawback is that it uses <em>homogeneous</em> multiplication.  Thus, it may cause problems when trying to multiply a <code>(unit nnreal)</code> by an <code>ennreal</code>.</p>\n<p>Approach 2: <em>monotone action</em>.  Introduce a more general typeclass allowing an action of a Type <code>M</code> on a second Type <code>N</code> and asserting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n₁</span> <span class=\"n\">n₂</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">n₁</span> <span class=\"bp\">≤</span> <span class=\"n\">n₂</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">n₁</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">•</span> <span class=\"n\">n₂</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This approach of course allows for more general statements, and would work better developing some API for \"positive subtypes\" of types with an order.  In the first instance, this can be quite short, only introducing a \"Type of positive elements\" whenever a type <code>has_zero</code> and <code>has_lt</code>.</p>\n<p>My preference is for Approach 2.  This works well in abstract Types, but also in concrete cases where you might want to multiply a positive rational number by an <code>ennreal</code> and know that multiplication is monotone.</p>\n<p>What are people's opinions on this?  Should I create a poll?</p>",
        "id": 241912529,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623156242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/ordered.20with.20pos/near/241912529\">said</a>:</p>\n<blockquote>\n<p>Thus, it may cause problems when trying to multiply a <code>(unit nnreal)</code> by an <code>ennreal</code>.</p>\n</blockquote>\n<p>Can you maybe give another example?  You can multiply a <code>units nnreal</code> and an <code>ennreal</code> just fine (the unit will just coerce to an ennreal).</p>",
        "id": 241913518,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1623156676
    },
    {
        "content": "<p>At the moment, I am actually failing to identify an example where there may not be a coercion saving the day.  Maybe there is no need for the extra generality of the \"proper action\" and all can be resolved using coercions+multiplication?</p>\n<p>I can only think of the following \"dynamical-systems-like\" example.<br>\nSuppose that you have a Type <code>X</code> with a self-map <code>f : X → X</code>.  This determines an action of <code>ℕ</code> on <code>X</code> by iterating <code>f</code>.  You can then act on <code>set X</code> elementwise via <code>f^[n] ''</code>.  On <code>set X</code> there is an addition (taking unions) and a <code>≤</code> (taking subsets) and the <code>ℕ</code>-action is monotone.  At this level, there is no coercion from <code>ℕ</code> to <code>set X</code> that would work, I think.</p>\n<p>Does this count?  The answer could well be: \"this is too contrived, so we do not need the greater generality\"!</p>",
        "id": 241917717,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623158531
    },
    {
        "content": "<p>I guess that the main take-away from the example is that you do not need a multiplication on <code>N</code> to have a monotonicity of <em>something</em> acting on it.  I feel like I should know a good example of this, but I am not managing to bring it to my conscience!</p>",
        "id": 241918596,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623158868
    },
    {
        "content": "<p>Your approach 2 looks like a weaker version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/smul_lt_smul_of_pos\">docs#smul_lt_smul_of_pos</a></p>",
        "id": 241932590,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623164127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/113488-general/topic/ordered.20with.20pos/near/241913518\">said</a>:</p>\n<blockquote>\n<p>You can multiply a <code>units nnreal</code> and an <code>ennreal</code> just fine (the unit will just coerce to an ennreal).</p>\n</blockquote>\n<p>It's not really the point of this thread, but I think there should be a <code>algebra nnreal ennreal</code> instance somewhere, from which we'd get <code>has_scalar (units nnreal) ennreal</code> automatically.</p>",
        "id": 241932873,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623164234
    },
    {
        "content": "<p><code>algebra R A</code> assumes that <code>A</code> is a semiring, right? But <code>ennreal</code> isn't.</p>",
        "id": 241933087,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1623164298
    },
    {
        "content": "<p>Eric, thank you for digging out something that would likely be an application of Approach 2, (should Approach 2 become part of mathlib)!</p>\n<p>While it is possible that most applications of the <code>ordered</code> refactor could be solved by instances, I still think that it might be worthwhile to pursue both Approach 1 <em>and</em> Approach 2, although not in the same PR.  I am now going to propose a poll, to see with which one to begin!</p>",
        "id": 241935854,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623165254
    },
    {
        "content": "<p>/poll mul_pos_monotone<br>\nApproach 1: monotone multiplication <code>∀ (a : N) {b c : N}, (0 &lt; a) → (b ≤ c) → (a * b ≤ a * c)</code><br>\nApproach 2: monotone action <code>∀ (m : M) {n₁ n₂ : N}, (n₁ ≤ n₂) → (m • n₁ ≤ m • n₂)</code></p>",
        "id": 241936154,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623165373
    },
    {
        "content": "<p>Oh, I totally missed that. Then I guess I mean there should be a <code>mul_action nnreal ennreal</code>?</p>",
        "id": 241936360,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623165466
    },
    {
        "content": "<p>Damiano, is the idea behind approach 2 to use a subtype <code>M</code> for the <code>0 &lt; a</code> condition?</p>",
        "id": 241936630,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623165564
    },
    {
        "content": "<p>Eric, yes, I would use the subtype that you mention to apply it, but only if approach 1 is not also developed.</p>",
        "id": 241937035,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623165730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/ordered.20with.20pos/near/241933087\">said</a>:</p>\n<blockquote>\n<p><code>algebra R A</code> assumes that <code>A</code> is a semiring, right? But <code>ennreal</code> isn't.</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/ennreal.canonically_ordered_comm_semiring\">docs#ennreal.canonically_ordered_comm_semiring</a>  suggests to me that ennreal is a semiring</p>",
        "id": 241937098,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623165764
    },
    {
        "content": "<p>(I do not view the two approaches as opposing: sometimes the \"unbundled\" approach 1 is better, other times the \"bundled\" approach 2 is better.  it is not difficult to go from one to the other, though having direct paths both ways may be convenient)</p>",
        "id": 241937169,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623165799
    },
    {
        "content": "<p>In approach 2 you are adding the assumption <code>0 &lt; m</code> right?</p>",
        "id": 241937447,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1623165906
    },
    {
        "content": "<p>In approach 2 you do not need to add the assumption <code>0 &lt; m</code>, since you would only get an instance of that type if multiplication is monotone.</p>",
        "id": 241937544,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623165943
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> you're right. my bad</p>",
        "id": 241937575,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1623165950
    },
    {
        "content": "<p>In other words, if multiplication of a type on another is monotone, <em>likely</em> the action of the first type is by positive elements.</p>",
        "id": 241937689,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623165977
    },
    {
        "content": "<p>But you need not have even an order relation on the acting type in order to get monotonicity of the action: the inequalities are all on the target type <code>N</code>.</p>",
        "id": 241937783,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623166019
    },
    {
        "content": "<p>Ah, I see.</p>",
        "id": 241938063,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1623166128
    },
    {
        "content": "<p>Thus, Approach 2 is outsourcing to the typeclass system to make sure that you have a proof that the elements of the Type <code>M</code> actually do have the correct monotonicity.</p>",
        "id": 241938074,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623166132
    },
    {
        "content": "<p>One advantage of approach 2 is that it generalizes both approach 1 and the current <code>covariant_class</code>, right?</p>",
        "id": 241938078,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1623166133
    },
    {
        "content": "<p>Yes, indeed, <code>covariant_class</code> would be applying approach 2 with twice the same type (i.e. <code>M = N</code>).<br>\nand the \"positive multiplication\" would be using approach 2 with the \"type of positive elements\" acting on the actual type.</p>",
        "id": 241938210,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623166185
    },
    {
        "content": "<p>Mathematically, there is little difference.  In Lean, instead of multiplying by the elements of a Type <code>N</code> that happen to be positive, you allow yourself to act on <code>N</code> with the elements of another type <code>M</code>.</p>\n<p>The use case is of course the one where <code>M</code> is the subtype of the positive elements of <code>N</code>, though this would not be required by the definitions.</p>",
        "id": 241939063,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623166473
    },
    {
        "content": "<p>I think approach 2 is worth trying.</p>",
        "id": 241939376,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1623166591
    },
    {
        "content": "<p>How about a third appoach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_monotone</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">out</span> <span class=\"o\">:</span> <span class=\"n\">monotone</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which you can then write approach 2 as using <code>[∀ m : M, is_monotone ((•) m : N → N)]</code></p>",
        "id": 241940191,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623166927
    },
    {
        "content": "<p>Eric, I like your suggestion, although I would also want to allow the freedom of having <code>strict_mono</code>.  In other words, I was thinking of leaving the (order) relation as an input of the class, like for <code>covariant</code>.</p>",
        "id": 241940728,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623167154
    },
    {
        "content": "<p>So, I could sometimes assume that multiplication is monotone and sometimes strictly monotone.</p>",
        "id": 241940812,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623167182
    },
    {
        "content": "<p>Wait, <code>covariant_class</code> can be used to do approach 2, right? <code>covariant_class {x : M // 0 &lt; x} M (•) (≤)</code></p>",
        "id": 241944470,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1623168651
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/ordered.20with.20pos/near/241940728\">said</a>:</p>\n<blockquote>\n<p>Eric, I like your suggestion, although I would also want to allow the freedom of having <code>strict_mono</code>.  In other words, I was thinking of leaving the (order) relation as an input of the class, like for <code>covariant</code>.</p>\n</blockquote>\n<p>my experiments in <a href=\"https://github.com/leanprover-community/mathlib/issues/7834\">#7834</a> suggest that typeclasses with lots of (dependent) inputs as you're suggesting might be a bad idea - but it's also possible my problem is something else</p>",
        "id": 241945811,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623169177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/ordered.20with.20pos/near/241937575\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> you're right. my bad</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7846\">#7846</a></p>",
        "id": 241948014,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623170113
    },
    {
        "content": "<p>Eric, some similar comments on times had been raised before the introduction of <code>covariant_class though some timings performed by Jannis Limperg suggested that the </code>covariant<code> approach was (very marginally) faster than the current one with </code>ordered_...`.  In any case, I will try to see how it works and then we can decide what is best.  This will likely be tomorrow, though!</p>",
        "id": 241948742,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623170399
    },
    {
        "content": "<p>Floris, I think that I had tried to recycle <code>covariant_class</code>, but had failed.  I will try again and see how it works!</p>",
        "id": 241948855,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623170426
    },
    {
        "content": "<p>In any case, thank you all for the support!</p>",
        "id": 241948869,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623170432
    },
    {
        "content": "<p>My concern is not so much about speed, but about whether typeclass search will get stuck on the resulting dependent types.</p>",
        "id": 241952021,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623171645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/ordered.20with.20pos/near/241932873\">said</a>:</p>\n<blockquote>\n<p>I think there should be a <code>algebra nnreal ennreal</code> instance somewhere, from which we'd get <code>has_scalar (units nnreal) ennreal</code> automatically.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7846\">#7846</a> now provides <code>distrib_mul_action (units ℝ≥0) ℝ≥0∞</code></p>",
        "id": 241952199,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623171716
    },
    {
        "content": "<p>Dear All,</p>\n<p>here is a follow up, based on the discussion that we were having yesterday.  Below is a beginning of code to convert lemmas about <code>ordered_semiring</code>s into lemmas about <code>covariant_class M N (some_action) (&lt;)</code>.</p>\n<p>[Floris, this seems to work: I think that I had something more general in mind that would require <em>three</em> types, instead of two.]</p>\n<p>Main question.  Can I make the final proof of <code>mul_lt_mul_of_pos_left</code>\"simpler\"?</p>\n<p>Side question.  How would you improve the code?</p>\n<p>Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.ordered_ring</span>\n\n<span class=\"sd\">/--  The positive elements of a type. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">posi</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">posi</span>\n\n<span class=\"sd\">/--  An element of `posi α` can be coerced into `α`. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">posi</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a.1</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/--  A positive element of `α` can be lifted into `posi α`. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">can_lift</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">posi</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span>  <span class=\"o\">:=</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n  <span class=\"n\">cond</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">prf</span>  <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">Exists.intro</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/--  An ordered semiring automatically inherits a covariant_class for strictly monotone</span>\n<span class=\"sd\">multiplication by positive elements. -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">ordered_semiring.to_covariant_class_posi_left</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ordered_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">covariant_class</span> <span class=\"o\">(</span><span class=\"n\">posi</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">covc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">bc</span><span class=\"o\">,</span> <span class=\"n\">mul_lt_mul_of_pos_left</span> <span class=\"n\">bc</span> <span class=\"n\">a.2</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">  The lemma in general. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_lt_mul_of_pos</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">covariant_class</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)]</span>\n  <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">μ</span> <span class=\"n\">m</span> <span class=\"n\">o</span> <span class=\"o\">:=</span>\n<span class=\"n\">covariant_class.covc</span> <span class=\"n\">_</span> <span class=\"n\">h₁</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">  If possible, I would like this proof to be simply an application of the general lemma. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_lt_mul_of_pos_left</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ordered_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span>  <span class=\"n\">lift</span> <span class=\"n\">c</span> <span class=\"n\">to</span> <span class=\"o\">(</span><span class=\"n\">posi</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">using</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n      <span class=\"n\">convert</span> <span class=\"n\">posi.mul_lt_mul_of_pos</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">posi</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">h₁</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">posi</span>\n</code></pre></div>",
        "id": 242064608,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623245366
    },
    {
        "content": "<p>(also, I do not mind if a few initial lemmas have some awkwardness, but I would like to simply be able to apply most of the general lemmas in the <code>ordered_semiring</code> context, without having to juggle around type-theoretic assumptions all the time.)</p>",
        "id": 242066677,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623246146
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">can_lift</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">posi</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span>  <span class=\"o\">:=</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n  <span class=\"n\">cond</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">prf</span>  <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 242079881,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623250980
    },
    {
        "content": "<p>Thanks Kevin!  I edited the code above, to implement your suggestion!</p>",
        "id": 242080802,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623251328
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">elab_simple</span><span class=\"o\">]</span> <span class=\"n\">mul_lt_mul_of_pos</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_lt_mul_of_pos_left'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ordered_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">posi</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">mul_lt_mul_of_pos</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">posi</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">h₁</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_lt_mul_of_pos_left</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ordered_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">mul_lt_mul_of_pos_left'</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span>\n</code></pre></div>",
        "id": 242082517,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623252006
    },
    {
        "content": "<p>not sure if that's the answer you wanted!</p>",
        "id": 242082750,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623252116
    },
    {
        "content": "<p>I need to digest it, but it might be close to what I had in mind!</p>",
        "id": 242082835,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623252137
    },
    {
        "content": "<p>The idea would be that \"under the hood\" you prove the lemmas with the <code>'</code> in that style, but then you are allowed to use them in the familiar context with the \"explicit\" positivity assumption, rather than the one implicit in the subtype?</p>",
        "id": 242082951,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623252196
    },
    {
        "content": "<p>(I am also toying around with introducing a smul between <code>posi α</code> and <code>α</code>, but that is also a little heavy: having the explicit <code>0 &lt; c</code> or <code>0 \\le c</code> assumption in context is convenient, certainly for <em>thinking</em> about these lemmas.)</p>",
        "id": 242083320,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623252336
    },
    {
        "content": "<p>I'm not sure I know the idea, I was just trying to solve the puzzle you set :-)</p>",
        "id": 242085319,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623253022
    },
    {
        "content": "<p>Yes, that is a great start: thank you so much for your help!</p>",
        "id": 242086074,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623253304
    },
    {
        "content": "<p>If you make the <code>m</code> in <code>mul_lt_mul_of_pos</code> explicit (which it should be), then the following also works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mul_lt_mul_of_pos_left</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ordered_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">posi.mul_lt_mul_of_pos</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">posi</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 242106491,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1623261914
    },
    {
        "content": "<p>Aah, this is the correct solution. I knew you shouldn't be messing with the elaboration strategies but I've realised recently that I still don't properly understand the rules for which inputs should be explicit.</p>",
        "id": 242115089,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623265906
    },
    {
        "content": "<p>Floris, thank you so much!  I had the correct argument explicit in the definition of <code>covariant_class</code> but got lazy here: I will be more careful!</p>",
        "id": 242116767,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623266648
    },
    {
        "content": "<p>Is there a reason to (at least in Approach 1) only require multiplication by <em>positive</em> elements to be monotone? It seems better mathematically to include the case <code>0 = a</code>. For example, the product of two types satisfying the condition with <code>0 &lt; a</code> won't necessarily also satisfy it, because <code>0 &lt; (a, a')</code> doesn't imply <code>0 &lt; a</code>.</p>\n<p>Is this a historical artifact perhaps? I seem to recall the Lean core library's definition of an ordered ring being odd, involving strict inequalities where <code>&lt;=</code> would be more natural.</p>",
        "id": 242139252,
        "sender_full_name": "Reid Barton",
        "timestamp": 1623277809
    },
    {
        "content": "<p>Of course in any sensible context it shouldn't matter since when <code>0 = a</code> we have <code>0 * b = 0 = 0 * c</code>.</p>",
        "id": 242139622,
        "sender_full_name": "Reid Barton",
        "timestamp": 1623278069
    },
    {
        "content": "<p>Dear Reid,</p>\n<p>you are completely right, of course!</p>\n<p>The reason I chose specifically strict monotonicity was simply because I still want the existing lemmas in mathlib to \"just work\".  In fact, the whole <code>ordered</code> refactor started because I felt that the existing system was not designed to deal with order relations interacting with general algebraic operations, not necessarily commutative, for instance.  Thus, I plan to prove lemmas for strict and non-strict monotonicity, but I certainly want to preserve the existing lemmas.</p>",
        "id": 242158255,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623299188
    },
    {
        "content": "<p>OK, I don't know what order of refactors is best, but the eventually desired state should be one in which <code>ordered_ring</code> has only <code>mul_nonneg</code> as an axiom and not <code>mul_pos</code>.</p>",
        "id": 242222489,
        "sender_full_name": "Reid Barton",
        "timestamp": 1623337805
    },
    {
        "content": "<p><em>order</em> of refactors, huh</p>",
        "id": 242225507,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1623339143
    },
    {
        "content": "<p>Reid, at the moment, I am simply introducing typeclasses for proving statements with more flexible (typeclass) assumptions.  I am not thinking of changing the definition of <code>ordered_ring</code>.  At least, not yet!</p>",
        "id": 242228874,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623340524
    }
]
[
    {
        "content": "<p>I found the following technique useful recently and thought it might be interesting to others.<br>\nSometimes in a dependently-typed situation we have two expressions which are morally equal but we cannot directly state their equality because the types of the two sides are only propositionally equal. For my example I'll take associativity of <code>append</code> on <code>vector</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- doesn&#39;t typecheck</span>\n<span class=\"c1\">-- lemma bad_append : (x.append y).append z = x.append (y.append z) := ...</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">error: type mismatch at application</span>\n<span class=\"cm\">  (x.append y).append z = x.append (y.append z)</span>\n<span class=\"cm\">term</span>\n<span class=\"cm\">  x.append (y.append z)</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  vector α (i + (j + k))</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  vector α (i + j + k)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 210378589,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600343976
    },
    {
        "content": "<p>There are a couple of ways to deal with this, including using heterogeneous equality or inserting a cast of some kind. Here is another one.  Often in the situation where you'd like to apply this equality, the term <code>(x.append y).append z</code> appears in a context that could accept a vector of any length. Then, you can apply a lemma of the following form:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">subtype</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">vector</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">good_append</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">C</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">append</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"bp\">+</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">add_assoc</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"n\">congr&#39;</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">A</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">),</span>\n    <span class=\"n\">v</span> <span class=\"bp\">==</span> <span class=\"n\">w</span> <span class=\"bp\">↔</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">to_list</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">to_list</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">rfl</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">heq_iff_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">vector</span><span class=\"bp\">.</span><span class=\"n\">to_list_append</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">append_assoc</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 210378730,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600344058
    },
    {
        "content": "<p>For example <code>C</code> might be something like <code>is_palindrome : Π {n : ℕ}, vector α n → Prop</code>. Or in other situations, <code>C</code> might be some general property like continuity. Then you can rewrite under <code>C</code> using something like <code>refine (good_append x y z).mpr _</code>. (<code>rw</code> gets confused by the form of the lemma, and couldn't know where to rewrite.)</p>",
        "id": 210378971,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600344190
    },
    {
        "content": "<p>Could we have some sort of <code>hrw</code> (heterogenous rw) that could make using any of these tricks easier?</p>",
        "id": 210379436,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600344460
    },
    {
        "content": "<p>Is that <code>heq</code> <code>have</code> thing just missing API? I avoid heq like the plague.</p>",
        "id": 210387197,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600348495
    },
    {
        "content": "<p>I think this is equivalent to the statement that if you tuple a vector with its length you get something you can state an equality about</p>",
        "id": 210387637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600348676
    },
    {
        "content": "<p>Is there a similar trick that can be done where <code>\\iota</code> is a family of types that depends on a vector? It seems that <code>heq</code> would still cause issues in that case.</p>",
        "id": 210387730,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600348696
    },
    {
        "content": "<p>that is, <code>⟨(i + j) + k, (x.append y).append z⟩ = ⟨i + (j + k), x.append (y.append z)⟩</code> is an equality in <code>Σ n, vector A n</code></p>",
        "id": 210387872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600348764
    },
    {
        "content": "<p>whch is of course true because that's equivalent to <code>list.append_assoc</code></p>",
        "id": 210387902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600348786
    },
    {
        "content": "<p>Well... it's a combination of <code>list.append</code> and <code>add_assoc</code> right?</p>",
        "id": 210387994,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600348812
    },
    {
        "content": "<p>I mean that <code>Σ n, vector A n</code> is isomorphic to <code>list A</code>, and the two sides of that are mapped by the isomorphism to <code>(x ++ y) ++ z</code> and <code>x ++ (y ++ z)</code></p>",
        "id": 210388086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600348862
    },
    {
        "content": "<p>Oh I see.</p>",
        "id": 210388107,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600348870
    },
    {
        "content": "<p>Right, and one way to look at it is that <code>sigma.mk</code> is the universal possible choice for <code>C</code>--but when you want to apply this lemma you probably don't have a <code>sigma.mk</code> in the term waiting to be rewritten, so it's more convenient to use in the form with <code>C</code>.</p>",
        "id": 210388943,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600349231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/heq.20alternative/near/210387730\">said</a>:</p>\n<blockquote>\n<p>Is there a similar trick that can be done where <code>\\iota</code> is a family of types that depends on a vector? It seems that <code>heq</code> would still cause issues in that case.</p>\n</blockquote>\n<p>Yeah, I actually tried to do this when I wrote down the type of the lemma for the first time, and then Lean told me it wouldn't work--the purpose of <code>C</code> is to hide the problematic type index, so it can't appear in the result type of <code>C</code>.</p>",
        "id": 210389245,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600349359
    },
    {
        "content": "<p>In my case the type doesn't change (as some might guess my real <code>C</code> is the property of a subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">R^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> being definable in some structure, which is a <code>Prop</code>), so I didn't think about what one could do if it does change.</p>",
        "id": 210389992,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600349648
    },
    {
        "content": "<p>Nice trick! <br>\nI still feel like the lemma should be with <code>heq</code>, and that there should be tooling to make it easy to go from the <code>heq</code> statement to the lemma <code>good_append</code>.</p>",
        "id": 210452306,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1600377287
    },
    {
        "content": "<p>Here's yet another alternative which I haven't really tried to use for anything, but seems sensible for theoretical reasons:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.basic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">dependent equality / dependent path / \"pathover\" from HoTT/cubical type theory</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">deq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">),</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">deq</span> <span class=\"o\">(</span><span class=\"n\">eq.refl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">refl</span><span class=\"o\">]</span> <span class=\"n\">deq.refl</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">x</span> <span class=\"bp\">`</span> <span class=\"bp\">=</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"n\">x'</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">deq</span> <span class=\"n\">e</span> <span class=\"n\">x</span> <span class=\"n\">x'</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[symm]</span> <span class=\"kd\">lemma</span> <span class=\"n\">deq.symm</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">]</span> <span class=\"n\">x'</span> <span class=\"bp\">→</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span><span class=\"o\">[</span><span class=\"n\">e.symm</span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩,</span>\n  <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[trans]</span> <span class=\"kd\">lemma</span> <span class=\"n\">deq.trans</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"n\">a''</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e'</span> <span class=\"o\">:</span> <span class=\"n\">a'</span> <span class=\"bp\">=</span> <span class=\"n\">a''</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x''</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a''</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">]</span> <span class=\"n\">x'</span> <span class=\"bp\">→</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span><span class=\"o\">[</span><span class=\"n\">e'</span><span class=\"o\">]</span> <span class=\"n\">x''</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"o\">[</span><span class=\"n\">e.trans</span> <span class=\"n\">e'</span><span class=\"o\">]</span> <span class=\"n\">x''</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩,</span>\n  <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 213656799,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602948421
    },
    {
        "content": "<p>Cool. I guess the <code>rinto</code> is necessary to see past the constructor of the inductive type?</p>",
        "id": 213656936,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1602948624
    },
    {
        "content": "<p>yes, it's just short for <code>cases</code></p>",
        "id": 213657019,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602948749
    },
    {
        "content": "<p>But to really make this cubical, we would need <code>deq</code> over <code>deq</code>,  etc...</p>",
        "id": 213657025,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1602948767
    },
    {
        "content": "<p><code>deq</code> over <code>deq</code> is not really any more cubical, but it is a separate issue I'm a bit confused about</p>",
        "id": 213657043,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602948803
    },
    {
        "content": "<p>Isn't it a path dependent on a path?</p>",
        "id": 213657050,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1602948842
    },
    {
        "content": "<p>A path dependent on a path is still a path</p>",
        "id": 213657092,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602948864
    },
    {
        "content": "<p>I think you're thinking of a path <em>in</em> a path type</p>",
        "id": 213657096,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602948869
    },
    {
        "content": "<p>(I'm assuming by <code>deq</code> over <code>deq</code> you meant something like <code>e : a = a'</code>, <code>f : x =[e] x'</code>, then you want some kind of <code>y =[f] y'</code>)</p>",
        "id": 213657111,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602948918
    },
    {
        "content": "<p>that just corresponds to a longer telescope/context</p>",
        "id": 213657160,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602948968
    },
    {
        "content": "<p>like a path <code>\\I -&gt; Sigma (a : A) (b : B a), C a b</code> (where <code>\\I</code> is the interval)</p>",
        "id": 213657172,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602949022
    },
    {
        "content": "<p>while a higher cube is <code>\\I -&gt; \\I -&gt; A</code></p>",
        "id": 213657177,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602949036
    },
    {
        "content": "<p>er, <code>Pi</code> wasn't right--something more like <code>Sigma</code>, but really more like <code>a : A, b : B a |- \\I -&gt; C a b</code></p>",
        "id": 213657190,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602949078
    },
    {
        "content": "<p>ok even this is wrong</p>",
        "id": 213657227,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602949093
    },
    {
        "content": "<p><code>a</code> and <code>b</code> should also depend on an interval variable... but hopefully you get the idea</p>",
        "id": 213657241,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602949159
    },
    {
        "content": "<p>Explicitly, this is the next entry in the sequence</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ddeq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">]</span> <span class=\"n\">x'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"n\">a</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"n\">a'</span> <span class=\"n\">x'</span><span class=\"o\">),</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"n\">a</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ddeq</span> <span class=\"o\">(</span><span class=\"n\">deq.refl</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">y</span>\n</code></pre></div>",
        "id": 213657433,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602949442
    },
    {
        "content": "<p>I'm just being naive and thinking of a path of paths as a cube.</p>",
        "id": 213657487,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1602949516
    },
    {
        "content": "<p>But yes I get the idea</p>",
        "id": 213657490,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1602949524
    },
    {
        "content": "<p>Right, this one isn't a path of paths, it's a path whose image under the fibration/display map corresponding to <code>C</code> is the given path <code>e</code></p>",
        "id": 213657550,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602949621
    },
    {
        "content": "<p>Forgetting cubical stuff, it seems that to really make this behave like equality we would need the <code>ddeq</code> you defined, and a <code>dddeq</code> and a <code>ddddeq</code> and ...</p>",
        "id": 213657553,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1602949636
    },
    {
        "content": "<p>or in the <code>ddeq</code>, three paths, each one lying over the next (previous?)</p>",
        "id": 213657554,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602949646
    },
    {
        "content": "<p>Oh you mean like the Kan filling condition for cubes? (I don't remember the actual name)</p>",
        "id": 213657617,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1602949748
    },
    {
        "content": "<p>Amusingly, this is (at least spiritually) related to the other conversation about the topology on an sigma type</p>",
        "id": 213657624,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602949767
    },
    {
        "content": "<p>I built the pathover library for Lean 2 HoTT, and I was also worried about needing ddeq, dddeq, etc. (and in HoTT it's worse because then you also need square, dsquare, ddsquare, ..., cube, dcube, ..., ...). However, if you defined <code>ddeq</code>, depending on a path <code>p : x = x'</code> and a pathover <code>q : y =[p] y'</code> and write it as something as <code>z =[p][q] z'</code>, then you can prove that it's equivalent to <code>z =[(p, q)] z'</code>, where <code>(p, q)</code> is a path <code>(x, y) = (x', y')</code> in the sigma-type, built from <code>p</code> and <code>q</code>. And then it's easier to just use <code>z =[(p, q)] z'</code> in the first place, and then you never have to define <code>deq</code>.</p>",
        "id": 213668025,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1602964360
    },
    {
        "content": "<p>Is <code>deq</code> different from equality of sigma types?  I was experimenting with this, and you can at least implement the recursor for <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>'s <code>deq</code> with it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">deq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">psigma.mk</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">psigma.mk</span> <span class=\"n\">a'</span> <span class=\"n\">x'</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">===</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"o\">:=</span> <span class=\"n\">deq</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[refl]</span> <span class=\"kd\">lemma</span> <span class=\"n\">deq.refl</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">===</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span>  <span class=\"c1\">-- \"not a rfl lemma\"</span>\n<span class=\"kd\">@[symm]</span> <span class=\"kd\">lemma</span> <span class=\"n\">deq.symm</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">===</span> <span class=\"n\">x'</span> <span class=\"bp\">→</span> <span class=\"n\">x'</span> <span class=\"bp\">===</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">@[trans]</span> <span class=\"kd\">lemma</span> <span class=\"n\">deq.trans</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"n\">a''</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x''</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a''</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">===</span> <span class=\"n\">x'</span> <span class=\"bp\">→</span> <span class=\"n\">x'</span> <span class=\"bp\">===</span> <span class=\"n\">x''</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">===</span> <span class=\"n\">x''</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">deq.index_eq</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">===</span> <span class=\"n\">x'</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">deq.value_eq</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">===</span> <span class=\"n\">x'</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">deq.value_eq'</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">===</span> <span class=\"n\">x'</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">eq.rec</span> <span class=\"n\">x</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">deq.to_heq</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">===</span> <span class=\"n\">x'</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">x'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">deq</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">deq.rec</span> <span class=\"o\">{</span><span class=\"n\">C'</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">a'</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">C'</span> <span class=\"n\">rfl</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">===</span> <span class=\"n\">x'</span> <span class=\"bp\">→</span> <span class=\"n\">C'</span> <span class=\"n\">e</span> <span class=\"n\">x</span> <span class=\"n\">x'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">apply</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">deq.rec_rule</span> <span class=\"o\">{</span><span class=\"n\">C'</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">a'</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">C'</span> <span class=\"n\">rfl</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a'</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">deq.rec</span> <span class=\"n\">α</span> <span class=\"n\">C</span> <span class=\"bp\">@</span><span class=\"n\">C'</span> <span class=\"bp\">@</span><span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"n\">rfl</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"n\">deq.refl</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 213669928,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1602967347
    },
    {
        "content": "<p>If you have proof irrelevance like in Lean 3 they are the same. <br>\nIn HoTT they are not quite the same, but closely related:<br>\n<a href=\"https://github.com/leanprover/lean2/blob/8072fdf9a0b31abb9d43ab894d7a858639e20ed7/hott/types/sigma.hlean#L109-L110\">https://github.com/leanprover/lean2/blob/8072fdf9a0b31abb9d43ab894d7a858639e20ed7/hott/types/sigma.hlean#L109-L110</a><br>\nA path is in a sigma type consists of a path between the first components and then a path between the second components over the first path.</p>",
        "id": 213673963,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1602974064
    },
    {
        "content": "<p>I like Kyle's version of deq, it looks strictly more useful than <code>heq</code></p>",
        "id": 213689411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602998754
    },
    {
        "content": "<p>I think the type of <code>deq</code> is less convenient to work with than <code>heq</code>: the elaborator will not always be able to figure out what <code>C</code> is from the types of <code>x</code> and <code>x'</code>. In the hott3 library we had to make the family of pathovers explicit, because the elaborator of Lean 3 too often couldn't figure out the type family (in Lean 2 this was not necessary).</p>",
        "id": 213691656,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1603002425
    },
    {
        "content": "<p>That's probably true. I often use sigma type equalities in lieu of <code>deq</code> (as mentioned earlier in this thread), but you can almost never avoid writing the type family</p>",
        "id": 213691835,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603002785
    },
    {
        "content": "<p>Why do you think <code>deq</code> is more useful than <code>heq</code>? Isn't <code>deq</code> just a special case of <code>heq</code>, and you can prove all lemmas about <code>deq</code> for <code>heq</code>?</p>",
        "id": 213691897,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1603002934
    },
    {
        "content": "<p><code>heq</code> is a special case of <code>deq</code> (with the identity <code>C</code>), not the other way around afaict</p>",
        "id": 213691959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603003079
    },
    {
        "content": "<p>Oh, you're right. From <code>deq x x'</code> you get that <code>a = a'</code>, which you don't get from <code>x == x'</code>. Yeah, that sounds pretty useful.</p>",
        "id": 213692081,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1603003298
    },
    {
        "content": "<p>The difference between my original <code>deq</code> and Kyle's version is indexing vs bundling--in Lean, everything in sight is a Prop and so there seems to be no disadvantage to Kyle's bundled version.</p>",
        "id": 213709491,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603032448
    }
]
[
    {
        "content": "<p>I got a \"goal accomplished\" together with a \"deterministic timeout\". This appends right at the end of a proof, at the \"refl\" or \"simp\" line. I found out that this problem was already encountered one week ago : <br>\n<a href=\"#narrow/stream/240192-Berkeley-Lean.20Seminar/topic/Project.20ideas/near/217690233\">https://leanprover.zulipchat.com/#narrow/stream/240192-Berkeley-Lean.20Seminar/topic/Project.20ideas/near/217690233</a><br>\nThis error message is quite dreadful (you feel so close, but you are so far), and I think it deserves its own topic. In my case, I found a different proof that work, but I still don't understand why my first, more beautiful proof fails. The issue was also solved in the discussion linked above. What I gathered is that : <br>\n-the issue is not actually at the \"refl\" but happens before, some tactic is messing around, corrupting some goal in the background, and when the compiler checks what's the tactic did, it gets lost.<br>\n-In the case linked above, replacing a \"have\" by a \"let\" in an isomorphism in the proof solved the problem. The isomorphism had to be describe explicitly.<br>\n-In my case, I replaced a proof based on a associativity lemmas by a proof with multiple dsimp and some lower level lemmas. I have still no idea where the error comes from, and I am afraid it is just under the carpet, ready to appear again.</p>",
        "id": 218432308,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606834683
    },
    {
        "content": "<p>Since I have a functioning proof (for now), this topic aims at documenting the issue rather than solving my problem, but here is the faulty code anyway : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">compq_quotient_assoc</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"o\">:</span><span class=\"n\">ideal</span> <span class=\"bp\">$</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">quotient_cast</span> <span class=\"o\">(</span><span class=\"n\">le_of_eq</span> <span class=\"o\">(</span><span class=\"n\">comp_ideal_assoc</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">I</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span> <span class=\"o\">(</span><span class=\"n\">compq_quotient</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"n\">comp_ideal</span> <span class=\"n\">p</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">compq_quotient</span> <span class=\"n\">p</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">=</span>\n<span class=\"n\">compq_quotient</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">I</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">compq_quotient</span><span class=\"o\">,</span> <span class=\"n\">quotient_cast</span><span class=\"o\">],</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">quotient_map_assoc</span><span class=\"o\">},</span>\n    <span class=\"n\">congr'</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">compq_assoc</span><span class=\"o\">,</span>  <span class=\"c1\">--goal accomplished but deterministic timeout</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>and the correct proof : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">compq_quotient_assoc'</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"o\">:</span><span class=\"n\">ideal</span> <span class=\"bp\">$</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">quotient_cast</span> <span class=\"o\">(</span><span class=\"n\">le_of_eq</span> <span class=\"o\">(</span><span class=\"n\">comp_ideal_assoc</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">I</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span> <span class=\"o\">(</span><span class=\"n\">compq_quotient</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"n\">comp_ideal</span> <span class=\"n\">p</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">compq_quotient</span> <span class=\"n\">p</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">=</span>\n<span class=\"n\">compq_quotient</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">I</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">ring_hom.ext</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">aclass</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">ideal.quotient.mk_surjective</span> <span class=\"n\">aclass</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">quotient_cast</span><span class=\"o\">,</span> <span class=\"n\">compq_quotient</span><span class=\"o\">,</span> <span class=\"n\">comp_ideal</span><span class=\"o\">,</span> <span class=\"n\">ideal.quotient_map</span><span class=\"o\">,</span> <span class=\"n\">ideal.map</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span>  <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">ideal.quotient.lift_mk</span><span class=\"o\">},</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">compq</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">comp_assoc</span><span class=\"o\">,</span>  <span class=\"c1\">--works fine, but slow</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Finally, the full context : </p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>import ring_theory.adjoin_root ring_theory.ideal.operations <br>\nimport linear_algebra.basis linear_algebra.matrix algebra.module.basic  algebra.polynomial.group_ring_action<br>\nimport tactic</p>\n<p>noncomputable theory</p>\n<p>--We show that 1, (X-l), ... (X-l)^n is a basis for K[X]/(X-l)^(n+1), using the power basis 1, ..., X^n of K[X]/X^(n+1)</p>\n<p>namespace adjoin_root_basis</p>\n<p>open polynomial --to use X as the polynomial indeterminate</p>\n<p>variables {R:Type} [comm_ring R] (I J : ideal $polynomial R) (p q: polynomial R)</p>\n<p>--let us define some casting function to take care of the heterogenous equality problem. </p>\n<p>lemma trivial_id_inclusion  {I J: ideal R} (ilj:I≤ J) : I ≤ ideal.comap (<a href=\"http://ring_hom.id\">ring_hom.id</a> R) J :=<br>\nbegin<br>\n    intros x xin, simp, exact  ilj xin,<br>\nend </p>\n<p>def quotient_cast {I J:ideal R} (ilj: I≤ J) :=ideal.quotient_map J (<a href=\"http://ring_hom.id\">ring_hom.id</a> R) (trivial_id_inclusion ilj)</p>\n<p>--a few simp-type lemmas for quotient_cast<br>\nlemma quotient_cast_id {I : ideal R} (ilj: I≤ I): (quotient_cast ilj)=ring_hom.id I.quotient :=<br>\nbegin<br>\n    dsimp [quotient_cast, ideal.quotient_map],ext, <br>\n    cases ideal.quotient.mk_surjective x with a ha,<br>\n    rw ← ha,<br>\n    rw ideal.quotient.lift_mk ,<br>\n    simp,<br>\nend</p>\n<p>lemma quotient_cast_composition {I J L : ideal R} (ilj : I≤ J) (jll: J≤L) : <br>\n(quotient_cast jll)∘ (quotient_cast ilj)= quotient_cast (le_trans ilj jll):=<br>\nbegin<br>\n   dsimp [quotient_cast, ideal.quotient_map], ext,  <br>\n   cases ideal.quotient.mk_surjective x with a ha,<br>\n    rw ← ha,<br>\n    repeat {rw ideal.quotient.lift_mk},<br>\n    simp,<br>\nend</p>\n<p>--this should do for the nondefinitional equality problem<br>\n--question : could this \"cast\" tric be done more generally to any dependent type ? </p>\n<p>--another preliminary : the \"associativity\" of quotient_map. <br>\n#check ideal.quotient_map </p>\n<p>--first a little lemma to compose inequalities necessary to quotient_map</p>\n<p>def comap_ineg_assoc {R1: Type} {R2: Type} {R3:Type} [comm_ring R1] [comm_ring R2] [comm_ring R3] {I: ideal R1} {J: ideal R2} (K:ideal R3)<br>\n(f: ring_hom R1 R2) (g: ring_hom R2 R3)  (ilfj: I≤ ideal.comap f J) (jlgk : J≤ ideal.comap g K) :<br>\nI≤ ideal.comap (g.comp f) K :=λ x xin,jlgk (ilfj xin)</p>\n<p>lemma quotient_map_assoc {R1: Type} {R2: Type} {R3:Type} [comm_ring R1] [comm_ring R2] [comm_ring R3] {I: ideal R1} {J: ideal R2} (K:ideal R3)<br>\n(f: ring_hom R1 R2) (g: ring_hom R2 R3) (ilfj: I≤ ideal.comap f J) (jlgk : J≤ ideal.comap g K) :<br>\n(ideal.quotient_map K g jlgk).comp (ideal.quotient_map J f ilfj )=ideal.quotient_map K (g.comp f) (comap_ineg_assoc K f g ilfj jlgk):=<br>\nbegin<br>\n    apply ring_hom.ext, intro xclass,<br>\n    cases ideal.quotient.mk_surjective xclass with x hx, rw ← hx,<br>\n    dsimp [ideal.quotient_map],<br>\n    repeat {rw ideal.quotient.lift_mk},simp,<br>\nend</p>\n<p>--Now we construct some ring homomorphisms between quotients. </p>\n<p>def compq (q:polynomial R) : ring_hom (polynomial R) (polynomial R):=<br>\n{<br>\nto_fun:= λ p, p.comp q, <br>\nmap_add':=λ p r, begin apply add_comp, end , <br>\nmap_mul':= λ p r, begin simp, end, <br>\nmap_one':= begin simp, end,<br>\nmap_zero':=begin simp, end,<br>\n}</p>\n<p>lemma compq_assoc (p:polynomial R) (q: polynomial R) : (compq p).comp (compq q) =compq (q.comp p):=<br>\nbegin<br>\n    apply ring_hom.ext, intro x,<br>\n    dsimp [compq], <br>\n    apply comp_assoc, --Key step<br>\nend</p>\n<p>def comp_ideal (p: polynomial R) (I: ideal $polynomial R)  :=ideal.map (compq p) I </p>\n<p>--a simp lemma describing the composition<br>\nlemma comp_ideal_assoc (p q:polynomial R) (I: ideal $ polynomial R)  : comp_ideal q (comp_ideal p I) =comp_ideal (p.comp q) I:=<br>\nbegin<br>\n    dsimp [comp_ideal], <br>\n    rw ideal.map_map, --Key step<br>\n    congr', <br>\n    rw compq_assoc q p,<br>\nend</p>\n<p>--a simp lemma used to define the quotient map <br>\nlemma compq_comp_ideal (p:polynomial R) (I:ideal $ polynomial R) : ∀ (r:polynomial R),<br>\nr∈ I → r.comp p ∈ comp_ideal p I :=<br>\nbegin<br>\n    intros r rin,<br>\n    apply ideal.subset_span, --key step 1<br>\n    dsimp [compq],<br>\n    use r,<br>\n    split, <br>\n    {exact rin,},{simp,},<br>\nend</p>\n<p>def compq_quotient (p:polynomial R) (I: ideal $polynomial R)  : I.quotient →+* (comp_ideal p I).quotient :=<br>\nideal.quotient_map (comp_ideal p I) (compq p) (compq_comp_ideal p I)</p>\n<p>#check compq_quotient p I <br>\n#check (compq_quotient q (comp_ideal p I) ).comp (compq_quotient p I)<br>\n#check (quotient_cast (le_of_eq (comp_ideal_assoc p q I))).comp ( (compq_quotient q (comp_ideal p I) ).comp (compq_quotient p I))</p>\n<p>--the lemma that \"trivally\" composes the compq_quotient maps. We need the quotient_cast map to <br>\n--make the equality between quotients by ideals wich are equal but not equal by def. </p>\n<p>lemma compq_quotient_assoc (p: polynomial R) (q : polynomial R) (I:ideal $ polynomial R) :<br>\n(quotient_cast (le_of_eq (comp_ideal_assoc p q I))).comp ( (compq_quotient q (comp_ideal p I) ).comp (compq_quotient p I))=<br>\ncompq_quotient (p.comp q) I :=<br>\nbegin<br>\n    dsimp [compq_quotient, quotient_cast],<br>\n    repeat {rw quotient_map_assoc},<br>\n    congr',<br>\n    simp,<br>\n    rw compq_assoc,  --goal accomplished but deterministic timeout<br>\nend</p>\n<p>lemma compq_quotient_assoc' (p: polynomial R) (q : polynomial R) (I:ideal $ polynomial R) :<br>\n(quotient_cast (le_of_eq (comp_ideal_assoc p q I))).comp ( (compq_quotient q (comp_ideal p I) ).comp (compq_quotient p I))=<br>\ncompq_quotient (p.comp q) I :=<br>\nbegin<br>\n    apply ring_hom.ext, intro aclass, <br>\n    cases ideal.quotient.mk_surjective aclass with a ha,<br>\n    dsimp [quotient_cast, compq_quotient, comp_ideal, ideal.quotient_map, ideal.map],<br>\n    rw ←  ha,<br>\n    repeat {rw ideal.quotient.lift_mk},<br>\n    simp,<br>\n    dsimp [compq],<br>\n    rw comp_assoc,  --works fine, but slow<br>\nend</p>\n</div></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>\n</code></pre></div>",
        "id": 218432839,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606834909
    },
    {
        "content": "<p>The faulty proof uses a lemma quotient_map_assoc on the composition of ideal.quotient_map, maybe a similar lemma already exists but the closest I could find was  ideal.comp_quotient_map_eq_of_comp_eq<br>\nThe lemma quotient_map_assoc does not return any error, but I fear that it's where the mess happens. It's a shame because it looks useful.</p>",
        "id": 218434232,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606835506
    },
    {
        "content": "<p>The problem with the timing-out proof is <code>congr'</code> (if you put <code>sorry</code> immediately after the <code>congr'</code> you get the timeout).</p>",
        "id": 218436330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606836443
    },
    {
        "content": "<p>Indeed, but there may still be a mess earlier. When I get rid of the congr' and I try to do a rw, I get a \"motive is not type correct\". With simp_rw, the goal accomplished+timeout is back : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">compq_quotient</span><span class=\"o\">,</span> <span class=\"n\">quotient_cast</span><span class=\"o\">],</span>\n    <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">quotient_map_assoc</span><span class=\"o\">},</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n     <span class=\"n\">simp_rw</span> <span class=\"n\">compq_assoc</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"o\">,</span>  <span class=\"c1\">-- rw gives a \"motive is not type correct\" error, so I use simp_rw</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"c1\">--ga +timeout</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 218438877,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606837509
    },
    {
        "content": "<p>you need four backticks for the spoiler tag if you want to put code in it</p>",
        "id": 218444943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606839622
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> thanks, it's done.</p>",
        "id": 218445390,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606839794
    },
    {
        "content": "<p>There is no coloration though.</p>",
        "id": 218445686,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606839922
    },
    {
        "content": "<p>you need <code> ```lean </code> probably</p>",
        "id": 218445734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606839944
    },
    {
        "content": "<p>it's set as the default language in this zulip instance but I guess it doesn't work under spoiler tags</p>",
        "id": 218445837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606839979
    },
    {
        "content": "<p>Indeed color is back !</p>",
        "id": 218446688,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606840357
    },
    {
        "content": "<p>I think I understand the problem a bit more, having tested different things. I think it lies in the argument <code> (hIJ : I ≤ ideal.comap f J)</code> of ideal.quotient_map . In VSCode, this argument is hidden in the current goal during the proof (but I get to see it if I hover on it). I think the rw tactics fails because if it replaces an expression in the first argument of quotient_map but does not modify it in the second argument, the obtained expression makes no sense. I suppose simp_rw and congr' both have a faulty treatment of this second argument. This is why taking a representative with ideal.quotient.mk_surjective and proving things outside of the quotient works in the second proof.</p>",
        "id": 218451271,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606842144
    },
    {
        "content": "<p>So far I've managed to reduce the bad <code>congr'</code> proof to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"n\">ideal.comap</span>\n    <span class=\"o\">((</span><span class=\"n\">ring_hom.id</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">((</span><span class=\"n\">compq</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">compq</span> <span class=\"n\">p</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"n\">comp_ideal</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"n\">ideal.comap</span> <span class=\"o\">(</span><span class=\"n\">compq</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">comp_ideal</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">comp_ideal</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient_map</span>\n    <span class=\"o\">((</span><span class=\"n\">ring_hom.id</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">((</span><span class=\"n\">compq</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">compq</span> <span class=\"n\">p</span><span class=\"o\">)))</span> <span class=\"n\">h1</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">comp_ideal</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient_map</span> <span class=\"o\">(</span><span class=\"n\">compq</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">H_congr_lemma</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">f_1</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_3</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f_1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hIJ</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"n\">ideal.comap</span> <span class=\"n\">f</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hIJ_1</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"n\">ideal.comap</span> <span class=\"n\">f_1</span> <span class=\"n\">J</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">f_1</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_3</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f_1</span><span class=\"o\">)</span>\n   <span class=\"o\">(</span><span class=\"n\">hIJ</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"n\">ideal.comap</span> <span class=\"n\">f</span> <span class=\"n\">J</span><span class=\"o\">),</span>\n     <span class=\"bp\">@</span><span class=\"n\">eq.drec</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">f</span>\n       <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f_1</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_3</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f_1</span><span class=\"o\">),</span>\n          <span class=\"n\">J.quotient_map</span> <span class=\"n\">f</span> <span class=\"n\">hIJ</span> <span class=\"bp\">=</span> <span class=\"n\">J.quotient_map</span> <span class=\"n\">f_1</span>\n              <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">eq.rec</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">f</span>\n                 <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"n\">ideal.comap</span> <span class=\"n\">f</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n                 <span class=\"n\">hIJ</span> <span class=\"n\">f_1</span> <span class=\"n\">e_3</span><span class=\"o\">))</span>\n       <span class=\"n\">rfl</span> <span class=\"n\">f_1</span> <span class=\"n\">e_3</span><span class=\"o\">)</span>\n    <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"n\">f</span> <span class=\"n\">f_1</span> <span class=\"n\">e_3</span> <span class=\"n\">hIJ</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">H_congr_lemma</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"n\">comp_ideal</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">)</span>\n    <span class=\"o\">((</span><span class=\"n\">ring_hom.id</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">((</span><span class=\"n\">compq</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">compq</span> <span class=\"n\">p</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"n\">compq</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">))</span>\n    <span class=\"n\">sorry</span>\n    <span class=\"n\">h1</span>\n    <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 218452308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606842610
    },
    {
        "content": "<p>The theorem statement is the state immediately before <code>congr'</code>. AFAICT it typechecks, so rw is not to blame</p>",
        "id": 218452405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606842654
    },
    {
        "content": "<p>The <code>H_congr_lemma</code> is the proof generated by <code>congr'</code>. It also typechecks, but applying the proof (which is the final <code>have</code> and <code>exact this</code>) fails. I notice that the type of the <code>have</code> is not literally the same as the goal, it produces something other than <code>h2</code> on the rhs</p>",
        "id": 218452644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606842764
    },
    {
        "content": "<p>Nice ! I should learn how to get these generated proofs. I did not mean to say that rw was to blame, I meant that it cannot be applied because of the second argument, and this is why I was cornered into using congr' in the first place.</p>",
        "id": 218454210,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606843455
    },
    {
        "content": "<p>I've written a lemma to replace the sorry, in your code, to be sure it was not interfering. The second <code>have</code> produces </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">comp_ideal</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient_map</span> <span class=\"o\">((</span><span class=\"n\">ring_hom.id</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">((</span><span class=\"n\">compq</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">compq</span> <span class=\"n\">p</span><span class=\"o\">)))</span> <span class=\"n\">h1</span> <span class=\"bp\">=</span>\n<span class=\"o\">(</span><span class=\"n\">comp_ideal</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient_map</span> <span class=\"o\">(</span><span class=\"n\">compq</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>where _ is of type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">I</span> <span class=\"bp\">≤</span> <span class=\"n\">ideal.comap</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">comp_ideal</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">I</span><span class=\"o\">))</span>  <span class=\"o\">(</span><span class=\"n\">compq</span> <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Implementing the substitution (i.e. replacing f by (compq (p.comp q) ) in the expression) gives the type of h2. This type is equal to the type of h2, but not definitionally (edit : no, they are defeq) ! This problem, again. Does this mean there is some <code>heq</code> issue in <code>congr'</code> ?</p>",
        "id": 218458110,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606845360
    },
    {
        "content": "<p>are you sure it is not defeq? I tried the same thing and <code>rfl</code> proves they are equal</p>",
        "id": 218458202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606845398
    },
    {
        "content": "<p>Okay, they are defeq. Why is this not <code>h2</code> then ?</p>",
        "id": 218458329,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606845469
    },
    {
        "content": "<p>it is, I'm pretty sure</p>",
        "id": 218458407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606845485
    },
    {
        "content": "<p>but I also have evidence that lean is unfolding lots of things and I'm not sure why yet</p>",
        "id": 218458452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606845504
    },
    {
        "content": "<p>for example, the error goes away if you make <code>ring_hom.id</code> an axiom</p>",
        "id": 218458495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606845535
    },
    {
        "content": "<p>More minimized:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.eval</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">p.comp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">q.comp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">p.comp</span> <span class=\"bp\">=</span> <span class=\"n\">q.comp</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">eq.rec</span> <span class=\"n\">h1</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">q.comp</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">change</span> <span class=\"n\">h2</span> <span class=\"bp\">=</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 218462118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606847200
    },
    {
        "content": "<p>the weird thing is that the <code>change</code> works but the <code>exact</code> doesn't, meaning that the elaborator and kernel disagree about the defeq</p>",
        "id": 218462193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606847239
    },
    {
        "content": "<p>So it is indeed a problem of defeq on the type of h2 ? Very strange indeed.</p>",
        "id": 218464685,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606848508
    },
    {
        "content": "<p>is anything <code>irreducible</code> today?</p>",
        "id": 218464771,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606848553
    },
    {
        "content": "<p><code>polynomial.comp</code> appears to be today's culprit</p>",
        "id": 218464799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606848571
    },
    {
        "content": "<p>it still doesn't make any sense to me that this would be unfolded though</p>",
        "id": 218464927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606848614
    },
    {
        "content": "<p>This looks similar to the other weirdness then</p>",
        "id": 218464998,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606848656
    },
    {
        "content": "<p>amusingly, lean is totally fine with the proof <code>proof_irrel _ _</code></p>",
        "id": 218465009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606848664
    },
    {
        "content": "<p>in that, putting everything else aside, <span aria-label=\"this\" class=\"emoji emoji-1f446\" role=\"img\" title=\"this\">:this:</span> both sides of the equality are propositions</p>",
        "id": 218465031,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606848677
    },
    {
        "content": "<p>actually <code>eval₂</code> looks like a better candidate for irreducibility</p>",
        "id": 218465236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606848782
    },
    {
        "content": "<p>also finsupp.sum</p>",
        "id": 218465294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606848816
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/b7649bcd2d4db889ae2651637e2c8969c89f4c1f/src/data/polynomial/eval.lean#L479-L485\">https://github.com/leanprover-community/mathlib/blob/b7649bcd2d4db889ae2651637e2c8969c89f4c1f/src/data/polynomial/eval.lean#L479-L485</a></p>",
        "id": 218465310,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606848821
    },
    {
        "content": "<p>or do you mean better than <code>tensor_algebra</code> or whatever it was</p>",
        "id": 218465345,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606848841
    },
    {
        "content": "<p>oh curious</p>",
        "id": 218465410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606848861
    },
    {
        "content": "<p>(For <span class=\"user-mention\" data-user-id=\"349646\">@Simon Andreys</span> and others, I'm referring to <a href=\"#narrow/stream/113488-general/topic/algebra.2Esemiring_to_ring.20breaks.20semimodule.20typeclass.20lookup/near/218215493\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/algebra.2Esemiring_to_ring.20breaks.20semimodule.20typeclass.20lookup/near/218215493</a>)</p>",
        "id": 218465727,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606849006
    },
    {
        "content": "<p>Uh oh:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.eval</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">p.eval₂</span> <span class=\"n\">c</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">p.eval₂</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p.eval₂</span> <span class=\"n\">c</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">p.eval₂</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">h2</span> <span class=\"bp\">=</span> <span class=\"n\">eq.rec</span> <span class=\"n\">h1</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- timeout</span>\n</code></pre></div>\n<p>irreducibility may not be good enough</p>",
        "id": 218465904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606849085
    },
    {
        "content": "<p>Aha, it's not <code>eval2</code> that's the problem, it's fine if you use <code>eval2</code> over another semiring. It's the <code>polynomial R</code> semiring instance</p>",
        "id": 218467049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606849615
    },
    {
        "content": "<p>or at least, it's the combination of the two</p>",
        "id": 218467303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606849754
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.basic</span>\n\n<span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">polynomial.eval₂'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"n\">p.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">polynomial</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">p.eval₂'</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">q.eval₂'</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p.eval₂'</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">q.eval₂'</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">h2</span> <span class=\"bp\">=</span> <span class=\"n\">eq.rec</span> <span class=\"n\">h1</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Replacing the definition of <code>eval₂'</code> with <code>sorry</code> makes it work, so clearly lean is reducing the irreducible</p>",
        "id": 218468150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606850187
    },
    {
        "content": "<p>The issue is quite out of my scope, but what I gather is that the elaborator does reduce some expression while the compilator doesn't (or the other way around ?), and this problem was already raised before and is linked with the irreducible tag. It's reassuring in some way, since I kinda understand what may cause it (some Prop in the parameters of a function is wrongly typed by some tactic), and how to work around (unfold and dsimp, and use low level lemmas, as unpleasant it may be). Better even, the root problem may be solved at some point and the \"high\" level proof be efficient again.</p>",
        "id": 218489736,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1606860800
    },
    {
        "content": "<p>I was overly optimistic when saying that I knew how to work around the problem : it resurfaced at the next lemma. I will use a less composite approach to construct the isomorphism I want.</p>",
        "id": 218766291,
        "sender_full_name": "Simon Andreys",
        "timestamp": 1607035962
    }
]
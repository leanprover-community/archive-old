[
    {
        "content": "<p>Something is wrong with my definition of <code>orthonormal</code> here:  as evidence, note that if <code>orthonormal</code> is changed to <code>linear_independent</code> throughout, then there are no errors.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.inner_product</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kn\">open</span> <span class=\"n\">finite_dimensional</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">is_R_or_C</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`⟪`</span><span class=\"n\">x</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">y</span><span class=\"bp\">`⟫`</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">inner</span> <span class=\"bp\">𝕜</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">orthonormal</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"bp\">⟪</span><span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">j</span><span class=\"bp\">⟫</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"bp\">𝕜</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">basis_constructor</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">orthonormal</span> <span class=\"bp\">𝕜</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">card_eq</span> <span class=\"o\">:</span> <span class=\"n\">fintype.card</span> <span class=\"n\">ι</span> <span class=\"bp\">=</span> <span class=\"n\">findim</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_basis</span> <span class=\"bp\">𝕜</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">E</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_set</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">findim</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">my_set_spec</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">orthonormal</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">my_set</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">findim</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">my_set</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">basis_constructor</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">my_set_spec</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"c1\">-- error is here!</span>\n</code></pre></div>",
        "id": 222522835,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1610503124
    },
    {
        "content": "<p>The error message is a beauty!</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>type mismatch at application\n  basis_constructor 𝕜 (my_set_spec 𝕜 E)\nterm\n  my_set_spec 𝕜 E\nhas type\n @orthonormal 𝕜 E _inst_1 _inst_2\n    (fin\n       (@findim 𝕜 E\n          (@normed_field.to_field 𝕜 ... ***etc etc***\nbut is expected to have type ***etc etc***\n ```\n</code></pre></div>",
        "id": 222522961,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1610503213
    },
    {
        "content": "<p>But run through diff-checker, the difference in terms is</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>classical.prop_decidable (a = b))\n</code></pre></div>\n<p>vs</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>@subtype.decidable_eq ℕ\n  (λ (x : ℕ),\n    x &lt;\n      @findim 𝕜 E\n        (@normed_field.to_field 𝕜\n            (@nondiscrete_normed_field.to_normed_field 𝕜\n              (@is_R_or_C.to_nondiscrete_normed_field 𝕜 _inst_1)))\n        (@normed_group.to_add_comm_group E (@inner_product_space.to_normed_group 𝕜 E _inst_1 _inst_2))\n        (@normed_space.to_semimodule 𝕜 E\n            (@nondiscrete_normed_field.to_normed_field 𝕜\n              (@is_R_or_C.to_nondiscrete_normed_field 𝕜 _inst_1))\n            (@inner_product_space.to_normed_group 𝕜 E _inst_1 _inst_2)\n            (@inner_product_space.to_normed_space 𝕜 E _inst_1 _inst_2)))\n  (λ (a b : ℕ), nat.decidable_eq a b)\n  a\n  b)\n</code></pre></div>",
        "id": 222523022,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1610503280
    },
    {
        "content": "<p>Maybe adding a <code>decidable_eq iota </code> argument to <code>basis_constructor</code> might help?</p>",
        "id": 222526908,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1610506947
    },
    {
        "content": "<p>I think I would have just given up with this <code>decidable_eq</code> stuff and gone with something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">orthonormal</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∥</span><span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"bp\">⟪</span><span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">j</span><span class=\"bp\">⟫</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 222530112,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1610510255
    },
    {
        "content": "<p>Thanks both!  I really would like to get it working the \"if then else\" way.  It feels like whack-a-mole:  Chris' idea solves my toy example (posted here) but creates new problems in my real use case.  I have tried twice to get a useful <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, without success, so let me just link the branch:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/compare/exists-orthonormal-basis\">https://github.com/leanprover-community/mathlib/compare/exists-orthonormal-basis</a><br>\nit would be great if someone has the energy to track down the issue.</p>",
        "id": 222530950,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1610511037
    },
    {
        "content": "<p>Is there any particular reason to use if-then-else if it creates this mess?</p>",
        "id": 222531355,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1610511464
    },
    {
        "content": "<p>Good question! ... it's just a hunch, but I suspect that arguments like the following will be cleaner:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- An orthonormal set is linearly independent. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_independent_of_orthonormal</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">orthonormal</span> <span class=\"bp\">𝕜</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">linear_independent</span> <span class=\"bp\">𝕜</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">linear_independent_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">l</span> <span class=\"n\">hl</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h_fun</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">j</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">j</span><span class=\"bp\">⟫</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">j</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"bp\">𝕜</span><span class=\"o\">)),</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">he</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">finsupp.total</span> <span class=\"n\">ι</span> <span class=\"n\">E</span> <span class=\"bp\">𝕜</span> <span class=\"n\">v</span> <span class=\"n\">l</span><span class=\"bp\">⟫</span> <span class=\"bp\">=</span> <span class=\"bp\">⟪</span><span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"bp\">⟫</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">hl</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">finsupp.total_apply</span><span class=\"o\">,</span> <span class=\"n\">finsupp.inner_sum</span><span class=\"o\">,</span> <span class=\"n\">h_fun</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">key</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 222531439,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1610511536
    },
    {
        "content": "<p>anything with summing, anything where one would write it on paper using <a href=\"https://en.wikipedia.org/wiki/Kronecker_delta\">https://en.wikipedia.org/wiki/Kronecker_delta</a></p>",
        "id": 222531467,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1610511577
    },
    {
        "content": "<p>I haven't tried it, but it feels like one would have to break into cases to prove the above lemma using the other definition?</p>",
        "id": 222531656,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1610511728
    },
    {
        "content": "<p>I see. Yeah, maybe I just don't have enough patience for this sort of typeclass mess :-)</p>",
        "id": 222532911,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1610512865
    },
    {
        "content": "<p>Though for a case like this we would probably anyway want a lemma stating <code>l.sum (λ j a, a * ⟪v i, v j⟫) = l i</code>.</p>",
        "id": 222532979,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1610512934
    },
    {
        "content": "<p>I'd go for Frédéric's solution, which avoids all the mess (but you would still prove the lemmas that <code>⟪v i, v i⟫ = 1</code> and <code>⟪v i, v j⟫ = 0</code> for <code>i</code> different from <code>j</code>, which is what you really need). If you really want to go for the <code>ite</code> definition, a way to fix things is probably to remove <code>open_locale classical</code>, and add <code>decidable_eq</code> assumptions in all the statements where Lean complains. But IMHO having less typeclasses in definitions is good; because it means Lean will have to work less whenever it encounters the definition.</p>",
        "id": 222546789,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610525264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/another.20decidable_eq.20problem/near/222546789\">said</a>:</p>\n<blockquote>\n<p>If you really want to go for the <code>ite</code> definition, a way to fix things is probably to remove <code>open_locale classical</code>, and add <code>decidable_eq</code> assumptions in all the statements where Lean complains.</p>\n</blockquote>\n<p>I got it working with this suggestion.  Now that my pride has been satisfied with this small victory over Lean, perhaps I can switch to Frédéric's method :)</p>",
        "id": 222599297,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1610552413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/113488-general/topic/another.20decidable_eq.20problem/near/222531439\">said</a>:</p>\n<blockquote>\n<p>Good question! ... it's just a hunch, but I suspect that arguments like the following will be cleaner:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- An orthonormal set is linearly independent. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_independent_of_orthonormal</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">orthonormal</span> <span class=\"bp\">𝕜</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">linear_independent</span> <span class=\"bp\">𝕜</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Frédéric's definition looks like it should be convenient for deducing that from <code>linear_independent_of_ne_zero_of_inner_eq_zero</code>.</p>",
        "id": 222664906,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1610582624
    },
    {
        "content": "<p>Ah, thanks for the pointer, I didn't know we had this already!</p>",
        "id": 222666360,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1610583673
    }
]
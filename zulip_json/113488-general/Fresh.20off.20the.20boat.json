[
    {
        "content": "<p>Anyone is willing to prove this example for me? It seems too obvious, but I have not luck doing it within the past hour.</p>\n<div class=\"codehilite\"><pre><span></span>universe u\n\nvariable {α : Type u}\n\nstructure constraint (α:Type u) :=\n  cnstr::\n  (trv:bool) -- is trivial\n  (stt:bool) -- is strict\n  (low:bool) -- is lower-bound\n  (bnd:α)\nopen constraint\n\ndef setof : constraint α → α → Prop\n| (cnstr tt _  _   _  ) _ := tt\n| (cnstr _  tt low bnd) a := tt --if low then bnd &lt; a else a &lt; bnd\n| (cnstr _  ff low bnd) a := tt --if low then bnd ≤ a else a ≤ bnd\n\nexample (c: constraint α) (a:α) : setof c a := sorry\n</pre></div>",
        "id": 124351061,
        "sender_full_name": "Nima",
        "timestamp": 1522296924
    },
    {
        "content": "<p>It doesn't even typecheck <span class=\"user-mention\" data-user-id=\"112062\">@Nima</span></p>",
        "id": 124351110,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522297049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Sorry, I  added \"open constraint\". Now it is typed checked</p>",
        "id": 124351152,
        "sender_full_name": "Nima",
        "timestamp": 1522297142
    },
    {
        "content": "<p>you can prove it as:</p>\n<div class=\"codehilite\"><pre><span></span>example (c: constraint α) (a:α) : setof c a :=\nby cases c ; trivial\n</pre></div>\n\n\n<p>I believe</p>",
        "id": 124351206,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522297255
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> internal.lean:21:59: error<br>\ntrivial tactic failed<br>\nstate:<br>\nα : Type u,<br>\na : α,<br>\ntrv stt low : bool,<br>\nbnd : α<br>\n⊢ setof {trv := trv, stt := stt, low := low, bnd := bnd} a</p>",
        "id": 124351263,
        "sender_full_name": "Nima",
        "timestamp": 1522297405
    },
    {
        "content": "<p>You probably want <code>true</code> instead of <code>tt</code> in the definition of <code>setof</code></p>",
        "id": 124351376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522297655
    },
    {
        "content": "<p>And you may find it easier to use this definition rather than yours:</p>\n<div class=\"codehilite\"><pre><span></span>inductive constraint (a : Type u)\n| trivial : constraint\n| strict_upper (x : a) : constraint\n| strict_lower (x : a) : constraint\n| nonstrict_upper (x : a) : constraint\n| nonstrict_lower (x : a) : constraint\n</pre></div>",
        "id": 124351484,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522297816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <br>\nThe following gives me the same error</p>\n<div class=\"codehilite\"><pre><span></span>def  setof : constraint α → α →  Prop\n| (cnstr tt _ _ _ ) _ := true\n| (cnstr _ tt low bnd) a := true --if low then bnd &lt; a else a &lt; bnd\n| (cnstr _ ff low bnd) a := true --if low then bnd ≤ a else a ≤ bnd\n</pre></div>\n\n\n<p>The following is not typechecked</p>\n<div class=\"codehilite\"><pre><span></span>def  setof : constraint α → α →  Prop\n| (cnstr true _ _ _ ) _ := true\n| (cnstr _ true low bnd) a := true --if low then bnd &lt; a else a &lt; bnd\n| (cnstr _ false low bnd) a := true --if low then bnd ≤ a else a ≤ bnd\n</pre></div>",
        "id": 124351488,
        "sender_full_name": "Nima",
        "timestamp": 1522297838
    },
    {
        "content": "<p>The first one is what I mean. FYI you can code block with triple backquote before and after</p>",
        "id": 124351496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522297879
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def setof : constraint α → α → Prop\n| (cnstr tt _ _ _ ) _ := true\n| (cnstr ff tt low bnd) a := true --if low then bnd &lt; a else a &lt; bnd\n| (cnstr ff ff low bnd) a := true --if low then bnd ≤ a else a ≤ bnd\n\nexample : ∀ (c : constraint α) (a:α), setof c a\n| (cnstr tt _ _ _) _ := trivial\n| (cnstr ff tt low bnd) a := trivial\n| (cnstr ff ff low bnd) a := trivial\n</pre></div>",
        "id": 124351539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522297931
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> you don't need after :P</p>",
        "id": 124351545,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522297986
    },
    {
        "content": "<p>Are you one of those people who leaves off <code>&lt;/html&gt;</code></p>",
        "id": 124351546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522298006
    },
    {
        "content": "<p>YOU RUINED THE INTERNET</p>",
        "id": 124351547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522298036
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Not sure what you mean!?</p>",
        "id": 124351592,
        "sender_full_name": "Nima",
        "timestamp": 1522298112
    },
    {
        "content": "<p>About what? The example shows how to prove the theorem by cases</p>",
        "id": 124351593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522298137
    },
    {
        "content": "<p>my quip about the internet was for kenny's benefit</p>",
        "id": 124351594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522298160
    },
    {
        "content": "<p>Note that you need to explicitly specify <code>ff</code> for the latter two cases in the definition of <code>setof</code> for the proof to work</p>",
        "id": 124351633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522298218
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Thanks a lot, it worked</p>",
        "id": 124351638,
        "sender_full_name": "Nima",
        "timestamp": 1522298241
    },
    {
        "content": "<p>Also, if you want to use <code>&lt;</code> you will need an appropriate typeclass, e.g.</p>\n<div class=\"codehilite\"><pre><span></span>def setof [linear_order α] : constraint α → α → Prop\n| (cnstr tt _ _ _ ) _ := true\n| (cnstr ff tt low bnd) a := if low then bnd &lt; a else a &lt; bnd\n| (cnstr ff ff low bnd) a := if low then bnd ≤ a else a ≤ bnd\n</pre></div>",
        "id": 124351677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522298316
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> too soon for those lessons ;)</p>",
        "id": 124351684,
        "sender_full_name": "Nima",
        "timestamp": 1522298392
    },
    {
        "content": "<p>I agree with simon though about your encoding; having a bunch of <code>bool</code> flags will make things harder than just having a single inductive case split</p>",
        "id": 124351726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522298446
    },
    {
        "content": "<p>You can also replace <code>α → Prop</code> with <code>set α</code> in the definition of <code>setof</code> (they are the same, but <code>set α</code> has more associated notations)</p>",
        "id": 124351776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522298597
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Is there any easy explanation for why do I need \"to explicitly specify <code>ff</code> for the latter two cases in the definition of <code>setof</code> for the proof to work \"</p>",
        "id": 124351777,
        "sender_full_name": "Nima",
        "timestamp": 1522298626
    },
    {
        "content": "<p>And if you want to avoid type classes, you should pick a specific type (e.g. <code>ℕ</code>, <code>ℤ</code>, <code>ℚ</code>, <code>ℝ</code>) and the order will come from there</p>",
        "id": 124351821,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522298685
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Is there any easy explanation for why do I need \"to explicitly specify <code>ff</code> for the latter two cases in the definition of <code>setof</code> for the proof to work \"</p>\n</blockquote>\n<p>Because your definition has three equations and you can't match against the bools unless you know their values because you use their exact values in the equations</p>",
        "id": 124351866,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522298771
    },
    {
        "content": "<p>E.g.:</p>\n<div class=\"codehilite\"><pre><span></span>| (cnstr tt _ _ _ ) _ := true\n</pre></div>",
        "id": 124351867,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522298796
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def setof : constraint α → α → Prop\n| (cnstr tt _ _ _ ) _ := true\n| (cnstr ff tt low bnd) a := true\n| (cnstr ff ff low bnd) a := true\n#print prefix setof.equations\n-- setof.equations._eqn_1 : ∀ {α : Type u} (low : bool) (bnd a : α), setof {trv := ff, stt := ff, low := low, bnd := bnd} a = true\n-- setof.equations._eqn_2 : ∀ {α : Type u} (low : bool) (bnd a : α), setof {trv := ff, stt := tt, low := low, bnd := bnd} a = true\n-- setof.equations._eqn_3 : ∀ {α : Type u} (_x _x_1 : bool) (_x_2 _x_3 : α), setof {trv := tt, stt := _x, low := _x_1, bnd := _x_2} _x_3 = true\n\ndef setof : constraint α → α → Prop\n| (cnstr tt _ _ _ ) _ := true\n| (cnstr _ tt low bnd) a := true\n| (cnstr _ ff low bnd) a := true\n#print prefix setof.equations\n-- setof.equations._eqn_1 : ∀ {α : Type u} (low : bool) (bnd a : α), setof {trv := ff, stt := ff, low := low, bnd := bnd} a = true\n-- setof.equations._eqn_2 : ∀ {α : Type u} (low : bool) (bnd a : α), setof {trv := ff, stt := tt, low := low, bnd := bnd} a = true\n-- setof.equations._eqn_3 : ∀ {α : Type u} (_x : bool) (_x_1 _x_2 : α), setof {trv := tt, stt := ff, low := _x, bnd := _x_1} _x_2 = true\n-- setof.equations._eqn_4 : ∀ {α : Type u} (_x : bool) (_x_1 _x_2 : α), setof {trv := tt, stt := tt, low := _x, bnd := _x_1} _x_2 = true\n</pre></div>",
        "id": 124351870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522298821
    },
    {
        "content": "<p>Actually, the problem is that without specifying that the last two cases are <code>ff</code>, it does its first case split on the second bool, leading to four cases overall (with a superfluous case split on <code>stt</code> in the trivial case). This means that later you will need to case on it in the theorem</p>",
        "id": 124351918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522298913
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> So the following from \"8.2. Wildcards and Overlapping Patterns\" is not that useful \" But Lean handles the ambiguity by using the first applicable equation, so the net result is the same \"</p>",
        "id": 124351924,
        "sender_full_name": "Nima",
        "timestamp": 1522298966
    },
    {
        "content": "<p>This has more to do with internals of the heuristics for what to case split when you aren't being explicit about it</p>",
        "id": 124351972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522299019
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Got it! Thanks</p>",
        "id": 124351976,
        "sender_full_name": "Nima",
        "timestamp": 1522299043
    },
    {
        "content": "<p>There's really no need to use a variable in the latter cases, you know it's <code>ff</code> and by writing it you tell lean to split there</p>",
        "id": 124351979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522299064
    },
    {
        "content": "<p>Have I defined <code>has_coe_to_sort</code> correctly? If so, how do I fix the <code>admit</code>s in my proof?</p>\n<div class=\"codehilite\"><pre><span></span>inductive constraint\n| trv                    : constraint\n| stt (bnd:ℕ) (low:Prop) : constraint\n| nst (bnd:ℕ) (low:Prop) : constraint\n\nnamespace constraint\n\ndef setof : constraint → ℕ → Prop :=\nbegin\n  intros c a,\n  cases c with bnd lft bnd lft,\n    case trv         {exact true},\n    case stt bnd lft {exact lft ∧ bnd&lt;a ∨ a &lt; bnd},\n    case nst bnd lft {exact lft ∧ bnd≤a ∨ a ≤ bnd},\nend\n\ninstance constraint_to_sort : has_coe_to_sort constraint :=\n  {S := Type, coe := λ S, {x // setof S x}}\n\nexample : ∀ (c:constraint) (n:c), setof c n :=\nbegin\n  intros c n,\n  cases c,\n    trivial,\n    begin\n      admit\n    end,\n    begin\n      admit\n    end\nend\n\nend constraint\n</pre></div>",
        "id": 124369160,
        "sender_full_name": "Nima",
        "timestamp": 1522334678
    },
    {
        "content": "<p>This doesn't typecheck for me.</p>",
        "id": 124371359,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522337779
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>invalid `case`, there is no goal tagged with prefix [constraint.stt, bnd, lft]\nstate:\n2 goals\ncase constraint.stt\na bnd : ℕ,\nlft : Prop\n⊢ Prop\n\ncase constraint.nst\na bnd : ℕ,\nlft : Prop\n⊢ Prop\n</pre></div>",
        "id": 124371371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522337807
    },
    {
        "content": "<p>line 13</p>",
        "id": 124371375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522337818
    },
    {
        "content": "<p>fixed it</p>",
        "id": 124371556,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522338050
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def setof : constraint → ℕ → Prop :=\nbegin\n  intros c a,\n  cases c with bnd lft bnd lft,\n    case trv         {exact true},\n    case stt {exact lft ∧ bnd&lt;a ∨ a &lt; bnd},\n    case nst {exact lft ∧ bnd≤a ∨ a ≤ bnd},\nend\n</pre></div>",
        "id": 124371576,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522338084
    },
    {
        "content": "<p>I'm using a recent lean nightly</p>",
        "id": 124371579,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522338092
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <br>\nThe following two lines fixed it (replace <code>admit</code>s)<br>\n<code>exact @subtype.property nat (setof (stt bnd low)) n</code><br>\n<code>exact @subtype.property nat (setof (nst bnd low)) n</code><br>\nIn fact I can solve the example in the following way</p>\n<div class=\"codehilite\"><pre><span></span>example : ∀ (c:constraint) (n:c), setof c n :=\nbegin\n  intros c n,\n  exact @subtype.property nat (setof c) n\nend\n</pre></div>",
        "id": 124371678,
        "sender_full_name": "Nima",
        "timestamp": 1522338221
    },
    {
        "content": "<p>I am confused about what's going on.</p>",
        "id": 124371841,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522338440
    },
    {
        "content": "<p><code>setof c</code> wants a nat, and you give it <code>n</code>, which is a <code>c</code>.</p>",
        "id": 124371847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522338464
    },
    {
        "content": "<p>Why the following is invalid? <br>\nError Message \" invalid universe declaration, 'u_1' shadows a local universe\"<br>\nIf I use <code>variable α : Type u</code> then everything will be fine</p>\n<div class=\"codehilite\"><pre><span></span>universe u\nconstant  α : Type u\nvariables x y : α\n</pre></div>\n\n\n<p>The following gives me no error (why?):</p>\n<div class=\"codehilite\"><pre><span></span>universe u\nconstant α : Type u\nvariable x : α\nvariable y : α\n</pre></div>",
        "id": 124375020,
        "sender_full_name": "Nima",
        "timestamp": 1522343674
    },
    {
        "content": "<p>I know the following example can be solve by replacing the last line with <code>exact hm</code>. But why I receive a this error:</p>\n<div class=\"codehilite\"><pre><span></span>universe u\nvariable {α : Type u}\nconstant le : α → α → Prop\nexample :\n∀ (α : Type u)\n  (hm : ∃ (m : α), ∀ (m&#39; : α), le m m&#39;),\n  (∃ (m : α), ∀ (a : α) , le m a) :=\nbegin\n  intros α hm,\n  match hm with ⟨m,hh⟩ := sorry\nend\n</pre></div>\n\n\n<p>It gives me</p>\n<div class=\"codehilite\"><pre><span></span>tmp.lean:12:2: error\ndon&#39;t know how to synthesize placeholder\ncontext:\n⊢ Type ?\n\ntmp.lean:12:2: error\nequation compiler failed (use &#39;set_option trace.eqn_compiler.elim_match true&#39; for additional details)\n\ntmp.lean:12:8: error\nunknown identifier &#39;hm&#39;\n\ntmp.lean:12:8: error\ndon&#39;t know how to synthesize placeholder\ncontext:\n⊢ Sort ?\n\ntmp.lean:12:16: error\ninvalid constructor ⟨...⟩, expected type is not an inductive type\n  ?m_1\n</pre></div>",
        "id": 124376097,
        "sender_full_name": "Nima",
        "timestamp": 1522345433
    },
    {
        "content": "<p>That is funny. Generally I never use constants at all.</p>",
        "id": 124376139,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522345450
    },
    {
        "content": "<p>right, you shouldn't use constant</p>",
        "id": 124376145,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522345473
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> You mean constant for types, right? Otherwise, how do you assume a relation is given to you?</p>",
        "id": 124376163,
        "sender_full_name": "Nima",
        "timestamp": 1522345584
    },
    {
        "content": "<p>I never ever use constants. I would write something like <code>example (le : X -&gt; X -&gt; Prop) : blah</code></p>",
        "id": 124376512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346069
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112062\">@Nima</span> you use variable</p>",
        "id": 124376522,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522346101
    },
    {
        "content": "<p>Or <code>variable</code> yes</p>",
        "id": 124376538,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346119
    },
    {
        "content": "<p>I would use variables or the trick above for an abstract relation.</p>",
        "id": 124376552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346158
    },
    {
        "content": "<p>For a \"well-known\" one like <code>le</code> I would use the type class system</p>",
        "id": 124376596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346171
    },
    {
        "content": "<p>Like this:</p>",
        "id": 124376626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346267
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>variables (X : Type) [has_le X]\nvariables (x y : X)\n#check has_le.le x y\n#check x ≤ y\n</pre></div>",
        "id": 124376674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346297
    },
    {
        "content": "<p>Making X an instance of class <code>has_le</code> enables me to use the notation <code>\\leq</code></p>",
        "id": 124376689,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346321
    },
    {
        "content": "<p><code>\\le</code> :)</p>",
        "id": 124376695,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522346331
    },
    {
        "content": "<p>no way!</p>",
        "id": 124376696,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346339
    },
    {
        "content": "<p>You'll be telling me I don't have to type <code>\\forall</code> next</p>",
        "id": 124376706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346360
    },
    {
        "content": "<p>I know the shortest code for the symbols I use :P</p>",
        "id": 124376707,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522346364
    },
    {
        "content": "<p><code>\\fo</code></p>",
        "id": 124376709,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522346365
    },
    {
        "content": "<p>I discovered that one because I once typed something like <code>\\fo4all</code> followed by a space</p>",
        "id": 124376760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346405
    },
    {
        "content": "<p>and was like \"wooah, it's magic\"</p>",
        "id": 124376772,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346413
    },
    {
        "content": "<p>\"it worked anyway\"</p>",
        "id": 124376783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346421
    },
    {
        "content": "<p>Back to the point</p>",
        "id": 124376817,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346488
    },
    {
        "content": "<p>you can write <code>[H : has_le X]</code> if you want to give the construction a name. Otherwise it ends up being called something like <code>_inst_1</code></p>",
        "id": 124376872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346530
    },
    {
        "content": "<p>but most of the time you don't want to do that</p>",
        "id": 124376882,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522346568
    },
    {
        "content": "<p>Right, most of the time you want Lean to figure it out for you</p>",
        "id": 124376920,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1522346635
    },
    {
        "content": "<p>Thanks, <br>\nWould you please answer this one as well?</p>\n<blockquote>\n<p>I know the following example can be solve by replacing the last line with <code>exact hm</code>. But why I receive a this error:</p>\n</blockquote>",
        "id": 124377820,
        "sender_full_name": "Nima",
        "timestamp": 1522347903
    },
    {
        "content": "<p>match is not a tactic. If you want to use it you have to say <code>exact match ...</code></p>",
        "id": 124377930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522348050
    },
    {
        "content": "<p>When you write it there lean gets all sorts of confused in the parsing</p>",
        "id": 124377984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522348084
    },
    {
        "content": "<p>also <code>match</code> requires <code>end</code> after it</p>",
        "id": 124378010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522348154
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Awesome!</p>",
        "id": 124378069,
        "sender_full_name": "Nima",
        "timestamp": 1522348226
    },
    {
        "content": "<p>The tactic equivalent of <code>match</code> is <code>cases</code>, but I think you have already discovered this</p>",
        "id": 124378075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522348255
    },
    {
        "content": "<p>so you could use <code>cases hm with m hh,</code> in place of the match line</p>",
        "id": 124378087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522348303
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Thanks a lot, I finally finished a proof! (super simple one, yet 65 lines!!)</p>",
        "id": 124379367,
        "sender_full_name": "Nima",
        "timestamp": 1522350200
    },
    {
        "content": "<p>This is about <strong> coercions </strong><br>\nThe first example in the following code works perfectly fine.<br>\nHowever, the second example cannot be type-checked. I know this direction in general is not possible. But this example, <code>trv α</code> contains all elements of <code>α</code>. So how should I prove the second example?</p>\n<div class=\"codehilite\"><pre><span></span>universe u\nvariables {α : Type u} [linear_order α]\n\ninductive constraint (α:Type u)\n| trv                    : constraint\n| stt (bnd:α) (low:Prop) : constraint\n| nst (bnd:α) (low:Prop) : constraint\n\nnamespace constraint\n\ndef setof : constraint α → α → Prop :=\nbegin\n  intros c a,\n  cases c with bnd low bnd low,\n    case trv         {exact true},\n    case stt bnd low {exact low ∧ bnd&lt;a ∨ ¬ low ∧ a &lt; bnd},\n    case nst bnd low {exact low ∧ bnd≤a ∨ ¬ low ∧ a ≤ bnd},\nend\n\ninstance constraint_to_sort : has_coe_to_sort (constraint α) :=\n  {S := Type u, coe := λ S, {x // setof S x}}\n\nexample : ∀ (c:constraint α) (a:c), setof c a :=\nbegin\n  intros c a,\n  exact @subtype.property α (setof c) a\nend\n\nexample : (∀ (a : (trv α)), ff) → ∀ a:α, ff :=\nbegin\n  intros h a,\n  exact h a\nend\n\nend constraint\n</pre></div>",
        "id": 124383712,
        "sender_full_name": "Nima",
        "timestamp": 1522356750
    },
    {
        "content": "<p>what is the intuition behind all these?</p>",
        "id": 124383739,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522356826
    },
    {
        "content": "<p>Using coercion we can say every natural number is a real number. But what if we know <code>r</code> is a real number <code>2</code>. How we can use it as a natural number.</p>",
        "id": 124383794,
        "sender_full_name": "Nima",
        "timestamp": 1522356899
    },
    {
        "content": "<p>what is trv stt nst?</p>",
        "id": 124383804,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522356918
    },
    {
        "content": "<p>Constructors of <code>constraint</code>. The code defines coercion from <code>constraint  α</code> to <code>α</code>. I am trying to go back from <code>α</code> to <code>constraint α</code>.  In the second example, <code>trv α</code> is a trivial constraint that is satisfied by every element of type <code>α</code>.</p>",
        "id": 124383989,
        "sender_full_name": "Nima",
        "timestamp": 1522357092
    },
    {
        "content": "<p>btw <code>setof</code> doesn't type check</p>",
        "id": 124384111,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522357222
    },
    {
        "content": "<p>I copy pasted it from VSCode, it type checks perfectly fine.<br>\nSomeone else told me if they remove <code>bnd</code> and <code>low</code> right after <code>case stt</code> and <code>case nst</code> they can compile it as well.</p>",
        "id": 124384152,
        "sender_full_name": "Nima",
        "timestamp": 1522357322
    },
    {
        "content": "<p>right</p>",
        "id": 124384192,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522357330
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>universe u\nvariables {α : Type u} [linear_order α]\n\ninductive constraint (α:Type u)\n| trv                    : constraint\n| stt (bnd:α) (low:Prop) : constraint\n| nst (bnd:α) (low:Prop) : constraint\n\nnamespace constraint\n\ndef setof : constraint α → α → Prop :=\nbegin\n  intros c a,\n  cases c with bnd low bnd low,\n    case trv {exact true},\n    case stt {exact low ∧ bnd&lt;a ∨ ¬ low ∧ a &lt; bnd},\n    case nst {exact low ∧ bnd≤a ∨ ¬ low ∧ a ≤ bnd},\nend\n\ninstance constraint_to_sort : has_coe_to_sort (constraint α) :=\n  {S := Type u, coe := λ S, {x // setof S x}}\n\nexample : ∀ (c:constraint α) (a:c), setof c a :=\nbegin\n  intros c a,\n  exact @subtype.property α (setof c) a\nend\n\nexample : (∀ (a : (trv α)), ff) → ∀ a:α, ff :=\nbegin\n  intros h a,\n  exact h ⟨a, trivial⟩\nend\n\nend constraint\n</pre></div>",
        "id": 124384196,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522357338
    },
    {
        "content": "<p>solution ^</p>",
        "id": 124384198,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522357343
    },
    {
        "content": "<p>also, I would avoid using any tactics in definitions</p>",
        "id": 124384222,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522357390
    },
    {
        "content": "<p>Thanks, so <code>trivial</code> is basically a proof that <code>a</code> is satisfied by <code>trv α</code>. Right?</p>",
        "id": 124384230,
        "sender_full_name": "Nima",
        "timestamp": 1522357406
    },
    {
        "content": "<blockquote>\n<p>also, I would avoid using any tactics in definitions</p>\n</blockquote>\n<p>\"Fresh off the boat\", so no idea what best practices are. Just trying to survive ;)</p>",
        "id": 124384300,
        "sender_full_name": "Nima",
        "timestamp": 1522357465
    },
    {
        "content": "<p>oh, ok, sorry</p>",
        "id": 124384333,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522357541
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def setof : constraint α → α → Prop\n| (trv α)       a := true\n| (stt bnd low) a := low ∧ bnd&lt;a ∨ ¬ low ∧ a &lt; bnd\n| (nst bnd low) a := low ∧ bnd≤a ∨ ¬ low ∧ a ≤ bnd\n</pre></div>",
        "id": 124384399,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522357619
    },
    {
        "content": "<p>Cool, thanks</p>",
        "id": 124384477,
        "sender_full_name": "Nima",
        "timestamp": 1522357717
    },
    {
        "content": "<p>Is there any tactic that can push the negation inside quantifiers?<br>\nFor example <code>¬  ∀ x,∃ y, p x y</code> should become <code>∃ x,∀ y, ¬ p x y</code>.<br>\nUsing <code>classical</code> is fine.</p>",
        "id": 124387596,
        "sender_full_name": "Nima",
        "timestamp": 1522362791
    },
    {
        "content": "<p>no. use a lemma</p>",
        "id": 124388893,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522365138
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110025\">@Andrew Ashworth</span> You mean some lemma (probably two) twice. Right? I was looking for some tactic to push the negation all the way inside. Not sure how difficult it is to write such a tactic. I don't think writing a lemma is the solution, or at least I don't know how that can be done using a lemma such that one invocation of it will do the job.</p>",
        "id": 124389077,
        "sender_full_name": "Nima",
        "timestamp": 1522365577
    },
    {
        "content": "<p>i mean, literally write a lemma stating <code> ¬ ∀ x,∃ y, p x y </code> iff <code> ∃ x,∀ y, ¬ p x y </code>. Then rewrite with it.</p>",
        "id": 124389453,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522366366
    },
    {
        "content": "<p>How do I find Lean version that is running online? I am using 3.3.0 (re-downloaded 5 minutes ago) and cannot typecheck the following code from Programming in Lean (the online Lean typechecks it):</p>\n<div class=\"codehilite\"><pre><span></span>import system.io\nvariable [io.interface]\nopen nat io\n\ndef print_squares : ℕ → io unit\n| 0        := return ()\n| (succ n) := print_squares n &gt;&gt;\n              put_str (nat.to_string n ++ &quot;^2 = &quot; ++\n                       nat.to_string (n * n) ++ &quot;\\n&quot;)\n\n#eval print_squares 100\n</pre></div>",
        "id": 124394062,
        "sender_full_name": "Nima",
        "timestamp": 1522375570
    },
    {
        "content": "<p>The latest version of lean doesn't use <code>io.interface</code>. Try removing that line and the rest should work</p>",
        "id": 124394417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522376419
    },
    {
        "content": "<p>Removing that adds to error.  The current error I am receiving is <code> unknown identifier 'nat.to_string' </code>.<br>\nIf it is of any help, I am on Mac and downloaded the binary version.</p>",
        "id": 124394471,
        "sender_full_name": "Nima",
        "timestamp": 1522376563
    },
    {
        "content": "<p>Looks like it's just <code>to_string</code> now</p>",
        "id": 124395469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522378842
    },
    {
        "content": "<p>what did I just see</p>",
        "id": 124395480,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522378890
    },
    {
        "content": "<p>is Lean basically python now</p>",
        "id": 124395481,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522378895
    },
    {
        "content": "<p>i think there's room to add more handy programming gadgets once lean 4 rolls around and we can extend the parser</p>",
        "id": 124396126,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522380275
    },
    {
        "content": "<p><code>map (fun x -&gt; x * x) [0 .. 10] = [0, 1, 4, 9, 16, 25, 36, 49, 56, 64, 81, 100]</code> would be sweet</p>",
        "id": 124396196,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522380388
    },
    {
        "content": "<p>we already have list.map</p>",
        "id": 124396199,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522380400
    },
    {
        "content": "<p>you can't write <code>[0 .. 10]</code> right now</p>",
        "id": 124396203,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522380413
    },
    {
        "content": "<p>list.range</p>",
        "id": 124396204,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522380418
    },
    {
        "content": "<p>or more generally <code>[0 .. 2 .. 10]</code> where you can supply a step</p>",
        "id": 124396214,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522380446
    },
    {
        "content": "<p>aha, that's not quite so simple to declare with a <code>notation</code> command</p>",
        "id": 124396257,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522380525
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>import system.io\n\nopen nat io\n\ndef print_fib_core : ℕ → ℕ × ℕ × io unit\n| 0        := (0, 1, return ())\n| (succ n) := let (a, b, c) := print_fib_core n in\n              (b, a+b, c &gt;&gt;\n                  put_str (&quot;fib &quot; ++ to_string n ++ &quot; = &quot; ++\n                       to_string a ++ &quot;\\n&quot;))\n\ndef print_fib : ℕ → io unit :=\nλ n, (print_fib_core n).2.2\n\n#eval print_fib 100\n</pre></div>",
        "id": 124396269,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522380577
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>fib 0 = 0\nfib 1 = 1\nfib 2 = 1\nfib 3 = 2\nfib 4 = 3\nfib 5 = 5\nfib 6 = 8\nfib 7 = 13\nfib 8 = 21\nfib 9 = 34\nfib 10 = 55\n[...]\nfib 90 = 2880067194370816120\nfib 91 = 4660046610375530309\nfib 92 = 7540113804746346429\nfib 93 = 12200160415121876738\nfib 94 = 19740274219868223167\nfib 95 = 31940434634990099905\nfib 96 = 51680708854858323072\nfib 97 = 83621143489848422977\nfib 98 = 135301852344706746049\nfib 99 = 218922995834555169026\n</pre></div>",
        "id": 124396274,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522380593
    },
    {
        "content": "<p>cool, now I can do Project Euler with it</p>",
        "id": 124396276,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522380601
    },
    {
        "content": "<p>this is ridiculous</p>",
        "id": 124396325,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522380624
    },
    {
        "content": "<p>project euler in a functional language is painful, but that's probably because i don't speak monad</p>",
        "id": 124396360,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522380717
    },
    {
        "content": "<p>you only need <code>io unit</code> :P</p>",
        "id": 124396406,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522380739
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Thank you, it worked (I still need <code> variable [io.interface]</code>, but it works)</p>",
        "id": 124396431,
        "sender_full_name": "Nima",
        "timestamp": 1522380835
    },
    {
        "content": "<p>ok</p>",
        "id": 124396472,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522380849
    },
    {
        "content": "<p>I get <code> VM does not have code for 'unsafe_monad_from_pure_bind' </code> when I try to run that code</p>",
        "id": 124396942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522381874
    },
    {
        "content": "<p>which code?</p>",
        "id": 124396946,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522381891
    },
    {
        "content": "<p>your fib code</p>",
        "id": 124396991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522381994
    },
    {
        "content": "<p>what is your lean version?</p>",
        "id": 124396992,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522382006
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>Lean (version 3.3.1, commit 28f4143be31b, RELEASE)\n</pre></div>",
        "id": 124396995,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522382032
    },
    {
        "content": "<p>28f414</p>",
        "id": 124396996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522382032
    },
    {
        "content": "<p>wow</p>",
        "id": 124396998,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522382037
    },
    {
        "content": "<p>what does that mean</p>",
        "id": 124397036,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522382044
    },
    {
        "content": "<p>same as yours, evidently</p>",
        "id": 124397039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522382054
    },
    {
        "content": "<p>I can't even find<code>unsafe_monad_from_pure_bind</code> in the lean repo, it's a mystery where that comes from</p>",
        "id": 124397111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522382172
    },
    {
        "content": "<p>meh, restart and it's fine</p>",
        "id": 124397117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522382202
    },
    {
        "content": "<p>what is the intended use for bit0 and bit1?</p>",
        "id": 124397125,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522382241
    },
    {
        "content": "<p>can I use them in recursion?</p>",
        "id": 124397127,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522382245
    },
    {
        "content": "<p>Here's my version of the fib printer:</p>\n<div class=\"codehilite\"><pre><span></span>def fib_core : ℕ → ℕ × ℕ\n| 0        := (0, 1)\n| (succ n) := let (a, b) := fib_core n in (b, a+b)\n\ndef fib (n) := (fib_core n).1\n\ndef print_fib (n : ℕ) : io unit :=\n(list.range 100).mmap&#39; (λ n,\n  put_str (&quot;fib &quot; ++ to_string n ++ &quot; = &quot; ++\n    to_string (fib n) ++ &quot;\\n&quot;))\n\n#eval print_fib 100\n</pre></div>\n\n\n<p>It's asymptotically slower than Kenny's version since it recomputes <code>fib</code> rather than calculating as it goes, but this is a bit closer to what you would expect in another programming language without any fancy tricks</p>",
        "id": 124397368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522382703
    },
    {
        "content": "<p><code>bit0</code> and <code>bit1</code> are used by the parser to construct natural number literals and other number literals like <code>7</code>, which is actually <code>bit1 (bit1 (bit1 1)))</code> in whatever type (it must have typeclasses for <code>has_add</code> and <code>has_one</code>)</p>",
        "id": 124397445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522382809
    },
    {
        "content": "<p>If you want to define a function by binary recursion over <code>nat</code>, use <code>nat.binary_rec_on</code>, which uses <code>bit b n</code> which generalizes <code>bit0</code> and <code>bit1</code> with a boolean bit parameter</p>",
        "id": 124397459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522382865
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def list.update {α : Type*} : list α → list nat → α → list α\n| L []     x := L\n| L (h::t) x := (L.update t x).update_nth h x\n\nnamespace eratosthenes\n\ndef aux1 : nat → nat → nat\n| sq lo := if (lo+1)*(lo+1) &gt; sq then lo else lo+1\n\ndef isqrt : nat → nat\n| n := if H : n / 4 &lt; n then\n         (aux1 n (isqrt (n / 4) * 2))\n       else n\n\ndef aux2 : list bool → nat → nat → list bool :=\nλ L len n, L.update (list.map (λ z, (z + n) * n) (list.range $ len / n)) ff\n\ndef aux3 : list bool → nat → nat → list bool\n| L len 0     := L\n| L len 1     := L\n| L len (n+1) := aux2 (aux3 L len n) len (n+1)\n\ndef aux4 : nat → list bool :=\nλ n, aux3 (list.repeat tt n) n (isqrt n)\n\ndef aux5 : list bool → nat → list nat :=\nλ L n, (list.range n).filter $ λ z, L.nth z = tt\n\nend eratosthenes\n\ndef eratosthenes : nat → list nat :=\nλ n, (eratosthenes.aux5 (eratosthenes.aux4 n) n).drop 2\n\n#eval eratosthenes 1000\n</pre></div>",
        "id": 124397505,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522382943
    },
    {
        "content": "<p>why is this so slow</p>",
        "id": 124397508,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522382946
    },
    {
        "content": "<p>geez, name your stuff better</p>",
        "id": 124397558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383045
    },
    {
        "content": "<p>well I don't intend to PR it :P</p>",
        "id": 124397560,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383063
    },
    {
        "content": "<p>it's like reading decompiled sources</p>",
        "id": 124397565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383070
    },
    {
        "content": "<p>oh, sorry</p>",
        "id": 124397566,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383082
    },
    {
        "content": "<p>aux1 is for isqrt</p>",
        "id": 124397567,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383090
    },
    {
        "content": "<p>heh, sieve of e</p>",
        "id": 124397568,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522383093
    },
    {
        "content": "<p>aux2 does one sieve</p>",
        "id": 124397569,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383096
    },
    {
        "content": "<p><a href=\"https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\" target=\"_blank\" title=\"https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\">https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf</a></p>",
        "id": 124397570,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522383097
    },
    {
        "content": "<p>What's the anticipated order?</p>",
        "id": 124397571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383114
    },
    {
        "content": "<p>of what?</p>",
        "id": 124397611,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383127
    },
    {
        "content": "<p>of the code</p>",
        "id": 124397613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383130
    },
    {
        "content": "<p>it sieves sqrt(n) times</p>",
        "id": 124397615,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383141
    },
    {
        "content": "<p>each time taking n</p>",
        "id": 124397616,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383144
    },
    {
        "content": "<p>I think it's O(n^1.5) then</p>",
        "id": 124397619,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383151
    },
    {
        "content": "<p>I see several quadratic passes at least</p>",
        "id": 124397620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383161
    },
    {
        "content": "<p>where is the quadratic pass</p>",
        "id": 124397621,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383174
    },
    {
        "content": "<p><code>(list.range n).filter $ λ z, L.nth z = tt</code> passes over <code>L</code> for each <code>n</code></p>",
        "id": 124397628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383185
    },
    {
        "content": "<p>oh, how should I fix that</p>",
        "id": 124397638,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383208
    },
    {
        "content": "<p>ah, I should deconstruct the list</p>",
        "id": 124397639,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383223
    },
    {
        "content": "<p>paper i linked discusses the sieve in a functional setting exhaustively</p>",
        "id": 124397640,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522383237
    },
    {
        "content": "<p>You should put comments or something, it's not obvious what the auxes do</p>",
        "id": 124397681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383261
    },
    {
        "content": "<p>should I implement the code form your paper?</p>",
        "id": 124397689,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383319
    },
    {
        "content": "<p>i mean, if you want a functional Sieve of Eratosthenes , that is also pretty fast, yes</p>",
        "id": 124397730,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522383389
    },
    {
        "content": "<p>does it use data structures that I don't have?</p>",
        "id": 124397735,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383426
    },
    {
        "content": "<p>PriorityQ?</p>",
        "id": 124397738,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383443
    },
    {
        "content": "<p>this is getting a bit out of hand, but you could implement one from okasaki's \"purely functional data structures\"</p>",
        "id": 124397777,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522383541
    },
    {
        "content": "<p>Yeah, we don't have that, maybe <code>rb_map</code> will work</p>",
        "id": 124397780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383543
    },
    {
        "content": "<p>Beware, Okasaki assumes a <code>susp</code> type (aka memoization), but we don't have one</p>",
        "id": 124397784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383585
    },
    {
        "content": "<p>hm. then i'd use the red-black tree in lean core for everything</p>",
        "id": 124397828,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522383652
    },
    {
        "content": "<p>You actually could make your original code a lot faster simply by using arrays instead of lists. You are using them like arrays anyway</p>",
        "id": 124397833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383679
    },
    {
        "content": "<p>and that will make <code>L.nth</code> asymptotically fast</p>",
        "id": 124397834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383712
    },
    {
        "content": "<p>I've never used array :P</p>",
        "id": 124397874,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383728
    },
    {
        "content": "<p>I don't even know arrays exist</p>",
        "id": 124397875,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522383734
    },
    {
        "content": "<p><code>array</code> is like <code>vector</code>, it's a list with a fixed (in the type) size</p>",
        "id": 124397896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383839
    },
    {
        "content": "<p>and importantly, it's implemented as an C++ array, meaning that updates and nth are fast</p>",
        "id": 124397938,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522383871
    },
    {
        "content": "<p>can I trace the function calls? i.e. debugging?</p>",
        "id": 124397993,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522384027
    },
    {
        "content": "<p>is vector a dynamically growing array under the hood?</p>",
        "id": 124397996,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522384057
    },
    {
        "content": "<p>... i wonder how much work it would take to use a dynamically growing array for lean's list impl</p>",
        "id": 124398049,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522384170
    },
    {
        "content": "<p><code>vector</code> is literally just a subtype of <code>list</code>. <code>array</code> is isomorphic to <code>vector</code>, and is implemented as the <code>parray</code> type in C++, which is a C++ array with some added support for end extension and persistent usage</p>",
        "id": 124398148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522384376
    },
    {
        "content": "<p>ahh, i see</p>",
        "id": 124398220,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522384560
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def list.update {α : Type*} : list α → list nat → α → list α\n| L []     x := L\n| L (h::t) x := (L.update t x).update_nth h x\n\ndef list.extract {α : Type*} [decidable_eq α] : list α → nat → α → list nat\n| L      0     x := []\n| []     (n+1) x := []\n| (h::t) (n+1) x := if h = x then n :: t.extract n x else t.extract n x\n\nnamespace eratosthenes\n\ndef aux1 : nat → nat → nat\n| sq lo := if (lo+1)*(lo+1) &gt; sq then lo else lo+1\n\ndef isqrt : nat → nat\n| n := if H : n / 4 &lt; n then aux1 n (isqrt (n / 4) * 2) else n\n\n-- from L, make every n-th item false\ndef step : list bool → nat → nat → list bool :=\nλ L len n, L.update (list.map (λ z, (z + n) * n) (list.range $ len / n)) ff\n\n-- do &quot;step&quot; for every integer from 2 to n\ndef sieve : list bool → nat → nat → list bool\n| L len 0     := L\n| L len 1     := L\n| L len (n+1) := if L.nth (n+1) = tt then step (sieve L len n) len (n+1) else sieve L len n\n\n-- invoke sieve with sqrt(n)\ndef prime.bool : nat → list bool :=\nλ n, sieve (list.repeat tt n) n (isqrt n)\n\nend eratosthenes\n\ndef eratosthenes : nat → list nat :=\nλ n, ((eratosthenes.prime.bool n).reverse.extract n tt).reverse.drop 2\n\n#eval eratosthenes 1000\n</pre></div>",
        "id": 124398431,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522384966
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what do you think is the complexity of this?</p>",
        "id": 124398434,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522384976
    },
    {
        "content": "<p>ah, I see a quadratic pass</p>",
        "id": 124398474,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385043
    },
    {
        "content": "<p><code>L.update</code> is quadratic</p>",
        "id": 124398480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385054
    },
    {
        "content": "<p>right</p>",
        "id": 124398481,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385058
    },
    {
        "content": "<p>I think you should define <code>step</code> by recursion</p>",
        "id": 124398484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385102
    },
    {
        "content": "<p>it shouldn't be hard to make every <code>n</code>th item false by keeping an accumulator</p>",
        "id": 124398494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385126
    },
    {
        "content": "<p>You can't do <code>step</code> in less than O(n) time with this data structure, so <code>sieve</code> is necessarily O(n^2)</p>",
        "id": 124398539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385209
    },
    {
        "content": "<p>what do you mean?</p>",
        "id": 124398540,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385221
    },
    {
        "content": "<p><code>step</code> has to walk down the entire list to change stuff</p>",
        "id": 124398547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385243
    },
    {
        "content": "<p>but I only need to call step <code>sqrt(n)</code> times</p>",
        "id": 124398551,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385256
    },
    {
        "content": "<p>Ah, that's true. So n^1.5 seems likely</p>",
        "id": 124398592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385296
    },
    {
        "content": "<p>As that paper will tell you though, this isn't \"true\" eratosthenes since you have to visit all the skipped entries multiple times</p>",
        "id": 124398597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385381
    },
    {
        "content": "<p>I see</p>",
        "id": 124398599,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385395
    },
    {
        "content": "<p>well that paper is too technical</p>",
        "id": 124398639,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385407
    },
    {
        "content": "<p>it's O(n^1.5) now, empirically</p>",
        "id": 124398687,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385532
    },
    {
        "content": "<p>because I can do 10000 now</p>",
        "id": 124398688,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385535
    },
    {
        "content": "<p>(how pathetic)</p>",
        "id": 124398691,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385540
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def list.extract {α : Type*} [decidable_eq α] : list α → nat → α → list nat\n| L      0     x := []\n| []     (n+1) x := []\n| (h::t) (n+1) x := if h = x then n :: t.extract n x else t.extract n x\n\nnamespace eratosthenes\n\ndef aux1 : nat → nat → nat\n| sq lo := if (lo+1)*(lo+1) &gt; sq then lo else lo+1\n\ndef isqrt : nat → nat\n| n := if H : n / 4 &lt; n then aux1 n (isqrt (n / 4) * 2) else n\n\n-- from L, make every n-th item false\ndef step : list bool → nat → nat → list bool :=\nλ L n start, L.enum.map (λ z, if z.1 % n = 0 ∧ start ≤ z.1 then ff else z.2)\n\n-- do &quot;step&quot; for every integer from 2 to n\ndef sieve : list bool → nat →list bool\n| L 0     := L\n| L 1     := L\n| L (n+1) := if L.nth (n+1) = tt then step (sieve L n) (n+1) ((n+1)*(n+1)) else sieve L n\n\n-- invoke sieve with sqrt(n)\ndef prime.bool : nat → list bool :=\nλ n, sieve (list.repeat tt n) (isqrt n)\n\nend eratosthenes\n\ndef eratosthenes : nat → list nat :=\nλ n, ((eratosthenes.prime.bool n).reverse.extract n tt).reverse.drop 2\n\n#eval eratosthenes 10000\n</pre></div>",
        "id": 124398692,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385547
    },
    {
        "content": "<p>now I'm going to redo it</p>",
        "id": 124398695,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385569
    },
    {
        "content": "<p>i.e. use <code>list nat</code> instead of <code>list bool</code></p>",
        "id": 124398698,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385584
    },
    {
        "content": "<p>and use accumulator instead of mod</p>",
        "id": 124398701,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385590
    },
    {
        "content": "<p>well, that paper has a list based implementation on page 11</p>",
        "id": 124398704,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522385624
    },
    {
        "content": "<p>oh</p>",
        "id": 124398743,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385655
    },
    {
        "content": "<p>but, you'll need a lazy sequence type</p>",
        "id": 124398745,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522385670
    },
    {
        "content": "<p>coinduction is coming soon, I hope :)</p>",
        "id": 124398746,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385678
    },
    {
        "content": "<p>i don't know if lean supports lazy semantics right now</p>",
        "id": 124398747,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522385683
    },
    {
        "content": "<p>we already have stream</p>",
        "id": 124398749,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385691
    },
    {
        "content": "<p>but I don't know how computable it is</p>",
        "id": 124398750,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522385699
    },
    {
        "content": "<p>Seriously, use <code>array</code></p>",
        "id": 124398751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385700
    },
    {
        "content": "<p>if you care about speed, use <code>array</code></p>",
        "id": 124398757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385711
    },
    {
        "content": "<p>linked lists are known horrible in almost all cases in CS theory</p>",
        "id": 124398760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385744
    },
    {
        "content": "<p><code>stream</code> exists and is computable, but is not remotely efficient as a stream</p>",
        "id": 124398802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385794
    },
    {
        "content": "<p>the hard part about making that paper applicable in lean is all the tricks used to take advantage of laziness</p>",
        "id": 124398808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385844
    },
    {
        "content": "<p>AFAIK there are no plans to make lean lazy. You can manually add laziness using <code>thunk</code></p>",
        "id": 124398847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385903
    },
    {
        "content": "<p>yeah, it's unfortunate that the most popular pure functional language emphasizes laziness so much</p>",
        "id": 124398849,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522385919
    },
    {
        "content": "<p>it's really hard to move code snippets and ideas over</p>",
        "id": 124398853,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522385945
    },
    {
        "content": "<p>ML is a good functional strict language, but I find it often does too much impure stuff</p>",
        "id": 124398857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522385963
    },
    {
        "content": "<p>that's a benefit :)</p>",
        "id": 124398859,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522385985
    },
    {
        "content": "<p>(i use f# when i can)</p>",
        "id": 124398860,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522385995
    },
    {
        "content": "<p>In the sense that it makes it difficult to transfer ideas over</p>",
        "id": 124398899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522386006
    },
    {
        "content": "<p>i haven't tried to do much imperative programming in lean</p>",
        "id": 124398907,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522386041
    },
    {
        "content": "<p>is it hard to emulate?</p>",
        "id": 124398909,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1522386051
    },
    {
        "content": "<p>now it's much faster!</p>",
        "id": 124399059,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522386369
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>namespace eratosthenes\n\ndef aux1 : nat → nat → nat\n| sq lo := if (lo+1)*(lo+1) &gt; sq then lo else lo+1\n\ndef isqrt : nat → nat\n| n := if H : n / 4 &lt; n then aux1 n (isqrt (n / 4) * 2) else n\n\n-- from L, remove every item divisible by n\ndef step : list nat → nat → list nat\n| []     n := []\n| (h::t) n := if h%n = 0 then step t n else h::step t n\n\n-- each time : remove one element, do step on that element\ndef sieve : nat → list nat → list nat\n| hi []     := []\n| hi (h::t) := if h ≤ hi then (h::step t h) else (h::t)\n\nend eratosthenes\n\ndef eratosthenes : nat → list nat :=\nλ n, eratosthenes.sieve (eratosthenes.isqrt n) ((list.range n).drop 2)\n\n#eval eratosthenes 10000\n</pre></div>",
        "id": 124399060,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522386377
    },
    {
        "content": "<p>I think <code>step</code> can be expressed as a <code>list.filter</code> without a performance hit with this approach</p>",
        "id": 124399219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522386791
    },
    {
        "content": "<p>Isn't <code>sieve</code> recursive?</p>",
        "id": 124399222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522386833
    },
    {
        "content": "<p>yes, I just discovered the bug xd</p>",
        "id": 124399244,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522386843
    },
    {
        "content": "<p>now Lean doesn't trust that my recursion is well-founded</p>",
        "id": 124399282,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522386923
    },
    {
        "content": "<p>I can't be bothered to prove that to Lean</p>",
        "id": 124399283,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522386931
    },
    {
        "content": "<p>so, see you :P</p>",
        "id": 124399284,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522386933
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>namespace eratosthenes\n\n-- O(1)\ndef aux1 : nat → nat → nat\n| sq lo := if (lo+1)*(lo+1) &gt; sq then lo else lo+1\n\n-- O(log n)\ndef isqrt : nat → nat\n| n := if H : n / 4 &lt; n then aux1 n (isqrt (n / 4) * 2) else n\n\n-- O(n)\n-- from L, remove every item divisible by n\ndef step : list nat → nat → list nat\n| []     n := []\n| (h::t) n := if h%n = 0 then step t n else h::step t n\n\ntheorem aux (t : list nat) (h : nat) : list.sizeof (step t h) ≤ list.sizeof t :=\nbegin\n  induction t with h1 t1 ih,\n  { dsimp [step],\n    refl },\n  { dsimp [step],\n    by_cases H : h1 % h = 0,\n    { simp [H, list.sizeof],\n      apply le_trans ih,\n      apply le_trans (nat.le_add_right _ (sizeof h1)),\n      exact nat.le_add_left _ _ },\n    { simp [H, list.sizeof],\n      apply nat.add_le_add_left,\n      rw add_comm,\n      apply nat.add_le_add_right,\n      exact ih } }\nend\n\ntheorem aux2 (t : list nat) (h : nat) : has_well_founded.r (step t h) (h :: t) :=\nbegin\n  dsimp [has_well_founded.r, sizeof_measure, measure, inv_image, sizeof, has_sizeof.sizeof, list.sizeof],\n  apply lt_of_le_of_lt (aux t h),\n  apply nat.lt_add_of_pos_left,\n  rw add_comm,\n  exact nat.zero_lt_succ _\nend\n\n-- O(n^1.5)\n-- each time : remove one element, do step on that element\ndef sieve (hi : nat) : list nat → list nat\n| []     := []\n| (h::t) := if h ≤ hi then (h::(sieve $ step t h)) else (h::t)\nusing_well_founded { dec_tac := `[exact aux2 t h] }\n\nend eratosthenes\n\n-- O(n^1.5)\ndef eratosthenes : nat → list nat :=\nλ n, eratosthenes.sieve (eratosthenes.isqrt n) ((list.range n).drop 2)\n\n#eval eratosthenes 10000\n</pre></div>",
        "id": 124399694,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522387737
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I lied</p>",
        "id": 124399696,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522387740
    },
    {
        "content": "<p>If you used <code>filter</code> for <code>step</code>, the lemma would be easier</p>",
        "id": 124399751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522387857
    },
    {
        "content": "<p>btw it can handle <code>100000</code> now</p>",
        "id": 124400262,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522388994
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I don't see what difference it makes. It isn't a lemma that L.filter p has size at most L</p>",
        "id": 124400366,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522389141
    },
    {
        "content": "<p>It's a sublist from <code>filter_sublist</code>, and sublist implies length less equal</p>",
        "id": 124400386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522389202
    },
    {
        "content": "<p>so how exactly would I prove its well-foundedness?</p>",
        "id": 124400388,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522389236
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def step (L : list nat) (n : nat) : list nat :=\nL.filter (λ a, a%n ≠ 0)\n\ndef sieve (hi : nat) : list nat → list nat\n| []     := []\n| (h::t) :=\n  have (step t h).length &lt; (h :: t).length, from\n  lt_succ_of_le $ list.length_le_of_sublist $ list.filter_sublist _,\n  if h ≤ hi then h::sieve (step t h) else h::t\nusing_well_founded {\n  rel_tac := λ _ _, `[exact ⟨_, measure_wf list.length⟩],\n  dec_tac := `[exact this] }\n</pre></div>",
        "id": 124401268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522391092
    },
    {
        "content": "<p>oh, changing the relation</p>",
        "id": 124401276,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522391125
    },
    {
        "content": "<p>I see</p>",
        "id": 124401277,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522391126
    },
    {
        "content": "<p>The following is from Programming in Lean and works perfectly fine in the online Lean. Any idea how I should make it also work in version 3.3.0?</p>\n<div class=\"codehilite\"><pre><span></span>open expr tactic classical\n\nmeta def normalize_hyp (lemmas : list expr) (hyp : expr) : tactic unit :=\ndo try (simp_at hyp lemmas)\n</pre></div>",
        "id": 124436819,
        "sender_full_name": "Nima",
        "timestamp": 1522457156
    },
    {
        "content": "<p>what errors are you encountering?</p>",
        "id": 124436867,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522457237
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>sandbox3.lean:6:3: error\n\ndon&#39;t know how to synthesize placeholder\ncontext:\nlemmas : list expr,\nhyp : expr,\nnormalize_hyp : tactic unit\n⊢ Type ?\n\n\nsandbox3.lean:6:8: error\n\nunknown identifier &#39;simp_at&#39;\n</pre></div>",
        "id": 124436869,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522457253
    },
    {
        "content": "<p>Yes, those errors</p>",
        "id": 124436964,
        "sender_full_name": "Nima",
        "timestamp": 1522457435
    },
    {
        "content": "<p>Can you try <code>simp_hyp</code> instead of <code>simp_at</code>?</p>",
        "id": 124437019,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522457591
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  simp_hyp hyp\nterm\n  hyp\nhas type\n  expr\nbut is expected to have type\n  simp_lemmas\n</pre></div>",
        "id": 124437022,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522457618
    },
    {
        "content": "<p>ok, first, swap the order of the arguments: <code> simp_hyp lemmas hyp</code></p>",
        "id": 124437257,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522458129
    },
    {
        "content": "<p>second, let's construct a <code>simp_lemmas</code></p>",
        "id": 124437259,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522458146
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>meta def normalize_hyp (lemmas : list expr) (hyp : expr) : tactic unit :=\ndo s &lt;- simp_lemmas.append simp_lemmas.mk lemmas,\n   try (simp_at s hyp)\n</pre></div>",
        "id": 124437309,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522458258
    },
    {
        "content": "<p><code>simp_at</code>(<code>unknown identifier</code>)?<br>\nIf I use <code>simp_hyp</code> give me the same error</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  simp_hyp hyp\nterm\n  hyp\nhas type\n  expr\nbut is expected to have type\n  simp_lemmas\nAdditional information:\n/Users/nima/Dropbox/Codes/Lean/Interval/tmp.lean:5:8: context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message\n  type mismatch, term\n    (simp_hyp ?m_1 ?m_2 h\n       {max_steps := simp.default_max_steps,\n        contextual := ff,\n        lift_eq := tt,\n        canonize_instances := tt,\n        canonize_proofs := ff,\n        use_axioms := tt,\n        zeta := tt,\n        beta := tt,\n        eta := tt,\n        proj := tt,\n        iota := tt,\n        single_pass := ff,\n        fail_if_unchanged := tt,\n        memoize := tt})\n  has type\n    expr → tactic expr : Type\n  but is expected to have type\n    tactic ?m_1 : Type ?\n</pre></div>",
        "id": 124437406,
        "sender_full_name": "Nima",
        "timestamp": 1522458535
    },
    {
        "content": "<p>Sorry, the second version was wrong. I fixed it</p>",
        "id": 124437425,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522458603
    },
    {
        "content": "<p>Is there any lean file that I can download from github to have the fix?</p>",
        "id": 124437594,
        "sender_full_name": "Nima",
        "timestamp": 1522459000
    },
    {
        "content": "<p>I mean, this is what it should be:</p>\n<div class=\"codehilite\"><pre><span></span>meta def normalize_hyp (lemmas : list expr) (hyp : expr) : tactic unit :=\ndo s &lt;- simp_lemmas.append simp_lemmas.mk lemmas,\n   try (simp_at s hyp)\n</pre></div>",
        "id": 124437603,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522459067
    },
    {
        "content": "<p>but <code>simp_at</code> gives me <code>unknown identifier 'simp_at' </code> error</p>",
        "id": 124437655,
        "sender_full_name": "Nima",
        "timestamp": 1522459175
    },
    {
        "content": "<p>Sorry I keep making the same typo:</p>\n<div class=\"codehilite\"><pre><span></span>meta def normalize_hyp (lemmas : list expr) (hyp : expr) : tactic unit :=\ndo s &lt;- simp_lemmas.append simp_lemmas.mk lemmas,\n   try (simp_hyp s hyp)\n</pre></div>",
        "id": 124437699,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522459257
    },
    {
        "content": "<p>This gives me the following error:</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  simp_hyp s hyp\nterm\n  hyp\nhas type\n  expr\nbut is expected to have type\n  opt_param (list name) list.nil\nAdditional information:\n/Users/nima/Dropbox/Codes/Lean/Interval/tmp.lean:5:8: context: switched to simple application elaboration procedure because failed to use expected type to elaborate it, error message\n  type mismatch, term\n    (simp_hyp ?m_1 ?m_2 h\n       {max_steps := simp.default_max_steps,\n        contextual := ff,\n        lift_eq := tt,\n        canonize_instances := tt,\n        canonize_proofs := ff,\n        use_axioms := tt,\n        zeta := tt,\n        beta := tt,\n        eta := tt,\n        proj := tt,\n        iota := tt,\n        single_pass := ff,\n        fail_if_unchanged := tt,\n        memoize := tt})\n  has type\n    expr → tactic expr : Type\n  but is expected to have type\n    tactic ?m_1 : Type ?\n</pre></div>",
        "id": 124437706,
        "sender_full_name": "Nima",
        "timestamp": 1522459321
    },
    {
        "content": "<p>that's progress</p>",
        "id": 124437753,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522459405
    },
    {
        "content": "<p>How about</p>\n<div class=\"codehilite\"><pre><span></span>meta def normalize_hyp (lemmas : list expr) (hyp : expr) : tactic unit :=\ndo s &lt;- simp_lemmas.append simp_lemmas.mk lemmas,\n   try (simp_hyp s [] hyp)\n</pre></div>",
        "id": 124437795,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522459470
    },
    {
        "content": "<p>Wow! Thanks</p>",
        "id": 124437842,
        "sender_full_name": "Nima",
        "timestamp": 1522459617
    },
    {
        "content": "<p>No problems. Sorry for the excessive back and forth.</p>",
        "id": 124437851,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522459674
    },
    {
        "content": "<p>I don't see <code>simp_at</code> in the lean web editor either. Is it in 3.3.0?</p>",
        "id": 124437890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522459694
    },
    {
        "content": "<p>No problem at all.<br>\nI don't know how to check Lean version, mine is supposed to be 3.3.0.<br>\nThe same chapter gives me error. <br>\nLast line <code> unknown identifier 'monad.for''</code><br>\nIs there a magic fix for this one as well?</p>\n<blockquote>\n<p>The for' tactic, like the for tactic, applies the second argument to each element of the first, but it returns unit rather than accumulate the results in a list. </p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span>open expr tactic classical monad\n\nmeta def normalize_hyp (lemmas : list expr) (hyp : expr) : tactic unit :=\ndo s &lt;- simp_lemmas.append simp_lemmas.mk lemmas,\n   try (simp_hyp s [] hyp)\n\nmeta def normalize_hyps : tactic unit :=\ndo hyps ← local_context,\n   lemmas ← monad.mapm mk_const [``not_not_intro],\n   monad.for&#39; hyps (normalize_hyp lemmas)\n</pre></div>",
        "id": 124437950,
        "sender_full_name": "Nima",
        "timestamp": 1522459882
    },
    {
        "content": "<blockquote>\n<p>I don't see <code>simp_at</code> in the lean web editor either. Is it in 3.3.0?</p>\n</blockquote>\n<p>It disappeared in <a href=\"https://github.com/leanprover/lean/commit/69ed291aab8493a7fb33b52dc2982e2db417761f\" target=\"_blank\" title=\"https://github.com/leanprover/lean/commit/69ed291aab8493a7fb33b52dc2982e2db417761f\">https://github.com/leanprover/lean/commit/69ed291aab8493a7fb33b52dc2982e2db417761f</a><br>\nin July</p>",
        "id": 124437965,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522459922
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112062\">@Nima</span> you can check your version with <code>lean --version</code></p>",
        "id": 124437997,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522459961
    },
    {
        "content": "<p>Instead of <code> monad.for' hyps (normalize_hyp lemmas) </code> try <code>hyps.mmap' (normalize_hyp lemmas)</code></p>",
        "id": 124438043,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522460079
    },
    {
        "content": "<p>Fantastic!<br>\nThanks a lot,<br>\nAlso, my version is <code>Lean (version 3.3.0, commit fa9c868ed2bb, Release)</code></p>",
        "id": 124438094,
        "sender_full_name": "Nima",
        "timestamp": 1522460195
    },
    {
        "content": "<p>Yeah, that's exactly 3.3.0</p>",
        "id": 124438145,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522460381
    },
    {
        "content": "<p>Programming in Lean seems to be working with a pretty old version of Lean</p>",
        "id": 124438148,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522460402
    },
    {
        "content": "<p>Sorry if this is too stupid, but why the following does not type-checks (I don't care the example itself) :</p>\n<div class=\"codehilite\"><pre><span></span>universe u\nvariable {α : Type u}\nexample (p:α → Prop) : (¬(∃ (a:α), ¬ p a)) → (∀ (a:α), p a) :=\nbegin\n  intros h a,\n  have h&#39; : (p a) → p a,\n  from admit,\n  admit\nend\n</pre></div>\n\n\n<p>I get the following error at <code>have</code></p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  p a\nterm\n  a\nhas type\n  p a : Prop\nbut is expected to have type\n  α : Type u\nstate:\nα : Type u,\np : α → Prop,\nh : ¬∃ (a : α), ¬p a,\na : α\n⊢ p a\n</pre></div>\n\n\n<p>This is Tactic State right before <code>have</code></p>\n<div class=\"codehilite\"><pre><span></span>α : Type u,\np : α → Prop,\nh : ¬∃ (a : α), ¬p a,\na : α\n⊢ p a\n</pre></div>",
        "id": 124442486,
        "sender_full_name": "Nima",
        "timestamp": 1522471004
    },
    {
        "content": "<p>That's puzzling</p>",
        "id": 124442534,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522471164
    },
    {
        "content": "<p>You can't <code>from admit</code>, <code>admit</code> is a tactic not a term. Use <code>from sorry</code> or just <code>admit</code></p>",
        "id": 124442585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471312
    },
    {
        "content": "<p>Dang! I completely missed that!</p>",
        "id": 124442624,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522471340
    },
    {
        "content": "<p>But the error is actually an issue with the variable <code>a</code> together with <code>p -&gt; q</code> instead of <code>\\forall (_ : p), q</code></p>",
        "id": 124442625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471377
    },
    {
        "content": "<p>So the following change gives me the same error:</p>\n<div class=\"codehilite\"><pre><span></span>have h&#39; : (p a) → (p a),\n  admit,\n  admit\n</pre></div>",
        "id": 124442632,
        "sender_full_name": "Nima",
        "timestamp": 1522471393
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean/issues/1822\" target=\"_blank\" title=\"https://github.com/leanprover/lean/issues/1822\">https://github.com/leanprover/lean/issues/1822</a></p>",
        "id": 124442672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471468
    },
    {
        "content": "<p>Oooooooh! I had to stare a it for a while. I almost bore a whole through my monitor</p>",
        "id": 124442673,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522471498
    },
    {
        "content": "<p>You can work around the issue by writing <code>∀_:p a, p a</code> instead of <code>p a -&gt; p a</code></p>",
        "id": 124442681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471519
    },
    {
        "content": "<p>or use a variable other than <code>a</code></p>",
        "id": 124442682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471538
    },
    {
        "content": "<p>Is there any plan to change that horrible convention to name that bound variable <code>a</code>?</p>",
        "id": 124442723,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522471576
    },
    {
        "content": "<p>I think? There are two separate autonaming approaches, one produces <code>a_n</code> and the other produces <code>_x_n</code></p>",
        "id": 124442724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471618
    },
    {
        "content": "<p>The underscore trick switches to the other naming convention</p>",
        "id": 124442729,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471635
    },
    {
        "content": "<p>But it's never as simple as it seems for this stuff. See the issue</p>",
        "id": 124442731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471669
    },
    {
        "content": "<p>also <a href=\"https://github.com/leanprover/lean/pull/1844\" target=\"_blank\" title=\"https://github.com/leanprover/lean/pull/1844\">https://github.com/leanprover/lean/pull/1844</a></p>",
        "id": 124442770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471710
    },
    {
        "content": "<p>Yeah, don't I know it</p>",
        "id": 124442778,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522471764
    },
    {
        "content": "<p>Looks like Leo wanted to postpone a fix because of the new parser (sigh...)</p>",
        "id": 124442779,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471789
    },
    {
        "content": "<p>Thanks for the link</p>",
        "id": 124442780,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522471793
    },
    {
        "content": "<p>I've heard that song before :D</p>",
        "id": 124442822,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522471811
    },
    {
        "content": "<p>Here's hoping that the new parser also cures cancer :D</p>",
        "id": 124442823,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522471830
    },
    {
        "content": "<p>but don't bother with any medicine or chemotherapy in the meantime</p>",
        "id": 124442824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471862
    },
    {
        "content": "<p>oh, what does double colon mean? as in, <code>{x : : p a}</code> something like that</p>",
        "id": 124442829,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522471889
    },
    {
        "content": "<p>that's malformed</p>",
        "id": 124442830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471898
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/mathlib/pull/88#discussion_r178095763\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/pull/88#discussion_r178095763\">https://github.com/leanprover/mathlib/pull/88#discussion_r178095763</a></p>",
        "id": 124442869,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522471931
    },
    {
        "content": "<blockquote>\n<p>what about <code>def next.fixed_point {x : : α} (H : x ≤ f x) : fixed_point</code> (in similar for previous) then you can shorten some proofs below.</p>\n</blockquote>",
        "id": 124442871,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522471945
    },
    {
        "content": "<p>looks like a typo</p>",
        "id": 124442872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522471946
    },
    {
        "content": "<p>oh</p>",
        "id": 124442874,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522471950
    },
    {
        "content": "<blockquote>\n<p>But the error is actually an issue with the ...</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I only understood that part, but it worked. So thank you  :)</p>",
        "id": 124443018,
        "sender_full_name": "Nima",
        "timestamp": 1522472339
    },
    {
        "content": "<p>Basically, <code>have h' : (p a) → p a,</code> is the same as <code>have h' : ∀ a : p a, p a,</code> so the first <code>a</code> has type <code> α</code> and the second one has type <code>p a</code></p>",
        "id": 124443076,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522472514
    },
    {
        "content": "<p>Thanks for the clarification,<br>\nSome of the discussion on those links were about how Lean should choose name of the bounded variable in <code>∀ a : p ...</code>. Right? (I mean is it always <code>a</code> or starts with <code>a</code>, so if I don't start names with <code>a</code> then I will never see this problem again?)</p>",
        "id": 124443709,
        "sender_full_name": "Nima",
        "timestamp": 1522474102
    },
    {
        "content": "<p>Yes. Ideally it should be chosen to be distinct from the variables on the RHS, but for some reason this is complicated, so it just uses a name generator and you the user are responsible for not choosing the same name. You should beware of naming your variables <code>a</code>, <code>a_1</code>, <code>a_2</code> etc. as well as <code>_x</code>, <code>_x_1</code>, <code>_x_2</code> etc. Also <code>_inst</code> and <code>_match</code> and other underscore names are taken, so you should avoid starting your variables with an underscore.</p>",
        "id": 124443809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522474407
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>has type\n  α → α → Prop : Type u\nbut is expected to have type\n  α → α → Type ? : Type (max u (?+1))\n</pre></div>",
        "id": 124447155,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522482969
    },
    {
        "content": "<p>is Prop not a type?</p>",
        "id": 124447156,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522482971
    },
    {
        "content": "<p>btw <code>plift</code> seems to have resolved the error</p>",
        "id": 124447161,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483024
    },
    {
        "content": "<p>Prop is a Type, but Prop is not Type</p>",
        "id": 124447207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522483145
    },
    {
        "content": "<p>Prop is Type 0, no?</p>",
        "id": 124447211,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483158
    },
    {
        "content": "<p>Prop is Sort 0, Type u is Sort (u+1)</p>",
        "id": 124447214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522483172
    },
    {
        "content": "<p>oh</p>",
        "id": 124447215,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483178
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>don&#39;t know how to synthesize placeholder\ncontext:\nα : Type u,\n_inst_1 : partial_order α,\nx y : α,\nhxy : plift (x ≤ y)\n⊢ {down := le_trans (hxy.down) ({down := le_refl y}.down)} = hxy\n</pre></div>",
        "id": 124447258,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483246
    },
    {
        "content": "<p>proof irrelevance after plift...?</p>",
        "id": 124447262,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483255
    },
    {
        "content": "<p>you have to case on <code>hxy</code> first</p>",
        "id": 124447269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522483306
    },
    {
        "content": "<p>or rewrite with <code>plift.up_down</code></p>",
        "id": 124447308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522483334
    },
    {
        "content": "<p><code>congr_arg plift.up rfl</code> works</p>",
        "id": 124447315,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483407
    },
    {
        "content": "<p>after casing</p>",
        "id": 124447316,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483418
    },
    {
        "content": "<p><code> λ x y ⟨hxy⟩, congr_arg plift.up rfl</code></p>",
        "id": 124447317,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483426
    },
    {
        "content": "<p>but <code>rfl</code> doesn't?</p>",
        "id": 124447318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522483431
    },
    {
        "content": "<p>I'm stupid</p>",
        "id": 124447354,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483443
    },
    {
        "content": "<p>it does</p>",
        "id": 124447355,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483443
    },
    {
        "content": "<p>interesting</p>",
        "id": 124447362,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483470
    },
    {
        "content": "<p>it goes assertion error without the casing</p>",
        "id": 124447363,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483474
    },
    {
        "content": "<p>but I've been getting too many assertion errors I decided to stop caring</p>",
        "id": 124447364,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483488
    },
    {
        "content": "<p>hm, that's not a place I've seen an assertion error before</p>",
        "id": 124447372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522483524
    },
    {
        "content": "<p>is there polymorphic empty type?</p>",
        "id": 124447461,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483799
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def empty : category empty :=\n{ Mor := empty.rec _,\n  Comp := empty.rec _,\n  Id := empty.rec _,\n  Hid_left := empty.rec _,\n  Hid_right := empty.rec _,\n  Hassoc := empty.rec _ }\n</pre></div>",
        "id": 124447507,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483902
    },
    {
        "content": "<p>lol</p>",
        "id": 124447508,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483903
    },
    {
        "content": "<p>Surprisingly no. You can use <code>ulift empty</code> in a pinch</p>",
        "id": 124447548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522483976
    },
    {
        "content": "<p>and yes, I'm doing category theory again</p>",
        "id": 124447555,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522483994
    },
    {
        "content": "<p><code>λ x y z, unit.cases_on z rfl</code></p>",
        "id": 124447600,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522484117
    },
    {
        "content": "<p>is there a way to case on <code>z</code> in the lambda part?</p>",
        "id": 124447601,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522484124
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def one : category unit :=\n{ Mor := λ _ _, unit,\n  Comp := λ _ _ _ _ _, unit.star,\n  Id := λ _, unit.star,\n  Hid_left := λ _ _, unit.rec rfl,\n  Hid_right := λ _ _, unit.rec rfl,\n  Hassoc := λ _ _ _ _ _ _ _, rfl }\n</pre></div>",
        "id": 124447641,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522484188
    },
    {
        "content": "<p>you can write <code>()</code> in the lambda I think, or <code>⟨⟩</code></p>",
        "id": 124447688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522484307
    },
    {
        "content": "<p>the latter works</p>",
        "id": 124447693,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522484348
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def of_monoid (α : Type u) [monoid α] : category unit :=\n{ Mor := λ _ _, α,\n  Comp := λ _ _ _, (*),\n  Id := λ _, 1,\n  Hid_left := λ _ _, one_mul,\n  Hid_right := λ _ _, mul_one,\n  Hassoc := λ _ _ _ _, mul_assoc }\n</pre></div>",
        "id": 124447782,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522484569
    },
    {
        "content": "<p>how beautifully the structures are compatible</p>",
        "id": 124447783,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522484577
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def of_monoid (α : Type u) [monoid α] : category unit :=\n{ Mor := λ _ _, α,\n  Comp := λ _ _ _, (*),\n  Id := λ _, 1,\n  Hid_left := λ _ _, one_mul,\n  Hid_right := λ _ _, mul_one,\n  Hassoc := λ _ _ _ _, mul_assoc }\n\ndef to_monoid (C: category unit) : monoid (C.Mor () ()) :=\n{ mul := C.Comp _ _ _,\n  mul_assoc := C.Hassoc () () () (),\n  one := C.Id (),\n  one_mul := C.Hid_left () (),\n  mul_one := C.Hid_right () () }\n</pre></div>",
        "id": 124447841,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522484759
    },
    {
        "content": "<p>this is very beautiful</p>",
        "id": 124447878,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522484763
    },
    {
        "content": "<p>I think you can do better in that last one... in any category, the homs from an object to itself forms a monoid</p>",
        "id": 124447888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522484870
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def to_monoid {α : Type u} (C: category α) (x : α) : monoid (C.Mor x x) :=\n{ mul := C.Comp _ _ _,\n  mul_assoc := C.Hassoc x x x x,\n  one := C.Id x,\n  one_mul := C.Hid_left x x,\n  mul_one := C.Hid_right x x }\n</pre></div>",
        "id": 124447931,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522484948
    },
    {
        "content": "<p>done</p>",
        "id": 124447932,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522484949
    },
    {
        "content": "<p>I just realized the forgetful functor and its adjoint exists in Cat</p>",
        "id": 124447974,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485018
    },
    {
        "content": "<p>now <code>one</code> is a special case of <code>discrete</code></p>",
        "id": 124448020,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485126
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def discrete (α : Type u) : category α :=\n{ Mor := λ _ _, unit,\n  Comp := λ _ _ _ _ _, (),\n  Id := λ _, (),\n  Hid_left := λ _ _ ⟨⟩, rfl,\n  Hid_right := λ _ _ ⟨⟩, rfl,\n  Hassoc := λ _ _ _ _ _ _ _, rfl }\n\ndef one : category unit :=\ndiscrete unit\n</pre></div>",
        "id": 124448021,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485148
    },
    {
        "content": "<p>ok technically zero also, but...</p>",
        "id": 124448022,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485161
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def discrete (α : Type u) : category α :=\n{ Mor := λ _ _, unit,\n  Comp := λ _ _ _ _ _, (),\n  Id := λ _, (),\n  Hid_left := λ _ _ ⟨⟩, rfl,\n  Hid_right := λ _ _ ⟨⟩, rfl,\n  Hassoc := λ _ _ _ _ _ _ _, rfl }\n\ndef zero : category empty :=\ndiscrete empty\n\ndef one : category unit :=\ndiscrete unit\n</pre></div>",
        "id": 124448023,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485181
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  how would you call the category <code>* -&gt; *</code> and the category <code>* =&gt; *</code>?</p>",
        "id": 124448158,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485557
    },
    {
        "content": "<p>(one arrow, two arrows)</p>",
        "id": 124448159,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485562
    },
    {
        "content": "<p>what do they mean?</p>",
        "id": 124448161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522485584
    },
    {
        "content": "<p>the former is the category with 2 objects and 3 morphisms</p>",
        "id": 124448162,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485595
    },
    {
        "content": "<p>that's <code>two</code></p>",
        "id": 124448202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522485614
    },
    {
        "content": "<p>and the latter is with 4 morphisms</p>",
        "id": 124448203,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485621
    },
    {
        "content": "<p><code>two'</code>? <code>two_eq</code> (since it's the equalizer diagram)</p>",
        "id": 124448205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522485650
    },
    {
        "content": "<p>so it doesn't have a name in convention?</p>",
        "id": 124448210,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485669
    },
    {
        "content": "<p>I've never seen it have an official name</p>",
        "id": 124448212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522485687
    },
    {
        "content": "<p>yes, I meant official. words.</p>",
        "id": 124448213,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485700
    },
    {
        "content": "<p>maybe <code>equalizer_diagram</code> lol</p>",
        "id": 124448250,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485724
    },
    {
        "content": "<p>Alternatively <code>two_mor</code> since it's the canonical two morphism diagram</p>",
        "id": 124448259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522485792
    },
    {
        "content": "<p>what do you mean?</p>",
        "id": 124448260,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485807
    },
    {
        "content": "<p>and how are you going to name the pullback diagram</p>",
        "id": 124448261,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485829
    },
    {
        "content": "<p><code>three_in</code> and <code>three_out</code>?</p>",
        "id": 124448300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522485856
    },
    {
        "content": "<p>hmm</p>",
        "id": 124448301,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485863
    },
    {
        "content": "<p>ok</p>",
        "id": 124448302,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485868
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def Mor : bool → bool → Type\n| ff ff := unit\n| ff tt := bool\n| tt ff := empty\n| tt tt := unit\n</pre></div>",
        "id": 124448348,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485976
    },
    {
        "content": "<p>do you want to switch <code>bool</code> and <code>empty</code>?</p>",
        "id": 124448349,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522485981
    },
    {
        "content": "<p>Hm, that seems a bit painful to work with</p>",
        "id": 124448398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522486175
    },
    {
        "content": "<p>how would you do it?</p>",
        "id": 124448400,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522486199
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def Mor : bool → bool → Type\n| ff ff := unit\n| ff tt := bool\n| tt ff := empty\n| tt tt := unit\n\ndef Comp : Π x y z : bool, Mor y z → Mor x y → Mor x z\n| ff ff ff _ g := g\n| ff ff tt f _ := f\n| ff tt tt _ g := g\n| tt tt tt _ _ := ()\n</pre></div>",
        "id": 124448441,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522486207
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>inductive Mor : bool → bool → Type\n| id : ∀ b, Mor b b\n| par : bool → Mor ff tt\n</pre></div>",
        "id": 124448446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522486260
    },
    {
        "content": "<p>heh...</p>",
        "id": 124448452,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522486271
    },
    {
        "content": "<p>what does <code>par</code> stand for?</p>",
        "id": 124448454,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522486284
    },
    {
        "content": "<p>parallel</p>",
        "id": 124448455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522486289
    },
    {
        "content": "<p>making up names is hard...</p>",
        "id": 124448456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522486299
    },
    {
        "content": "<p>eu entendo</p>",
        "id": 124448496,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522486332
    },
    {
        "content": "<p>It might be worth generalizing this example to a whole bouquet of parallel arrows indexed by <code>A</code></p>",
        "id": 124448540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522486448
    },
    {
        "content": "<p>fair enough</p>",
        "id": 124448542,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522486458
    },
    {
        "content": "<p>would you like to do the hard job of naming it for me</p>",
        "id": 124448543,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522486467
    },
    {
        "content": "<p><code>par</code> :)</p>",
        "id": 124448544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522486475
    },
    {
        "content": "<p>wonderful</p>",
        "id": 124448545,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522486482
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>inductive Mor : bool → bool → Type\n| id : ∀ b, Mor b b\n| par : bool → Mor ff tt\n\ndef Comp : Π x y z : bool, Mor y z → Mor x y → Mor x z\n| ff ff _  f _ := f\n| _  tt tt _ g := g\n</pre></div>",
        "id": 124448546,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522486502
    },
    {
        "content": "<p>two cases!</p>",
        "id": 124448549,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522486504
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>namespace par\n\nvariable α : Type u\n\ninductive Mor : bool → bool → Type u\n| id : ∀ b, Mor b b\n| par : α → Mor ff tt\n\ndef Comp : Π x y z, Mor α y z → Mor α x y → Mor α x z\n| ff ff _  f _ := f\n| _  tt tt _ g := g\n\ndef Hid_left : ∀ x y f, Comp α x y y (Mor.id α y) f = f\n| ff ff (Mor.id α b) := rfl\n| ff tt _ := rfl\n| tt tt (Mor.id α b) := rfl\n\ndef Hid_right : ∀ x y f, Comp α x x y f (Mor.id α x) = f\n| ff ff (Mor.id α b) := rfl\n| ff tt _ := rfl\n| tt tt (Mor.id α b) := rfl\n\ndef Hassoc : ∀ x y z w f g h, Comp α x y w (Comp α y z w f g) h = Comp α x z w f (Comp α x y z g h)\n| ff ff _  _  _ _ _ := rfl\n| ff tt tt tt _ _ _ := rfl\n| tt tt tt tt _ _ _ := rfl\n\nend par\n\ndef par (α : Type u) : category bool :=\n{ Mor := par.Mor α,\n  Comp := par.Comp α,\n  Id := par.Mor.id α,\n  Hid_left := par.Hid_left α,\n  Hid_right := par.Hid_right α,\n  Hassoc := par.Hassoc α }\n\ndef two_mor : category bool :=\npar bool\n</pre></div>",
        "id": 124448782,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487076
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> do you see any possible golf on the casings?</p>",
        "id": 124448783,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487098
    },
    {
        "content": "<p>I sometimes use secondary cases when a bunch of cases are the same; there isn't too much of that in this example but you could write <code>Hassoc</code> as</p>\n<div class=\"codehilite\"><pre><span></span>def Hassoc : ∀ x y z w f g h, Comp α x y w (Comp α y z w f g) h = Comp α x z w f (Comp α x y z g h)\n| ff ff _  _  _ _ _ := rfl\n| b tt tt tt _ _ _ := by cases b; refl\n</pre></div>",
        "id": 124448833,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522487266
    },
    {
        "content": "<p>well...</p>",
        "id": 124448872,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487287
    },
    {
        "content": "<p>that tactic was |unnecessary|</p>",
        "id": 124448874,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487301
    },
    {
        "content": "<p>The advantage really shows itself when you need to deal with a wildcard case which abbreviates five identical cases with five identical proofs</p>",
        "id": 124448879,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522487347
    },
    {
        "content": "<p>I see</p>",
        "id": 124448880,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487368
    },
    {
        "content": "<p>it doesn't make the generated proof any shorter, but it's a slightly neater arrangement</p>",
        "id": 124448921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522487413
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>structure category (α : Type u) : Type (max u v + 1) :=\n(Mor : Π x y : α, Type v)\n(Comp : Π x y z, Mor y z → Mor x y → Mor x z)\n(Id : Π x, Mor x x)\n(Hid_left : ∀ x y (f : Mor x y), Comp _ _ _ (Id _) f = f)\n(Hid_right : ∀ x y (f : Mor x y), Comp _ _ _ f (Id _) = f)\n(Hassoc : ∀ x y z w (f : Mor z w) (g : Mor y z) (h : Mor x y), Comp _ _ _ (Comp _ _ _ f g) h = Comp _ _ _ f (Comp _ _ _ g h))\n</pre></div>",
        "id": 124448922,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487440
    },
    {
        "content": "<p>I run into type problem when I try to define a cone</p>",
        "id": 124448923,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487451
    },
    {
        "content": "<p>namely, option</p>",
        "id": 124448924,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487457
    },
    {
        "content": "<p>the problem is the type of the morphism...</p>",
        "id": 124448929,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487470
    },
    {
        "content": "<p>I was thinking about doing the same for the <code>Mor.id</code> cases in <code>Hid_left</code> and such but you need the cases there so that the <code>ff tt</code> case works</p>",
        "id": 124448930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522487474
    },
    {
        "content": "<p>wait</p>",
        "id": 124448973,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487540
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def Mor : option α → option α → Type u_1\n| none none := punit\n| none (some y) := punit\n| (some x) none := ulift empty\n| (some x) (some y) := C.Mor x y\n</pre></div>",
        "id": 124448974,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487544
    },
    {
        "content": "<p>how the hell does this work</p>",
        "id": 124448975,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487547
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>variables {α : Type u} (C : category α)\n</pre></div>",
        "id": 124448977,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487555
    },
    {
        "content": "<p>what's the problem?</p>",
        "id": 124448978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522487557
    },
    {
        "content": "<p>this is amazing</p>",
        "id": 124448979,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487557
    },
    {
        "content": "<p>I never defined <code>u_1</code></p>",
        "id": 124448980,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487561
    },
    {
        "content": "<p>it comes with <code>C</code>, but I never gave it a name</p>",
        "id": 124448982,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487568
    },
    {
        "content": "<p>yeah, it's a really thin abstraction</p>",
        "id": 124448987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522487592
    },
    {
        "content": "<p>how does it work</p>",
        "id": 124448988,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487599
    },
    {
        "content": "<p>also why <code>variables A B : Sort*</code> doesn't work</p>",
        "id": 124448990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522487609
    },
    {
        "content": "<p>it's unprecedented, the ability to have an unnamed name</p>",
        "id": 124448991,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487622
    },
    {
        "content": "<p>Whenever you have a free universe variable in a <code>variable</code> declaration, it adds a <code>universe u_n</code> definition to the file and uses that</p>",
        "id": 124449030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522487655
    },
    {
        "content": "<p>it's not magically named or a metavariable or anything</p>",
        "id": 124449031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522487672
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>inductive Mor : option α → option α → Type (max u u_1)\n| id : ∀ y, Mor none y\n| mor : ∀ x y (f : C.Mor x y), Mor (some x) (some y)\n</pre></div>",
        "id": 124449049,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487731
    },
    {
        "content": "<p>why do I need <code>max</code> here but not that one?</p>",
        "id": 124449050,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487737
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def Mor : option α → option α → Type u_1\n| none none := punit\n| none (some y) := punit\n| (some x) none := ulift empty\n| (some x) (some y) := C.Mor x y\n</pre></div>",
        "id": 124449052,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487757
    },
    {
        "content": "<p>I don't recommend using <code>u_1</code>, you should name your variables</p>",
        "id": 124449108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522487860
    },
    {
        "content": "<p>how would I do that?</p>",
        "id": 124449109,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487869
    },
    {
        "content": "<p><code>universes u v</code>?</p>",
        "id": 124449111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522487879
    },
    {
        "content": "<p>no...</p>",
        "id": 124449150,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487888
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>structure category (α : Type u) : Type (max u v + 1) :=\n(Mor : Π x y : α, Type v)\n(Comp : Π x y z, Mor y z → Mor x y → Mor x z)\n(Id : Π x, Mor x x)\n(Hid_left : ∀ x y (f : Mor x y), Comp _ _ _ (Id _) f = f)\n(Hid_right : ∀ x y (f : Mor x y), Comp _ _ _ f (Id _) = f)\n(Hassoc : ∀ x y z w (f : Mor z w) (g : Mor y z) (h : Mor x y), Comp _ _ _ (Comp _ _ _ f g) h = Comp _ _ _ f (Comp _ _ _ g h))\n</pre></div>",
        "id": 124449153,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487903
    },
    {
        "content": "<p>I can't name it</p>",
        "id": 124449154,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487905
    },
    {
        "content": "<p>it comes with the <code>Mor</code> of the category variable</p>",
        "id": 124449155,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487912
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>variables {α : Type u} (C : category α)\n</pre></div>",
        "id": 124449156,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487924
    },
    {
        "content": "<p>You can write universe arguments of a constant explicitly with <code>category.{u v}</code></p>",
        "id": 124449157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522487940
    },
    {
        "content": "<p>oh worked</p>",
        "id": 124449162,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522487956
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>inductive Mor : option α → option α → Type (max u v)\n| id : ∀ y, Mor none y\n| mor : ∀ x y (f : C.Mor x y), Mor x y\n</pre></div>",
        "id": 124449215,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488079
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> the name <code>id</code> is morally wrong; how would you name it?</p>",
        "id": 124449216,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488087
    },
    {
        "content": "<p>maybe <code>proj</code></p>",
        "id": 124449217,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488096
    },
    {
        "content": "<p>you should use <code>some</code> instead of the coercion</p>",
        "id": 124449258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522488153
    },
    {
        "content": "<p>like you were before</p>",
        "id": 124449259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522488159
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>inductive Mor : option α → option α → Type (max u v)\n| proj : ∀ y, Mor none y\n| mor : ∀ x y (f : C.Mor x y), Mor (some x) (some y)\n</pre></div>",
        "id": 124449262,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488184
    },
    {
        "content": "<p>this?</p>",
        "id": 124449263,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488185
    },
    {
        "content": "<p>komu eesu?</p>",
        "id": 124449266,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488192
    },
    {
        "content": "<p>maybe just <code>none_le</code> or something like that?</p>",
        "id": 124449267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522488196
    },
    {
        "content": "<p>i don't like thinking it in a poset-manner</p>",
        "id": 124449268,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488207
    },
    {
        "content": "<p>about</p>",
        "id": 124449269,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488211
    },
    {
        "content": "<p>I think this one should be defined with a <code>def</code>; that will fix the universe <code>max</code> thing</p>",
        "id": 124449314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522488327
    },
    {
        "content": "<p>what do you mean by \"fix\", is it a bug?</p>",
        "id": 124449315,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488348
    },
    {
        "content": "<p>The problem is that lean isn't smart enough to notice that the <code>∀ y</code> in proj only fills out one morphism per type in the family</p>",
        "id": 124449355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522488395
    },
    {
        "content": "<p>If you just try to push it all in a single inductive type, it overestimates the best universe</p>",
        "id": 124449360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522488459
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def Mor : option α → option α → Type v\n| none none := punit\n| none (some y) := punit\n| (some x) none := ulift empty\n| (some x) (some y) := C.Mor x y\n\ndef Comp : Π x y z, Mor C y z → Mor C x y → Mor C x z\n| none none _ f _ := f\n| none _ (some z) _ _ := punit.star\n| (some x) (some y) (some z) f g := C.Comp x y z f g\n</pre></div>",
        "id": 124449489,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488777
    },
    {
        "content": "<p>the sky is blue again</p>",
        "id": 124449490,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488779
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what next, are you going to tell me that you can generalize <code>option</code> to <code>sum</code></p>",
        "id": 124449496,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488818
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def Mor : option α → option α → Type v\n| none     y        := punit\n| _        none     := ulift empty\n| (some x) (some y) := C.Mor x y\n</pre></div>",
        "id": 124449536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522488850
    },
    {
        "content": "<p>ok thanks</p>",
        "id": 124449537,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488874
    },
    {
        "content": "<p>ok it's really 3 equations</p>",
        "id": 124449543,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522488918
    },
    {
        "content": "<p>You can generalize option to sum, there are two interesting structures there - disjoint union and union where the left objects have morphisms to the right</p>",
        "id": 124449544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522488927
    },
    {
        "content": "<p>but <code>option</code> is nicer to use than <code>sum punit</code></p>",
        "id": 124449586,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522488981
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def Mor : option α → option α → Type v\n| none y := punit\n| (some x) none := ulift empty\n| (some x) (some y) := C.Mor x y\n\n/-\n._eqn_1 : ∀ {α : Type u} (C : category α) (y : option α), Mor C none y = punit\n._eqn_2 : ∀ {α : Type u} (C : category α) (x : α), Mor C (some x) none = ulift empty\n._eqn_3 : ∀ {α : Type u} (C : category α) (x y : α), Mor C (some x) (some y) = C.Mor x y\n-/\n\ndef Mor : option α → option α → Type v\n| none y := punit\n| _ none := ulift empty\n| (some x) (some y) := C.Mor x y\n\n/-\n._eqn_1 : ∀ {α : Type u} (C : category α), Mor C none none = punit\n._eqn_2 : ∀ {α : Type u} (C : category α) (val : α), Mor C none (some val) = punit\n._eqn_3 : ∀ {α : Type u} (C : category α) (val : α), Mor C (some val) none = ulift empty\n._eqn_4 : ∀ {α : Type u} (C : category α) (x y : α), Mor C (some x) (some y) = C.Mor x y\n-/\n</pre></div>",
        "id": 124449587,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489016
    },
    {
        "content": "<p>por que pasa isso</p>",
        "id": 124449592,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489031
    },
    {
        "content": "<p>ok I know why I'm just exclaiming</p>",
        "id": 124449594,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489048
    },
    {
        "content": "<p>¡</p>",
        "id": 124449633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522489105
    },
    {
        "content": "<p>pojish einteindeh si eu falu assii?</p>",
        "id": 124449678,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489209
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 124449685,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489283
    },
    {
        "content": "<p>your portuguese is getting harder to read</p>",
        "id": 124449722,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522489325
    },
    {
        "content": "<p>:P</p>",
        "id": 124449725,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489333
    },
    {
        "content": "<p>\"podes entender se eu falo assim\"</p>",
        "id": 124449727,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489339
    },
    {
        "content": "<p>I think Nima had a similar issue the other day</p>",
        "id": 124449736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522489419
    },
    {
        "content": "<p>not understanding my portuguese?</p>",
        "id": 124449737,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489432
    },
    {
        "content": "<p>something about the order of case splits causing superfluous splitting</p>",
        "id": 124449774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522489444
    },
    {
        "content": "<p>oh</p>",
        "id": 124449778,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489454
    },
    {
        "content": "<p>I could do disjoint union</p>",
        "id": 124449780,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489488
    },
    {
        "content": "<p>but I don't think there's this notion in the category theory community?</p>",
        "id": 124449782,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489498
    },
    {
        "content": "<p>Have you coordinated with Scott?</p>",
        "id": 124449789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522489511
    },
    {
        "content": "<p>I mean, it is probably some universal objects in the category of categories</p>",
        "id": 124449790,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489515
    },
    {
        "content": "<p>no</p>",
        "id": 124449791,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489516
    },
    {
        "content": "<p>The disjoint union is certainly the coproduct in Cat</p>",
        "id": 124449792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522489544
    },
    {
        "content": "<p>aha</p>",
        "id": 124449793,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489552
    },
    {
        "content": "<p>is there a shorthand for <code>punit.star</code>?</p>",
        "id": 124449876,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522489712
    },
    {
        "content": "<p>why does <code>#check  Type  1000000</code> crash?</p>",
        "id": 124450072,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522490266
    },
    {
        "content": "<p>no, although you could open <code>punit</code></p>",
        "id": 124450073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522490271
    },
    {
        "content": "<p>lol stop breaking lean</p>",
        "id": 124450110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522490284
    },
    {
        "content": "<p>I mean, it should be just a construct</p>",
        "id": 124450113,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522490292
    },
    {
        "content": "<p>unless you're telling me that it creates an array with a million entries</p>",
        "id": 124450114,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522490303
    },
    {
        "content": "<p>but most of them should be just empty?</p>",
        "id": 124450115,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522490307
    },
    {
        "content": "<p>I think it does something by recursion a million times and busts the stack</p>",
        "id": 124450116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1522490335
    },
    {
        "content": "<p>hmm</p>",
        "id": 124450118,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522490342
    },
    {
        "content": "<p>Is there a general construction that abstracts \"from set to pointed set\"?</p>",
        "id": 124450123,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522490389
    },
    {
        "content": "<p>oh, it's just the coslice category isn't it</p>",
        "id": 124450186,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522490522
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def Cat : category Σ α : Type u, category.{u v} α :=\n{ Mor := λ C D, functor C.2 D.2,\n  Comp := λ C D E, functor.comp C.2 D.2 E.2,\n  Id := λ C, functor.id C.2,\n  Hid_left := λ C D F, by cases F; refl,\n  Hid_right := λ C D F, by cases F; refl,\n  Hassoc := λ _ _ _ _ _ _ _, rfl, }\n</pre></div>",
        "id": 124451065,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522492697
    },
    {
        "content": "<p>my life is now complete</p>",
        "id": 124451066,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522492700
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>def comma {α : Type u} (C : category.{u v} α)\n  {β : Type u₁} (D : category.{u₁ v₁} β)\n  {γ : Type u₂} (E : category.{u₂ v₂} γ)\n  (F : functor C E) (G : functor D E) :\n  category Σ c d, E.Mor (F.F c) (G.F d) :=\n{ Mor := λ x y, { P : C.Mor x.1 y.1 × D.Mor x.2.1 y.2.1 //\n      E.Comp (F.F x.1) (F.F y.1) (G.F y.2.1) y.2.2 (F.mor x.1 y.1 P.1)\n    = E.Comp (F.F x.1) (G.F x.2.1) (G.F y.2.1) (G.mor x.2.1 y.2.1 P.2) x.2.2 },\n  Comp := λ x y z P Q, ⟨(C.Comp x.1 y.1 z.1 P.1.1 Q.1.1, D.Comp x.2.1 y.2.1 z.2.1 P.1.2 Q.1.2),\n    by rw [← F.Hcomp, ← G.Hcomp, E.Hassoc, ← Q.2, ← E.Hassoc, P.2, E.Hassoc]⟩,\n  Id := λ x, ⟨(C.Id x.1, D.Id x.2.1), by rw [F.Hid, G.Hid, E.Hid_left, E.Hid_right]⟩,\n  Hid_left := λ x y P, subtype.eq $ by dsimp; rw [C.Hid_left, D.Hid_left]; cases P.1; refl,\n  Hid_right := λ x y P, subtype.eq $ by dsimp; rw [C.Hid_right, D.Hid_right]; cases P.1; refl,\n  Hassoc := λ x y z w P Q R, subtype.eq $ by dsimp; rw [C.Hassoc, D.Hassoc] }\n</pre></div>\n\n\n<p>Now I can have pointed sets :P</p>",
        "id": 124452180,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522495482
    },
    {
        "content": "<p>How do we pass arguments to meta definition?<br>\nThe following does not typecheck</p>\n<div class=\"codehilite\"><pre><span></span>universe u\nopen tactic monad expr classical\n\nmeta def inst {α: Type u} (p:α → Prop) (h:∀ (n:α), p n) (a:α) : tactic unit :=\ndo skip\n\nexample {α:Type u} (b:α) (p:α → Prop) : (∀ (a:α), p a) → p b :=\nbegin\n  intro h,\n  have h&#39; : p b, from h b, -- I want the next line have does the same thing\n  inst p h b, -- error: unknown identifier &#39;p&#39; &#39;h&#39; &#39;b&#39;\nend\n</pre></div>\n\n\n<p>Tactic State:</p>\n<div class=\"codehilite\"><pre><span></span>α : Type u,\nb : α,\np : α → Prop,\nh : ∀ (a : α), p a,\nh&#39; : p b\n⊢ p b\n</pre></div>",
        "id": 124464151,
        "sender_full_name": "Nima",
        "timestamp": 1522525283
    },
    {
        "content": "<p>I believe there exists a tactic for what you're trying to do. I'm still going to assume that you want an answer to the question you actually asked</p>",
        "id": 124464196,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522525404
    },
    {
        "content": "<p>I don't know such tactic, but sure, I would like to know an answer to what I asked.</p>",
        "id": 124464258,
        "sender_full_name": "Nima",
        "timestamp": 1522525554
    },
    {
        "content": "<p>It is called <code>specialize</code>. It is pretty nice. </p>\n<p>Let's put your tactic in its section because we need to open a bunch of namespaces:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">section</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span> <span class=\"n\">interactive</span> <span class=\"n\">interactive</span><span class=\"bp\">.</span><span class=\"n\">types</span> <span class=\"n\">lean</span><span class=\"bp\">.</span><span class=\"n\">parser</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">inst</span> <span class=\"o\">(</span><span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">texpr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">texpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">trace</span> <span class=\"n\">fa</span><span class=\"o\">,</span>\n   <span class=\"n\">trace</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 124464348,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522525723
    },
    {
        "content": "<p>When you're given information to a tactic, you're basically giving them syntactic objects and you need provide a way for Lean to parse it. That's because you can invent a lot of different notations for your tactics.</p>",
        "id": 124464361,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522525793
    },
    {
        "content": "<p>When I write <code>inst h b</code>, I still get the same error(?)</p>",
        "id": 124464414,
        "sender_full_name": "Nima",
        "timestamp": 1522525918
    },
    {
        "content": "<p>I'm not sure it will solve anything but let's see if it does. Add the following between your tactic and your lemma:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">run_cmd</span> <span class=\"n\">add_interactive</span> <span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">inst</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 124464460,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522526025
    },
    {
        "content": "<p>Instead of the previous error, this gives me  error <code>expression expected </code>, error is below <code>b</code> in <code>inst h b</code></p>",
        "id": 124464516,
        "sender_full_name": "Nima",
        "timestamp": 1522526140
    },
    {
        "content": "<p>Also, is there anyway I can use <code>specialize</code> on a <strong>goal</strong>  like <code>∃ (b : α), p b</code></p>",
        "id": 124464668,
        "sender_full_name": "Nima",
        "timestamp": 1522526431
    },
    {
        "content": "<p>To your second question: no, you need <code>existsi</code> and you feel it your witness or a list of witnesses</p>",
        "id": 124464676,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522526475
    },
    {
        "content": "<p>What if you erase <code>b</code> in <code>inst h b</code>?</p>",
        "id": 124464723,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522526546
    },
    {
        "content": "<p>Here is the status:</p>\n<div class=\"codehilite\"><pre><span></span>universe u\n\nsection\nopen tactic interactive interactive.types lean.parser\nmeta def inst (fa : parse texpr) (x : parse texpr) : tactic unit :=\ndo trace fa,\n   trace x\nend\nrun_cmd add_interactive [`inst]\n\nexample {α:Type u} (b:α) (p:α → Prop) : (∀ (a:α), p a) → p b :=\nbegin\n  intro h,\n  inst h,  -- error: expression expected\n  admit\nend\n</pre></div>",
        "id": 124464777,
        "sender_full_name": "Nima",
        "timestamp": 1522526666
    },
    {
        "content": "<p>Ok, I get it. Sorry it took me a while. Lean seems <code>h b</code> as one expression in <code>inst h b</code> so we need a separator</p>",
        "id": 124464788,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522526733
    },
    {
        "content": "<p>We could require the user to enter <code>inst (h, b)</code>, how does that look to you?</p>",
        "id": 124464829,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522526775
    },
    {
        "content": "<p>Fine by me, but does that mean we should change definition of <code>inst</code>? (right now I am getting the same error)</p>",
        "id": 124464839,
        "sender_full_name": "Nima",
        "timestamp": 1522526847
    },
    {
        "content": "<p>In that case, you'd define your tactic as:</p>\n<div class=\"codehilite\"><pre><span></span>meta def inst (fa : parse $ tk &quot;(&quot; *&gt; texpr &lt;* tk &quot;,&quot;)\n              (x : parse $ texpr &lt;* tk &quot;)&quot;) : tactic unit :=\ndo trace fa,\n   trace x\n\nend\n</pre></div>",
        "id": 124464843,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522526859
    },
    {
        "content": "<p>wow! this is scary</p>",
        "id": 124464845,
        "sender_full_name": "Nima",
        "timestamp": 1522526878
    },
    {
        "content": "<p><code>tk</code> and <code>texpr</code> are commands for the parser: literally \"parse a parenthesis\" and \"parse an expression\"</p>",
        "id": 124464886,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522526934
    },
    {
        "content": "<p><code>&lt;*</code> and <code>*&gt;</code> is just to get them to be executed one after the other. <code>a &lt;* b</code> runs <code>a</code> first, then <code>b</code> and returns whatever <code>a</code> returns. <code>a *&gt; b</code> runs <code>a</code> first as well and then runs <code>b</code> and returns the result of <code>b</code></p>",
        "id": 124464934,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522527013
    },
    {
        "content": "<p>I see, and <code>$</code> ?</p>",
        "id": 124464941,
        "sender_full_name": "Nima",
        "timestamp": 1522527095
    },
    {
        "content": "<p>It's a way of making function application nicer by using fewer parentheses. If you'd write <code>f (g (h x))</code> instead you can write <code>f $ g $ h x</code></p>",
        "id": 124464990,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522527191
    },
    {
        "content": "<p>So, instead of <code> parse $ tk \"(\" *&gt; texpr &lt;* tk \",\" </code>, one could write:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">parse</span>\n   <span class=\"o\">(</span><span class=\"n\">do</span> <span class=\"n\">tk</span> <span class=\"s2\">&quot;(&quot;</span><span class=\"o\">,</span>\n       <span class=\"n\">e</span> <span class=\"err\">←</span> <span class=\"n\">texpr</span><span class=\"o\">,</span>\n       <span class=\"n\">tk</span> <span class=\"s2\">&quot;,&quot;</span><span class=\"o\">,</span>\n       <span class=\"n\">return</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 124465039,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522527289
    },
    {
        "content": "<p>We can only use <code>$</code> in meta world. Right?<br>\nThe following gives me error</p>\n<div class=\"codehilite\"><pre><span></span>def f (n:ℕ) := n+1\nexample : f $ f $ 1 = 3 := sorry\n</pre></div>\n\n\n<p>Error is:</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  f (1 = 3)\nterm\n  1 = 3\nhas type\n  Prop\nbut is expected to have type\n  ℕ\n</pre></div>",
        "id": 124465047,
        "sender_full_name": "Nima",
        "timestamp": 1522527317
    },
    {
        "content": "<p>No actually, it works everywhere. The problem with your expression is <code>f $ f 1</code> is of type <code>ℕ </code> but you're using it to specify the type of <code>example</code> it should have type <code>Sort u</code></p>",
        "id": 124465095,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522527421
    },
    {
        "content": "<p>Now the problem is precedence: <code>$</code> has lower precedence than <code>=</code> and Lean reads your expression as <code>f (f (1 = 3))</code></p>",
        "id": 124465142,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522527490
    },
    {
        "content": "<p>Nice, thanks a lot,<br>\nAlso, <code>existsi</code> you mentioned worked as a charm.</p>",
        "id": 124465144,
        "sender_full_name": "Nima",
        "timestamp": 1522527534
    },
    {
        "content": "<p><code>$</code> won't make your expression nicer but if you applied <code>f</code> once more, you could write <code>f (f $ f 1) = 3</code> where you use <code>(</code> and <code>)</code> to \"protect\" <code>=</code> from <code>$</code>, in a sense</p>",
        "id": 124465151,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522527576
    },
    {
        "content": "<p>I see, it is good to have an alternative to parenthesis</p>",
        "id": 124465245,
        "sender_full_name": "Nima",
        "timestamp": 1522527752
    },
    {
        "content": "<p>to be fair I would then do <code>example : (f ∘ f ∘ f) 1 = 4 := sorry</code> :)</p>",
        "id": 124465259,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1522527790
    },
    {
        "content": "<p>it's an eternal Haskell bikeshed as to how to mix parens, composition, flip and low priority application :P</p>",
        "id": 124465306,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1522527865
    },
    {
        "content": "<p>I agree on second point, not on first. I prefer <code> f ∘ f ∘ f $ 1</code> if we're going to use <code>∘</code> to avoid parenthesis ... but in this case, it doesn't help</p>",
        "id": 124465522,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1522528423
    },
    {
        "content": "<p>oh, you're absolutely right in this regard, it doesn't avoid the parens :)</p>",
        "id": 124465562,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1522528453
    },
    {
        "content": "<p>in general I do prefer composition over anything else tho</p>",
        "id": 124465563,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1522528468
    },
    {
        "content": "<p>I know <code>exact fact p</code> finishes the proof, but how can I break it into the following two steps:<br>\n1. add <code>fact</code> to my set of hypotheses (named <code>fa</code>)<br>\n2. use <code>fa</code> to finish the proof</p>\n<div class=\"codehilite\"><pre><span></span>constant fact : ∀ (p:Prop), ¬p\nexample (p:Prop) : ¬p :=\nbegin\n  exact fact p\nend\n</pre></div>\n\n\n<p>Also, I used <code>constant</code> to define an axiom. Is this the usual method?</p>",
        "id": 124784334,
        "sender_full_name": "Nima",
        "timestamp": 1523157267
    },
    {
        "content": "<p>we don't usually use <code>constant/axiom</code></p>",
        "id": 124784341,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523157308
    },
    {
        "content": "<p><code>have fa := fact, exact fa p</code></p>",
        "id": 124784342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523157326
    },
    {
        "content": "<p>The usual method is not to add axioms at all. Usually it suffices to use <code>variable</code> instead, which adds the \"axiom\" as a precondition of the theorem</p>",
        "id": 124784382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523157373
    },
    {
        "content": "<p>You can also use <code>apply fa</code> instead of <code>exact fa p</code> to finish the proof</p>",
        "id": 124784383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523157422
    },
    {
        "content": "<p>as a useless and obvious remark, your axiom is inconsistent:</p>",
        "id": 124784427,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523157515
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>constant fact : ∀ (p:Prop), ¬p\nexample : false :=\nbegin\n  apply fact (fact = fact),\n  exact rfl\nend\n</pre></div>",
        "id": 124784428,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523157517
    },
    {
        "content": "<p>If I have many axioms, isn't it going to be a problem?<br>\nSuppose I define a lot of axioms to use in a project.<br>\nBut I am sure I am not going to use all of them in all of theorems.<br>\nIsn't it considered a problem that I see all of them in my proof status?</p>",
        "id": 124784429,
        "sender_full_name": "Nima",
        "timestamp": 1523157536
    },
    {
        "content": "<p>what are your axioms?</p>",
        "id": 124784434,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523157552
    },
    {
        "content": "<p>One way to manage a large collection of axioms is to bundle them all in a typeclass like <code>field A</code></p>",
        "id": 124784480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523157609
    },
    {
        "content": "<p>If you use <code>variable</code> to declare your axioms, only the ones you actually use in a given theorem will be added as preconditions to the theorem</p>",
        "id": 124784487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523157669
    },
    {
        "content": "<blockquote>\n<p>If you use <code>variable</code> to declare your axioms, only the ones you actually use in a given theorem will be added as preconditions to the theorem</p>\n</blockquote>\n<p>So in that case, what is the difference between constant and variable?</p>",
        "id": 124784530,
        "sender_full_name": "Nima",
        "timestamp": 1523157770
    },
    {
        "content": "<p><code>constant</code> is global, in the sense that it is true once and for all</p>",
        "id": 124784578,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523157882
    },
    {
        "content": "<p>whereas, e.g. <code>example : P -&gt; Q := sorry</code> is the same as</p>\n<div class=\"codehilite\"><pre><span></span>variable (h : P)\nexample : Q := sorry\n</pre></div>",
        "id": 124784587,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523157919
    },
    {
        "content": "<p><code>variable</code> is more like a local assumption</p>",
        "id": 124784588,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523157942
    },
    {
        "content": "<p>I have not written any large collection of axioms, I am thinking of a <code>C++</code> type with a lot of constraints.<br>\nIf all these constraints are satisfied then the operations that I will define on this type make sense.<br>\nSo how should I define all type constraints so I can easily use them later? (obviously I am going to have more than one type)</p>",
        "id": 124784629,
        "sender_full_name": "Nima",
        "timestamp": 1523157971
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>class module (α : out_param $ Type u) (β : Type v) [out_param $ ring α]\n  extends has_scalar α β, add_comm_group β :=\n(smul_add : ∀r (x y : β), r • (x + y) = r • x + r • y)\n(add_smul : ∀r s (x : β), (r + s) • x = r • x + s • x)\n(mul_smul : ∀r s (x : β), (r * s) • x = r • s • x)\n(one_smul : ∀x : β, (1 : α) • x = x)\n</pre></div>",
        "id": 124784640,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523158031
    },
    {
        "content": "<p>make it a structure / class</p>",
        "id": 124784641,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523158041
    },
    {
        "content": "<p>A <code>constant</code> / <code>axiom</code> (they're the same) is like you gained knowledge for free. With <code>variables</code>, <code>class</code> and <code>structure</code>, you get to assume certain properties but whatever you assume eventually has to be proved.</p>",
        "id": 124784749,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523158254
    },
    {
        "content": "<p>If you have <code>variable h : false</code>, you can prove any theorem statement you want but using that theorem will be much more demanding. If you have <code>constant h : false</code>, you'll be able to prove all the theorems that you want and you'll never have to \"pay\" for such a strong assumption. That means that you may be building a bunch of nonsense. Especially if you have two or more axioms and you don't realize that they contradict each other</p>",
        "id": 124784821,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523158409
    },
    {
        "content": "<p>(actually, I can't think of a use for a theorem that assumes false (with <code>variable</code>), it's probably useless but also harmless)</p>",
        "id": 124784910,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523158597
    },
    {
        "content": "<p>you can never prove false, so you can never use that theorem</p>",
        "id": 124784913,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523158613
    },
    {
        "content": "<p>oh wait</p>",
        "id": 124784914,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523158620
    },
    {
        "content": "<p>So would you finish this example (if I use <code>constant</code> then I can do it):</p>\n<div class=\"codehilite\"><pre><span></span>variable h : false\nexample : ∀ (p:Prop), ¬ p :=  sorry\n</pre></div>",
        "id": 124784918,
        "sender_full_name": "Nima",
        "timestamp": 1523158625
    },
    {
        "content": "<p>that theorem is exactly <code>false.elim</code></p>",
        "id": 124784919,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523158625
    },
    {
        "content": "<p>I use <code>false.elim</code> all the time...</p>",
        "id": 124784922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523158626
    },
    {
        "content": "<p><code>false.elim h</code></p>",
        "id": 124784923,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523158642
    },
    {
        "content": "<blockquote>\n<p>I use <code>false.elim</code> all the time...</p>\n</blockquote>\n<p>Yes, me too but you only need one of those</p>",
        "id": 124784924,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523158664
    },
    {
        "content": "<p>What is true is that you don't really need anything other than <code>false.elim</code> in an inconsistent context</p>",
        "id": 124784961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523158685
    },
    {
        "content": "<p>I see, thanks</p>",
        "id": 124784964,
        "sender_full_name": "Nima",
        "timestamp": 1523158697
    },
    {
        "content": "<p>since it's like <code>sorry</code>, it's the best theorem</p>",
        "id": 124784965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523158697
    },
    {
        "content": "<p>You can also write <code>h.elim</code> if <code>h : false</code> btw</p>",
        "id": 124784972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523158786
    },
    {
        "content": "<p>When I wasn't using <code>class</code>, I defined a constant for an operator and then define notation for it. How can I do the same for class?</p>\n<div class=\"codehilite\"><pre><span></span>universe u\nclass number(α : Type u) [linear_order α] :=\n(neg₀ : α     → option α)\n\nprefix `-₀`:40 := neg₀ -- won&#39;t type check\n</pre></div>",
        "id": 124785013,
        "sender_full_name": "Nima",
        "timestamp": 1523158830
    },
    {
        "content": "<p><code>number.neg_o</code></p>",
        "id": 124785015,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523158842
    },
    {
        "content": "<p>not sure what you're trying to do though</p>",
        "id": 124785021,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523158894
    },
    {
        "content": "<p>neg maps alpha to option alpha?</p>",
        "id": 124785022,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523158899
    },
    {
        "content": "<p>optional negation, I assume</p>",
        "id": 124785023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523158910
    },
    {
        "content": "<p>something like <code>nat.ppred</code>?</p>",
        "id": 124785024,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523158920
    },
    {
        "content": "<p>Excellent,<br>\nSuppose I have a value of type <code>int</code> (in <code>C++</code>). Just because negation is defined it does not mean that I can take negation of every value. So I defined it to be something like this!</p>",
        "id": 124785063,
        "sender_full_name": "Nima",
        "timestamp": 1523158961
    },
    {
        "content": "<p>but shouldn't that not be a field</p>",
        "id": 124785065,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523158963
    },
    {
        "content": "<p>I mean, you don't want to permit any map from alpha to option alpha</p>",
        "id": 124785066,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523158983
    },
    {
        "content": "<p>Who said anything about it being a field?</p>",
        "id": 124785071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523159000
    },
    {
        "content": "<p>by field I mean a field of the class</p>",
        "id": 124785072,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159010
    },
    {
        "content": "<p>i.e. the things after <code>:=</code></p>",
        "id": 124785073,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159016
    },
    {
        "content": "<p>what's wrong with specifying a negation operation like this?</p>",
        "id": 124785074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523159038
    },
    {
        "content": "<p>oh</p>",
        "id": 124785113,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159083
    },
    {
        "content": "<p>I thought it's like making int from nat</p>",
        "id": 124785114,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159092
    },
    {
        "content": "<p>misinterpreted</p>",
        "id": 124785115,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159096
    },
    {
        "content": "<p>Section 6.6 of Theorem Proving in Lean says</p>\n<blockquote>\n<p>They can also include subscripts, which can be entered by typing <code>\\_</code> followed by the desired subscripted character</p>\n</blockquote>\n<p>I can only use single digits as subscript in VS Code. Am I missing something?</p>",
        "id": 124785258,
        "sender_full_name": "Nima",
        "timestamp": 1523159426
    },
    {
        "content": "<p><code>\\_m\\_g</code></p>",
        "id": 124785259,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159440
    },
    {
        "content": "<p>you need to do it twice</p>",
        "id": 124785260,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159444
    },
    {
        "content": "<p>I type <code>m</code> then <code>\\</code> then <code>_</code> them <code>m</code> then <code>\\</code> then <code>_</code> then <code>g</code>then space <br>\nI got: <code>m</code> followed by a box followed by a dash followed by <code>g</code></p>",
        "id": 124785311,
        "sender_full_name": "Nima",
        "timestamp": 1523159638
    },
    {
        "content": "<p><code>\\_m \\_g </code></p>",
        "id": 124785350,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159656
    },
    {
        "content": "<p>space after <code>m</code></p>",
        "id": 124785351,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159663
    },
    {
        "content": "<p>I typed <code>m</code> then <code>\\</code> then <code>_</code> them <code>m</code> then space then <code>\\</code> then <code>_</code> then <code>g</code>then space  <br>\nI got: <code>m</code> followed by a box followed by a space followed by dash followed by <code>g</code></p>",
        "id": 124785358,
        "sender_full_name": "Nima",
        "timestamp": 1523159729
    },
    {
        "content": "<p>maybe <code>m</code> doesn't work then</p>",
        "id": 124785399,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159796
    },
    {
        "content": "<p><code>\\_r \\_g</code></p>",
        "id": 124785400,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159799
    },
    {
        "content": "<p>not every letter has subscript</p>",
        "id": 124785401,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159803
    },
    {
        "content": "<p>the point being, make each letter separately</p>",
        "id": 124785408,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523159826
    },
    {
        "content": "<p>Thank, <code>r</code> worked</p>",
        "id": 124785448,
        "sender_full_name": "Nima",
        "timestamp": 1523159931
    },
    {
        "content": "<p>Would you let me know why the following won't type check</p>\n<div class=\"codehilite\"><pre><span></span>universe u\nclass number(α : Type u) [linear_order α] :=\n(neg₀ : α     → option α)\nprefix `-₀`:40 := number.neg₀\nexample (α : Type u) [linear_order α] : ∀ (n:number α), (-₀ n) = (neg₀ n) := sorry\n</pre></div>",
        "id": 124785544,
        "sender_full_name": "Nima",
        "timestamp": 1523160138
    },
    {
        "content": "<p><code>number.neg_0 n</code></p>",
        "id": 124785546,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523160162
    },
    {
        "content": "<p>or <code>n.neg_0</code></p>",
        "id": 124785547,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523160172
    },
    {
        "content": "<p>oops!<br>\nWhen I defined everything in terms of a class, then type of my operators don't make any sense</p>",
        "id": 124785599,
        "sender_full_name": "Nima",
        "timestamp": 1523160305
    },
    {
        "content": "<p>how so?</p>",
        "id": 124785603,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523160316
    },
    {
        "content": "<p>Ok, here is two errors I still receive</p>\n<div class=\"codehilite\"><pre><span></span>failed to synthesize type class instance for\nα : Type u,\n_inst_1 : linear_order α,\nn : number α\n⊢ linear_order (number α)\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span>invalid field notation, function &#39;number.neg₀&#39; does not have explicit argument with type (number ...)\n</pre></div>",
        "id": 124785644,
        "sender_full_name": "Nima",
        "timestamp": 1523160383
    },
    {
        "content": "<p>right\\</p>",
        "id": 124785645,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523160400
    },
    {
        "content": "<p>aha</p>",
        "id": 124785646,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523160407
    },
    {
        "content": "<p>you should have <code>[number \\alpha]</code></p>",
        "id": 124785647,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523160419
    },
    {
        "content": "<p>and then <code>\\forall n:\\alpha, -\\_o n = number.neg\\_o n</code></p>",
        "id": 124785654,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523160443
    },
    {
        "content": "<p>but I would use <code>extends</code>:</p>\n<div class=\"codehilite\"><pre><span></span>universe u\n\nclass number (α : Type u) extends linear_order α :=\n(neg₀ : α → option α)\n\nprefix `-₀`:40 := number.neg₀\n\nexample (α : Type u) [number α] : ∀ (n:α), (-₀ n) = (number.neg₀ n) := λ _, rfl\n</pre></div>",
        "id": 124785696,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523160509
    },
    {
        "content": "<p>When going from an OO-ish language (like C++) to a functional language (like Lean and Haskell), one pitfall is that <code>class</code> don't mean the same thing anymore. In C++, a class defines a type while in Lean, a class is a sort of packet of information that can be inferred about your types</p>",
        "id": 124785697,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523160530
    },
    {
        "content": "<p>Thanks, without <code>[linear_order α]</code> --&gt; <code>extends linear_order α</code> it would not type checked</p>",
        "id": 124785789,
        "sender_full_name": "Nima",
        "timestamp": 1523160729
    },
    {
        "content": "<p>there's a way to do it without <code>extends</code>:</p>\n<div class=\"codehilite\"><pre><span></span>universe u\n\nclass number (α : Type u) [linear_order α] :=\n(neg₀ : α → option α)\n\nprefix `-₀`:40 := number.neg₀\n\nexample (α : Type u) [linear_order α] [number α] : ∀ (n:α), (-₀ n) = (number.neg₀ n) := λ _, rfl\n</pre></div>",
        "id": 124785790,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523160762
    },
    {
        "content": "<p>but I prefer the version with <code>extends</code></p>",
        "id": 124785792,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523160779
    },
    {
        "content": "<p>Also, can I do something so instead of <code> _inst_1 : number α </code> I will get something like <code>hn : number α</code>?</p>",
        "id": 124785807,
        "sender_full_name": "Nima",
        "timestamp": 1523160839
    },
    {
        "content": "<p>if you want to do that, you can, but you should also make it a structure</p>",
        "id": 124785847,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523160862
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>universe u\n\nclass number (α : Type u) [linear_order α] :=\n(neg₀ : α → option α)\n\nprefix `-₀`:40 := number.neg₀\n\nexample (α : Type u) [linear_order α] [hn : number α] : ∀ (n:α), (-₀ n) = (number.neg₀ n) := λ _, rfl\n</pre></div>",
        "id": 124785851,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523160903
    },
    {
        "content": "<p>Awesome, thank you</p>",
        "id": 124785895,
        "sender_full_name": "Nima",
        "timestamp": 1523160984
    },
    {
        "content": "<p>Sorry if it is too obvious, but how do you finish this example:</p>\n<div class=\"codehilite\"><pre><span></span>universe u\nclass  number(α : Type u) extends linear_order α := unit\nexample (α : Type u) [nn:number α] (a:α) (b:α) : (a&lt;b) → (a≤ b) := sorry\n</pre></div>",
        "id": 124786746,
        "sender_full_name": "Nima",
        "timestamp": 1523163177
    },
    {
        "content": "<p><code>le_of_lt</code></p>",
        "id": 124786752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523163203
    },
    {
        "content": "<p><code>and.left</code> :-)</p>",
        "id": 124786753,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523163212
    },
    {
        "content": "<p>eww</p>",
        "id": 124786755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523163217
    },
    {
        "content": "<p>actually that won't work now that I come to think of it</p>",
        "id": 124786756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523163240
    },
    {
        "content": "<p>Thanks, but I was thinking of how I can directly use <code>preorder.lt</code>?<br>\nWhen I say <code>have hh:=nn.lt</code> all I get is <code> hh : α → α → Prop </code>. But <code>preorder.lt</code> is defined to be <code> (lt := λ a b, a ≤ b ∧ ¬ b ≤ a) </code></p>",
        "id": 124786805,
        "sender_full_name": "Nima",
        "timestamp": 1523163335
    },
    {
        "content": "<p>use <code>let</code> instead of <code>have</code></p>",
        "id": 124786844,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523163366
    },
    {
        "content": "<p><code>have</code> forgets definitions</p>",
        "id": 124786845,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523163371
    },
    {
        "content": "<p>This was also kenny's mistake - <code>preorder.lt</code> is not defined as that</p>",
        "id": 124786846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523163372
    },
    {
        "content": "<p>that's only the default value</p>",
        "id": 124786847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523163380
    },
    {
        "content": "<p>there is a second field that says that <code>preorder.lt</code> is equivalent to that, from which <code>le_of_lt</code> is proven</p>",
        "id": 124786850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523163411
    },
    {
        "content": "<p>Perhaps you are oversimplifying your problem, but <code>le_of_lt</code> is certainly the way to solve the original question</p>",
        "id": 124786896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523163489
    },
    {
        "content": "<p>sure, I am trying to see how I can directly use all those properties defined for a class.<br>\nI used <code>let hh := nn.lt</code> and got <code> hh : α → α → Prop := linear_order.lt </code>.<br>\nWhy does it say <code>linear_order</code> and not <code>preorder</code>?</p>\n<div class=\"codehilite\"><pre><span></span>class preorder (α : Type u) extends has_le α, has_lt α :=\n(le_refl : ∀ a : α, a ≤ a)\n(le_trans : ∀ a b c : α, a ≤ b → b ≤ c → a ≤ c)\n(lt := λ a b, a ≤ b ∧ ¬ b ≤ a)\n(lt_iff_le_not_le : ∀ a b : α, a &lt; b ↔ (a ≤ b ∧ ¬ b ≤ a) . order_laws_tac)\n\nclass partial_order (α : Type u) extends preorder α :=\n(le_antisymm : ∀ a b : α, a ≤ b → b ≤ a → a = b)\n\nclass linear_order (α : Type u) extends partial_order α :=\n(le_total : ∀ a b : α, a ≤ b ∨ b ≤ a)\n</pre></div>",
        "id": 124786999,
        "sender_full_name": "Nima",
        "timestamp": 1523163816
    },
    {
        "content": "<p><code>linear_order.lt</code> extracts the <code>lt</code> field of a <code>linear_order</code>. It is defined in terms of <code>preorder.lt</code>, just composing with the parent structure conversions</p>",
        "id": 124787296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523164551
    },
    {
        "content": "<p>When <code>lt_iff_le_not_le</code> is defined for <code>preorder</code>, why do we need a lemma with same name for <code>preorder</code>?</p>",
        "id": 124787337,
        "sender_full_name": "Nima",
        "timestamp": 1523164611
    },
    {
        "content": "<p>If you know <code> number α</code>, then you can write <code>number.lt a b</code> where <code>a b : α</code> (you don't need to refer to <code>nn</code>) and it will refer to the <code>lt</code> field inherited from <code>preorder</code></p>",
        "id": 124787343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523164656
    },
    {
        "content": "<p>The lemmas of a structure are often restated as separate theorems in order to get the notations and implicitness of arguments right</p>",
        "id": 124787383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523164712
    },
    {
        "content": "<p>so for instance you can write <code>a &lt; b</code> where <code>a b : α</code> and it will find the <code>number</code> instance and work it back to the <code>preorder</code> that supplies the implementation of <code>&lt;</code></p>",
        "id": 124787393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523164793
    },
    {
        "content": "<p>but this is not the same term as <code>number.lt a b</code> (it is definitionally equal), which can affect rewrites and things</p>",
        "id": 124787434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523164830
    },
    {
        "content": "<p><code>let hh := number.lt a b</code> gives me error: <code> unknown identifier 'number.lt' </code></p>",
        "id": 124787435,
        "sender_full_name": "Nima",
        "timestamp": 1523164830
    },
    {
        "content": "<p>The new structure command doesn't create <code>number.lt</code> type fields, it just has parent structure fields</p>",
        "id": 124787444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523164868
    },
    {
        "content": "<p>the preferred way to refer to it is <code>a &lt; b</code> of course</p>",
        "id": 124787446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523164911
    },
    {
        "content": "<p>but should be able to write <code>preorder.lt a b</code> or <code>linear_order.lt a b</code>.. they are all the same, definitionally</p>",
        "id": 124787486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523164979
    },
    {
        "content": "<p>I have no problem with <code>a&lt;b</code>. My problem is that I still don't know how to finish this example (how do I expand definition <code>nn.lt</code> or  <code>preorder.lt a b</code>,  I failed to do it using <code>rw</code>)? I don't care about the full proof, just how do I bring definition or the lemma itself into my hypotheses?</p>\n<div class=\"codehilite\"><pre><span></span>universe u\nclass number(α : Type u) extends linear_order α := unit\nexample (α : Type u) [nn:number α] (a:α) (b:α) : (a&lt;b) → (a≤ b) :=\nbegin\n  intro less,\n  let hh := nn.lt,\n  admit\nend\n</pre></div>",
        "id": 124787575,
        "sender_full_name": "Nima",
        "timestamp": 1523165219
    },
    {
        "content": "<p>The relevant lemma is <code>lt_iff_le_not_le</code>, which you can refer to directly by <code>preorder.lt_iff_le_not_le</code> or through the restated version (which uses notation for le and lt). So the proof would be something like <code>(preorder.lt_iff_le_not_le _ _).1 less</code></p>",
        "id": 124787720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523165576
    },
    {
        "content": "<p>Again, <code>nn.lt</code> <em>is not a definition</em>, despite the <code>:=</code>. It is a default value for a field, which is allowed to be anything. The reason we know it is in fact equivalent to that default value is because of <code>lt_iff_le_not_le</code>.</p>",
        "id": 124787762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523165645
    },
    {
        "content": "<blockquote>\n<p>Again, <code>nn.lt</code> <em>is not a definition</em>, despite t...</p>\n</blockquote>\n<p>Very helpful, thank you.<br>\nHow can I  expand/replace <code> ≤ </code> to/with <code> preorder.le </code>?</p>",
        "id": 124788049,
        "sender_full_name": "Nima",
        "timestamp": 1523166411
    },
    {
        "content": "<p><code>dsimp [( ≤ )]</code></p>",
        "id": 124788056,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523166433
    },
    {
        "content": "<p>Nice</p>",
        "id": 124788059,
        "sender_full_name": "Nima",
        "timestamp": 1523166459
    },
    {
        "content": "<p>How should I write the <code>match</code> so the whole thing will type-check?</p>\n<div class=\"codehilite\"><pre><span></span>universe u\nclass number(α : Type u) extends linear_order α :=\n(min : option α)\n(min_prop : match min with\n            | none := true -- some predicate\n            | sime m := true -- some predicate\n            end)\n</pre></div>",
        "id": 124802900,
        "sender_full_name": "Nima",
        "timestamp": 1523203798
    },
    {
        "content": "<p>Some not sime</p>",
        "id": 124802998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523203938
    },
    {
        "content": "<p>still does not typecheck</p>",
        "id": 124802999,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523203946
    },
    {
        "content": "<p>And brackets round some m</p>",
        "id": 124803001,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523203955
    },
    {
        "content": "<p>That should do it</p>",
        "id": 124803003,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523203961
    },
    {
        "content": "<p>nope</p>",
        "id": 124803004,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523203973
    },
    {
        "content": "<p>I don't think you can do funny things inside that particular position</p>",
        "id": 124803007,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523203983
    },
    {
        "content": "<p>Then we need the big guns to save us</p>",
        "id": 124803012,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523204015
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>universe u\nclass number(α : Type u) extends linear_order α :=\n(min : option α)\n(min_prop : match min with\n            | none := true -- some predicate\n            | (some m) := true -- some predicate\n            end)\n</pre></div>\n\n\n<p>gives me <code> invalid match/convoy expression, expected type is not known </code></p>",
        "id": 124803051,
        "sender_full_name": "Nima",
        "timestamp": 1523204053
    },
    {
        "content": "<p>min might also mean something else</p>",
        "id": 124803052,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523204061
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>universe u\nclass number(α : Type u) extends linear_order α :=\n(min : option α)\n(min_prop : @option.rec_on α (λ x, Prop) min true (λ x, true))\n</pre></div>",
        "id": 124803053,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523204065
    },
    {
        "content": "<p>this worked</p>",
        "id": 124803054,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523204066
    },
    {
        "content": "<p>He is just rewriting the match into what lean expands it to</p>",
        "id": 124803055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523204097
    },
    {
        "content": "<p>Given the error</p>",
        "id": 124803063,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523204147
    },
    {
        "content": "<p>To me <code>match</code> or <code>cases</code> are a lot more readable that <code>rec_on</code>.<br>\nIs there any way to fix this and use <code>match</code>?</p>",
        "id": 124803065,
        "sender_full_name": "Nima",
        "timestamp": 1523204161
    },
    {
        "content": "<p>Is the issue that lean needs to be told the type earlier on?</p>",
        "id": 124803106,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523204210
    },
    {
        "content": "<p>I think so</p>",
        "id": 124803107,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523204219
    },
    {
        "content": "<p>Any way I can fix the error message <code> failed to register private name '_match_2', prefix has not been registered </code> for this:</p>\n<div class=\"codehilite\"><pre><span></span>universe u\nclass number(α : Type u) extends linear_order α :=\n(min : option α)\n(max_prop : Prop := match min with\n                    | none := true\n                    | (some _) := true\n                    end))\n</pre></div>",
        "id": 124804468,
        "sender_full_name": "Nima",
        "timestamp": 1523207568
    },
    {
        "content": "<p>Interesting. I'm not sure you can use <code>match</code> this way because it requires the creation of auxiliary definitions. You can try <code>option.cases_on min true (λ _, true)</code> instead or create a definition yourself that you refer to in that expression.</p>",
        "id": 124804999,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523208913
    },
    {
        "content": "<p>I know <code>option.cases_on min true (λ _, true)</code> works, but to me <code>match</code> and <code>cases</code> are a lot more readable.<br>\nI am just trying to define some property to my <code>class</code> and it seems impossible without using <code>cases_on</code> or <code>rec_on</code></p>",
        "id": 124805183,
        "sender_full_name": "Nima",
        "timestamp": 1523209392
    },
    {
        "content": "<p>You can also do:</p>\n<div class=\"codehilite\"><pre><span></span>def max_prop_def (α : Type*) : option α -&gt; Prop\n  | none := true\n  | (some _) := true\n</pre></div>\n\n\n<p>And use <code>max_prop_def min</code> as your default value.</p>",
        "id": 124805272,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523209623
    },
    {
        "content": "<p>Fantastic, thanks a lot!<br>\n<code>Type*</code> means Type at some universe?</p>",
        "id": 124805367,
        "sender_full_name": "Nima",
        "timestamp": 1523209813
    },
    {
        "content": "<p>Exactly! And Lean infers that universe for you</p>",
        "id": 124805679,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523210577
    },
    {
        "content": "<p>you can also write <code>universe u</code> at the top and then <code>(alpha : Type u)</code>. It's like variables -- you are implicitly quantifying over universes.</p>",
        "id": 124805978,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523211314
    },
    {
        "content": "<p>I strongly recommend Simon's solution over inlining the match (even assuming you can get it to work). It might look nice up front, but as soon as you start using these properties in proofs, you will have to reference those internals</p>",
        "id": 124806249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523211928
    },
    {
        "content": "<p>Would you please tell me how I should change this, so it will type check?</p>\n<div class=\"codehilite\"><pre><span></span>inductive constraint (α:Type*)\n| trv                                        : constraint\n| stt (bnd:α) (low:Prop) (d : decidable low) : constraint\n\nnamespace constraint\ndef setof {α : Type*} [linear_order α] : constraint α → α → Prop\n| (trv α)         a := true\n| (stt bnd low d) a := if low then bnd&lt;a else a&lt;bnd -- ERROR: failed to synthesize type class instance for\n</pre></div>",
        "id": 124806595,
        "sender_full_name": "Nima",
        "timestamp": 1523212728
    },
    {
        "content": "<p>I'm not sure what <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> will think of it but I propose:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">bound</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">upper</span>  <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bound</span>\n<span class=\"bp\">|</span> <span class=\"n\">lower</span>  <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bound</span>\n\n<span class=\"n\">def</span> <span class=\"kn\">check</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_linear_order</span>  <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">bound</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">bound</span><span class=\"bp\">.</span><span class=\"n\">lower</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">bound</span><span class=\"bp\">.</span><span class=\"n\">upper</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"n\">y</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">constraint</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">trv</span>                     <span class=\"o\">:</span> <span class=\"n\">constraint</span>\n<span class=\"bp\">|</span> <span class=\"n\">stt</span> <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span><span class=\"n\">bound</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">constraint</span>\n<span class=\"n\">def</span> <span class=\"n\">setof</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">trv</span> <span class=\"n\">α</span><span class=\"o\">)</span>         <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">stt</span> <span class=\"n\">bnd</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kn\">check</span> <span class=\"n\">bnd</span> <span class=\"n\">a</span>\n</pre></div>",
        "id": 124806903,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523213508
    },
    {
        "content": "<p>Thanks for showing <code>lean</code> :)<br>\nI have to think about/learn/understand your solution.<br>\nIn a meantime, is there a way to merge similar cases?<br>\nConsider the following example</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">constraint</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">trv</span>        <span class=\"o\">:</span> <span class=\"n\">constraint</span>\n<span class=\"bp\">|</span> <span class=\"n\">lt</span> <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span>\n<span class=\"bp\">|</span> <span class=\"n\">le</span> <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span>\n<span class=\"bp\">|</span> <span class=\"n\">gt</span> <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span>\n<span class=\"bp\">|</span> <span class=\"n\">ge</span> <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">constraint</span>\n<span class=\"n\">def</span> <span class=\"n\">prop</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">trv</span> <span class=\"n\">α</span><span class=\"o\">):=</span> <span class=\"n\">true</span> <span class=\"c1\">-- short term</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"c1\">-- very long term 1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"c1\">-- very long term 1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">gt</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"c1\">-- very long term 2</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ge</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"c1\">-- very long term 2</span>\n</pre></div>\n\n\n<p>Is there any way I use pattern matching and merge those cases where the right hand side is going to be the same?<br>\nI know it is a long shot, but even better: may be cases for <code>lt</code> and <code>le</code> have a lot in common, <code>very_long ∧p1</code> and <code>very_long∧p2</code>.  Is there a way to effectively write something like </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">prop</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">trv</span> <span class=\"n\">α</span><span class=\"o\">):=</span> <span class=\"n\">true</span> <span class=\"c1\">-- short term</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">:(</span><span class=\"n\">lt</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">or</span> <span class=\"n\">x</span><span class=\"o\">:(</span><span class=\"n\">le</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">very_long</span> <span class=\"bp\">∧</span> <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"bp\">_</span><span class=\"o\">):=</span> <span class=\"n\">p1</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"bp\">_</span><span class=\"o\">):=</span><span class=\"n\">p2</span> <span class=\"kn\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">gt</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"c1\">-- very long term 2</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">ge</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"c1\">-- very long term 2</span>\n</pre></div>",
        "id": 124807220,
        "sender_full_name": "Nima",
        "timestamp": 1523214175
    },
    {
        "content": "<blockquote>\n<p>Thanks for showing <code>lean</code></p>\n</blockquote>\n<p>My pleasure! I love sharing my excitement for Lean.</p>\n<p>I would go back to the separation of <code>constraint</code> and <code>bound</code> and define <code>prop</code> as:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">strictness</span>\n<span class=\"bp\">|</span> <span class=\"n\">strict</span> <span class=\"bp\">|</span> <span class=\"n\">non_strict</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">bound</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">upper</span>  <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">strictness</span> <span class=\"bp\">→</span> <span class=\"n\">bound</span>\n<span class=\"bp\">|</span> <span class=\"n\">lower</span>  <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">strictness</span> <span class=\"bp\">→</span> <span class=\"n\">bound</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">bound</span> <span class=\"n\">strictness</span>\n<span class=\"c1\">-- ...</span>\n\n<span class=\"n\">def</span> <span class=\"n\">prop</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">trv</span> <span class=\"n\">α</span><span class=\"o\">):=</span> <span class=\"n\">true</span> <span class=\"c1\">-- short term</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">stt</span> <span class=\"o\">(</span><span class=\"n\">lower</span> <span class=\"n\">b</span> <span class=\"n\">str</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">very_long</span> <span class=\"bp\">∧</span> <span class=\"k\">match</span> <span class=\"n\">str</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">strict</span><span class=\"o\">:=</span> <span class=\"n\">p1</span> <span class=\"bp\">|</span> <span class=\"n\">non_strict</span> <span class=\"o\">:=</span><span class=\"n\">p2</span> <span class=\"kn\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">stt</span> <span class=\"o\">(</span><span class=\"n\">upper</span> <span class=\"n\">b</span> <span class=\"n\">str</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"c1\">-- very long term 2</span>\n</pre></div>",
        "id": 124807668,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523215315
    },
    {
        "content": "<p>So the short answer is that you can't combine pattern matching and propositional notation. You can, however, try to get a bit closer and define functions like <code>is_strict</code> or <code>is_le</code> and use them in <code>if _ then _ else _</code>.</p>",
        "id": 124807713,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523215439
    },
    {
        "content": "<p>Thanks a lot,<br>\nAbout <code>[decidable_linear_order ℕ]</code><br>\nAt the intuitive level, does this mean if you give me two natural numbers, I can tell you which one is larger?<br>\nI think the answer yes, but it should be no.<br>\nFor example, if you give me two natural number in <strong>binary format</strong> then comparing them is decidable. But who said you are going to always give them in binary format?<br>\nSo if I use <code>[decidable_linear_order ℕ]</code> in a definition, and use <code>classical</code> to find two numbers inside that definition, does that mean comparing them is decidable? (I think the answer should be no, but I don't know why)</p>",
        "id": 124807940,
        "sender_full_name": "Nima",
        "timestamp": 1523215941
    },
    {
        "content": "<blockquote>\n<p>At the intuitive level, does this mean if you give me two natural numbers, I can tell you which one is larger?</p>\n</blockquote>\n<p>Yes that's correct. </p>",
        "id": 124808142,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523216423
    },
    {
        "content": "<blockquote>\n<p>I think the answer yes, but it should be no.</p>\n</blockquote>\n<p>In Lean, no set of numbers are postulated (i.e. we say \"let there be natural numbers\" and they appear). Instead, each set of numbers is constructed as an inductive type. In particular, natural numbers are defined as follows:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span>\n</pre></div>\n\n\n<p>You may recognize the structure of Peano's axiomatization of natural numbers. The big difference is that the above is a valid definition. Whenever you are given two natural numbers, they are given to you in unary notation (e.g. 11111 for 5, 111 for 3 and so on). This makes comparison decidable</p>",
        "id": 124808241,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523216666
    },
    {
        "content": "<p>For the sake of performances however, the virtual machine and some tactics use binary representations (in the case of the vm, it's implemented by gmp, I believe)</p>",
        "id": 124808252,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523216720
    },
    {
        "content": "<p>Is this what you were getting at?</p>",
        "id": 124808255,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523216747
    },
    {
        "content": "<p>That makes sense, thanks.</p>",
        "id": 124808675,
        "sender_full_name": "Nima",
        "timestamp": 1523217565
    },
    {
        "content": "<p>How can I finish the last definition?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">ind</span>\n<span class=\"bp\">|</span> <span class=\"n\">emt</span> <span class=\"o\">:</span> <span class=\"n\">ind</span>\n<span class=\"bp\">|</span> <span class=\"n\">val</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span><span class=\"n\">ind</span>\n<span class=\"kn\">open</span> <span class=\"n\">ind</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_nonempty</span> <span class=\"o\">:</span> <span class=\"n\">ind</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">emt</span>     <span class=\"o\">:=</span> <span class=\"n\">false</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n\n<span class=\"n\">def</span> <span class=\"n\">valof</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ind</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_nonempty</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">admit</span> <span class=\"kn\">end</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>Status is </p>\n<div class=\"codehilite\"><pre><span></span>i : ind,\nh : is_nonempty i,\n_match : ind → ℕ,\n_x : ind\n⊢ ℕ\n</pre></div>\n\n\n<p>It seems <code>lean</code> forgot about the first case!</p>",
        "id": 124812752,
        "sender_full_name": "Nima",
        "timestamp": 1523227438
    },
    {
        "content": "<p>I don't understand what the difference is, but it could be done using the following definition:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">valof</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ind</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_nonempty</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_nonempty</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">a</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 124813315,
        "sender_full_name": "Nima",
        "timestamp": 1523228714
    },
    {
        "content": "<p>Here's how to avoid the <code>a</code>:</p>",
        "id": 124813425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523228926
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">valof</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ind</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_nonempty</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">i</span> <span class=\"k\">with</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">false</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">n</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 124813433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523228949
    },
    {
        "content": "<p>After <code>cases</code> you have two goals, and it's encouraged to wrap them in curly brackets so you can deal with them one at a time (it helps with debugging later on when Leo changes everything and stuff stops working)</p>",
        "id": 124813486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523229034
    },
    {
        "content": "<p>what is wrong with <code>a</code>? <br>\nIs it because <code>a</code> is used internally?</p>",
        "id": 124813493,
        "sender_full_name": "Nima",
        "timestamp": 1523229070
    },
    {
        "content": "<p>the fact that Lean randomly calls variables a is considered a bug ;-)</p>",
        "id": 124813835,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523229806
    },
    {
        "content": "<p>Not least because you might already have another variable called a!</p>",
        "id": 124813836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523229816
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean/issues/1822\" target=\"_blank\" title=\"https://github.com/leanprover/lean/issues/1822\">https://github.com/leanprover/lean/issues/1822</a></p>",
        "id": 124813884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523229907
    },
    {
        "content": "<p>In Lean 4 your code will stop working but mine should be OK. In fact your code does not work for me -- which version of Lean are you using?</p>",
        "id": 124813925,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523229982
    },
    {
        "content": "<p>I am on the nightly from 6th April.</p>",
        "id": 124813927,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523230005
    },
    {
        "content": "<p>All my code does, of course, is explicitly names the variable when we do the case split.</p>",
        "id": 124813932,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523230038
    },
    {
        "content": "<p>Lean (version 3.3.0, commit fa9c868ed2bb, Release)</p>",
        "id": 124813984,
        "sender_full_name": "Nima",
        "timestamp": 1523230192
    },
    {
        "content": "<p>v3.4 is coming soon. A lot has happened since 3.3.</p>",
        "id": 124814034,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523230267
    },
    {
        "content": "<p>Oh, this works for me:</p>",
        "id": 124814079,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523230359
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span>  <span class=\"n\">valof&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ind</span><span class=\"o\">),</span> <span class=\"n\">is_nonempty</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">emt</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">h</span>\n</pre></div>",
        "id": 124814083,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523230370
    },
    {
        "content": "<p>The equation compiler is apparently more clever than match</p>",
        "id": 124814089,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523230393
    },
    {
        "content": "<p>that can't be right because they are the same thing. The difference is that I am getting h involved in the matching process here.</p>",
        "id": 124814129,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523230445
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span>  <span class=\"n\">valof</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ind</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_nonempty</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span>  <span class=\"k\">match</span> <span class=\"n\">i</span><span class=\"o\">,</span><span class=\"n\">h</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">emt</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">h</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 124814192,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523230604
    },
    {
        "content": "<p>You need to tell the equation compiler about h explicitly, so it seems.</p>",
        "id": 124814194,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523230619
    },
    {
        "content": "<p>Thanks, your solution worked for me,<br>\nBut I did not understand why I should use <code>h</code> in the match (I know it won't type-check without it, but I don't know why)</p>",
        "id": 124814735,
        "sender_full_name": "Nima",
        "timestamp": 1523231843
    },
    {
        "content": "<p>How can I mark result Prop decidable?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">func</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)[</span><span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)[</span><span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">true</span> <span class=\"k\">else</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- won&#39;t type check</span>\n</pre></div>",
        "id": 124815048,
        "sender_full_name": "Nima",
        "timestamp": 1523232573
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">func</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">func_of_decidable_is_decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">H</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">true</span> <span class=\"k\">else</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 124815254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523233059
    },
    {
        "content": "<p>I explain to the type class inference system that it should spot that if p is decidable then func p is too.</p>",
        "id": 124815294,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523233087
    },
    {
        "content": "<p>Great, thanks</p>",
        "id": 124815298,
        "sender_full_name": "Nima",
        "timestamp": 1523233134
    },
    {
        "content": "<p>As for the equation compiler question (why it's not smart enough to make deductions about h) -- I'm afraid that's beyond my pay grade. You can see in your begin/end attempt that by the time we've got to the right of the colon-equals, Lean doesn't even seem to know that i is emt -- even if you explicitly write that it is -- so it can't make any deductions about h.</p>",
        "id": 124815365,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523233286
    },
    {
        "content": "<p>I think that when you match on both <code>i</code> and <code>h</code>, it allows Lean to change the type of <code>h</code> (or rather, its patterns) to reflect that you're matching on <code>i</code>. In the first branch, <code>h : is_empty (val n)</code> and in the second, <code>h : is_empty emt</code>. After that, we have definitional equality with <code>false</code> (resp. <code>true</code>) by simply unfolding <code>is_empty</code></p>",
        "id": 124815524,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523233655
    },
    {
        "content": "<p>With regards to decidable, when a function returns <code>true</code> or <code>false</code> and then that you need it to be decidable, you can use <code>bool</code> instead and it will be automatically decidable because there is an implicit conversion from <code>bool</code> to <code>Prop</code> and the resulting <code>Prop</code> is decidable.</p>",
        "id": 124815579,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523233737
    },
    {
        "content": "<p>How do I prove <code>decidable true</code>?<br>\nRegarding using <code>bool</code>, it works, but then either I have write <code>p=tt</code> or I will see the left symbol <code>↥p</code> everywhere (not sure how comfortable I am with that, or how much trouble it is going to cause me later).</p>",
        "id": 124815709,
        "sender_full_name": "Nima",
        "timestamp": 1523234014
    },
    {
        "content": "<p><code>decidable true</code> has type <code>Type</code>so I'm not sure you can prove it.</p>",
        "id": 124815760,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234110
    },
    {
        "content": "<p>Here's the definition of decidable -- it's an inductive type.</p>",
        "id": 124815761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234150
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>class inductive decidable (p : Prop)\n| is_false (h : ¬p) : decidable\n| is_true  (h : p) : decidable\n</pre></div>",
        "id": 124815801,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234166
    },
    {
        "content": "<p>So you have two constructors, <code>is_true</code> and <code>is_false</code></p>",
        "id": 124815802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234179
    },
    {
        "content": "<p><code>#check is_true trivial -- decidable true</code></p>",
        "id": 124815813,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234226
    },
    {
        "content": "<p><code>true</code> is a Prop and <code>trivial</code> is a proof of <code>true</code></p>",
        "id": 124815856,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234303
    },
    {
        "content": "<p>So if output of a function is either <code>true</code> or <code>false</code>, how do I say this output is decidable (without going to <code>bool</code>)? From what you just said, what I am trying to write in <code>lean</code> does not even make sense. Right?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">func</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)[</span><span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)[</span><span class=\"n\">decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">true</span> <span class=\"k\">else</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- won&#39;t type check</span>\n</pre></div>",
        "id": 124815867,
        "sender_full_name": "Nima",
        "timestamp": 1523234396
    },
    {
        "content": "<p>Well you have to prove that the output is either true or false, and then you can make an instance of the decidable class by using is_false if it's false and is_true if it's true</p>",
        "id": 124815916,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234496
    },
    {
        "content": "<p>Take a look at how core Lean proves that less than or equal to is decidable on nat</p>",
        "id": 124815978,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234613
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">decidable_le</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">b</span>     <span class=\"o\">:=</span> <span class=\"n\">is_true</span> <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"n\">not_succ_le_zero</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">decidable_le</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">is_true</span> <span class=\"n\">h</span>  <span class=\"o\">:=</span> <span class=\"n\">is_true</span> <span class=\"o\">(</span><span class=\"n\">succ_le_succ</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">is_false</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">is_false</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">le_of_succ_le_succ</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n  <span class=\"kn\">end</span>\n</pre></div>",
        "id": 124815981,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234630
    },
    {
        "content": "<p>Given the statement <code>a &lt;= b</code> it either proves that it's true or proves that it's false, and in each case it creates an instance of <code>decidable (a &lt;= b)</code></p>",
        "id": 124816022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234686
    },
    {
        "content": "<p>using the <code>is_true</code> or <code>is_false</code> constructors</p>",
        "id": 124816028,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234704
    },
    {
        "content": "<p>things like <code>nat.zero_le</code> are lemmas in Lean (that one says \"forall n, 0 &lt;= n\")</p>",
        "id": 124816073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234766
    },
    {
        "content": "<p>Earlier in the file they must have written \"open nat\" so you don't have to keep writing \"nat.\"</p>",
        "id": 124816076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523234790
    },
    {
        "content": "<p>Sorry, but I still cannot figure out how to make this example work without going to <code>bool</code></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">func</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"kn\">instance</span> <span class=\"n\">func_of_decidable_is_decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">func</span><span class=\"o\">],</span>\n  <span class=\"c1\">-- I have to prove decidable true</span>\n  <span class=\"n\">admit</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">true</span> <span class=\"k\">else</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 124816172,
        "sender_full_name": "Nima",
        "timestamp": 1523235046
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">func</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"kn\">instance</span> <span class=\"n\">func_of_decidable_is_decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">is_true</span> <span class=\"n\">trivial</span>\n</pre></div>",
        "id": 124816222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523235182
    },
    {
        "content": "<p>I just use the constructor</p>",
        "id": 124816227,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523235186
    },
    {
        "content": "<p>in tactic mode you can write <code>exact is_true trivial</code></p>",
        "id": 124816265,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523235245
    },
    {
        "content": "<p>Thanks, now I got it!</p>",
        "id": 124816270,
        "sender_full_name": "Nima",
        "timestamp": 1523235258
    },
    {
        "content": "<p>The only way you can ever prove decidable anything is to use a constructor. decidable is an inductive type with two constructors and the only way to make an instance of it is to use one of the constructors.</p>",
        "id": 124816272,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523235290
    },
    {
        "content": "<p><code>decidable.true</code> proves <code>decidable true</code></p>",
        "id": 124816379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523235591
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>instance (i) : decidable (is_nonempty i) :=\nby cases i; unfold is_nonempty; apply_instance\n</pre></div>",
        "id": 124816479,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523235736
    },
    {
        "content": "<p><code>valof</code> can also be defined without the <code>emt</code> case at all:</p>\n<div class=\"codehilite\"><pre><span></span>def valof : Π (i : ind), is_nonempty i → ℕ\n| (val n) h := n\n</pre></div>\n\n\n<p>This is because lean does cases on <code>h</code> there and needs no cases since it's <code>false</code></p>",
        "id": 124816490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523235803
    },
    {
        "content": "<p>I don't recommend using <code>bool</code> in this case if you can help it; it's possible but the coercions will get in your way sooner or later</p>",
        "id": 124816533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523235888
    },
    {
        "content": "<p>what is the difference between <code>unfold</code> and <code>rw</code>?</p>",
        "id": 124816581,
        "sender_full_name": "Nima",
        "timestamp": 1523235985
    },
    {
        "content": "<p>Also, you can prove <code>decidable T</code> for any expression <code>T</code> that is already known to be decidable from earlier stuff (like ands of ors of true and natural number equality and other things like that) by <code>apply_instance</code>.</p>",
        "id": 124816582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523236004
    },
    {
        "content": "<p><code>unfold</code> does definitional unfolding; the syntax is <code>unfold X</code> where <code>X</code> is a definition will rewrite with the equation lemmas for <code>X</code>. <code>rw</code> does arbitrary (non-definitional) rewriting with any equations you give it</p>",
        "id": 124816591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523236061
    },
    {
        "content": "<p>However, <code>rw X</code> also works as a shorthand for \"rewrite with the equation lemmas for <code>X</code>\" which makes it very similar to <code>unfold</code> in this instance</p>",
        "id": 124816634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523236123
    },
    {
        "content": "<p>Thank you,<br>\nAfter all these helps and more than an hour I wrote <strong>6 lines</strong> as a proof  <span class=\"emoji emoji-1f631\" title=\"scream\">:scream:</span></p>",
        "id": 124817111,
        "sender_full_name": "Nima",
        "timestamp": 1523237287
    },
    {
        "content": "<p>\"perfection is when there is nothing left to take away\" - Antoine de Saint-Exupery</p>",
        "id": 124817178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523237509
    },
    {
        "content": "<p>Just to be clear, that was just survival; no perfection was involved!</p>",
        "id": 124817309,
        "sender_full_name": "Nima",
        "timestamp": 1523237808
    },
    {
        "content": "<p>I also like to quote Adventure Time when it comes to learning functional programming and proving: sucking is the first step towards being kind of good at something.</p>",
        "id": 124817314,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523237877
    },
    {
        "content": "<p>The fun thing about Haskell and Lean is that ugly code is still very much usable. As you learn more, you see it improve over time. My ugly Haskell and Lean code is still easier to refactor and evolve than anything I wrote in any language. Just to say: starting with bad code is not too much of a problem</p>",
        "id": 124817408,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523238069
    },
    {
        "content": "<p>When I use <code>cases </code> on an inductive type, how can I specify the first case that I would like to consider?<br>\nWhen I am in tactic mode, how can I have pattern matching on two inductive types at the same time?</p>",
        "id": 124819331,
        "sender_full_name": "Nima",
        "timestamp": 1523242790
    },
    {
        "content": "<p>nested cases?</p>",
        "id": 124819379,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523242813
    },
    {
        "content": "<blockquote>\n<p>When I use <code>cases </code> on an inductive type, how can I specify the first case that I would like to consider?</p>\n</blockquote>\n<p>in tactic mode you can write</p>\n<div class=\"codehilite\"><pre><span></span>case list.nil\n{ simp },\ncase list.cons\n{ simp }\n</pre></div>",
        "id": 124819382,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523242857
    },
    {
        "content": "<p>Thanks for <code>case</code><br>\nBy \"nested cases\" you mean writing multiple <code>cases</code>?<br>\nI meant something like <code>match a,b with</code>? Is there anything like that available?</p>",
        "id": 124819491,
        "sender_full_name": "Nima",
        "timestamp": 1523243089
    },
    {
        "content": "<p><code>exact match a,b with</code></p>",
        "id": 124819500,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523243107
    },
    {
        "content": "<p>you can always use <code>exact</code> to go into term mode</p>",
        "id": 124819501,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523243115
    },
    {
        "content": "<p>and <code>by</code> to go into tactic mode</p>",
        "id": 124819502,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523243120
    },
    {
        "content": "<p>no, I don't think there's a tactic for nested cases</p>",
        "id": 124819503,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523243130
    },
    {
        "content": "<p><code>exact match a,b with</code> is exactly what I was looking for. Thank you.</p>",
        "id": 124819545,
        "sender_full_name": "Nima",
        "timestamp": 1523243193
    },
    {
        "content": "<p><code>rcases</code>, from the mathlib tactics, does multiple cases</p>",
        "id": 124820994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523246717
    },
    {
        "content": "<p>but it only works with one input expression. In fact regular cases will automatically generalize dependent hypotheses like <code>match i, h with</code> in your earlier example.</p>",
        "id": 124821038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523246785
    },
    {
        "content": "<p>Does it make any sense if I use <code>classical</code> to prove something like <code> decidable (number.choose α = none) </code>?</p>",
        "id": 124863817,
        "sender_full_name": "Nima",
        "timestamp": 1523322678
    },
    {
        "content": "<p>You can, but <code>option.is_none</code> is already decidable</p>",
        "id": 124864641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523324515
    },
    {
        "content": "<p>There's also something contradictory to using classical reasoning to prove decidability: decidability is preferable to <code>classical.em</code> (excluded middle) especially to preserve computability. If you bring in classical reasoning, you lose computability so you might as well go all the way and just use <code>classical.prop_decidable</code> to make every proposition decidable:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">prop_decidable</span>\n</pre></div>\n\n\n<p>This is useful to use <code>if _ then _ else _</code> without proving decidability.</p>",
        "id": 124865269,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523325906
    },
    {
        "content": "<p>So if I want to use <code>decidable</code> as what it is intended to be then I should not use <code>classical</code>. Right?</p>",
        "id": 124865624,
        "sender_full_name": "Nima",
        "timestamp": 1523326676
    },
    {
        "content": "<p>but <code>classical.prop_decidable</code> just says that every <code>prop</code> is <code>decidable</code></p>",
        "id": 124865732,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523326808
    },
    {
        "content": "<p><code>decidable</code> is a proof obligation that is trivial if you are being classical. Most conventional math in lean is classical, so you usually don't have to worry about this. You should think about decidability if you are writing an executable program (if you have to mark your program <code>noncomputable</code> it won't run).</p>",
        "id": 124865767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523326894
    },
    {
        "content": "<p>You can attempt to avoid LEM even when proving theorems, like Kenny, but the library won't really help you in this quest so it's an uphill battle</p>",
        "id": 124865820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523326966
    },
    {
        "content": "<p>Please look at the last two lines, as I am not sure if anything else there is relevant</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">number</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">d₁</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_trivial</span> <span class=\"n\">c</span><span class=\"o\">),</span>\n<span class=\"n\">d₂</span> <span class=\"o\">:</span> <span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">match</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_trivial</span> <span class=\"n\">c</span><span class=\"o\">)),</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_satisfiable</span> <span class=\"n\">c</span><span class=\"o\">),</span>\n<span class=\"n\">hnt</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">is_trivial</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"n\">d₃</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_lower_bound</span> <span class=\"n\">c</span><span class=\"o\">),</span>\n<span class=\"bp\">_</span><span class=\"n\">match</span> <span class=\"o\">:</span>\n  <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_lower_bound</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"n\">decidable</span>\n    <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">is_lower_bound</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">is_satisfiable</span><span class=\"bp\">._</span><span class=\"n\">match_3</span> <span class=\"n\">c</span> <span class=\"n\">hnt</span> <span class=\"o\">(</span><span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">max</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n       <span class=\"o\">(</span><span class=\"n\">is_satisfiable</span><span class=\"bp\">._</span><span class=\"n\">match_4</span> <span class=\"n\">c</span> <span class=\"n\">hnt</span> <span class=\"o\">(</span><span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">min</span> <span class=\"n\">α</span><span class=\"o\">))),</span>\n<span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">is_lower_bound</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">match</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_satisfiable</span><span class=\"bp\">._</span><span class=\"n\">match_3</span> <span class=\"n\">c</span> <span class=\"n\">hnt</span> <span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"o\">),</span>\n<span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">aa</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">get_bound</span> <span class=\"n\">c</span> <span class=\"n\">hnt</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"err\">⊢</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">get_bound</span> <span class=\"n\">c</span> <span class=\"n\">hnt</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>If I do <code> exact aa,</code> I receive this cryptic error message.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">decidable</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_lt</span><span class=\"bp\">.</span><span class=\"n\">lt</span> <span class=\"n\">α</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">preorder</span><span class=\"bp\">.</span><span class=\"n\">to_has_lt</span> <span class=\"n\">α</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">partial_order</span><span class=\"bp\">.</span><span class=\"n\">to_preorder</span> <span class=\"n\">α</span>\n             <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear_order</span><span class=\"bp\">.</span><span class=\"n\">to_partial_order</span> <span class=\"n\">α</span>\n                <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear_order</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">decidable_linear_order</span><span class=\"bp\">.</span><span class=\"n\">le</span> <span class=\"n\">α</span> <span class=\"n\">d₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">decidable_linear_order</span><span class=\"bp\">.</span><span class=\"n\">lt</span> <span class=\"n\">α</span> <span class=\"n\">d₂</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n                   <span class=\"bp\">_</span><span class=\"o\">))))</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">constraint</span><span class=\"bp\">.</span><span class=\"n\">get_bound</span> <span class=\"n\">α</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"n\">c</span> <span class=\"n\">hnt</span><span class=\"o\">)</span>\n       <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">decidable</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_lt</span><span class=\"bp\">.</span><span class=\"n\">lt</span> <span class=\"n\">α</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">preorder</span><span class=\"bp\">.</span><span class=\"n\">to_has_lt</span> <span class=\"n\">α</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">partial_order</span><span class=\"bp\">.</span><span class=\"n\">to_preorder</span> <span class=\"n\">α</span>\n             <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">linear_order</span><span class=\"bp\">.</span><span class=\"n\">to_partial_order</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">to_linear_order</span> <span class=\"n\">α</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">))))</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">constraint</span><span class=\"bp\">.</span><span class=\"n\">get_bound</span> <span class=\"n\">α</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"n\">c</span> <span class=\"n\">hnt</span><span class=\"o\">)</span>\n       <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"bp\">...</span>\n</pre></div>\n\n\n<p>I know I might not gave enough information to receive an exact answer, but is there any clue you can share about why this might happen?</p>",
        "id": 124865830,
        "sender_full_name": "Nima",
        "timestamp": 1523327001
    },
    {
        "content": "<p>You have <code>decidable (is_trivial c)</code> as an assumption, which is probably a bad sign. How is <code>is_trivial</code> and <code>constraint</code> defined?</p>",
        "id": 124865882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523327098
    },
    {
        "content": "<p>diamond of death?</p>",
        "id": 124865889,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523327131
    },
    {
        "content": "<p>I think <code> decidable_linear_order α</code> is more problematic because it is already subsumed by <code>number α</code></p>",
        "id": 124865935,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523327173
    },
    {
        "content": "<p>yes, <code> number α</code> and <code> decidable_linear_order α</code> both supply a less-equal relation</p>",
        "id": 124865937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523327180
    },
    {
        "content": "<p>you should replace <code>decidable_linear_order α</code> with <code>@decidable_rel α (&lt;)</code></p>",
        "id": 124865947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523327229
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">is_trivial</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">cnstr</span>  <span class=\"n\">ktrv</span>        <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">cnstr</span> <span class=\"o\">(</span><span class=\"n\">kdyn</span> <span class=\"n\">trv</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span>                            <span class=\"o\">:=</span> <span class=\"n\">false</span>\n</pre></div>",
        "id": 124865948,
        "sender_full_name": "Nima",
        "timestamp": 1523327264
    },
    {
        "content": "<p>or define <code>decidable_number</code></p>",
        "id": 124865950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523327272
    },
    {
        "content": "<p>You should be able to prove <code>decidable (is_trivial c)</code> for all <code>c</code> as an instance, so it shouldn't need to be an assumption</p>",
        "id": 124865991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523327306
    },
    {
        "content": "<p>I make <strong>no claim</strong> of writing in the best or even a good way. Just trying to find my way through.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">triviality</span>\n<span class=\"bp\">|</span> <span class=\"n\">trv</span>\n<span class=\"bp\">|</span> <span class=\"n\">ntr</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">direction</span>\n<span class=\"bp\">|</span> <span class=\"n\">lower</span>\n<span class=\"bp\">|</span> <span class=\"n\">upper</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">strictness</span>\n<span class=\"bp\">|</span> <span class=\"n\">stt</span>\n<span class=\"bp\">|</span> <span class=\"n\">nst</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">triviality_kind</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"n\">ktrv</span>                             <span class=\"o\">:</span> <span class=\"n\">triviality_kind</span>\n<span class=\"bp\">|</span> <span class=\"n\">kntr</span>                   <span class=\"o\">(</span><span class=\"n\">bnd</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">triviality_kind</span>\n<span class=\"bp\">|</span> <span class=\"n\">kdyn</span> <span class=\"o\">(</span><span class=\"n\">tr</span> <span class=\"o\">:</span> <span class=\"n\">triviality</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bnd</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">triviality_kind</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">direction_kind</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"n\">klower</span>\n<span class=\"bp\">|</span> <span class=\"n\">kupper</span>\n<span class=\"bp\">|</span> <span class=\"n\">kdynam</span> <span class=\"o\">(</span><span class=\"n\">dir</span> <span class=\"o\">:</span> <span class=\"n\">direction</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">strictness_kind</span>\n<span class=\"bp\">|</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"n\">kstt</span>\n<span class=\"bp\">|</span> <span class=\"n\">knst</span>\n<span class=\"bp\">|</span> <span class=\"n\">kdyn</span> <span class=\"o\">(</span><span class=\"n\">st</span> <span class=\"o\">:</span> <span class=\"n\">strictness</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">constraint</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">cnstr</span> <span class=\"bp\">::</span>\n  <span class=\"o\">(</span><span class=\"n\">trvk</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">triviality_kind</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">dirk</span> <span class=\"o\">:</span> <span class=\"n\">direction_kind</span> <span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">strk</span> <span class=\"o\">:</span> <span class=\"n\">strictness_kind</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">ndir</span> <span class=\"o\">:</span> <span class=\"n\">dirk</span> <span class=\"bp\">=</span> <span class=\"n\">direction_kind</span><span class=\"bp\">.</span><span class=\"n\">none</span>  <span class=\"bp\">↔</span> <span class=\"n\">trvk</span> <span class=\"bp\">=</span> <span class=\"n\">triviality_kind</span><span class=\"bp\">.</span><span class=\"n\">ktrv</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">nstr</span> <span class=\"o\">:</span> <span class=\"n\">strk</span> <span class=\"bp\">=</span> <span class=\"n\">strictness_kind</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"bp\">↔</span> <span class=\"n\">trvk</span> <span class=\"bp\">=</span> <span class=\"n\">triviality_kind</span><span class=\"bp\">.</span><span class=\"n\">ktrv</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span>  <span class=\"n\">is_trivial_is_decidable</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_trivial</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">c</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">trvk</span><span class=\"bp\">;</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">is_trivial</span> <span class=\"o\">}</span><span class=\"bp\">;</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">tr</span> <span class=\"o\">}</span><span class=\"bp\">;</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">true</span> <span class=\"o\">}</span><span class=\"bp\">;</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">false</span><span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 124865997,
        "sender_full_name": "Nima",
        "timestamp": 1523327379
    },
    {
        "content": "<p>You seem to already have the proof I mention there</p>",
        "id": 124866049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523327456
    },
    {
        "content": "<p>What produced the <code>d₁ : decidable (is_trivial c)</code> in the theorem you are proving?</p>",
        "id": 124866094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523327523
    },
    {
        "content": "<p>I am trying to prove  the following is decidable</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">is_satisfiable</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_trivial</span> <span class=\"n\">c</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">is_true</span>  <span class=\"bp\">_</span>  <span class=\"o\">:=</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">choose</span> <span class=\"n\">α</span> <span class=\"bp\">≠</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"n\">is_false</span> <span class=\"n\">ht</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">get_strictness</span> <span class=\"n\">c</span> <span class=\"n\">ht</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nst</span> <span class=\"o\">:=</span>  <span class=\"n\">true</span>\n    <span class=\"bp\">|</span> <span class=\"n\">stt</span> <span class=\"o\">:=</span>  <span class=\"k\">if</span> <span class=\"n\">is_lower_bound</span> <span class=\"n\">c</span> <span class=\"k\">then</span>\n                <span class=\"k\">match</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">max</span> <span class=\"n\">α</span> <span class=\"k\">with</span>\n                <span class=\"bp\">|</span> <span class=\"n\">none</span>   <span class=\"o\">:=</span> <span class=\"n\">true</span>\n                <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">get_bound</span> <span class=\"n\">c</span> <span class=\"n\">ht</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span>\n                <span class=\"kn\">end</span>\n              <span class=\"k\">else</span>\n                <span class=\"k\">match</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">min</span> <span class=\"n\">α</span> <span class=\"k\">with</span>\n                <span class=\"bp\">|</span> <span class=\"n\">none</span>   <span class=\"o\">:=</span> <span class=\"n\">true</span>\n                <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">get_bound</span> <span class=\"n\">c</span> <span class=\"n\">ht</span>\n                <span class=\"kn\">end</span>\n    <span class=\"kn\">end</span>\n  <span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>Second line:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span>  <span class=\"n\">is_satisfiable_is_decidable</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n          <span class=\"o\">[</span><span class=\"n\">d₁</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_trivial</span> <span class=\"n\">c</span><span class=\"o\">)]</span>\n          <span class=\"o\">[</span><span class=\"n\">d₂</span> <span class=\"o\">:</span> <span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_satisfiable</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">d₁</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">is_true</span>  <span class=\"n\">ht</span>  <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">is_satisfiable</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span>\n<span class=\"bp\">|</span> <span class=\"n\">is_false</span> <span class=\"n\">hnt</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">is_satisfiable</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">get_strictness</span> <span class=\"n\">c</span> <span class=\"n\">hnt</span><span class=\"bp\">;</span> <span class=\"n\">unfold</span> <span class=\"n\">is_satisfiable</span><span class=\"bp\">._</span><span class=\"n\">match_2</span><span class=\"o\">,</span>\n    <span class=\"k\">begin</span>\n      <span class=\"k\">have</span> <span class=\"n\">d₃</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_lower_bound</span> <span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"k\">match</span> <span class=\"n\">d₃</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">is_true</span>  <span class=\"n\">hl</span>  <span class=\"o\">:=</span>\n        <span class=\"k\">begin</span>\n          <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">],</span>\n          <span class=\"n\">exact</span> <span class=\"k\">match</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">max</span> <span class=\"n\">α</span> <span class=\"k\">with</span>\n          <span class=\"bp\">|</span> <span class=\"n\">none</span>   <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">is_satisfiable</span><span class=\"bp\">._</span><span class=\"n\">match_3</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">true</span>\n          <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n                      <span class=\"n\">unfold</span> <span class=\"n\">is_satisfiable</span><span class=\"bp\">._</span><span class=\"n\">match_3</span><span class=\"o\">,</span>\n                      <span class=\"k\">have</span> <span class=\"n\">aa</span> <span class=\"o\">:=</span> <span class=\"n\">decidable_linear_order</span><span class=\"bp\">.</span><span class=\"n\">decidable_lt</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">get_bound</span> <span class=\"n\">c</span> <span class=\"n\">hnt</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n                      <span class=\"n\">exact</span> <span class=\"n\">aa</span><span class=\"o\">,</span>\n                      <span class=\"kn\">end</span>\n          <span class=\"c1\">-- by unfold is_satisfiable._match_3; apply_instance</span>\n          <span class=\"kn\">end</span>\n        <span class=\"kn\">end</span>\n      <span class=\"bp\">|</span> <span class=\"n\">is_false</span> <span class=\"n\">hnl</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hnl</span><span class=\"o\">],</span> <span class=\"n\">admit</span> <span class=\"kn\">end</span>\n      <span class=\"kn\">end</span><span class=\"o\">,</span>\n    <span class=\"kn\">end</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">decidable</span><span class=\"bp\">.</span><span class=\"n\">true</span>\n  <span class=\"kn\">end</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 124866108,
        "sender_full_name": "Nima",
        "timestamp": 1523327587
    },
    {
        "content": "<p>drop the line <code>           [d₁ : decidable (is_trivial c)] </code></p>",
        "id": 124866109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523327599
    },
    {
        "content": "<p>You can do the match by writing <code>if ht : is_trivial c then ... else ...</code></p>",
        "id": 124866111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523327630
    },
    {
        "content": "<p>Should I drop <code> [d : decidable (is_trivial c)] </code> from definition of <code>is_satisfiable</code> as well?</p>",
        "id": 124866223,
        "sender_full_name": "Nima",
        "timestamp": 1523327882
    },
    {
        "content": "<p>Given the complexity of your definition, I think you would do better to change <code>is_satisfiable</code> to type <code>def is_satisfiable (c : constraint α) : bool :=</code>. Same for <code>is_trivial</code>, since it's just a bunch of <code>true</code> and <code>false</code> branches</p>",
        "id": 124866253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523327914
    },
    {
        "content": "<p>Then decidability will be trivial, and you can prove the unfolding of the individual branches as (much easier) lemmas</p>",
        "id": 124866261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523327972
    },
    {
        "content": "<p>I don't have all your definitions so I don't know if this typechecks, but something like this:</p>\n<div class=\"codehilite\"><pre><span></span>def is_trivial : constraint α → bool\n| (cnstr  ktrv        _ _ _ _) := tt\n| (cnstr (kdyn trv _) _ _ _ _) := tt\n| _                            := ff\n\ndef is_satisfiable (c : constraint α) : bool :=\nif ht : is_trivial c then\n  (number.choose α).is_some\nelse\n  match get_strictness c ht with\n  | nst := tt\n  | stt :=\n    if is_lower_bound c then\n      match number.max α with\n      | none   := tt\n      | some m := get_bound c ht &lt; m\n      end\n    else\n      match number.min α with\n      | none   := tt\n      | some m := m &lt; get_bound c ht\n      end\n  end\n</pre></div>",
        "id": 124866476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523328417
    },
    {
        "content": "<p>Would you please tell me why I should have dropped <code>[d₁ : decidable (is_trivial c)]</code>?<br>\nShouldn't I have one of these for every property I put in <code>if then else</code>?</p>",
        "id": 124866687,
        "sender_full_name": "Nima",
        "timestamp": 1523328902
    },
    {
        "content": "<p>When you look at <code>(get_bound c hnt &lt; m)</code> you should see that <code>&lt;</code> is generic, i.e. it is inferred from instances. Because of that you should see that it takes four parameters, not two:</p>\n<ul>\n<li><code>α </code></li>\n<li>some instance of <code>has_lt α</code></li>\n<li><code>get_bound c hnt</code></li>\n<li><code>m</code></li>\n</ul>\n<p>This means that if different instances of <code>has_lt</code> are inferred for two <code>&lt;</code> propositions, they are not syntactically the same so you can't use one to prove the other</p>",
        "id": 124866740,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523329060
    },
    {
        "content": "<p>That means that you have to consciously try to have a unique path to any instance that you're going to use. If the instances are conceptually the same, it might still be hard to prove and the effort is usually not worth it</p>",
        "id": 124866786,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523329136
    },
    {
        "content": "<p>When you say <code>[d₁ : decidable (is_trivial c)]</code> , you are defining a function parametric over proofs that triviality is decidable. There's no need to do this, you already have such a proof/function and want to call it whenever you want to decide if a constraint is trivial</p>",
        "id": 124866904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523329416
    },
    {
        "content": "<p>If you say <code>if ht : is_trivial c then ...</code>, it automatically infers the <code>decidable (is_trivial c)</code> argument (using the environment, not just the local context), which is what you want.</p>",
        "id": 124866963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523329509
    },
    {
        "content": "<p>Thank you both,<br>\nI need time to take these in ...</p>",
        "id": 124867141,
        "sender_full_name": "Nima",
        "timestamp": 1523329896
    },
    {
        "content": "<p>Sure :) it's a slow process. You can have Lean's pretty printer show more information and, among others, show the implicit and type class arguments by using <code>set_option pp.all true</code> before your theorem.</p>",
        "id": 124867357,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523330376
    },
    {
        "content": "<p>OK, after I changed something and I will get back to it later, I managed to rewrote the whole proof in the following nicer way.<br>\nAs you can see something is almost duplicated. Is there anyway I can make this even shorter (ie remove those duplications)?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span>  <span class=\"n\">is_satisfiable_is_decidable</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_satisfiable</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">is_trivial</span>     <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">is_satisfiable</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">],</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span> <span class=\"k\">else</span>\n  <span class=\"k\">if</span> <span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">is_nonstrict</span>   <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">is_satisfiable</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hs</span><span class=\"o\">],</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span> <span class=\"k\">else</span>\n  <span class=\"k\">if</span> <span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">is_lower_bound</span> <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"k\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">is_satisfiable</span><span class=\"bp\">;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">max</span> <span class=\"n\">α</span> <span class=\"k\">with</span> <span class=\"n\">m</span><span class=\"bp\">;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span><span class=\"n\">hs</span><span class=\"o\">,</span><span class=\"n\">hl</span><span class=\"o\">,</span><span class=\"n\">is_satisfiable</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n    <span class=\"n\">apply_instance</span>\n  <span class=\"k\">else</span> <span class=\"k\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">is_satisfiable</span><span class=\"bp\">;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">min</span> <span class=\"n\">α</span> <span class=\"k\">with</span> <span class=\"n\">m</span><span class=\"bp\">;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span><span class=\"n\">hs</span><span class=\"o\">,</span><span class=\"n\">hl</span><span class=\"o\">,</span><span class=\"n\">is_satisfiable</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n    <span class=\"n\">apply_instance</span>\n</pre></div>",
        "id": 124869749,
        "sender_full_name": "Nima",
        "timestamp": 1523335435
    },
    {
        "content": "<p>Can you reproduce the definitions of <code>is_satisfiable</code>, <code>constraint</code>, <code>is_trivial</code>, <code>is_nonstrict</code> and <code>is_lower_bound</code> please?</p>",
        "id": 124869940,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523335760
    },
    {
        "content": "<p>I did not mean shorter proof using all these definitions. I thought just because those lines look a lot like each other, one should be able to merge them using something like <code>try</code>. But if I write <code>if ht : is_trivial c ∨ is_nonstrict c then</code> then I cannot even write <code>cases ht</code>, and I did not understand why.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">constraint</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">cnstr</span> <span class=\"bp\">::</span>\n  <span class=\"o\">(</span><span class=\"n\">trvk</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">triviality_kind</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">dirk</span> <span class=\"o\">:</span> <span class=\"n\">direction_kind</span> <span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">strk</span> <span class=\"o\">:</span> <span class=\"n\">strictness_kind</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">ndir</span> <span class=\"o\">:</span> <span class=\"n\">dirk</span> <span class=\"bp\">=</span> <span class=\"n\">direction_kind</span><span class=\"bp\">.</span><span class=\"n\">none</span>  <span class=\"bp\">↔</span> <span class=\"n\">trvk</span> <span class=\"bp\">=</span> <span class=\"n\">triviality_kind</span><span class=\"bp\">.</span><span class=\"n\">ktrv</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">nstr</span> <span class=\"o\">:</span> <span class=\"n\">strk</span> <span class=\"bp\">=</span> <span class=\"n\">strictness_kind</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"bp\">↔</span> <span class=\"n\">trvk</span> <span class=\"bp\">=</span> <span class=\"n\">triviality_kind</span><span class=\"bp\">.</span><span class=\"n\">ktrv</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_trivial</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">cnstr</span>  <span class=\"n\">ktrv</span>        <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">cnstr</span> <span class=\"o\">(</span><span class=\"n\">kdyn</span> <span class=\"n\">trv</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span>                            <span class=\"o\">:=</span> <span class=\"n\">false</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_lower_bound</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">cnstr</span> <span class=\"bp\">_</span>  <span class=\"n\">klower</span>        <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">cnstr</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">kdynam</span> <span class=\"n\">lower</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span>                              <span class=\"o\">:=</span> <span class=\"n\">false</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_nonstrict</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">cnstr</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>  <span class=\"n\">knst</span>      <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">cnstr</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">kdyn</span> <span class=\"n\">nst</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span>                          <span class=\"o\">:=</span> <span class=\"n\">false</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_satisfiable</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">is_trivial</span>     <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">choose</span> <span class=\"n\">α</span> <span class=\"bp\">≠</span> <span class=\"n\">none</span> <span class=\"k\">else</span>\n  <span class=\"k\">if</span>      <span class=\"n\">is_nonstrict</span>   <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"n\">true</span> <span class=\"k\">else</span>\n  <span class=\"k\">if</span>      <span class=\"n\">is_lower_bound</span> <span class=\"n\">c</span> <span class=\"k\">then</span>\n    <span class=\"k\">match</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">max</span> <span class=\"n\">α</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span>   <span class=\"o\">:=</span> <span class=\"n\">true</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">get_bound</span> <span class=\"n\">c</span> <span class=\"n\">ht</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span>\n    <span class=\"kn\">end</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">match</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">min</span> <span class=\"n\">α</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span>   <span class=\"o\">:=</span> <span class=\"n\">true</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">get_bound</span> <span class=\"n\">c</span> <span class=\"n\">ht</span>\n    <span class=\"kn\">end</span>\n</pre></div>",
        "id": 124870028,
        "sender_full_name": "Nima",
        "timestamp": 1523335923
    },
    {
        "content": "<p>I'd like to replace your big <code>if _ then _ else _ </code> with a <code>match</code> but I can't think of a nice way to do it. Instead, let's try this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">begin</span>\n   <span class=\"n\">refine</span> <span class=\"o\">(</span> <span class=\"k\">if</span> <span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">is_trivial</span>     <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"bp\">_</span>\n            <span class=\"k\">else</span> <span class=\"k\">if</span>      <span class=\"n\">is_nonstrict</span>   <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"bp\">_</span>\n            <span class=\"k\">else</span> <span class=\"k\">if</span>      <span class=\"n\">is_lower_bound</span> <span class=\"n\">c</span> <span class=\"k\">then</span>\n                <span class=\"k\">match</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">max</span> <span class=\"n\">α</span> <span class=\"k\">with</span>\n                 <span class=\"bp\">|</span> <span class=\"n\">none</span>   <span class=\"o\">:=</span> <span class=\"bp\">_</span>\n                 <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span>\n                <span class=\"kn\">end</span>\n            <span class=\"k\">else</span>\n                <span class=\"k\">match</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">min</span> <span class=\"n\">α</span> <span class=\"k\">with</span>\n                 <span class=\"bp\">|</span> <span class=\"n\">none</span>   <span class=\"o\">:=</span> <span class=\"bp\">_</span>\n                 <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span>\n                <span class=\"kn\">end</span> <span class=\"o\">)</span>\n   <span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">is_satisfiable</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">apply_instance</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 124870217,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523336381
    },
    {
        "content": "<p>Not very concise but less repetitive</p>",
        "id": 124870219,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523336399
    },
    {
        "content": "<p>As a side note: I suggest you pick more obvious names -- that is, names whose meaning is obvious rather than names that are easy to pick -- that names such as <code>knst</code>. I feel overly short names pose a puzzle to the reader.</p>",
        "id": 124870361,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523336644
    },
    {
        "content": "<p>Thanks a lot, seems something I can use often.<br>\nRegarding <code>refine</code>, I found this:</p>\n<blockquote>\n<p>The refine tactic applies the expression in question to the goal, but leaves any remaining metavariables for us to fill</p>\n</blockquote>\n<p>Is that what you are trying to do?<br>\nHow does <code>refine</code> knows inside <code>(..)</code> is supposed to be definition of <code>is_satisfiable</code> and so it can fill all the <code>_</code>?</p>",
        "id": 124870419,
        "sender_full_name": "Nima",
        "timestamp": 1523336842
    },
    {
        "content": "<blockquote>\n<p>As a side note: I suggest you pick more ...</p>\n</blockquote>\n<p>Sometimes I think I might be sick, since I prefer <code>stt</code> and <code>nst</code> over <code>strict</code> and <code>non_strict</code>, mainly because when you write them in two consecutive lines, they are nicely aligned! <span class=\"emoji emoji-1f643\" title=\"upside down face\">:upside_down_face:</span></p>",
        "id": 124870519,
        "sender_full_name": "Nima",
        "timestamp": 1523337073
    },
    {
        "content": "<p>Yes that's what I'm trying to do. Think of refine as applying type inference to <code>(if ... then _ else ... :  decidable (is_satisfiable c))</code>. Before we start, we don't know the type of <code>_</code> but then, we use the type of <code>dite</code> (the <code>if _ then _ else _</code> function) and we can figure out that <code>_</code> has type <code>decidable (is_satisfiable c)</code>. When we're done with type inference / type checking, we still don't know a term (or proof) to assign to <code>_</code> so building such a term becomes the goal of a subproof.</p>",
        "id": 124870612,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523337271
    },
    {
        "content": "<p>Symbols that line up do look nice! As a compromise, you may consider padding with spaces</p>",
        "id": 124870621,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523337315
    },
    {
        "content": "<p>OK, I copy-pasted your suggestion and I am receiving the following error (highlighted below the first <code>;</code>), is this a version issue? (I am on 3.3.0)</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">Tactic</span> <span class=\"n\">State</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">number</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span>\n<span class=\"err\">⊢</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_satisfiable</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n\n<span class=\"n\">don&#39;t</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">placeholder</span>\n<span class=\"kn\">context</span><span class=\"o\">:</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">number</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">is_trivial</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">match</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_satisfiable</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"err\">⊢</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_satisfiable</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">number</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span>\n<span class=\"err\">⊢</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_satisfiable</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 124870724,
        "sender_full_name": "Nima",
        "timestamp": 1523337585
    },
    {
        "content": "<p>I don't think your approach will work, Simon. First of all, <code>match</code> and <code>let match</code> have a tendency to be insulated from pexpr metavariable generation, so that they end up being immediate (term) goals even if they appear in a <code>refine</code></p>",
        "id": 124870774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523337672
    },
    {
        "content": "<p>Second, it is important for Nima's proof approach that the <code> number.max α </code> argument be exposed at the point of the <code>match</code>/<code>cases</code>, otherwise it won't be generalized. That means that the <code>unfold is_satisfiable</code> command has to come <em>before</em> the match attempt</p>",
        "id": 124870822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523337750
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I think you're right.</p>\n<p><span class=\"user-mention\" data-user-id=\"112062\">@Nima</span> Would you mind using <a href=\"https://gist.github.com/\" target=\"_blank\" title=\"https://gist.github.com/\">https://gist.github.com/</a> to share all the definitions needed to make the example work?</p>",
        "id": 124870826,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523337772
    },
    {
        "content": "<p>I'll try to make a proof work on my side and get back to you</p>",
        "id": 124870878,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523337879
    },
    {
        "content": "<p>Here is a link<br>\n<strong><a href=\"https://github.com/nima-roohi/lets-learn-some-lean\" target=\"_blank\" title=\"https://github.com/nima-roohi/lets-learn-some-lean\">lets-learn-some-lean</a></strong></p>",
        "id": 124871580,
        "sender_full_name": "Nima",
        "timestamp": 1523339487
    },
    {
        "content": "<p>In <code>number.lean</code>, you almost certainly want <code>:</code> instead of <code>:=</code> in the fields <code> neg₀</code> etc</p>",
        "id": 124871630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523339628
    },
    {
        "content": "<p>Sure,  thanks,</p>",
        "id": 124871678,
        "sender_full_name": "Nima",
        "timestamp": 1523339732
    },
    {
        "content": "<p>Here's my next suggestion:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span>  <span class=\"n\">is_satisfiable_is_decidable</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">is_satisfiable</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span> <span class=\"k\">if</span> <span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">is_trivial</span>     <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"bp\">_</span>\n            <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">is_nonstrict</span>   <span class=\"n\">c</span> <span class=\"k\">then</span> <span class=\"bp\">_</span>\n            <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">is_lower_bound</span> <span class=\"n\">c</span> <span class=\"k\">then</span>\n                <span class=\"bp\">_</span>\n            <span class=\"k\">else</span>\n                <span class=\"bp\">_</span> <span class=\"o\">)</span>\n   <span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">is_satisfiable</span><span class=\"o\">]</span>\n   <span class=\"bp\">;</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">max</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n   <span class=\"bp\">;</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">min</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n   <span class=\"bp\">;</span> <span class=\"n\">try</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">is_satisfiable</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n   <span class=\"bp\">;</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 124872748,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523341982
    },
    {
        "content": "<p>It could work without the <code>generalize</code>s but it would produce many more cases</p>",
        "id": 124872756,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523342037
    },
    {
        "content": "<p>why is that?</p>",
        "id": 124872798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523342054
    },
    {
        "content": "<p>also isn't the first <code>simp</code> redundant?</p>",
        "id": 124872799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523342067
    },
    {
        "content": "<p>Yeah, I just noticed that</p>",
        "id": 124872801,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523342089
    },
    {
        "content": "<p>also the parens around the <code>refine</code> should be unnecessary</p>",
        "id": 124872807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523342112
    },
    {
        "content": "<p>I mean: which first <code>simp</code>?</p>",
        "id": 124872808,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523342114
    },
    {
        "content": "<blockquote>\n<p>also the parens around the <code>refine</code> should be unnecessary</p>\n</blockquote>\n<p>I think it might create a precedence problem with <code>;</code></p>",
        "id": 124872859,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523342220
    },
    {
        "content": "<p>To answer your first question: it generates many more cases because we only need <code>cases number.max α</code> (resp. <code>cases number.min α</code>) in one branch out of four so, at the first <code>try</code>, without the <code>generalize</code>, we end up with <code>8</code> cases instead of <code>5</code> and, at the second try, we end up with <code>16</code> cases instead of <code>6</code>. We don't see all those cases but somehow knowing that they're there would give me nightmares</p>",
        "id": 124872982,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523342466
    },
    {
        "content": "<p>does <code>generalize</code> fail if the target expression is not present?</p>",
        "id": 124873026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523342549
    },
    {
        "content": "<p><code>generalize : number.max α = x</code> does but not <code>generalize h : number.max α = x</code></p>",
        "id": 124873080,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523342665
    },
    {
        "content": "<p>I kind of like this use of <code>refine</code>. Maybe a tactic such as <code>if_then_else [is_trivial c,is_nonstrict c,is_lower_bound c]</code> would be nicer though.</p>",
        "id": 124873185,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523342926
    },
    {
        "content": "<p>A remark on theorems like this, where you have to go through all the cases in your original definition: You have to do this every time you want to prove anything about <code>is_satisfiable</code>, which is why I prefer to write a custom recursor that does the match splits for you. You can then use it to define <code>is_satisfiable</code> itself, as well as theorems proving properties about it</p>",
        "id": 124873190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523342951
    },
    {
        "content": "<p>That make sense. Do you also write a tactic to apply the recursor?</p>",
        "id": 124873193,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523342997
    },
    {
        "content": "<p><code>by_cases</code> is the tactic version of <code>if then else</code></p>",
        "id": 124873194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523343000
    },
    {
        "content": "<p>Can you give it multiple conditions?</p>",
        "id": 124873237,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523343022
    },
    {
        "content": "<p>Not usually, I will either write it explicitly as a term or use <code>apply is_satisfiable.rec</code></p>",
        "id": 124873238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523343036
    },
    {
        "content": "<p>no</p>",
        "id": 124873239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523343043
    },
    {
        "content": "<p>I'm not convinced you will always have this structure anyway; it seems like it's best just to nest the <code>by_cases</code> applications</p>",
        "id": 124873246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523343110
    },
    {
        "content": "<p>you could also have <code>if h1 then if h2 then e1 else e2 else e3</code></p>",
        "id": 124873287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523343144
    },
    {
        "content": "<p>Thank you for the solution.<br>\nBy actually doing it, I can see <code>cases number.max α</code> creates a lot more cases than <code>generalize : number.max α = x, cases x</code>. But why (aren't they both cases on <code>none</code> and <code>some _</code>)?</p>",
        "id": 124873419,
        "sender_full_name": "Nima",
        "timestamp": 1523343504
    },
    {
        "content": "<p>In <code>generalize : number.max α = x, cases x</code>, <code>generalize : number.max α = x</code> fails if <code>number.max α</code> is not used in the goal and therefore <code>cases x</code> doesn't get executed. It's a complicated way of saying <code>cases number.max α</code> but only if I actually use <code>number.max α</code></p>",
        "id": 124873477,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523343617
    },
    {
        "content": "<p>I see,<br>\nAlso, is this <strong>recuroser</strong> a concept in lean or Haskell?</p>\n<blockquote>\n<p>... which is why I prefer to write a custom recursor that does the match splits for you. ...</p>\n</blockquote>\n<p>Theorem Proving in Lean, Section 7.1</p>\n<blockquote>\n<p>... It is also known as a recursor, and it is what makes the type “inductive” ...</p>\n</blockquote>\n<p>??</p>",
        "id": 124873546,
        "sender_full_name": "Nima",
        "timestamp": 1523343813
    },
    {
        "content": "<p>By the time it is used, <code>number.max α</code> has disappeared from all but one goal</p>",
        "id": 124873547,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523343818
    },
    {
        "content": "<p>The recursor is a Lean and dependent type theory concept</p>",
        "id": 124873636,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523343976
    },
    {
        "content": "<p>In Lean, an inductive type definition is not a first class citizen. It is translated into a bunch of constants and definitions.</p>",
        "id": 124873689,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523344147
    },
    {
        "content": "<p>Let's take a look at:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">my_option</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:</span> <span class=\"n\">my_option</span>\n <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">my_option</span>\n</pre></div>",
        "id": 124873691,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523344168
    },
    {
        "content": "<p>It's not limited to dependent types, of course. <span class=\"emoji emoji-1f642\" title=\"simple smile\">:simple_smile:</span></p>",
        "id": 124873696,
        "sender_full_name": "Sean Leather",
        "timestamp": 1523344185
    },
    {
        "content": "<p>Thanks for the precision!</p>",
        "id": 124873741,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523344219
    },
    {
        "content": "<p>Gotta keep you on your toes. <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>",
        "id": 124873747,
        "sender_full_name": "Sean Leather",
        "timestamp": 1523344262
    },
    {
        "content": "<p>If we type in </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"kn\">prefix</span> <span class=\"n\">my_option</span>\n</pre></div>\n\n\n<p>we see the constants and definitions that <code>my_option</code> is translated into</p>",
        "id": 124873752,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523344268
    },
    {
        "content": "<p>Sean will correct me if I'm wrong but I think only three of them are constants: two constructors</p>\n<div class=\"codehilite\"><pre><span></span>my_option.none : Π (α : Type u_1), my_option α\nmy_option.some : Π {α : Type u_1}, α → my_option α\n</pre></div>\n\n\n<p>and one recursor</p>\n<div class=\"codehilite\"><pre><span></span>my_option.cases_on : Π {α : Type u_1} {C : my_option α → Sort l} (n : my_option α),\n  C (my_option.none α) → (Π (a : α), C (my_option.some a)) → C n\n</pre></div>\n\n\n<p>(I just realized that <code>no_confusion</code> is actually a definition)</p>",
        "id": 124873906,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523344631
    },
    {
        "content": "<p>The recursor basically tells you how to pattern match on <code>my_option</code>. When you pattern match on <code>opt : my_option α</code>, you're constructing a value of <code>C opt</code> (for some <code>C</code>) and you have to provide a way to construct <code>C opt</code> in the case where <code>opt</code> is <code>none</code> and in the case where <code>opt</code> is <code>some a</code></p>",
        "id": 124873964,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523344785
    },
    {
        "content": "<p>Actually the constant is <code>my_option.rec_on</code>, and of course <code>my_option</code> itself is also a constant</p>",
        "id": 124874009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523344819
    },
    {
        "content": "<p><code>rec_on</code> should be a definition as well.  <code>rec</code> is the recursor constant.</p>",
        "id": 124874019,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1523344876
    },
    {
        "content": "<p>Aren't <code>rec_on</code> and <code>cases_on</code> defined in term of each other?</p>",
        "id": 124874021,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523344879
    },
    {
        "content": "<p><code>rec_on</code> and <code>cases_on</code> are the same for a nonrecursive inductive type</p>",
        "id": 124874026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523344916
    },
    {
        "content": "<p>What I mean is, for recursive inductive types, do we actually have two separate constants for <code>cases</code> and <code>rec</code>?</p>",
        "id": 124874078,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523345029
    },
    {
        "content": "<p>there is no <code>cases</code> for some reason, just <code>cases_on</code>, and no, <code>rec</code> is the only elimination-like constant, <code>cases_on</code> just ignores the inductive hypotheses</p>",
        "id": 124874127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523345131
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> <a href=\"https://xenaproject.wordpress.com/2018/03/24/no-confusion-over-no_confusion/\" target=\"_blank\" title=\"https://xenaproject.wordpress.com/2018/03/24/no-confusion-over-no_confusion/\">https://xenaproject.wordpress.com/2018/03/24/no-confusion-over-no_confusion/</a> -- <code>no_confusion</code> is defined in terms of the eliminator, but I always found the definition rather obscure. I wrote some notes about it in the link.</p>",
        "id": 124874175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523345199
    },
    {
        "content": "<p>Ok, that's what I thought. So I cut some cornets in my explanation by making it about <code>cases_on</code> instead of <code>rec</code></p>",
        "id": 124874176,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523345206
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thanks! I was sure it had to be postulated too. I guess i got confused <span class=\"emoji emoji-1f61d\" title=\"stuck out tongue closed eyes\">:stuck_out_tongue_closed_eyes:</span></p>",
        "id": 124874189,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523345262
    },
    {
        "content": "<p>Just for the sake of completeness and posterity, is this what everybody is seeing after <code>#print prefix my_option</code>?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">my_option</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">my_option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">my_option</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n  <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">n</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">has_sizeof_inst</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">α_inst</span> <span class=\"o\">:</span> <span class=\"n\">has_sizeof</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"n\">has_sizeof</span> <span class=\"o\">(</span><span class=\"n\">my_option</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">no_confusion</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v1</span> <span class=\"n\">v2</span> <span class=\"o\">:</span> <span class=\"n\">my_option</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">v1</span> <span class=\"bp\">=</span> <span class=\"n\">v2</span> <span class=\"bp\">→</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">no_confusion_type</span> <span class=\"n\">P</span> <span class=\"n\">v1</span> <span class=\"n\">v2</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">no_confusion_type</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">},</span> <span class=\"n\">Sort</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">my_option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">my_option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">l</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">),</span> <span class=\"n\">my_option</span> <span class=\"n\">α</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"bp\">.</span><span class=\"n\">inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">},</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">true</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"bp\">.</span><span class=\"n\">inj_arrow</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">},</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span> <span class=\"o\">⦃</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">l</span><span class=\"o\">⦄,</span> <span class=\"o\">(</span><span class=\"n\">true</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"bp\">.</span><span class=\"n\">inj_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">},</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"bp\">.</span><span class=\"n\">sizeof_spec</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">α_inst</span> <span class=\"o\">:</span> <span class=\"n\">has_sizeof</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">sizeof</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">my_option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">l</span><span class=\"o\">},</span>\n  <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">my_option</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"n\">n</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">my_option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">my_option</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n  <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">none</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">n</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">sizeof</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">α_inst</span> <span class=\"o\">:</span> <span class=\"n\">has_sizeof</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"n\">my_option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">my_option</span> <span class=\"n\">α</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"bp\">.</span><span class=\"n\">inj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">a_1</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a_1</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"bp\">.</span><span class=\"n\">inj_arrow</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">a_1</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span> <span class=\"o\">⦃</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">l</span><span class=\"o\">⦄,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a_1</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"bp\">.</span><span class=\"n\">inj_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">a_1</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a_1</span><span class=\"o\">)</span>\n<span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"bp\">.</span><span class=\"n\">sizeof_spec</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">α_inst</span> <span class=\"o\">:</span> <span class=\"n\">has_sizeof</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">sizeof</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">my_option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeof</span> <span class=\"n\">a</span>\n</pre></div>",
        "id": 124874229,
        "sender_full_name": "Sean Leather",
        "timestamp": 1523345284
    },
    {
        "content": "<p>Yes</p>",
        "id": 124874240,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523345364
    },
    {
        "content": "<p>Awesome. I haven't upgraded Lean in a while, so some things may have changed. <span class=\"emoji emoji-1f642\" title=\"simple smile\">:simple_smile:</span></p>",
        "id": 124874243,
        "sender_full_name": "Sean Leather",
        "timestamp": 1523345380
    },
    {
        "content": "<p>Or rather, until other people answer: I don't know</p>",
        "id": 124874244,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523345387
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> here's an indication that it doesn't have to be postulated -- once you have <code>cases</code> for <code>nat</code> you can define <code>is_zero</code> by <code>is_zero 0 = tt</code> and <code>is_zero (succ n) = ff</code> and then prove that zero can't be a successor that way.</p>",
        "id": 124874245,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523345393
    },
    {
        "content": "<p>Is this what _everybody_ is seeing??</p>",
        "id": 124874287,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523345416
    },
    {
        "content": "<p>I don't know either.</p>",
        "id": 124874290,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523345423
    },
    {
        "content": "<p>One response was enough for me, it seems.</p>",
        "id": 124874297,
        "sender_full_name": "Sean Leather",
        "timestamp": 1523345440
    },
    {
        "content": "<p>[i.e. it's what I am seeing]</p>",
        "id": 124874298,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523345440
    },
    {
        "content": "<blockquote>\n<p>Is this what _everybody_ is seeing??</p>\n</blockquote>\n<p>we all know you teach m1f</p>",
        "id": 124874302,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523345458
    },
    {
        "content": "<p>I don't. What is m1f?</p>",
        "id": 124874311,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523345479
    },
    {
        "content": "<p>I only required an extistential result, rather than a universal quantification.</p>",
        "id": 124874312,
        "sender_full_name": "Sean Leather",
        "timestamp": 1523345480
    },
    {
        "content": "<p>m1f = introduction to proof course</p>",
        "id": 124874317,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523345512
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> one should probably change the course name then</p>",
        "id": 124874358,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523345528
    },
    {
        "content": "<p>So let's rephrase then: does there exist a participant other than myself that also sees the following output ... ?</p>",
        "id": 124874359,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523345529
    },
    {
        "content": "<p>Yes.</p>",
        "id": 124874360,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523345538
    },
    {
        "content": "<p>Yes</p>",
        "id": 124874361,
        "sender_full_name": "Nima",
        "timestamp": 1523345545
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> I think it's not only the <a href=\"#narrow/stream/113488-general/subject/constructing.20proofs.20by.20hand/near/124872856\" title=\"#narrow/stream/113488-general/subject/constructing.20proofs.20by.20hand/near/124872856\">dictionary</a> that uses English to describe English. We also do that here.</p>",
        "id": 124874422,
        "sender_full_name": "Sean Leather",
        "timestamp": 1523345662
    },
    {
        "content": "<p>doom day's clock is ticking</p>",
        "id": 124874443,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523345717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112062\">@Nima</span> I'm just curious what your background is relevant to Lean. Have you worked with functional programming or proof assistants?</p>",
        "id": 124874490,
        "sender_full_name": "Sean Leather",
        "timestamp": 1523345766
    },
    {
        "content": "<p>Alright! Enough excitement for today. I have to wake up in a few hours and get back to writing. Good &lt;&lt;insert current period of the day of your timezone here&gt;&gt; everyone!</p>",
        "id": 124874634,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523346027
    },
    {
        "content": "<p>And good night to you, <span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span>!</p>",
        "id": 124874652,
        "sender_full_name": "Sean Leather",
        "timestamp": 1523346073
    },
    {
        "content": "<p>Good night. <span class=\"user-mention\" data-user-id=\"110045\">@Sean Leather</span> has returned too, neat! Hello.</p>",
        "id": 124874654,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1523346081
    },
    {
        "content": "<p>You can check time zones on Zulip I noticed.</p>",
        "id": 124874656,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523346089
    },
    {
        "content": "<p>interesting</p>",
        "id": 124874658,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523346100
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110027\">@Moses Schönfinkel</span> Hello, hello! You don't have any news on Lean 5 to tell me about, do you? <span class=\"emoji emoji-1f61f\" title=\"worried\">:worried:</span></p>",
        "id": 124874661,
        "sender_full_name": "Sean Leather",
        "timestamp": 1523346117
    },
    {
        "content": "<p>click on the down-arrow which appears when you mouse over a person's name on the right</p>",
        "id": 124874663,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523346119
    },
    {
        "content": "<p>and you see their local time</p>",
        "id": 124874703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523346131
    },
    {
        "content": "<p>I have been having some issues with my crystal ball ever since my cat cracked it.</p>",
        "id": 124874704,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1523346151
    },
    {
        "content": "<p>although Kenny went from Lon to HK and didn't update his</p>",
        "id": 124874706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523346159
    },
    {
        "content": "<blockquote>\n<p>functional programming:</p>\n</blockquote>\n<p>Only Scala, which based on what I see, I would not be surprised if people find it insulting that I put Scala and FP side by side ;)</p>\n<blockquote>\n<p>proof assistants</p>\n</blockquote>\n<p>I worked with PVS, for example, I have a paper in which I said something is wrong and this is the right version. In order to be more confident, I proved some of the stuff in PVS (about 25K proof commands, which of course could be very inefficient proofs)</p>",
        "id": 124874708,
        "sender_full_name": "Nima",
        "timestamp": 1523346179
    },
    {
        "content": "<blockquote>\n<p>although Kenny went from Lon to HK and didn't update his</p>\n</blockquote>\n<p>done</p>",
        "id": 124874716,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523346212
    },
    {
        "content": "<p>Scala is the best way to target JVM.</p>",
        "id": 124874766,
        "sender_full_name": "Moses Schönfinkel",
        "timestamp": 1523346289
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112062\">@Nima</span> Would you mind giving us a reference to your paper? I did some PVS too and I'd like to see what you did</p>",
        "id": 124874825,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523346412
    },
    {
        "content": "<p>Revisiting MITL to Fix Decision Procedures <br>\n<a href=\"https://link.springer.com/chapter/10.1007/978-3-319-73721-8_22\" target=\"_blank\" title=\"https://link.springer.com/chapter/10.1007/978-3-319-73721-8_22\">https://link.springer.com/chapter/10.1007/978-3-319-73721-8_22</a><br>\nProofs can be found here (link is also in the paper)<br>\n<a href=\"http://uofi.box.com/v/PVSProofsOfMITL\" target=\"_blank\" title=\"http://uofi.box.com/v/PVSProofsOfMITL\">http://uofi.box.com/v/PVSProofsOfMITL</a></p>",
        "id": 124874898,
        "sender_full_name": "Nima",
        "timestamp": 1523346600
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 124874946,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523346642
    },
    {
        "content": "<p>Ok, now I'm really off</p>",
        "id": 124874949,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523346649
    },
    {
        "content": "<p>I have a type <code>constraint</code> which represents something like <code>bnd &lt; x</code> or <code>x &lt; bnd</code>.<br>\nI have a function <code>sem</code> (semantics) that receives a constraint as input and return a predicate one <code>ℕ</code> as output (the set of values satisfied by the constraint). Let <code>c</code> be a constraint. I would like to be able to write <code>x : c</code>. For that, I have the following code, but I am not sure about <code>{x // sem S x}</code>. Is there a mistake or a better way there?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">constraint</span>\n<span class=\"bp\">|</span> <span class=\"n\">low</span> <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">upp</span> <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kn\">open</span> <span class=\"n\">constraint</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sem</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">c</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">low</span> <span class=\"n\">bnd</span> <span class=\"o\">:=</span> <span class=\"n\">bnd</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">upp</span> <span class=\"n\">bnd</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bnd</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">constraint_to_pred</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">constraint</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">⟨λ</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">sem</span> <span class=\"n\">c</span> <span class=\"n\">a</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">constraint_to_sort</span><span class=\"o\">:</span>\n  <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">constraint</span> <span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">sem</span> <span class=\"n\">S</span> <span class=\"n\">x</span><span class=\"o\">}}</span>\n</pre></div>\n\n\n<p>If everything is fine, how do I finish the following example:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">low</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">admit</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 124899110,
        "sender_full_name": "Nima",
        "timestamp": 1523388400
    },
    {
        "content": "<p>It looks good to me except that I don't know that you actually need the <code>has_coe</code> instance</p>",
        "id": 124899250,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523388623
    },
    {
        "content": "<p>For the proof, you can try:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">low</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold_coes</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">admit</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 124899258,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523388639
    },
    {
        "content": "<p>It should unfold all the coercions and then you should see a clear way to finishing the proof</p>",
        "id": 124899280,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523388699
    },
    {
        "content": "<p>If I comment the first instance then the second one won't type check (may be because of <code>{x // sem S x}</code> that I prefer not to have any way)</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at field &#39;coe&#39;\n  λ (S : constraint), {x // ⁇}\nhas type\n  constraint → Sort (max 1 ?) : Type (max 1 ?)\nbut is expected to have type\n  constraint → Type ? : Type (?+1)\n</pre></div>\n\n\n<p>If I don't comment the first instance then I will receive the following error: <code>unknown identifier 'unfold_coes'</code></p>",
        "id": 124899441,
        "sender_full_name": "Nima",
        "timestamp": 1523388948
    },
    {
        "content": "<p>You need <code>import tactic</code></p>",
        "id": 124899492,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523389011
    },
    {
        "content": "<p>If you want to remove the first instance, I think you need to change the second to:</p>\n<div class=\"codehilite\"><pre><span></span>instance constraint_to_sort:\n  has_coe_to_sort (constraint ) :=\n  {S := Sort*, coe := λ S, {x // sem S x}}\n</pre></div>",
        "id": 124899573,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523389161
    },
    {
        "content": "<p>OK, I don't know what happened, but removing the first instance does not give me error any more</p>\n<blockquote>\n<p>You need import tactic</p>\n</blockquote>\n<p>Do you mean <code>open tactic</code>? Line <code>import init.meta.tactic</code> will type check, but <code>import tactic</code> will not.</p>",
        "id": 124899844,
        "sender_full_name": "Nima",
        "timestamp": 1523389578
    },
    {
        "content": "<p>You're not using <code>leanpkg</code> and <code>mathlib</code> right? Now would be a good time to bring them in</p>",
        "id": 124899858,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523389639
    },
    {
        "content": "<p>In a terminal where your sources are, type in:</p>\n<div class=\"codehilite\"><pre><span></span>leanpkg init lets-learn-some-lean\nleanpkg add leanprover/mathlib\n</pre></div>",
        "id": 124899909,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523389723
    },
    {
        "content": "<p>OK, I have imported tactic. But I still receive the same error.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">constraint</span>\n<span class=\"bp\">|</span> <span class=\"n\">low</span> <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">upp</span> <span class=\"o\">(</span><span class=\"n\">bnd</span><span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kn\">open</span> <span class=\"n\">constraint</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sem</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">constraint</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">c</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">low</span> <span class=\"n\">bnd</span> <span class=\"o\">:=</span> <span class=\"n\">bnd</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"n\">upp</span> <span class=\"n\">bnd</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bnd</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- this instance seems redundant for now</span>\n<span class=\"kn\">instance</span> <span class=\"n\">constraint_to_pred</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">constraint</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">⟨λ</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">sem</span> <span class=\"n\">c</span> <span class=\"n\">a</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">constraint_to_sort</span><span class=\"o\">:</span>\n  <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">constraint</span> <span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">sem</span> <span class=\"n\">S</span> <span class=\"n\">x</span><span class=\"o\">}}</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">low</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold_coes</span><span class=\"o\">,</span> <span class=\"c1\">-- ERROR: unknown identifier &#39;unfold_coes&#39;</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">admit</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I think dependency is successfully created. For example, I can make the following work perfectly fine.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H₁</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">finish</span>\n</pre></div>\n\n\n<p>But no luck with <code>unfold_coes</code></p>",
        "id": 124902193,
        "sender_full_name": "Nima",
        "timestamp": 1523392950
    },
    {
        "content": "<p>Inside a proof, I have two cases. In case 1, I prove something about lower bound and in case 2, I prove something about upper bound. Each case has multiple steps, but the structure is identical (in order to obtain the second part from the first part, all I need to do is replace word <code>mid</code> with <code>max</code>).<br>\nHow do I write both these cases without practically writing a part of the proof twice?</p>",
        "id": 124970239,
        "sender_full_name": "Nima",
        "timestamp": 1523512890
    },
    {
        "content": "<p>where is the word <code>mid</code> and <code>max</code>?</p>",
        "id": 124970283,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523512936
    },
    {
        "content": "<p>could you post your code?</p>",
        "id": 124970284,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523512946
    },
    {
        "content": "<p>The whole code is too long, but here is the part I was talking about (I just wanted to see what the general approach is in these situations. Do you create a whole new <code>meta</code> function, or you can do something inline):</p>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"n\">by_cases</span> <span class=\"n\">is_lower_bound</span> <span class=\"n\">c</span> <span class=\"k\">with</span> <span class=\"n\">hl</span> <span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hl</span><span class=\"o\">],</span>\n  <span class=\"k\">begin</span>\n    <span class=\"k\">have</span> <span class=\"n\">hl&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">is_lower_bound_is_lower</span> <span class=\"n\">c</span> <span class=\"n\">ht</span><span class=\"o\">)</span> <span class=\"n\">hl</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hm</span> <span class=\"o\">:=</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">min_prop</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">min</span> <span class=\"n\">α</span> <span class=\"k\">with</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">unfold</span> <span class=\"n\">min_prop</span> <span class=\"n\">at</span> <span class=\"n\">hm</span><span class=\"o\">,</span>\n    <span class=\"k\">begin</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">hm</span> <span class=\"n\">bnd</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">hm</span> <span class=\"k\">with</span> <span class=\"n\">m&#39;</span> <span class=\"n\">hm&#39;</span><span class=\"o\">,</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">h₁</span> <span class=\"n\">m&#39;</span><span class=\"o\">,</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">sem</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span><span class=\"n\">hb</span><span class=\"o\">,</span><span class=\"n\">hl&#39;</span><span class=\"o\">,</span><span class=\"n\">hs&#39;</span><span class=\"o\">,</span><span class=\"n\">sem</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">lt_iff_le_not_le</span> <span class=\"n\">hm&#39;</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"n\">this</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n      <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n    <span class=\"kn\">end</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">hm</span> <span class=\"n\">bnd</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h₁</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">sem</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span><span class=\"n\">hb</span><span class=\"o\">,</span><span class=\"n\">hl&#39;</span><span class=\"o\">,</span><span class=\"n\">hs&#39;</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">sem</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">le_antisymm</span> <span class=\"n\">hm</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">],</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n<span class=\"c1\">-- next case replace words &quot;lower&quot; with &quot;upper&quot; and &quot;min&quot; with &quot;max&quot;</span>\n</pre></div>",
        "id": 124970345,
        "sender_full_name": "Nima",
        "timestamp": 1523513128
    },
    {
        "content": "<p>You are not likely to be able to simplify this unless you formalize the symmetry between <code>min</code> and <code>max</code> here</p>",
        "id": 124970386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523513172
    },
    {
        "content": "<p>You can try to extract a lemma with something with the same type as <code>min</code> and <code>max</code></p>",
        "id": 124970390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523513222
    },
    {
        "content": "<p>If I don't extract any lemma, is there any way, I can write this proof but replace for example <code>(is_lower_bound_is_lower c ht)</code> with a placeholder and later fill that placeholder twice?</p>",
        "id": 124970450,
        "sender_full_name": "Nima",
        "timestamp": 1523513385
    },
    {
        "content": "<p>You can run the same tactic script twice. As long as you set up the state (before or after) with suitable modifications, you can do this kind of thing</p>",
        "id": 124970504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523513472
    },
    {
        "content": "<p>For example, you could have <code>have lem := is_lower_bound_is_lower</code> in one branch and <code>have lem := is_upper_bound_is_upper</code> in the other branch, and then run a script that refers to <code>lem</code> which means different things in the two branches</p>",
        "id": 124970548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523513548
    },
    {
        "content": "<p>gotcha, thanks</p>",
        "id": 124970597,
        "sender_full_name": "Nima",
        "timestamp": 1523513687
    },
    {
        "content": "<p>or just copy it once already</p>",
        "id": 124970598,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523513689
    },
    {
        "content": "<p>How do I combine the following two:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">unfold</span> <span class=\"n\">f1</span> <span class=\"n\">at</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"c1\">-- only at h1 and h2</span>\n<span class=\"n\">unfold</span> <span class=\"n\">f1</span> <span class=\"c1\">-- only at goal (?)</span>\n</pre></div>",
        "id": 124971067,
        "sender_full_name": "Nima",
        "timestamp": 1523514758
    },
    {
        "content": "<p><code>unfold f1</code> can also be written <code>unfold f1 at |-</code>, and you can do both with <code>unfold f1 at h1 h2 |-</code></p>",
        "id": 124971268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523515221
    },
    {
        "content": "<p>there's also a unicode version of <code>|-</code></p>",
        "id": 124971269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523515233
    },
    {
        "content": "<p>thanks</p>",
        "id": 124971554,
        "sender_full_name": "Nima",
        "timestamp": 1523515898
    },
    {
        "content": "<p>I wonder if <code>wlog</code> might be of help for your repetition problem. Like Mario said, you'd need to formalize the symmetry some more but maybe <code>wlog</code> can do some of that</p>",
        "id": 124981003,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523533838
    },
    {
        "content": "<p>Sorry, but how do I finish this example?</p>\n<div class=\"codehilite\"><pre><span></span>class number := (aa1 := tt)\nexample [nn:number] : number.aa1 = tt := sorry\n</pre></div>",
        "id": 125005327,
        "sender_full_name": "Nima",
        "timestamp": 1523568543
    },
    {
        "content": "<p>Try <code>by simp!</code></p>",
        "id": 125005396,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523568609
    },
    {
        "content": "<p>(the <code>!</code> is part of the proof)</p>",
        "id": 125005400,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523568629
    },
    {
        "content": "<p>I got error: <code>command expected</code></p>",
        "id": 125005417,
        "sender_full_name": "Nima",
        "timestamp": 1523568669
    },
    {
        "content": "<p>Restart your Lean server (C-c C-r in emacs)</p>",
        "id": 125005472,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523568727
    },
    {
        "content": "<p>I am on VS Code, restarted the whole program. But no luck!</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">number</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">aa1</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span><span class=\"o\">)</span>\n<span class=\"kn\">example</span> <span class=\"o\">[</span><span class=\"n\">nn</span><span class=\"o\">:</span><span class=\"n\">number</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">aa1</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"bp\">!</span>  <span class=\"c1\">-- error command expected</span>\n</pre></div>\n\n\n<p>Lean 3.3.0</p>",
        "id": 125005522,
        "sender_full_name": "Nima",
        "timestamp": 1523568838
    },
    {
        "content": "<p>Oh! 3.3.0 ...</p>",
        "id": 125005571,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523568862
    },
    {
        "content": "<p>ok, one sec</p>",
        "id": 125005574,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523568865
    },
    {
        "content": "<p>ok <code>by refl</code> should do it</p>",
        "id": 125005580,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523568889
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">invalid</span> <span class=\"n\">apply</span> <span class=\"n\">tactic</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n  <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">aa1</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span>\n<span class=\"k\">with</span>\n  <span class=\"err\">?</span><span class=\"n\">m_2</span> <span class=\"bp\">=</span> <span class=\"err\">?</span><span class=\"n\">m_2</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">nn</span> <span class=\"o\">:</span> <span class=\"n\">number</span>\n<span class=\"err\">⊢</span> <span class=\"n\">number</span><span class=\"bp\">.</span><span class=\"n\">aa1</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span>\n</pre></div>",
        "id": 125005670,
        "sender_full_name": "Nima",
        "timestamp": 1523569011
    },
    {
        "content": "<p>What happens if you do:</p>\n<div class=\"codehilite\"><pre><span></span>begin\n  unfold number.aa1\nend\n</pre></div>",
        "id": 125005701,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523569062
    },
    {
        "content": "<p>Sorry, I just got what is happening. The proof shouldn't work</p>",
        "id": 125005794,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523569192
    },
    {
        "content": "<p>Yep, it does not.</p>",
        "id": 125005855,
        "sender_full_name": "Nima",
        "timestamp": 1523569232
    },
    {
        "content": "<p>In <code>class number := (aa1 := tt)</code>, <code>aa1</code> is a field of type <code>bool</code> whose default value (when you build an instance) is <code>tt</code>. You can still specify a different value so you don't know for sure that <code>aa1</code> is <code>tt</code> in your example</p>",
        "id": 125005877,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523569306
    },
    {
        "content": "<p>What are you trying to do with that example? I suspect you're misusing classes</p>",
        "id": 125005923,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523569347
    },
    {
        "content": "<p>First, how do I change a default value? Is this like a programming language that I can assign value to variables??<br>\nI wanted to show <code>number.has_prev a</code> is decidable for any value <code>a</code>. But I guess you are saying value of <code>has_prev</code> can be changed later (can mark it like a constant! I am lost)</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">(</span><span class=\"n\">has_prev</span>  <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">dense</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span> <span class=\"bp\">∧</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">min</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 125005995,
        "sender_full_name": "Nima",
        "timestamp": 1523569500
    },
    {
        "content": "<p>No, this is not about mutating variables. Think of <code>class number</code> as a type declaration:</p>\n<div class=\"codehilite\"><pre><span></span>@[class]\nstructure number :=\n  (aa1 : bool)\n</pre></div>\n\n\n<p>the <code>:= tt</code> part allows you to write:</p>\n<div class=\"codehilite\"><pre><span></span>instance : number :=\n{ }\n</pre></div>\n\n\n<p>and it is taken to mean:</p>\n<div class=\"codehilite\"><pre><span></span>instance : number :=\n{ aa1 := tt }\n</pre></div>",
        "id": 125006160,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523569739
    },
    {
        "content": "<p>ooo!</p>",
        "id": 125006189,
        "sender_full_name": "Nima",
        "timestamp": 1523569794
    },
    {
        "content": "<p>And in keeping with desugaring the <code>class</code> / <code>instance</code> syntax, the latter is equivalent to:</p>\n<div class=\"codehilite\"><pre><span></span>@[instance]\ndef my_number_instance : number :=\n{ aa1 := tt }\n</pre></div>",
        "id": 125006246,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523569827
    },
    {
        "content": "<p>What was I thinking!!<br>\nThanks a lot.</p>",
        "id": 125006293,
        "sender_full_name": "Nima",
        "timestamp": 1523569902
    },
    {
        "content": "<p>No worries</p>",
        "id": 125006340,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523569927
    },
    {
        "content": "<p>How do I finish this example without using <code>finish</code>?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">param</span> <span class=\"bp\">|</span> <span class=\"n\">p1</span> <span class=\"bp\">|</span> <span class=\"n\">p2</span> <span class=\"bp\">|</span> <span class=\"n\">p3</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">param</span><span class=\"bp\">.</span><span class=\"n\">p1</span> <span class=\"bp\">=</span> <span class=\"n\">param</span><span class=\"bp\">.</span><span class=\"n\">p2</span> <span class=\"bp\">→</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 125121921,
        "sender_full_name": "Nima",
        "timestamp": 1523825325
    },
    {
        "content": "<p><code>example : param.p1 = param.p2 → false := λ h, param.no_confusion h</code></p>",
        "id": 125121986,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1523825519
    },
    {
        "content": "<p>you can also use <code>by injection h</code></p>",
        "id": 125122032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1523825616
    },
    {
        "content": "<p>Thank you both</p>",
        "id": 125122172,
        "sender_full_name": "Nima",
        "timestamp": 1523825908
    },
    {
        "content": "<p>I think you could create new topics, instead of always reusing the same one. It would make it easier for other readers to decide whether they could learn something from your questions.</p>",
        "id": 125122183,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1523825974
    },
    {
        "content": "<p>That is definitely an option. However, most (if not all) of my questions are trivially answered by experienced users like Simon or Mario. I look at \"Fresh off the boat\" as a topic that contains questions a new user like me with a very little experience might ask. Nothing deep, but they come from everywhere (for example, because I read a book and that book talks about lots of different things). That is how I see them related. </p>\n<p>Of course, another option is to create one topic for basically every one of them. The point is, 1) I don't know the answer is in <code>no_confusion</code> or <code>injection</code>, so most likely the topic I would create won't have a meaningful representation of its content. 2) I doubt that a user will learn much just by reading a single one of them. Either, they already know the answer, or if they don't, they are likely to benefit from similar questions that now they would not know how to find.</p>\n<p>I agree, for some concepts having a separate topic makes a lot of sense. For example, Code Generation, Meta Programming, mathlib (may be each with subtopics as well). But I don't see enough benefit to bloat list of topic by wanting every topic to be as specific as possible. Maybe having both kinds would be more helpful. Some are general-nothing-deep-scattered-subjects and some focused-deep-into-a-concent topics.</p>\n<p>Please let me know what you think. If I see you guys prefer separate topics anyway, I will do my best to post that way.</p>",
        "id": 125123108,
        "sender_full_name": "Nima",
        "timestamp": 1523827836
    },
    {
        "content": "<p>I think you can already pick a good topic by describing the problem that you're having. In this case you could say \"how to I prove that different constructors form distinct values\". I don't think the topic should contain the answer to your question because, if someone has the same problem as you, they won't know to look in the thread you created.</p>",
        "id": 125123341,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523828238
    },
    {
        "content": "<p>You can also pick a very bad topic name and change it later as suggestions come in</p>",
        "id": 125123382,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1523828298
    },
    {
        "content": "<p>No problem,<br>\nThanks for letting me know your thought.</p>",
        "id": 125123395,
        "sender_full_name": "Nima",
        "timestamp": 1523828388
    }
]
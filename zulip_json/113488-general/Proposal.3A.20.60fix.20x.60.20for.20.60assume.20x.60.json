[
    {
        "content": "<p>I would like to propose a small extension to Lean's structure language, namely <code>fix</code> as an alias for <code>assume</code>, intended to be used for data (as opposed to propositions).</p>\n<p>Where mathematicians would write \"Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> be a real number. Assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">x &gt; 0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">x &gt; 3</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>&gt;</mo><mn>9</mn></mrow><annotation encoding=\"application/x-tex\">x^2 &gt; 9</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.853208em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">9</span></span></span></span>, in Lean we would write</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">assume</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"k\">show</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"err\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">...</span>\n</pre></div>\n\n\n<p>My proposal is to allow <code>fix</code>, so we could write</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">fix</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"k\">show</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"err\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">9</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">...</span>\n</pre></div>\n\n\n<p>\"Fix x\" is often used in mathematics as a synonym for \"let x be a ...\", especially in proofs and at the beginning of a section (\"in this section, we fix ...\"). It's short and works well when we don't write the type, like above. <code>fix</code>-<code>assume</code>-<code>show</code> is also the Isabelle/Isar idiom.</p>\n<p>Of course, Lean has Curry-Howard, but in other places identical or nearly identical pairs of commands exist, e.g. <code>constant</code> vs. <code>axiom</code>, <code>let</code> vs. <code>have</code>, <code>def</code> vs. <code>lemma</code>. Why not <code>fix</code> vs. <code>assume</code>?</p>\n<p>In <a href=\"https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf\" title=\"https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf\">The Hitchhiker's Guide to Logical Verification</a>, which is used to teach interactive theorem proving, we introduced <code>fix</code> as an abbreviation for <code>assume</code>. It makes teaching easier, I find. See e.g. the schematic example on p. 35 (45 including the forematter).</p>\n<p>What are your thoughts? <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  wouldn't it help you when golfing? <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>,  <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> , <span class=\"user-mention\" data-user-id=\"133635\">@Sander Dahmen</span> , and of course Buzzard et al. (<span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> , <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> ),  wouldn't it help you write nicer looking math proofs?</p>",
        "id": 194764067,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587449699
    },
    {
        "content": "<p>I think this actually used to exist</p>",
        "id": 194764086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587449728
    },
    {
        "content": "<p>I prefer <code>\\lam</code> for golfing</p>",
        "id": 194764097,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587449745
    },
    {
        "content": "<p>Personally, I just use <code>\\lam</code> always and don't think about it. I don't like superfluous options. But <code>fix</code> for me has problematic connotations from its usage in Coq</p>",
        "id": 194764183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587449817
    },
    {
        "content": "<p>My recollection is that around lean 2 / early lean 3, there were a lot more synonymous keywords, like <code>hypothesis</code>, <code>conjecture</code> etc, including <code>fix</code> and <code>assume</code> as synonyms for <code>\\lam</code>. This list was later cut down because too many options lead to analysis paralysis - people need to know all the synonyms, and know that they <em>are</em> synonyms. For me even <code>assume</code> is not good because of this.</p>",
        "id": 194764480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450143
    },
    {
        "content": "<p>For example <code>def</code> and <code>theorem</code> are subtly different, but <code>lemma</code> is the same as <code>theorem</code> and <code>definition</code> is the same as <code>def</code>. Why?</p>",
        "id": 194764503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450190
    },
    {
        "content": "<p>Yes, I understand that \"analysis paralysis\" can be a problem.</p>",
        "id": 194764515,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587450203
    },
    {
        "content": "<p>Is it possible to declare <code>fix</code> as a notation for <code>\\lam</code>? I think it can be</p>",
        "id": 194764594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450290
    },
    {
        "content": "<p>I'm also not a fan of aliases in general. But I'm ready to make an exception for Curry-Howard. Concerning <code>lemma</code> (et al.) vs. <code>def</code> (et al.), I wish the small difference had been made on the universe (<code>Type _</code> or <code>Prop</code>), so these could be considered \"Curry-Howard aliases\".</p>",
        "id": 194764601,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587450304
    },
    {
        "content": "<p>Yes, it is possible, and that's what I do in the Hitchhiker's Guide. But we don't get syntax highlighting in VS Code.</p>",
        "id": 194764616,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587450327
    },
    {
        "content": "<p>That actually doesn't depend on anything in lean</p>",
        "id": 194764672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450365
    },
    {
        "content": "<p>you just need to update the extension for the new highlighting</p>",
        "id": 194764680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450384
    },
    {
        "content": "<p>Well, <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> won't treat <code>fix</code> as a keyword unless it's a keyword.</p>",
        "id": 194764690,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587450400
    },
    {
        "content": "<p>And I won't fork his extension just for that.</p>",
        "id": 194764695,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587450411
    },
    {
        "content": "<p>It would be nice if there were another way to set up highlighting per project so that we get things like <code>#lint</code> in color</p>",
        "id": 194764704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450426
    },
    {
        "content": "<p>Regardless, I want to raise the matter with the whole community, in the hope that they say <code>fix x</code> is great, we want it, etc. If nobody cares, I'll just go away.</p>",
        "id": 194764716,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587450448
    },
    {
        "content": "<p>I mean, lean knows about \"user commands\" and is configurable in this way, but the extension doesn't</p>",
        "id": 194764726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450459
    },
    {
        "content": "<p>Again, I don't want a private extension. I'm making a proposal to change Lean for everybody.</p>",
        "id": 194764746,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587450481
    },
    {
        "content": "<p>That \"fix\" isn't shown in blue, I can live with. The syntax highlighting has other, much worse oddities.</p>",
        "id": 194764804,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587450505
    },
    {
        "content": "<p>What about functions called <code>fix</code>?</p>",
        "id": 194764821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450539
    },
    {
        "content": "<p>I know that this has been used at least 2 or 3 times in mathlib</p>",
        "id": 194764838,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450566
    },
    {
        "content": "<p>I'm guessing they would behave like functions called <code>assume</code>.</p>",
        "id": 194764840,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587450571
    },
    {
        "content": "<p>no, they almost always are being used to mean a fixpoint / recursive function of some kind</p>",
        "id": 194764859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450598
    },
    {
        "content": "<p>Sure, but if there's a strong concensus, I'm sure it will be easy to rename them to have more specific names.</p>",
        "id": 194764911,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587450625
    },
    {
        "content": "<p>for example <code>well_founded.fix</code></p>",
        "id": 194764925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450647
    },
    {
        "content": "<p>Anyway, I know you're not going to use <code>fix</code>, so that's 1:0 against. I'm curious to hear what the others will have to say.</p>",
        "id": 194764927,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587450649
    },
    {
        "content": "<p>of course. I'm obviously not the target audience for this so I'm happy to hear other voices. I'm just curious what the rollout would look like here</p>",
        "id": 194764950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450704
    },
    {
        "content": "<p>I don't think there are any functions called <code>assume</code>, but that's no surprise since declaring a function the same name as a keyword is a pain</p>",
        "id": 194765020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587450742
    },
    {
        "content": "<p>I like the idea, because it lowers the barrier for newcomers (something that Lean is already pretty good at in general). The \"analysis paralysis\" is a bit of a problem, but I think we can overcome that. Especially if VScode tooltips explain the aliases / differences. (I don't think we currently have tooltips on keywords, do we?)</p>",
        "id": 194765314,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587451130
    },
    {
        "content": "<p>Oh, my mistake, I checked the logs and the word for this in early lean 3 was <code>take</code></p>",
        "id": 194765437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587451253
    },
    {
        "content": "<p>I prefer <code>fix</code>, but I recognise the name clash with the <code>fix</code> from Coq.</p>",
        "id": 194765590,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587451439
    },
    {
        "content": "<p>I think this is the issue that resulted in the removal of <code>take</code> as a keyword: <a href=\"https://github.com/leanprover/lean/pull/1706\" title=\"https://github.com/leanprover/lean/pull/1706\">https://github.com/leanprover/lean/pull/1706</a></p>",
        "id": 194765625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587451443
    },
    {
        "content": "<p>From that issue.<br>\n<span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> said:</p>\n<blockquote>\n<p>I think I would be fine with just calling it <code>list.take</code> and making it <code>protected</code>. Using dot-notation for list functions is more ergonomic than opening the namespace anyway.</p>\n</blockquote>\n<p>So all the <code>fix</code> functions can be made <code>protected</code> and continue their existence.</p>",
        "id": 194765801,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587451669
    },
    {
        "content": "<p>Also interested to hear <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> 's position since he uses this kind of style often</p>",
        "id": 194765983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587451817
    },
    {
        "content": "<p>I'm siding with Jeremy here: \"<code>take</code> is nice for teaching students how to write proofs, and for that purpose, lambda, fun, and assume are not very natural as substitutes. So, I will be sorry to see it go. That said, I can live without it.\"</p>",
        "id": 194766003,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587451834
    },
    {
        "content": "<p>Considering that lean's term mode was originally based pretty directly on Isar, I'm curious if I will find <code>fix</code> if I dig far enough into the past of lean 2, before I got involved</p>",
        "id": 194766102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587451958
    },
    {
        "content": "<p>I will vote in favour of adding <code>fix</code>. The naming conflict doesn't seem a big deal (there are namespaces for this, after all), and choosing between <code>fix</code> and <code>assume</code> doesn't sound more difficult than choosing between <code>def</code> and <code>lemma</code>. (Could a linter see the difference between <code>λ</code>, <code>assume</code>, and <code>fix</code>?)</p>",
        "id": 194769560,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1587454865
    },
    {
        "content": "<p>I never tell Xena people about this verbose term mode style and I personally find it hard to read the moment the number of goals starts to increase and one misplaced comma can throw things into chaos. Because I am always telling beginners to go straight into tactic mode and stay there, it's easy for us to get a fix, we could just add a tactic. Trying to make \"verbose term mode\" closer to English is an interesting question but it's not the mode for me personally. I am well aware that it can be popular amongst beginners with a CS background though</p>",
        "id": 194771531,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587456406
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> But do you also tell them to use tactic mode for definitions? Jasmin is talking about definitions here.</p>",
        "id": 194771638,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587456483
    },
    {
        "content": "<p>Oh I see. I tell them never to make definitions</p>",
        "id": 194772151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587456910
    },
    {
        "content": "<p>And leave that to the experts</p>",
        "id": 194772163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587456920
    },
    {
        "content": "<p>Well I was thinking of structured proofs. Indeed, it doesn't concern Kevin.</p>",
        "id": 194772187,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587456940
    },
    {
        "content": "<p>I think tactic mode is \"structured proofs\"</p>",
        "id": 194772200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587456954
    },
    {
        "content": "<p>I have a lot of trouble structuring term mode proofs well</p>",
        "id": 194772254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587456973
    },
    {
        "content": "<p>as in, every kind of indentation is terrible</p>",
        "id": 194772276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587457003
    },
    {
        "content": "<p>That's debatable, but if \"structured proof\" is controversial terminology, I mean \"assume have show calc\" proofs.</p>",
        "id": 194772284,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587457012
    },
    {
        "content": "<p>I find <code>calc</code> hard to indent.</p>",
        "id": 194772302,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587457032
    },
    {
        "content": "<p>I'm saying that for \"assume have show calc\" there are literally tactics called each of those</p>",
        "id": 194772316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587457051
    },
    {
        "content": "<p>(technically there is no <code>calc</code> tactic but <code>calc</code> as a tactic means <code>exact calc</code>)</p>",
        "id": 194772388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587457089
    },
    {
        "content": "<p>From what I've seen of isabelle, I think that Isar structured proofs look much more like tactic proofs than term mode, because of the neat indentation and block structure</p>",
        "id": 194772622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587457252
    },
    {
        "content": "<p>For example, how do you do a case split on an or hypothesis in isar? IIRC it looks basically like <code>cases h, { subproof }, { subproof }</code> with different keywords</p>",
        "id": 194772683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587457315
    },
    {
        "content": "<p>See p. 45, top-right example of <a href=\"https://isabelle.in.tum.de/website-Isabelle2014/dist/Isabelle2014/doc/prog-prove.pdf\" title=\"https://isabelle.in.tum.de/website-Isabelle2014/dist/Isabelle2014/doc/prog-prove.pdf\">https://isabelle.in.tum.de/website-Isabelle2014/dist/Isabelle2014/doc/prog-prove.pdf</a></p>",
        "id": 194773661,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587457958
    },
    {
        "content": "<p>It's true that Isar feels in some sense more flexible than Lean term-based structured proofs. The grammar feels less constraining, more like tactics and less like writing a term.</p>",
        "id": 194773819,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587458054
    },
    {
        "content": "<p>The error messages are also less wild. More like writing an imperative program and less like writing a Haskell program.</p>",
        "id": 194773848,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587458080
    },
    {
        "content": "<p>Whereas Isabelle tactic mode is just horrible if you're used to Coq's or Lean's. No names for hypotheses? Come on.</p>",
        "id": 194773888,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587458110
    },
    {
        "content": "<blockquote>\n<p>Proof commands perform transitions of Isar/VM machine configurations,which are block-structured, consisting of a stack of nodes with three main components: logical proof context, current facts, and open goals. (<a href=\"https://isabelle.in.tum.de/dist/Isabelle2020/doc/isar-ref.pdf\" title=\"https://isabelle.in.tum.de/dist/Isabelle2020/doc/isar-ref.pdf\">https://isabelle.in.tum.de/dist/Isabelle2020/doc/isar-ref.pdf</a> p.129)</p>\n</blockquote>\n<p>This sounds an <em>awful</em> lot like a description of tactics a la lean</p>",
        "id": 194773997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587458169
    },
    {
        "content": "<p>Still, you can't invoke a tactic in the middle of an Isar proof to change the proof goal. You always need a <code>fix</code>, an <code>assume</code>, a <code>have</code>, a <code>let</code>, a <code>define</code>, or a <code>show</code> (I'm perhaps forgetting one or two, like <code>guess</code>).</p>",
        "id": 194774444,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587458497
    },
    {
        "content": "<p>But the <code>{ }</code> have a very special semantics. They look superficially like the parentheses surrounding proof subterms, but their main purpose is to delimit the scope of <code>fix</code>es and <code>assume</code>s. You can nest them arbitrarily.</p>",
        "id": 194774558,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587458588
    },
    {
        "content": "<p>A bit like <code>{ }</code> in C++ w.r.t. variable definitions, really.</p>",
        "id": 194774575,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587458612
    },
    {
        "content": "<p>Yes, I think that isar top level commands map well to lean tactics, but not necessarily vice versa - lean tactics can do additional things that isabelle can't. So I think \"structured proofs\" in lean should be a specially curated subset of tactics with formatting conventions to make it more \"structured\"</p>",
        "id": 194774641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587458646
    },
    {
        "content": "<p>In principle we could even have a linter or something to enforce these guidelines so that you can have something with as much formal structure as isar</p>",
        "id": 194774843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587458815
    },
    {
        "content": "<p>The current situation is indeed quite messy, and when I teach I have to hide quite a bit of \"junk\" (e.g. the <code>assume</code> and <code>calc</code> tactics). Even then, it's still messy. Maybe getting rid of \"structured proofs\" and focusing on the other two, tactics and raw proof terms, is the way to go. Isn't that what Coq does anyway?</p>",
        "id": 194775401,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587459168
    },
    {
        "content": "<p>Reading quickly, I have the impression you are using a correspondence between term mode and structured proofs, but I don't think this holds: you can perfectly make a structured proof in tactic mode also, using <code>have</code>, <code>show</code>, <code>calc</code>, <code>obtain</code> and so on. That's the mode I prefer, by the way: it keeps some readability, but you have a goal state and everything, so writing proofs is way easier than in term mode.</p>\n<p>And I wouldn't mind having <code>fix</code> available there as a synonym for <code>assume</code> or <code>intro</code>.</p>",
        "id": 194776134,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587459628
    },
    {
        "content": "<p>When I met Makarius in Bonn, he somehow was convinced that structured proofs would be removed from Lean 4. I don't know anything about that, and personally I wouldn't want them gone. Term mode is not flexible enough to simulate Isar-style proofs a la <code>induction, case, have, have, show</code>.</p>",
        "id": 194776590,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1587459891
    },
    {
        "content": "<p>Given the context of the discussion I'm not sure what sense of \"structured proofs\" you mean</p>",
        "id": 194776669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587459943
    },
    {
        "content": "<blockquote>\n<p>structured proofs would be removed from Lean 4</p>\n</blockquote>\n<p>Which meaning of structured proof is this using?</p>",
        "id": 194776677,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587459951
    },
    {
        "content": "<p>Jasmin, I'm a bit confused by your question because you initially asked for mathematicians opinion but, much later in the conversation, I suddenly realized this was all about crazy term mode proofs, so I don't see how this has anything to do with us.</p>",
        "id": 194776861,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587460044
    },
    {
        "content": "<p>My preferred way of juggling between tactics and terms is explained in <a href=\"https://leanprover-community.github.io/lean-web-editor/#url=https%3A%2F%2Fraw.githubusercontent.com%2Fleanprover-community%2Ftutorials%2Fmaster%2Fsrc%2Ffirst_proofs.lean\" title=\"https://leanprover-community.github.io/lean-web-editor/#url=https%3A%2F%2Fraw.githubusercontent.com%2Fleanprover-community%2Ftutorials%2Fmaster%2Fsrc%2Ffirst_proofs.lean\">https://leanprover-community.github.io/lean-web-editor/#url=https%3A%2F%2Fraw.githubusercontent.com%2Fleanprover-community%2Ftutorials%2Fmaster%2Fsrc%2Ffirst_proofs.lean</a> if you are patient enough to read. The default mode is tactic, but with a lot of small scale back and forth using relatively low complexity expressions and <code>by</code>.</p>",
        "id": 194777283,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587460306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/Proposal.3A.20.60fix.20x.60.20for.20.60assume.20x.60/near/194776134\" title=\"#narrow/stream/113488-general/topic/Proposal.3A.20.60fix.20x.60.20for.20.60assume.20x.60/near/194776134\">said</a>:</p>\n<blockquote>\n<p>And I wouldn't mind having <code>fix</code> available there as a synonym for <code>assume</code> or <code>intro</code>.</p>\n</blockquote>\n<p>I agree here, as a tactic I think <code>fix</code> is unproblematic as a synonym for <code>assume</code></p>",
        "id": 194777305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587460319
    },
    {
        "content": "<p>I assumed Jasmin meant \"structured tactics\" with that since he mentioned the <code>assume</code> tactic, which is my default meaning of the term as well. Basically, I'm agreeing with Mario:</p>\n<blockquote>\n<p>I think \"structured proofs\" in lean should be a specially curated subset of tactics with formatting conventions to make it more \"structured\"</p>\n</blockquote>",
        "id": 194777306,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1587460319
    },
    {
        "content": "<p>And, like Sébastien, I think that non-trivial proofs involving some mathematical idea should be done using structuring tactics, with occasional comments. See for instance <a href=\"#narrow/stream/116395-maths/topic/Lebesgue.20number.20lemma/near/194033514\" title=\"#narrow/stream/116395-maths/topic/Lebesgue.20number.20lemma/near/194033514\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lebesgue.20number.20lemma/near/194033514</a></p>",
        "id": 194777410,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587460409
    },
    {
        "content": "<p>About the broad idea of separating assumption introduction from data introduction, there is a difficulty with bounded quantifiers. In my course a <em>lot</em> of goals start with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>ε</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\forall \\varepsilon &gt; 0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathdefault\">ε</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>. There I really don't want to write <code>fix epsilon, assume epsilon_pos</code>. So the neutral <code>intros epsilon epsilon_pos</code> is convenient.</p>",
        "id": 194777582,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587460541
    },
    {
        "content": "<p>I think the isar notion of \"structured proofs\" precludes a proof like this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">inf_lt</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">is_an_inf_of</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"c1\">-- Let `y` be any real number.</span>\n  <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Let&#39;s prove the contrapositive</span>\n  <span class=\"n\">contrapose</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- The symbol `¬` means negation. Let&#39;s ask Lean to rewrite the goal without negation,</span>\n  <span class=\"c1\">-- pushing negation through quantifiers and inequalities</span>\n  <span class=\"n\">push_neg</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Let&#39;s assume the premise, calling the assumption `h`</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- `h` is exactly saying `y` is a lower bound of `A` so the second part of</span>\n  <span class=\"c1\">-- the infimum assumption `hx` applied to `y` and `h` is exactly what we want.</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hx</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">y</span> <span class=\"n\">h</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>because of the use of \"non-approved\" tactics like <code>contrapose</code> and <code>push_neg</code> being used for changing the goal statement</p>",
        "id": 194777663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587460579
    },
    {
        "content": "<p>Also I don't care about the Coq meaning of <code>fix</code>, but we could use <code>take</code> instead. <code>fix</code> sounds more like cases on a existential assumption to me.</p>",
        "id": 194777710,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587460619
    },
    {
        "content": "<p>much like our rule on \"nonterminal simp\", isar extends this to basically all tactics except for the small list Jasmin gave above</p>",
        "id": 194777716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587460624
    },
    {
        "content": "<p>If you violate this rule too much, your tactic script ends up more like a coq style imperative proof</p>",
        "id": 194777815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587460705
    },
    {
        "content": "<p>(I'm not making a value judgment here, but I think this is the line that \"structured proofs\" is trying to draw)</p>",
        "id": 194777855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587460749
    },
    {
        "content": "<p>So instead of  <code>contrapose, push_neg</code>, you would say : <code>suffices H : ..., by { contrapose, push_neg, exact H}</code>.</p>",
        "id": 194777976,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587460818
    },
    {
        "content": "<p>This was not the example of structured proof, the Lebesgue number lemma was</p>",
        "id": 194777985,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587460823
    },
    {
        "content": "<p>Yes, sure.</p>",
        "id": 194777997,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587460834
    },
    {
        "content": "<p>Sorry, I see that terminology is confusing. When I teach Lean, I tell my students that there are tactical proofs, structured proofs, and raw proof terms. In tactical, I use <code>intro</code>. In \"structures proofs\", I use <code>assume</code> (and <code>fix</code>). In raw proof terms, I use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">λ</span></span></span></span>. If anybody has a better name for structured proofs a.k.a. syntactically sugared proof terms, I'm a taker.</p>\n<p>As for <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> : True, I forgot for a moment that many of you guys wouldn't care because you use tactics for nearly everything.</p>",
        "id": 194778879,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587461434
    },
    {
        "content": "<p>I would say that lean has two modes, term mode and tactic mode. Both modes have idioms that can be used to make the proof more structured for presentation purposes</p>",
        "id": 194779137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587461572
    },
    {
        "content": "<p>But not for definitions, and I think you were talking about definitions as well, right?</p>",
        "id": 194779139,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587461572
    },
    {
        "content": "<p>although because term mode is an expression grammar the options for out of band annotations are more limited</p>",
        "id": 194779240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587461627
    },
    {
        "content": "<p>Johan, I wasn't thinking about definitions. And indeed, Mario, I agree that \"structured proofs\" are just a subtype, but for teaching it's convenient to have a different name.</p>",
        "id": 194779811,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587461990
    },
    {
        "content": "<p>sure, but if you include structured proofs that makes 4 modes total, not 3, that's my point</p>",
        "id": 194780022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587462115
    },
    {
        "content": "<p>and the mathematicians on the chat seem to prefer the mode that you haven't enumerated</p>",
        "id": 194780089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587462144
    },
    {
        "content": "<p>because there is definitely also such a thing as \"unstructured tactic proofs\", such as those that you get from people learning to write tactics from NNG</p>",
        "id": 194780180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587462210
    },
    {
        "content": "<p>Well I'm only teaching three modes.</p>",
        "id": 194780578,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587462443
    },
    {
        "content": "<p>But you're right. I teach very briefly the <code>have</code> and <code>let</code> tactics -- I guess that's the fourth mode.</p>",
        "id": 194780608,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587462472
    },
    {
        "content": "<p>Maybe I should just give up on that <code>assume</code> <code>show</code> stuff and use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">λ</span></span></span></span>. But Rob teaches the previous course with that (and raw proof terms)...</p>",
        "id": 194780742,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587462546
    },
    {
        "content": "<p>Jasmin, what do you think of the proof given by Patrick at <a href=\"#narrow/stream/116395-maths/topic/Lebesgue.20number.20lemma/near/194033514\" title=\"#narrow/stream/116395-maths/topic/Lebesgue.20number.20lemma/near/194033514\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Lebesgue.20number.20lemma/near/194033514</a>? For me, that's the most readable we can achieve with Lean today.</p>",
        "id": 194780774,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587462574
    },
    {
        "content": "<p>I like it. It's basically Isar. And it shows that one doesn't need proof terms to write structured proofs.</p>",
        "id": 194781222,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587462858
    },
    {
        "content": "<p>I have been pointing students towards this \"obtain\" style since I saw it. But for me, the most readable style is the one that Mario posted above, where you just write any old proof but put comments everywhere :-)</p>",
        "id": 194781518,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587463102
    },
    {
        "content": "<p>Someone at Bonn really wanted to grill me about the difference between forward proofs and backward proofs, but I often feel I have nothing to say here. For some reason I don't think I understand the question properly.</p>",
        "id": 194781621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587463194
    },
    {
        "content": "<p>It starts already with the huge fractions that computer scientists use with T's on their side. We call stacks of them \"trees\", and when we \"climb\" the \"tree\" from the \"root\", you'd think we're going upwards but actually we say \"backwards\". Very easy, you see. But if you descend the \"tree\" from the \"leaves\", then you proceed \"forwards\", not downwards. Proof terms are also bidirectional (inside out or outside in).</p>",
        "id": 194781937,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587463370
    },
    {
        "content": "<p>Hey Kevin, do you know Rob recorded a video to explain to us one flavor of the big fraction thing?</p>",
        "id": 194782337,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587463715
    },
    {
        "content": "<p>The flavor which is about finding the most complicated way to explain a trivial proof. Unfortunately it's not the one we'd need to understand Mario's thesis. For that we need the typing rules big fractions, but it's related I think.</p>",
        "id": 194782397,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587463789
    },
    {
        "content": "<p>Videos 5 and 7 at <a href=\"http://robertylewis.com/logic_and_modeling/lecture_1\" title=\"http://robertylewis.com/logic_and_modeling/lecture_1\">http://robertylewis.com/logic_and_modeling/lecture_1</a>. You need to click your way until it shows the slides properly. Unfortunately I haven't found the playback speed option so it's pretty painful to watch. Take this as a patience exercise.</p>",
        "id": 194782677,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587464010
    },
    {
        "content": "<p>Perhaps it would be better to talk not about \"structured proofs\" like a different category, but \"proof structuring\" as an (incremental) method of organizing tactic proofs using specific structuring tactics.</p>",
        "id": 194782903,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1587464186
    },
    {
        "content": "<p>This doesn't help me. I need a name for <code>assume have show</code>-style proofs, so I can tell my students, \"Write a foo-bar proof\" and they'll know what I mean. Any ideas anybody?</p>",
        "id": 194782993,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587464266
    },
    {
        "content": "<p><code>(fix) assume have show</code> is too much of a mouthful.</p>",
        "id": 194783076,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587464307
    },
    {
        "content": "<p>raw term proof/structured term proof/raw tactic proof/structured tactic proof</p>",
        "id": 194784586,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1587465264
    },
    {
        "content": "<p>I could live with \"structured proof term\" (with proof before term). For tactics, I guess \"structured\" arises once you start using \"have\", more or less?</p>",
        "id": 194786297,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587466578
    },
    {
        "content": "<p>\"have\" or \"suffices\" or \"obtain\"</p>",
        "id": 194789330,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587468814
    },
    {
        "content": "<p>and sometimes \"change\" or \"show\"</p>",
        "id": 194789346,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587468835
    },
    {
        "content": "<p>and especially <code>{ }</code></p>",
        "id": 194791064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587470041
    },
    {
        "content": "<p>I don't have a strong opinion here. In the early days of Lean, we had lots of aliases. The words <code>structure</code> and <code>record</code> were interchangeable, and we had <code>take</code> and <code>assume</code>. All of these were the same: <code>theorem</code> <code>lemma</code> <code>proposition</code> <code>corollary</code> and probably more. Instead of <code>variable</code> you could write <code>premise</code>, and instead of <code>parameter</code> you could write <code>hypothesis</code>. I think <code>conjecture</code> was allowed for something as well.</p>\n<p>At one point early in the Lean 3 years, Leo decided to clean up and simplify syntax. The only synonyms he kept were <code>axiom</code> / <code>constant</code> and <code>theorem</code> / <code>lemma</code>.</p>\n<p>Ultimately, I think he was right. The proliferation of keywords made the system feel messy and chaotic. It is easy to explain and get used to <code>assume</code>; I have had no trouble explaining the double use to students. One of the attractive things about Lean is that the syntax is so clean.</p>\n<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> will also remember the endless discussion over the use of <code>.</code> for projection notation, as in<code>l.cons</code>. IIRC, before that we used <code>l.&gt;cons</code>, and there was a lot of worry that if we used a period the ambiguity with namespaces would confuse people and cause problems. But eventually Leo made a decision, and in hindsight, it was the right one.</p>\n<p>Leo has a really good sense for these things. He is almost always right.  I suspect that once we start using Lean 4, we will cringe when we look back on all the underscores. (Incidentally, in the early days of Lean, we also debated underscores vs. hyphens, which Agda uses, as in <code>my-long-theorem-name</code>. Leo rejected that, because it would mean requiring spaces around a minus sign, so we could not write <code>x-y</code>.)</p>",
        "id": 194808170,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1587478696
    },
    {
        "content": "<p>Oh, another Leo innovation: we used to write <code>definition</code> before he shortened it to <code>def</code>. I think that is why <code>def</code> isn't syntax highlighted in the Zulip code blocks.</p>",
        "id": 194808779,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1587478950
    },
    {
        "content": "<p>Originally it was <code>l^.cons</code> I think. But yes, that was a fun change. At first we were cautious about <code>^.</code> itself being too crazy to keep, but soon we started using it so much that not only couldn't we live without it, we even started thinking about making its syntax almost invisible. It simply was that good.</p>",
        "id": 194809455,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1587479275
    },
    {
        "content": "<p>It actually still works:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">[]</span><span class=\"err\">^</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n</pre></div>",
        "id": 194809688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587479364
    },
    {
        "content": "<p>Are there any ambiguities in <code>x.foo</code> that are not fixed by <code>x .foo</code>? If so we can probably remove <code>^.</code></p>",
        "id": 194810111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587479539
    },
    {
        "content": "<p>there are precisely 0 uses of <code>^.</code> in mathlib</p>",
        "id": 194810274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587479627
    },
    {
        "content": "<p>Yes, it's already been removed in Lean 4</p>",
        "id": 194810367,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1587479651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> Thanks for the historical perspective. It explains why Lean is half against aliases and half in favor -- a slightly messy state. I surely never mention <code>definition</code> to my students, nor <code>fun</code> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">λ</span></span></span></span> etc. Given that the axiom of choice is specified with <code>axiom</code> even though the result type is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span></span></span></span>, I'm guessing there's more dead wood there.</p>",
        "id": 194818711,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587482724
    },
    {
        "content": "<p>Note that <code>axiom/constant</code> will actually be a meaningful choice in Lean 4: <code>constant</code>s have to be inhabited. I actually can't think of any synonyms still left apart from ASCII syntax.</p>",
        "id": 194820438,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1587483387
    },
    {
        "content": "<p><code>rw</code> vs. <code>rewrite</code>?</p>",
        "id": 194821667,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1587483907
    },
    {
        "content": "<p><code>axiom</code> and <code>constant</code> are actually distinct all through the lean process, but I've never been able to figure out what the difference is</p>",
        "id": 194823045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587484545
    },
    {
        "content": "<p>The fact that <code>choice</code> has type alpha isn't actually that relevant - while it is easy to explain the difference between <code>def</code> and <code>theorem</code> via the curry howard Prop/Type distinction, in lean the difference is in other things: <code>def</code>s are elaborated synchronously, and they have code generated, while <code>theorem</code>s do not. It makes sense then that <code>choice</code> should be an <code>axiom</code> since it has no code, by comparison to a <code>meta constant</code> which has no lean definition but nevertheless has code. <code>constant</code> is used nowhere in lean core so I don't know exactly what its purpose is</p>",
        "id": 194823802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587484813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121058\">Jasmin Blanchette</span> <a href=\"#narrow/stream/113488-general/topic/Proposal.3A.20.60fix.20x.60.20for.20.60assume.20x.60/near/194821667\" title=\"#narrow/stream/113488-general/topic/Proposal.3A.20.60fix.20x.60.20for.20.60assume.20x.60/near/194821667\">said</a>:</p>\n<blockquote>\n<p><code>rw</code> vs. <code>rewrite</code>?</p>\n</blockquote>\n<p>Ah, that does look redundant. I assume no-one is actually using <code>rewrite</code>, just like with <code>definition</code>.</p>",
        "id": 194826354,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1587485907
    },
    {
        "content": "<p>Not that either of them is in Lean 4 right now. We did kill <code>return</code> in favor of <code>pure</code>!</p>",
        "id": 194826604,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1587486010
    },
    {
        "content": "<p>This thread involved some historical storytelling, and I belatedly realized that I should have given <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>  credit for the current form of anonymous projections. It was Leo's idea to use them for projections of a structure so that for example we could write <code>p.fst</code> and Lean would infer from the type of <code>p</code> that this means <code>prod.fst p</code>. But Sebastian quickly pointed out that the same trick would work for any theorem or definition in a namespace with the same name as the type, allowing us to write <code>l.length</code> first <code>list.length l</code>. What a stroke of genius! It's a good thing he is so involved in the syntax of Lean 4.</p>",
        "id": 195343823,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1587921649
    },
    {
        "content": "<p>Oh, I didn't even remember that change, only the syntactic one... it's interesting that there hasn't been much discussion so far about generalizing the notation even further, e.g. over super structures (seems relatively straightforward) or typeclasses (less clear). No changes there in Lean 4, yet.</p>",
        "id": 195344318,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1587922458
    },
    {
        "content": "<p>This is indeed very convenient.</p>",
        "id": 195344566,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587922737
    },
    {
        "content": "<p>Hey, we did ask very loudly for a more powerful dot notation for super structures in Lean 4.</p>",
        "id": 195344603,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587922768
    },
    {
        "content": "<p>Sebastian, see also <a href=\"#narrow/stream/113488-general/topic/to_extending\" title=\"#narrow/stream/113488-general/topic/to_extending\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_extending</a></p>",
        "id": 195344705,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587922878
    }
]
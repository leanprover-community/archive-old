[
    {
        "content": "<p>Hi, so I’m still trying to implement <code>finmap β ≃ Σ (keys : finset α), (Π (key ∈ keys), β key)</code>, and I’ve made some progress but now I’m completely stuck in heq hell. I need to prove equality of two sigma types to show that pair →  map → pair is an identity (my goal is roughly of the form <code>f (g x) = x</code> where <code>x : sigma β</code>) — the trouble is that nearly every attempt to break apart that equality to prove it results in <code>heq</code> because of the nature of the sigma type. My code so far looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finmap</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.image</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.sigma</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">lemma</span> <span class=\"n\">option.heq_some_iff_get_heq</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">o</span> <span class=\"bp\">==</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">o.is_some</span><span class=\"o\">,</span> <span class=\"n\">option.get</span> <span class=\"n\">h</span> <span class=\"bp\">==</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">list.pmap_eq_self</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">prover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">prover</span> <span class=\"n\">x</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">list.pmap</span> <span class=\"n\">f</span> <span class=\"n\">l</span> <span class=\"n\">prover</span> <span class=\"bp\">=</span> <span class=\"n\">l</span>\n<span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">list.pmap</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"n\">l_hd</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">l_ih</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">or.inr</span> <span class=\"n\">H</span><span class=\"o\">)),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">make_entries</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">keys</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"bp\">∈</span> <span class=\"n\">keys</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">key</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"n\">keys.val.pmap</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">elem_mem</span> <span class=\"o\">:</span> <span class=\"n\">elem</span> <span class=\"bp\">∈</span> <span class=\"n\">keys.val</span><span class=\"o\">),</span> <span class=\"o\">⟨</span><span class=\"n\">elem</span><span class=\"o\">,</span> <span class=\"n\">value</span> <span class=\"n\">elem</span> <span class=\"n\">elem_mem</span><span class=\"o\">⟩)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finmap.equiv_finset_fun</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">finmap</span> <span class=\"n\">β</span> <span class=\"bp\">≃</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">keys</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"bp\">∈</span> <span class=\"n\">keys</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">key</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">map</span><span class=\"o\">,</span> <span class=\"o\">{</span>\n    <span class=\"n\">fst</span> <span class=\"o\">:=</span> <span class=\"n\">map.keys</span><span class=\"o\">,</span>\n    <span class=\"n\">snd</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">x_mem</span><span class=\"o\">,</span> <span class=\"n\">option.get</span> <span class=\"o\">(</span><span class=\"n\">finmap.lookup_is_some.mpr</span> <span class=\"n\">x_mem</span><span class=\"o\">),</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">pair</span><span class=\"o\">,</span> <span class=\"o\">{</span>\n    <span class=\"n\">entries</span> <span class=\"o\">:=</span> <span class=\"n\">make_entries</span> <span class=\"n\">pair.1</span> <span class=\"n\">pair.2</span><span class=\"o\">,</span>\n    <span class=\"n\">nodupkeys</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">quot.ind</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">keys</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n        <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">keys_nodup</span> <span class=\"o\">:</span> <span class=\"n\">keys.nodup</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"bp\">∈</span> <span class=\"n\">keys</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">key</span><span class=\"o\">),</span>\n          <span class=\"o\">(</span><span class=\"n\">make_entries</span> <span class=\"o\">⟨</span><span class=\"n\">keys</span><span class=\"o\">,</span> <span class=\"n\">keys_nodup</span><span class=\"o\">⟩</span> <span class=\"n\">value</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nodupkeys</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">keys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">keys_nodup</span> <span class=\"o\">:</span> <span class=\"n\">keys.nodup</span><span class=\"o\">)</span> <span class=\"n\">value</span><span class=\"o\">,</span>\n        <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">make_entries</span><span class=\"o\">,</span> <span class=\"n\">list.nodupkeys</span><span class=\"o\">,</span> <span class=\"n\">list.keys</span><span class=\"o\">,</span> <span class=\"n\">list.map_pmap</span><span class=\"o\">,</span> <span class=\"n\">keys_nodup</span><span class=\"o\">])</span>\n      <span class=\"n\">pair.1.val</span>\n      <span class=\"n\">pair.1.nodup</span>\n      <span class=\"n\">pair.2</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"c1\">-- map → pair → map is an identity (not a pretty proof but I’ll come back to this later)</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">map</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">map</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finmap.keys</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">finmap.ext</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">make_entries</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">multiset.keys</span><span class=\"o\">],</span>\n    <span class=\"n\">induction</span> <span class=\"n\">map_entries</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.pmap_map</span><span class=\"o\">],</span>\n    <span class=\"n\">convert</span> <span class=\"bp\">←</span> <span class=\"n\">list.perm.refl</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">list.pmap_eq_self</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">x_mem</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">map_nodupkeys</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">exists_prop_of_true</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">option.get</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">x_snd</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">option.eq_some_iff_get_eq.mp</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">finmap.induction_on</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">sigma.mk</span> <span class=\"n\">x_fst</span> <span class=\"n\">x_snd</span> <span class=\"bp\">∈</span> <span class=\"n\">f.entries</span> <span class=\"bp\">→</span> <span class=\"n\">finmap.lookup</span> <span class=\"n\">x_fst</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">x_snd</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">alist.mem_lookup_iff.mpr</span><span class=\"o\">),</span>\n    <span class=\"n\">exact</span> <span class=\"n\">x_mem</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- pair → map → pair is an identity</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">pair</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">pair</span> <span class=\"k\">with</span> <span class=\"n\">keys</span> <span class=\"n\">val</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">keys</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">keys_val</span><span class=\"o\">,</span>\n\n    <span class=\"c1\">-- STRATEGY 1: Don’t break the sigma</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">make_entries</span><span class=\"o\">],</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">multiset.quot_mk_to_coe''</span><span class=\"o\">],</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">multiset.coe_pmap</span><span class=\"o\">],</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finmap.keys</span><span class=\"o\">],</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">multiset.coe_keys</span><span class=\"o\">],</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.keys</span><span class=\"o\">],</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span>\n      <span class=\"n\">list.map</span> <span class=\"n\">sigma.fst</span> <span class=\"o\">(</span><span class=\"n\">list.pmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">elem_mem</span> <span class=\"o\">:</span> <span class=\"n\">elem</span> <span class=\"bp\">∈</span> <span class=\"bp\">↑</span><span class=\"n\">keys_val</span><span class=\"o\">),</span> <span class=\"o\">⟨</span> <span class=\"n\">elem</span><span class=\"o\">,</span> <span class=\"n\">val</span> <span class=\"n\">elem</span> <span class=\"n\">elem_mem</span> <span class=\"o\">⟩)</span> <span class=\"n\">keys_val</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"bp\">=</span> <span class=\"n\">list.pmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">elem</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">elem_mem</span> <span class=\"o\">:</span> <span class=\"n\">elem</span> <span class=\"bp\">∈</span> <span class=\"bp\">↑</span><span class=\"n\">keys_val</span><span class=\"o\">),</span> <span class=\"n\">sigma.fst</span> <span class=\"o\">⟨</span> <span class=\"n\">elem</span><span class=\"o\">,</span> <span class=\"n\">val</span> <span class=\"n\">elem</span> <span class=\"n\">elem_mem</span> <span class=\"o\">⟩)</span> <span class=\"n\">keys_val</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">list.map_pmap</span> <span class=\"o\">},</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span>\n    <span class=\"c1\">-- ^ errors, for some reason; `rw` and `simp` also fail, hence all the dsimps</span>\n\n    <span class=\"c1\">-- STRATEGY 2: Break the sigma</span>\n    <span class=\"n\">fapply</span> <span class=\"n\">sigma.eq</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finmap.keys</span><span class=\"o\">,</span> <span class=\"n\">make_entries</span><span class=\"o\">,</span> <span class=\"n\">multiset.keys</span><span class=\"o\">,</span> <span class=\"n\">list.map_pmap</span><span class=\"o\">,</span> <span class=\"n\">list.map_id''</span><span class=\"o\">],</span>\n    <span class=\"c1\">-- What now? How do I prove a goal of the form `_.rec_on (…) = …`?</span>\n\n    <span class=\"c1\">-- STRATEGY 3: Embrace the heq</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finmap.keys</span><span class=\"o\">,</span> <span class=\"n\">make_entries</span><span class=\"o\">,</span> <span class=\"n\">multiset.keys</span><span class=\"o\">,</span> <span class=\"n\">list.map_pmap</span><span class=\"o\">,</span> <span class=\"n\">list.map_id''</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">function.hfunext</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a_heq_b</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">a_eq_b</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">eq_of_heq</span> <span class=\"n\">a_heq_b</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">function.hfunext</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finmap.keys</span><span class=\"o\">,</span> <span class=\"n\">make_entries</span><span class=\"o\">,</span> <span class=\"n\">multiset.keys</span><span class=\"o\">,</span> <span class=\"n\">a_eq_b</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a_mem</span> <span class=\"n\">b_mem</span> <span class=\"n\">a_mem_eq_b_mem</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">exists_prop_of_true</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">option.get</span> <span class=\"n\">h</span> <span class=\"bp\">==</span> <span class=\"n\">val</span> <span class=\"n\">b</span> <span class=\"n\">b_mem</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">option.heq_some_iff_get_heq.mp</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">make_entries</span><span class=\"o\">,</span> <span class=\"n\">multiset.quot_mk_to_coe''</span><span class=\"o\">,</span> <span class=\"n\">multiset.coe_pmap</span><span class=\"o\">],</span>\n    <span class=\"c1\">-- What now? I have no ideä how to simplify or prove this goal because it uses `heq`…</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>You can see the three different strategies I’ve tried, but with each one I encountered a dead end somehow. Any ideäs on this?</p>",
        "id": 320013073,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1673131587
    },
    {
        "content": "<p>Do you mean \"equality of 2 elements of a sigma type\"? Because equality of types is something different.</p>",
        "id": 320013932,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1673132388
    },
    {
        "content": "<p>Here is a complete proof with some auxiliary lemmas that should go to other files. The main trick I used was to use a subtype of a product type as an intermediate type. Probably, one can golf the last equivalence using existing equiv.*_congr constructions.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finmap</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.sigma</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">multiset</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">can_lift_finset</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">can_lift</span> <span class=\"o\">(</span><span class=\"n\">multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">finset.val</span> <span class=\"n\">multiset.nodup</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">hm</span><span class=\"o\">,</span> <span class=\"o\">⟨⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nodup_keys</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)}</span> <span class=\"o\">:</span> <span class=\"n\">m.keys.nodup</span> <span class=\"bp\">↔</span> <span class=\"n\">m.nodupkeys</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">m</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">⟩,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nodupkeys.nodup</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m.nodupkeys</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">m.nodup</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">nodup_keys.2</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">of_map</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">multiset</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">part.to_option_is_some</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">part</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable</span> <span class=\"n\">o.dom</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">o.to_option.is_some</span> <span class=\"bp\">↔</span> <span class=\"n\">o.dom</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">by_cases</span> <span class=\"n\">o.dom</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">part.to_option</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">option</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">get_eq_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">o.is_some</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">get</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">o</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">is_some_iff_exists.1</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_def</span><span class=\"o\">,</span> <span class=\"n\">get_some</span><span class=\"o\">,</span> <span class=\"n\">some_inj</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">option</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finmap</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lookup_eq_some_iff</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">f.lookup</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">sigma.mk</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f.entries</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">f</span> <span class=\"k\">with</span> <span class=\"o\">⟨⟨</span><span class=\"n\">l</span><span class=\"o\">⟩,</span> <span class=\"n\">hl</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">list.mem_lookup_iff</span> <span class=\"n\">hl</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">nodup</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.entries.nodup</span> <span class=\"o\">:=</span> <span class=\"n\">f.nodupkeys.nodup</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">sigma_keys_lookup</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f.keys.sigma</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f.lookup</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">f.entries</span><span class=\"o\">,</span> <span class=\"n\">f.nodup</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f.entries</span> <span class=\"bp\">→</span> <span class=\"n\">x.fst</span> <span class=\"bp\">∈</span> <span class=\"n\">f.keys</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">multiset.mem_map_of_mem</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">lookup_eq_some_iff</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">keys_lookup_equiv</span> <span class=\"o\">:</span>\n  <span class=\"n\">finmap</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f.2</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_some</span> <span class=\"bp\">↔</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">f.1</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨(</span><span class=\"n\">f.keys</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f.lookup</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">lookup_is_some</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨(</span><span class=\"n\">f.1.1.sigma</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f.1.2</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">refine</span> <span class=\"n\">multiset.nodup_keys.1</span> <span class=\"o\">((</span><span class=\"n\">finset.nodup</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_on</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_val</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_sigma</span><span class=\"o\">,</span> <span class=\"n\">option.mem_to_finset</span><span class=\"o\">,</span> <span class=\"n\">option.mem_def</span><span class=\"o\">],</span>\n      <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">hj</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">),</span>\n      <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">option.some.inj</span> <span class=\"o\">(</span><span class=\"n\">hx.symm.trans</span> <span class=\"n\">hy</span><span class=\"o\">),</span>\n      <span class=\"n\">refl</span>\n    <span class=\"kd\">end</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩,</span> <span class=\"n\">hf</span><span class=\"o\">⟩,</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">ext</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"bp\">;</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">keys</span><span class=\"o\">],</span>\n      <span class=\"o\">{</span> <span class=\"n\">ext1</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n          <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">option.get</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">option.get_mem</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">hi</span><span class=\"o\">⟩,</span>\n        <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">multiset.keys</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">option.mem_def</span><span class=\"o\">,</span> <span class=\"n\">lookup_eq_some_iff</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_val</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_sigma</span><span class=\"o\">,</span>\n          <span class=\"n\">option.mem_to_finset</span><span class=\"o\">,</span> <span class=\"n\">and_iff_right_iff_imp</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hf</span><span class=\"o\">],</span>\n        <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">option.is_some_iff_exists.2</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n    <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finmap_equiv_sigma</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">finmap</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"bp\">Σ</span> <span class=\"n\">keys</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"bp\">Π</span> <span class=\"n\">k</span> <span class=\"bp\">∈</span> <span class=\"n\">keys</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"n\">keys_lookup_equiv.trans</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f.1.1</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">option.get</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">f.2</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">hi</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨(</span><span class=\"n\">f.1</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">part.to_option</span> <span class=\"o\">⟨</span><span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">f.1</span><span class=\"o\">,</span> <span class=\"n\">f.2</span> <span class=\"n\">i</span><span class=\"o\">⟩),</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩,</span> <span class=\"n\">hf</span><span class=\"o\">⟩,</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n      <span class=\"n\">congr'</span> <span class=\"k\">with</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_some</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">option.is_some_iff_exists.2</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">option.get_eq_iff</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hf</span><span class=\"o\">]</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩,</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n      <span class=\"n\">congr'</span> <span class=\"k\">with</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">option.get_eq_iff</span><span class=\"o\">,</span> <span class=\"n\">part.mem_to_option</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finmap</span>\n</code></pre></div>\n</div></div>",
        "id": 320024349,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1673141331
    },
    {
        "content": "<p>Thank you very much! I’ll have to spend a while studying that :D</p>",
        "id": 320046331,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1673163969
    },
    {
        "content": "<p>It's hard to work with equality of <code>x y : Σ i, α i</code> unless <code>x.1 = y.1</code> is a definitional equality. So, it helps to isolate \"actual work\" from wrapping in convenient types.</p>",
        "id": 320047800,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1673165352
    },
    {
        "content": "<p>BTW, I don't know which of the equivalences is more useful in practice.</p>",
        "id": 320047818,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1673165381
    },
    {
        "content": "<p>The trick to work with sigma types is to make <code>x.1 = y.1</code> an equality of at least one free variable, then <code>subst</code> it. Then <code>x.2 == y.2</code> becomes <code>x.2 = y.2</code>.</p>",
        "id": 320048238,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673165825
    },
    {
        "content": "<p>PRd non-sigma version: <a href=\"https://github.com/leanprover-community/mathlib/pull/18151\">#18151</a>. I'm not sure that we need the sigma version in <code>mathlib</code> because the math content is there but it's easier to deal with a subtype of a product than with a sigma type.</p>",
        "id": 321028654,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1673555505
    }
]
[
    {
        "content": "<p>Something we eventually should have are Mathematica-style Guide pages (here's a random example: <a href=\"https://reference.wolfram.com/language/guide/Associations.html\">https://reference.wolfram.com/language/guide/Associations.html</a>). The idea of these is to give you a cross-cutting overview of different useful functionality for how to interact with things in some general area. I don't think they're meant to be exhaustive, but rather meant to give you enough to find a way into the rest of the library.</p>",
        "id": 291463640,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659234598
    },
    {
        "content": "<p>They also have tutorials that are worked-out examples for how to do something, and of course documentation for individual functions.</p>",
        "id": 291463732,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659234683
    },
    {
        "content": "<p>We so far have two guide pages that come to mind: <a href=\"https://leanprover-community.github.io/mathlib-overview.html\">https://leanprover-community.github.io/mathlib-overview.html</a> and <a href=\"https://leanprover-community.github.io/undergrad.html\">https://leanprover-community.github.io/undergrad.html</a></p>",
        "id": 291463783,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659234733
    },
    {
        "content": "<p>The module docs for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset\">docs#finset</a> also serve as a guide page</p>",
        "id": 291463821,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659234820
    },
    {
        "content": "<p>But one thing to keep in mind is that the source files for mathlib don't themselves have to be the documentation -- Mathematica's rich documentation is all completely separate from the source code. One one hand, that makes it harder to remember to keep it up to date, but on the other it allows the documentation to have structure that's best for documenting (instead of needing to find compromises based on how the source is structured).</p>",
        "id": 291463937,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659234961
    },
    {
        "content": "<p>On the same spirit (dedicated documentation): <a href=\"https://scikit-learn.org/stable/user_guide.html\">https://scikit-learn.org/stable/user_guide.html</a></p>",
        "id": 291464075,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1659235134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Making.20mathlib.20more.20readable.20.28was.3A.20Improving.20the.20mathlib.20.2E.2E.2E/near/291463640\">said</a>:</p>\n<blockquote>\n<p>Something we eventually should have are Mathematica-style Guide pages (here's a random example: <a href=\"https://reference.wolfram.com/language/guide/Associations.html\">https://reference.wolfram.com/language/guide/Associations.html</a>). The idea of these is to give you a cross-cutting overview of different useful functionality for how to interact with things in some general area. I don't think they're meant to be exhaustive, but rather meant to give you enough to find a way into the rest of the library.</p>\n</blockquote>\n<p>Did you have a look at chapters 7 to 9 in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">Mathematics in Lean</a>?</p>",
        "id": 291479156,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659257723
    },
    {
        "content": "<p>Yes <span class=\"user-mention\" data-user-id=\"416472\">@Winston Yin</span> I'm not sure reading mathlib is the way to learn how to formalise mathematics in lean, we are trying to generate other documentation for this (like the link Patrick suggested)</p>",
        "id": 291479418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659258121
    },
    {
        "content": "<p>I would like it very much if there were some nice ways of “litterate programming in Lean”. With the same text that furnishes the Lean code and a human readable text that can be used to study the math. (This, <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> ,  would be the actual Bourbaki 2.0.)</p>",
        "id": 291483990,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1659264649
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/stream/113488-general/topic/Making.20mathlib.20more.20readable.20.28was.3A.20Improving.20the.20mathlib.20.2E.2E.2E/near/291460564\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> should we break this into a new thread?</p>\n<p>Does it make sense to think of a button in the page generated by doc-gen that can show usages?</p>\n<p>It's not as simple as a syntactical search because of simp lemmas, so maybe it would require a post-processing step to gather such information</p>\n</blockquote>\n<p>Are you asking for a used by list (and or a \"uses\" list) on theorems? That can very well be done in doc-gen4 by just processing the Exprs of all theorems and seeing what names pop up there is no need for special casing with <code>simp</code>.</p>",
        "id": 291484872,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1659265885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/113488-general/topic/Making.20mathlib.20more.20readable.20.28was.3A.20Improving.20the.20mathlib.20.2E.2E.2E/near/291483990\">said</a>:</p>\n<blockquote>\n<p>I would like it very much if there were some nice ways of “litterate programming in Lean”. With the same text that furnishes the Lean code and a human readable text that can be used to study the math. (This, <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> ,  would be the actual Bourbaki 2.0.)</p>\n</blockquote>\n<p>You are basically asking for something hte likes of <a href=\"https://alectryon-paper.github.io/\">https://alectryon-paper.github.io/</a> right? I'm already on working getting stuff like this on the way for Lean 4 as well</p>",
        "id": 291484929,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1659265956
    },
    {
        "content": "<p>I still think that making proofs readable should be an automatic post-processing step. Of course capabilities of this post-processing step would still put some constraints on proof scripts.</p>",
        "id": 291484949,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659266007
    },
    {
        "content": "<p>What does it mean to be readable for a proof? Or to be transformed into a readable one?</p>",
        "id": 291485012,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1659266058
    },
    {
        "content": "<p>Henrik, what Antoine is asking for goes much beyond what Alectryon is currently doing. But indeed the post-processing tool would start like Alectryon.</p>",
        "id": 291485015,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659266071
    },
    {
        "content": "<p>Did you ever read <a href=\"https://www.imo.universite-paris-saclay.fr/~pmassot/files/exposition/why_formalize.pdf\">https://www.imo.universite-paris-saclay.fr/~pmassot/files/exposition/why_formalize.pdf</a>? Section 2 is the relevant one here.</p>",
        "id": 291485108,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659266181
    },
    {
        "content": "<p>And of course a very easy readability criterion is that someone would has already written lots of Lean proof should not have any reading advantage at all.</p>",
        "id": 291485136,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659266254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Making.20mathlib.20more.20readable.20.28was.3A.20Improving.20the.20mathlib.20.2E.2E.2E/near/291484949\">said</a>:</p>\n<blockquote>\n<p>I still think that making proofs readable should be an automatic post-processing step. Of course capabilities of this post-processing step would still put some constraints on proof scripts.</p>\n</blockquote>\n<p>Well, but I think a balance between making proofs readable (i.e. understandable for the interested mathematician) and making them <em>exploitable</em> (I cannot came up with a better term: I mean that someone can learn from them something about formalising, possibly formalising another similar lemma getting inspiration from that proof) would be useful. For instance, if a proof requires <code>a+b=b+a</code>, golfing <code>exact add_comm a b</code> to <code>exact add_comm _ _</code>is precisely the thing I would oppose: it adds nothing, but if one does not know yet how things works, the two underlines are genuinely painful.</p>",
        "id": 291485709,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1659267048
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> I was talking about a \"used by\" list, preferably ranked by relevance (the declarations that are used the most would come up on top)</p>",
        "id": 291485777,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1659267200
    },
    {
        "content": "<p>An \"uses\" list would be ranked in reverse order, I think. So that the most \"exquisite\" declarations would come up on top to avoid always having the same declarations at the top of almost every \"uses\" list. For instance, seeing <code>nat.add_comm</code> at the top doesn't add a lot of info</p>",
        "id": 291486093,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1659267615
    },
    {
        "content": "<p>However, this also sounds like something that could be supported by the IDE somehow. Some languages (I know Scala and Java) do</p>",
        "id": 291486181,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1659267831
    },
    {
        "content": "<p>Should the \"used by\" counter include transitive counts? For example if you have a very basic theorem in a theory you build up bigger and bigger statements from  that are each not used that often you won't really get a clear view of what is relevant without transitive counters right?</p>",
        "id": 291486303,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1659267964
    },
    {
        "content": "<p>And if we can agree on this, how far should it take transitivity into consideration? Fully? Up until module borders? A certain number of steps?</p>",
        "id": 291486486,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1659268229
    },
    {
        "content": "<p>Oh right, I meant to respond to the \"used by\" comment. I think it's a fantastic idea; it's one of the features from the metamath HTML pages that I miss in doc-gen and it is really good for helping to identify places to look when doing refactors, in addition to being one way to explore the mathematical content of a formal development. (It should probably be accompanied by a list of theorems referenced as well, so that you can go both up and down the graph of theorem references. In metamath this is automatic since the proof display is itself a list of theorem applications, but in lean it is not as trivial to reconstruct the list of referenced theorems from the source because of tactics that can pull who knows what into the proof.)</p>",
        "id": 291487194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659269322
    },
    {
        "content": "<p>Oh since doc-gen4 analyses the Expr's that is not really an issue I can just traverse them and look for mentions of Expr.const that are <code>Prop</code> typed right?</p>",
        "id": 291487209,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1659269380
    },
    {
        "content": "<blockquote>\n<p>the declarations that are used the most would come up on top</p>\n</blockquote>\n<p>That is probably the wrong heuristic. Declarations that are used a lot tend to be uninteresting. Metamath's heuristic uses order in the file: the later a theorem is proved the more \"important\" it is</p>",
        "id": 291487212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659269393
    },
    {
        "content": "<p>that's slightly nontrivial when the proofs are not linearized, but I think you can do something reasonable with definitional height</p>",
        "id": 291487277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1659269437
    },
    {
        "content": "<p>Regarding transitive references, I'm not sure. My first instinct is \"no, transitive references aren't interesting for this use case\"</p>",
        "id": 291487567,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1659269922
    },
    {
        "content": "<p>I think it also heavily depends on what kind of result this is. Knowing <em>where</em> (or how many times) the proof that <code>a+b=b+a</code> is used in a commutative monoid is of no interest, but knowing which parts of commutative algebra rely on the Chinese remainder theorem might be interesting. Can't we think of a flag like the <code>simp</code> one, but for doc purposes?</p>",
        "id": 291488520,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1659271280
    },
    {
        "content": "<blockquote>\n<p>if a proof requires <code>a+b=b+a</code>, golfing <code>exact add_comm a b</code> to <code>exact add_comm _ _</code>is precisely the thing I would oppose: it adds nothing, but if one does not know yet how things works, the two underlines are genuinely painful.</p>\n</blockquote>\n<p>I am actually arguing the exact opposite. Replacing variable names with underscores makes the proof much more robust to refactorings (because if you rename a variable for X reason you don't have to change the underscore), and not having an underscore is a flag that not everything can be inferred, that there's a choice being made.</p>",
        "id": 291490962,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1659274442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Making.20mathlib.20more.20readable.20.28was.3A.20Improving.20the.20mathlib.20.2E.2E.2E/near/291479156\">said</a>:</p>\n<blockquote>\n<p>Did you have a look at chapters 7 to 9 in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">Mathematics in Lean</a>?</p>\n</blockquote>\n<p>This is great, but it's serving a different purpose, more like a tutorial than a Guide page. (It would also be great if something like this were part of the mathlib repository itself, with some linting to make sure definitions/lemmas are kept up to date, and part of the docgen.)</p>\n<p>I've been planning on (eventually) creating some guide pages and figuring out how to incorporate them into our documentation, in my copious free time and all that...</p>",
        "id": 291497976,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659283561
    },
    {
        "content": "<p>Worth noting. Something I've come across once is that a proof is very extensively documented, but then the API changes, the proof is golfed down, and the old comments all become superfluous.</p>",
        "id": 291503604,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1659290459
    },
    {
        "content": "<p>I imagine trying to make theorems more readable would lead to more of these long proofs necessitating comments, when in reality we should be looking to make things shorter so as to make them immediately clear.</p>",
        "id": 291503785,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1659290645
    },
    {
        "content": "<p>I disagree with top down proofs being harmful to readability. Top down reasoning is the way most people come up with proofs, and in my experience, the way most beginners to proofs try writing them. The only advantage I see to putting every next step into its own <code>have</code> block is that you can see the explicit term being proved, advantage made redundant by the goal view.</p>",
        "id": 291504049,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1659290943
    },
    {
        "content": "<p>But maybe, as has been said before, this is a holy war topic we won't get anything out of discussing.</p>",
        "id": 291504134,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1659291010
    },
    {
        "content": "<p>I think the idea of having some kind of compressed (but re-expandable) representation of proofs should be possible with the correct heuristics. </p>\n<p>The simplest I think that can actually be somewhat informative is keeping only the tactics that depend on local hypotheses; i.e. if I have 12 rewrites, and only the 4th and 7th actually use a local hypothesis, then we only show something like <code>rw [h4, h7]</code>. It isn't valid code anymore, but one can interact with this using the cursor to show the goal state after <code>h4</code>, or after <code>h7</code>, and not see any of the intermediate steps. </p>\n<p>The idea is that the human writing the proof probably rewrote <code>h4</code> as a key step, then did a bunch of <code>rw</code>s to simplify until they could use <code>h7</code>as a key step, etc. If this is a decent measure, then I feel like it would be fairly robust. </p>\n<p>And of course, if the steps between <code>h4</code> and <code>h7</code> are not immediate, then one could expand to show the rewrites in between. How this expansion happens would be chosen heuristically. Maybe through some tagging system that ranks which tactics/lemmas should be erased? <code>@[simp]</code> has been pretty effective so far</p>",
        "id": 291505768,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1659293018
    },
    {
        "content": "<p>Violeta, your opinions about proofs may change when you will encounter more sophisticated proofs.</p>",
        "id": 291511548,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1659300360
    },
    {
        "content": "<p>I think there is, honestly, a tension here between multiple conceptions of what a proof even is, and what \"readability\" of a proof should be. Personally I favour a term-first style (I love using <code>refine</code> and <code>exact</code> and <code>rintros</code> etc. as much possible to really compress down a proof). But obviously such a thing doesn't produce a proof that is very useful for understanding the mathematics or understanding how to use a proof assistant, or even necessarily grant insight into how the proof assistant itself works.</p>\n<p>There are a number of statements above that assume \"readability\" is one thing, and say whether or not it is good. My contention is that it very much isn't: to say a proof is readable without saying for whom and for what is meaningless.</p>\n<p>Far more important to get right, in my view, are statements and definitions. Because of proof irrelevance, it doesn't matter to me how things are proved in Lean, as long as they are (well, with the caveat that one should avoid the use of slow tactics as much as possible - i.e. they should be efficiently verifiable). But it absolutely does matter to me how things are defined and stated. </p>\n<p>As I also mentioned, there are also questions of \"what are proofs for\". Is a proof designed to convince a human of the truth of a statement through mathematical argument? This implies at least one kind of readability. Or perhaps it is simply meant to verify as correct a readable statement - that is another kind. And this is a social question as much as it is a technical one.</p>",
        "id": 291566959,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1659356712
    },
    {
        "content": "<p>(There are also questions of maintainability, which are related to readability but are subtly different. I <em>do</em> think proofs should be maintainable.)</p>",
        "id": 291567084,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1659356765
    },
    {
        "content": "<p>My view on proof irrelevance would be slightly different: since it does not matter for Lean how things are proved, it is better to have proofs that are human-readable (I don't think this statement is meaningless, even though human-readability is not well-defined). I agree that for trivial statements term-proofs are better (it shows that nothing interesting is happening) and if a proof is more readable then it should generally be easier to maintain.</p>",
        "id": 291574818,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1659360338
    },
    {
        "content": "<p>I agree they should be readable for some definition of readable. I don't think this necessarily translate to \"understandable for the interested mathematician\", as <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> puts it, for myself at least.</p>",
        "id": 291593864,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1659368983
    }
]
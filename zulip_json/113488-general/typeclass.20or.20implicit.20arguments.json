[
    {
        "content": "<p>I keep coming back to the question of typeclass or implicit arguments, as I feel I still don't understand well enough what is going on. Let me take the example of the continuity of composition for the sake of the discussion. In mathlib, we have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">},</span> <span class=\"n\">continuous</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">continuous</span>\n<span class=\"n\">def</span> <span class=\"n\">continuous</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">],</span>\n  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n</pre></div>\n\n\n<p>In <code>continuous.comp</code>, the explicit arguments <code>continuous g</code> and <code>continuous f</code> already contain information about some topologies. So, when we use <code>continuous.comp</code>, instance search fires to find topologies on <code>α</code>, <code>β</code> and <code>γ</code>, and then it sees the arguments <code>continuous g</code> and <code>continuous f</code> and it checks that the topologies found by instance search are defeq to the ones in these arguments. </p>\n<p>If instead the topologies in <code>continuous.comp</code> where implicit arguments, then none of this would be needed. However, this is not what we do usually, so I was afraid of some trap. As a little experiment, I changed the definition of <code>continuous.comp</code> to have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hβ</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">hγ</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">},</span> <span class=\"n\">continuous</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Surprisingly, mathlib compiles perfectly well with this change (and I know that <code>continuous.comp</code> is used zillions of times, so this should be a robust check).</p>\n<p>Is there any drawback to this, or should we change our practice and change typeclass argument to implicit arguments whenever this is possible?  (And I have the impression this would be possible at many many many places!)</p>",
        "id": 179739600,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1572772272
    },
    {
        "content": "<blockquote>\n<p>However, this is not what we do usually, so I was afraid of some trap</p>\n</blockquote>\n<p>Isn't this because we had got into our habits before Chris' brilliant idea?</p>",
        "id": 179740339,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572773866
    },
    {
        "content": "<p>Probably yes, but I had not realized yet how this is applicable all over mathlib. Would this be lintable?</p>",
        "id": 179740438,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1572774040
    },
    {
        "content": "<p>An issue is that it would be cumbersome to adjust the (typeclass or implicit) parameters to each statement. Ideally, one could declare parameters with <code>variable {[topological_space α]}</code>, meaning use typeclass unless this is inferrable from later parameters. But this looks like science-fiction to me.</p>",
        "id": 179740523,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1572774203
    },
    {
        "content": "<p>The reason it works in this case is because <code>continuous f</code> and <code>continuous g</code> are hypotheses, which then determine these arguments. Often, the arguments are determined by the type of the conclusion instead, in which case this trick doesn't work. Basically it's the same rule as when we ask if an argument should be implicit vs explicit, except here it is implicit vs instance implicit</p>",
        "id": 179740972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572775184
    },
    {
        "content": "<p>The science fiction solution is actually fact for binder inference in projections of structures; this is the reason why things <code>list.nil</code> would have an explicit alpha but <code>list.cons</code> doesn't (except that we override this behavior in that particular case with the funny <code>| nil {} : list</code> notation)</p>",
        "id": 179741035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572775307
    },
    {
        "content": "<p>Sure, you need a hypothesis (Prop or Type) determining the typeclass. But this happens everywhere! I just opened a file at random and took a random statement:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">minimal_polynomial</span><span class=\"bp\">.</span><span class=\"n\">min</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">α</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">α</span><span class=\"o\">},</span>\n  <span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">monic</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"err\">⇑</span><span class=\"o\">(</span><span class=\"n\">polynomial</span><span class=\"bp\">.</span><span class=\"n\">aeval</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">degree</span> <span class=\"o\">(</span><span class=\"n\">minimal_polynomial</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">degree</span> <span class=\"n\">p</span>\n</pre></div>\n\n\n<p>All the typeclass arguments can be made implicit as they are already contained in <code> is_integral α x</code>.</p>",
        "id": 179742131,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1572777576
    },
    {
        "content": "<p>I can see several options here.<br>\n1) Don't change anything to our practice<br>\n2) In new additions, make implicit the parameters that can be made implicit, and also do it in existing files when it seems useful (possibly with the help of a linter)<br>\n3) Wait for Lean 4, and build there a mechanism that will transform automagically typeclass arguments into implicit arguments if they can be inferred from a later argument.<br>\n4) (unrealistic) fix everything in mathlib</p>\n<p>Any opinion about this? I think it is an important question for performance in Lean 3 as instance search is often a bottleneck.</p>",
        "id": 179742421,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1572778159
    },
    {
        "content": "<blockquote>\n<p>4) (unrealistic) fix everything in mathlib</p>\n</blockquote>\n<p>It's the regex challenge!</p>",
        "id": 179743210,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572779690
    },
    {
        "content": "<p>I don't think this is actually a performance problem, because you still have to search for the instance the first time (in the <code>is_integral α x</code> argument for example) and later searches should just hit the cache. But it does solve the issue with unified instances not matching inferred</p>",
        "id": 179744995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572783321
    },
    {
        "content": "<p>Is it so unrealistic to fix everything in mathlib? Especially if we can get some linter help, it can be done incrementally.</p>",
        "id": 180285171,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1573257792
    }
]
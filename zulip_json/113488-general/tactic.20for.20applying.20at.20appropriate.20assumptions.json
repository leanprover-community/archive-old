[
    {
        "content": "<p>I've got a theorem:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">lc_value</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">exp</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">value</span> <span class=\"bp\">→</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">lc</span>\n</pre></div>\n\n\n<p>Is there a tactical way to apply this theorem to all assumptions matching <code>_.value</code> to produce more assumptions <code>_.lc</code>?</p>",
        "id": 126035144,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525336516
    },
    {
        "content": "<p>How's this for my first attempt at writing a tactic? It can be improved, of course.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">apply_matching</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">texpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>\n  <span class=\"n\">do</span> <span class=\"n\">e</span> <span class=\"err\">←</span> <span class=\"n\">to_expr</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n     <span class=\"n\">et</span> <span class=\"err\">←</span> <span class=\"n\">infer_type</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n     <span class=\"n\">guard</span> <span class=\"n\">et</span><span class=\"bp\">.</span><span class=\"n\">is_arrow</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;&#39;apply_matching&#39; expected a function, got &#39;{et}&#39;&quot;</span><span class=\"o\">,</span>\n     <span class=\"n\">any_hyp</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">do</span>\n       <span class=\"n\">ht</span> <span class=\"err\">←</span> <span class=\"n\">infer_type</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n       <span class=\"n\">unify</span> <span class=\"n\">ht</span> <span class=\"n\">et</span><span class=\"bp\">.</span><span class=\"n\">binding_domain</span><span class=\"o\">,</span>\n       <span class=\"n\">n</span> <span class=\"err\">←</span> <span class=\"n\">mk_fresh_name</span><span class=\"o\">,</span>\n       <span class=\"n\">note</span> <span class=\"n\">n</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">mk_app</span> <span class=\"n\">e</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n</pre></div>",
        "id": 126043003,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525350571
    },
    {
        "content": "<p>That is, I know some ways in which it can be improved, but comments to that effect are most welcome.</p>",
        "id": 126043088,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525350648
    },
    {
        "content": "<p>I believe I've jumped into the rabbit hole now.</p>",
        "id": 126043239,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525350841
    },
    {
        "content": "<p>If I understand correctly, given a rule <code>r : p -&gt; q</code> (where you call my <code>r</code> <code>p</code>) you're looking for an assumption <code>h : p</code> which would allow you to add an assumption <code>h' : q</code>. </p>\n<p>First question: do you expect the user to see the name of that new assumption? If so, I doubt <code>mk_fresh_name</code> will give you appealing names. Maybe you should give at least the option of specifying the name.</p>",
        "id": 126055842,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525368951
    },
    {
        "content": "<p>Second question: is there a reason that your rule wouldn't be desirable if you had a pi type where the bound variable occurs in the term?</p>",
        "id": 126055958,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525369032
    },
    {
        "content": "<p>Third question:  could it not be useful to repeat the process a certain number of times (if the user provides a list of names for the new assumptions, repeat until you run out of names; otherwise, repeat as many times as you can).</p>",
        "id": 126056021,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525369106
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> Thanks for looking at it!</p>\n<blockquote>\n<p>If I understand correctly, given a rule <code>r : p -&gt; q</code> (where you call my <code>r</code> <code>p</code>) you're looking for an assumption <code>h : p</code> which would allow you to add an assumption <code>h' : q</code>. </p>\n</blockquote>\n<p>That's almost correct. My current thinking is to look for all assumptions <code>h_i : p</code> and create all possible new assumptions <code>h_i' : q</code> where <code>h_i' = r h_i</code>.</p>\n<blockquote>\n<p>First question: do you expect the user to see the name of that new assumption? If so, I doubt <code>mk_fresh_name</code> will give you appealing names. Maybe you should give at least the option of specifying the name.</p>\n</blockquote>\n<p>In general, I would expect the new assumptions to be used in something like <code>tauto</code> or possibly just <code>assumption</code>. But I would certainly like to have useful fresh names and not the stuff spit out by <code>mk_fresh_name</code>. (I'm now using <code>get_unused_name</code>, but that doesn't seem much better.) Since multiple fresh names may be created, I think the option of specifying one name is not enough. I thought about doing something like adding a suffix to the name of <code>h</code>. How do I get the name of the hypothesis from the <code>expr</code>?  What do you think?</p>\n<blockquote>\n<p>Second question: is there a reason that your rule wouldn't be desirable if you had a pi type where the bound variable occurs in the term?</p>\n</blockquote>\n<p>Perhaps not. Are you suggesting I use <code>is_pi</code> instead of <code>is_arrow</code>?</p>\n<blockquote>\n<p>Third question:  could it not be useful to repeat the process a certain number of times (if the user provides a list of names for the new assumptions, repeat until you run out of names; otherwise, repeat as many times as you can).</p>\n</blockquote>\n<p>Repeating is indeed my intention. Is it not doing that? I haven't yet tested. But, looking again at <code>any_hyp_aux</code>, it looks like it does stop at the first success. Is there an existing function for iterating over all of the local context or <code>list expr</code>, or should I write one?</p>",
        "id": 126083155,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525415995
    },
    {
        "content": "<blockquote>\n<p>Is there an existing function for iterating over all of the local context or <code>list expr</code>, or should I write one?</p>\n</blockquote>\n<p>Answering my own question: <code>list.mfoldl</code>/<code>list.mfoldr</code></p>",
        "id": 126083607,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525416944
    },
    {
        "content": "<p>The latest version with <code>expr.is_pi</code> and <code>list.mfoldl</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">apply_matching</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">texpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">do</span> <span class=\"n\">e</span> <span class=\"err\">←</span> <span class=\"n\">to_expr</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n     <span class=\"n\">et</span> <span class=\"err\">←</span> <span class=\"n\">infer_type</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n     <span class=\"n\">guard</span> <span class=\"n\">et</span><span class=\"bp\">.</span><span class=\"n\">is_pi</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;&#39;apply_matching&#39; expected a function, got &#39;{et}&#39;&quot;</span><span class=\"o\">,</span>\n     <span class=\"n\">local_context</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">mfoldl</span>\n       <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">do</span>\n         <span class=\"n\">ht</span> <span class=\"err\">←</span> <span class=\"n\">infer_type</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n         <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">try</span> <span class=\"o\">(</span><span class=\"n\">do</span>\n           <span class=\"n\">unify</span> <span class=\"n\">ht</span> <span class=\"n\">et</span><span class=\"bp\">.</span><span class=\"n\">binding_domain</span><span class=\"o\">,</span>\n           <span class=\"n\">n</span> <span class=\"err\">←</span> <span class=\"n\">get_unused_name</span><span class=\"o\">,</span>\n           <span class=\"n\">note</span> <span class=\"n\">n</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">mk_app</span> <span class=\"n\">e</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])))</span>\n       <span class=\"o\">()</span>\n</pre></div>",
        "id": 126085893,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525421583
    },
    {
        "content": "<p>It's funny and annoying that I keep forgetting the commas in Lean <code>do</code>-notation.</p>",
        "id": 126085942,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525421644
    },
    {
        "content": "<p>Now with a <code>'</code> appended to the name of the source hypothesis:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">name</span><span class=\"bp\">.</span><span class=\"n\">update_suffix</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">name</span>\n<span class=\"bp\">|</span> <span class=\"n\">name</span><span class=\"bp\">.</span><span class=\"n\">anonymous</span>        <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">name</span><span class=\"bp\">.</span><span class=\"n\">anonymous</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"bp\">.</span><span class=\"n\">mk_string</span> <span class=\"n\">s</span> <span class=\"n\">p</span><span class=\"o\">)</span>  <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">name</span><span class=\"bp\">.</span><span class=\"n\">mk_string</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">name</span><span class=\"bp\">.</span><span class=\"n\">mk_numeral</span> <span class=\"n\">n</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">name</span><span class=\"bp\">.</span><span class=\"n\">mk_numeral</span> <span class=\"n\">n</span> <span class=\"n\">p</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">apply_matching</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">texpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">do</span> <span class=\"n\">e</span> <span class=\"err\">←</span> <span class=\"n\">to_expr</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n     <span class=\"n\">et</span> <span class=\"err\">←</span> <span class=\"n\">infer_type</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n     <span class=\"n\">guard</span> <span class=\"n\">et</span><span class=\"bp\">.</span><span class=\"n\">is_pi</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;&#39;apply_matching&#39; expected a function, got &#39;{et}&#39;&quot;</span><span class=\"o\">,</span>\n     <span class=\"n\">local_context</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">mfoldl</span>\n       <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">do</span>\n         <span class=\"n\">ht</span> <span class=\"err\">←</span> <span class=\"n\">infer_type</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n         <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">try</span> <span class=\"err\">$</span> <span class=\"n\">do</span>\n           <span class=\"n\">unify</span> <span class=\"n\">ht</span> <span class=\"n\">et</span><span class=\"bp\">.</span><span class=\"n\">binding_domain</span><span class=\"o\">,</span>\n           <span class=\"n\">note</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">local_pp_name</span><span class=\"bp\">.</span><span class=\"n\">update_suffix</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">append</span> <span class=\"s2\">&quot;&#39;&quot;</span><span class=\"o\">))</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">mk_app</span> <span class=\"n\">e</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]))</span>\n       <span class=\"o\">()</span>\n</pre></div>",
        "id": 126088409,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525426359
    },
    {
        "content": "<p>Hmm. I thought perhaps I could remove <code>ht ← infer_type h</code> and <code>unify ht et.binding_domain</code> because <code>note</code> would type check the expression <code>expr.mk_app e [h])</code>, but I ended up generating a new hypothesis for every existing hypothesis. <code>note</code> is defined with <code>assertv_core</code>, but it didn't do what I would expect from a cursory reading.</p>",
        "id": 126088722,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525426924
    },
    {
        "content": "<p>Sorry I missed the first question. At least, you didn't miss it</p>",
        "id": 126093166,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525435609
    },
    {
        "content": "<p>I would change:</p>\n<div class=\"codehilite\"><pre><span></span> et ← infer_type e,\n guard et.is_pi &lt;|&gt; fail format!&quot;&#39;apply_matching&#39; expected a function, got &#39;{et}&#39;&quot;,\n</pre></div>\n\n\n<p>to</p>\n<div class=\"codehilite\"><pre><span></span> (expr.pi _ _ ed _) &lt;- infer_type | fail format!&quot;&#39;apply_matching&#39; expected a function, got &#39;{et}&#39;&quot;,\n</pre></div>",
        "id": 126093228,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525435718
    },
    {
        "content": "<p>and <code>.local_pp_name.update_suffix (flip append \"'\")</code> to <code>.local_pp_name.update_suffix (++ \"'\")</code></p>",
        "id": 126093239,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525435757
    },
    {
        "content": "<blockquote>\n<p><code>note</code> is defined with <code>assertv_core</code>, but it didn't do what I would expect from a cursory reading.</p>\n</blockquote>\n<p>Care to elaborate?</p>",
        "id": 126093335,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525435926
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\"><pre><span></span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">pi</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">ed</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">infer_type</span> <span class=\"bp\">|</span> <span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;&#39;apply_matching&#39; expected a function, got &#39;{et}&#39;&quot;</span><span class=\"o\">,</span>\n</pre></div>\n\n\n</blockquote>\n<p>What is <code>|</code> here? Is this equivalent to the following bracketing (assuming said bracketing is valid)?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">((</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">pi</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">ed</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">infer_type</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;&#39;apply_matching&#39; expected a function, got &#39;{et}&#39;&quot;</span><span class=\"o\">),</span>\n</pre></div>",
        "id": 126093336,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525435932
    },
    {
        "content": "<blockquote>\n<p>and <code>.local_pp_name.update_suffix (flip append \"'\")</code> to <code>.local_pp_name.update_suffix (++ \"'\")</code></p>\n</blockquote>\n<p>Ah, sections are supported. I wasn't sure and didn't try.</p>",
        "id": 126093350,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525435985
    },
    {
        "content": "<p>No, I don't think that's syntactically valid. It's because <code>(expr.pi _ _ ed _) &lt;- infer_type</code> is an incomplete pattern matching statement. <code>|</code> comes in to say \"here's what you do if it doesn't match ...\"</p>",
        "id": 126093403,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525436069
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p><code>note</code> is defined with <code>assertv_core</code>, but it didn't do what I would expect from a cursory reading.</p>\n</blockquote>\n<p>Care to elaborate?</p>\n</blockquote>\n<p>About? <span class=\"emoji emoji-1f642\" title=\"simple smile\">:simple_smile:</span></p>",
        "id": 126093486,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525436192
    },
    {
        "content": "<blockquote>\n<p>No, I don't think that's syntactically valid. It's because <code>(expr.pi _ _ ed _) &lt;- infer_type</code> is an incomplete pattern matching statement. <code>|</code> comes in to say \"here's what you do if it doesn't match ...\"</p>\n</blockquote>\n<p>I see. Is this <code>|</code> strictly for pattern-matching in <code>do</code>-notation? Is it notation defined somewhere, or is it built in?</p>",
        "id": 126093504,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525436275
    },
    {
        "content": "<p>And there's a subtle difference with <code>&lt;|&gt;</code>. While <code>do x &lt;- a &lt;|&gt; b, c</code> means <code>a &lt;|&gt; b &gt;&gt;= λ x, c</code>, <code>do x &lt;- a | b, c</code> means:</p>\n<div class=\"codehilite\"><pre><span></span>a &gt;&gt;= λ x₀,\nmatch x₀ with\n | x := c\n | _ := b\nend\n</pre></div>",
        "id": 126093554,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525436308
    },
    {
        "content": "<p>i.e. when you run <code>b</code>, you exit immediately. If <code>b</code> is not a fail statement but a statement like <code>return none</code>, the whole function returns <code>non</code>.</p>",
        "id": 126093560,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525436380
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\"><pre><span></span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">pi</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">ed</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">infer_type</span> <span class=\"bp\">|</span> <span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;&#39;apply_matching&#39; expected a function, got &#39;{et}&#39;&quot;</span><span class=\"o\">,</span>\n</pre></div>\n\n\n</blockquote>\n<p>Except that, with this, I no longer have <code>et</code>. <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>",
        "id": 126093665,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525436572
    },
    {
        "content": "<blockquote>\n<blockquote>\n<blockquote>\n<p>note is defined with assertv_core, but it didn't do what I would expect from a cursory reading.</p>\n</blockquote>\n<p>Care to elaborate?</p>\n</blockquote>\n<p>About? </p>\n</blockquote>\n<p>Hoping to break records of quotes within quotes, here's my answer. Please, let's make this an Inception of quotes.</p>\n<p>What did you expect from <code>assertv_core</code> and how did the reality differ?</p>",
        "id": 126093722,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525436691
    },
    {
        "content": "<blockquote>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">pi</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">ed</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">infer_type</span> <span class=\"bp\">|</span> <span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;&#39;apply_matching&#39; expected a function, got &#39;{et}&#39;&quot;</span><span class=\"o\">,</span>\n</pre></div>\n\n\n</blockquote>\n<p>Except that, with this, I no longer have <code>et</code>. <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>I missed the occurrence in the error message. What a bummer! I thought we could get rid of it. Let's go with:</p>\n<div class=\"codehilite\"><pre><span></span> <span class=\"n\">et</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">infer_type</span><span class=\"o\">,</span>\n <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">pi</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">ed</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">pure</span> <span class=\"n\">et</span> <span class=\"bp\">|</span> <span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;&#39;apply_matching&#39; expected a function, got &#39;{et}&#39;&quot;</span><span class=\"o\">,</span>\n</pre></div>",
        "id": 126093796,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525436829
    },
    {
        "content": "<blockquote>\n<p>What did you expect from <code>assertv_core</code> and how did the reality differ?</p>\n</blockquote>\n<p>As I said, I expected it to type-check the expression.</p>",
        "id": 126093802,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525436863
    },
    {
        "content": "<blockquote>\n<p>Let's go with:</p>\n<div class=\"codehilite\"><pre><span></span> <span class=\"n\">et</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">infer_type</span><span class=\"o\">,</span>\n <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">pi</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">ed</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">pure</span> <span class=\"n\">et</span> <span class=\"bp\">|</span> <span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;&#39;apply_matching&#39; expected a function, got &#39;{et}&#39;&quot;</span><span class=\"o\">,</span>\n</pre></div>\n\n\n</blockquote>\n<p>Hmm, I'm not convinced that's better. <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>",
        "id": 126093848,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525436940
    },
    {
        "content": "<p>Oh I see. I would think that too. But as the developers keep pointing out, they are very aggressive in their optimization. They try to never type check by default. The whole proof will be type checked at the end so that's not unsafe but it does mean that you have to <code>unify</code> or <code>type_check</code> when you think you need it.</p>",
        "id": 126093923,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525437071
    },
    {
        "content": "<blockquote>\n<p>Oh I see. I would think that too. But as the developers keep pointing out, they are very aggressive in their optimization. They try to never type check by default. The whole proof will be type checked at the end so that's not unsafe but it does mean that you have to <code>unify</code> or <code>type_check</code> when you think you need it.</p>\n</blockquote>\n<p>Oh, interesting. So, you can introduce badly typed hypotheses?</p>",
        "id": 126093981,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525437166
    },
    {
        "content": "<blockquote>\n<p>Oh, interesting. So, you can introduce badly typed hypotheses?</p>\n</blockquote>\n<p>... and goals?</p>",
        "id": 126093988,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525437198
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>Let's go with:</p>\n<div class=\"codehilite\"><pre><span></span> <span class=\"n\">et</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">infer_type</span><span class=\"o\">,</span>\n <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">pi</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">ed</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">pure</span> <span class=\"n\">et</span> <span class=\"bp\">|</span> <span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;&#39;apply_matching&#39; expected a function, got &#39;{et}&#39;&quot;</span><span class=\"o\">,</span>\n</pre></div>\n\n\n</blockquote>\n<p>Hmm, I'm not convinced that's better. <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>Yeah, that's less of an improvement</p>",
        "id": 126093993,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525437226
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>Oh, interesting. So, you can introduce badly typed hypotheses?</p>\n</blockquote>\n<p>... and goals?</p>\n</blockquote>\n<p>The expressions and goals are still type checked from time to time but you can find a way.</p>",
        "id": 126094048,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525437339
    },
    {
        "content": "<p>I think <code>to_expr</code> type checks the expression so that already filters out a lot of nonsense</p>",
        "id": 126094114,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525437415
    },
    {
        "content": "<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>note is defined with assertv_core, but it didn't do what I would expect from a cursory reading.</p>\n</blockquote>\n<p>Care to elaborate?</p>\n</blockquote>\n<p>About? </p>\n</blockquote>\n<p>Hoping to break records of quotes within quotes, here's my answer. Please, let's make this an Inception of quotes.</p>\n</blockquote>\n<p>I think Zulip needs threads within topics within streams... <span class=\"emoji emoji-1f3d8\" title=\"house buildings\">:house_buildings:</span></p>",
        "id": 126094120,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525437439
    },
    {
        "content": "<p>Current version:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">note_all_applied</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">texpr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n  <span class=\"n\">do</span> <span class=\"n\">e</span> <span class=\"err\">←</span> <span class=\"n\">to_expr</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n     <span class=\"n\">et</span> <span class=\"err\">←</span> <span class=\"n\">infer_type</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n     <span class=\"n\">guard</span> <span class=\"n\">et</span><span class=\"bp\">.</span><span class=\"n\">is_pi</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">fail</span> <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;&#39;note_all_applied&#39; expected a function, got &#39;{et}&#39;&quot;</span><span class=\"o\">,</span>\n     <span class=\"n\">local_context</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">mfoldl</span>\n       <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">do</span>\n         <span class=\"n\">ht</span> <span class=\"err\">←</span> <span class=\"n\">infer_type</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n         <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">try</span> <span class=\"err\">$</span> <span class=\"n\">do</span>\n           <span class=\"n\">unify</span> <span class=\"n\">ht</span> <span class=\"n\">et</span><span class=\"bp\">.</span><span class=\"n\">binding_domain</span><span class=\"o\">,</span>\n           <span class=\"n\">note</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">local_pp_name</span><span class=\"bp\">.</span><span class=\"n\">update_suffix</span> <span class=\"o\">(</span><span class=\"bp\">++</span> <span class=\"s2\">&quot;&#39;&quot;</span><span class=\"o\">))</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">mk_app</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]))</span>\n       <span class=\"o\">()</span>\n</pre></div>\n\n\n<p>I'm not really sure about a good name. <code>apply_matching</code> is certainly not good: too much of a connection to <code>apply</code>.</p>",
        "id": 126094324,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525437755
    },
    {
        "content": "<p>how about <code>have_spec</code> (for specialization)?</p>",
        "id": 126094606,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525438262
    },
    {
        "content": "<p>I think you you should check if the domain of <code>e</code> is a proposition. If it is, having multiple specializations will only be noisy</p>",
        "id": 126094623,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525438307
    },
    {
        "content": "<blockquote>\n<p>how about <code>have_spec</code> (for specialization)?</p>\n</blockquote>\n<p>1. My immediate thought is to expand <code>spec</code> to <code>specification</code>.<br>\n2. I would not naturally think of this as specialization. The resulting type depends on the argument.</p>",
        "id": 126094786,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525438624
    },
    {
        "content": "<p>and Kevin is defining the <code>spec</code>trum of a ring... although that will probably be called <code>Spec</code>.</p>",
        "id": 126094897,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1525438812
    },
    {
        "content": "<blockquote>\n<p>I think you you should check if the domain of <code>e</code> is a proposition. If it is, having multiple specializations will only be noisy</p>\n</blockquote>\n<p>I don't follow. If I have this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">,</span>\n<span class=\"n\">note_all_applied</span> <span class=\"n\">or_true</span>\n</pre></div>\n\n\n<p>I see this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n<span class=\"n\">h&#39;</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"bp\">∨</span> <span class=\"n\">true</span> <span class=\"bp\">↔</span> <span class=\"n\">true</span>\n</pre></div>",
        "id": 126095717,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525440191
    },
    {
        "content": "<p><em>a proposition</em></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"o\">:</span>  <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n<span class=\"k\">assume</span> <span class=\"n\">h&#39;</span> <span class=\"o\">:</span>  <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n<span class=\"n\">note_all_applied</span> <span class=\"o\">(</span><span class=\"n\">not_lt_of_ge</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>The above should only produce one more assumption, not two.</p>",
        "id": 126096992,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525442371
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> I'm sorry, but I'm still not getting what you're saying.</p>\n<p>What do you mean by a proposition? I used <code>h : Prop</code>, but you may be thinking of something else.</p>\n<p>I tried to make a working example out of your code, and this is what I have:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">h&#39;</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">note_all_applied</span> <span class=\"n\">not_lt_of_ge</span>\n</pre></div>\n\n\n<p>The state:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"n\">h&#39;</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n<span class=\"n\">h&#39;</span> <span class=\"n\">h&#39;&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span>\n<span class=\"err\">⊢</span> <span class=\"err\">?</span><span class=\"n\">m_1</span>\n</pre></div>\n\n\n<p>So, two things are clearly problematic here:</p>\n<ul>\n<li>Output hypotheses (<code>h'</code>, <code>h''</code>) with the same type (<code>¬y &lt; x</code>). However, there are input hypotheses with the same type. I'm not sure this is something the tactic should handle because:<ul>\n<li>Handling duplicate outputs adds complexity when the duplicate inputs already exist, and, consequently, this complexity appears unnecessary.</li>\n<li>If the tactic did something else, what would it be, and would it still be predictable?</li>\n</ul>\n</li>\n<li>Duplicate <code>h'</code> hypotheses. The output hypothesis naming could certainly be better. It would be nice to have fresh, readable, predictable names, perhaps similar to what <code>cases</code> and <code>induction</code> do. Do you have any suggestions for this?</li>\n</ul>\n<p>That said, I'm not sure what the above has to do with propositions. The same issues can be shown with non-<code>Prop</code> types:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">note_all_applied</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n</pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">x&#39;</span> <span class=\"n\">y&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span>\n<span class=\"err\">⊢</span> <span class=\"kt\">Prop</span>\n</pre></div>",
        "id": 126170825,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525598771
    },
    {
        "content": "<p>What I was trying to point out is that the types of <code>h</code>,<code>h'</code>,<code>h'</code> and <code>h''</code> themselves have type <code>Prop</code>. Maybe I should have called them proofs instead of proposition. Sorry for the confusion.</p>\n<p>I was saying that using many of them in your tactic would result in repetition because of proof irrelevant.</p>",
        "id": 126183355,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525629122
    },
    {
        "content": "<p>As you point out, that might make for a highly redundant tactic code.</p>",
        "id": 126183363,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525629140
    },
    {
        "content": "<p>If you decide to adopt that more aggressive simplification, you can replace <code>mfold</code> or <code>for_each</code> with:</p>\n<div class=\"codehilite\"><pre><span></span>meta def for_each_considering_proof_irrelevance {α : Type}\n  (irrel : bool) (f : α → tactic unit) (xs : list α) : tactic unit :=\nif irrel then\n  xs.any_of f\nelse\n  xs.for_each f\n</pre></div>",
        "id": 126183637,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1525629747
    },
    {
        "content": "<p>Thanks for pointing at <code>for_each</code> and <code>any_of</code>. Funny that they don't seem to be used at all in the Lean core library.</p>",
        "id": 126202657,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525674414
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"110045\">@Sean Leather</span>, what happened to this tactic? I think I want it now, and I'm not sure where to look for it.</p>",
        "id": 131154182,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1533797062
    },
    {
        "content": "<p>You mean the one and only tactic I ever wrote? It's <a href=\"https://github.com/spl/tts/blob/69893255c64e407f3b3ca6e9ff6242f7120177d8/src/tactics.lean#L15-L24\" target=\"_blank\" title=\"https://github.com/spl/tts/blob/69893255c64e407f3b3ca6e9ff6242f7120177d8/src/tactics.lean#L15-L24\">here</a>. I think I use it in the same repository, but I'm not convinced it is actually that useful.</p>",
        "id": 131155526,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533799085
    }
]
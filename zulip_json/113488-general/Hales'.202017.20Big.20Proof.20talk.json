[
    {
        "content": "<p>I'm giving a talk today at Inria and in the talk I mention Hales' July 2017 talk at the Big Proof Newton Institute workshop: <a href=\"https://www.newton.ac.uk/seminar/20170710100011001\">https://www.newton.ac.uk/seminar/20170710100011001</a> (I always love the binary link, I think it means 10th July, 10am to 11am, room 1). It's worth investing an hour watching the video, but there's also a link to the slides on that page (although, like any good slide talk, the slides don't make sense by themselves, so you have to watch the video to hear the full story). I watched it again yesterday, to remind me of exactly what he had said and what the state of the art was in 2017. This was the talk that got me interested in Lean (I had never heard of Lean before this talk, but he mentions it in the answer to a question).</p>\n<p>p11 of the slides talks about Lessons from the formalisation of Kepler, and one is:</p>\n<blockquote>\n<p>Formalizers should be part of the tactical response teams that<br>\nroutinely intervene in prominent, difficult, unpublished proofs.</p>\n</blockquote>\n<p>I think that the work going on right now in the <a class=\"stream\" data-stream-id=\"267928\" href=\"/#narrow/stream/267928-condensed-mathematics\">#condensed mathematics</a> stream fits this description very well. We are formalising a prominent, difficult, unpublished result of Clausen and Scholze. Hales explicitly mentions the ABC conjecture on the next slide, and I had a discussion with Ivan Fesenko about whether this was feasible recently (I think the difficulty is getting someone to start doing it, I think a top-down formalisation would be one way to make progress). </p>\n<p>Slide 32 talks about difficulties with Fabstracts and his attitude is \"ignore them for now\" -- my understanding of his point here is that we need to look at the greater goal of getting a deliverable to working mathematicians which they can actually understand. Right now we have difficulties with porting mathlib to Lean 4 but the overall goal of getting mathematicians interested in this area in general is greater than this obstruction which is why I am still highly motivated to continue working on mathematics in Lean 3. Someone in private conversations raised the possibility of just porting mathlib by hand, as did Daniel Selsam publically recently, and if this is what we ultimately have to do then I'm sure it will get done. This is going to be a hard problem but I don't think we should let it get in the way.</p>\n<p>The final thing I want to flag is that on slide 34 Hales lists a bunch of things which would need to be done just to formalise statements in automorphic representation theory (the branch of number theory that Hales and I work in). I think that at the time that list just looked like a big joke to some people. But the first thing on the list is schemes and the last thing is perfectoid spaces, and we've shown that these things can be done. There is also measure theory, functional analysis, Galois theory, category theory, and we have many of the main definitions in mathlib now. There is also a bunch of stuff which we don't have but which I absolutely have one eye on. I think Hales' point with this slide was that even formalising part of number theory is going to be a huge amount of work, however I am not sure that even he would have envisaged that four years later one could look at his list and say \"well a whole bunch of that stuff is either done, or could be done soon\".</p>",
        "id": 233629724,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617876610
    },
    {
        "content": "<p>Can you give a link for today talk? Thank's!</p>",
        "id": 233631066,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617877501
    },
    {
        "content": "<p>I'm not sure it's public! It's also for computer scientists. <a href=\"http://68nqrt.inria.fr/index.html\">http://68nqrt.inria.fr/index.html</a> . Maybe the link just works?</p>",
        "id": 233632377,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617878347
    },
    {
        "content": "<p>It is a 30 minute seminar and then a 30 minute discussion.</p>",
        "id": 233632402,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617878371
    },
    {
        "content": "<p>It seems to work, thank you!</p>",
        "id": 233633509,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1617879112
    },
    {
        "content": "<p>I enjoyed the talk.</p>",
        "id": 233661833,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1617892157
    },
    {
        "content": "<p>I wonder if you actually failed to upset anyone. :-)</p>",
        "id": 233661906,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1617892180
    },
    {
        "content": "<p>I tried really hard but I think my comments about Voevodsky could upset some people. I wanted to give the impression that you'll never attract most mathematicians unless you work classically, and basically I'm saying that Voevodsky's constructivism was a big mistake, but i know there are people who worship him</p>",
        "id": 233664175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617892921
    },
    {
        "content": "<p>Sorry I had to drop a bit early due a meeting. But I loved the talk ;-)</p>",
        "id": 233665356,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1617893320
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> are you aware of some typical theorems that don't work in a constructivist setting? (I mean not just painful to prove but known to not be provable)</p>",
        "id": 233666072,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1617893555
    },
    {
        "content": "<p>The issue with this question is that it kind of assumes that the theorems I think about can even be <em>stated</em> in a constructivist setting. In algebraic geometry there is something called a scheme, which is a topological space which locally looks like an affine scheme, and an affine scheme is a topological space which is built from a commutative ring, and without LEM you cannot even prove that the thing you construct from the ring is a topological space, so in some sense an answer to your question is \"every theorem about schemes\". Here is a link to (something which unfolds to) a 7000 page pdf which has a few theorems about schemes: <a href=\"https://stacks.math.columbia.edu/\">https://stacks.math.columbia.edu/</a> . </p>\n<p>The answers that the constructivists give to this is \"well you have to reformulate the statements so that they make sense construtively, you need to go and learn the theory of locales\". But the moment I start talking about locales, I have lost all of the algebraic geometers in my department, who have never heard of locales. So for me this is not a satisfactory way to proceed.</p>",
        "id": 233666892,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617893827
    },
    {
        "content": "<p>Nice, I hadn't realised you'd fail already at that level.</p>",
        "id": 233670553,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1617894611
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"235513\">@Daniel Fabian</span> Every ring has a maximal ideal. You need choice for that. And it's a fact that's used a number of times in getting commutative algebra of the ground (and hence algebraic geometry and a bunch of number theory)</p>",
        "id": 233672141,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617894993
    },
    {
        "content": "<p>Also,</p>\n<ul>\n<li>existence of algebraic closures,</li>\n<li>existence of bases of vector spaces,</li>\n<li>bipartite iff 2-colourable</li>\n</ul>\n<p>are further examples of statements that are equivalent (I think) to the Axiom of choice.</p>\n<p>On the other hand, \"most\" algebraic geometry used in practice is for schemes of finite type over ℤ (or ℚ, if you really need a field).  In such cases, my guess is that many statements could be salvaged, but it would probably be hard, non-rewarding work.</p>",
        "id": 233673702,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617895421
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> We sure use algebraically closed fields a lot. But I guess we only really need <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mover accent=\"true\"><mi mathvariant=\"double-struck\">F</mi><mo>ˉ</mo></mover><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\bar\\mathbb{F}_p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.111778em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8256699999999999em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">F</span></span></span><span style=\"top:-3.25789em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.16666em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span> most of the time...</p>",
        "id": 233674354,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617895667
    },
    {
        "content": "<p>I would go further and say that most of the times you use an a-priori-hard-to-specialize <em>finite</em> extension of the ground field.  In many cases, you could probably work hard and figure out an extension that actually works, but... why?!?! <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 233674574,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617895747
    },
    {
        "content": "<p>Something that took me a while to internalize is the difference between \"closed under specialization\" and \"closed\": it is tricky to come up with examples of \"reasonable\" properties of schemes that are closed under specialization, but not closed.  Such properties would be good challenges for constructivism, I think.</p>",
        "id": 233674999,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617895856
    },
    {
        "content": "<p>For instance, proving the Noether-Lefschetz theorem for quartics in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"double-struck\">P</mi><mi mathvariant=\"double-struck\">C</mi><mn>3</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{P}^3_{\\mathbb{C}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.093331em;vertical-align:-0.279223em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">P</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-2.420777em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathbb mtight\">C</span></span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.279223em;\"><span></span></span></span></span></span></span></span></span></span> <em>constructively</em> could be a good test!</p>",
        "id": 233675315,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617895972
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> thanks!</p>",
        "id": 233676475,
        "sender_full_name": "Daniel Fabian",
        "timestamp": 1617896362
    },
    {
        "content": "<p>It's maybe worth pointing out that a lot of the strangeness of constructive mathematics comes from absence of LEM rather than choice. A pedestrian example of a theorem that's not valid constructively is \"Z is a PID\". The problem is that even if you have a decidable subset of Z, you can't tell if it has a non-zero element. Similarly with algebraic closures you can't tell if a polynomial is reducible or irreducible, so splitting fields are already problematic</p>",
        "id": 233711660,
        "sender_full_name": "David Wärn",
        "timestamp": 1617909042
    },
    {
        "content": "<p>Of course, the constructivist (me!) would say that the classical definition of PID misses the point, and ℤ is a perfectly fine Bézout <code>wf_dvd_monoid</code>.</p>",
        "id": 233711950,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1617909162
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>, I'm curious to what you extent you think it would be viable for someone who cared about <code>wf_dvd_monoid</code>s  to contribute to refactoring mathlib \"from the bottom\" to introduce and use constructivist ideas. It would be essential that all the 90% that was still classical could stay essentially as it is (but that's okay, I presume, as PID -&gt; wf_dvd_monoid). Presumably actually the question is about whether you think it would work from a community-interaction point of view.</p>",
        "id": 233749678,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1617927243
    },
    {
        "content": "<p>I think making mathlib, as it stands right now, constructivist behind the scenes would require more than one person. There are quite a few fundamental definitions like <code>finsupp</code>, where treating them constructively was causing too much work for the classical side of things. If some of the technology improved (e.g. we wouldn't need to be so careful with <code>decidable_eq</code>), my hope is that making one definition constructive wouldn't break downstream usages (or at least, not as much as it does right now). In that case, people who care about constructivism don't make life worse for working classically, and I can see one or perhaps a pair of interested contributors making most of mathlib constructive.</p>\n<p>One aspect of Lean that I think is an advantage for the constructivists, is that it is still ultimately based on type theory: there is a good notion of data in Lean, and you can point out instances where having access to this data is really useful for the working mathematician.</p>",
        "id": 233782563,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1617955197
    },
    {
        "content": "<p>My arguments against constructivism are: (1) mathematicians in maths departments are brought up to think that constructivists are crazy, so even <em>talking</em> about constructivism involves some risk when it comes to being taken seriously by the mathematicians who matter (2) constructivism makes the library harder for mathematicians to use (c.f. Peter Nelson with his finset woes) (3) constructivists tend to overestimate the importance of constructivism in mathematics, perhaps due to their mathematical tastes not being aligned with what is actually going on in mathematics departments (i.e. a mismatch between what I think the word mathematics \"means\" and what a constructivist thinks it means).</p>\n<p>Anecdotal evidence: when I read the odd order paper I was really turned off by the explanation of how they struggled to do representation theory because they didn't have access to the complex numbers, and simply could not understand what the point of working extra-hard to develop enough of a constructive theory of representation theory to push the arguments through. It was that, and the fact that they also highlighted their idea of defining a group hom from G to H as a partially defined map from some bigger group which contained G and H which just made me think that these people were crazy -- somehow they seemed to be investing a lot of time into issues which I felt should not be there in a proof system. However I really don't know how many other mathematicians would react the way I reacted to that paper. One can contrast that with what Patrick wrote in the perfectoid paper about extending continuous maps defined on dense subsets, and how he had the insight of not working with subsets at all but finding the correct abstraction and thus \"beating Bourbaki\" (a phrase he would not use himself, I know) where here he is proposing diverging from the standard literature but in a way which makes a lot of sense to me.</p>",
        "id": 233791466,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617960337
    },
    {
        "content": "<p>Isn't being constructive just a totally independent issue than being formal? You can do neither, either, or both. Why fight two wars at once? It's hard enough to be formal.</p>",
        "id": 233793628,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1617961532
    },
    {
        "content": "<p>I thought formalising was a fun puzzle game, not a war :-)</p>",
        "id": 233794483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617961949
    },
    {
        "content": "<p>It's an addiction! The war is getting others hooked :-)</p>",
        "id": 233794545,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1617961986
    },
    {
        "content": "<p>Those three points are good ones, and IMO they are sufficient to show that we shouldn't replace mathlib with a purely constructive library. The way I approach constructivism is not as much a project to replace existing mathematics, but instead ask a new question, which I believe is interesting and can lead to useful insights: what do we need to do to make sense of these notions in a constructive/computational setting?  And if the topic is not formalized at all, a classical formalization is much more useful to mathlib than an unfinished constructive formalization.</p>",
        "id": 233795792,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1617962559
    },
    {
        "content": "<p>I think your approach is sensible and practical!</p>",
        "id": 233796173,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617962753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/113488-general/topic/Hales'.202017.20Big.20Proof.20talk/near/233793628\">said</a>:</p>\n<blockquote>\n<p>Isn't being constructive just a totally independent issue than being formal? You can do neither, either, or both. Why fight two wars at once? It's hard enough to be formal.</p>\n</blockquote>\n<p>Sure you can do neither, either, or both (and I think it makes a lot of sense for mathlib to do one but generally not the other), but they're not totally separate issues. There's a lot of synergy between constructive mathematics and formal mathematics. If you want to prove things about your definitions, it helps if the computer can unfold your definitions, and this is easier if your definitions are constructive. I think there's even more synergy in univalent foundations, with its hProps. One of the fundamental obstructions to making mathlib constructive is the proof-irrelevant <code>Prop</code>. On the one hand it's very useful because you get lots of defeqs, on the other hand it's constructively problematic because you can't extract data from it.</p>",
        "id": 233798407,
        "sender_full_name": "David Wärn",
        "timestamp": 1617963998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/113488-general/topic/Hales'.202017.20Big.20Proof.20talk/near/233793628\">said</a>:</p>\n<blockquote>\n<p>Isn't being constructive just a totally independent issue than being formal? You can do neither, either, or both. Why fight two wars at once? It's hard enough to be formal.</p>\n</blockquote>\n<p>I guess they are not totally independent in the sense that if you go both formal and constructive then any natural number you define (like the rank of some elliptic curve over Q or the order of the torsion of some homotopy group) automatically comes with an algorithm to evaluate it. That algorithm probably won't be practical or efficient but there is some psychological comfort in having it.</p>",
        "id": 233799754,
        "sender_full_name": "Joachim Hauge",
        "timestamp": 1617964719
    },
    {
        "content": "<p>But there is no known algorithm to compute the rank of an elliptic curve over Q, and yet I want to talk about it because I want to state BSD.</p>",
        "id": 233799825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617964771
    },
    {
        "content": "<p>There are algorithms which work in most cases, but they rely on Sha being finite which is a big open problem.</p>",
        "id": 233799864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617964797
    },
    {
        "content": "<p>Note that I do not feel at all psychologically uncomfortable about this fact :-)</p>",
        "id": 233799952,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617964827
    },
    {
        "content": "<p>There is no algorithm that has been proven to be correct for all elliptic curves. But if you define a specific elliptic curve in a dependent type theory with canonicity then the rank of that specific elliptic curve (which is a closed term of N) necessarily comes with an algorithm to evaluate it.</p>",
        "id": 233800046,
        "sender_full_name": "Joachim Hauge",
        "timestamp": 1617964908
    },
    {
        "content": "<p>This sounds to me like a massive warning sign to mathematicians -- \"don't use dependent type theories with canonicity\".</p>",
        "id": 233800131,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617964952
    },
    {
        "content": "<p>A particular strain of mathematicians has come to dominate the funding agencies and universities but I'm not sure what the reasons for that are. It would seem the society at large doesn't care either way.</p>",
        "id": 233800303,
        "sender_full_name": "Joachim Hauge",
        "timestamp": 1617965061
    },
    {
        "content": "<p>In fact I am really confused by what you are saying. I can just write down <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>38756382756386</mn><mi>x</mi><mo>+</mo><mn>23478368756345</mn></mrow><annotation encoding=\"application/x-tex\">y^2=x^3+38756382756386x+23478368756345</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mord\">8</span><span class=\"mord\">7</span><span class=\"mord\">5</span><span class=\"mord\">6</span><span class=\"mord\">3</span><span class=\"mord\">8</span><span class=\"mord\">2</span><span class=\"mord\">7</span><span class=\"mord\">5</span><span class=\"mord\">6</span><span class=\"mord\">3</span><span class=\"mord\">8</span><span class=\"mord\">6</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">3</span><span class=\"mord\">4</span><span class=\"mord\">7</span><span class=\"mord\">8</span><span class=\"mord\">3</span><span class=\"mord\">6</span><span class=\"mord\">8</span><span class=\"mord\">7</span><span class=\"mord\">5</span><span class=\"mord\">6</span><span class=\"mord\">3</span><span class=\"mord\">4</span><span class=\"mord\">5</span></span></span></span> and it might be the case that humanity cannot prove that there is an algorithm which is guaranteed to terminate to compute the rank of this curve. Yet I want to be able to state BSD in Lean, because if I cannot then the particular strain of mathematicians who have come to dominate the funding agencies and universities, i.e. precisely the people that it is absolutely crucially important that we as a community appeal to if we want this area to grow, will think our prover is useless.</p>",
        "id": 233800735,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617965309
    },
    {
        "content": "<p>Oh OK I am unconfused. The point is that the definition of rank is this: \"I can write down a concrete computable Q-vector space. I can write down a noncomputable predicate on this which cuts out a subspace. The rank is the dimension of this subspace\".</p>",
        "id": 233800771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617965333
    },
    {
        "content": "<p>Mathematicians decided 100 years ago that if they allowed this definition then mathematics would grow much faster, and now there's no going back.</p>",
        "id": 233800945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617965412
    },
    {
        "content": "<p>This case is particularly subtle, because there is actually also an algorithm which should in theory define a computable predicate which cuts out the same subspace, but nobody can prove that it terminates in general (although it always terminated whenever anyone ran it on a concrete elliptic curve).</p>",
        "id": 233801273,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617965593
    },
    {
        "content": "<blockquote>\n<p>If you want to prove things about your definitions, it helps if the computer can unfold your definitions, and this is easier if your definitions are constructive.</p>\n</blockquote>\n<p>I don't really buy this argument anymore. \"Constructive\" means \"computable\" only in the barest possible sense; if you actually <em>really</em> care about computation, the stuff intuitionistic mathematics gives you is not very useful. Put another way, constructive mathematics tries to be both mathematics and computation, and ends up being a poor approximation of both. What's more, it turns out that when reasoning about algorithms there isn't any particular reason to be constructive in your logic; you can still prove asymptotic bounds on programs and all the rest.</p>",
        "id": 233801284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617965603
    },
    {
        "content": "<blockquote>\n<p>One of the fundamental obstructions to making mathlib constructive is the proof-irrelevant Prop. On the one hand it's very useful because you get lots of defeqs, on the other hand it's constructively problematic because you can't extract data from it.</p>\n</blockquote>\n<p>I wouldn't call this a fundamental obstruction. The basic idea is that if you want to extract data from something, put it in <code>Type</code>, otherwise put it in <code>Prop</code>. You can still do many of the hProp tricks in <code>Type</code>, for example <code>trunc</code> is the (computable!) propositional truncation, and you can eliminate from it to any type that is a subsingleton.</p>",
        "id": 233801711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617965840
    },
    {
        "content": "<p>Most constructions that we can actually reasonably compute are in the correct universes for doing so. If not, there would be a lot more <code>noncomputable</code> stuff than there currently is</p>",
        "id": 233801853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617965928
    },
    {
        "content": "<p>There are a few notable exceptions, like <code>finsupp</code>, <code>polynomial</code> and <code>real</code>, where we could be computable and made a conscious decision not to be in order to make the maths smoother, but in all cases there is actually some subtlety to picking an appropriate data representation to be not just computable but also computationally efficient, and the plan is to make computational analogues of these types if and when they get used for some algorithm, so that they can be appropriately tailored to that use-case.</p>",
        "id": 233802229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617966120
    },
    {
        "content": "<p>A good recent example is from the <a href=\"https://github.com/leanprover-community/mathlib/pull/7057\"><code>itauto</code></a> decision procedure I PR'd. This starts with a definition of an inductive type <code>prop</code> representing intuitionistic propositions. Even though lean's <code>Prop</code> is \"not computable\", that didn't prevent me from writing a program that computes with elements of <code>Prop</code>, because I can just reflect into an inductive type tailored to the purpose at hand.</p>",
        "id": 233802632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617966324
    },
    {
        "content": "<p><code>norm_num</code> works the same way. Even though equality on <code>real</code> is \"not computable\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">9</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">5</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>It seems \"not computable\" doesn't actually mean what it sounds</p>",
        "id": 233803029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617966503
    },
    {
        "content": "<p>By the way, would there be a conceptual problem in making polynomials irreducible? Currently, they are not, and this led to some difficulties in <a href=\"https://github.com/leanprover-community/mathlib/issues/7084\">#7084</a> (big <code>rfl</code> or <code>convert</code> that are unreasonably slow).</p>",
        "id": 233814016,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1617972242
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> has tried this, but it caused a lot of breakage.</p>",
        "id": 233814674,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617972576
    },
    {
        "content": "<p>Gabriel has done some very helpful work in this direction too.</p>",
        "id": 233814721,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1617972601
    },
    {
        "content": "<p>I think there have been several rounds of: 1) make <code>polynomial</code> irreducible 2) fix some breakages 3) revert it to semireducible because you didn't fix everything 4) PR the fixes.</p>",
        "id": 233814868,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1617972657
    },
    {
        "content": "<p>It would be lovely to be able to omit step 3)!</p>",
        "id": 233814893,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1617972670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/Hales'.202017.20Big.20Proof.20talk/near/233800131\">said</a>:</p>\n<blockquote>\n<p>This sounds to me like a massive warning sign to mathematicians -- \"don't use dependent type theories with canonicity\".</p>\n</blockquote>\n<p>You can still define noncomputable numbers like the rank of an elliptic curve in such a system. It just won't be a natural number, but some sort of generalised natural number -- \"bounded initial segment of N\", or something like this. You might not like this, I'm just trying to say that it's possible to express these things constructively</p>",
        "id": 233822083,
        "sender_full_name": "David Wärn",
        "timestamp": 1617975539
    },
    {
        "content": "<p>The double-negation fragment of constructive mathematics is indeed the most natural one. <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 233822444,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1617975694
    },
    {
        "content": "<blockquote>\n<p>What's more, it turns out that when reasoning about algorithms there isn't any particular reason to be constructive in your logic; you can still prove asymptotic bounds on programs and all the rest.</p>\n</blockquote>\n<p>Sure. But there is a reason to be constructive in your logic if you want to extract data from your proofs. If you want to prove that <code>f</code> is bijective and injective, and then get a computable inverse from this proof, then your logic had better be constructive.</p>",
        "id": 233824356,
        "sender_full_name": "David Wärn",
        "timestamp": 1617976395
    },
    {
        "content": "<blockquote>\n<p>I wouldn't call this a fundamental obstruction. The basic idea is that if you want to extract data from something, put it in <code>Type</code>, otherwise put it in <code>Prop</code>. You can still do many of the hProp tricks in <code>Type</code>, for example <code>trunc</code> is the (computable!) propositional truncation, and you can eliminate from it to any type that is a subsingleton.</p>\n</blockquote>\n<p>It's not a fundamental obstruction in the sense that you can do constructive reasoning in Lean using <code>trunc</code>. But mathlib doesn't use trunc very much (for good reason!), so using mathlib constructively becomes awkward. (And subsingleton elimination is more powerful in UF than in Lean since you get more subsingletons, like \"the type of initial objects in a univalent category\")</p>",
        "id": 233825342,
        "sender_full_name": "David Wärn",
        "timestamp": 1617976761
    },
    {
        "content": "<p>Note I was only trying to make the weak claim that constructivism and formal mathematics have some synergy, not that constructive mathematics is easier to formalise. It seems to me that using <code>norm_num</code> to compute on <code>ℝ</code> just moves the problem of \"making arithemtic computable\" from definitions to lemmas and tactics. I'm not saying there's anything wrong with this, but at the end of the day you're still thinking about similar problems as constructive mathematicians, i.e. \"how to make maths compute\".</p>",
        "id": 233826573,
        "sender_full_name": "David Wärn",
        "timestamp": 1617977187
    },
    {
        "content": "<p>Of course intuitionistic logic sometimes gives you algorithms that are worthless in practice. But there's also nothing stopping you from defining efficient algorithms constructively</p>",
        "id": 233826905,
        "sender_full_name": "David Wärn",
        "timestamp": 1617977304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113488-general/topic/Hales'.202017.20Big.20Proof.20talk/near/233826573\">said</a>:</p>\n<blockquote>\n<p>[...] using <code>norm_num</code> to compute on <code>ℝ</code> just moves the problem of \"making arithemtic computable\" from definitions to lemmas and tactics.</p>\n</blockquote>\n<p>Isn't that the only possible way?  I.e., there is no way to make <code>(=) : ℝ → ℝ → bool</code> computable, but <code>norm_num</code> can still compute many useful real numbers.</p>",
        "id": 233827995,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1617977699
    },
    {
        "content": "<p>Sure. I'm out of my depth here, but I'd expect to be able to prove certain other things about real numbers, like <code>sin.real 0.1 &gt; 0</code>, 'by computation', assuming <code>sin.real</code> were sufficiently computable</p>",
        "id": 233828928,
        "sender_full_name": "David Wärn",
        "timestamp": 1617978053
    },
    {
        "content": "<p>I mean, with another model of the reals, we could have a computable function that takes a real number and gives you a rational approximation with error at most 0.01 (possibly wrapped in <code>trunc</code>). As I understand, this could in principle be done by a future version of <code>norm_num</code>, but the work has not yet been done?</p>",
        "id": 233829754,
        "sender_full_name": "David Wärn",
        "timestamp": 1617978357
    },
    {
        "content": "<p>Yeah, I guess that would require a whole lot of work, one would need theorems of the form \"if x is in this box with rational endpoints then sin(x) is in that box with rational endpoints, and if we make the first box smaller then the second box gets smaller\". I suspect the reason this sort of thing isn't happening is that you can formalise a huge amount of mathematics without ever even caring whether sin(0.1) is positive or negative, and the current driving force in mathlib is somehow people doing other stuff. My guess is that if you were to start prodding the Coq people you'd find a ton of stuff done in this direction.</p>",
        "id": 233829996,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617978450
    },
    {
        "content": "<p>Right, we have a little bit in this direction. Just enough to define <code>real.pi</code>. (And we can even compute the first 5 digits or so <span aria-label=\"shock\" class=\"emoji emoji-1f628\" role=\"img\" title=\"shock\">:shock:</span> <span aria-label=\"open mouth\" class=\"emoji emoji-1f62e\" role=\"img\" title=\"open mouth\">:open_mouth:</span>)<br>\nBut I don't think that I know of any other proof where you wan't to plug some <code>x</code> into <code>real.sin</code> where <code>x</code> isn't \"special\".</p>",
        "id": 233830369,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617978590
    },
    {
        "content": "<p>My guess is that this stuff will happen organically when it's needed. Right now we are romping ahead with theorems of Scholze involving real numbers without ever actually mentioning an explicit real number at all. The only reason we can evaluate pi to even one decimal place was that we decided it would be a fun thing to do on pi day two years ago :-) But I would imagine that there are people here who might well one day need this kind of stuff. Growth of mathlib can often be motivated by people having lofty goals and then focussing on what needs to be done next in order to attain them. Right now I don't see a lofty goal which needs to know whether sin(0.1) is positive or negative, but one I guess could imagine it appearing in the future.</p>",
        "id": 233832399,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617979207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113488-general/topic/Hales'.202017.20Big.20Proof.20talk/near/233829754\">said</a>:</p>\n<blockquote>\n<p>I mean, with another model of the reals, we could have a computable function that takes a real number and gives you a rational approximation with error at most 0.01 (possibly wrapped in <code>trunc</code>). As I understand, this could in principle be done by a future version of <code>norm_num</code>, but the work has not yet been done?</p>\n</blockquote>\n<p>Actually this is impossible, at least with cauchy representation, even if you use efficiently converging cauchy sequences. Given a particular cauchy sequence, you can get an arbitrarily good rational approximation computably, but once you take the quotient, different cauchy sequences will give different approximate results and even though any of them would be \"fine\" you still can't get a particular answer out.</p>",
        "id": 233833044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617979443
    },
    {
        "content": "<p>This is solved by wrapping result in <code>trunc</code> right?</p>",
        "id": 233833277,
        "sender_full_name": "David Wärn",
        "timestamp": 1617979525
    },
    {
        "content": "<p>However this <em>can</em> be done by norm_num, because it doesn't work on the actual type <code>real</code> as understood by constructivists, it works on representations of real numbers in a more explicitly computable subset such as algebraic numbers</p>",
        "id": 233833287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617979527
    },
    {
        "content": "<p>Wrapping the result in <code>trunc</code> means you never get an answer to the question though</p>",
        "id": 233833323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617979543
    },
    {
        "content": "<p>it's possible to give an approximate lt function on real which outputs <code>trunc bool</code> but what good is that?</p>",
        "id": 233833430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617979571
    },
    {
        "content": "<blockquote>\n<p>sin(0.1) is positive or negative</p>\n</blockquote>\n<p>This particular instance is actually very easy to prove.  But it would of course be great to have interval arithmetic (or sth similar) in mathlib.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">sin</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">sin_pos_of_pos_of_le_one</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 233833478,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1617979585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Hales'.202017.20Big.20Proof.20talk/near/233830369\">said</a>:</p>\n<blockquote>\n<p>Right, we have a little bit in this direction. Just enough to define <code>real.pi</code>. (And we can even compute the first 5 digits or so <span aria-label=\"shock\" class=\"emoji emoji-1f628\" role=\"img\" title=\"shock\">:shock:</span> <span aria-label=\"open mouth\" class=\"emoji emoji-1f62e\" role=\"img\" title=\"open mouth\">:open_mouth:</span>)<br>\nBut I don't think that I know of any other proof where you wan't to plug some <code>x</code> into <code>real.sin</code> where <code>x</code> isn't \"special\".</p>\n</blockquote>\n<p>I doubt this is something we can target in the near future (unless we manage to attract some numerical analysts?), but I could imagine a program in Lean N that generates a plot of <code>sin</code> with an accompanying proof of correctness, e.g. that the black pixels are all \"close\" to actual values. (see also the <a href=\"#narrow/stream/270676-lean4/topic/raytracer/near/224672752\">Lean 4 raytracers</a>.)</p>",
        "id": 233833533,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1617979597
    },
    {
        "content": "<p>In Coq they have it already: <a href=\"https://coq.discourse.group/t/interval-4-2-now-with-plotting/1248\">https://coq.discourse.group/t/interval-4-2-now-with-plotting/1248</a></p>",
        "id": 233833678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617979644
    },
    {
        "content": "<p>I don't know how to prove <code>0 &lt; sin 0.1</code> in computable real arithmetic the constructive way though, because the type of <code>&lt;</code> doesn't really admit a total function</p>",
        "id": 233833685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617979648
    },
    {
        "content": "<p>It's possible to prove it with a <em>proof</em>, but not some <code>#eval</code> thing</p>",
        "id": 233833723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617979665
    },
    {
        "content": "<p>(although I'm confused about the floor function graph in that Coq link because for sure there's a lot of points on that staircase graph which are provably nowhere near actual values)</p>",
        "id": 233833936,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617979741
    },
    {
        "content": "<p>Of course we can't make <code>&lt;</code> computable. But you could have a computable <code>approx : Π (x : ℝ), trunc { y : ℚ // abs (x - y) &lt; 0.01 }</code>. Then it's easy to prove concrete inequalities where the gap is large enough: just compare the two approximations</p>",
        "id": 233833940,
        "sender_full_name": "David Wärn",
        "timestamp": 1617979743
    },
    {
        "content": "<p>How do you prove that the gap is large enough?</p>",
        "id": 233834015,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1617979773
    },
    {
        "content": "<p>What do you mean? Given a particular inequality, like <code>sin (e + pi) &lt; -0.4</code>, you'd be able to prove it just by comparing approximations. AFAICT this is currently tricky in Lean only because you don't have access to rational approximations</p>",
        "id": 233834749,
        "sender_full_name": "David Wärn",
        "timestamp": 1617980019
    },
    {
        "content": "<p>Incidentally, it's easy to prove in mathlib that <code>0 &lt; sin 0.1</code>, since we know <code>sin</code> is positive on (0, pi) and <code>0 &lt; 0.1 &lt; 3 &lt; pi</code> can be verified by norm_num and a lemma about pi</p>",
        "id": 233834815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617980043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110043\">Gabriel Ebner</span> <a href=\"#narrow/stream/113488-general/topic/Hales'.202017.20Big.20Proof.20talk/near/233833478\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>sin(0.1) is positive or negative</p>\n</blockquote>\n<p>This particular instance is actually very easy to prove.  But it would of course be great to have interval arithmetic (or sth similar) in mathlib.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">sin</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">sin_pos_of_pos_of_le_one</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 233835059,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1617980137
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span> That method works well if you have a particular cauchy sequence to work with, and this is what actual \"exact real arithmetic\" packages in languages like C++ or Haskell do. But if you drink the intuitionist coolaid then you will want to take a quotient of those cauchy sequences so that you have the \"real reals\" instead of just some surjective cover with too much data in it, and once you do that you lose all ability to distinguish anything from anything else</p>",
        "id": 233835247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617980204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113488-general/topic/Hales'.202017.20Big.20Proof.20talk/near/233834749\">said</a>:</p>\n<blockquote>\n<p>What do you mean? Given a particular inequality, like <code>sin (e + pi) &lt; -0.4</code>, you'd be able to prove it just by comparing approximations. AFAICT this is currently tricky in Lean only because you don't have access to rational approximations</p>\n</blockquote>\n<p>But the trunc representation doesn't give you that.  You still need to show that the approximate intervals don't overlap.</p>",
        "id": 233835270,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1617980214
    },
    {
        "content": "<p>Well the approximations are sufficiently far apart, so the original numbers must be too</p>",
        "id": 233835402,
        "sender_full_name": "David Wärn",
        "timestamp": 1617980270
    },
    {
        "content": "<p>Yes, that's clear.  But you can't do that with <code>trunc { y : ℚ // abs (x - y) &lt; 0.01 }</code>.  If you define a function on the truncation, you need to prove that it is constant, i.e., it returns the same value for every approximation.  And that's only true if the intervals don't overlap.</p>",
        "id": 233836244,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1617980475
    },
    {
        "content": "<p>Right. This wouldn't give you a total computable <code>&lt;</code>, but it would help you write tactics to prove particular inequalities</p>",
        "id": 233836985,
        "sender_full_name": "David Wärn",
        "timestamp": 1617980590
    },
    {
        "content": "<p>For a simpler example, let's say we want to prove <code>0 &lt; e</code> given an algorithm for <code>e</code>. We can build <code>trunc {q | abs (e - q) &lt; 1}</code>, and if we run it let's say we get <code>2</code>, but it's behind the quotient so we aren't allowed to tell the difference between this and <code>2.5</code> and other numbers that we can't be sure about. Now if we see <code>2</code> we can conclude that any other number in the equivalence class is within 1 of 2 and therefore <code>e</code> is positive. <em>But we don't know that we can only get <code>2</code></em>. We need to know that all values within 1 of 2 have this property, and so we aren't sure that <code>1.5</code> isn't in the equivalence class too, or <code>1</code>, or <code>0.5</code> or <code>0</code> where we're definitely hosed. We want a function that says \"yes\", \"no\" or \"inconclusive\", but the line between \"yes\" and \"inconclusive\" is itself fuzzy and basically makes everything \"inconclusive\"</p>",
        "id": 233838042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617980785
    },
    {
        "content": "<p>Isn't this solved by tactics? E.g. can't I write a tactic which takes an assumption <code>trunc.mk a : trunc A</code> in context and replaces it with <code>a : A</code>?</p>",
        "id": 233838758,
        "sender_full_name": "David Wärn",
        "timestamp": 1617980946
    },
    {
        "content": "<p>Yes, that's the norm_num way. Forget about computing in the logic, and look at the terms that were written down instead</p>",
        "id": 233838910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617980982
    },
    {
        "content": "<p>when you step up a meta-level everything becomes computable because it's all lambda calculus</p>",
        "id": 233839118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617981023
    },
    {
        "content": "<p>But my point is that once you take that step, it becomes utterly irrelevant whether the object language has choice or LEM or uses constructive logic or can run proofs, because you are looking <em>at</em> the proofs and can compute whatever you want. Isabelle uses a code generation scheme along these lines and the idea that you need constructive mathematics to be able to run functions from the logic is very foreign to them</p>",
        "id": 233839847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617981198
    },
    {
        "content": "<p>Sure. But if your definitions aren't constructive from the beginning, and you want to compute with them, then you need to add lemmas and tactics to compute with them. Whereas if you had a computable model of say the reals from the beginning, then you'd get computable rational approximations for free</p>",
        "id": 233840597,
        "sender_full_name": "David Wärn",
        "timestamp": 1617981343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Hales'.202017.20Big.20Proof.20talk/near/233835247\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> That method works well if you have a particular cauchy sequence to work with, and this is what actual \"exact real arithmetic\" packages in languages like C++ or Haskell do. But if you drink the intuitionist coolaid then you will want to take a quotient of those cauchy sequences so that you have the \"real reals\" instead of just some surjective cover with too much data in it, and once you do that you lose all ability to distinguish anything from anything else</p>\n</blockquote>\n<p>I don't understand what you mean by this. If you have a setoid version of the reals, with no quotienting, then you don't even need to wrap your approximations in <code>trunc</code>. But if your reals are equivalence classes of Cauchy sequences (or a recursive HIT like in the HoTT book), can't you still get approximations wrapped in <code>trunc</code>?</p>",
        "id": 233841015,
        "sender_full_name": "David Wärn",
        "timestamp": 1617981423
    },
    {
        "content": "<p>Yes, but an approximation wrapped in <code>trunc</code> cannot be printed, because the printing does not satisfy the quotient property</p>",
        "id": 233841756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617981600
    },
    {
        "content": "<p>nor can it be compared to a given rational, unless you already know the answer in advance</p>",
        "id": 233841897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617981639
    },
    {
        "content": "<p>any function defined out of the <code>trunc</code> has to be locally constant as Gabriel said, and all such functions are trivial</p>",
        "id": 233842057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617981711
    },
    {
        "content": "<p>But at least you could feed it to a tactic to do things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">sin</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"bp\">+</span> <span class=\"n\">pi</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">-</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rat_approx</span>\n</code></pre></div>",
        "id": 233842205,
        "sender_full_name": "David Wärn",
        "timestamp": 1617981759
    },
    {
        "content": "<p>Yes, but you don't need computable reals to do that</p>",
        "id": 233842288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617981789
    },
    {
        "content": "<p>You can implement exactly the same <code>rat_approx</code> tactic whether <code>real</code> is constructive or nonconstructive</p>",
        "id": 233842393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617981839
    },
    {
        "content": "<p>Sure</p>",
        "id": 233842448,
        "sender_full_name": "David Wärn",
        "timestamp": 1617981848
    },
    {
        "content": "<p>I never meant to argue against this</p>",
        "id": 233842463,
        "sender_full_name": "David Wärn",
        "timestamp": 1617981857
    },
    {
        "content": "<p>My view is that this <code>rat_approx</code> approach is the right one, and the intuitionistic constructive reals thing doesn't actually solve the problems it set out to do</p>",
        "id": 233842618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617981921
    },
    {
        "content": "<p>I'm just saying that you get more for free if your definitions are constructive. You initially save effort working nonconstructively, but then you still need to write code to compute with things. (I'm not saying either approach is better overall)</p>",
        "id": 233842686,
        "sender_full_name": "David Wärn",
        "timestamp": 1617981950
    },
    {
        "content": "<p>If I want to compute pi, I will use some <a href=\"https://en.wikipedia.org/wiki/Chudnovsky_algorithm\">crazy formula</a> with good convergence. That doesn't mean the abstract definition of pi needs to be that. I certainly wouldn't want to be messing with a formula about arctan when I still haven't proved that pi exists. These are different things for different purposes, so defining things twice is a strength, not a weakness</p>",
        "id": 233842974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617982075
    },
    {
        "content": "<p>Sometimes, the mathematical definition is also good computationally. Maybe <code>list.map</code> is an example. But these are in the minority - even <code>list.map</code> has to sacrifice a lot of performance because it works on linked lists instead of arrays. Most algorithms are very different from the abstract concepts they compute</p>",
        "id": 233843500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1617982279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Hales'.202017.20Big.20Proof.20talk/near/233842974\">said</a>:</p>\n<blockquote>\n<p>If I want to compute pi, I will use some <a href=\"https://en.wikipedia.org/wiki/Chudnovsky_algorithm\">crazy formula</a> with good convergence. That doesn't mean the abstract definition of pi needs to be that. I certainly wouldn't want to be messing with a formula about arctan when I still haven't proved that pi exists. These are different things for different purposes, so defining things twice is a strength, not a weakness</p>\n</blockquote>\n<p>I think the issue here is that in intensional type theory you can have non-equal real numbers with the same sequence of digits. So when you are talking about \"pi\" you are really talking about several different objects.</p>",
        "id": 233931342,
        "sender_full_name": "Joachim Hauge",
        "timestamp": 1618036488
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"403138\">@Joachim Hauge</span> That doesn't seem \"practical or efficient\" and neither do I get any  \"psychological comfort in having it\".</p>",
        "id": 233934226,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618038884
    },
    {
        "content": "<p>So I'm glad that there is just one <code>real.pi</code> in mathlib, and that we can write a tactic to compute it's digits.</p>",
        "id": 233934258,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618038933
    },
    {
        "content": "<p>Right, so this idea about different reals with the same digits might be interesting to some foundational people but it is also a massive red flag when it comes to attracting conventional mathematicians to proof assistants (which is my ultimate goal and the motivation behind a lot of my work). What you describe might lead to foundational questions of interest to some people but it is not the model of mathematics which is in the head of the important mathematicians so it should not be the direction of travel for mathlib if we want to further penetrate the market</p>",
        "id": 233938157,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618043256
    },
    {
        "content": "<p>This is not about constructivism. It's true that there are (also in Lean) terms like <code>0 + pi</code> and <code>pi</code> that represent the same real number but are not defeq. I guess in some sense this is due to the fact that they represent different ways of computing pi. But it doesn't matter much to theorem proving, since they're still (propositionally) equal. (You can construct other computable real numbers which are \"actually\" equal but not provably equal, by Gödel, but that's really beside the point.) The equality <code>0+pi = pi</code> is perfectly constructive. Constructive reals (like the HIT reals) have exactly the same extensionality as you'd expect</p>",
        "id": 233939777,
        "sender_full_name": "David Wärn",
        "timestamp": 1618045056
    },
    {
        "content": "<p>I guess the \"equal\" that <span class=\"user-mention silent\" data-user-id=\"403138\">Joachim Hauge</span> mentions is what we would call defeq, and following Kevin's remarks this is exactly why I consider defeq a scourge and ITT misguided for making me care about a manifestly non-mathematical relation</p>",
        "id": 233941146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618046532
    },
    {
        "content": "<p>But, <span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span>, the equality <code>0+pi = pi</code> won't necessarily be an equality if you leave the reals unquotiented (actually in that particular example it probably is, but there are minor variations that won't be like <code>(2 * pi) / 2</code>). So you get stuck in this middle ground where either you have the desirable mathematical properties (with the quotient) or the computational properties (without the quotient) but not both.</p>",
        "id": 233941312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618046741
    },
    {
        "content": "<p>I claim that you still retain some good computational properties with the quotient. You don't get total computable <code>(=)</code> or <code>(&lt;)</code>, but that's unavoidable and unrelated to the quotient. What you do get is computable <code>trunc</code>-wrapped rational approximations. Given this, writing a tactic to prove inequalities in the reals is trivial. Whereas with mathlib's noncomputable reals, proving <code>sin(e + pi) &lt; -0.4</code>, which should just be a matter of unfolding definitions, is not that easy.</p>",
        "id": 233942265,
        "sender_full_name": "David Wärn",
        "timestamp": 1618047848
    },
    {
        "content": "<p>It is possible to implement a prover for <code>sin(e + pi) &lt; -0.4</code> by associating computational methods to <code>sin</code>, <code>e</code>, <code>pi</code> and <code>+</code>. This is essentially the same as what you would need to do with a computable real definition of <code>sin</code>, <code>e</code>, <code>pi</code>, etc except that you would also have to prove equivalence of these computations to the real thing. The computable real approach skips this step, but instead you would need to work with this computational method when proving that <code>sin pi = 0</code> and all those other pure maths facts</p>",
        "id": 233947471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618053519
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"403138\">@Joachim Hauge</span> Mario has now explained what I presume you mean, but for mathematicians there is only one kind of equality. The reason the natural number game makes sense to mathematicians is that I explicitly had to \"disable\" checking for definitional equality so that mathematicians could not tell the difference between the defeq n+0=n and the theorem 0+n=n. No mathematician would accept the idea that these two kinds of equalities are distinct because we think of mathematics in a very symmetric way and breaking the symmetry is confusing to us. We have one equality to rule them all, namely mathematical equality -- the idea that two things are \"the same\". We have done well for centuries never going into any further details and these things need to shielded from mathematicians. In NNG n+0=n is proved with <code>rw add_zero</code> and not <code>rfl</code>, and I think this is key to the accessibility for mathematicians. Our instinct is to prove equalities by rewriting rather than unfolding.</p>",
        "id": 233950573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618056789
    },
    {
        "content": "<p>For <a href=\"https://github.com/leanprover-community/mathlib/issues/7084\">#7084</a>, I had to modify the definition of power, so that <code>x ^ 0</code> is not defeq to <code>1</code>, and <code>x ^ n.succ</code> is not defeq to <code>x * x^n</code> any more. This means a lot of proofs broke because they were abusing these definitional equalities, and instead I had to <code>rw [pow_zero]</code> or <code>rw [pow_succ]</code> a lot. I feel this is really for the better, because now the proofs are both more readable and more robust. I came slowly to the conclusion that the only place where defeq really matters is not in userland, but in instanceland where the kernel is checking things and you don't have control on what it is doing.</p>",
        "id": 233951235,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618057432
    },
    {
        "content": "<p>I think it's a bit unfair to say for mathematicians there is only one kind of equality. As well as the \"usual\" one, once you receive your licence to use the word \"canonical\", you can arbitrarily use the <code>=</code> symbol instead of <code>≅</code>. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 233951303,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618057469
    },
    {
        "content": "<p>defeq:</p>\n<blockquote>\n<p>The version I heard is that Pauli was lecturing, and he said \"this is obvious\". A student raises his hand and says \"sorry professor, I don't think that is obvious\". Pauli stares at the board, back at the students. He thinks for a bit. He starts pacing in front of the class, thinking. He looks back at the board. Eventually he leaves the room, comes back 20 minutes later and says \"I've thought about it and yes, it is obvious\".</p>\n</blockquote>\n<p>That's an awesome super power to have, but not one that really scales well.</p>",
        "id": 233951557,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618057707
    },
    {
        "content": "<p>I had never thought of Pauli in this story as the kernel checking a heavy <code>rfl</code>, but this is exactly it!</p>",
        "id": 233951739,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1618057895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/Hales'.202017.20Big.20Proof.20talk/near/233814868\">said</a>:</p>\n<blockquote>\n<p>I think there have been several rounds of: 1) make <code>polynomial</code> irreducible 2) fix some breakages 3) revert it to semireducible because you didn't fix everything 4) PR the fixes.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7421\">#7421</a></p>",
        "id": 236835946,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619790247
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Wow! You really are on a rampage!</p>",
        "id": 236837077,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619790718
    },
    {
        "content": "<p>Effective procrastination :-)</p>",
        "id": 236837669,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619790951
    },
    {
        "content": "<p>It worries me a little that this ends up adding 500 lines of what are essentially repeated proofs, and makes translating proofs from finsupp to polynomial (an activity which the original problem is partly due to the neglect of) harder. Is there any way we can better handle this with automation?</p>",
        "id": 236842510,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619792841
    },
    {
        "content": "<p>And unrelatedly, I assume the follow-up would be to do this to mv_polynomial too?</p>",
        "id": 236842601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619792879
    },
    {
        "content": "<p>Thank you for the hard work! I don't think the translation from <code>finsupp</code> to <code>polynomial</code> becomes much harder, since we still have the isomorphism between the two, <code>to_finsupp_iso</code>. (Indeed, I suspect the total amount of changes could have been smaller by using <code>to_finsupp_iso</code> rather than re-proving the existing results, although I have not tried doing so yet.)</p>",
        "id": 236844646,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1619793685
    },
    {
        "content": "<p>In fact, there isn't a lot of proof repetition. Most of the additional code is to set up all the operations on <code>polynomial R</code> by lifting to <code>finsupp</code>, then declaring everything irreducible and registering the basic properties. Once this is done, all proofs are essentially straightforward (and when they're not one-liners we can either lift things to <code>finsupp</code> or use <code>to_finsupp_iso</code>. Another source of addition is that several concepts were only defined for <code>finsupp</code>, but used liberally for polynomials (like <code>erase</code> or <code>frange</code>), so one has to register again the definitions and the basic properties.</p>",
        "id": 236853920,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619796629
    },
    {
        "content": "<p>The only real pain I encountered is that, after the refactoring, Lean can not at all compute with polynomials (before, it could compute their support), so <code>0.coeff n</code> is not definitionally equal to <code>0</code>, and <code>0.degree</code>, <code>0.nat_degree</code>, <code>0.leading_coeff</code> and so on have to be handled by rewrites instead of <code>rfl</code>. Once the basic few files had been done, this was essentially the only thing that needed fixing all over the library.</p>",
        "id": 236854271,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619796748
    },
    {
        "content": "<p>This sort of thing is what makes computer scientists shudder, and I think that this is a good reason for trying it, because it is trying to set up a theory in a way which is not at all intuitive for the kind of people who have been setting up theories of polynomials before. Mathematicians prove n+0=n by a rewrite in the natural number game because 0+n=n needs a rewrite and the proof of n+0=n feels like it should be the same because of our internal symmetry</p>",
        "id": 236863060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619800213
    },
    {
        "content": "<p>This is all because lean doesn't consider structures with defeq members as defeq, right?</p>",
        "id": 236880051,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619807005
    },
    {
        "content": "<p>(except in typeclass inference where it knows to try unpacking fields?)</p>",
        "id": 236880097,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619807027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/Hales'.202017.20Big.20Proof.20talk/near/236854271\">said</a>:</p>\n<blockquote>\n<p>The only real pain I encountered is that, after the refactoring, Lean can not at all compute with polynomials (before, it could compute their support), so <code>0.coeff n</code> is not definitionally equal to <code>0</code>, [...]</p>\n</blockquote>\n<p>If you want <code>0.coeff n</code> to reduce to <code>0</code>, then you shouldn't mark it as irreducible.</p>",
        "id": 236880499,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1619807192
    }
]
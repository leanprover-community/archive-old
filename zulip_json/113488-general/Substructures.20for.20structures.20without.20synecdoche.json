[
    {
        "content": "<p>Most (if not all) algebraic objects in mathlib seem to take advantage of the usual synecdoche, for example a group <code>G</code> <em>is</em> the type containing the elements of the group -- recall, synecdoche is when you refer to a thing by one of its parts (a group is actually <code>G</code> along with a multiplication operation, an inverse operation, and axioms).  Some algebraic objects, like modules, use two types, for example modules (the ring <code>R</code> and the abelian group <code>M</code> being acted upon), but we still can refer to <code>M</code> as if it were the module itself.  This is OK because many times we <em>want</em> to talk about multiple rings acting upon <code>M</code>.  So, the convention is that an algebraic object is referred to by a Type.</p>\n<p>Because of this convention, there is a convenient way of dealing with subobjects of an algebraic object <code>A</code>.  A subobject is a structure consisting of a carrier set of type <code>set A</code> along with some closure axioms.  Mathlib takes advantage of Lean's automatic coercions to sort of make subobjects be objects in their own right by, for instance, defining instances <code>group (↥G')</code> for <code>G' : subgroup G</code> and <code>[group G]</code>, where there is an instance <code>has_coe_to_sort G'</code> that gives the carrier set as a type.</p>\n<p>However, some objects involve multiple types and you do not refer to the object by synecdoche.  The particular case I have in mind are the various flavors of graphs.  A graph <code>G</code> consists of a vertex set <code>V</code> and an edge set <code>E</code>.  It's a term, not a type.  So, if you were to define a subgraph structure (a subset of <code>V</code>, a subset of <code>E</code>, and some axioms), you cannot use the same <code>coe_to_sort</code> trick to give subgraphs the structure of a graph.  You would have to do manual coercions everywhere, breaking the illusion that I feel we want to keep, that a subgraph <em>is</em> a graph.  Also, a distinction between modules and graphs is that, in some ways, module structures are a partial function on the class of rings, but a graph consists of a fixed vertex and edge set -- it makes little sense varying either of them in this way.</p>\n<p><strong>Here is the main question:</strong> how should one design an interface for structures that lack synecdoche so that, for instance, subgraphs are graphs?  I have one potential solution to this, but I'd like to know if anyone has explored any others.</p>\n<p>Let's look at a way semigroups could have been defined (this is not a recommendation, just an illustration; I'd rather use an object people are familiar with in mathlib rather than getting into implementation details of graphs).  Rather than giving individual types the structure of a semigroup, what if you declared that every term of a type is a semigroup?  From a category theory perspective, perhaps this is declaring that a type is the object set of some category, and you are giving each of those objects some concrete interpretation.</p>\n<p>The way this might look is the following (again, not a recommendation, just an illustration):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">class</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">semigroups</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">has_mul</span> <span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">carrier</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">semigroups</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">semigroup_to_sort</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semigroups</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">semigroups</span><span class=\"bp\">.</span><span class=\"n\">carrier</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">semigroup_coe_mul</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semigroups</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"n\">mul</span> <span class=\"n\">G</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">subsemigroup</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semigroups</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_mem&#39;</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"err\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semigroups</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">semigroups</span> <span class=\"o\">(</span><span class=\"n\">subsemigroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span> <span class=\"n\">subtype</span> <span class=\"o\">(</span><span class=\"n\">subsemigroup</span><span class=\"bp\">.</span><span class=\"n\">carrier</span> <span class=\"n\">G&#39;</span><span class=\"o\">),</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">subsemigroup</span><span class=\"bp\">.</span><span class=\"n\">mul_mem&#39;</span> <span class=\"n\">G&#39;</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">],</span>\n  <span class=\"kn\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>Notice how terms of <code>subsemigroup G</code> <em>are</em> semigroups themselves, without need for a coercion.  (Note: the <code>has_coe_to_sort</code> is there to implement synecdoche from the other side: you can treat a semigroup as if it had terms.  Graphs wouldn't have this instance.)  (Another note: I used <code>subtype</code> in the last instance because I was having trouble using the coercion arrows and didn't want to spend time figuring out what's wrong.)</p>\n<p>Hopefully this example makes it clear how this might apply to graphs.  One would have a class that declares that every term in a type can be interpreted as being a graph.  There would be graphs instances for the types of subgraphs and graph minors and so on.  So, if <code>G</code> is a term from any type of graphs, you could write <code>V G</code> and <code>E G</code> to get its vertex and edge types.</p>\n<p>Are there any other approaches that anyone has thought about?  It seems that graphs might the first time this issue might have come up.</p>\n<p>Using the semigroup example, an alternative could be using <code>has_coe</code> to give terms of a type a <code>semigroup</code> interpretation.  However, because <code>semigroup</code> is parameterized by its carrier type, it seems you'd need an instance like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">semigroup</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>and then whenever you coerce, you would be obligated to specify the carrier type.  A benefit of the <code>semigroups</code> approach is that a user of the API does not need to specify the carrier type: it is a function of the term at the class resolution level.</p>\n<p>One other comment for this rather long message: it seems like you still might want <code>semigroup</code> around so that you can implement one-off semigroups.  There's a tautological <code>semigroups (semigroup α)</code> instance.  It seems weird, but maybe it's a consequence that <code>semigroup</code> is equivalent to <code>semigroups pt</code> where <code>pt</code> is a one-term type.</p>",
        "id": 206864172,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597349383
    },
    {
        "content": "<p>I didn't read your full message, so maybe you already answered this, feel free to ignore but: At one point there was a definition of graph floating around on Zulip where the vertices came from some fixed \"universe\" Type, but were a (fin)set of elements from that universe: I.e. something like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">graph</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">verts</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">\\</span><span class=\"n\">times</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">incidence</span> <span class=\"o\">:</span> <span class=\"err\">\\</span><span class=\"k\">forall</span> <span class=\"n\">e</span> <span class=\"err\">\\</span><span class=\"k\">in</span> <span class=\"n\">edges</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"err\">\\</span><span class=\"k\">in</span> <span class=\"n\">verts</span> <span class=\"err\">\\</span><span class=\"n\">and</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"err\">\\</span><span class=\"k\">in</span> <span class=\"n\">verts</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>What is your opinion of this approach?</p>",
        "id": 206865281,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1597349876
    },
    {
        "content": "<p>Traditional link: Section 3 of <a href=\"https://hal.inria.fr/hal-00825074v1/document\">https://hal.inria.fr/hal-00825074v1/document</a></p>",
        "id": 206868214,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597351151
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>  I'm interested in particular about the \"synecdoche problem\" (or maybe it should be called the \"subobject problem\"?).  I know this is in some ways an XY problem, since getting a good graph interface is an end goal, but it's probably worth figuring out some reasonable solution to it.  It seems like something people must have thought about, but in my limited asking around I haven't found anything about it.  I'm guessing it's because most things have a primary carrier type.</p>\n<p>Anyway, regarding that graph definition, it is, essentially, the type of subgraphs of (directed) complete graphs.  It seems to be a viable way of dealing with graphs without multi-edges, especially if you are interested in the lattice of subgraphs, though a downside is the vertices are a set rather than a type.  Also, there will probably be some interest in defining the type of graph minors to prove theorems about excluded minors.</p>\n<p>For multigraphs, though, you can't really do this trick because there's not really a natural universal multigraph that every other multigraph is a subgraph of.  For simplicity, consider a common definition for multidigraphs:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">multidigraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ends</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>You sort of want edges to be able to be \"glued in\" anywhere you'd like.  A less natural approach that's analogous to the above <code>graph</code> definition would be something like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">multidigraph</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">Y</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">incidence</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">edges</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"err\">∈</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"err\">∈</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>where every multidigraph is a subgraph of the the one with edges between every pair of vertices indexed by <code>Y</code>.  (It \"solves\" the subgraph problem, but I wouldn't want to work with this definition.)</p>",
        "id": 206868351,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597351214
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Thanks, I'll take a look at that.</p>",
        "id": 206868366,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597351226
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I'm trying to understand what I should be getting out of that link, since it seems to be about how subobjects work in mathlib.  Is it that the way to solve this synecdoche problem is to define, for example, a directed multigraph to be a subgraph of a directed multigraph universe?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">multidigraph_universe</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">ends</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">multidigraph</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">multidigraph_universe</span> <span class=\"n\">V</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">E&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">compat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">E&#39;</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">ends</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"err\">∈</span> <span class=\"n\">V&#39;</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">ends</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">∈</span> <span class=\"n\">V&#39;</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>This is not exactly analogous to the paper, since the paper's group universe (a \"graph type\") is a type, but here a <code>multidigraph_universe</code> is a term.</p>",
        "id": 206875482,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597354949
    },
    {
        "content": "<p>I'm sorry about the cryptic message. This paper is not about mathlib at all, it's about the Coq library that contains the odd order theorem formalization.  And it's not about graph, it's closer to your original message about subsemigroups. But I still hoped you would get useful information about how they solved this \"subgroup of subgroup issue\".</p>",
        "id": 206876533,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597355736
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> It was interesting to read regardless, and thank you for sharing it.  I guess that even though it was Coq, it seemed like it might be what the design of mathlib was based on, except that mathlib has some different terminology and uses some typeclasses.</p>\n<p>Maybe it was a mistake using subsemigroups as an example.  The point was to translate an existing algebraic structure that relies on synecdoche (a semigroup \"is\" a type, and the additional structure is filled in by class resolution) into a form where objects are terms, and in this new form you could imagine adding more types to the structure.  The example also showed how you could define subobjects in a way that doesn't rely on the automatic coercion trick for these to be treated as objects.</p>\n<p>Perhaps I'll finally submit a PR with the multigraphs definition I've been working on that uses this technique.  I've been hesitating because it's unlike other solutions in mathlib, but I think it's justified because these sorts of combinatorial objects are unlike algebraic objects in that they aren't referred to by synecdoche, so the typeclasses have to be structured in a different way. (And it feels natural using the interface, once you're used to saying a type consists of graphs and a graph is a term of that type.  That's not so different from the paper you shared.)</p>",
        "id": 206879475,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597357994
    },
    {
        "content": "<p>I think I might have found an acceptable solution to this \"synecdoche problem,\" and it seems sort of obvious in retrospect.  Using simple graphs as an example, you can define a class that gives <em>terms</em> the structure of a simple graph:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">simple_graph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>Then you can define subgraphs and give them the structure of a simple graph:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">subgraph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">E&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">edge_sub</span> <span class=\"o\">:</span> <span class=\"n\">E&#39;</span> <span class=\"err\">⊆</span> <span class=\"n\">edge_set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">has_verts</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">E&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">V&#39;</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span> <span class=\"o\">:</span> <span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">G&#39;</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">...</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>Hence, subgraphs are graphs.</p>\n<p>These are \"abstract\" simple graphs.  You can form concrete ones using a sort of tautological instance:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">from_rel</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">rel</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">irref</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">rel</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">from_rel</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"bp\">...</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>(I'm sort of unsure whether needing this tautological instance is ok.)</p>\n<p>I have an implementation of this simple graph definition (a variation on <a href=\"https://github.com/leanprover-community/mathlib/issues/3458\">#3458</a>) along with the bounded lattice of subgraphs at <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean\">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean</a></p>\n<p>Does this seem like an acceptable design?  We have <a href=\"https://github.com/leanprover-community/mathlib/issues/3458\">#3458</a> in review without subgraphs; if this is a good idea, should we update it in this way? (Tagging <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>)</p>\n<p>Getting this interface right will inform how other combinatorial objects will work, since they tend to be referred to as terms rather than types, and they tend to have various kinds of derived objects like subobjects that you want to use as if they were objects.</p>",
        "id": 206963146,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597430624
    },
    {
        "content": "<p>I read this thread with interest, and was surprised that the category theory folk didn't weigh in, because what you are talking about is close to the \"bundling objects\" philosophy of category theory in Lean. <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> do you have anything to say about this?</p>",
        "id": 206963543,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597430853
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I don't understand why you have <code>\\alpha</code>, <code>G</code>, and <code>V</code>...</p>",
        "id": 206966710,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597432567
    },
    {
        "content": "<p>The downside of turning graphs into classes is that you can't have multiple graph structures on the same set of vertices. Hence I wouldn't go that route...</p>",
        "id": 206966827,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597432639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Substructures.20for.20structures.20without.20synecdoche/near/206966827\">said</a>:</p>\n<blockquote>\n<p>The downside of turning graphs into classes is that you can't have multiple graph structures on the same set of vertices. Hence I wouldn't go that route...</p>\n</blockquote>\n<p>This doesn't have that limitation, and in fact the design is purposefully trying to avoid this issue.  The class is putting a graph structure on a term, and that term specifies the graph's vertex set.  This lets you put graph structures on, for example, subgraphs, or really anything else that has a natural graph structure.  The example instances I gave show that you can certainly have multiple graph structures on the same vertex type.</p>\n<p>This use of classes is different from other algebraic structures, where the carrier type is given an instance (this is synecdoche: the carrier type is <em>part of</em> the algebraic object, but we refer to the type as if it were the object).  Here, we refer to a term <code>G</code> and give it a graph structure with <code>[simple_graph G]</code>, and then you can access its vertex type with <code>V G</code>.  Like you said, vertex types might have multiple graph structures, which is one aspect of what I'm calling the \"synecdoche problem.\"  A graph is not referred to by any of its components.</p>",
        "id": 206981157,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597438739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Substructures.20for.20structures.20without.20synecdoche/near/206963146\">said</a>:</p>\n<blockquote>\n<p>I think I might have found an acceptable solution to this \"synecdoche problem,\" and it seems sort of obvious in retrospect.  Using simple graphs as an example, you can define a class that gives <em>terms</em> the structure of a simple graph:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">simple_graph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n</blockquote>\n<p>Surely this is not what you mean. Alpha and G are not even used in fields.</p>",
        "id": 206981373,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597438845
    },
    {
        "content": "<p>Also a general note: having internal universe variables is asking for trouble.</p>",
        "id": 206981419,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597438876
    },
    {
        "content": "<p>This is what I mean.  It is a partial function at the type class level that maps terms of <code>α</code> to graph structures.  An alternative is to make it a total function, but I thought this was somewhat weird:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">simple_graphs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">symmetric</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">irreflexive</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>You write <code>(α : Type u) [simple_graphs α] (G : α)</code>  to get a graph in this form.</p>\n<p>The hedetniemi branch used internal universe variables for directed multigraphs: <a href=\"https://github.com/leanprover-community/mathlib/blob/hedetniemi/src/graph_theory/basic.lean#L11\">https://github.com/leanprover-community/mathlib/blob/hedetniemi/src/graph_theory/basic.lean#L11</a></p>",
        "id": 206981864,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597439085
    },
    {
        "content": "<p>This is also similar to <code>category_theory.has_hom</code>, which has an internal universe variable.</p>",
        "id": 206982271,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597439330
    },
    {
        "content": "<p>(But categories are modeled differently from graphs. We refer to a category by its object type, if I understand the library correctly, but we don't refer to a graph by its vertex type.)</p>",
        "id": 206982602,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597439484
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I've never seen such a class before, and it looks weird to me...<br>\nHow would you write the complete graph on a type <code>X</code> using your proposal?</p>",
        "id": 207008979,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597474563
    },
    {
        "content": "<p>Kyle's implementation is an additional level of indirection which we've never used elsewhere. <code>simple_graphs</code> is a type class on <code>\\a</code> that says \"you can interpret terms of \\a as particular simple graphs\".</p>",
        "id": 207009022,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597474667
    },
    {
        "content": "<p>One might imagine an analogous typeclass <code>polynomialish</code>, which says that you can think of a type as representing a polynomial. You might provide instances on <code>list R</code> (for polynomials presented by a list of coefficients) and on <code>nat \\to\\0 R</code> (for our current implementation).</p>",
        "id": 207009074,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597474775
    },
    {
        "content": "<p>Right... and I would like to see how this works in practice.</p>",
        "id": 207009116,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597474853
    },
    {
        "content": "<p>Yeah, me too. It seems an interesting idea, but I'd want a big chunk of evidence that it is usable.</p>",
        "id": 207009125,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597474886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I suppose a point of this topic is that things like graphs seem to work differently from other objects, so it might take a solution that looks different from what we've seen before -- and I'd like to gather ideas that others might have to get an ergonomic API!</p>\n<p>Here's complete graphs: <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean#L349\">https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean#L349</a> (I'm not particularly happy with the name <code>from_rel</code>.   It's the \"tautological\" instance of a simple graph.)</p>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I'd like more evidence, too.  The linked branch, above, exercises at least some of the idea.</p>",
        "id": 207009570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597475984
    },
    {
        "content": "<p>It's odd that the typeclass does not mention <code>G</code> within any of it's fields, of course.  To do this sort of typeclass well, it will take some discipline to prove additional lemmas connecting properties of a term <code>G</code> of a particular type to the fields of <code>simple_graph</code> (or whatever combinatorial object we are defining).</p>",
        "id": 207009744,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597476326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Aha... I see. How about <code>adj_rel</code> instead of <code>from_rel</code>?</p>",
        "id": 207010055,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597476983
    },
    {
        "content": "<p>(Also, minor point: I think <code>irrefl</code> is the more common name, rather than <code>irref</code>.)</p>",
        "id": 207010059,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597477007
    },
    {
        "content": "<p>Thanks for the naming suggestions.  I wonder if <code>from_adj_rel</code> might be good?  If you don't open the namespace, then <code>simple_graph.from_adj_rel r</code> is what you'd see.</p>",
        "id": 207010118,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597477152
    },
    {
        "content": "<p>Yes, but maybe <code>adj_rel</code> in the root namespace also makes sense?</p>",
        "id": 207010261,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597477483
    },
    {
        "content": "<p>I don't know... maybe others have good ideas?</p>",
        "id": 207010267,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597477511
    },
    {
        "content": "<p>I think naming these things is getting outside my pay grade <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>  (Though, I'll throw in <code>make_simple_graph</code>.)</p>",
        "id": 207010376,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597477711
    }
]
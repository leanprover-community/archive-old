[
    {
        "content": "<p>Some of you will have seen my post on Mathoverflow (<a href=\"https://mathoverflow.net/q/311159\" target=\"_blank\" title=\"https://mathoverflow.net/q/311159\">https://mathoverflow.net/q/311159</a>) where I described some tasks that I would like to see formalised for expository purposes, with extensive annotation.  I have carried out two of the tasks, and attempted to write useful annotations,  as shown on these pages:</p>\n<p><a href=\"http://neil-strickland.staff.shef.ac.uk/dagstuhl/Systems/Lean_mathlib/Tasks/primes/\" target=\"_blank\" title=\"http://neil-strickland.staff.shef.ac.uk/dagstuhl/Systems/Lean_mathlib/Tasks/primes/\">http://neil-strickland.staff.shef.ac.uk/dagstuhl/Systems/Lean_mathlib/Tasks/primes/</a> (infinitely many primes)<br>\n<a href=\"http://neil-strickland.staff.shef.ac.uk/dagstuhl/Systems/Lean_mathlib/Tasks/nilpotents/\" target=\"_blank\" title=\"http://neil-strickland.staff.shef.ac.uk/dagstuhl/Systems/Lean_mathlib/Tasks/nilpotents/\">http://neil-strickland.staff.shef.ac.uk/dagstuhl/Systems/Lean_mathlib/Tasks/nilpotents/</a> (the ideal of nilpotents)</p>\n<p>These are part of a larger set of pages that are under construction.  I would be interested to hear comments.<br>\nMy annotations include a number of confessions of confusion or ignorance, and I would be happy for<br>\npeople to enlighten me.  There are doubtless other misunderstandings as well that I have not flagged.</p>\n<p>Note that these formalisations are designed to optimise comprehensibility for users who know a lot<br>\nof mathematics but are new to proof assistants; I am not aiming for efficiency, or for consistency <br>\nwith standard Lean style in cases where that conflicts with comprehensibility.</p>",
        "id": 135961777,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1539770451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130308\">@Neil Strickland</span> Cool display mode! In the past there has been discussion here on Zulip on how  to generate html docs. This looks really nice. I suppose you could steel a syntax highlighter from somewhere (maybe VScode?) and use that as well.</p>",
        "id": 135963881,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539773316
    },
    {
        "content": "<p>Also, if you don't care about Lean/mathlib style guides, I would suggest calling the type underlying your <code>comm_ring</code> just <code>R</code> instead of <code>Œ±</code>.</p>",
        "id": 135964031,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539773568
    },
    {
        "content": "<p>You write</p>\n<blockquote>\n<p>(There is no obvious way to supply an alternative name; Lean rejects <code>variable [R : comm_ring Œ±]</code>, for reasons that are not clear to me.)</p>\n</blockquote>\n<p>That is very weird, because Scott is doing this all the time in his category libs. Do you get an actual error?<br>\nMaybe you should write <code>include R</code> afterwards. That will include the instance in all your local contexts. Does that help?</p>",
        "id": 135964166,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539773764
    },
    {
        "content": "<p>You also write</p>\n<blockquote>\n<p>The resulting heuristics are often effective, but it is also fairly common for the simplifier to apply rules in a way that is unhelpful. In those cases one can instead use the <code>rewrite</code> tactic (which can be abbreviated as <code>rw</code>) to give finer control over what rules are applied in what order. </p>\n</blockquote>\n<p>You might want to mention <code>simp only</code> and <code>simp [-rule]</code> that can be used to avoid bad simplification steps.</p>",
        "id": 135964326,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539774059
    },
    {
        "content": "<p>By the way, I must say that I really like these files! You wrote really extensive comments. Thanks a lot!</p>",
        "id": 135964342,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539774104
    },
    {
        "content": "<p>I hadn't noticed the <code>simp only</code> thing, thanks for pointing that out.  I will have a look and see whether that makes some steps easier.</p>",
        "id": 135964796,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1539774731
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130308\">@Neil Strickland</span> Do you just want us to spam all our feedback into this thread? Or how should we organise this?</p>",
        "id": 135964801,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539774761
    },
    {
        "content": "<p>That's a good question.  I was thinking of putting the whole set of pages and associated code (including Coq and Isabelle stuff) on GitHub, but that will require some organisation, and I haven't really decided on the right structure.  So we should probably just use this thread for the time being.</p>",
        "id": 135964958,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1539774977
    },
    {
        "content": "<p>Yes I already have some comments about your nilpotent proof</p>",
        "id": 135964963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539774995
    },
    {
        "content": "<p>(although I am currently on a tram in Sheffield -- are you coming to lunch with me?)</p>",
        "id": 135964985,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539775042
    },
    {
        "content": "<p>Lines 520-620 or so -- these are of no interest to mathematicians and you never need all these intermediate lemmas. You can prove what you want in a couple of lines but it's incomprehensible in some sense. Proving these fiddly things is hard for beginners</p>",
        "id": 135965059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539775171
    },
    {
        "content": "<blockquote>\n<p>The definition comes from the file mathlib/data/nat/basic.lean (but I do not know a completely automatic way to obtain that information).</p>\n</blockquote>\n<p>You can go to the location where the definition was defined either by ctrl+click, or by clicking on it, and then pressing F12. That will in particular give you the file in which it was defined.</p>",
        "id": 135973624,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1539783895
    },
    {
        "content": "<p>A few minor typos in the annotations to \"primes\": </p>\n<ul>\n<li>\n<p>line 10, \"The declaration of <code>min_fac_prime</code> has the shape:\" the declaration that follows is missing <code>&lt;span class=\"code&gt;&lt;/span&gt;</code> around it.</p>\n</li>\n<li>\n<p>line 13, \"the implicit arguments ùëù and ùëõ are deduced from the context.\" However, the code uses <code>@dvd_fact</code>.</p>\n</li>\n<li>\n<p>line 15, \"The syntax <code>(...).mpr</code> extracts the left-to-right half of this equivalence,\" should be \"right-to-left\".</p>\n</li>\n</ul>",
        "id": 135974877,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1539785273
    },
    {
        "content": "<p>Have you seen <a href=\"https://github.com/leanprover-community/mathlib/tree/tutorials/tutorials\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/tree/tutorials/tutorials\">the work in the \"tutorials\" branch in leanprover-community</a>? The files <code>two_add_two.lean</code> and <code>partitions.lean</code> tackle tasks 1 and 5 from your MO post, respectively.</p>",
        "id": 135975155,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1539785613
    },
    {
        "content": "<blockquote>\n<p>Maybe you should write <code>include R</code> afterwards.</p>\n</blockquote>\n<p>This is correct. Lean doesn't automatically inserts variables, unless they are <strong>explicitly</strong> mentioned in the definition. For example, if I write</p>\n<div class=\"codehilite\"><pre><span></span>variables {Œ± Œ≤ : Type}\ndef my_id (a : Œ±) : Œ± := a\n</pre></div>\n\n\n<p>Then the definition <code>my_id</code> does <em>not</em> have <code>Œ≤</code> as an argument. If you want to explicitly add a variable/parameter <code>x</code> to all following definitions, you can write <code>include x</code> (and stop doing it with <code>omit x</code>). Because type-class variables are almost never <em>explicitly</em> mentioned, the (quite arbitrary) convention was added that if you don't give a type-class variable a name, it is automatically included if all variables in its type are included (so the variable <code>[comm_ring Œ±]</code> is included when <code>Œ±</code> is included).</p>",
        "id": 135975455,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1539785913
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 135983921,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539793906
    },
    {
        "content": "<p>PS <code>data.nat.binomial</code> was written by <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>  -- an Imperial maths undergraduate :-)</p>",
        "id": 135983922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539793906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span>  and <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> : are you happy for me to steal <code>two_add_two.lean</code> and <code>partitions.lean</code> and adapt them to the same framework that I have used for primes and nilpotents?</p>",
        "id": 135984404,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1539794312
    },
    {
        "content": "<p>I'm completely fine with that.</p>",
        "id": 135984428,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539794342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130308\">@Neil Strickland</span>  At line 528 you have <code>p := n + m + 1</code> and <code>Sn_gt_k : n + 1 &gt; k</code> and you want <code>m &lt; p - k</code>. Here's a relatively painless proof which avoids a bunch of intermediate steps.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"c1\">--lines 516-624</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Sn_gt_k</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">):</span>\n<span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"k\">in</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">lt_sub_right_of_add_lt</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">lt_of_lt_of_le</span> <span class=\"o\">(</span><span class=\"n\">add_lt_add_left</span> <span class=\"n\">Sn_gt_k</span> <span class=\"n\">m</span><span class=\"o\">),</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 135984549,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539794428
    },
    {
        "content": "<p>I think it's hard for learners to prove these things -- I have to a certain extent got a nose for which way to go now, but it wouldn't surprise me if Chris, Kenny or Mario could pull off a one-liner. However the real point should be that this is trivial to a mathematician so ideally should be done with a tactic. I tried <code>linarith</code> (as did you) and I couldn't get it to work. Should it work?</p>",
        "id": 135984621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539794511
    },
    {
        "content": "<p>I'm fine with that too.</p>",
        "id": 135985306,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1539795246
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span> <span class=\"kn\">lemma</span> <span class=\"n\">npz_mul_right</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xR</span> <span class=\"o\">:</span> <span class=\"n\">next_pow_zero</span> <span class=\"n\">x</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">next_pow_zero</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">npz_mul_left</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"n\">n</span> <span class=\"n\">xR</span>\n  <span class=\"kn\">end</span>\n</pre></div>",
        "id": 135986207,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539796079
    },
    {
        "content": "<p>Computer scientists like writing their proofs backwards because then they don't get extra hypotheses cluttering up the context (\"things that used to be the goal\" are not remembered, whereas old hypotheses are)</p>",
        "id": 135986423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539796265
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">have</span> <span class=\"n\">Z2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">,</span><span class=\"n\">mul_add</span><span class=\"o\">,</span><span class=\"n\">mul_one</span><span class=\"o\">,</span><span class=\"n\">one_mul</span><span class=\"o\">,</span><span class=\"n\">add_assoc</span><span class=\"o\">],</span>\n</pre></div>\n\n\n<p>I would just put <code>by ring</code> because why not.</p>",
        "id": 135986424,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539796265
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130308\">@Neil Strickland</span> In the post by Kevin (above this one) you can see that <code>x</code> and <code>n</code> can be determined from <code>xR</code>. So you can make them implicit, by wrapping them in <code>{}</code> instead of <code>()</code>.</p>",
        "id": 135986431,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539796278
    },
    {
        "content": "<p>The reason it's not dealt with automatically by <code>simp</code> is I believe that Leo removed <code>add_mul</code> and <code>mul_add</code> from the list of simp rules because of some CS reasons.</p>",
        "id": 135987203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539797110
    },
    {
        "content": "<p>Do you ever use <code>nilpotent_mul_right</code>and <code>npz_mul_right</code> ?</p>",
        "id": 135987623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539797471
    },
    {
        "content": "<blockquote>\n<p>because of some CS reasons</p>\n</blockquote>\n<p>aka exponential blowup</p>",
        "id": 135992615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539801880
    },
    {
        "content": "<p>Like I said</p>",
        "id": 135992675,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1539801957
    },
    {
        "content": "<blockquote>\n<p>There are mechanisms that allow Lean to obtain a commutative ring structure automatically from a field structure where necessary, but the resulting commutative ring structure is anonymous. It has been found convenient to include the line</p>\n<p><code>instance : comm_ring ‚Ñö          := by apply_instance</code></p>\n<p>in data/rat.lean, which allows us to use the notation rat.comm_ring to refer to the standard commutative ring structure on $\\mathbb{Q}$. </p>\n</blockquote>\n<p>Actually this is just to make it faster for lean to discover that Q has a comm_ring instance. Not sure if you want to mention that though.</p>",
        "id": 135992862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539802143
    },
    {
        "content": "<blockquote>\n<p>There is no obvious way to supply an alternative name; Lean rejects variable [R : comm_ring Œ±], for reasons that are not clear to me.</p>\n</blockquote>\n<p>Johan already mentioned this a bit, but unnamed instance variables are automatically included whenever the variable they reference is included, while a named variable is only included if it is used directly. So if you want to name an instance variable you have to put <code>include R</code> so it gets included even when it is not referenced.</p>",
        "id": 135993054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539802348
    },
    {
        "content": "<blockquote>\n<p>We are given a proof (denoted n_le_m) that $n\\leq m$. We now apply the theorem nat.succ_le_succ to convert it to a proof that $n+1\\leq m+1$. Note that the conclusion of nat.succ_le_succ is actually that succ n ‚â§ succ m, where succ is the successor function as in Peano arithmetic. One needs to unwind the definitions of $1$ and $+$ to see that n + 1 is the same as succ n. It is not clear to me under what circumstances this unwinding happens automatically, but it seems to work here. </p>\n</blockquote>\n<p>Unfolding of definitions like this happens, quite aggressively, when lean expects something of type T and you give it something of type T', and it tries to figure out why T and T' are the same (definitionally equal). Most tactics, on the other hand, are sensitive to the exact way you write an expression, so for example <code>rw</code> would not work on a term of type <code>next_pow_zero</code> even though it is an equality after some unfolding. You can also obtain the result of line 18 in a more automatic way by using <code>unfold next_pow_zero at xR</code>.</p>",
        "id": 135993577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539802883
    },
    {
        "content": "<p>L19:</p>\n<blockquote>\n<p>Note that we have given the name Sn_le_Sm to our conclusion. The Lean documentation says that one can use the keyword have with no label, and use the keyword this to refer to the most recently proved statement. However, this does not seem to work here. I think that this is because we are in tactic mode, and anonymous have only works outside that mode. But the full story is not clear to me. </p>\n</blockquote>\n<p>Anonymous have should work here. You can put <code>have : n + 1 ‚â§ m + 1 := (succ_le_succ n_le_m),</code> on this line and use <code>this</code> instead of <code>Sn_le_Sm</code> in L21, and it should work. If not, let me know what error you get</p>",
        "id": 135993697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539803036
    },
    {
        "content": "<p>Unless you specifically want to focus on nat subtraction and how annoying it is to work with for pedagogical reasons, I would suggest using <code>le.dest</code> to avoid it altogether. This also gives you a chance to use <code>rcases</code> which I think is worth calling out.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">npz_shift</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xR</span> <span class=\"o\">:</span> <span class=\"n\">next_pow_zero</span> <span class=\"n\">x</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n_le_m</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">‚â§</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">next_pow_zero</span> <span class=\"n\">x</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">next_pow_zero</span> <span class=\"n\">at</span> <span class=\"n\">xR</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">‚â§</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">succ_le_succ</span> <span class=\"n\">n_le_m</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">dest</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"bp\">‚ü®</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">SnkSm</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">x</span><span class=\"err\">^</span><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">‚Üê</span> <span class=\"n\">SnkSm</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">pow_add</span><span class=\"o\">,</span> <span class=\"n\">xR</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 135998372,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539807846
    },
    {
        "content": "<p>Here's a proof of <code>npz_add</code> with a few comments of my own. I tried not to over-optimize it and keep it pedagogical:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- The first few parameters are implicit because they follow from the types of xR and yR</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">npz_add</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">xR</span> <span class=\"o\">:</span> <span class=\"n\">next_pow_zero</span> <span class=\"n\">x</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">yR</span> <span class=\"o\">:</span> <span class=\"n\">next_pow_zero</span> <span class=\"n\">y</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">next_pow_zero</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">next_pow_zero</span> <span class=\"n\">at</span> <span class=\"n\">xR</span> <span class=\"n\">yR</span> <span class=\"err\">‚ä¢</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- we want to unfold this definition everywhere so it doesn&#39;t get in the way</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"err\">‚àà</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">p</span><span class=\"o\">))),</span>\n    <span class=\"n\">x</span> <span class=\"err\">^</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"err\">‚Üë</span><span class=\"o\">(</span><span class=\"n\">choose</span> <span class=\"n\">p</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Let us use suffices so that we know why we are proving this</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"k\">calc</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"err\">^</span><span class=\"n\">p</span>\n        <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">p</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">^</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"err\">‚Üë</span><span class=\"o\">(</span><span class=\"n\">choose</span> <span class=\"n\">p</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n        <span class=\"o\">:</span> <span class=\"n\">add_pow</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">p</span> <span class=\"c1\">-- use binomial theorem</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">p</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span>\n        <span class=\"o\">:</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum_congr</span> <span class=\"n\">rfl</span> <span class=\"n\">this</span> <span class=\"c1\">-- use the assumption</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">sum_const_zero</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- note for Neil: use {} instead of begin end to make it clearer that syntax</span>\n  <span class=\"c1\">-- in tactic mode is different than term mode.</span>\n  <span class=\"c1\">-- Similarly &#39;by&#39; is unnecessary in tactic mode</span>\n  <span class=\"n\">intros</span> <span class=\"n\">k</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">k_lt_Sp</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">mem_range</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">k_le_p</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">‚â§</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">le_of_lt_succ</span> <span class=\"n\">k_lt_Sp</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- note the name of the theorem is derivable from the statement (very important!)</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">le_or_gt</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">k</span> <span class=\"k\">with</span> <span class=\"n\">Sn_le_k</span> <span class=\"bp\">|</span> <span class=\"n\">Sn_gt_k</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">dest</span> <span class=\"n\">Sn_le_k</span> <span class=\"k\">with</span> <span class=\"bp\">‚ü®</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">Z0</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span> <span class=\"c1\">-- note Z0 : (n + 1) + j = k</span>\n    <span class=\"k\">have</span> <span class=\"n\">Z1</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">xR</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- Note at this point that theorem Z2 is actually a special case</span>\n    <span class=\"c1\">-- of npz_shift, so maybe we should go back and generalize it? Exercise for the reader</span>\n    <span class=\"k\">have</span> <span class=\"n\">Z2</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">^</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">‚Üê</span> <span class=\"n\">Z0</span><span class=\"o\">,</span> <span class=\"c1\">-- x ^ (n + 1 + j) = 0</span>\n        <span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">pow_add</span><span class=\"o\">,</span> <span class=\"c1\">-- x ^ (n + 1) * x ^ j = 0</span>\n        <span class=\"n\">Z1</span><span class=\"o\">,</span> <span class=\"c1\">-- 0 * x ^ j = 0</span>\n        <span class=\"n\">zero_mul</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Z2</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"n\">k_le_n</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">‚â§</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">lt_succ_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">Sn_gt_k</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">dest</span> <span class=\"n\">k_le_n</span> <span class=\"k\">with</span> <span class=\"bp\">‚ü®</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">Z0</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span> <span class=\"c1\">-- Z0 : k + j = n</span>\n    <span class=\"k\">have</span> <span class=\"n\">Z4</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">sub_eq_of_eq_add</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- get rid of the subtraction because nat subtraction sucks</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">Z0</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n      <span class=\"c1\">-- After unfolding p and using Z0.symm : n = k + j, the goal is</span>\n      <span class=\"c1\">-- (k + j) + m + 1 = k + (m + 1 + j) which simp can handle</span>\n      <span class=\"c1\">-- (just associativity and commutativity of addition)</span>\n    <span class=\"k\">have</span> <span class=\"n\">Z6</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"err\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Z4</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"n\">root_</span><span class=\"bp\">.</span><span class=\"n\">pow_add</span><span class=\"o\">,</span> <span class=\"n\">yR</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Z6</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 136000972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539810487
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"130308\">@Neil Strickland</span>  the viewer is really cool! The tex doesn't load for me though but if I add <code>MathJax.Hub.Queue([\"Typeset\",MathJax.Hub]);\n</code> to viewer.js line 102 above  <code>this.show_comment(0);</code> it does.</p>",
        "id": 136009280,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1539820758
    },
    {
        "content": "<p>Thanks to everyone for your feedback.  I am working on incorporating it and also improving my infrastructure in various ways; I will report back in a day or two.</p>",
        "id": 136015026,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1539828511
    },
    {
        "content": "<p>I'd love to see your infrastructure turn into <code>leandoc</code>. :-)</p>",
        "id": 136016513,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539830858
    },
    {
        "content": "<p>Can I suggest that you don't embed html in the source code, but use markdown instead? I don't think we're ever going to want to include html in source files, but markdown ($ ... $ for math is of course fine) is great.</p>",
        "id": 136016580,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539830962
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130308\">@Neil Strickland</span> I am using the latest version of Chrome (69.0.3497.100 (Official Build) (64-bit)) on OS X 10.10.5 and I see this: <a href=\"/user_uploads/3121/Cb0AG3O7WFQGsv-jamxweKyi/Screen-Shot-2018-10-18-at-6.25.03-pm.png\" target=\"_blank\" title=\"Screen-Shot-2018-10-18-at-6.25.03-pm.png\">Code from \"There are infinitely many primes\"</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Cb0AG3O7WFQGsv-jamxweKyi/Screen-Shot-2018-10-18-at-6.25.03-pm.png\" target=\"_blank\" title=\"Code from &quot;There are infinitely many primes&quot;\"><img src=\"/user_uploads/3121/Cb0AG3O7WFQGsv-jamxweKyi/Screen-Shot-2018-10-18-at-6.25.03-pm.png\"></a></div>",
        "id": 136026586,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539849390
    },
    {
        "content": "<p>Line 145 in <code>nilpotents</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">is_reduced</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<blockquote>\n<p>I am not completely clear about the mechanism for handling implicit and explicit arguments here. At the beginning of this file we opened a section and had the declaration <code>variable {Œ± : Type u}</code>. [...] It seems that the declaration here overrides the default behaviour and converts <code>ùõº</code> to an explicit argument. The ring structure on <code>ùõº</code> remains an implicit argument handled by typeclass inference, however. </p>\n</blockquote>\n<p>It's my understanding that when you explicitly include in a <code>def</code> some variable <code>ùõº</code> with the same name as one in an earlier <code>variable</code> declaration, lean locally creates a new variable which is unrelated to the other <code>ùõº</code>; in particular, previous typeclass assignments won't apply to the new <code>ùõº</code>, and that's why you had to put in <code>[comm_ring ùõº]</code> here again. </p>\n<p>To convert an existing variable from implicit to explicit, write <code>variable (ùõº)</code> on the line before this definition. Then when you want to let <code>ùõº</code> be implicit again (presumably after 158), you can write <code>variable {ùõº}</code>.</p>",
        "id": 136053537,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1539879344
    },
    {
        "content": "<p>Typo in the comments to line 153-154 in <code>nilpotents</code>: there's a missing space in \"<code>init/data/setoid.lean</code>in\".</p>\n<p>Including the types explicitly in lines 153 and 159 would make things more readable to me: <code> def reduced_quotient (Œ± : Type*) [comm_ring Œ±] : Type* :=</code> and <code>instance reduced_quotient_mk_is_ring_hom : is_ring_hom quotient_ring.mk :=</code>.</p>\n<p>I'm not sure what \"further problems related to implicit arguments\" occurred that required you to write lines 168-178 but if you say more perhaps we can figure it out.</p>",
        "id": 136055004,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1539880479
    }
]
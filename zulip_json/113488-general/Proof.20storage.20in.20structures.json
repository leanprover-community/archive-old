[
    {
        "content": "<p>To maintain their invariant, some structures contain proofs in addition to \"real\" data. I wonder, does Lean store the actual proof at runtime? For a small structure like a rational number, the overhead must be huge.</p>",
        "id": 241068724,
        "sender_full_name": "Valéry Croizier",
        "timestamp": 1622578318
    },
    {
        "content": "<p>No, everything in Prop is erased. That's more or less why Prop exists separately.</p>",
        "id": 241075764,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622581646
    },
    {
        "content": "<p>Lean doesn't store the proofs at runtime, they are used to typecheck the user's functions, but they are erased by the compiler by a step called <code>erase_irrelevant</code>, here is a small example of a type, which is a nat and a proof that it is small:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.compiler</span> <span class=\"n\">true</span> <span class=\"c1\">--so we can see what the compiler does</span>\n<span class=\"kd\">structure</span> <span class=\"n\">smallnat</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">10</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sub</span> <span class=\"o\">:</span> <span class=\"n\">smallnat</span>  <span class=\"bp\">→</span> <span class=\"n\">smallnat</span> <span class=\"bp\">→</span> <span class=\"n\">smallnat</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">n1</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">n2</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">n1</span> <span class=\"bp\">-</span> <span class=\"n\">n2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">omega</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">sub'</span> <span class=\"o\">:</span> <span class=\"n\">nat</span>  <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n1</span> <span class=\"n\">n2</span><span class=\"o\">,</span> <span class=\"n\">n1</span> <span class=\"bp\">-</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>First thing to note is that the generated bytecode (the last part of the output) is very similar for both functions e.g. for the <code>smallnat</code> version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">compiler.optimize_bytecode</span><span class=\"o\">]</span>  <span class=\"n\">sub</span> <span class=\"mi\">2</span>\n<span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">move</span> <span class=\"mi\">0</span>\n<span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">move</span> <span class=\"mi\">1</span>\n<span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"n\">ginvoke</span> <span class=\"n\">nat.has_sub</span>\n<span class=\"mi\">3</span><span class=\"o\">:</span> <span class=\"n\">apply</span>\n<span class=\"mi\">4</span><span class=\"o\">:</span> <span class=\"n\">apply</span>\n<span class=\"mi\">5</span><span class=\"o\">:</span> <span class=\"n\">ret</span>\n</code></pre></div>\n<p>there are no proofs being referred to in this bytecode, in fact lean has optimized by realising our structure is basically just a nat, and gotten rid of the structure completely, but that happens after the proofs are erased. The version just for nats is almost the same:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">compiler.optimize_bytecode</span><span class=\"o\">]</span>  <span class=\"n\">sub'</span> <span class=\"mi\">2</span>\n<span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">move</span> <span class=\"mi\">0</span>\n<span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">move</span> <span class=\"mi\">1</span>\n<span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"n\">cfun</span> <span class=\"n\">nat.sub</span>\n<span class=\"mi\">3</span><span class=\"o\">:</span> <span class=\"n\">ret</span>\n</code></pre></div>\n<p>we can see the step where the proofs are stripped away here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">compiler.elim_recursors</span><span class=\"o\">]</span>\n<span class=\"bp\">&gt;&gt;</span> <span class=\"n\">sub</span>\n<span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"n\">ᾰ</span> <span class=\"o\">:</span> <span class=\"n\">smallnat</span><span class=\"o\">),</span>\n  <span class=\"n\">_x.cases_on</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"o\">[</span><span class=\"n\">nat_value_macro</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">smallnat</span><span class=\"o\">),</span>\n       <span class=\"n\">_x.cases_on</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n_1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"o\">:</span> <span class=\"n\">n_1</span> <span class=\"bp\">&lt;</span> <span class=\"o\">[</span><span class=\"n\">nat_value_macro</span><span class=\"o\">]),</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">n_1</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">}))</span>\n    <span class=\"n\">ᾰ</span>\n<span class=\"o\">[</span><span class=\"n\">compiler.erase_irrelevant</span><span class=\"o\">]</span>\n<span class=\"bp\">&gt;&gt;</span> <span class=\"n\">sub</span>\n<span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"n\">ᾰ</span> <span class=\"o\">:</span> <span class=\"n\">smallnat</span><span class=\"o\">),</span>\n  <span class=\"n\">smallnat.cases_on</span> <span class=\"n\">_x</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">◾</span><span class=\"o\">),</span>\n       <span class=\"n\">smallnat.cases_on</span> <span class=\"n\">ᾰ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n_1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">◾</span><span class=\"o\">),</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">has_sub.sub</span> <span class=\"bp\">◾</span> <span class=\"n\">nat.has_sub</span> <span class=\"n\">n</span> <span class=\"n\">n_1</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"bp\">◾</span><span class=\"o\">}))</span>\n</code></pre></div>",
        "id": 241076019,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1622581762
    }
]
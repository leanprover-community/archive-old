[
    {
        "content": "<p>I have a <code>tree</code> and a recursive proposition that no two branches share a leaf (<code>tree_disjoint: tree.disjoint</code>).<br>\nI would like to do an inductive proof, say that the list of all leaves of a tree has no duplicates.<br>\nSince I'm doing a lot of such inductive proofs, I want a very concise induction scheme.</p>\n<p>I don't like the mess that the <code>tree.disjoint</code> hypothesis produces though.<br>\n(In my actual scenario, I have more tree cases that represent marked edges and about 40 such inductive proofs.)<br>\nA standard inductive proof on <code>tree</code> adds <code>*.disjoint</code> to all induction hypothesis and it does not unfold <code>tree.disjoint</code>,<br>\neven though I only need the disjoint prop for the branch case. All other cases just unfold and pass the prop as is.</p>\n<p>So I was thinking of a custom induction scheme.</p>\n<p>I get this \"mess\" with <code>induction tr</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">Tree.leaf</span>\n    <span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n    <span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n    <span class=\"n\">tree_disjoint</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Tree.leaf</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">disjoint</span>\n\n    <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">Tree.leaf</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"n\">case</span> <span class=\"n\">Tree.branch</span>\n    <span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n    <span class=\"n\">t_tr1t_tr2</span><span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span>\n    <span class=\"n\">t_ih_tr1</span><span class=\"o\">:</span> <span class=\"n\">t_tr1.disjoint</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">t_tr1</span>\n    <span class=\"n\">t_ih_tr2</span><span class=\"o\">:</span> <span class=\"n\">t_tr2.disjoint</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">t_tr2</span>\n    <span class=\"n\">tree_disjoint</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t_tr1.branch</span> <span class=\"n\">t_tr2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">disjoint</span>\n\n    <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">t_tr1.branch</span> <span class=\"n\">t_tr2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But I would like to get this with <code>induction tr using (Tree.disjoint_induction tree_disjoint)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">Tree.leaf</span>\n    <span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n    <span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n\n    <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">Tree.leaf</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"n\">case</span> <span class=\"n\">Tree.branch</span>\n    <span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n    <span class=\"n\">t_tr1t_tr2</span><span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span>\n    <span class=\"n\">t_ih_tr1</span><span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">t_tr1</span> <span class=\"c1\">-- No disjoint hypothesis here!</span>\n    <span class=\"n\">t_ih_tr2</span><span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">t_tr2</span>\n    <span class=\"c1\">-- This is the only thing I need from tr.disjoint:</span>\n    <span class=\"n\">tree_disjoint</span><span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">t_tr1.leaves</span> <span class=\"n\">t_tr2.leaves</span>\n\n    <span class=\"bp\">⊢</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">t_tr1.branch</span> <span class=\"n\">t_tr2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I played around with a custom induction lemma, but failed. The <a href=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html\">docs</a> don't say much about custom induction lemmas.<br>\nIt seems like I cannot even add decidable_eq type classes (I non-deterministically get \"induction tactic failed, major premise type is ill-formed\").<br>\nAlso, I don't know how to pass the prop <code>tr.tree</code> to the induction lemma.</p>\n<p>Do you have an idea? Is this even possible with a custom induction lemma?</p>\n<p>This is the context:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">Tree</span>\n<span class=\"bp\">|</span> <span class=\"n\">branch</span> <span class=\"o\">(</span><span class=\"n\">tr1</span> <span class=\"n\">tr2</span><span class=\"o\">:</span> <span class=\"n\">Tree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span> <span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Tree.leaves_list</span><span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Tree.leaf</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Tree.branch</span> <span class=\"n\">tr1</span> <span class=\"n\">tr2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tr1.leaves_list</span> <span class=\"bp\">++</span> <span class=\"n\">tr2.leaves_list</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Tree.leaves</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">a.leaves_list.to_finset</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Tree.disjoint</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Tree.leaf</span> <span class=\"n\">leaf</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">Tree.branch</span> <span class=\"n\">tr1</span> <span class=\"n\">tr2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tr1.disjoint</span> <span class=\"bp\">∧</span> <span class=\"n\">tr2.disjoint</span> <span class=\"bp\">∧</span> <span class=\"n\">disjoint</span> <span class=\"n\">tr1.leaves</span> <span class=\"n\">tr2.leaves</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Tree.rec_on2</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">leaf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">Tree.leaf</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">branch</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">tr1</span> <span class=\"n\">tr2</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">tr1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">tr2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">tr1.leaves</span> <span class=\"n\">tr2.leaves</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">tr1.branch</span> <span class=\"n\">tr2</span><span class=\"o\">)):</span>\n  <span class=\"n\">C</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Tree.leaves_list.nodup</span> <span class=\"o\">{</span> <span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">tree_disjoint</span><span class=\"o\">:</span> <span class=\"n\">t.disjoint</span><span class=\"o\">):</span>\n    <span class=\"n\">t.leaves_list.nodup</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n    <span class=\"c1\">-- This non-deterministically fails with `induction tactic failed, major premise type is ill-formed` in lean 3.21.0</span>\n  <span class=\"n\">induction</span> <span class=\"n\">t</span> <span class=\"n\">using</span> <span class=\"n\">Tree.rec_on2</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span> <span class=\"o\">{</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221643839,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609852182
    },
    {
        "content": "<p>Why doesn't this work? <code>Tree.rec_on2</code> should be true.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Tree.rec_on2</span> <span class=\"o\">{</span> <span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">n_disjoint</span><span class=\"o\">:</span> <span class=\"n\">n.disjoint</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">leaf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">Tree.leaf</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">branch</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">tr1</span> <span class=\"n\">tr2</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">tr1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">tr2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">tr1.leaves</span> <span class=\"n\">tr2.leaves</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">tr1.branch</span> <span class=\"n\">tr2</span><span class=\"o\">)):</span>\n  <span class=\"n\">C</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Tree.leaves_list.nodup</span> <span class=\"o\">{</span> <span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">tree_disjoint</span><span class=\"o\">:</span> <span class=\"n\">t.disjoint</span><span class=\"o\">):</span>\n    <span class=\"n\">t.leaves_list.nodup</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">t</span> <span class=\"n\">using</span> <span class=\"n\">Tree.rec_on2</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 221644990,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609852979
    },
    {
        "content": "<p><del>All you need is <code>@[elab_as_eliminator]</code> tagging <code>Tree.rec_on2</code>, and then <code>induction t using Tree.rec_on2</code> works</del></p>",
        "id": 221663298,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609862417
    },
    {
        "content": "<p>I just use <code>refine</code> instead of <code>induction using</code>, it's a lot more reliable</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">refine</span> <span class=\"n\">Tree.rec_on2</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">tr1</span> <span class=\"n\">tr2</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n</code></pre></div>",
        "id": 221664171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609862789
    },
    {
        "content": "<p>What would be your proof for <code>Tree.rec_on2</code>? How are you going to show <code>disjoint tr1.leaves tr2.leaves</code>?</p>",
        "id": 221664734,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1609863044
    },
    {
        "content": "<p>It seems a shame to have an <code>induction</code> tactic that intros all the hypotheses for you and applies case names, only to not be able to use it</p>",
        "id": 221665056,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609863107
    },
    {
        "content": "<p>I ran into a similar problem with <a href=\"#narrow/stream/113488-general/topic/.5Brecursor.5D.20doesn't.20understand.20coe_to_sort/near/217396242\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/.5Brecursor.5D.20doesn't.20understand.20coe_to_sort/near/217396242</a></p>",
        "id": 221665423,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609863227
    },
    {
        "content": "<p>are you volunteering to fix <code>induction using</code> in the C++?</p>",
        "id": 221665430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609863234
    },
    {
        "content": "<p>Perhaps if I had an understanding of the problem. Does lean4 have the same problem with <code>induction using</code>, or is there no <code>using</code> any more?</p>",
        "id": 221665604,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1609863302
    },
    {
        "content": "<p>I think lean 4 has something fancier, but equivalent</p>",
        "id": 221665681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609863345
    },
    {
        "content": "<p>I would assume it didn't inherit whatever bug this is</p>",
        "id": 221665708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609863359
    },
    {
        "content": "<p>Does <code>with_cases { refine ... }</code> or <code>with_cases { apply ... }</code> do anything useful? I think there's some related functionality there.</p>",
        "id": 221667813,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1609864231
    },
    {
        "content": "<p>It's certainly possible to get equivalent functionality if you use <code>with_cases</code>, but you would have to manually tag the subgoals</p>",
        "id": 221667952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609864303
    },
    {
        "content": "<p>I just don't find <code>induction using</code> to be very useful, so I don't really care that it's buggy</p>",
        "id": 221668102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1609864350
    },
    {
        "content": "<p><code>with_cases { apply ... }</code> picks up the case names if you give them in the induction principle:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[elab_as_eliminator]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">nat_ind</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">successor</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.rec</span> <span class=\"n\">zero</span> <span class=\"n\">successor</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">with_cases</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">nat_ind</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">zero</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">z</span><span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">successor</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"n\">ih</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">ih</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p><code>with_cases { refine ... }</code> doesn't...</p>",
        "id": 221669243,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1609864847
    },
    {
        "content": "<blockquote>\n<p>I just use refine instead of induction using, it's a lot more reliable</p>\n</blockquote>\n<p>It does not tag the goals though... I like the <code>case ...</code> statement really much! <br>\nThank you very much for the trick with <code>(λ tr1 tr2 h1 h2 x, _)</code>. I thought I had to use assume when after refine!</p>",
        "id": 221684011,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609871725
    },
    {
        "content": "<blockquote>\n<p>What would be your proof for Tree.rec_on2? How are you going to show disjoint tr1.leaves tr2.leaves</p>\n</blockquote>\n<p>The first \"case\" of the induction proof should imply this!</p>",
        "id": 221684224,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609871819
    },
    {
        "content": "<p><code>with_cases</code> is doing something strange here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Tree.leaves_list.nodup</span> <span class=\"o\">{</span> <span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">α</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">tree_disjoint</span><span class=\"o\">:</span> <span class=\"n\">t.disjoint</span><span class=\"o\">):</span>\n    <span class=\"n\">t.leaves_list.nodup</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">with_cases</span> <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">Tree.rec_on2</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">tr1</span> <span class=\"n\">tr2</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>   <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Adding <code>(λ a, _) (λ tr1 tr2 h1 h2 x, _),</code> has no effect!</p>",
        "id": 221684937,
        "sender_full_name": "Henning Dieterichs",
        "timestamp": 1609872192
    }
]
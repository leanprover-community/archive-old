[
    {
        "content": "<p>Johan mentioned this but I thought it deserved its own stream. I would like to hear the community's response to the negative points.</p>\n<p><a href=\"https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/\" target=\"_blank\" title=\"https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/\">https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/</a></p>\n<p>I am not too bothered about the steep learning curve (point 3). This will change over time as more documentation becomes available. There are sporadic counterexamples to Tom's claim, e.g. <span class=\"user-mention\" data-user-id=\"121918\">@Edward Ayers</span> and others seem to have managed well just by asking questions (and indeed I guess technically I am not in any of the categories Hales mentions either, although it did take me a year of my life and I'm still not very good at it).</p>",
        "id": 134182451,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537294172
    },
    {
        "content": "<p>As for 9 (diamonds), I know that Chris was finding these extremely frustrating and he was just goofing around with finite sets.</p>",
        "id": 134182648,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537294331
    },
    {
        "content": "<p>I think the story with diamonds is: there are workarounds, but they aren't particularly natural and you almost certainly won't get it right on your first attempt.</p>",
        "id": 134182959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537294655
    },
    {
        "content": "<p>Does anyone know what libraries are alluded to in Point 2: \"Lean 3 broke the Lean 2 libraries, and old libraries still haven’t been ported to Lean 3. \"?</p>",
        "id": 134183534,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537295216
    },
    {
        "content": "<p>Chris' struggles were particularly vacuous -- my understanding was that he would end up with two instances of a subsingleton which were not defeq and it would break type class inference.</p>",
        "id": 134183676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537295361
    },
    {
        "content": "<p>I read over his negative points, but I don't see how they could be (1) fixed, or (2) fixed in a way that doesn't make another set of tradeoffs somewhere else down the line</p>",
        "id": 134183691,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1537295389
    },
    {
        "content": "<p>Well of course this is a perfectly valid point. One can take any thing, however wonderful, and list all the ways it could be even more wonderful, including problems which are basically known to be impossible to fix.</p>",
        "id": 134183751,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537295439
    },
    {
        "content": "<p>I think Simon and Sean are working on point 4 (software engineering library)</p>",
        "id": 134183800,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537295520
    },
    {
        "content": "<p>I sympathise with Hales' point 10 -- I did find it a bore during my brief dalliance with topological rings, that I had to write <code>ring</code> and <code>topological space</code> and <code>topological ring</code> everywhere. And it's absolutely true that one wants to take completed tensor products of topological modules when doing adic spaces.</p>",
        "id": 134183854,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537295549
    },
    {
        "content": "<p>Is (8) fixed by these <code>additive</code> and <code>multiplicative</code> tricks, to a large extent?</p>",
        "id": 134183890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537295614
    },
    {
        "content": "<p>I think \"It seems to me that a system designed for doing mathematics should do more than just declare them illegal.\" is Tom misunderstanding Lean's main goal</p>",
        "id": 134183893,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537295622
    },
    {
        "content": "<p>Is point 7 (Ugly projection chains are required.) a problem in real situations?</p>",
        "id": 134183971,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537295701
    },
    {
        "content": "<p>Of course 9, 10 and 11 are real problems, but I have no idea how to fix that</p>",
        "id": 134183998,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537295742
    },
    {
        "content": "<p>About point 10, why can't we define <code>topological ring</code> in a single line using class and extends?</p>",
        "id": 134184650,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537296385
    },
    {
        "content": "<p>I think it would be useful to separate the pain points from the points of annoyance.  Point 10 seems to me to be a point of annoyance. In mathematics, you can underspecify your constructions. You can parameterize your constructions and say \"the reader knows what I mean here\". In formal language everything needs to be completely specified which is bound to cause annoying verbosity. Coq chooses to parameterize constructions using functors and modules which can make modules simple but their use complicated. Lean's adoption of type classes can make the specification of your mathematical concepts a bit more verbose but using them is extremely unintrusive.</p>",
        "id": 134185611,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537297156
    },
    {
        "content": "<p>It's comments like this from the CS side which I was really hoping to elicit. Thanks Simon (and Mario!)</p>",
        "id": 134185782,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537297286
    },
    {
        "content": "<p>You're welcome! I'm glad this is welcome. I sometimes have a hard time stopping myself for ranting and wouldn't want to annoy</p>",
        "id": 134185871,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537297353
    },
    {
        "content": "<p>I'm really tempted to shrug off all those down sides to be honest. </p>\n<p>His point 1. about being bloated doesn't make sense to me. Bloated compared to what? HOL-light? Isabelle? The logic aren't the same so it's hard to meaningfully compare. Compared to Coq? Absolutely not. Lean exorcised features like termination checking, coinductive types and pattern matching from the kernel to great benefit.</p>",
        "id": 134186077,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537297539
    },
    {
        "content": "<p>I also wondered how many of these cons were disadvantages of Lean compared to other theorem proving systems, versus just \"formal methods are hard\".</p>",
        "id": 134186310,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537297779
    },
    {
        "content": "<p>Actually point 10 about bundling and unbundling is the item on this list which has caused me the most grief</p>",
        "id": 134186744,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537298207
    },
    {
        "content": "<blockquote>\n<p>Actually point 10 about bundling and unbundling is the item on this list which has caused me the most grief</p>\n</blockquote>\n<p>Do you know if other provers address the problem better?</p>",
        "id": 134186891,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537298378
    },
    {
        "content": "<p>Nope, and I don't really have any idea what a better solution would look like.<br>\nI guess a general method for unbundling is \"a [type-with-structure] whose underlying type is equal to [T]\", so I guess better support for handling equalities would ease the pain. (For example, I saw some slides about some theorem proving system whose name I forget in which if you had a proof of <code>p = q</code> in scope, then the types <code>p</code> and <code>q</code> would unify. I guess GHC works a bit like this as well. It has its own complications.)</p>",
        "id": 134187062,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537298545
    },
    {
        "content": "<blockquote>\n<p>I also wondered how many of these cons were disadvantages of Lean compared to other theorem proving systems, versus just \"formal methods are hard\".</p>\n</blockquote>\n<p>Good question. And I think the comparison can be broken down into two parts: </p>\n<p>1. for someone who's about to start a short term project, is Lean a good choice?<br>\n2. if you're willing to contribute libraries or other infrastructure, is Lean a good prover to invest in?</p>",
        "id": 134187064,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537298548
    },
    {
        "content": "<p>I think it should be noted that Tom Hales is someone who has years and years of experience both as a user of theorem provers and as a \"regular\" research mathematician. This is not just someone listing a couple of annoyances. There probably is quite a lot of thought and experience behind this critique.</p>",
        "id": 134187072,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1537298566
    },
    {
        "content": "<p>That's actually the angle that I'm trying to take and I think that's the reason why we should look closely at the list. Individually, we may miss nuggets of insight but I'm hoping a discussion like this can dig them out.</p>",
        "id": 134187984,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537299560
    },
    {
        "content": "<blockquote>\n<p>Does anyone know what libraries are alluded to in Point 2: \"Lean 3 broke the Lean 2 libraries, and old libraries still haven’t been ported to Lean 3. \"?</p>\n</blockquote>\n<p>I think Tom is wrong on this point. While it's true that we never actually ported the lean 2 libraries, they have been \"morally\" ported, and the reasons for not porting directly have more to do with the change in management and design decisions than backwards incompatibility on the part of lean</p>",
        "id": 134188213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537299837
    },
    {
        "content": "<p>When Lean 4 hits, if it has no simplifier, am I right in thinking that porting mathlib will simply wait until it does?</p>",
        "id": 134188283,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537299883
    },
    {
        "content": "<p>more or less</p>",
        "id": 134188292,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537299893
    },
    {
        "content": "<p>mathlib will live wherever it is most well supported</p>",
        "id": 134188308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537299913
    },
    {
        "content": "<p>Do you know why mathlib takes so long to compile?</p>",
        "id": 134188311,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537299917
    },
    {
        "content": "<p>or more precisely why it takes so long for some people?</p>",
        "id": 134188322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537299937
    },
    {
        "content": "<p>For me it's fine but i have a relatively new machine</p>",
        "id": 134188329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537299949
    },
    {
        "content": "<p>There are a lot of culprits to point at. Extensive use of tactics and slow elaboration are probably the main factors, if we're talking about compilation from scratch</p>",
        "id": 134188412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537300012
    },
    {
        "content": "<p>Can we fix slow elaboration with cunning instance definitions?</p>",
        "id": 134188432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537300036
    },
    {
        "content": "<p>Not really, at least not without sacrificing something far more important</p>",
        "id": 134188453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537300074
    },
    {
        "content": "<p>that's something that needs to be tackled on the core side</p>",
        "id": 134188496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537300088
    },
    {
        "content": "<p>and I don't even know if it can be improved</p>",
        "id": 134188501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537300099
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/f9e9bf90003f6a2b82196e60da0b14cc57c90c44/src/valuation_spectrum.lean#L17\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-perfectoid-spaces/blob/f9e9bf90003f6a2b82196e60da0b14cc57c90c44/src/valuation_spectrum.lean#L17\">https://github.com/kbuzzard/lean-perfectoid-spaces/blob/f9e9bf90003f6a2b82196e60da0b14cc57c90c44/src/valuation_spectrum.lean#L17</a></p>",
        "id": 134188512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537300117
    },
    {
        "content": "<p>but we've all seen examples of simple <code>exact</code> proofs that inexplicably take several seconds</p>",
        "id": 134188526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537300137
    },
    {
        "content": "<p>Why did Patrick have to <code>set_option class.instance_max_depth 41</code>?<br>\n`</p>",
        "id": 134188531,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537300142
    },
    {
        "content": "<p>that's a good question to ask Patrick</p>",
        "id": 134188548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537300164
    },
    {
        "content": "<p>Is that related? Is thjs \"exact proofs take several seconds\" phenomenon understood?</p>",
        "id": 134188564,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537300175
    },
    {
        "content": "<p>not by me, not really</p>",
        "id": 134188576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537300197
    },
    {
        "content": "<p>There was one that came up the other day, maybe Kenny had something which took 4 seconds and changing the elaboration strategy fixed it</p>",
        "id": 134188622,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537300205
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/why.20is.20this.20slow.3F\" title=\"#narrow/stream/113488-general/topic/why.20is.20this.20slow.3F\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/why.20is.20this.20slow.3F</a></p>",
        "id": 134188674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537300281
    },
    {
        "content": "<p>yes, that's the sort of thing I'm talking about</p>",
        "id": 134188678,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537300288
    },
    {
        "content": "<p>I'm pretty sure that there are several borderline proofs in mathlib that are just taking a long time to elaborate</p>",
        "id": 134188693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537300313
    },
    {
        "content": "<p>when you multiply that by thousands it starts to contribute to global warming</p>",
        "id": 134188757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1537300353
    },
    {
        "content": "<p>out of curiosity if I wanted to write a tactic could I write it in C++ (like Coq does with OCaml?)</p>",
        "id": 134189015,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1537300621
    },
    {
        "content": "<p>maybe a better question is: can I compile it into a library and dynamically link to it at runtime?</p>",
        "id": 134189041,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1537300652
    },
    {
        "content": "<p>I think you have to write it in Lean.</p>",
        "id": 134189046,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537300664
    },
    {
        "content": "<p>but only because I've never heard anyone else talking about or doing this</p>",
        "id": 134189098,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537300690
    },
    {
        "content": "<p>I also wondered whether Lean has some kind of FFI.</p>",
        "id": 134189940,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537301493
    },
    {
        "content": "<p>I think there is such a thing as a \"Lean extension\" but I don't know anything more about that.</p>",
        "id": 134190001,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537301524
    },
    {
        "content": "<p>I don't see any reason why Lean couldn't adopt a Haskell-style FFI to C</p>",
        "id": 134190057,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537301584
    },
    {
        "content": "<p>I wonder what sort of existing libraries Tom Hales wants to use (or uses, in HOL light)</p>",
        "id": 134190085,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537301628
    },
    {
        "content": "<p>I think a proper FFI is planned for Lean 4</p>",
        "id": 134190267,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1537301829
    },
    {
        "content": "<p>If you want to write a tactic which uses a linear programming solver as an oracle, then a simple FFI is enough. If you want to write \"simp, but different\" in C++ (for performance or familiarity) then you need direct access to Lean internals.</p>",
        "id": 134190785,
        "sender_full_name": "Reid Barton",
        "timestamp": 1537302315
    },
    {
        "content": "<p>About a year ago when I first saw Lean (at the big proof conf) I had similar reservations.</p>\n<p>I agree that the language is difficult to learn. There is just a lot of syntax and it is hard to tell if a piece of syntax is fundamental or just sugar. Some of the attributes do magic syntax things that aren't documented.  But the syntax is _way_ easier than Isabelle's.</p>\n<p>I think that Lean has a chance of taking off because it is relatively simple and there is a strong focus on tooling support and because it is a fresh start that doesn't have to be backwards compatible.<br>\nEg the Isabelle source code is an intimidating sprawl of different projects and languages. </p>\n<p>Complaining about a lack of library support is an inevitable complaint. Libraries for a new computer language always have to start somewhere. I also believe that the ultimate goal of interactive theorem proving should be that writing up a new mathematical theory in a formal system should (in the future)  take about the same amount of time as writing rigorous, informal notes. Formalising a theory for oneself, even a simple undergraduate one, is an extremely powerful way of learning about that theory. So I believe that mathlib should be more of a book of examples and standardisations that you can use to code up your own formalisations, rather than a monorepo of truth.</p>\n<p>With the typeclass complaints (7 to 11), I have just come to accept that this is always a total nightmare no matter what system you use. Humans are very good at looking at (their own, internal) typeclasses and rapidly bundling, unbundling, identifying obvious coercions, diamonding, finding isomorphisms and so on. Computers need these spelled out to them, so libraries get cluttered with typeclass-plumbing lemmas. Oh well.</p>",
        "id": 134218109,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537344924
    },
    {
        "content": "<blockquote>\n<p>So I believe that mathlib should be more of a book of examples and standardisations that you can use to code up your own formalisations, rather than a monorepo of truth.</p>\n</blockquote>\n<p>I need to have my monorepo of truth because the sooner we can start saying \"Look! We have a complete definition of perfectoid spaces! Look! We have a complete formulation of Langlands functoriality! Look! Here are the 6 Clay Problems which are actually mathematics!\" the sooner mathematicians will sit up and take notice</p>",
        "id": 134218516,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537345425
    },
    {
        "content": "<p>I regard this as extremely high priority.</p>",
        "id": 134218564,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537345447
    },
    {
        "content": "<p>I also, this time just for personal reasons, want to be able to say \"Look! Our students are demanding problem sheets are set in Lean and you can't do that for them because you don't know it\" to my colleagues, but I have a longer time frame for that goal.</p>",
        "id": 134218579,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537345497
    },
    {
        "content": "<p>I think the book of standardisations and formalisations is something else. What would you imagine it looked like? No way are we going to get mathlib to define a compact space as \"every open cover has a finite subcover\" because they have their reasons for using filters etc. However we are equally unlikely to get the 2nd year metric spaces and topology person to switch to using filters, because most mathematicians never need them.</p>",
        "id": 134218654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537345597
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121918\">@Edward Ayers</span> tell me more about what you want. I have a bunch of undergraduates who are currently writing code which has nowhere to go.</p>",
        "id": 134218666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537345627
    },
    {
        "content": "<p>The main thing that I want (and am working on) is automation that is good enough that one doesn't need to clutter ones theory file with lots of lemmas that you wouldn't put in a maths textbook.</p>",
        "id": 134219095,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537346189
    },
    {
        "content": "<p>I think it is critical to get formal documents to have the same terseness and readability as informal mathematics.</p>",
        "id": 134219289,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537346422
    },
    {
        "content": "<p>Let's just say that in 5 years' time you get funded for some proposal to write an undergraduate mathematics textbook in Lean, and you have to prove that a compact metric space is complete.</p>",
        "id": 134219315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346477
    },
    {
        "content": "<p>You look at mathlib and discover that there is already a proof in there, probably in the generality of pseudo-compact semi-metric spaces</p>",
        "id": 134219331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346512
    },
    {
        "content": "<p>and the proof is unreadable, and intended to be unreadable.</p>",
        "id": 134219376,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346536
    },
    {
        "content": "<p>Is the idea that you prove it again, using the standard filter-free proof presented to undergraduate mathematicians, and underlying it all is a really good interface which people have written so that it now reads like the maths proofs which I present to undergraduate mathematicians in lectures?</p>",
        "id": 134219411,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346629
    },
    {
        "content": "<p>If you did that, it would teach mathematicians how to use Lean I guess. But the proof will still be in mathlib and terse and incomprehensible, and devs would rather use the mathlib proof than the proof in the book.</p>",
        "id": 134219477,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346704
    },
    {
        "content": "<p>I'm just trying to understand how all this fits into the scheme of things.</p>",
        "id": 134219483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346715
    },
    {
        "content": "<p>Yes the result in the library isn't good enough because it is over-generalised. It doesn't have to be in Latex and be all fancy, and the argumentation doesn't have to be exactly the same as how it is done in lectures. But it has to possible to follow the argument without unpacking lots of more general theories.</p>",
        "id": 134219485,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537346726
    },
    {
        "content": "<p>So your goal is a <em>readable proof</em></p>",
        "id": 134219490,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346756
    },
    {
        "content": "<p>yes</p>",
        "id": 134219546,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537346798
    },
    {
        "content": "<p>I must be honest, I do not really understand enough about library maintenance to know why mathlib prefers what one might call \"obfuscated proofs\".</p>",
        "id": 134219550,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346807
    },
    {
        "content": "<p>But I have no doubt that they have good reasons.</p>",
        "id": 134219560,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346825
    },
    {
        "content": "<p>It has to be a proof where you can read it and be able to see how to make similar arguments yourself.</p>",
        "id": 134219564,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537346837
    },
    {
        "content": "<p>And I want to conclude from this that your readable proofs will not actually be useful in terms of library-building, for some reason that I don't understand but am arguing must exist</p>",
        "id": 134219576,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346861
    },
    {
        "content": "<p>On the other hand it seems to me that your readable proofs will be essential for teaching mathematicians how to use formal proof verification systems.</p>",
        "id": 134219628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346886
    },
    {
        "content": "<p>If you use the obfuscated approach I think you can save time because you only have to prove the super-general case.</p>",
        "id": 134219636,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537346901
    },
    {
        "content": "<blockquote>\n<p>It has to be a proof where you can read it and be able to see how to make similar arguments yourself.</p>\n</blockquote>\n<p>I specifically tried to write the definition of a perfectoid space in such a way that a mathematician who knows 0 about theorem provers and look at the code and think \"oh yeah, I can see that this might well be a definition of a perfectoid space\"</p>",
        "id": 134219661,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346940
    },
    {
        "content": "<p>It depends on what you want the library to do I guess.</p>",
        "id": 134219666,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537346945
    },
    {
        "content": "<p>but I made no attempt to do so for some of the earlier files because I have dreams of getting at least some of this stuff into mathlib</p>",
        "id": 134219678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346962
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\">- A perfectoid ring, following Fontaine Sem Bourb-/</span>\n<span class=\"n\">class</span> <span class=\"n\">perfectoid_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">Tate_ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">complete</span> <span class=\"o\">:</span> <span class=\"n\">is_complete</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">uniform</span>  <span class=\"o\">:</span> <span class=\"n\">is_uniform</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">ramified</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ϖ</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">is_pseudo_uniformizer</span> <span class=\"n\">ϖ</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">((</span><span class=\"n\">ϖ</span><span class=\"err\">^</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">Frob</span>     <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"err\">ᵒ</span><span class=\"o\">)</span> <span class=\"err\">∣</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"err\">^</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"n\">class</span> <span class=\"n\">perfectoid_space</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">adic_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">perfectoid_cover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Huber_pair</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">perfectoid_ring</span> <span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">R</span><span class=\"o\">],</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">is_preadic_space_equiv</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">Spa</span> <span class=\"n\">A</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 134219682,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537346992
    },
    {
        "content": "<p>Mathematicians who know this area know that a perfectoid ring is a complete uniform ring satisfying some axioms, and that's what they see here.</p>",
        "id": 134219742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537347029
    },
    {
        "content": "<p>But if they look at the definition of complete, they see filter hell</p>",
        "id": 134219756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537347047
    },
    {
        "content": "<p>So you see, I am trying to conform to mathlib's aims in some places and your aims in others.</p>",
        "id": 134219775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537347085
    },
    {
        "content": "<p>But in general I am very unclear about why Larry is so keen on human-readable code and given that mathlib is run by people who seem to know what they are doing, and who are intentionally accepting highly minimised code which is not at all optimised for readability, there are presumably arguments for both styles. Can I deduce from what you're saying that there should be a place for both?</p>",
        "id": 134219948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537347257
    },
    {
        "content": "<blockquote>\n<p>But if they look at the definition of complete, they see filter hell</p>\n</blockquote>\n<p>That's actually a bad example. Uniform spaces are needed for topological rings (we can't assume the topology is metrizable here)</p>",
        "id": 134220322,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537347736
    },
    {
        "content": "<blockquote>\n<p>Why did Patrick have to <code>set_option class.instance_max_depth 41</code>?</p>\n</blockquote>\n<p>Because it won't compile with depth 40. Of course it almost certainly doesn't mean that one successful search has depth 41. Most likely it means Lean needs depth 41 before giving up on a bad idea and starting to backtrack. So what seems needed is a way to block stupid ideas in type class search. But this is clearly something for Leo and Sebastian to think about, we can't do anything about that (the same thing applies to the thread discussing proof cache yesterday, it's a bit ridiculous to discuss this as if Leo never thought about its...)  In the mean time we could try to carefully craft type class shortcuts in this specific case.</p>",
        "id": 134220635,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537348190
    },
    {
        "content": "<p>complete rings: Yes that is true. But in general I guess one could do a \"case study\". Ed gets hold of some second year metric spaces and topology lecture course, and tries to write down the course <em>exactly as the lecturer wrote it</em> and see how much of it he could get Lean to swallow, filling in all the auxiliary boring stuff with the <code>by undergraduate_mathematician</code> tactic.</p>",
        "id": 134220691,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537348254
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Why Larry is so keen on human-readable proof, and why we don't have them in mathlib:<br>\nIsabelle's language (called Isar) was always intended to produce human readable proofs. A lot of document generation around it allows to produce TeX-documents. The automation is geard towards it. And type inference is much easier in the simple typed setting of Isabelle.</p>\n<p>One important part in readable formal proofs is to repeat the statements you want to prove. But in DTT this is much harder, as type inference often fails, and the user needs to provide more information (or needs to add type class information <code>letI</code> and co). In Isabelle this is often not necessary. There, it is much easier just to copy your statement and it just works, without adding additional typing informations. Of course, this is all at the cost of a much simpler type system.</p>\n<p>At least this is for me a reason, why I don't use <code>have</code> etc as much as I did in Isabelle. Also Isabelle has more automation like <code>auto</code> and <code>sledgehammer</code>, where it makes sense just to say what you want to prove, without stating how it is proved.</p>",
        "id": 134220693,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537348258
    },
    {
        "content": "<blockquote>\n<p>I think it should be noted that Tom Hales is someone who has years and years of experience both as a user of theorem provers and as a \"regular\" research mathematician. This is not just someone listing a couple of annoyances. There probably is quite a lot of thought and experience behind this critique.</p>\n</blockquote>\n<p>Yes, we need to be careful not to become a fanboy community. Everybody here love Lean, but it doesn't mean it can't be criticized. I've seen this with the Blender3D community, and I think it's pretty dangerous. And we can actually act on some of these bad points, especially the learning curve and libraries part. Of course many things are beyond our control, but I'm sure Leo will read it at some point, and although he probably knows all this, he may still get something out of it (but I'm afraid many things are very difficult to \"fix\" without breaking something else).</p>",
        "id": 134221026,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1537348795
    },
    {
        "content": "<p>Ed's comments make me think that he might be better off using Isabelle</p>",
        "id": 134221352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537349329
    },
    {
        "content": "<p>on the other hand it would be wonderful to do this sort of project in Lean for teaching purposes.</p>",
        "id": 134221353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1537349329
    },
    {
        "content": "<p>Don't make me go back to Isabelle!</p>",
        "id": 134224649,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537354550
    },
    {
        "content": "<p>:-)</p>",
        "id": 134224759,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1537354684
    },
    {
        "content": "<p>More seriously,<br>\nI don't quite agree with <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span>  about readability.<br>\nFirstly, most of the time you can avoid the 'dependent' part of DTT and write out proofs in the same way as Isar without too many problems.<br>\nThere is no reason why Lean can't have automation like sledgehammer and auto, it is just that Isabelle has been around longer.</p>\n<p>Readability for me doesn't mean that it pretty prints to Latex and has plain english keywords. It means that what is written maps cleanly to an explanation at a level that a human would give.</p>\n<p>Perhaps a good example is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">protected</span> <span class=\"kn\">lemma</span> <span class=\"n\">add_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">suffices</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"k\">from</span>\n    <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">succ_add</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">▸</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">congr_arg</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">add_comm</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>This would not look good in a maths textbook, but once you take time to understand the syntax, it matches what a human would write:</p>\n<blockquote>\n<p>Induct on <code>n</code>. In the zero case we have <code>n+0=0+n</code> which we proved in <code>nat.zero_add</code>.<br>\nIn the <code>m+1</code> case, it suffices to prove <code>succ (n + m) = succ (m + n)</code> since we have<br>\n<code> ∀ (n m : ℕ), succ n + m = succ (n + m)</code>. But then we are done since <code>(n+m)=(m+n)</code> by the induction premiss.</p>\n</blockquote>\n<p>The proofs are totally different syntactically but they both share the same skeleton and go in to (roughly) the same level of detail. That's what I mean by readability.</p>\n<p>So my complaint with mathlib is that often the lemmas and definitions will sometimes deviate from the level of explanation that a mathematician is after.<br>\nEither spelling out simple lemmas that a mathemematician would not bother with, or appealing to some mysterious general lemma. </p>\n<p>I think a good example of this is defining the lattice structure on filters using galois connections in mathlib (in <code>filter.lean</code>). Here, we take advantage of a general theory to define a lattice structure. But then if you read the code, after this we have to use <code>original_complete_lattice.copy</code> because we want non-general definitions of join and meet. So using the general theory introduced a lot of plumbing that makes it hard to follow.  (apologies to the authors of that file, I am not trying to be a  jerk and I don't have a better way of solving this)</p>",
        "id": 134225432,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537355667
    },
    {
        "content": "<p>Perhaps that's not a good example, I don't know how the lattice structure on a filter would be introduced in a maths textbook.</p>",
        "id": 134225517,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537355859
    },
    {
        "content": "<p>Isar syntax doesn't meet this definition of readability because you will often have to write out vastly more steps than a textbook proof would need, even with the help of Isabelle's powerful automation.</p>",
        "id": 134225948,
        "sender_full_name": "Edward Ayers",
        "timestamp": 1537356528
    },
    {
        "content": "<p>With readable I don't mean that it resembles readable English text. What I mean is that it is readable without looking at the tactic output. This is not only a technicality: When we have control how the proof is represented why have more control how to guide a user through the proof. Maybe we can call this <strong>explicit</strong> proofs?!</p>\n<p>Your example of <code>add_comm</code> is an exception in mathlib. Often one wouldn't write the <code>suffices</code>. so the (second) central part to understand the proof is missing. The main part, the induction, is luckily easy to see.</p>\n<p>Another difference is that Isar doesn't have a very powerful tactic mode (at least nothing comparable to Lean's). So people are much more eager to write down <code>have</code> with repeating a similar statements. This again helps a reader going through a proof and reading it. </p>\n<p>I also hope that Lean will have in the non to distant future tactics similar to auto (tidy is a good candidate) and sledgehammer. But we will see if people start writing more explicit proofs.</p>",
        "id": 134226390,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537357154
    },
    {
        "content": "<p>I think currently it is not possible to find a theorem prover were you don't need to write vastly more steps than a textbook proof would need. Hopefully somewhere in the future this is possible. But we are far from this.</p>",
        "id": 134226465,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1537357241
    },
    {
        "content": "<p>The <a href=\"https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/\">post</a> and this topic are very dated but I don't seem to find:</p>\n<ol>\n<li>any (semi-)official replies (or status updates) to the issues raised in the post</li>\n<li>any other systematic review of Lean (or mathlib) comparing to other theorem provers such as Agda, HOL Light, Isabelle, Coq etc. (or their mathematical libraries) except for some Lean/Mathlib papers</li>\n</ol>\n<p>The only thing related I find useful is discussions in nForum: <a href=\"https://nforum.ncatlab.org/discussion/6626/lean/\">https://nforum.ncatlab.org/discussion/6626/lean/</a> , particularly comment 8, 10, 13, 14, 18, 22 .</p>",
        "id": 203371292,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594290864
    },
    {
        "content": "<p>Is \"A Survey on Theorem Provers in Formal Methods\" by Nawaz et al (2019) perhaps something you are looking for? <a href=\"https://arxiv.org/pdf/1912.03028v1\">https://arxiv.org/pdf/1912.03028v1</a></p>",
        "id": 203439316,
        "sender_full_name": "Hester Breman",
        "timestamp": 1594328104
    },
    {
        "content": "<p>Wow, that is very detailed :)</p>",
        "id": 203439945,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594328395
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"297703\">@Hester Breman</span> Thank you! That's a very extensive survey, previously I was only reading <a href=\"https://arxiv.org/abs/2005.12876\">A Survey of Languages for Formalizing Mathematics</a> which has an emphasis on formalizing mathematics but contains fewer details for respective languages. This paper makes a good complement.</p>\n<p>The specific issues Hales raised are partly addressed by papers formalizing mathematics or technical papers focusing on individual features, some are Lean's and some Coq's that mentions Lean (or is mentioned by Lean). I'm kind of looking for more papers on the design of mathematical libraries, particularly on different solutions leveraging features ( or due to limitations) of different languages.</p>",
        "id": 203465613,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594350915
    },
    {
        "content": "<p><a href=\"https://arxiv.org/pdf/1912.03028v1\">https://arxiv.org/pdf/1912.03028v1</a> has some not-so-great aspects. The caption on Fig 1: \"Theorems proved by scientists in ITPs\" would be funny if I was in the mood. In fact that figure is showing how many of the theorems on Freek's list have been proved by various people...</p>",
        "id": 203466251,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1594351888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> Thank you for your kind reply, especially because apparently the article I sent is not that great. Thank you also for the interesting article by Kaliszyk &amp; Rabe. If I see a paper closer to your interest of design of mathematical libraries, I'll let you know.</p>",
        "id": 203685917,
        "sender_full_name": "Hester Breman",
        "timestamp": 1594626200
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296911\">@Utensil Song</span> FYI The paper you were reading will be presented very soon today at CICM 2020: <a href=\"https://easychair.org/smart-program/CICM-13/\">https://easychair.org/smart-program/CICM-13/</a> (see also the stream CICM 2020).</p>",
        "id": 205212567,
        "sender_full_name": "Hester Breman",
        "timestamp": 1595927153
    },
    {
        "content": "<p>Thanks for the kind reminder, I have signed up for CICM 2020 (but unfortunately missed the talks from yesterday).</p>",
        "id": 205212963,
        "sender_full_name": "Utensil Song",
        "timestamp": 1595927463
    }
]
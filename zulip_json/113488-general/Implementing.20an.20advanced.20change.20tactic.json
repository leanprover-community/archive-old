[
    {
        "content": "<p>Sometimes I want to change a part of an assumption or the goal with another expression, providing a proof that they are equal. Tactics <code>convert</code>, <code>convert_to</code>, <code>congr</code>, <code>congr'</code> and <code>change</code> may help sometimes, but they are not flexible enough for my use case.</p>\n<p>I would like to have a tactic <code>ch</code> that changes a part of an expression with another expression and creates a new goal to prove that the two expressions are equal. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ch</span> <span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">_</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The goals become:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">⊢</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">ℕ</span>\n</code></pre></div>\n<p>The tactic looks at <code>_ + 1</code> and tries to resolve <code>_</code>. If there was additional <code>b + 1</code> in the goal expression, the tactic would throw an error, because the match would be ambiguous. After resolving <code>_</code> to <code>a</code>, it produces a new goal asking to prove that <code>a + 1 = ?m_1 * 1</code> for some natural number <code>?m_1</code>. Underscores on the LHS resolve to fixed expressions, while underscores on the RHS become metavariables. The tactic can also be applied at multiple locations.</p>\n<p>This is my attempt to implement it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic.interactive</span>\n<span class=\"n\">setup_tactic_parser</span>\n\n<span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.interactive.ch</span>\n  <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">texpr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">location</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">h</span> <span class=\"bp\">←</span> <span class=\"n\">i_to_expr</span> <span class=\"n\">eq</span><span class=\"o\">,</span>\n  <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"n\">tactic.assert</span> <span class=\"bp\">`</span><span class=\"n\">this</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">tactic.swap</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">none</span> <span class=\"n\">none</span> <span class=\"n\">tt</span> <span class=\"o\">[</span><span class=\"n\">simp_arg_type.expr</span> <span class=\"bp\">``</span><span class=\"o\">(</span><span class=\"bp\">%%</span><span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">[]</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n  <span class=\"n\">clear</span> <span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">this</span><span class=\"o\">],</span>\n  <span class=\"n\">tactic.swap</span>\n</code></pre></div>\n<p>It does not support underscores at all and <code>simp</code> is not good enough for this purpose, because, for example, it will fail if we try to replace <code>x</code> with <code>x * 1</code>. The better approach would be to rewrite it manually (by using <code>eq.rec</code> to explicitly specify what parts we want to rewrite). Any suggestions on how to proceed?</p>",
        "id": 280519173,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1651162913
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">_</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">tactic failed, there are unsolved goals</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">2 goals</span>\n<span class=\"cm\">a b : ℕ</span>\n<span class=\"cm\">⊢ 0 ≤ ?m_1 * 1 * b * (?m_1 * 1)</span>\n\n<span class=\"cm\">a b : ℕ</span>\n<span class=\"cm\">⊢ a + 1 = ?m_1 * 1</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 280520231,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651163324
    },
    {
        "content": "<p>That's nice, but somewhat too verbose. I tried to make a single tactic for <code>rw [...], swap</code>, but I'm not sure how to construct a <code>parse rw_rules</code> term:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">tactic.interactive.ch</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">texpr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">location</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">rw</span> <span class=\"n\">p</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"c1\">-- term `p` has type `parse texpr` but is expected to have type `parse rw_rules`</span>\n  <span class=\"n\">tactic.swap</span>\n</code></pre></div>",
        "id": 280534436,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1651169593
    },
    {
        "content": "<p>I would also like the tactic to handle the following case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ch</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Goals:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span>\n\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 280535936,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1651170306
    },
    {
        "content": "<p>Can you do the <code>rw</code> trick above but for <code>simp_rw</code> to solve that one?</p>",
        "id": 280537697,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651171131
    },
    {
        "content": "<p>Apparently not.</p>",
        "id": 280538397,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1651171440
    },
    {
        "content": "<p>Lean <a href=\"https://leanprover-community.github.io/archive/stream/113489-new-members/topic/rewrite.20tactic.20failed.2C.20lemma.20lhs.20is.20a.20metavariable.html#273731209\">doesn't allow you to rewrite by <code>x = x + 1</code></a>, but if you switch the sides it works, but not without a call of the <code>have</code> or <code>suffices</code> tactic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  tactic failed, there are unsolved goals</span>\n<span class=\"cm\">  state:</span>\n<span class=\"cm\">  2 goals</span>\n<span class=\"cm\">  h : ∀ (n : ℕ), n + 1 = n</span>\n<span class=\"cm\">  ⊢ ∃ (n : ℕ), n = 0</span>\n\n<span class=\"cm\">  ⊢ ∀ (n : ℕ), n + 1 = n</span>\n<span class=\"cm\">  -/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>There's also the conv mode.<br>\nIf you want to dig into tactic writing, the  metaprogramming / tactics stream would be the place to get help from.</p>",
        "id": 280558245,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651181283
    }
]
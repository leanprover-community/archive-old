[
    {
        "content": "<p>hey all, I've been studying the rules of inductive types.<br>\nin particular, I wanted to test my understanding of 2 rules, but found some unexpected things:</p>\n<p>1) recursive arguments may not be used in types of other arguments.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- this is fine.</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">t1</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">i1</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">aa</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t1</span>\n\n<span class=\"c1\">-- same as t1, but with `x` first.</span>\n<span class=\"c1\">-- why does this not work?</span>\n<span class=\"c1\">-- error: \"invalid occurrence of recursive arg#2 of 'foo_1.t2.i1', the body of the functional type depends on it.\"</span>\n<span class=\"c1\">-- this works if I remove `aa`.</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">t2</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">i1</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">aa</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t2</span>\n\n<span class=\"c1\">-- same as t1, but with something using `x`.</span>\n<span class=\"c1\">-- expected to not work, because recursive arguments may not be used.</span>\n<span class=\"c1\">-- the error however does not really suggest that to me: \"nested occurrence 'eq.{1} foo_1.t3 x' contains variables that are not parameters\" (it does not come from inductive.cpp)</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">t3</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">i1</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">aa</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">t3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xx</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t3</span>\n</code></pre></div>\n<p>2) the sort levels of the constructor arguments must be less than or equal to the sort level of the inductive type, unless it lives in Prop.<br>\nhere, I think there is a mistake in the paper:<br>\n<a href=\"/user_uploads/3121/fUeqTDD9ifx3zbJz9eDhPSnP/image.png\">image.png</a> <br>\nshouldn't that also use imax?<br>\nthis code works, but shouldn't according to my understanding of the formula:</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/fUeqTDD9ifx3zbJz9eDhPSnP/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/fUeqTDD9ifx3zbJz9eDhPSnP/image.png\"></a></div><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span>      <span class=\"n\">T0</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"kd\">def</span>      <span class=\"n\">T1</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span>\n<span class=\"kd\">def</span>      <span class=\"n\">T2</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Sort</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">t1</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">2</span>\n<span class=\"bp\">|</span> <span class=\"n\">i0</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">T0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t1</span>\n<span class=\"bp\">|</span> <span class=\"n\">i1</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">T1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t1</span>\n<span class=\"bp\">|</span> <span class=\"n\">i2</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">T2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t1</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">t2</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">i0</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">T0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t2</span>\n<span class=\"bp\">|</span> <span class=\"n\">i1</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">T1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t2</span>  <span class=\"c1\">-- these should not work,</span>\n<span class=\"bp\">|</span> <span class=\"n\">i2</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">T2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t2</span>  <span class=\"c1\">-- because not {1,2} &lt;= 0</span>\n</code></pre></div>",
        "id": 272126005,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1645023258
    },
    {
        "content": "<p>(re rule <a href=\"https://github.com/leanprover-community/mathlib/pull/2\">#2</a>): this comment from the code suggests that both rules use the same condition (with imax) to me:<br>\n\"The universe levels of arguments b and u must be smaller than or equal to l_k in I.<br>\nWhen the environment is marked as impredicative, then l_k must be 0 (Prop) or must be different from zero for any instantiation of the universe level parameters (and global level parameters).\"<br>\nthough, to be honest, I don't really understand it either: isn't \"(l_k must be 0 or must be different from zero) for any ...\" just equivalent to `true for any ...\"</p>",
        "id": 272127094,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1645023705
    },
    {
        "content": "<p>Yes, that is a typo in the paper. The actual code uses the condition <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">ℓ</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>≤</mo><mi mathvariant=\"normal\">ℓ</mi><mo>∨</mo><mi mathvariant=\"normal\">ℓ</mi><mo>≤</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\ell&#x27;\\le \\ell \\lor \\ell\\le 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879em;vertical-align:-0.136em;\"></span><span class=\"mord\"><span class=\"mord\">ℓ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">ℓ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∨</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.136em;\"></span><span class=\"mord\">ℓ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, which can be equivalently written <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><msup><mi mathvariant=\"normal\">ℓ</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">ℓ</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mi mathvariant=\"normal\">ℓ</mi></mrow><annotation encoding=\"application/x-tex\">imax(\\ell&#x27;,\\ell)\\le\\ell</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ima</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\">ℓ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">ℓ</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">ℓ</span></span></span></span></p>",
        "id": 272128238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645024260
    },
    {
        "content": "<p>We urgently need a new emoji</p>",
        "id": 272128331,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1645024298
    },
    {
        "content": "<p>The one we use when someone actually read that paper (and even finds a typo <span aria-label=\"open mouth\" class=\"emoji emoji-1f62e\" role=\"img\" title=\"open mouth\">:open_mouth:</span> )</p>",
        "id": 272128424,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1645024326
    },
    {
        "content": "<p>Regarding (1), lean has some slightly more restrictive rules for recursive arguments to the left of non-recursive arguments, likely due to historical factors (this was not originally allowed). I think the check is just buggy here.</p>\n<p>The <code>t3</code> example is triggering the nested inductive compiler, which is an additional feature supported by the lean elaborator which is not covered in the paper because nested inductives are compiled to regular inductives for consumption by the kernel. The nested inductive compiler can't handle dependencies like this, but since it's the last system to take a crack at the inductive spec you get that error instead of the one coming from the kernel.</p>",
        "id": 272129099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645024632
    },
    {
        "content": "<blockquote>\n<p>though, to be honest, I don't really understand it either: isn't \"(l_k must be 0 or must be different from zero) for any ...\" just equivalent to `true for any ...\"</p>\n</blockquote>\n<p>No. This can be expressed in the paper notation as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">ℓ</mi><mo>≤</mo><mn>0</mn><mo>∨</mo><mn>1</mn><mo>≤</mo><mi mathvariant=\"normal\">ℓ</mi></mrow><annotation encoding=\"application/x-tex\">\\ell\\le 0\\lor 1\\le \\ell</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.136em;\"></span><span class=\"mord\">ℓ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∨</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">ℓ</span></span></span></span>, and it is not unconditionally true because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">ℓ</mi></mrow><annotation encoding=\"application/x-tex\">\\ell</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">ℓ</span></span></span></span> is an expression which can contain universe variables, while the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">ℓ</mi><mo>≤</mo><msup><mi mathvariant=\"normal\">ℓ</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\ell \\le \\ell&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.136em;\"></span><span class=\"mord\">ℓ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord\">ℓ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> relation is universally closed over those variables. So an expression like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">max(u, v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span> (where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> are variables) is a counterexample, because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> is neither always 0 nor always nonzero.</p>",
        "id": 272129501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645024832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/rules.20of.20inductive.20types/near/272129099\">said</a>:</p>\n<blockquote>\n<p>The <code>t3</code> example is triggering the nested inductive compiler</p>\n</blockquote>\n<p>oh, yeah! I didn't realize that <code>eq</code> would of course be given <code>t3</code> implicitly.<br>\nI tried to \"use\" a recursive argument somehow. I guess this is why doing so is disallowed: because applying is never strictly positive? (edit: and applying is the only way I can think of using a recursive argument)</p>",
        "id": 272138122,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1645028300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/rules.20of.20inductive.20types/near/272129501\">said</a>:</p>\n<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">max(u, v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span> (where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> are variables) is a counterexample, because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> is neither always 0 nor always nonzero.</p>\n</blockquote>\n<p>I see, that's a good example!</p>",
        "id": 272138136,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1645028308
    },
    {
        "content": "<p>wow, this is the clearest explanation i've found so far, props to whoever wrote it: <a href=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#axiomatic-details\">https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#axiomatic-details</a></p>",
        "id": 272140198,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1645029177
    }
]
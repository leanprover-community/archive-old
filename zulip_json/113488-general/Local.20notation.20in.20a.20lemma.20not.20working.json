[
    {
        "content": "<p>Could anyone tell me why this doesn't work?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">op_comm</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kn\">infix</span> <span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 204060364,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1594890208
    },
    {
        "content": "<p>It fails because it cannot find <code>has_mul T</code>, but my hope was it would use the local infix instead.</p>",
        "id": 204060435,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1594890245
    },
    {
        "content": "<p>I've never seen local notation introduced in a lemma like this before. I think it's out of scope to the right of the <code>:</code> already.</p>",
        "id": 204060688,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1594890463
    },
    {
        "content": "<p>I'm looking at this and there seem to be 3 problems:</p>",
        "id": 204061002,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594890712
    },
    {
        "content": "<ol>\n<li><code>op</code> should be <code>op : T → T → T</code></li>\n<li><code>*</code> will refer to the global <code>has_mul</code> and might not have been shadowed by the local one, to rule out this factor, better try another unicode</li>\n<li>when 1&amp;2 is fixed, Lean seems to be confused by the syntax and give another error</li>\n</ol>",
        "id": 204061226,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594890899
    },
    {
        "content": "<p>Nice catch</p>",
        "id": 204061370,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1594891013
    },
    {
        "content": "<p>Lean is happy with</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">op_comm</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span>  <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"kn\">infix</span> <span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 204061389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1594891033
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">op_comm</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kn\">infix</span> <span class=\"bp\">⬝</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"bp\">⬝</span> <span class=\"n\">b</span> <span class=\"bp\">⬝</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">⬝</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">⬝</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>gives</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"n\">goal</span>\n<span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n<span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span>\n<span class=\"err\">⊢</span> <span class=\"err\">⁇</span>\n\n<span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">invalid</span> <span class=\"kn\">definition</span><span class=\"o\">,</span> <span class=\"err\">&#39;</span><span class=\"bp\">|</span><span class=\"err\">&#39;</span> <span class=\"n\">or</span> <span class=\"err\">&#39;</span><span class=\"o\">:=</span><span class=\"err\">&#39;</span> <span class=\"n\">expected</span>\n<span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">type</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"n\">a</span>\n<span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">T</span>\n<span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">command</span> <span class=\"n\">expected</span>\n</code></pre></div>",
        "id": 204061392,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594891036
    },
    {
        "content": "<p>It would be nice if I could push <code>op</code> back to the LHS of the colon, but this syntax isn't valid:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">op_comm</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"kn\">infix</span> <span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>Is there a way to create a binder of no variables, as I attempt to do here?</p>",
        "id": 204061538,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1594891166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Local.20notation.20in.20a.20lemma.20not.20working/near/204061389\">said</a>:</p>\n<blockquote>\n<p>Lean is happy with</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">op_comm</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span>  <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"kn\">infix</span> <span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n</blockquote>\n<p>Oh, something might not survive moving from the right side of <code>:</code>/<code>∀</code> to the left side</p>",
        "id": 204061545,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594891178
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">op_comm</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>  <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kn\">infix</span> <span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>The above works. It seems that Lean need something that's not a definition to be after <code>∀</code> and it makes sense since without that, Lean can't form a pi type here.</p>",
        "id": 204064140,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594893110
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">op_comm</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kn\">infix</span> <span class=\"bp\">⬝</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">T : Type,</span>\n<span class=\"cm\">a b c : T,</span>\n<span class=\"cm\">op : T → T → T,</span>\n<span class=\"cm\">n : opt_param ℕ 1</span>\n<span class=\"cm\">⊢ a = a</span>\n\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 204066059,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594894592
    },
    {
        "content": "<p>The case above reveal the truth. Lean parser accepts such syntax for specifying optional parameter, but semantically it didn't register the infix under such syntax.</p>",
        "id": 204066137,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594894681
    },
    {
        "content": "<p>This would be even more obvious in the following example:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">reserve</span> <span class=\"kn\">infix</span> <span class=\"bp\">⬝</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">a</span> <span class=\"bp\">⬝</span> <span class=\"n\">b</span> <span class=\"c1\">-- Lean chokes as \\cdot is not defined</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">op_comm</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kn\">infix</span> <span class=\"bp\">⬝</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">a</span> <span class=\"bp\">⬝</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">⬝</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"c1\">-- Lean chokes with the same error message</span>\n</code></pre></div>",
        "id": 204066363,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594894833
    },
    {
        "content": "<p><code>infix</code> binders are primarily used for structures. I've never seen them used in lemmas or in foralls</p>",
        "id": 204066443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594894912
    },
    {
        "content": "<p>I suspect this is an accident of the grammar</p>",
        "id": 204066501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594894939
    },
    {
        "content": "<p>In forall, it works:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">op_comm</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span>  <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"kn\">infix</span> <span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">T : Type,</span>\n<span class=\"cm\">a b c : T</span>\n<span class=\"cm\">⊢ ∀ (op : T → T → T), op (op a b) c = op a (op b c)</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 204066530,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594894958
    },
    {
        "content": "<p>They have no actual impact on the shape of the term, they are not really foralls at all</p>",
        "id": 204066544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594894970
    },
    {
        "content": "<p>plus lean doesn't even really have a concept of locally scoped notations, and the implementation here is kind of a hack</p>",
        "id": 204066668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895050
    },
    {
        "content": "<p>It may be just an unintentional side effect of some Lean C++ code for the one in forall to work while lhs of <code>:</code> doesn't</p>",
        "id": 204066673,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594895056
    },
    {
        "content": "<p>I'm curious to see what <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> thinks about these sort of local local notations</p>",
        "id": 204066767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895153
    },
    {
        "content": "<p>I can push all the binders out of the forall with a dummy unit argument:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">op_comm</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"bp\">_</span> <span class=\"o\">:</span> <span class=\"n\">unit</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"kn\">infix</span> <span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">op</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>which feels like a nasty hack</p>",
        "id": 204066833,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1594895186
    },
    {
        "content": "<p>It seems to be the same mechanism why the following works:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"n\">class</span> <span class=\"n\">functor&#39;&#39;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"kn\">infixr</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"o\">:=</span> <span class=\"n\">map</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>(from <a href=\"https://github.com/leanprover/lean/wiki/Refactoring-structures#other-goodies\">https://github.com/leanprover/lean/wiki/Refactoring-structures#other-goodies</a> ) </p>\n<p>Lean seems to be able to pick the notation up in general.</p>",
        "id": 204066885,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594895247
    },
    {
        "content": "<p>yes, that's what I mean</p>",
        "id": 204067044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895356
    },
    {
        "content": "<p>That's just a \"binder sequence\", and binder sequences appear elsewhere in the grammar as well</p>",
        "id": 204067067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895379
    },
    {
        "content": "<p>Yeah, I saw the notation for classes and wondered if I could get away with it for lemmas</p>",
        "id": 204067078,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1594895389
    },
    {
        "content": "<p>Is there such a thing as an empty binder sequence in the grammar?</p>",
        "id": 204067146,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1594895414
    },
    {
        "content": "<p>Not directly. You can't write <code>\\forall, 2 = 2</code> for example</p>",
        "id": 204067177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895451
    },
    {
        "content": "<p>But you can write structures with no fields</p>",
        "id": 204067198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895478
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">unit&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">mk</span>\n<span class=\"kn\">structure</span> <span class=\"n\">unit&#39;&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">mk</span> <span class=\"bp\">::</span>\n</code></pre></div>",
        "id": 204067307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895571
    },
    {
        "content": "<p>you would think that <code>structure unit''' := </code> or <code>structure unit''' := .</code> or <code>structure unit'''.</code> would work but no</p>",
        "id": 204067344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895618
    },
    {
        "content": "<p>bizarrely, <code>structure unit'''' (x : ℕ)</code> <em>does</em> work</p>",
        "id": 204067445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895684
    },
    {
        "content": "<p>which means that</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">unit&#39;&#39;&#39;&#39;</span> <span class=\"o\">(</span><span class=\"kn\">infix</span> <span class=\"bp\">`*`</span> <span class=\"o\">:=</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>also works</p>",
        "id": 204067512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895740
    },
    {
        "content": "<p>These are all interesting parsing edge cases that may or may not survive when Lean 4 comes.</p>",
        "id": 204067525,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594895756
    },
    {
        "content": "<p>I sure hope they die</p>",
        "id": 204067571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895772
    },
    {
        "content": "<p>But it's interesting to read the related C++ code</p>",
        "id": 204067583,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594895781
    },
    {
        "content": "<p>I can tell it's a ball of hacks and I don't even need to read the code</p>",
        "id": 204067605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/113488-general/topic/Local.20notation.20in.20a.20lemma.20not.20working/near/204066885\">said</a>:</p>\n<blockquote>\n<p>It seems to be the same mechanism why the following works:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"n\">class</span> <span class=\"n\">functor&#39;&#39;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"kn\">infixr</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"o\">:=</span> <span class=\"n\">map</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>(from <a href=\"https://github.com/leanprover/lean/wiki/Refactoring-structures#other-goodies\">https://github.com/leanprover/lean/wiki/Refactoring-structures#other-goodies</a> ) </p>\n<p>Lean seems to be able to pick the notation up in general.</p>\n</blockquote>\n<p>But I do wish this one to survive</p>",
        "id": 204067655,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594895862
    },
    {
        "content": "<p>It's very useful</p>",
        "id": 204067705,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594895884
    },
    {
        "content": "<p>I would prefer to see it replaced by a proper notation scoping system</p>",
        "id": 204067713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895888
    },
    {
        "content": "<p>Otherwise, I don't know how to express this: <a href=\"#narrow/stream/113488-general/topic/unbundled.20v.2Es.2E.20%28semi-%29bundled/near/204051388\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unbundled.20v.2Es.2E.20%28semi-%29bundled/near/204051388</a></p>",
        "id": 204067748,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594895922
    },
    {
        "content": "<p>fields with <code>:=</code> are nothing special</p>",
        "id": 204067784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895965
    },
    {
        "content": "<p>those are just sugar for <code>opt_param</code></p>",
        "id": 204067798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594895975
    },
    {
        "content": "<p>What's the un-sugared syntax, and where can I read about it?</p>",
        "id": 204067939,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1594896094
    },
    {
        "content": "<p>Unable to define notations in the process of defining a new structure/class, will make me break a structure/class into a few classes, with notations defined between them.</p>",
        "id": 204067947,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594896102
    },
    {
        "content": "<p>Or I can't use notations to express Props using the operations defined for the class</p>",
        "id": 204068037,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594896171
    },
    {
        "content": "<p><code>(x : A := a)</code> is sugar for <code>(x : opt_param A a)</code></p>",
        "id": 204068148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594896255
    },
    {
        "content": "<p>note that <code>opt_param A a</code> is defeq to <code>A</code> so this doesn't cause any typing problems, but the tag is used by lean as an elaboration hint</p>",
        "id": 204068187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594896300
    },
    {
        "content": "<p>Think</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"n\">class</span> <span class=\"n\">semigroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"kn\">infix</span> <span class=\"bp\">⬝</span> <span class=\"o\">:=</span> <span class=\"n\">mul</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">⬝</span> <span class=\"n\">b</span> <span class=\"bp\">⬝</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">⬝</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">⬝</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>for more complicated cases.</p>",
        "id": 204068234,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594896347
    },
    {
        "content": "<p>I don't object to notations local to a structure at all (although I think that the gain is largely illusory since it doesn't survive parsing)</p>",
        "id": 204068326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594896419
    },
    {
        "content": "<p>I think that it should be part of an actual scoping system though</p>",
        "id": 204068362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594896444
    },
    {
        "content": "<p>rather than just something specific to binder sequences</p>",
        "id": 204068373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594896460
    },
    {
        "content": "<p>like there should be a <code>let infix</code> term constructor</p>",
        "id": 204068440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594896485
    },
    {
        "content": "<blockquote>\n<p>it doesn't survive parsing</p>\n</blockquote>\n<p>Oh, that's true. I was already using the break-into-a-few-classes-and-define-notations-in-between way before I learned the existence of such a syntax. So I didn't notice it.</p>",
        "id": 204068486,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594896536
    },
    {
        "content": "<p>if you just write one mega structure with 50 fields and several notation-worthy fields, and don't try to prove anything about the structure, then you will think this trick is great</p>",
        "id": 204068626,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594896625
    },
    {
        "content": "<p>but once you try to inhabit the structure you will find it isn't very easy to work with the resulting structure definition</p>",
        "id": 204068649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594896656
    },
    {
        "content": "<p>Yes, for one, I noticed I still have to add</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"err\">ᵣ</span><span class=\"bp\">_</span><span class=\"n\">defeq</span><span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"err\">ᵣ</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>even after I have</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"err\">ᵣ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 204068893,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594896854
    },
    {
        "content": "<p>because the equality implied by <code>:=</code> is only optional</p>",
        "id": 204068967,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594896928
    },
    {
        "content": "<p>yep, the <code>:=</code> is just a guideline</p>",
        "id": 204068986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594896948
    },
    {
        "content": "<p>it would be nice if structures actually supported let binders in the constructor. I think Coq does</p>",
        "id": 204069087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594897008
    },
    {
        "content": "<p>Do you want <code>(notation `fᵣ`  := (algebra_map R G : R →+* G))</code>?</p>",
        "id": 204070096,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1594897809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Local.20notation.20in.20a.20lemma.20not.20working/near/204068440\">said</a>:</p>\n<blockquote>\n<p>like there should be a <code>let infix</code> term constructor</p>\n</blockquote>\n<p>But there is.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"k\">let</span> <span class=\"kn\">infix</span> <span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"k\">in</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span>\n</code></pre></div>\n\n\n<p>Don't get too attached to it, however; since no-one has ever used - or apparently needed - it as far as we know, we will drop that one in Lean 4 since it complicates hygiene quite a bit. I think the introduction of proper namespace-scoped notations should more than offset that.</p>",
        "id": 204093787,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1594910926
    },
    {
        "content": "<p>I've found that syntax quite useful for introducing notation in a recursive definition like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">reserve</span> <span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"err\">⋏</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">70</span>\n<span class=\"n\">def</span> <span class=\"n\">wedge</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">Gₙ</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Gₙ</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Gₙ</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">⟨</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">y₁</span><span class=\"o\">,</span> <span class=\"n\">y₂</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"err\">⋏</span> <span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">wedge</span> <span class=\"k\">in</span>\n    <span class=\"o\">(</span><span class=\"n\">x₂</span> <span class=\"err\">⋏</span> <span class=\"n\">y₂</span><span class=\"o\">,</span> <span class=\"n\">x₁</span> <span class=\"err\">⋏</span> <span class=\"n\">y₂</span> <span class=\"bp\">+</span> <span class=\"n\">x₂</span> <span class=\"err\">⋏</span> <span class=\"err\">̅</span><span class=\"n\">y₁</span><span class=\"err\">ᵈ</span><span class=\"o\">)</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"err\">⋏</span> <span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">wedge</span>\n</code></pre></div>\n\n\n<p>It still feels clumsy, but it would be great if whatever replaces <code>let infix</code> enables a similar approach</p>",
        "id": 205577830,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1596191900
    },
    {
        "content": "<p>What about declaring <code>has_wedge.wedge</code> first, then notation, then make an instance and implement wedge in it? This way would survive Lean 4 and the storyline is still clear?</p>",
        "id": 205580136,
        "sender_full_name": "Utensil Song",
        "timestamp": 1596194185
    },
    {
        "content": "<p>That issue is quite similar to the common pattern of declaring a structure/class with a notation, which is a bit awkward as well (having to redeclare the notation outside). I'd like to improve that one in Lean 4, so it would make sense to find a general solution that also works for <code>def</code> etc.</p>",
        "id": 205580798,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1596194831
    },
    {
        "content": "<p>Ah, my idea doesn't seem to work, Lean doesn't accept equation compiler in structure (not an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> , a sketch of the syntax idea):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- multivectors</span>\n<span class=\"n\">def</span> <span class=\"n\">Gₙ</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Gₙ</span> <span class=\"n\">n</span> <span class=\"bp\">×</span> <span class=\"n\">Gₙ</span> <span class=\"n\">n</span>\n\n<span class=\"n\">class</span> <span class=\"n\">has_wedge</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">wedge</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"n\">class</span> <span class=\"n\">has_vee</span>   <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">vee</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"err\">⋏</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"o\">:=</span> <span class=\"n\">has_wedge</span><span class=\"bp\">.</span><span class=\"n\">wedge</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"err\">⋎</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"o\">:=</span> <span class=\"n\">has_vee</span><span class=\"bp\">.</span><span class=\"n\">vee</span>\n\n<span class=\"n\">class</span> <span class=\"n\">has_ga_ops</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">has_wedge</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_vee</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">ga_ops</span> <span class=\"o\">:</span> <span class=\"n\">has_ga_ops</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"n\">Gₙ</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">wedge</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">⟨</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">y₁</span><span class=\"o\">,</span> <span class=\"n\">y₂</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x₂</span> <span class=\"err\">⋏</span> <span class=\"n\">y₂</span><span class=\"o\">,</span> <span class=\"n\">x₁</span> <span class=\"err\">⋏</span> <span class=\"n\">y₂</span> <span class=\"bp\">+</span> <span class=\"n\">x₂</span> <span class=\"err\">⋏</span> <span class=\"err\">̅</span><span class=\"n\">y₁</span><span class=\"err\">ᵈ</span><span class=\"o\">),</span>\n    <span class=\"n\">vee</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">⟨</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">y₁</span><span class=\"o\">,</span> <span class=\"n\">y₂</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span>  <span class=\"o\">(</span><span class=\"n\">x₁</span> <span class=\"err\">⋎</span> <span class=\"n\">y₂</span> <span class=\"bp\">+</span> <span class=\"err\">̅</span><span class=\"n\">x₂</span> <span class=\"err\">⋎</span> <span class=\"n\">y₁</span><span class=\"o\">,</span> <span class=\"n\">x₂</span> <span class=\"err\">⋎</span> <span class=\"n\">y₂</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 205581735,
        "sender_full_name": "Utensil Song",
        "timestamp": 1596195736
    },
    {
        "content": "<p>oh wow that seems really hard to support</p>",
        "id": 205581889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596195910
    },
    {
        "content": "<p>Is the solution to allow forward declarations? If I could forward declare <code>def wedge : the_type := by patience</code>, I could then associate a notation with it, and then fill out the definition later. Of course, this is still difficult in the equation compiler, where the local <code>wedge</code> isn't quite the global one.</p>",
        "id": 205582498,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1596196516
    },
    {
        "content": "<p>It really should be</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">mutual</span>\n  <span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"err\">⋏</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">wedge</span>\n  <span class=\"n\">def</span> <span class=\"n\">wedge</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">_</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Gₙ</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Gₙ</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Gₙ</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">y₁</span><span class=\"o\">,</span> <span class=\"n\">y₂</span><span class=\"bp\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x₂</span> <span class=\"err\">⋏</span> <span class=\"n\">y₂</span><span class=\"o\">,</span> <span class=\"n\">x₁</span> <span class=\"err\">⋏</span> <span class=\"n\">y₂</span> <span class=\"bp\">+</span> <span class=\"n\">x₂</span> <span class=\"err\">⋏</span> <span class=\"err\">̅</span><span class=\"n\">y₁</span><span class=\"err\">ᵈ</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Just have to implement that somehow...</p>",
        "id": 205582584,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1596196580
    },
    {
        "content": "<p>The current syntax would make that more like the following, wouldn't it?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">mutual</span> <span class=\"n\">def</span> <span class=\"n\">wedge</span><span class=\"o\">,</span> <span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"err\">⋏</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">70</span>\n<span class=\"k\">with</span>  <span class=\"bp\">`</span> <span class=\"err\">⋏</span> <span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">wedge</span>\n<span class=\"k\">with</span> <span class=\"n\">wedge</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">_</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Gₙ</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Gₙ</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Gₙ</span> <span class=\"n\">α</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">x₁</span><span class=\"o\">,</span> <span class=\"n\">x₂</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">y₁</span><span class=\"o\">,</span> <span class=\"n\">y₂</span><span class=\"bp\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x₂</span> <span class=\"err\">⋏</span> <span class=\"n\">y₂</span><span class=\"o\">,</span> <span class=\"n\">x₁</span> <span class=\"err\">⋏</span> <span class=\"n\">y₂</span> <span class=\"bp\">+</span> <span class=\"n\">x₂</span> <span class=\"err\">⋏</span> <span class=\"err\">̅</span><span class=\"n\">y₁</span><span class=\"err\">ᵈ</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 205582977,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1596196919
    },
    {
        "content": "<p>Well, I only know that I won't implement that one!</p>",
        "id": 205583064,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1596196985
    },
    {
        "content": "<p><code>mutual ... end</code> certainly seems a lot nicer!</p>",
        "id": 205583971,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1596197842
    }
]
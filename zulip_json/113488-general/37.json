[
    {
        "content": "<p>I am proud to have inserted what is as far as I know the first 37 in mathlib, put there at request of the inhabited linter. Nobody cared. Similarly 1/0 to a mathematician is just junk. The computer scientists insist on returning a value such as 0 simply because it is more convenient computationally.<br>\nCould one define a mathematician's division on the reals or more generally any field in the following way : <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mi mathvariant=\"normal\">/</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x/y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> in maths node is what we both agree on for y nonzero, and for y=0 it is a value called <code>junk</code>, a term which is a default value of every type? Am I working in some junk monad or something? We could recover mathematically correct natural subtraction this way. Is <code>omega</code> easier to write for mathematician's subtraction? We promise this question isn't junk, now let <code>ring</code> solve <code>a-b+b=a</code> because omega is buggy (note to self: add link to Rob issue). Turns out mathematicians might be happy to enter <code>a&lt;=b</code> into the typeclass system. </p>\n<p>Mathematicians can't understand why a-b+b=a on nat is not done by <code>ring</code>.</p>",
        "id": 202211440,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593303470
    },
    {
        "content": "<p>I think you're just talking about the Maybe / option monad</p>",
        "id": 202211502,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593303579
    },
    {
        "content": "<p>The specific proposal is slightly different than option. In optional division, a / b = None if and only if b = 0.  In junk division, a / b = junk if b = 0 or b * junk = a since junk is a number.  As I see it junk division has the advantage also that you don’t have to constantly use monadic operations to get the result from inside the monad.  But it has some of the same disadvantages as the current division, with slightly less downsides since you can’t use the fact that 1/0 = 0 (but you can still use the fact that 1/0 is some arbitrary real number).</p>",
        "id": 202214373,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593308901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202214373\">said</a>:</p>\n<blockquote>\n<p>The specific proposal is slightly different than option. In optional division, a / b = None if and only if b = 0.  In junk division, a / b = junk if b = 0 or b * junk = a since junk is a number.  As I see it junk division has the advantage also that you don’t have to constantly use monadic operations to get the result from inside the monad.  But it has some of the same disadvantages as the current division, with slightly less downsides since you can’t use the fact that 1/0 = 0 (but you can still use the fact that 1/0 is some arbitrary real number).</p>\n</blockquote>\n<p>In optional division we should have <code>a / b = None</code> when <code>a = None</code> as well, which matches your description of junk division -- though I suppose this depends on how exactly we're defining optional division</p>",
        "id": 202214482,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593309091
    },
    {
        "content": "<p>I assume it was</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">divOpt</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">real</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">none</span> <span class=\"k\">else</span> <span class=\"n\">a</span><span class=\"bp\">/</span><span class=\"n\">b</span>\n</code></pre></div>\n\n\n<p>where a/b is the current division.  In your proposal, you are adding an additional element to the reals.</p>",
        "id": 202214621,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593309325
    },
    {
        "content": "<p>Right, I think this is what Kevin was talking about though - a default value of every type</p>",
        "id": 202214694,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593309435
    },
    {
        "content": "<p>I think he wants that default value to still be an element of the type, but you can't prove what it is.  (And to be clear, I assume we are only talking about inhabited types. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> )</p>",
        "id": 202214739,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593309517
    },
    {
        "content": "<p>Actually, I read it again. Maybe that is what he meant.</p>",
        "id": 202214836,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593309684
    },
    {
        "content": "<p>In Scala, types can can be subtypes of other types.  One interesting consequence is that the error type is a subtype all all types.  So you can write, something like <code>if b = 0 then error else a/b</code>, but of course Scala isn't a theorem prover and if one isn't careful you can easily break consistency here. I assume one would have a real difficult time making a division using any method that is both (1) easy to use and (2) doesn't allow you to prove some <br>\n\"false theorem\", like <code>exists a: real, 1 / a = a</code>.</p>",
        "id": 202215116,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593310179
    },
    {
        "content": "<p>I think with Lean's hidden coercions though (especially into <code>option</code>) we can mimic Scala's subtyping - or at least be able to divide nicely - while remaining within the option monad</p>",
        "id": 202215171,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593310254
    },
    {
        "content": "<p>I wonder if instead, one defined division with an implicit or type class assumption {h : b ne 0} or [h : b ne 0].  So if one writes <code>a/b</code> they have to have in the context that <code>b != 0</code>.  I also, haven't thought this through though.</p>",
        "id": 202215303,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593310452
    },
    {
        "content": "<p>I think this idea has come up a bunch of times, my recollection was that it's nice in theory but awkward in practice</p>",
        "id": 202215316,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593310491
    },
    {
        "content": "<p>I think you idea would be the same, no. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 202215330,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593310519
    },
    {
        "content": "<p>I don't immediately see why</p>",
        "id": 202215333,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593310540
    },
    {
        "content": "<p>Well consider the theorem if a/a = a then a = 1.  Is this true in this optional reals?  I don't think so, unless we change the meaning of quantifiers.</p>",
        "id": 202215384,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593310601
    },
    {
        "content": "<p>Also, I imagine a coersion from <code>some n</code> to <code>n</code> say causing a number of small difficulties.  Does <code>foo (x/y)</code> even type check if <code>foo : real -&gt; real</code> and <code>y = None</code>?</p>",
        "id": 202215481,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593310800
    },
    {
        "content": "<p>No, the coercion is the other way</p>",
        "id": 202215654,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593311061
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n<span class=\"n\">def</span> <span class=\"n\">optional_div</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">option</span> <span class=\"n\">ℝ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">none</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">optional_div</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">ite</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">split_ifs</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">injection</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">div_self</span> <span class=\"n\">h</span> <span class=\"n\">at</span> <span class=\"n\">h_1</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h_1</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">injection</span> <span class=\"n\">hx</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 202215662,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593311091
    },
    {
        "content": "<p>I don't actually know Lean's option API very well so it could well be possible to improve this, but I hope it illustrates what I mean</p>",
        "id": 202215669,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593311122
    },
    {
        "content": "<p>I don't see how the difficulties which come with typeclass/implicit parameters transfer to this, but I don't for a second doubt that there could be other difficulties</p>",
        "id": 202215708,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593311186
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> There is a field-like algebraic structure called a \"meadow\" with division-by-zero, and one variant of meadows literally defines <code>1 / 0 = junk</code> as you suggested, and otherwise coincides with the field division operator. They are discussed here for example: <a href=\"https://arxiv.org/abs/1406.6878v3\">https://arxiv.org/abs/1406.6878v3</a> (The paper uses the name <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">a</mi></mrow><annotation encoding=\"application/x-tex\">\\bold{a}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">a</span></span></span></span></span> for <code>junk</code>.)</p>",
        "id": 202215734,
        "sender_full_name": "Scott Olson",
        "timestamp": 1593311253
    },
    {
        "content": "<p>I'm curious how far you could get defining everything in terms of meadows and then showing field-specific theorems under the hypothesis <code>denom ≠ 0</code> (just as you do now with <code>1 / 0 = 0</code> or <code>1 / 0 = 37</code>). The upside is that there's also a sensible algebraic theory for <code>1 / 0 = junk</code>, it's just not fields.</p>",
        "id": 202215795,
        "sender_full_name": "Scott Olson",
        "timestamp": 1593311345
    },
    {
        "content": "<p>Incidentally there's also a version of meadows with <code>1 / 0 = 0</code>, but the authors of this paper at least seem to prefer the other version.</p>",
        "id": 202215854,
        "sender_full_name": "Scott Olson",
        "timestamp": 1593311456
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> That is interesting!</p>",
        "id": 202216027,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593311777
    },
    {
        "content": "<p>Another option would be to use the powerset monad instead of the Maybe monad, and define x/0 to be everything.</p>",
        "id": 202216356,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1593312438
    },
    {
        "content": "<p>That's an interesting idea! Maybe we could get a theory of multivalued functions too then</p>",
        "id": 202216403,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593312523
    },
    {
        "content": "<p>Algebra has things called \"hyperstructures\" where operations take values in sets</p>",
        "id": 202216412,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1593312552
    },
    {
        "content": "<p>So it's not that crazy of an idea :)</p>",
        "id": 202216414,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1593312562
    },
    {
        "content": "<p>Fair, I just hadn't heard of hyperstructures, nor thought of applying nondeterminism monads to Lean</p>",
        "id": 202216420,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593312597
    },
    {
        "content": "<p>You can do this with any monad actually, just work internally in the Kleisli category</p>",
        "id": 202216465,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1593312621
    },
    {
        "content": "<p>I'm not sure we want to be in the Kleisli category here though, it seems more natural to me to define operations on <code>T ℝ</code> and have the monad's unit as an implicit coercion</p>",
        "id": 202216487,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593312720
    },
    {
        "content": "<p>I agree.. you want to quantify over terms in the original type. The maps are taken in the Kleisli category though.</p>",
        "id": 202216530,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1593312783
    },
    {
        "content": "<p>I think this is essentially what you were suggesting with the Maybe monad, right?</p>",
        "id": 202216542,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1593312823
    },
    {
        "content": "<p>Currently the following doesn't type check:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">add</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">optional_div</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>But I assume that is just because there aren't enough coercion rules.</p>",
        "id": 202216933,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593313604
    },
    {
        "content": "<p>Also the same with <code>+</code> in place of <code>add</code> but that is because <code>option ℝ</code> doesn't have <code>has_add</code>.  I think you want to make this work without the user noticing this, you would have to go through every type class and extend it to <code>option alpha</code> if appropriate (or find a way to do it automatically, like Scala's implicit macros).</p>",
        "id": 202216943,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593313643
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">defs</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n\n<span class=\"n\">def</span> <span class=\"n\">ℝ&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">option</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℝ&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">some</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">ℝ&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">ℝ&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_inv</span> <span class=\"n\">ℝ&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">bind</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"n\">none</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_div</span> <span class=\"n\">ℝ&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"bp\">⁻¹⟩</span>\n</code></pre></div>\n\n\n<p>This is an option</p>",
        "id": 202216989,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593313720
    },
    {
        "content": "<p>It needs a bunch of lemmas to be generated to make it possible to prove things</p>",
        "id": 202216998,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593313764
    },
    {
        "content": "<p>You would have to do it for other types too, since <code>(floor r/r) + 1</code> where <code>floor : real -&gt; nat</code> would now return an <code>option nat</code>.  Basically, anything that touches a partial function becomes an option.</p>",
        "id": 202217067,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593313888
    },
    {
        "content": "<p>Right, because junk is a value of any type</p>",
        "id": 202217132,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593313998
    },
    {
        "content": "<p>So we aren't just making a new reals, we are making a new type theory.</p>",
        "id": 202217253,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593314201
    },
    {
        "content": "<p>We're adding a new layer on the existing type theory</p>",
        "id": 202217257,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593314222
    },
    {
        "content": "<p>I'm not arguing this is a good idea, just that it's one implementation of what I interpret Kevin wants</p>",
        "id": 202217262,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593314242
    },
    {
        "content": "<p>I think it is the best proposal so far probably.  (Except for replacing 1/0 = 0 with some arbitrary real number that we can't prove what it is.)</p>",
        "id": 202217312,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593314330
    },
    {
        "content": "<p>I guess I was surprised that it works as well as it does.  The only issue is the fact that it has to propagate through much of Lean means that one would have to adjust a bunch of stuff to make the coercions seamless.</p>",
        "id": 202217606,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593314992
    },
    {
        "content": "<p>I wonder what will come first? <span aria-label=\"smile\" class=\"emoji emoji-263a\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<ol>\n<li>Proper partial functions in theorem provers which are easy to work with and are natural to mathematicians.</li>\n<li>AI which formalizes mathematics for us.</li>\n</ol>\n<p>I would have guessed the former, but this division issue has been around for a long time...</p>",
        "id": 202218102,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593315972
    },
    {
        "content": "<p>I'd be curious how this partial function problem manifests itself in measure and probably theory.  In both, there is a reoccurring assumption of having measurable functions.  However, no mathematician is going to write that assumption on every line of a proof.  (Actually, one might argue that there is a lot that probabilists don't write down in their proofs.)  I think Lean's current solution for chaining together \"measurable\" functions is a Giry monad.  However the Giry monad can't be implemented purely in Lean (since not all Lean functions are measurable), only a non-lawful approximation of it.  In particular, just like division, if a function is not measurable, the result is something trivial.  The zero measure I think.  I'm curious how easy this would be to work.  Much of probability theory is just chaining together calculations, but if at every step of the calculation, one has to prove that the resulting term is still measurable (and not degenerate), that would be quite painful.  Have we found a working solution in that setting?</p>",
        "id": 202218890,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593317821
    },
    {
        "content": "<p>(Or maybe this isn't as painful as I imagine.  I still hold out hope that someone can formalize martingales and finally formally prove the strong law of large numbers via the martingale proof.)</p>",
        "id": 202218943,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593317933
    },
    {
        "content": "<p>This approach is what is used in the HOLs by the way</p>",
        "id": 202220703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593321781
    },
    {
        "content": "<p>Could I just say that having 0^-1 = 0 allows for some simpler lemmas</p>",
        "id": 202220715,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593321820
    },
    {
        "content": "<p>there is a hilbert epsilon operator on every type, so you can just use <code>epsilon (\\lam x, false)</code> as a random value in whatever type</p>",
        "id": 202220717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593321833
    },
    {
        "content": "<p><code>epsilon (\\lam x, true)</code>  also works</p>",
        "id": 202220754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593321847
    },
    {
        "content": "<p>But it's a big problem in dependent type theory because not all types are inhabited</p>",
        "id": 202220758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593321866
    },
    {
        "content": "<p>(and consistency depends on this)</p>",
        "id": 202220761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593321881
    },
    {
        "content": "<p>I think it is kind of ridiculous to compare this to general AI (and I get it's hyperbole, but still). This is entirely a problem of our own making, it doesn't even slightly generalize to other approaches to theorem proving</p>",
        "id": 202220825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593322025
    },
    {
        "content": "<p>The Giry monad thing is also a very lean problem</p>",
        "id": 202220829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593322045
    },
    {
        "content": "<p>You can certainly have a notation for lawful bind</p>",
        "id": 202220839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593322068
    },
    {
        "content": "<p>just not using do notation as currently implemented</p>",
        "id": 202220877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593322085
    },
    {
        "content": "<p>There were already a few occurrences of 37 in mathlib :) <a href=\"https://github.com/leanprover-community/mathlib/search?q=37&amp;unscoped_q=37\">https://github.com/leanprover-community/mathlib/search?q=37&amp;unscoped_q=37</a><br>\nAlso, mathlib currently has exactly 37 watchers :P</p>",
        "id": 202221008,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593322400
    },
    {
        "content": "<p>I see that <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> has learnt well from <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span></p>",
        "id": 202221053,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593322493
    },
    {
        "content": "<p>hrm, I'd rather see <code>arbitrary _</code> used for that</p>",
        "id": 202221233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593322854
    },
    {
        "content": "<p>I'm curious about how mathematicians view expressions like <code>x / y</code> where <code>y</code> could be zero.  Let's say I ask Lean to prove a theorem like <code>forall (x y :Nat), x / y &lt;= x</code> whose validity depends on the meaning of <code>x / 0</code>.   Is it important to mathematicians that one cannot prove this proposition in Lean?<br>\nI'm personally agnostic to this.  I'd often rather have a simpler total logic that sometimes let me prove nonsense theorems.<br>\nSomewhat related, the first theorem prover I used, ACL2,  used an untyped logic solved this by having a notion of \"guards\" that defiend the partial domains of functions.  In normal usage, there were all sorts of nonsense theorems that were true like <code>0/0 = 0</code>, but if you really cared, you could validate all the guards were satisfied.</p>",
        "id": 202221745,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1593323769
    },
    {
        "content": "<p>in lean 4, some functions return <code>arbitrary a</code> in edge cases. but <code>arbitrary</code> is defined as a constant, which is essentially a definition without delta reduction in lean 4 (as opposed to an axiom). i think if there is no delta reduction you won't be able to unfold the definition and prove it to be equal to some value?</p>\n<p>aside from this and the other things mentioned, one possible solution would be to have a proper multi-valued logic with junk values that propagate through all expressions.</p>",
        "id": 202226706,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593333438
    },
    {
        "content": "<p>and what is <code>arbitrary empty</code> in Lean 4?</p>",
        "id": 202226720,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593333474
    },
    {
        "content": "<p>but that comes with its own bag of problems, e.g. now you need a weak negation etc</p>",
        "id": 202226757,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593333490
    },
    {
        "content": "<p>arbitrary is still just Inhabited.default</p>",
        "id": 202226760,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593333511
    },
    {
        "content": "<p>constants work differently in lean 4</p>",
        "id": 202226778,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593333549
    },
    {
        "content": "<p>so it's like an <code>irreducible</code> version of <code>default</code></p>",
        "id": 202226783,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593333568
    },
    {
        "content": "<p>do irreducibles have delta reduction?</p>",
        "id": 202226786,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593333592
    },
    {
        "content": "<p>i always thought irreducible only affects elaboration, not type checking (but i never used it much in my own work)</p>",
        "id": 202226892,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593333734
    },
    {
        "content": "<p>Note that <code>arbitrary A</code> already exists in lean 3, and it is just an irreducible version of <code>default</code></p>",
        "id": 202227683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593335276
    },
    {
        "content": "<p>irreducibles have delta reduction but only in the kernel, which means that you have to circumvent the elaborator if you want to use it in a proof</p>",
        "id": 202227727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593335321
    },
    {
        "content": "<p><code>constant</code>s in lean 4 don't even have delta reduction in the kernel</p>",
        "id": 202227737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593335354
    },
    {
        "content": "<p>and they do in lean 3?</p>",
        "id": 202227803,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593335465
    },
    {
        "content": "<p>In lean 3 <code>constant</code> is just a synonym of <code>axiom</code></p>",
        "id": 202227859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593335557
    },
    {
        "content": "<p>obviously there is no delta reduction because there is no definition</p>",
        "id": 202227865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593335583
    },
    {
        "content": "<p>in lean 4 there is a definition but no delta reduction</p>",
        "id": 202227870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593335592
    },
    {
        "content": "<p>what definition?</p>",
        "id": 202227875,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593335611
    },
    {
        "content": "<p>like <code>constant foo : nat := 37</code></p>",
        "id": 202227876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593335622
    },
    {
        "content": "<p>you cannot prove in lean 4 that <code>foo = 37</code></p>",
        "id": 202227917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593335644
    },
    {
        "content": "<p>The lean 3 equivalent of that is <code>constant foo : nat</code> and again you can't prove that <code>foo = 37</code> but this is not really a surprise</p>",
        "id": 202227936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593335725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202227727\">said</a>:</p>\n<blockquote>\n<p>irreducibles have delta reduction but only in the kernel, which means that you have to circumvent the elaborator if you want to use it in a proof</p>\n</blockquote>\n<p>right, that's what i thought. i can't think of any major downsides vs. <code>x/0 = 37</code>, so maybe this would be the right approach?</p>",
        "id": 202228872,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593337530
    },
    {
        "content": "<p>for programming purposes, there is also <code>panic</code>: <a href=\"https://github.com/leanprover/lean4/blob/ab5c0301d657ead4d950f461d4bcdd36606c5e72/src/Init/Util.lean#L30\">https://github.com/leanprover/lean4/blob/ab5c0301d657ead4d950f461d4bcdd36606c5e72/src/Init/Util.lean#L30</a></p>",
        "id": 202228930,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593337653
    },
    {
        "content": "<p>(constants still behave like their (possibly external) definitions during evaluation, so there are different semantics)</p>",
        "id": 202228998,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593337754
    },
    {
        "content": "<p>I think the right approach is <code>x / 0 = 0</code></p>",
        "id": 202229638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593338870
    },
    {
        "content": "<p>but that's just for division</p>",
        "id": 202229683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593338885
    },
    {
        "content": "<p>i wonder if one could improve the error reporting in tactic mode when a user encounters <code>arbitrary</code> to tell the user that they might be missing an assumption</p>",
        "id": 202230255,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593339745
    },
    {
        "content": "<p>I'm not sure what kind of situation would require this</p>",
        "id": 202230327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593339845
    },
    {
        "content": "<p>people would probably get stuck before they see <code>arbitrary</code>, i guess</p>",
        "id": 202230345,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593339902
    },
    {
        "content": "<p>I think <code>x/0=junk</code> gives you some added information which you're losing with this totalitarian viewpoint</p>",
        "id": 202243879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593361981
    },
    {
        "content": "<p>Can you confirm Kevin that <code>junk</code> should be a new object not in ℝ, as opposed to an arbitrary member of ℝ?</p>",
        "id": 202244254,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593362584
    },
    {
        "content": "<p>So, something like <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>'s suggestion above?  (But maybe more built into the type theory.)</p>",
        "id": 202244297,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593362642
    },
    {
        "content": "<p><code>junk</code> is an indication that something went wrong, and that tactics should be able to be more efficient if they work under the assumption that nothing went wrong. How it's modelled I don't know, but I think it's persistent: if you do anything to junk you end up with junk.</p>",
        "id": 202248819,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593369578
    },
    {
        "content": "<p>Yeah I think this matches the interpretation of the Maybe monad as failure</p>",
        "id": 202248976,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593369810
    },
    {
        "content": "<p>It sounds like kevin wants a way to open the Maybe monad (in the middle of a tactic proof, or maybe always at the beginning by default), do a bunch of stuff, then <em>exit</em> the Maybe monad, generating proof obligations for as few <code>some</code>s as possible.</p>",
        "id": 202249302,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1593370246
    },
    {
        "content": "<p>Right, if the result of the tactic's computation is Nothing then the tactic just fails</p>",
        "id": 202249652,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593370739
    },
    {
        "content": "<p>That said, perhaps he wants something a little different: \"more efficient if they work under the assumption that nothing went wrong\"</p>",
        "id": 202249727,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593370821
    },
    {
        "content": "<p>Right -- I don't want Lean to not apply (a-b)+b=a just because it isn't always true -- I want it to apply it and pick up the pieces later -- I would not have done a-b if it was junk so there's a b&lt;=a proof available somewhere, maybe by <code>linarith</code>.</p>",
        "id": 202250091,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593371381
    },
    {
        "content": "<p>Hmm, so at the moment you could do this manually using <code>rw</code>, and pick up the pieces later (while <code>simp</code> wouldn't because of the extra pieces), so could your notion just be achieved with a version of <code>simp</code> which generates a bunch of new proof obligations</p>",
        "id": 202250286,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1593371656
    },
    {
        "content": "<p>(this is a complete side note and not really relevant to the mathematics, but this idea of junk is extremely similar to how some C/C++ compilers reason about code. They have different kinds of abstract \"poison\" values that mean \"this cannot have happened, so we can optimize code under the assumption that nothing went wrong\". getting the semantics of these poison values right is rather tricky, though: <a href=\"https://dl.acm.org/doi/pdf/10.1145/3140587.3062343\">https://dl.acm.org/doi/pdf/10.1145/3140587.3062343</a> )</p>",
        "id": 202251248,
        "sender_full_name": "Carl Friedrich Bolz-Tereick",
        "timestamp": 1593372986
    },
    {
        "content": "<p>One thing I thought about is that one would have to be careful with equality and <code>junk</code>, since <code>junk = junk</code>.  In the current option proposals, this is true: `exists a : real, 1/a = 1/(a+a).</p>",
        "id": 202255745,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593378964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202250091\">said</a>:</p>\n<blockquote>\n<p>if it was junk so there's a b&lt;=a proof available somewhere, maybe by <code>linarith</code>.</p>\n</blockquote>\n<p>Would we expect a tactic to know this? (a-b)+b=a could also be junk since b is junk say.  It would have to backtrack to even know how one got to junk, so it know which assumption it can use.</p>",
        "id": 202255973,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593379279
    },
    {
        "content": "<p>i think if you want to exclude cases like <code>junk = junk</code> you will have to go the route of a multi-valued logic where undefined values behave similar to exceptions. i'm not sure if that is a good idea, and surely you will then need things like weak negation, weak implication etc. to make sense of things like LEM.</p>",
        "id": 202255977,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593379299
    },
    {
        "content": "<p>A whole different option with monads is to use a state monad.  The state would be of type Prop (or a list Prop) and be the assumptions needed to get a result.  Then there isn't a junk value, but instead <code>a - b</code> would technically return something of type <code>(a &lt;= b) -&gt; nat</code>, but the first part would be hidden by the monad.  It wouldn't compute (in the sense of #eval) in the same way as the option monad, but it would still be a monad which would hide the fact the the obligations still need to be met.  With coercion, you could write (a - b - c - d) easily.  The are just carried along until the end to be filled in.  (I haven't thought through the details with the context.  So, maybe that makes it difficult or impossible to implement.)  Also, I imagine this has all the same problems as the other similar solutions like implicit and type class assumptions.</p>",
        "id": 202256225,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593379634
    },
    {
        "content": "<p>We will never see junk values because the code mathematicians write avoids junk. We don't divide by zero, this is the point. For CS people the ability to do it is a convenience with occasional advantages. For us it's never done and this fact is not being leveraged to its full extent</p>",
        "id": 202256490,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593379949
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202256490\">said</a>:</p>\n<blockquote>\n<p>We will never see junk values because the code mathematicians write avoids junk. We don't divide by zero, this is the point. For CS people the ability to do it is a convenience with occasional advantages. For us it's never done and this fact is not being leveraged to its full extent</p>\n</blockquote>\n<p>mathematicians are lazy! (in the sense of haskell)</p>",
        "id": 202256573,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593380061
    },
    {
        "content": "<p>If someone writes <code>(a - b) + b = a</code>, is it automatically true, since obviously <code>b &gt;= a</code> for <code>a - b</code> to be written?  Or does it still require the assumption <code>b &gt;= a</code>?  For what it's worth, if someone can get that state monad example of mine, working, then with automatic coercion, when one writes <code>(a - b) + b = a</code> it is just a pretty printed version of <code>(a &lt;= b) -&gt; (a - b) + b = a</code> and the monad might make it easier to do proofs.</p>",
        "id": 202256679,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593380254
    },
    {
        "content": "<p>I'd like to see a \"subsingleton monad\" (is there a name for this?), mapping a type <code>X</code> to the type of subsingleton subsets of <code>X</code>, i.e. objects that are well-defined if they exist. Classically this is the same as <code>option X</code> -- a subsingleton is either empty or just some singleton -- but you wouldn't need undecidable <code>if</code>s to define things like inverses or integrals</p>",
        "id": 202281094,
        "sender_full_name": "David Wärn",
        "timestamp": 1593417637
    },
    {
        "content": "<p>I fear that all these suggestions are in the end harder to compose than <code>1/0 = 0</code> and <code>2 - 37 = 0</code>.<br>\n<span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> tactics could still apply <code>(a - b) + b = a</code> even if you use <code>0</code> instead of <code>junk</code>, right? The promise is still there.</p>",
        "id": 202281508,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593417881
    },
    {
        "content": "<p><code>roption</code> serves a similar purpose to the subsingleton monad you speak of.</p>",
        "id": 202281898,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1593418152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202281898\">said</a>:</p>\n<blockquote>\n<p><code>roption</code> serves a similar purpose to the subsingleton monad you speak of.</p>\n</blockquote>\n<p>Oh, thanks! <code>roption</code> is indeed isomorphic to subsingleton</p>",
        "id": 202282307,
        "sender_full_name": "David Wärn",
        "timestamp": 1593418458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202281508\">said</a>:</p>\n<blockquote>\n<p>I fear that all these suggestions are in the end harder to compose than <code>1/0 = 0</code> and <code>2 - 37 = 0</code>.</p>\n</blockquote>\n<p>That is what I would have thought too, but did you see <a href=\"#narrow/stream/113488-general/topic/37/near/202215662\">the example above</a>?  It seems to show that with monads (which naturally compose well), and coercion, some ideas seem to compose almost seamlessly.</p>",
        "id": 202300798,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593432869
    },
    {
        "content": "<p>monads don't compose as well as actual composition though</p>",
        "id": 202301354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593433262
    },
    {
        "content": "<p>It is possible to use an option monad for things like subtraction, and indeed <code>nat.psub</code> exists if you want to use it. But try it for a while and you will find it's strictly worse than just using <code>nat.sub</code> because you still have the same assumptions you need to pass around and now you also have to deal with the fact that <code>rw</code> doesn't really work anymore</p>",
        "id": 202301541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593433407
    },
    {
        "content": "<p>What I want is Pi (a b : nat), (h : b &lt;= a := by schoolkid) -&gt; nat</p>",
        "id": 202313182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593439476
    },
    {
        "content": "<p>This is mathematical subtraction on nat, and it has better lemmas than rubbish old computer science subtraction</p>",
        "id": 202313324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593439557
    },
    {
        "content": "<p>Are you saying you don't like burritos?</p>",
        "id": 202313525,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593439638
    },
    {
        "content": "<p>That still doesn't really solve anything, it just means you will be calling on the schoolkid all the time, even when not really necessary, and the job still has to be done</p>",
        "id": 202315163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593440264
    },
    {
        "content": "<p>One tactic that might be useful is a tactic that looks at the goal and adds <code>b &lt;= a</code> to the context for every subtraction <code>a - b</code> in the goal if it's not already present (and it can be extensible with more partiality conditions, e.g. <code>b != 0</code> when you see <code>a / b</code>, <code>a &gt;= 0</code> when you see <code>sqrt a</code>, etc)</p>",
        "id": 202315644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593440406
    },
    {
        "content": "<p>Alternatively, rather than adding these to the context they could be added as extra arguments to a <code>simp</code> invocation so that more conditional rewrite rules fire. So you could <code>partial_simp</code> <code>(a - b) + b</code> to <code>a</code> and it would automatically try to prove <code>h : b &lt;= a</code> (using a discharger, perhaps <code>linarith</code> by default) and then call <code>simp [h]</code> so that the conditional rewrite rule <code>nat.sub_add_cancel</code> applies</p>",
        "id": 202316247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593440604
    },
    {
        "content": "<p>this is pretty similar to how <code>nlinarith</code> works: look at the goal, heuristically add some assumptions to the context, then call the workhorse <code>linarith</code> tactic</p>",
        "id": 202316477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593440675
    },
    {
        "content": "<p>I think the claim is the job will almost always have to be done anyways (why bother forming <code>n-1</code> if you don't need to know it's one less than <code>n</code>) and easier to solve in the context where you wrote <code>n-1</code> than later.</p>",
        "id": 202316903,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593440836
    },
    {
        "content": "<p>that's not always true. For instance you might need to prove <code>n - 1 &gt; 0</code> and then you want to know that <code>n &gt; 1</code> instead.  Here <code>n &gt;= 1</code> might not come up at all and would be a distraction</p>",
        "id": 202317702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441120
    },
    {
        "content": "<p>But how would you get <code>n - 1</code> in the first place then?</p>",
        "id": 202317843,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593441157
    },
    {
        "content": "<p>What do you mean? In the context we know <code>n &gt; 1</code> so <code>n - 1</code> is well formed, but we don't care that <code>n &gt;= 1</code> even though it is true</p>",
        "id": 202318010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441214
    },
    {
        "content": "<p>Why is <code>n - 1 &gt; 0</code> our goal</p>",
        "id": 202318079,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593441240
    },
    {
        "content": "<p>That's just the example</p>",
        "id": 202318138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441248
    },
    {
        "content": "<p>maybe we are taking the log</p>",
        "id": 202318180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441257
    },
    {
        "content": "<p>What my point is, is that mathematicians don't do subtraction unless it's sensible</p>",
        "id": 202318200,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593441264
    },
    {
        "content": "<p>But why are we taking the log? Eventually we have to relate it back to <code>n</code> right?</p>",
        "id": 202318217,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593441271
    },
    {
        "content": "<p>your example is silly</p>",
        "id": 202318221,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593441272
    },
    {
        "content": "<p>If we didn't need to know that <code>n - 1</code> was one less than <code>n</code> we could just write 37 or whatever.</p>",
        "id": 202318265,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593441287
    },
    {
        "content": "<p>I'm really confused now</p>",
        "id": 202318292,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441299
    },
    {
        "content": "<p>I'm saying we are doing some math with <code>log (n - 1)</code>, say</p>",
        "id": 202318343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441314
    },
    {
        "content": "<p>Sure, I claim all the same properties hold of <code>log 37</code></p>",
        "id": 202318391,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593441332
    },
    {
        "content": "<p>except for one</p>",
        "id": 202318407,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593441340
    },
    {
        "content": "<p>and so in order to do something with this expression we end up having to prove <code>n - 1 &gt; 0</code>, and we want to apply a theorem that says <code>n &gt; 1 -&gt; n - 1 &gt; 0</code></p>",
        "id": 202318444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441359
    },
    {
        "content": "<p>and this theorem does not say <code>n &gt; 1 -&gt; n &gt;= 1 -&gt; n - 1 &gt; 0</code> because that would be stupid</p>",
        "id": 202318517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441380
    },
    {
        "content": "<p>But we would never see <code>n - 1</code> in the first place unless we were going to use <code>(n - 1) + 1 = n</code> later anyways</p>",
        "id": 202318589,
        "sender_full_name": "Reid Barton",
        "timestamp": 1593441407
    },
    {
        "content": "<p>not necessarily</p>",
        "id": 202318821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441483
    },
    {
        "content": "<p>we might need to use a different theorem about subtraction</p>",
        "id": 202318855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441494
    },
    {
        "content": "<p>that one is just the \"definitional theorem\", we could be working well past that level</p>",
        "id": 202318906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441516
    },
    {
        "content": "<p>for example we wanted to apply a theorem that uses nat subtraction in its statement</p>",
        "id": 202318990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441551
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> If your goal is <code>0 ≤ srqt x</code>, do you want to prove <code>0 ≤ x</code> as a precondition, or just have this be a theorem without assumptions?</p>",
        "id": 202319186,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593441613
    },
    {
        "content": "<p>I am onboard with always having the fact <code>1 &lt;= n</code> \"on call\" as it were, but I don't want every theorem ever about subtraction to have this as an assumption that needs to be threaded through</p>",
        "id": 202319208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441623
    },
    {
        "content": "<p>That's why <code>nat.sub</code> is defined the way it is</p>",
        "id": 202319240,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593441637
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202318589\">said</a>:</p>\n<blockquote>\n<p>But we would never see <code>n - 1</code> in the first place unless we were going to use <code>(n - 1) + 1 = n</code> later anyways</p>\n</blockquote>\n<p>You might need an arbitrary <code>k</code> such that <code>k &lt; n &lt;= 2*k</code> (still assuming <code>n&gt;1</code>)</p>",
        "id": 202319265,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593441648
    },
    {
        "content": "<p>and it's annoying because <code>omega</code> is broken</p>",
        "id": 202319302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593441662
    },
    {
        "content": "<p>but when I do subtraction I don't want to use nat.sub, I'd rather use mathematician's subtraction, because I think it will be better for automation</p>",
        "id": 202319421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593441707
    },
    {
        "content": "<p>Why?</p>",
        "id": 202319523,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593441731
    },
    {
        "content": "<p>Automation can just assume you didn't do anything stupid, right?</p>",
        "id": 202319583,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593441748
    },
    {
        "content": "<p>I contend that the only difference between <code>nat.sub</code> and mathematician's subtraction is better bookkeeping around these \"on call\" assumptions</p>",
        "id": 202319591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441750
    },
    {
        "content": "<p>Automation can just generate some side goals, and work under the assumption that everything is <em>mathematically sane</em>.<br>\nIt could proceed to try to prove some of these side goals...</p>",
        "id": 202319767,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593441810
    },
    {
        "content": "<p>I don't see what the problem is with the way Lean handles partial function.<br>\nMathematicians only use these function with some preconditions. In the case that you assume those preconditions, our functions have the exact behavior you want. Why do you care it has a (unexpected?) behavior in cases when you don't use it?<br>\nThe real problem is that <code>nat.sub</code> is denoted <code>-</code> and <code>nat.div</code> denoted <code>/</code> so you can \"accidentally\" use it, while you really wanted to use a different operation.</p>",
        "id": 202319782,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593441817
    },
    {
        "content": "<p>I don't think lean currently has a very good way to notate \"preferred preconditions\" right now, but it is nothing we couldn't solve with a tactic that introduces a framework of annotations of its own</p>",
        "id": 202319911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593441856
    },
    {
        "content": "<p>I really don't want <code>x - y</code> to end up in <code>option nat</code>.</p>",
        "id": 202320057,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593441900
    },
    {
        "content": "<p>And I also don't want <code>x -[h] y</code></p>",
        "id": 202320092,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593441912
    },
    {
        "content": "<p>Of course the real problem is that a mathematician <em>will</em> write <code>k - n</code> and expect <code>k - n + n = k</code>, whatever the values of <code>k</code> and <code>n</code>. This is the real problem with <code>nat.sub</code>.</p>",
        "id": 202320487,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442064
    },
    {
        "content": "<p>How does <code>field_simp</code> handle this? It's not that hard to look at a term, locate all the partial function subterms, and derive a list of things that \"really ought to be true\" and then... prove them somehow?</p>",
        "id": 202320572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442084
    },
    {
        "content": "<p>It's different from <code>x / y</code>, because there the promise is that <code>y</code> will never be zero.</p>",
        "id": 202320610,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442095
    },
    {
        "content": "<p>We could lint theorems that fail their preferred preconditions</p>",
        "id": 202320695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442127
    },
    {
        "content": "<p><code>field_simp</code> is just a curated simpset, right?</p>",
        "id": 202320725,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442138
    },
    {
        "content": "<p>I thought it derives the preferred preconditions but maybe it just accepts proofs of those preconditions</p>",
        "id": 202320805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442171
    },
    {
        "content": "<p>But we probably don't need to lint theorems because if they fail preconditions they are either true by funny tricks (in which case we probably intend to silence the lint) or they are false and the user will notice soon enough</p>",
        "id": 202321031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442245
    },
    {
        "content": "<p>Proposal: use notation <code>∸</code> for <code>nat.sub</code>.</p>",
        "id": 202321053,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593442257
    },
    {
        "content": "<p>How about <code>nat.div</code> and <code>int.div</code>?</p>",
        "id": 202321315,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442360
    },
    {
        "content": "<p><code>/.</code> for both?</p>",
        "id": 202321356,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593442373
    },
    {
        "content": "<p><code>class has_ill_behaved_div</code></p>",
        "id": 202321396,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593442389
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/3226\">#3226</a> mentions having to prove nats are &gt;= 0 many times, which seems prophetic of these nat.sub solutions</p>",
        "id": 202321404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442392
    },
    {
        "content": "<p>I like <code>//</code> from python</p>",
        "id": 202321499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442441
    },
    {
        "content": "<p>for truncated div</p>",
        "id": 202321544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442446
    },
    {
        "content": "<p>also fine with me</p>",
        "id": 202321563,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593442455
    },
    {
        "content": "<p>Or the <code>-:-</code> symbol?</p>",
        "id": 202321570,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442460
    },
    {
        "content": "<p><code>÷</code></p>",
        "id": 202321593,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442470
    },
    {
        "content": "<p><code>//</code> could look confusing in <code>{x // y // x = 37}</code></p>",
        "id": 202321668,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442505
    },
    {
        "content": "<p>ah, that's true</p>",
        "id": 202321693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442517
    },
    {
        "content": "<p>Of course it's unambiguous, but still</p>",
        "id": 202321712,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442530
    },
    {
        "content": "<p>But why are we disambiguating this symbol anyway?</p>",
        "id": 202321742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442546
    },
    {
        "content": "<p>I don't want to send the message this is \"wrong division\"</p>",
        "id": 202321837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442571
    },
    {
        "content": "<p>Because people use these operations without realizing they are using <em>these</em> operations.</p>",
        "id": 202321931,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593442606
    },
    {
        "content": "<p>I wish <code>k - n</code> would be an int, and <code>k ∸ n</code> a <code>nat</code>. But that would require changing the type signature of <code>-</code> to something ugly with an outparam. Doesn't sound like a good idea.</p>",
        "id": 202321940,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442608
    },
    {
        "content": "<p>I understand the appeal only when the symbol is being used out of the traditional domain</p>",
        "id": 202321978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442622
    },
    {
        "content": "<p>If <code>k &gt;= n</code>, then I see no issue at all with the notation <code>k - n</code>, because it's not a lie</p>",
        "id": 202322179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442690
    },
    {
        "content": "<p>Sure, but what if <code>k &lt; n</code>?</p>",
        "id": 202322212,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442702
    },
    {
        "content": "<p>and if <code>k &lt; n</code> then what are you even doing writing <code>k - n</code></p>",
        "id": 202322223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442711
    },
    {
        "content": "<p>This actually happens in maths <span aria-label=\"shock\" class=\"emoji emoji-1f628\" role=\"img\" title=\"shock\">:shock:</span></p>",
        "id": 202322225,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442711
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202322223\">said</a>:</p>\n<blockquote>\n<p>and if <code>k &lt; n</code> then what are you even doing writing <code>k - n</code></p>\n</blockquote>\n<p>Well, you might be a mathematician</p>",
        "id": 202322255,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442725
    },
    {
        "content": "<p>we can have a tactic that will slap you on the wrist if you desire</p>",
        "id": 202322271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442730
    },
    {
        "content": "<p>The typically expect the result to be an <code>int</code></p>",
        "id": 202322299,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202322271\">said</a>:</p>\n<blockquote>\n<p>we can have a tactic that will slap you on the wrist if you desire</p>\n</blockquote>\n<p>That doesn't sound very user friendly.</p>",
        "id": 202322316,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442748
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I think the problem is users might write <code>n - m</code> or <code>n / m</code> while they really meant to first apply a cast to <code>n</code>, but don't realize that didn't happen automatically.</p>",
        "id": 202322336,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593442755
    },
    {
        "content": "<p>then maybe a wrist slapping tactic is the right solution</p>",
        "id": 202322386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442774
    },
    {
        "content": "<p>Or a wrist slapping notation?</p>",
        "id": 202322494,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442803
    },
    {
        "content": "<p>it can scour the context for things that probably don't mean what you think they mean</p>",
        "id": 202322510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442808
    },
    {
        "content": "<p>You could just have the type checker do the wrist slapping.</p>",
        "id": 202322529,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442816
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">Error</span><span class=\"o\">:</span> <span class=\"n\">did</span> <span class=\"n\">not</span> <span class=\"n\">find</span> <span class=\"kn\">instance</span> <span class=\"bp\">`</span><span class=\"n\">has_sub</span> <span class=\"n\">nat</span><span class=\"bp\">`</span>\n</code></pre></div>",
        "id": 202322559,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442830
    },
    {
        "content": "<p>Or we use different notation, and have a lemma that in all sensible cases <code>n ∸ m = n - m</code></p>",
        "id": 202322570,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593442838
    },
    {
        "content": "<p>no, this can't be more than a lint because there are also legitimate uses for out of domain stuff</p>",
        "id": 202322583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442844
    },
    {
        "content": "<p>but we have that lemma already, it's called <code>int.coe_nat_sub</code></p>",
        "id": 202322675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442886
    },
    {
        "content": "<p>Exactly, it would just look a bit different after the change</p>",
        "id": 202322731,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593442911
    },
    {
        "content": "<p>I would still want what you are calling <code>n - m</code> to actually elaborate to <code>\\u n - \\u m</code></p>",
        "id": 202322821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442944
    },
    {
        "content": "<p>I agree, can we do that?</p>",
        "id": 202322909,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593442984
    },
    {
        "content": "<p>only in the right typing context</p>",
        "id": 202322937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593442997
    },
    {
        "content": "<p>That would be awesome...</p>",
        "id": 202322946,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443001
    },
    {
        "content": "<p>How about abolishing <code>k - n</code>, and having <code>k ∸ n</code> and <code>k -[ℤ] n</code>. Then users are always explicit about what they mean.</p>",
        "id": 202323098,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443062
    },
    {
        "content": "<p>The latter being notation for <code>(k:ℤ) - n</code>.</p>",
        "id": 202323155,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443096
    },
    {
        "content": "<p>Well, maybe it's not worth it... to have separate notation for that.</p>",
        "id": 202323208,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443119
    },
    {
        "content": "<p>What is the proposal exactly? In context <code>m - n : ?A</code> we first assume <code>-</code> is <code>has_sub.sub ?A ?M</code> and then have to determine the type of <code>n : ?A</code> and <code>m : ?A</code>, then see <code>n : nat</code>, reject this because <code>has_sub nat</code> fails (or is suppressed somehow), and then insert a coercion; we still have to determine what <code>?A</code> is and then deep magic causes <code>?A := int</code></p>",
        "id": 202323380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443193
    },
    {
        "content": "<p>this looks like something that is not likely to happen in lean 3</p>",
        "id": 202323469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443238
    },
    {
        "content": "<p><code>has_sub</code> should remain to depend on just one type.</p>",
        "id": 202323517,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443264
    },
    {
        "content": "<p>Just remove the instance for <code>nat</code></p>",
        "id": 202323541,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443275
    },
    {
        "content": "<p>And have special notation for <code>nat.sub</code>.</p>",
        "id": 202323637,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443307
    },
    {
        "content": "<p>We create a new class <code>has_truncated_sub</code> and <code>∸</code> is notation for that.</p>",
        "id": 202323751,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443362
    },
    {
        "content": "<p>Similarly for <code>has_crazy_div</code>. And we have instances <code>has_crazy_div nat</code> and <code>has_crazy_div int</code>.</p>",
        "id": 202323814,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443396
    },
    {
        "content": "<p>Am I allowed to say that I am completely happy with the current state of affairs, writing <code>n - m</code> to mean nat subtraction?</p>",
        "id": 202323875,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593443406
    },
    {
        "content": "<p>I still think this kind of marginalizes <code>nat.sub</code> when it is used legitimately like <code>2 ^ n - 1 = sum_k 2^k</code></p>",
        "id": 202323884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443409
    },
    {
        "content": "<p>Having to put a monus in there is just cognitive overhead for the reader</p>",
        "id": 202323953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443438
    },
    {
        "content": "<p>And that trying complicated solutions around a non-existing problem will likely only make things worse.</p>",
        "id": 202323986,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593443458
    },
    {
        "content": "<p>I don't think the solution is that complicated. And we've seen quite some users being very confused by <code>2 - 5 = 0</code>.</p>",
        "id": 202324118,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443509
    },
    {
        "content": "<p>Unfortunately Casper isn't on Zulip yet...</p>",
        "id": 202324160,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443522
    },
    {
        "content": "<p>We need linters and assistance tools for this</p>",
        "id": 202324196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202324196\">said</a>:</p>\n<blockquote>\n<p>We need linters and assistance tools for this</p>\n</blockquote>\n<p>Like a type checker?</p>",
        "id": 202324219,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443559
    },
    {
        "content": "<p>no</p>",
        "id": 202324230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443564
    },
    {
        "content": "<p>like a sanity checker</p>",
        "id": 202324271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443582
    },
    {
        "content": "<p>Having <code>3 - 2</code> parse to nat subtraction and <code>3 - 5</code> insert a coercion looks like a crazy hack to me.</p>",
        "id": 202324279,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593443584
    },
    {
        "content": "<p>it's also probably undecidable</p>",
        "id": 202324322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443600
    },
    {
        "content": "<p>That's not what we are suggesting</p>",
        "id": 202324333,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443604
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> <code>3 - 5</code> would simply not typecheck in my proposal. (Unless the type is <code>int</code> or some other <code>add_group</code> say.)</p>",
        "id": 202324487,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443636
    },
    {
        "content": "<p><code>3 ∸ 5 = 0</code></p>",
        "id": 202324636,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443658
    },
    {
        "content": "<p>and <code>3 - 2</code> presumably also doesn't typecheck?</p>",
        "id": 202324721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443676
    },
    {
        "content": "<p>even though any mathematician will say that this is fine</p>",
        "id": 202324766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443685
    },
    {
        "content": "<p>Yup...</p>",
        "id": 202324813,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443705
    },
    {
        "content": "<p>When you type C++ in a modern IDE and you are doing something weird (using an uninitialized variable, say), you get a live warning. I would be fine with having the same mechanism fire up if you write <code>m - n</code> and <code>linarith</code> can not infer <code>n \\le m</code> from the context. But it should just be a warning, and let you proceed if you want to.</p>",
        "id": 202324827,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593443717
    },
    {
        "content": "<p>I would be very happy with that solution. But I don't have the brains to implement it.</p>",
        "id": 202324901,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443759
    },
    {
        "content": "<p>Having live feedback from tactics while I type is not something that exists in our ecosystem at the moment.</p>",
        "id": 202324990,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443790
    },
    {
        "content": "<p>if it's explicitly invoked (the wrist slapping tactic) it's not so hard to implement</p>",
        "id": 202324995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443791
    },
    {
        "content": "<p>Also... it needs to be fast.</p>",
        "id": 202325003,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443798
    },
    {
        "content": "<p>calling linarith all the time will probably not be fast</p>",
        "id": 202325024,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443811
    },
    {
        "content": "<p>but you could swap it out for <code>assumption</code> in many cases</p>",
        "id": 202325075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202324995\">said</a>:</p>\n<blockquote>\n<p>if it's explicitly invoked (the wrist slapping tactic) it's not so hard to implement</p>\n</blockquote>\n<p>I don't think newbies are going to explicitly invoke anything.</p>",
        "id": 202325115,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443858
    },
    {
        "content": "<p>I like to give the example</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">composition_card</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">composition</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n\n\n<p>in <code>composition.lean</code>. Where <code>-</code> is nat subtraction. I want to keep the right to do this :)</p>",
        "id": 202325126,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593443864
    },
    {
        "content": "<p>I love this discussion... but dinner is calling</p>",
        "id": 202325143,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593443875
    },
    {
        "content": "<p>Sebastien I think that this qualifies you as a CS person to Kevin</p>",
        "id": 202325322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593443956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202325143\">said</a>:</p>\n<blockquote>\n<p>I love this discussion... but dinner is calling</p>\n</blockquote>\n<p>I have a new theory about Covid. I think it was created by some Dutch scientists to make sure international conferences are cancelled because they can't stand having dinner at a civilized time.</p>",
        "id": 202328527,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593445467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113488-general/topic/37/near/202325126\">said</a>:</p>\n<blockquote>\n<p>I like to give the example</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">composition_card</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">composition</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n\n\n<p>in <code>composition.lean</code>. Where <code>-</code> is nat subtraction. I want to keep the right to do this :)</p>\n</blockquote>\n<p>Every mathematician will think that you proved that <code>fintype.card (composition 0) = 1 / 2</code>.</p>\n<p><del>(Of course that's actually true by <code>rfl</code>, which is all the more confusing.)</del></p>",
        "id": 202331384,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593446813
    },
    {
        "content": "<p>No, clearly <code>2 ^ (0 - 1) = 1 ≠ 0 = 1 / 2</code></p>",
        "id": 202331577,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1593446898
    },
    {
        "content": "<p>Ooh crap...</p>",
        "id": 202331703,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593446973
    },
    {
        "content": "<p>Maybe <code>/</code> should round up? After all, it's returning junk values whenever the denominator doesn't divide the numerator :-)</p>",
        "id": 202337704,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593449487
    },
    {
        "content": "<p>I defined <code>int</code> as the quotient of nat^2 by the usual equivalence relation yesterday, and along the way discovered that the function <code>nat -&gt; nat -&gt; int</code> which Johan was talking about in the context of subtraction is actually called <code>quotient.mk</code>.</p>",
        "id": 202337918,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593449560
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Why didn't you just reuse Amelia's api? Is this for some teaching stuff?</p>",
        "id": 202340688,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593450789
    },
    {
        "content": "<p>Yes</p>",
        "id": 202343515,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593452017
    }
]
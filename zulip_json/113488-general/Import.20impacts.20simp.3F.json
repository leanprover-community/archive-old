[
    {
        "content": "<p>Hi all! I just encountered a phenomenon that I don't understand quite well. Don't know if you have any clue? <br>\n(the mathlib I used is based on the commit \"9a8dcb9be408e7ae8af9f6832c08c021007f40ec\", maybe not the latest but it's quite new)</p>\n<p>Let's start from an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.linarith</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">finset.range</span> <span class=\"mi\">49</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">49</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This one should look good and we have goal accomplished. But if I add more imports to the file, like the following one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.floor</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group_power.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.quadratic_discriminant</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.ring.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.asymptotics.asymptotic_equivalent</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.mean_inequalities</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.inner_product</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.pi_Lp</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.exp_log</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.pow</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.trigonometric</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.equiv.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.int.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.int.gcd</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.int.modeq</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.multiset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.factorial</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.modeq</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.parity</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.pnat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.eval</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.rat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.ennreal</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.irrational</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.nnreal</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.sqrt</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.zmod.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">geometry.euclidean.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">geometry.euclidean.circumcenter</span>\n<span class=\"kn\">import</span> <span class=\"n\">init.data.nat.gcd</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.affine_space.affine_map</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.affine_space.independent</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.finite_dimensional</span>\n<span class=\"kn\">import</span> <span class=\"n\">number_theory.divisors</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.bounds</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.instances.nnreal</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">finset.range</span> <span class=\"mi\">49</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">49</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It became</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">there</span> <span class=\"n\">are</span> <span class=\"n\">unsolved</span> <span class=\"n\">goals</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"bp\">⊢</span> <span class=\"mi\">32</span> <span class=\"bp\">+</span> <span class=\"mi\">16</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">49</span>\n</code></pre></div>\n<p>So I would like to know if this is a bug or it's reasonable? And different imports do impact the performance of <code>simp</code>? Any clue is welcome!</p>",
        "id": 246713984,
        "sender_full_name": "Kunhao Zheng",
        "timestamp": 1626871740
    },
    {
        "content": "<p>It looks like one of your imports contains a simp lemma that rewrote 49 to it's binary representation 32+16+1. You can use <code>squeeze_simp</code> to get a better idea of what happened (it tells you what lemmas were used by simp)</p>",
        "id": 246714744,
        "sender_full_name": "David Wärn",
        "timestamp": 1626872084
    },
    {
        "content": "<p>Thanks! So the <code>simp</code> tactic will search through the lemma with <code>@simp</code> among all the files that I import. As I import more files, the search space is larger and there is more chance that it applies the lemma that is not really desirable. Is it correct?</p>",
        "id": 246715312,
        "sender_full_name": "Kunhao Zheng",
        "timestamp": 1626872355
    },
    {
        "content": "<p>Yes though in theory there should be no such thing as a simp lemma that is not really desirable.</p>",
        "id": 246715381,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1626872398
    },
    {
        "content": "<p>So this is a good opportunity to compare the results of the two <code>squeeze_simp</code>s and see if there are some <code>simp</code> tags that need rethinking.</p>",
        "id": 246715714,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1626872500
    },
    {
        "content": "<p>Cool! Thank you for the hint. This is a very good practice!</p>\n<p>The first one implies</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">nat.cast_bit0</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_const</span><span class=\"o\">,</span> <span class=\"n\">nsmul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">nat.cast_bit1</span><span class=\"o\">,</span> <span class=\"n\">finset.card_range</span><span class=\"o\">,</span> <span class=\"n\">nat.cast_one</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and the second one</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">one_mul</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_const</span><span class=\"o\">,</span> <span class=\"n\">nsmul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">algebra.bit1_smul_one</span><span class=\"o\">,</span> <span class=\"n\">finset.card_range</span><span class=\"o\">,</span> <span class=\"n\">nat.cast_one</span><span class=\"o\">,</span>\n  <span class=\"n\">algebra.bit0_smul_bit0</span><span class=\"o\">,</span> <span class=\"n\">algebra.bit1_smul_bit0</span><span class=\"o\">],</span>\n</code></pre></div>",
        "id": 246716259,
        "sender_full_name": "Kunhao Zheng",
        "timestamp": 1626872781
    },
    {
        "content": "<p>The offending one is the one that mentions bit1. As a stopgap, you can include [bit1] in your simp call.</p>",
        "id": 246716815,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1626873099
    },
    {
        "content": "<p>I don't have time to dig into this at the moment but the two lists are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"bp\">*</span> <span class=\"n\">mul_one</span>\n <span class=\"bp\">*</span> <span class=\"n\">finset.sum_const</span>\n <span class=\"bp\">*</span> <span class=\"n\">finset.card_range</span>\n <span class=\"bp\">*</span> <span class=\"n\">nsmul_eq_mul</span>\n <span class=\"bp\">*</span> <span class=\"n\">nat.cast_one</span>\n <span class=\"bp\">*</span> <span class=\"n\">nat.cast_bit0</span>\n <span class=\"bp\">*</span> <span class=\"n\">nat.cast_bit1</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"bp\">*</span> <span class=\"n\">one_mul</span>\n <span class=\"bp\">*</span> <span class=\"n\">finset.sum_const</span>\n <span class=\"bp\">*</span> <span class=\"n\">finset.card_range</span>\n <span class=\"bp\">*</span> <span class=\"n\">nsmul_eq_mul</span>\n <span class=\"bp\">*</span> <span class=\"n\">nat.cast_one</span>\n <span class=\"bp\">*</span> <span class=\"n\">algebra.bit0_smul_bit0</span>\n <span class=\"bp\">*</span> <span class=\"n\">algebra.bit1_smul_bit0</span>\n <span class=\"bp\">*</span> <span class=\"n\">algebra.bit1_smul_one</span>\n</code></pre></div>",
        "id": 246716943,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1626873162
    },
    {
        "content": "<p>Definitely the lemmas mentioning <code>bit</code> need some thought.</p>",
        "id": 246716983,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1626873192
    },
    {
        "content": "<p>The following versions of the lemmas <code>algebra.bit1_smul_one</code> and <code>algebra.bit0_smul_one</code> seem to work a bit better, I'll try and run CI on them and see what happens</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.floor</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group_power.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.quadratic_discriminant</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.ring.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.asymptotics.asymptotic_equivalent</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.mean_inequalities</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.inner_product</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.pi_Lp</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.exp_log</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.pow</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.special_functions.trigonometric</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.equiv.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.int.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.int.gcd</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.int.modeq</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.multiset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.factorial</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.modeq</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.parity</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.pnat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.eval</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.rat.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.ennreal</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.irrational</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.nnreal</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.sqrt</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.zmod.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">geometry.euclidean.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">geometry.euclidean.circumcenter</span>\n<span class=\"kn\">import</span> <span class=\"n\">init.data.nat.gcd</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.affine_space.affine_map</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.affine_space.independent</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.finite_dimensional</span>\n<span class=\"kn\">import</span> <span class=\"n\">number_theory.divisors</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.bounds</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.instances.nnreal</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">algebra.bit0_smul_one'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"n\">bit0</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">bit0</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">bit0</span><span class=\"o\">,</span> <span class=\"n\">add_smul</span><span class=\"o\">]</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">algebra.bit1_smul_one'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"n\">bit1</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">bit1</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">bit1</span><span class=\"o\">,</span> <span class=\"n\">add_smul</span><span class=\"o\">]</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">finset.range</span> <span class=\"mi\">49</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">49</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">algebra.bit1_smul_one</span><span class=\"o\">,</span> <span class=\"n\">algebra.bit1_smul_one'</span><span class=\"o\">,</span>\n      <span class=\"bp\">-</span><span class=\"n\">algebra.bit0_smul_one</span><span class=\"o\">,</span> <span class=\"n\">algebra.bit0_smul_one'</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 246834111,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1626952925
    },
    {
        "content": "<p>What's the difference between your lemma and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.bit1_smul_one\">docs#algebra.bit1_smul_one</a>?</p>",
        "id": 246835128,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626953822
    },
    {
        "content": "<p>Oh, I see - <code>bit1 (r • 1 : A)</code> vs <code>(r • 2 + 1 : A)</code> on the RHS</p>",
        "id": 246835235,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626953897
    },
    {
        "content": "<p>Yeah, your lemma definitely looks better</p>",
        "id": 246835245,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626953904
    },
    {
        "content": "<p>Yeah it looks like the originals aren't used anywhere by name, so the only potential issues would be in simp calls, hopefully CI will find them <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 246835333,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1626953973
    },
    {
        "content": "<p>That does look a lot better, thanks for investigating!</p>",
        "id": 246835470,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1626954070
    },
    {
        "content": "<p>Although actually - would <code>bit1 r • (1 : A) = r • bit1 (1 : A)</code> be a better simp lemma?</p>",
        "id": 246835671,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626954221
    },
    {
        "content": "<p>Since that ensures the bit1 gets placed on the <code>1</code> which is likely to introduce a numeral in a helpful place</p>",
        "id": 246835791,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626954301
    },
    {
        "content": "<p>This one isn't true right? <code>(2 + 2 + 1) • (1 : A) \\ne 2 • (1 + 1 + 1 : A)</code> the <code>bit0</code> version works, but I would think keeping both bit0/1 on the same side is best?</p>",
        "id": 246836169,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1626954619
    },
    {
        "content": "<p>This is now <a href=\"https://github.com/leanprover-community/mathlib/issues/8394\">#8394</a></p>",
        "id": 246836495,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1626954860
    }
]
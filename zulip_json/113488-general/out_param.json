[
    {
        "content": "<p>I thought that <code>out_param</code> should have disappeared from modules, but in <code>analysis.normed_space.basic</code> there are the following lines:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">normed_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">normed_field</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"kn\">extends</span> <span class=\"n\">normed_group</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">vector_space</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>I don't understand them, which is not a big deal, but I wanted to check that they should not be changed.</p>",
        "id": 160994372,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1552820719
    },
    {
        "content": "<p>I asked the same question last week...</p>",
        "id": 160994379,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1552820743
    },
    {
        "content": "<p>And what answer did you get?</p>",
        "id": 160994380,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1552820758
    },
    {
        "content": "<p>none</p>",
        "id": 160994432,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1552820830
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/topic/out_param.20again/near/160275177\" title=\"#narrow/stream/116395-maths/topic/out_param.20again/near/160275177\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/out_param.20again/near/160275177</a></p>",
        "id": 160995259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552822471
    },
    {
        "content": "<p>Thansk for the pointer. Indeed, this is the very same question!</p>",
        "id": 160995442,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1552822834
    },
    {
        "content": "<p>I am having problems with out_param in the following situation. Suppose <code>M</code> is a <code>C^1</code> manifold, with respect to a base field <code>k</code> and a model vector space <code>E</code>. I want to define the tangent space at a point <code>x</code>, by taking equivalence classes of vectors in charts. The maths are not important. The point is that <code>k</code> is relevant (you may want to consider a complex manifold as a real manifold), so just as for linear maps it should be explicit in the definition of the tangent space. However, there will always be one single model space <code>E</code>, so I don't want to have it as an explicit parameter in the definition: it should rather be inferred from the manifold instance in the context. I tried to write this as (with everything in <code>Type</code> to avoid potential universe issues):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">tangent_space_unfolded</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">nondiscrete_normed_field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">normed_space</span> <span class=\"n\">k</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">manifold</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">times_cont_diff_groupoid</span> <span class=\"mi\">1</span> <span class=\"n\">k</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">M</span> <span class=\"n\">E</span> <span class=\"bp\">//</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">chart</span> <span class=\"o\">(</span><span class=\"n\">times_cont_diff_groupoid</span> <span class=\"mi\">1</span> <span class=\"n\">k</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">}</span> <span class=\"bp\">×</span> <span class=\"n\">E</span>\n</pre></div>\n\n\n<p>(notice the <code>out_param</code> on <code>E</code> and <code>normed_space k E</code>). However, when I try to use this definition, <code>E</code> is not inferred. For instance, with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">tangent_vector_equiv_rel</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nondiscrete_normed_field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"n\">k</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">manifold</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">times_cont_diff_groupoid</span> <span class=\"mi\">1</span> <span class=\"n\">k</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">tangent_space_unfolded</span> <span class=\"n\">k</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">true</span>\n</pre></div>\n\n\n<p>I get the red squiggle under <code>p : tangent_space_unfolded k x</code> with the complaint</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">don&#39;t</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">placeholder</span>\n<span class=\"kn\">context</span><span class=\"o\">:</span>\n<span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">nondiscrete_normed_field</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n<span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">normed_space</span> <span class=\"n\">k</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n<span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_4</span> <span class=\"o\">:</span> <span class=\"n\">manifold</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">times_cont_diff_groupoid</span> <span class=\"mi\">1</span> <span class=\"n\">k</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span>\n<span class=\"err\">⊢</span> <span class=\"n\">out_param</span> <span class=\"kt\">Type</span>\n</pre></div>\n\n\n<p>If I make the parameter <code>E</code> explicit, on the other hand, everything is fine.</p>\n<p>There are very few places in the library where <code>out_param</code> is used, so I don't have enough examples (or documentation) to understand what the right syntax should be. Is it impossible to do what I would like?</p>",
        "id": 164911736,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557049708
    },
    {
        "content": "<p>out_param goes on instances and class definitions</p>",
        "id": 164912212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557050517
    },
    {
        "content": "<p>you can't just put it on a single definition, it's tied in to the whole instance search problem for that typeclass</p>",
        "id": 164912263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557050571
    },
    {
        "content": "<p>In this case, if you want <code>k</code> to determine <code>E</code> in <code>normed_space</code>, you would need to mark <code>E</code> as <code>out_param</code> in the definition of <code>normed_space</code>. I guess that's not what you want</p>",
        "id": 164912316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557050646
    },
    {
        "content": "<p>I don't want <code>k</code> to determine <code>E</code>, I want the manifold instance together with <code>k</code> to determine <code>E</code>.</p>",
        "id": 164912334,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557050696
    },
    {
        "content": "<p>but the manifold instance already mentions E</p>",
        "id": 164912354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557050722
    },
    {
        "content": "<p>So you want to trigger the search <code>manifold ?E (times_cont_diff_groupoid 1 k ?E) M</code>?</p>",
        "id": 164912407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557050812
    },
    {
        "content": "<p>Yes. I guess I don't understand at all what out_param does. What I would like to happen when Lean encounters <code>tangent_space k x</code>: it looks in the context for a instance of <code>manifold ?m1 (times_cont_diff_groupoid 1 k ?m1) M</code>, and if it finds one it picks it at <code>E</code>.</p>",
        "id": 164912409,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557050818
    },
    {
        "content": "<p>or is it <code>manifold ?E ?X M</code></p>",
        "id": 164912420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557050835
    },
    {
        "content": "<p>what is that second argument?</p>",
        "id": 164912424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557050880
    },
    {
        "content": "<p>It is really <code>manifold ?m1 (times_cont_diff_groupoid 1 k ?m1) M</code> that it should look for.</p>",
        "id": 164912467,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557050885
    },
    {
        "content": "<p>It is a groupoid, i.e., a set of local homeomorphisms between <code>M</code> and <code>E</code>.</p>",
        "id": 164912470,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557050918
    },
    {
        "content": "<p>can you make another class?</p>",
        "id": 164912539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557051032
    },
    {
        "content": "<p>like <code>model_space M ?E</code> or something</p>",
        "id": 164912541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557051044
    },
    {
        "content": "<p>that implies <code>manifold ?E (times_cont_diff_groupoid 1 k ?E) M</code></p>",
        "id": 164912543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557051056
    },
    {
        "content": "<p>I am wary of that typeclass arg. You can probably make lean search for it because lean typeclass search has no hygiene, but that's also why typeclass search is starting to fall over in mathlib</p>",
        "id": 164912624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557051195
    },
    {
        "content": "<p>What I could do is mark <code>E</code> as out_param in the definition of manifold. Except that this is not OK as there can be different model spaces depending on whether one considers a space as a real or complex manifold. So, it would really have to depend on both <code>k</code> and <code>M</code>. I can build a new class <code>smooth_manifold k ?E M</code> with <code>E</code> as an out_param, and see how this goes.</p>",
        "id": 164912628,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557051228
    },
    {
        "content": "<p>Being a manifold is definitely a type class, just as good as being a ring or a topological space. The only difference is that it has more structure built in, so it depends on more stuff but that's the way math is.</p>",
        "id": 164912685,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557051301
    },
    {
        "content": "<p>The problem isn't the math, it's the use of <code>(times_cont_diff_groupoid 1 k ?E)</code> as one of the arguments to the class. It's too dependent for my liking (it's not even a type IIUC)</p>",
        "id": 164913172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557052138
    },
    {
        "content": "<p>For each groupoid <code>G</code>, you have a notion of manifold based on this groupoid. For instance, <code>C^infty</code> manifolds, or manifolds with boundary, or manifold with corners, or contact manifolds, or orientable manifolds, or whatever. Each of these structures gives you access to some objects on the manifold. My idea is to set up a set of instances between these structures, so that when you have a contact manifold then you also get automatically a smooth structure, an oriented structure, and so on, just by typeclass inference. I have the impression that this is precisely the kind of things at which typeclass inference is good, but maybe I am missing something.</p>",
        "id": 164913454,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557052593
    },
    {
        "content": "<p>could you put the definition of <code>manifold</code>? I'm confused about the type of everything here</p>",
        "id": 164913667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557053029
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">structure_groupoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">members</span>      <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">local_homeomorph</span> <span class=\"n\">α</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">comp</span>         <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">e</span> <span class=\"n\">e&#39;</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">α</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">members</span> <span class=\"bp\">→</span> <span class=\"n\">e&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">members</span> <span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"bp\">→</span><span class=\"err\">ₕ</span> <span class=\"n\">e&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">members</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inv</span>          <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">α</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">members</span> <span class=\"bp\">→</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"err\">∈</span> <span class=\"n\">members</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">id_mem</span>       <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">α</span> <span class=\"err\">∈</span> <span class=\"n\">members</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">locality</span>     <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">α</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">,</span> <span class=\"bp\">∃</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span>\n                  <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">restr</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">members</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">members</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">eq_on_source</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"n\">e&#39;</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">α</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">members</span> <span class=\"bp\">→</span> <span class=\"n\">e&#39;</span> <span class=\"bp\">≈</span> <span class=\"n\">e</span> <span class=\"bp\">→</span> <span class=\"n\">e&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">members</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">manifold</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">structure_groupoid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">chart</span>  <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">local_homeomorph</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">compat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">e</span> <span class=\"n\">e&#39;</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">chart</span> <span class=\"bp\">→</span> <span class=\"n\">e&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">chart</span> <span class=\"bp\">→</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">→</span><span class=\"err\">ₕ</span> <span class=\"n\">e&#39;</span> <span class=\"err\">∈</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">cover</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∃</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">chart</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>One could also go for a manifold structure just by picking the charts and the cover condition (this would be a <code>has_chart</code> class, say, similar to <code>has_add</code> and friends), and say that the manifold structure is compatible with a given groupoid if the compat condition holds (in the same way as one can add properties extending <code>has_add</code> making it into a group, a ring, a module, and so on).</p>",
        "id": 164915110,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557055459
    },
    {
        "content": "<p>Okay, I see. I guess this definition of <code>manifold</code> differs from the earlier one though, since <code>α</code> is implicit now but the other one had three explicit args</p>",
        "id": 164918445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557061248
    },
    {
        "content": "<p>The order of inference still seems a bit weird to me. Can't manifolds have multiple model vector spaces? Like a manifold with different dimensions at different points</p>",
        "id": 164918467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557061320
    },
    {
        "content": "<p>Yes, you're right. I had tried to make the argument explicit to see if it made a difference, but it didn't so I came back to my original definition with alpha implicit.</p>",
        "id": 164918521,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557061347
    },
    {
        "content": "<p>It seems pretty natural to me that you should say M is a C^1 R^n manifold, and both R,n,M are required args</p>",
        "id": 164918552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557061442
    },
    {
        "content": "<p>In the most standard definition, the model space is the same everywhere (and so the dimension is the same everywhere). If you really want to have a manifold with different local dimensions with this definition, you can by taking as a model space the union of all R^n over varying n, but this is not very natural.</p>",
        "id": 164918598,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557061452
    },
    {
        "content": "<p>that's not a vector space</p>",
        "id": 164918604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557061472
    },
    {
        "content": "<p>The thing is that the groupoid <code>G</code> already contains the information about alpha.</p>",
        "id": 164918609,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557061491
    },
    {
        "content": "<p>The model space does not need to be a vector space (and in many applications it isn't)</p>",
        "id": 164918627,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557061510
    },
    {
        "content": "<p>An important example to keep in mind, however, is a complex manifold of dimension <code>n</code>, modelled over <code>C^n</code>, that you also want to think of as a manifold of dimension <code>2n</code> modelled over <code>R^{2n}</code>. So not everything can be implicit.</p>",
        "id": 164918923,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557061954
    },
    {
        "content": "<p>I think I want this definition to be explicit in all the args k E G M</p>",
        "id": 164918936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557062003
    },
    {
        "content": "<p>but you should keep things variable when possible. For example <code>tangent_space_unfolded</code> seems to be unnecessarily specializing on the groupoid</p>",
        "id": 164918986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557062067
    },
    {
        "content": "<p>Even if there is \"only one\" model space up to isomorphism doesn't mean there's only one up to defeq</p>",
        "id": 164919128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557062301
    },
    {
        "content": "<p>In particular I'm sure there will be ways to combine stuff in mathlib to get other isomorphic things like (R^2)^n that we also want to talk about</p>",
        "id": 164919149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557062373
    },
    {
        "content": "<p>You want to be able to speak of the tangent space to many manifolds, for instance to C^infty manifolds or to contact manifolds. If there is an instance saying that a C^infty manifold is a C^1 manifold, or that a contact manifold is a C^1 manifold, then you get the tangent space for all of them at once.</p>",
        "id": 164920531,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557064669
    },
    {
        "content": "<p>I mean that you have specialized to C^1 but the definition works in any groupoid, or at least that part of it does</p>",
        "id": 164922955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557068344
    },
    {
        "content": "<p>Also, given that the C^1 groupoid is data here, I think that those instances you just said are going to cause diamond problems</p>",
        "id": 164923063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557068516
    },
    {
        "content": "<p>Looking at your definition of manifold, it seems like <code>G</code> isn't actually necessary to define the manifold itself. You can have one manifold structure and assert that it is compatible with a variety of groupoids</p>",
        "id": 164923205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557068696
    },
    {
        "content": "<p>That also solves the problem of these composite constraints in the typeclass, since you then have <code>[manifold A B] [is_C1_manifold A B]</code> instead of <code>[manifold A (C1_groupoid A) B]</code></p>",
        "id": 164923296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557068812
    },
    {
        "content": "<p>where <code>is_C1_manifold</code> is a Prop</p>",
        "id": 164923307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557068828
    },
    {
        "content": "<p>I agree it is a good idea to separate the manifold structure, i.e., the data given by the charts, from the regularity of the charts, i.e., the fact that the charts belong to some groupoid. I'll try this route, thanks!</p>",
        "id": 164923427,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557069061
    },
    {
        "content": "<p>In fact, I am not so sure I gain anything with this. The two options are</p>\n<ul>\n<li>Just a typeclass <code>[manifold A G B]</code>, which contains data (the charts) and a proposition (the fact that the changes of charts belong to <code>G</code>)</li>\n<li>Two typeclasses, <code>[manifold A B]</code> containing the charts, and <code>[has_smoothness_class A G B]</code> (assuming <code>[manifold A B]</code>), which is only Prop, asserting that the changes of charts belong to <code>G</code>.</li>\n</ul>\n<p>Whe one sets up instances, with the second point of view the set of charts is fixed, and one only asserts, say, that if a manifold is C^oo then it is C^1 for the same charts. In the first approach, one would get an instance from <code>[manifold A (C^oo) B]</code> to <code>[manifold A C^1 B]</code>, keeping the same charts but asserting that they belong to the larger groupoid <code>C^1</code>. I don't see why the first approach would give rise to diamonds, as the data between the instances does not change, so whatever the path between the instances one should get defeq stuff, right?</p>",
        "id": 164924256,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557070466
    },
    {
        "content": "<p>In the first approach, the manifold itself is different when it is inferred by a different route</p>",
        "id": 164925952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557073234
    },
    {
        "content": "<p>because the manifold instance depends on G</p>",
        "id": 164925958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557073244
    },
    {
        "content": "<p>I guess you are saying that the typeclass instance itself might not be defeq but the <code>charts</code> projection is</p>",
        "id": 164926035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557073342
    },
    {
        "content": "<p>I don't get it. The manifold is made of data (the charts) and Props. Whatever way you go, you get the same data (it does not change through the instances), and the props are irrelevant. How could it not be defeq?</p>",
        "id": 164926046,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557073368
    },
    {
        "content": "<p>The manifold lives in a different type</p>",
        "id": 164926065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557073410
    },
    {
        "content": "<p><code>manifold A (C1_groupoid A (C1_of_C^oo)) B</code> vs <code>manifold A (C1_groupoid A (C1_of_C^2 (C^2_of_C^oo))) B</code> or something</p>",
        "id": 164926120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557073472
    },
    {
        "content": "<p>because the dependencies are different, these can't even be propositionally equal</p>",
        "id": 164926147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557073520
    },
    {
        "content": "<p>I still don't get it, sorry, I am a little bit slow. Suppose you have three instances</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">C1_of_C3</span> <span class=\"o\">[</span><span class=\"n\">manifold</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"err\">^</span><span class=\"mi\">3</span><span class=\"bp\">_</span><span class=\"n\">groupoid</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">manifold</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"err\">^</span><span class=\"mi\">1</span><span class=\"bp\">_</span><span class=\"n\">groupoid</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">M</span>\n<span class=\"kn\">instance</span> <span class=\"n\">C2_of_C3</span> <span class=\"o\">[</span><span class=\"n\">manifold</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"err\">^</span><span class=\"mi\">3</span><span class=\"bp\">_</span><span class=\"n\">groupoid</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">manifold</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"bp\">_</span><span class=\"n\">groupoid</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">M</span>\n<span class=\"kn\">instance</span> <span class=\"n\">C1_of_C2</span> <span class=\"o\">[</span><span class=\"n\">manifold</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"err\">^</span><span class=\"mi\">2</span><span class=\"bp\">_</span><span class=\"n\">groupoid</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">manifold</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"err\">^</span><span class=\"mi\">1</span><span class=\"bp\">_</span><span class=\"n\">groupoid</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">M</span>\n</pre></div>\n\n\n<p>Then the path C1_of_C3 seems to me to be completely equivalent to the composition of C2_of_C3 and C1_of_C2. And the types do not seem to depend on the chosen path.</p>",
        "id": 164927540,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557075834
    },
    {
        "content": "<p>Actually I think I'm the one that's slow. Feel free to ignore my ramblings, I must be tired. I think you are right. However, this kind of instance search seems like a bad idea - there are lots and lots of values of k in C^k, and I'm sure in the right context you will be able to get some silliness like a search for <code>has_zero nat</code> ending up at <code>manifold (C^57_groupoid R) nat</code></p>",
        "id": 164928029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1557076639
    },
    {
        "content": "<p>I am only planning to register the ones with 0, 1 and infinity. And prove the general statement, but not register it as an instance (if necessary, it can be registered locally).</p>",
        "id": 164928400,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1557077361
    },
    {
        "content": "<p>What is the purpose of <code>out_param</code>? It says something about output parameters in typeclasses but in <code>has_insert α γ</code> the first parameter is <code>out_param</code>.</p>",
        "id": 193281536,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586329550
    },
    {
        "content": "<p>I'm trying to turn <code>singleton</code> into a typeclass <code>has_singleton</code> + <code>lawful_singleton</code>.</p>",
        "id": 193281595,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586329575
    },
    {
        "content": "<p>So that we can have <code>{a} = {x | x = a}</code></p>",
        "id": 193281613,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586329604
    },
    {
        "content": "<p>It seems that Lean interprets <code>{x}</code> as <code>insert x ∅</code>, not as <code>singleton x</code>.</p>",
        "id": 193282260,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586330156
    },
    {
        "content": "<p>Yup, there are plans to change this... but I don't think there's a PR yet. I think Mario has a PR related to this to core lean (about how <code>{x,y, ..., z}</code> is defined</p>",
        "id": 193282600,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1586330389
    },
    {
        "content": "<p>man, a lot of proofs would break (at least those that I write, because I never use <code>simp</code>)</p>",
        "id": 193282695,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1586330459
    },
    {
        "content": "<p>I thought that it already calls <code>singleton</code>, and we just have to change <code>def singleton</code> in the library. I was wrong, so let's wait for Mario (I don't want to touch C++ lean code).</p>",
        "id": 193282732,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586330496
    },
    {
        "content": "<p>core lean doesn't mean C++ lean code</p>",
        "id": 193282820,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1586330548
    },
    {
        "content": "<p>If you use <code>singleton</code>, then you probably use <code>mem_singleton_iff</code>. We'll need to change its proof to <code>iff.rfl</code>, then most proofs should work.</p>",
        "id": 193282824,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586330550
    },
    {
        "content": "<p>Parsing of <code>{x, y, ...}</code> happens in C++.</p>",
        "id": 193282837,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586330566
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/pull/153/files\" title=\"https://github.com/leanprover-community/lean/pull/153/files\">https://github.com/leanprover-community/lean/pull/153/files</a></p>",
        "id": 193282860,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586330587
    },
    {
        "content": "<p>oh, interesting</p>",
        "id": 193282888,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1586330611
    },
    {
        "content": "<p>Even more interesting: <em>parsing</em> of <code>{x}</code> calls <code>singleton</code> but <em>pretty printing</em> relies on <code>singleton x = insert x ∅</code>.</p>",
        "id": 193283346,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586330933
    },
    {
        "content": "<p>So if I redefine <code>singleton x</code>, then <code>{x}</code> in the input will parse as <code>singleton x</code>, then printed as <code>singleton x</code> while <code>insert x ∅</code>  will be printed as <code>{x}</code>.</p>",
        "id": 193283504,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586331030
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span></p>",
        "id": 193283512,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586331037
    },
    {
        "content": "<p>The C++ change is already done and in the PR queue</p>",
        "id": 193283574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331094
    },
    {
        "content": "<p>(it's broken because C++11 but that's another matter)</p>",
        "id": 193283584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331107
    },
    {
        "content": "<p>the change you are talking about is entirely in lean</p>",
        "id": 193283646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331129
    },
    {
        "content": "<p>I don't know whether it should be okay to have <code>insert x empty</code>get printed as <code>{x}</code> or not. It basically boils down to whether we think we can reliably retain that form for literals</p>",
        "id": 193283775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331242
    },
    {
        "content": "<p>It seems that you're changing the parser, not the printer.</p>",
        "id": 193283826,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586331281
    },
    {
        "content": "<p>I would expect things like <code>simp</code> to easily break this (rewriting the inner <code>singleton a</code> to <code>insert a empty</code> in order to have a more uniform layout) and then the printer will give you the messy version</p>",
        "id": 193283836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331291
    },
    {
        "content": "<p>The change in the PR is only about parsing</p>",
        "id": 193283867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331317
    },
    {
        "content": "<p>Here I'm talking about the printing issue you pointed out</p>",
        "id": 193283889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331338
    },
    {
        "content": "<p>The problem is that <code>singleton x</code> is printed as <code>singleton x</code>, not <code>{x}</code>.</p>",
        "id": 193283952,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586331365
    },
    {
        "content": "<p>I'm joining the conversation midway, but printing <code>insert x empty</code> as <code>{x}</code> is what Isabelle does. Likewise, <code>insert x (insert y empty)</code> is printed as <code>{x, y}</code>. It works well in practice.</p>",
        "id": 193283955,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1586331367
    },
    {
        "content": "<p>and I should revise my earlier statement - if you want to change the printing behavior that's a C++ change</p>",
        "id": 193283961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331372
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121058\">@Jasmin Blanchette</span> the issue is the lack of consistency between parser and printer here</p>",
        "id": 193283981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331403
    },
    {
        "content": "<p>I would bet the printer is currently \"forgiving\" and will use the sugared notation for either of <code>insert ... insert singleton</code> and <code>insert ... insert empty</code></p>",
        "id": 193284008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331439
    },
    {
        "content": "<p>but the parser can't be round-tripping in this situation</p>",
        "id": 193284023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331462
    },
    {
        "content": "<p>No, I tried to redefine <code>singleton</code>, and the printer is not forgiving.</p>",
        "id": 193284103,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586331530
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"mi\">3</span> <span class=\"err\">∅</span><span class=\"o\">)):</span><span class=\"n\">set</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"c1\">-- {3, 2, 1} : set ℕ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"mi\">3</span><span class=\"o\">)):</span><span class=\"n\">set</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"c1\">-- {3, 2, 1} : set ℕ</span>\n</pre></div>",
        "id": 193284143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331556
    },
    {
        "content": "<p>Did you redefine <code>singleton</code>?</p>",
        "id": 193284159,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586331579
    },
    {
        "content": "<p>no, this is stock lean</p>",
        "id": 193284161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331588
    },
    {
        "content": "<p>If you redefine <code>singleton</code>, then it stops working.</p>",
        "id": 193284212,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586331608
    },
    {
        "content": "<p>I wouldn't mind if <code>insert x empty</code> doesn't print as <code>{x}</code>. If <code>{x}</code> is meant to be <code>singleton x</code> and that is no longer defeq to <code>insert x empty</code> I think it is actually a feature if the printer doesn't hide that.</p>",
        "id": 193284510,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1586331845
    },
    {
        "content": "<p>Here's a MWE subset of core to demonstrate the printing behavior:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">prelude</span>\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"n\">class</span> <span class=\"n\">has_emptyc</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">emptyc</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">out_param</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n<span class=\"n\">class</span> <span class=\"n\">has_insert</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n<span class=\"kn\">export</span> <span class=\"n\">has_insert</span> <span class=\"o\">(</span><span class=\"n\">insert</span><span class=\"o\">)</span>\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"err\">∅</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">has_emptyc</span><span class=\"bp\">.</span><span class=\"n\">emptyc</span> <span class=\"bp\">_</span>\n<span class=\"n\">def</span> <span class=\"n\">singleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_emptyc</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_insert</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_insert</span><span class=\"bp\">.</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">has_emptyc</span><span class=\"bp\">.</span><span class=\"n\">emptyc</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_emptyc</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_insert</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">c</span> <span class=\"err\">∅</span><span class=\"o\">)):</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- {c, b, a} : γ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"n\">c</span><span class=\"o\">)):</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- {c, b, a} : γ</span>\n</pre></div>",
        "id": 193284540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331878
    },
    {
        "content": "<p>Changing the definition of <code>singleton</code> doesn't affect parsing or printing:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">prelude</span>\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"n\">class</span> <span class=\"n\">has_emptyc</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">emptyc</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">out_param</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n<span class=\"n\">class</span> <span class=\"n\">has_insert</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n<span class=\"kn\">export</span> <span class=\"n\">has_insert</span> <span class=\"o\">(</span><span class=\"n\">insert</span><span class=\"o\">)</span>\n<span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"err\">∅</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">has_emptyc</span><span class=\"bp\">.</span><span class=\"n\">emptyc</span> <span class=\"bp\">_</span>\n<span class=\"n\">def</span> <span class=\"n\">singleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_emptyc</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_insert</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_insert</span><span class=\"bp\">.</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">has_insert</span><span class=\"bp\">.</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">has_emptyc</span><span class=\"bp\">.</span><span class=\"n\">emptyc</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_emptyc</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_insert</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">c</span> <span class=\"err\">∅</span><span class=\"o\">)):</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- {c, b, a} : γ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"n\">c</span><span class=\"o\">)):</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- {c, b, a} : γ</span>\n</pre></div>",
        "id": 193284577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586331931
    },
    {
        "content": "<p>Using a typeclass version breaks it:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">has_singleton</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">singleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_singleton</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_singleton</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"bp\">_</span> <span class=\"n\">a</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_emptyc</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_insert</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_singleton</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">c</span> <span class=\"err\">∅</span><span class=\"o\">)):</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- {c, b, a} : γ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"n\">c</span><span class=\"o\">)):</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- insert a (insert b (singleton c)) : γ</span>\n</pre></div>\n\n\n<p>but this is clearly because it's counting arguments wrong:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">has_singleton</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">singleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_singleton</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_singleton</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_singleton</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"bp\">_</span> <span class=\"n\">a</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_emptyc</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_insert</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_singleton</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">c</span> <span class=\"err\">∅</span><span class=\"o\">)):</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- {c, b, a} : γ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"n\">c</span><span class=\"o\">)):</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- {c, b, a} : γ</span>\n</pre></div>",
        "id": 193284925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586332179
    },
    {
        "content": "<p>it presumably relies on the contents of the singleton to be in argument # 5</p>",
        "id": 193285010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586332234
    },
    {
        "content": "<p>Thank you! I only tried the typeclass version, and didn't guess that it relies on argument index.</p>",
        "id": 193285050,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586332276
    },
    {
        "content": "<p>Yes, <code>frontends/lean/pp.cpp</code> has <code>is_constant(get_app_fn(e), get_singleton_name()) &amp;&amp; get_app_num_args(e) == 5</code></p>",
        "id": 193285162,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586332364
    },
    {
        "content": "<p>I can't test it because the other bug gets in the way, but I would expect <code>export has_singleton (singleton)</code> to also break printing, since now the name of the singleton constructor is <code>has_singleton.singleton</code> instead of <code>_root_.singleton</code></p>",
        "id": 193285225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586332422
    },
    {
        "content": "<p>Thank you for the explanation. I think that now I know how to do it.</p>",
        "id": 193285356,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586332516
    },
    {
        "content": "<p>BTW, why our notation for <code>sUnion</code> doesn't conflict with the one from stdlib?</p>",
        "id": 193285391,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586332550
    },
    {
        "content": "<p>Ignore.</p>",
        "id": 193285491,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586332602
    },
    {
        "content": "<p>heh, problem solved:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"kn\">inductive</span> <span class=\"n\">unit</span> <span class=\"bp\">|</span> <span class=\"n\">star</span>\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">unit</span><span class=\"bp\">.</span><span class=\"n\">star</span>\n<span class=\"n\">def</span> <span class=\"n\">singleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_singleton</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">unit</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_singleton</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"bp\">_</span> <span class=\"n\">a</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_emptyc</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_insert</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_singleton</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">c</span> <span class=\"err\">∅</span><span class=\"o\">)):</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- {c, b, a} : γ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"n\">c</span><span class=\"o\">)):</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- {c, b, a} : γ</span>\n</pre></div>",
        "id": 193285848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586332822
    },
    {
        "content": "<p>Isn't it easier to change a <code>5</code> into a <code>4</code>?</p>",
        "id": 193285919,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1586332862
    },
    {
        "content": "<p>not from lean</p>",
        "id": 193285933,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586332869
    },
    {
        "content": "<p>Sure... but we are changing core Lean anyway</p>",
        "id": 193285956,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1586332881
    },
    {
        "content": "<p>I wonder if it is worth making <code>unit</code> a class for implicit dummy args like this</p>",
        "id": 193285970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586332889
    },
    {
        "content": "<p>more fun with confusing the printer:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"kn\">inductive</span> <span class=\"n\">unit</span> <span class=\"bp\">|</span> <span class=\"n\">star</span>\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">unit</span><span class=\"bp\">.</span><span class=\"n\">star</span>\n<span class=\"n\">def</span> <span class=\"n\">singleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_singleton</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">unit</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"n\">has_singleton</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"bp\">_</span> <span class=\"n\">a</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_emptyc</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_insert</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_singleton</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">c</span> <span class=\"err\">∅</span><span class=\"o\">)):</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- {c, b, a} : γ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">singleton</span> <span class=\"n\">c</span><span class=\"o\">)):</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"c1\">-- {(), b, a} : γ</span>\n</pre></div>",
        "id": 193286404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586333185
    },
    {
        "content": "<p>also amusing that lean already knows that <code>unit</code> is printed as <code>()</code></p>",
        "id": 193286432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586333205
    },
    {
        "content": "<p>so the printer has access to definitions of stuffs?</p>",
        "id": 193286752,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1586333425
    },
    {
        "content": "<p>Thinking about this a bit more, I think I want the printer to stay the way it is w.r.t. sugaring both kinds of enumerated set. There are already a ton of places where the printer doesn't round trip, for example when there are non-canonical instances, or when you mix <code>succ</code> and <code>bit0</code>/<code>bit1</code></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"c1\">-- 1 : ℕ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">has_one</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">_</span> <span class=\"c1\">-- 1 : ℕ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"c1\">-- 2 : ℕ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_one</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"c1\">-- nat.succ 1 : ℕ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">bit1</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_one</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"c1\">-- 3 : ℕ</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">bit1</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"c1\">-- 3 : ℕ</span>\n</pre></div>",
        "id": 193286920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586333537
    },
    {
        "content": "<p>The printer is completely dumbly going over the term thinking it knows what's up, but you can easily mislead it</p>",
        "id": 193286986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586333600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> But if we implement the changes then <code>singleton x</code> is not defeq to <code>insert x ∅</code>, right? So <code>{x} = {x}</code> is not provable by <code>rfl</code>...</p>",
        "id": 193287022,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1586333635
    },
    {
        "content": "<p>did you think we had that property before?</p>",
        "id": 193287086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586333666
    },
    {
        "content": "<p>Why not?</p>",
        "id": 193287100,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586333680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/out_param/near/193287086\" title=\"#narrow/stream/113488-general/topic/out_param/near/193287086\">said</a>:</p>\n<blockquote>\n<p>did you think we had that property before?</p>\n</blockquote>\n<p>Maybe not, but this one is going to trip up a lot of people</p>",
        "id": 193287149,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1586333718
    },
    {
        "content": "<p>Why can't we just make the printer not do fancy things with <code>insert x ∅</code>? And have a <code>simp</code>-lemma that turns it into <code>singleton x</code></p>",
        "id": 193287182,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1586333749
    },
    {
        "content": "<p>I think that most people won't meet <code>insert x empty</code></p>",
        "id": 193287185,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586333752
    },
    {
        "content": "<p>Hmmm, that's probably right</p>",
        "id": 193287265,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1586333796
    },
    {
        "content": "<p>I think it's fine to say \"most people won't meet it\" but I would prefer for the failure mode to be confusing printing rather than a 10x blowup of the printed term.</p>",
        "id": 193287443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586333922
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">has_one</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">has_one</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"c1\">-- ⊢ 1 = 1</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"c1\">-- fail</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 193287471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586333945
    },
    {
        "content": "<p>it's trivially easy to come up with examples along these lines</p>",
        "id": 193287542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586333984
    },
    {
        "content": "<p>Of course</p>",
        "id": 193287550,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1586333997
    },
    {
        "content": "<p>the printer should really be viewed as a \"best effort\" thing</p>",
        "id": 193287592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586334004
    },
    {
        "content": "<p>at least as long as you aren't using <code>pp.all</code></p>",
        "id": 193287613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586334016
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Do you have a Lean built with your <a href=\"https://github.com/leanprover-community/lean/issues/153\" title=\"https://github.com/leanprover-community/lean/issues/153\">lean#153</a> applied?</p>",
        "id": 193287653,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586334058
    },
    {
        "content": "<p>no, why?</p>",
        "id": 193287692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586334094
    },
    {
        "content": "<p>I have a pretty good idea what will happen</p>",
        "id": 193287709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586334114
    },
    {
        "content": "<p>I wonder how <code>#check ({0, 1} : set nat)</code> will work.</p>",
        "id": 193287768,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586334137
    },
    {
        "content": "<p>it will produce the term <code>insert 0 (singleton 1)</code></p>",
        "id": 193287788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586334153
    },
    {
        "content": "<p>And how will it be pretty-printed?</p>",
        "id": 193287805,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586334176
    },
    {
        "content": "<p><code>{0, 1}</code> or <code>{1, 0}</code>?</p>",
        "id": 193287830,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1586334195
    },
    {
        "content": "<p>Actually, I guess I should have fixed the printer too in that PR since the printer will indeed print <code>{1, 0}</code></p>",
        "id": 193287831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586334196
    }
]
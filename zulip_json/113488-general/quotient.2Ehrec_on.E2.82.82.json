[
    {
        "content": "<p>I've got a <a href=\"https://github.com/spl/lean-finmap/blob/fb3f562de05059f136f855b88bf616c8aac7f365/src/data/multiset/dict.lean#L162-L172\" target=\"_blank\" title=\"https://github.com/spl/lean-finmap/blob/fb3f562de05059f136f855b88bf616c8aac7f365/src/data/multiset/dict.lean#L162-L172\">definition</a>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">kunion</span> <span class=\"o\">:</span> <span class=\"n\">m₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">m₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">hrec_on₂</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)),</span> <span class=\"n\">m₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">m₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n  <span class=\"n\">m₁</span> <span class=\"n\">m₂</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">(</span><span class=\"n\">d₁</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d₂</span> <span class=\"o\">:</span> <span class=\"n\">l₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">),</span> <span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">kunion</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"err\">$</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">l₃</span> <span class=\"n\">l₄</span> <span class=\"n\">p₁₃</span> <span class=\"n\">p₂₄</span><span class=\"o\">,</span>\n    <span class=\"n\">hfunext</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">perm_nodup_keys</span> <span class=\"n\">p₁₃</span><span class=\"o\">)</span> <span class=\"err\">$</span>\n      <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">d₁</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d₃</span> <span class=\"o\">:</span> <span class=\"n\">l₃</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">hfunext</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">perm_nodup_keys</span> <span class=\"n\">p₂₄</span><span class=\"o\">)</span> <span class=\"err\">$</span>\n        <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">d₂</span> <span class=\"o\">:</span> <span class=\"n\">l₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d₄</span> <span class=\"o\">:</span> <span class=\"n\">l₄</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n        <span class=\"n\">heq_of_eq</span> <span class=\"err\">$</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"err\">$</span> <span class=\"n\">perm_kunion</span> <span class=\"n\">d₂</span> <span class=\"n\">d₄</span> <span class=\"n\">p₁₃</span> <span class=\"n\">p₂₄</span>\n\n<span class=\"n\">local</span> <span class=\"kn\">infixr</span> <span class=\"bp\">`</span> <span class=\"n\">k</span><span class=\"err\">∪</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">67</span> <span class=\"o\">:=</span> <span class=\"n\">kunion</span>\n</pre></div>\n\n\n<p>and I want to prove the left and right units:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">zero_kunion</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">),</span> <span class=\"n\">nodup_keys_zero</span> <span class=\"n\">k</span><span class=\"err\">∪</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">kunion_zero</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">),</span> <span class=\"n\">d</span> <span class=\"n\">k</span><span class=\"err\">∪</span> <span class=\"n\">nodup_keys_zero</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n</pre></div>\n\n\n<p>I'm stuck on how to proceed. If I use <code>quotient.induction_on m</code>, I just unfold until I get down to <code>quot.rec_on ↑(hd :: tl)</code> or <code>quot.rec_on ↑nil</code>, but I don't know how to go further. (At one point, I believe I even made the simplifier loop infinitely.)</p>\n<p>Any suggestions on how to prove these?</p>",
        "id": 130971695,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533553785
    },
    {
        "content": "<p>Wow, that's a weird notation</p>",
        "id": 130971867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533553956
    },
    {
        "content": "<p>does it have to be a partial function?</p>",
        "id": 130971872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533553965
    },
    {
        "content": "<blockquote>\n<p>does it have to be a partial function?</p>\n</blockquote>\n<p>I don't follow you.</p>",
        "id": 130971983,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533554138
    },
    {
        "content": "<p>you could make it return empty when the inputs don't have <code>nodup_keys</code></p>",
        "id": 130972034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533554176
    },
    {
        "content": "<p>or it could be a <code>roption</code> if you are worried about the performance cost of checking <code>nodup_keys</code></p>",
        "id": 130972054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533554233
    },
    {
        "content": "<p>Sorry, Mario, your  use of “it” in multiple places is a bit too vague for me. Are you suggesting I use a different definition for <code>kunion</code>? If so, what is the type signature you're referring to?</p>",
        "id": 130972218,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533554464
    },
    {
        "content": "<p>Btw, I'm not asking for a completed solution. You're welcome to give me only hints or suggestions. <span class=\"emoji emoji-263a\" title=\"smile\">:smile:</span></p>",
        "id": 130972526,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533554920
    },
    {
        "content": "<p>I think <code>def kunion : multiset (sigma β) → multiset (sigma β) → roption (multiset (sigma β))</code> and then prove that <code>kunion</code> is defined exactly when each <code>multiset</code> is <code>nodup_keys</code></p>",
        "id": 130972544,
        "sender_full_name": "Reid Barton",
        "timestamp": 1533554989
    },
    {
        "content": "<p>Reid: Hmm, okay, thanks.</p>",
        "id": 130972612,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533555069
    },
    {
        "content": "<p>And what's the advantage to this approach? Is it simplicity of the definition and related theorems or performance or both?</p>",
        "id": 130972673,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533555136
    },
    {
        "content": "<p>Then you can avoid all this dependent eliminator stuff... although it's not clear to me whether your problem is related to this</p>",
        "id": 130972677,
        "sender_full_name": "Reid Barton",
        "timestamp": 1533555149
    },
    {
        "content": "<p>Okay, well, I'll give it a shot.</p>",
        "id": 130972701,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533555197
    },
    {
        "content": "<p>Just proving at <code> quotient.hrec_on_beta</code> lemma might help.</p>",
        "id": 130972702,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1533555206
    },
    {
        "content": "<p>Yes. Is that <code>↑</code> just <code>quotient.mk</code>?</p>",
        "id": 130972707,
        "sender_full_name": "Reid Barton",
        "timestamp": 1533555240
    },
    {
        "content": "<p>Yes, I think so.</p>",
        "id": 130972756,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533555262
    },
    {
        "content": "<p>Chris: I wondered the same thing. I'm not sure how to start with that.</p>",
        "id": 130972765,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533555279
    },
    {
        "content": "<p>Well, <code>quotient.rec_on</code> applied to <code>quotient.mk</code> should reduce...</p>",
        "id": 130972790,
        "sender_full_name": "Reid Barton",
        "timestamp": 1533555306
    },
    {
        "content": "<p>Or use <code>show</code></p>",
        "id": 130972792,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1533555308
    },
    {
        "content": "<p>I suppose it would look something like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">ind_beta</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ind</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"n\">a</span>\n</pre></div>",
        "id": 130972893,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533555444
    },
    {
        "content": "<p>that is trivially true, since both sides are propositions</p>",
        "id": 130974037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533556808
    },
    {
        "content": "<p>The advantage of using <code>roption</code> is avoiding all the <code>hrec</code> mess. I've had to define partial functions over quotients before, and I wish I'd thought of this then</p>",
        "id": 130974063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533556864
    },
    {
        "content": "<blockquote>\n<p>that is trivially true, since both sides are propositions</p>\n</blockquote>\n<p>Are you referring to <code>quot.ind_beta</code>, which is in the core library, or something else?</p>\n<blockquote>\n<p>The advantage of using <code>roption</code> is avoiding all the <code>hrec</code> mess. I've had to define partial functions over quotients before, and I wish I'd thought of this then</p>\n</blockquote>\n<p>Great! I'm working on it now.</p>",
        "id": 130974158,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533556987
    },
    {
        "content": "<p>I think someone probably copied <code>lift_beta</code> to <code>ind_beta</code> without realizing it was rather unnecessary.</p>",
        "id": 130974410,
        "sender_full_name": "Reid Barton",
        "timestamp": 1533557311
    },
    {
        "content": "<p>Ah! I see what you're saying now. I didn't look that closely at <code>ind_beta</code>.</p>",
        "id": 130974532,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533557458
    },
    {
        "content": "<p>This is definitely a much nicer definition:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">kunion&#39;</span> <span class=\"o\">(</span><span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">roption</span> <span class=\"o\">(</span><span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_on₂</span> <span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">,</span> <span class=\"n\">roption</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">∧</span> <span class=\"n\">l₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">kunion</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">))))</span> <span class=\"err\">$</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">l₃</span> <span class=\"n\">l₄</span> <span class=\"n\">p₁₃</span> <span class=\"n\">p₂₄</span><span class=\"o\">,</span> <span class=\"n\">roption</span><span class=\"bp\">.</span><span class=\"n\">ext&#39;</span>\n    <span class=\"o\">(</span><span class=\"n\">and_congr</span> <span class=\"o\">(</span><span class=\"n\">perm_nodup_keys</span> <span class=\"n\">p₁₃</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">perm_nodup_keys</span> <span class=\"n\">p₂₄</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">d₁</span><span class=\"o\">,</span> <span class=\"n\">d₂</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">d₃</span><span class=\"o\">,</span> <span class=\"n\">d₄</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"err\">$</span> <span class=\"n\">perm_kunion</span> <span class=\"n\">d₂</span> <span class=\"n\">d₄</span> <span class=\"n\">p₁₃</span> <span class=\"n\">p₂₄</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 130974767,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533557668
    },
    {
        "content": "<p>so now the theorem you want is either <code>m k∪ 0 = some m</code> or <code>m ∈ m k∪ 0</code> (they are equivalent)</p>",
        "id": 130974979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533557934
    },
    {
        "content": "<p>Right.</p>",
        "id": 130975110,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533558040
    },
    {
        "content": "<p>and the coercion lemma you want says <code>l₁.nodup_keys → l₂.nodup_keys → ↑l₁ k∪ ↑l₂ = some (l₁.kunion l₂)</code></p>",
        "id": 130975212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533558141
    },
    {
        "content": "<p>Got that, thanks. How should I coerce the 0 (<code>multiset.zero</code>) for <code>kunion' 0 ↑l</code>?</p>",
        "id": 130975700,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533558831
    },
    {
        "content": "<p>If I do <code>simp [has_zero.zero, multiset.zero]</code>, lean never ends.</p>",
        "id": 130975782,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533558951
    },
    {
        "content": "<p>you can just force it to unfold by applying <code>kunion_coe.trans _</code></p>",
        "id": 130975852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533559020
    },
    {
        "content": "<p>or you can rewrite with <code>coe_nil_eq_zero</code></p>",
        "id": 130975886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533559076
    },
    {
        "content": "<p>The aforementioned theorems:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">zero_kunion</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">),</span> <span class=\"n\">kunion&#39;</span> <span class=\"mi\">0</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">roption</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span> <span class=\"n\">m</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">kunion_coe</span> <span class=\"n\">nodup_keys_zero</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">kunion_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">),</span> <span class=\"n\">kunion&#39;</span> <span class=\"n\">m</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">roption</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span> <span class=\"n\">m</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">kunion_coe</span> <span class=\"n\">d</span> <span class=\"n\">nodup_keys_zero</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 130980496,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533564341
    },
    {
        "content": "<p>One last related question: Now that I have an <code>roption</code>-wrapped <code>multiset</code>, how should I specify theorems that involve the result of <code>kunion'</code>? For example, I had:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">mem_kunion</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">d₁</span> <span class=\"o\">:</span> <span class=\"n\">m₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d₂</span> <span class=\"o\">:</span> <span class=\"n\">m₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">),</span>\n  <span class=\"n\">disjoint</span> <span class=\"n\">m₁</span><span class=\"bp\">.</span><span class=\"n\">keys</span> <span class=\"n\">m₂</span><span class=\"bp\">.</span><span class=\"n\">keys</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">d₁</span> <span class=\"n\">k</span><span class=\"err\">∪</span> <span class=\"n\">d₂</span> <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">m₁</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">m₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on₂</span> <span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">mem_kunion_iff</span>\n</pre></div>\n\n\n<p>Should this become...?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">mem_kunion&#39;</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">d₁</span> <span class=\"o\">:</span> <span class=\"n\">m₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d₂</span> <span class=\"o\">:</span> <span class=\"n\">m₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">),</span>\n  <span class=\"n\">disjoint</span> <span class=\"n\">m₁</span><span class=\"bp\">.</span><span class=\"n\">keys</span> <span class=\"n\">m₂</span><span class=\"bp\">.</span><span class=\"n\">keys</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"err\">∈</span> <span class=\"n\">kunion&#39;</span> <span class=\"n\">m₁</span> <span class=\"n\">m₂</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">m₁</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">m₂</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on₂</span> <span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"n\">dk</span><span class=\"o\">,</span>\n  <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">roption</span><span class=\"bp\">.</span><span class=\"n\">eq_some_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">kunion_coe</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span><span class=\"o\">),</span> <span class=\"n\">mem_kunion_iff</span> <span class=\"n\">dk</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>Specifically, I mean: should I use a pattern like <code>∃ m ∈ kunion' m₁ m₂, ...</code> for theorems like this, or is there a better way?</p>",
        "id": 130981382,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533565302
    },
    {
        "content": "<p>I would take <code>m ∈ kunion' m₁ m₂</code> as a hypothesis and prove <code>s ∈ m ↔ s ∈ m₁ ∨ s ∈ m₂</code></p>",
        "id": 130982225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533566121
    },
    {
        "content": "<p>of course this hypothesis eliminates the need for d1 and d2</p>",
        "id": 130982297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533566168
    },
    {
        "content": "<p>alternatively, you can define <code>kunion</code> as <code>(kunion' m1 m2).get &lt;d1, d2&gt;</code> and have all your old theorems back</p>",
        "id": 130982374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533566276
    },
    {
        "content": "<p>True. I'm not sure which is a better definition to work with. If I were using the <code>multiset</code> interface directly, I would lean towards defining <code>kunion</code> as <code>(kunion' m1 m2).get &lt;d1, d2&gt;</code>. But since it's really meant to be the underlying implementation of <code>finmap</code>, perhaps it's not necessary.</p>",
        "id": 130991221,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533575231
    },
    {
        "content": "<p>Also, do you think I should use <code>roption</code> + <code>quotient.lift_on</code> consistently instead of <code>quotient.hrec_on</code>? I don't have any more uses of <code>quotient.hrec_on₂</code>, but I do have a number of uses of <code>quotient.hrec_on</code>.</p>",
        "id": 130991299,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533575304
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I'd like to get your thoughts on this <span class=\"emoji emoji-1f446\" title=\"point up\">:point_up:</span>. I haven't had any problems with <code>quotient.hrec_on</code> up to now, but maybe things would just be nicer all around if I used <code>roption</code> more. I'm not sure.</p>",
        "id": 131028609,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533628256
    },
    {
        "content": "<p>I think if it works once, it will probably work again</p>",
        "id": 131028618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533628280
    },
    {
        "content": "<p>Also, another option I forgot to mention was to make <code>kunion</code> a nondependent function, using the fact that <code>nodup_keys</code> is decidable</p>",
        "id": 131028672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533628336
    },
    {
        "content": "<p>Just to be clear about what you mean, do you think I should change the defs <a href=\"https://github.com/spl/lean-finmap/blob/fb3f562de05059f136f855b88bf616c8aac7f365/src/data/multiset/dict.lean\" target=\"_blank\" title=\"https://github.com/spl/lean-finmap/blob/fb3f562de05059f136f855b88bf616c8aac7f365/src/data/multiset/dict.lean\">here</a> to use <code>roption</code>?</p>",
        "id": 131028674,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533628341
    },
    {
        "content": "<p>(Just search for <code>hrec_on</code>.)</p>",
        "id": 131028693,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533628393
    },
    {
        "content": "<p>Even if we suppose that checking this is expensive, it doesn't matter if you are just using it as an abstract version so you can prove equations about it</p>",
        "id": 131028697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533628410
    },
    {
        "content": "<blockquote>\n<p>Also, another option I forgot to mention was to make <code>kunion</code> a nondependent function, using the fact that <code>nodup_keys</code> is decidable</p>\n</blockquote>\n<p>What do you mean by this?</p>",
        "id": 131028702,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533628426
    },
    {
        "content": "<p>define <code>kunion m1 m2 = if h : m1.nodup_keys /\\ m2.nodup_keys then (kunion' m1 m2).get h else 0</code></p>",
        "id": 131028797,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533628547
    },
    {
        "content": "<p>That's an interesting suggestion.</p>",
        "id": 131028858,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533628602
    },
    {
        "content": "<p>in fact, even if <code>nodup_keys</code> wasn't decidable you could make this definition anyway noncomputably and just not use it for evaluation</p>",
        "id": 131028874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533628649
    },
    {
        "content": "<p>Hmm, yes, I think I like this definition of <code>kunion</code>. I don't have to pass around the <code>m1.nodup_keys</code> everywhere.</p>",
        "id": 131029010,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533628845
    },
    {
        "content": "<p>Okay, well, I'll play around with it.</p>",
        "id": 131029031,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533628891
    },
    {
        "content": "<p>Yet more alternatively, you could define the subtype. Didn't you have <code>finmap</code> at one point for this?</p>",
        "id": 131029032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533628904
    },
    {
        "content": "<p>I decided to go with the <code>structure</code> for the same reasons <code>finset</code> is a <code>structure</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">finmap</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">nodup_keys</span> <span class=\"o\">:</span> <span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 131029090,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533628943
    },
    {
        "content": "<p>Mainly, for type class instance resolution.</p>",
        "id": 131029097,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533628972
    },
    {
        "content": "<p>that's fine, my point was that you can define <code>finmap.rec_on</code> to encapsulate this definition pattern</p>",
        "id": 131029099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533628982
    },
    {
        "content": "<p>and this way you never have to carry around any proofs since they are embedded in the type</p>",
        "id": 131029112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533629021
    },
    {
        "content": "<p>You mean the <code>if h : m.nodup_keys ... then ... else ...</code> pattern?</p>",
        "id": 131029158,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533629054
    },
    {
        "content": "<p>no, the <code>roption</code> or <code>hrec_on</code> version</p>",
        "id": 131029160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533629068
    },
    {
        "content": "<p>(it doesn't really matter too much which one you use, since it only has to be done once)</p>",
        "id": 131029167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533629097
    },
    {
        "content": "<p>Oh.... I'm awfully dumb today. So, define a <code>finmap.rec_on</code> that takes an <code>roption (multiset (sigma β))</code> to a <code>finmap</code>?</p>",
        "id": 131029228,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533629190
    },
    {
        "content": "<p>Err, actually the arrow goes the other way...</p>",
        "id": 131029236,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533629220
    },
    {
        "content": "<p>Anyway, it'd be a higher-order function.</p>",
        "id": 131029244,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533629260
    },
    {
        "content": "<p>Yeah, I think I see it.</p>",
        "id": 131029247,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533629272
    },
    {
        "content": "<p><code>finmap.rec_on</code> takes a <code>finmap A B</code>, a function <code>list (sigma B) -&gt; C</code>, and a proof that this function is equal up to permutation when the arguments have <code>nodup_keys</code></p>",
        "id": 131029289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533629291
    },
    {
        "content": "<p>Right.</p>",
        "id": 131029296,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533629312
    },
    {
        "content": "<p>So, given that, I would be skipping defining all of the defs and theorems for <code>multiset</code> and define them for only <code>list</code> and <code>finmap</code>?</p>",
        "id": 131029372,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533629454
    },
    {
        "content": "<p>right</p>",
        "id": 131029445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533629612
    },
    {
        "content": "<p>You can reconstruct the multiset definitions from the finmap ones by the <code>if ... else 0</code> trick</p>",
        "id": 131029450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533629636
    },
    {
        "content": "<p>I think multisets are a good stepping stone if you can actually define functions on them, but in your case the functions already have to assume nodup just to be well defined, so they've already jumped to finmap</p>",
        "id": 131029516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533629725
    },
    {
        "content": "<p>That's true.</p>",
        "id": 131029523,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533629751
    },
    {
        "content": "<p>Okay, I'm convinced.</p>",
        "id": 131029576,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533629841
    },
    {
        "content": "<p>I notice you have theorems like <code> s.1 ∈ (m.map_snd f).keys ↔ s.1 ∈ m.keys</code> with several variations. Why isn't this just <code>(m.map_snd f).keys = m.keys</code>?</p>",
        "id": 131029713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533630018
    },
    {
        "content": "<p>Because I use the <code>mem</code> one in the non-<code>mem</code>.</p>",
        "id": 131029750,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533630108
    },
    {
        "content": "<p>I suppose I don't have to.</p>",
        "id": 131029791,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533630130
    },
    {
        "content": "<p>the proof is just <code>map_comp</code></p>",
        "id": 131029808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533630185
    },
    {
        "content": "<p>you shouldn't use <code>mem</code> to try to characterize a multiset, it gets messy</p>",
        "id": 131029819,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533630227
    },
    {
        "content": "<p>The other problem with the <code>map_snd</code>/<code>keys</code> theorems is that I wanted to use it in <code>finmap</code>, but the best I could come up with was using <code>[inhabited (∀ a, β₁ a)]</code>. I'm not happy with that solution.</p>",
        "id": 131029874,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533630300
    },
    {
        "content": "<blockquote>\n<p>the proof is just <code>map_comp</code></p>\n</blockquote>\n<p>The proof of which?</p>",
        "id": 131029887,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533630329
    },
    {
        "content": "<p>I'm really confused about your confusion. It should be provable that <code>(m.map_snd f).keys = m.keys</code>, this makes the last 7 theorems or so unnecessary and it doesn't require any weird assumptions</p>",
        "id": 131029966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533630427
    },
    {
        "content": "<p>Okay, I think I see what you're saying. I'll give it a shot.</p>",
        "id": 131030141,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533630668
    },
    {
        "content": "<p>wait, just the last 4. The ones about <code>(m.map f).keys</code> are a bit awkward because <code>f : sigma B1 -&gt; sigma B2</code> can mingle keys and values in an unpredictable way. How about defining <code>m.map f g</code> where <code>f : A1 -&gt; A2</code> and <code>g : ∀ a, B1 a -&gt; B2 (f a)</code>; then you should be able to prove <code>(m.map f g).keys = m.keys.map f</code> and life is good</p>",
        "id": 131030157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533630713
    },
    {
        "content": "<p>Btw, did you mean <code>map_map</code> instead of <code>map_comp</code>?</p>",
        "id": 131030231,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533630838
    },
    {
        "content": "<p>yes</p>",
        "id": 131030275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533630858
    },
    {
        "content": "<p>it's written backwards for simp lemmas because <code>comp</code> is dumb</p>",
        "id": 131030288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533630885
    },
    {
        "content": "<p>so the name becomes <code>map_map</code> instead of <code>map_comp</code></p>",
        "id": 131030292,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533630897
    },
    {
        "content": "<p>I could only figure out how to do a general 2-arg <code>finmap</code> recursor using <code>quotient.hrec_on₂</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">lrec_on₂</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)},</span> <span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">l₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">l₃</span> <span class=\"n\">l₄</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p₁₃</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span> <span class=\"n\">l₃</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p₂₄</span> <span class=\"o\">:</span> <span class=\"n\">l₂</span> <span class=\"bp\">~</span> <span class=\"n\">l₄</span><span class=\"o\">)</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"n\">d₃</span> <span class=\"n\">d₄</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"n\">d₃</span> <span class=\"n\">d₄</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">hrec_on₂</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)),</span> <span class=\"n\">m₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">m₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">(</span><span class=\"n\">d₁</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d₂</span> <span class=\"o\">:</span> <span class=\"n\">l₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">),</span> <span class=\"n\">φ</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">l₃</span> <span class=\"n\">l₄</span> <span class=\"n\">p₁₃</span> <span class=\"n\">p₂₄</span><span class=\"o\">,</span> <span class=\"n\">hfunext</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_nodup_keys</span> <span class=\"n\">p₁₃</span><span class=\"o\">)</span> <span class=\"err\">$</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">d₁</span> <span class=\"n\">d₃</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">hfunext</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_nodup_keys</span> <span class=\"n\">p₂₄</span><span class=\"o\">)</span> <span class=\"err\">$</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">d₂</span> <span class=\"n\">d₄</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">heq_of_eq</span> <span class=\"err\">$</span> <span class=\"n\">c</span> <span class=\"n\">p₁₃</span> <span class=\"n\">p₂₄</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"n\">d₃</span> <span class=\"n\">d₄</span><span class=\"o\">)</span>\n  <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span>\n</pre></div>\n\n\n<p>I have a general 2-arg <code>finmap.lift_on₂</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">lift_on₂</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)},</span> <span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">l₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">l₃</span> <span class=\"n\">l₄</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p₁₃</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span> <span class=\"n\">l₃</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p₂₄</span> <span class=\"o\">:</span> <span class=\"n\">l₂</span> <span class=\"bp\">~</span> <span class=\"n\">l₄</span><span class=\"o\">)</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"n\">d₃</span> <span class=\"n\">d₄</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"n\">d₃</span> <span class=\"n\">d₄</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">roption</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_on₂</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">,</span> <span class=\"n\">roption</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">∧</span> <span class=\"n\">l₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">d₁</span><span class=\"o\">,</span> <span class=\"n\">d₂</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">l₃</span> <span class=\"n\">l₄</span> <span class=\"n\">p₁₃</span> <span class=\"n\">p₂₄</span><span class=\"o\">,</span> <span class=\"n\">roption</span><span class=\"bp\">.</span><span class=\"n\">ext&#39;</span>\n    <span class=\"o\">(</span><span class=\"n\">and_congr</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_nodup_keys</span> <span class=\"n\">p₁₃</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_nodup_keys</span> <span class=\"n\">p₂₄</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">d₁</span><span class=\"o\">,</span> <span class=\"n\">d₂</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">d₃</span><span class=\"o\">,</span> <span class=\"n\">d₄</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"n\">p₁₃</span> <span class=\"n\">p₂₄</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"n\">d₃</span> <span class=\"n\">d₄</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>But it seems like the <code>roption.dom</code> has a pair of lists, so this only seems useful in combination with <code>quotient.induction_on₂</code>. Is that right? Or can I do better?</p>",
        "id": 131093639,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533714832
    },
    {
        "content": "<p>What does the one arg version look like?</p>",
        "id": 131094611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533716666
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">lrec_on</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)},</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">d₁</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"n\">d₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">hrec_on</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)),</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">),</span> <span class=\"n\">φ</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hfunext</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_nodup_keys</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">heq_of_eq</span> <span class=\"err\">$</span> <span class=\"n\">c</span> <span class=\"n\">p</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span><span class=\"o\">)</span>\n  <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span>\n</pre></div>",
        "id": 131094622,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533716704
    },
    {
        "content": "<p>There are theorems where <code>quotient.induction_on₂</code> needs more than just <code>l₁.nodup_keys</code> and <code>l₂.nodup_keys</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">mem_kunion&#39;</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">d₁</span> <span class=\"o\">:</span> <span class=\"n\">m₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d₂</span> <span class=\"o\">:</span> <span class=\"n\">m₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">),</span>\n  <span class=\"n\">disjoint</span> <span class=\"n\">m₁</span><span class=\"bp\">.</span><span class=\"n\">keys</span> <span class=\"n\">m₂</span><span class=\"bp\">.</span><span class=\"n\">keys</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"err\">∈</span> <span class=\"n\">kunion&#39;</span> <span class=\"n\">m₁</span> <span class=\"n\">m₂</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">↔</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">m₁</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">m₂</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on₂</span> <span class=\"n\">m₁</span> <span class=\"n\">m₂</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"n\">dk</span><span class=\"o\">,</span>\n  <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">roption</span><span class=\"bp\">.</span><span class=\"n\">eq_some_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">kunion_coe</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span><span class=\"o\">),</span> <span class=\"n\">mem_kunion_iff</span> <span class=\"n\">dk</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>So, I think the above <code>finmap.lift_on₂</code> definition makes sense.</p>",
        "id": 131094845,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533717055
    },
    {
        "content": "<p>I would suggest you state <code>lrec_on</code> like this:</p>\n<div class=\"codehilite\"><pre><span></span>protected def lrec_on {γ : Sort*} (f : finmap α β)\n  (φ : list (sigma β) → γ)\n  (c : ∀ {l₁ l₂} (p : l₁ ~ l₂), l₁.nodup_keys → l₂.nodup_keys → φ l₁ = φ l₂) : γ :=\n</pre></div>\n\n\n<p>Recall that we are trying to avoid partial functions. The function <code>φ</code> is defined on lists, so there presumably won't be any trouble making arbitrary choices that depend on the order</p>",
        "id": 131098994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533723052
    },
    {
        "content": "<p>Given this it should not be hard to just iterate it twice to get <code>lrec_on₂</code></p>",
        "id": 131099010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1533723104
    },
    {
        "content": "<p>Okay, so I have the following.</p>\n<p>My initial version:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">lrec_on</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)},</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">d₁</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"n\">d₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">hrec_on</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)),</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span><span class=\"o\">),</span> <span class=\"n\">φ</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hfunext</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_nodup_keys</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">heq_of_eq</span> <span class=\"err\">$</span> <span class=\"n\">c</span> <span class=\"n\">p</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span><span class=\"o\">)</span>\n  <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span>\n\n<span class=\"n\">def</span> <span class=\"n\">erase</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"n\">finmap</span><span class=\"bp\">.</span><span class=\"n\">lrec_on</span> <span class=\"n\">f</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">kerase</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys_kerase</span> <span class=\"n\">a</span> <span class=\"n\">d</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">p</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span><span class=\"o\">,</span> <span class=\"n\">eq_of_veq</span> <span class=\"err\">$</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"err\">$</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_kerase</span> <span class=\"n\">a</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Your suggestion:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">lrec_on&#39;</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span> <span class=\"n\">l₂</span><span class=\"o\">),</span> <span class=\"n\">l₁</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">l₂</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">φ</span> <span class=\"n\">l₁</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">hrec_on</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)),</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hfunext</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_nodup_keys</span> <span class=\"n\">p</span><span class=\"o\">])</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">heq_of_eq</span> <span class=\"err\">$</span> <span class=\"n\">c</span> <span class=\"n\">p</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span><span class=\"o\">)</span>\n  <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span>\n\n<span class=\"n\">def</span> <span class=\"n\">erase&#39;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"n\">finmap</span><span class=\"bp\">.</span><span class=\"n\">lrec_on&#39;</span> <span class=\"n\">f</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">kerase</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys_kerase</span> <span class=\"n\">a</span> <span class=\"bp\">_⟩</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"n\">p</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span><span class=\"o\">,</span> <span class=\"n\">eq_of_veq</span> <span class=\"err\">$</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"err\">$</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">perm_kerase</span> <span class=\"n\">a</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I can define <code>erase</code> with <code>lrec_on</code>, but how do I define <code>erase'</code> with <code>lrec_on'</code>?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">don&#39;t</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">placeholder</span>\n<span class=\"kn\">context</span><span class=\"o\">:</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">finmap</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">,</span>\n<span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"err\">⊢</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nodup_keys</span> <span class=\"n\">l</span>\n</pre></div>",
        "id": 131103716,
        "sender_full_name": "Sean Leather",
        "timestamp": 1533729871
    }
]
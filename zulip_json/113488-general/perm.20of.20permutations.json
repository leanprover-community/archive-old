[
    {
        "content": "<p>This statement handwaves to \"it's obvious\", but the implementation of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.permutations\">docs#list.permutations</a> is so inscrutable to me (how are the permutations even ordered?), that I have no idea how to begin to prove it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.perm</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Two lists equivalent up to permutations have a list of permutations that are</span>\n<span class=\"sd\">equivalent up to permutation -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">list.perm_permutations</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">l₁.permutations</span> <span class=\"bp\">~</span> <span class=\"n\">l₂.permutations</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 244818953,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625338049
    },
    {
        "content": "<p>(I already asked this on the Discord, but figured I might have more luck here since the authors of <code>perm.lean</code>, Leo, Jeremy, and Mario aren't all on discord)</p>",
        "id": 244819003,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625338113
    },
    {
        "content": "<p>Regarding ordering, the python order looks much more obvious at a glance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">permutations</span>\n<span class=\"c1\">-- [[1, 2, 3], [2, 1, 3], [3, 2, 1], [2, 3, 1], [3, 1, 2], [1, 3, 2]]</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">itertools</span>\n<span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">itertools</span><span class=\"o\">.</span><span class=\"n\">permutations</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">]))</span>\n<span class=\"c1\"># [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]</span>\n</code></pre></div>",
        "id": 244819219,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625338445
    },
    {
        "content": "<p>It looks to me like it's implemented like the Haskell version: <a href=\"https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html#v:permutations\">https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html#v:permutations</a></p>",
        "id": 244819576,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625338947
    },
    {
        "content": "<p>And it's implemented like that in Haskell to take full advantage of laziness: <a href=\"https://stackoverflow.com/questions/24484348/what-does-this-list-permutations-implementation-in-haskell-exactly-do\">https://stackoverflow.com/questions/24484348/what-does-this-list-permutations-implementation-in-haskell-exactly-do</a></p>",
        "id": 244819650,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625339060
    },
    {
        "content": "<p>It doesn't need to be redefined but it does need more lemmas about it. The trouble is that the permutations seem to be in a strange order so there's no nice statement of <code>permuations_cons</code>. Maybe it's best to basically treat it like a multiset, and not prove any lemmas about the order.</p>",
        "id": 244820390,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1625340267
    },
    {
        "content": "<p>Is laziness relevant to lean?</p>",
        "id": 244820673,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625340754
    },
    {
        "content": "<p>I don't think so, but there are also properties of this implementation which are nice though they're not proved in Lean</p>",
        "id": 244820823,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625340971
    },
    {
        "content": "<p>I guess in principle we could have a <code>list.lexicographic_permutations</code> function</p>",
        "id": 244820854,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625341035
    },
    {
        "content": "<p>But proving its equivalence modulo permutation to the current implementation seems every bit as hard as my original lemma statement</p>",
        "id": 244820866,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625341064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/perm.20of.20permutations/near/244820854\">said</a>:</p>\n<blockquote>\n<p>I guess in principle we could have a <code>list.lexicographic_permutations</code> function</p>\n</blockquote>\n<p>We have something similar for list.sublists and list.sublists' so there is precedent for this kind of duplication</p>",
        "id": 244820925,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625341101
    },
    {
        "content": "<p>Chris, we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.permutations_aux_cons\">docs#list.permutations_aux_cons</a>; I think the API of permutations is \"unfold it first, then use the API of permutations_aux\".</p>",
        "id": 244820953,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625341145
    },
    {
        "content": "<p>Do we have any of these?</p>\n<ul>\n<li>every permutation of <code>l</code> occurs in <code>l.permutations</code></li>\n<li><code>l.permutations</code> has length <code>l.length!</code></li>\n<li><code>l.permutations</code> is natural in functions <code>\\a -&gt; \\b</code><br>\nAt least in principle these 3 should be enough to prove the result at the top of this thread</li>\n</ul>",
        "id": 244821779,
        "sender_full_name": "David Wärn",
        "timestamp": 1625342424
    },
    {
        "content": "<p>We have your first and second points certainly, at the bottom of data/list/perm</p>",
        "id": 244821796,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625342463
    },
    {
        "content": "<p>What does \"is natural\" mean there?</p>",
        "id": 244821920,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625342658
    },
    {
        "content": "<p><code>(l.map f).permutations = ...</code></p>",
        "id": 244821923,
        "sender_full_name": "David Wärn",
        "timestamp": 1625342677
    },
    {
        "content": "<p>You should be able to use this to reduce to the universal case where <code>l1</code> and <code>l2</code> are permutations of <code>[1, 2, ... n]</code></p>",
        "id": 244821941,
        "sender_full_name": "David Wärn",
        "timestamp": 1625342723
    },
    {
        "content": "<p>Where the <code>...</code> is <code>l.permutations.map (\\lam l, l.map f)</code>?</p>",
        "id": 244821942,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625342723
    },
    {
        "content": "<p>That does seem like an easier result to prove</p>",
        "id": 244821961,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625342756
    },
    {
        "content": "<p>Even proving that seems challenging, although my approach was just to hope that guessing the right induction would get me where I need to be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.permutations_aux_map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">is</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">permutations_aux</span> <span class=\"o\">(</span><span class=\"n\">is.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l.permutations_aux</span> <span class=\"n\">is</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">list.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">list.permutations_aux.rec</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span> <span class=\"n\">is</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">permutations_aux</span> <span class=\"o\">(</span><span class=\"n\">is.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l.permutations_aux</span> <span class=\"n\">is</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">list.map</span> <span class=\"n\">f</span><span class=\"o\">)),</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">is</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"n\">is</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">list.permutations</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">],</span>\n    <span class=\"n\">clear</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">is</span> <span class=\"k\">with</span> <span class=\"n\">h_is</span> <span class=\"n\">t_is</span> <span class=\"n\">ih_is</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.map_cons</span><span class=\"o\">,</span>\n      <span class=\"n\">list.permutations_aux2_snd_cons</span><span class=\"o\">],</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"gr\">sorry</span>\n    <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">list.permutations_map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">permutations</span> <span class=\"bp\">=</span> <span class=\"n\">l.permutations.map</span> <span class=\"o\">(</span><span class=\"n\">list.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">list.permutations</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">list.permutations_aux_map</span> <span class=\"n\">l</span> <span class=\"o\">[]</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 244823358,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625345068
    },
    {
        "content": "<p>The definition of <code>permutations</code> is definitely not supposed to be observable beyond the API, because it's a very messy definition</p>",
        "id": 244824218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625346351
    },
    {
        "content": "<p>While lean doesn't have to worry about laziness, it does have to worry about blowing the stack, so something like the haskell definition is still required</p>",
        "id": 244824264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625346382
    },
    {
        "content": "<p>all the key lemmas about <code>permutations_aux</code> are proven at the end of <code>data.list.perm</code></p>",
        "id": 244824366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625346493
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/113488-general/topic/perm.20of.20permutations/near/244820390\">said</a>:</p>\n<blockquote>\n<p>It doesn't need to be redefined but it does need more lemmas about it. The trouble is that the permutations seem to be in a strange order so there's no nice statement of <code>permuations_cons</code>. Maybe it's best to basically treat it like a multiset, and not prove any lemmas about the order.</p>\n</blockquote>\n<p>Indeed, although it doesn't have  <code>permutations_cons</code>, it is possible to state <code>permutations_cons</code> using <code>~</code> instead of equality</p>",
        "id": 244824582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625346857
    },
    {
        "content": "<p>I have a proof of <code>map_permutations</code> in <a href=\"https://github.com/leanprover-community/mathlib/issues/8188\">#8188</a>, but I'm not sure how <span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span> was thinking of using it to prove the perm permutation theorem</p>",
        "id": 244826768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625350372
    },
    {
        "content": "<p>Those proofs are gnarly, pattern matching on <code>_match_1</code></p>",
        "id": 244828280,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625353061
    },
    {
        "content": "<p>Are those just golfed to oblivion, or is there something going on that makes more conventional approaches tricky?</p>",
        "id": 244828330,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625353133
    },
    {
        "content": "<p>You can form an iso between members of list.permutations l and equiv.perm of the subtype of members of l, when nodup l. Then, by a cardinality argument, l.permutations must be nodup too. Then the result at the top of this thread follows. To form the iso, one needs the cycle.form_perm that I've been working on.</p>",
        "id": 244834929,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625364317
    },
    {
        "content": "<p>I had in mind something along the lines of</p>\n<ul>\n<li>prove that if <code>l.nodup</code> then <code>l.permutations.nodup</code> using a cardinality argument, like Yakov said. I think here you just need the fact that each <code>e : equiv.perm (fin l.length)</code> defines a distinct permutation of <code>l</code>.</li>\n<li>If <code>l1 ~ l2</code>, then <code>l1.permutations</code> and <code>l2.permutations</code> have the same elements, not counting multiplicity. So if <code>l1.nodup</code>, then everything is <code>nodup</code>, and so <code>l1.permutations ~ l2.permutations</code>.</li>\n<li>If <code>l.map f ~ t</code>, then there exists <code>l'</code> such that <code>l ~ l'</code> and <code>t = l'.map f</code>. Using this (or something else, I don't know what's in mathlib), you can prove that if <code>l1 ~ l2</code>, with <code>l1 : list \\a</code>, then there exists <code>\\b</code> and <code>f : \\b -&gt; \\a</code> and <code>l1', l2' : list \\b</code> such that <code>l1 = l1'.map f</code>, <code>l2 = l2'.map f</code>, and <code>l1'.nodup</code>. Concretely you can take <code>\\b = fin l1.length</code>, <code>f  i = l1.nth i</code>, <code>l1 = [0, 1, ...]</code>.</li>\n<li>Deduce the original result, using <code>map_permutations</code></li>\n</ul>",
        "id": 244849803,
        "sender_full_name": "David Wärn",
        "timestamp": 1625389229
    },
    {
        "content": "<p>I had another stab at proving it from induction alone, but I'm running into a total lack of understanding about the semantics of <code>permutations_aux</code>, and can't work out any of the properties it has. Is this true?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.perm.permutations_aux</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">i₁</span> <span class=\"n\">i₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i₁</span> <span class=\"bp\">~</span> <span class=\"n\">i₂</span><span class=\"o\">),</span>\n  <span class=\"n\">l.permutations_aux</span> <span class=\"n\">i₁</span> <span class=\"bp\">~</span> <span class=\"n\">l.permutations_aux</span> <span class=\"n\">i₂</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 244856278,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625400038
    },
    {
        "content": "<p>(if anyone who does  understand <code>permutations_aux</code> could write a docstring for it, that would be amazing! Otherwise I guess I should read the thorough explanation of the haskell code that Bhavik linked to...)</p>",
        "id": 244856296,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625400080
    },
    {
        "content": "<p>I wrote <code>permutations</code> and all the lemmas, but I can't say I have a deep understanding of what it does. For the most part, my understanding is already encoded in lemmas like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.mem_foldr_permutations_aux2\">docs#list.mem_foldr_permutations_aux2</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.mem_permutations_aux_of_perm\">docs#list.mem_permutations_aux_of_perm</a> that give a sense of what the inductive invariant is</p>",
        "id": 244857148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625401425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/perm.20of.20permutations/near/244828280\">said</a>:</p>\n<blockquote>\n<p>Those proofs are gnarly, pattern matching on <code>_match_1</code></p>\n</blockquote>\n<p>What is this a reference to? I didn't do any match like that in that PR</p>",
        "id": 244857214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625401509
    },
    {
        "content": "<p>Oh, you are talking about <code>permutations_aux2_fst</code> et al. I didn't write those for the PR, they were just moved from data.list.perm to data.list.basic</p>",
        "id": 244857282,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625401595
    },
    {
        "content": "<p>That kind of dependent matching is a rather old style, I think we have better tactics for doing that today but I don't feel like rewriting the proofs</p>",
        "id": 244857287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625401632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/perm.20of.20permutations/near/244856278\">said</a>:</p>\n<blockquote>\n<p>I had another stab at proving it from induction alone, but I'm running into a total lack of understanding about the semantics of <code>permutations_aux</code>, and can't work out any of the properties it has. Is this true?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.perm.permutations_aux</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">i₁</span> <span class=\"n\">i₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i₁</span> <span class=\"bp\">~</span> <span class=\"n\">i₂</span><span class=\"o\">),</span>\n  <span class=\"n\">l.permutations_aux</span> <span class=\"n\">i₁</span> <span class=\"bp\">~</span> <span class=\"n\">l.permutations_aux</span> <span class=\"n\">i₂</span> <span class=\"o\">:=</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>That looks like a good job for <code>slim_check</code></p>",
        "id": 244857437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625401903
    },
    {
        "content": "<p>I take it that means it is false</p>",
        "id": 244859296,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625404786
    },
    {
        "content": "<p><code>slim_check</code> hangs on this because checking that two lists are <code>perm</code> works by enumerating over all appendings:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.slim_check</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.perm</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.permutations_aux</span> <span class=\"n\">l'</span> <span class=\"bp\">~</span> <span class=\"n\">l.permutations_aux</span> <span class=\"o\">(</span><span class=\"n\">l'.rotate</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">slim_check</span>\n</code></pre></div>",
        "id": 244859437,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1625405032
    },
    {
        "content": "<p>Here's a reconstruction of the argument as a literate lean file:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.perm</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">list</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"o\">[]</span> <span class=\"n\">ys</span> <span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n\n<span class=\"c1\">-- permutations_aux2 is a bunch of functorial nonsense over the foo function:</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"n\">r</span> <span class=\"n\">ys</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"bp\">++</span> <span class=\"n\">ts</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">++</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"n\">t</span> <span class=\"o\">[]</span> <span class=\"n\">ys</span>\n\n<span class=\"c1\">-- foo is also a simple mapping of bar:</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">foo</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"n\">ys</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"n\">t</span> <span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"n\">ts</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- bar inserts x into every position of xs except the last:</span>\n<span class=\"k\">#eval</span> <span class=\"n\">bar</span> <span class=\"mi\">10</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"c1\">-- [[10, 1, 2, 3], [1, 10, 2, 3], [1, 2, 10, 3]]</span>\n\n<span class=\"c1\">-- permutations_aux is defined using the following recursion,</span>\n<span class=\"c1\">--  where I've moved the contribution of each iteration into a separate definition:</span>\n<span class=\"kd\">def</span> <span class=\"n\">grouping</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"n\">is</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">permutations</span> <span class=\"n\">is</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bind</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">foo</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"n\">is</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">permutations_aux</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">::</span> <span class=\"n\">ts</span><span class=\"o\">)</span> <span class=\"n\">is</span> <span class=\"bp\">=</span> <span class=\"n\">grouping</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"n\">is</span> <span class=\"bp\">++</span> <span class=\"n\">permutations_aux</span> <span class=\"n\">ts</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">::</span> <span class=\"n\">is</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- You should think of `is` as a side parameter here;</span>\n<span class=\"c1\">-- just pretend `permutations is` is already defined earlier so that this</span>\n<span class=\"c1\">-- is a simple recursion on `ts`.</span>\n\n<span class=\"c1\">-- The one other oddity here is the definition of `permutations` itself:</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">permutations</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"o\">::</span> <span class=\"n\">permutations_aux</span> <span class=\"n\">l</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">-- We're handling the identity permutation separately, so `permutations_aux` only deals with</span>\n<span class=\"c1\">-- the non-identity permutations. It's something like decomposing integers by powers of 10;</span>\n<span class=\"c1\">-- zero requires special handling.</span>\n\n<span class=\"c1\">-- So what's the big idea? We are going to partition the (non-identity) permutations</span>\n<span class=\"c1\">-- according to the longest fixed suffix. You can see that here:</span>\n<span class=\"k\">#eval</span> <span class=\"n\">permutations</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]</span>\n<span class=\"c1\">-- [[1, 2, 3, 4], [2, 1, 3, 4], [3, 2, 1, 4], [2, 3, 1, 4], [3, 1, 2, 4], [1, 3, 2, 4],</span>\n<span class=\"c1\">--  [4, 3, 2, 1], [3, 4, 2, 1], [3, 2, 4, 1], [4, 2, 3, 1], [2, 4, 3, 1], [2, 3, 4, 1],</span>\n<span class=\"c1\">--  [4, 1, 2, 3], [1, 4, 2, 3], [1, 2, 4, 3], [4, 2, 1, 3], [2, 4, 1, 3], [2, 1, 4, 3],</span>\n<span class=\"c1\">--  [4, 1, 3, 2], [1, 4, 3, 2], [1, 3, 4, 2], [4, 3, 1, 2], [3, 4, 1, 2], [3, 1, 4, 2]]</span>\n\n<span class=\"c1\">-- is partitioned like so:</span>\n<span class=\"k\">#eval</span> <span class=\"n\">grouping</span> <span class=\"mi\">1</span> <span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]</span> <span class=\"o\">[]</span> <span class=\"c1\">-- []</span>\n<span class=\"k\">#eval</span> <span class=\"n\">grouping</span> <span class=\"mi\">2</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"c1\">-- [[2, 1, 3, 4]]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">grouping</span> <span class=\"mi\">3</span> <span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"c1\">-- [[3, 2, 1, 4], [2, 3, 1, 4], [3, 1, 2, 4], [1, 3, 2, 4]]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">grouping</span> <span class=\"mi\">4</span> <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"c1\">-- [[4, 3, 2, 1], [3, 4, 2, 1], [3, 2, 4, 1], [4, 2, 3, 1], [2, 4, 3, 1], [2, 3, 4, 1],</span>\n<span class=\"c1\">--  [4, 1, 2, 3], [1, 4, 2, 3], [1, 2, 4, 3], [4, 2, 1, 3], [2, 4, 1, 3], [2, 1, 4, 3],</span>\n<span class=\"c1\">--  [4, 1, 3, 2], [1, 4, 3, 2], [1, 3, 4, 2], [4, 3, 1, 2], [3, 4, 1, 2], [3, 1, 4, 2]]</span>\n\n<span class=\"c1\">-- There no nonidentity permutations that fix 2,3,4, one permutation that fixes 3,4,</span>\n<span class=\"c1\">-- 4 permutations that fix 4, and the remaining 18 permutations don't fix 4.</span>\n\n<span class=\"c1\">-- So how does `grouping` accomplish this? It is defined like so:</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"n\">is</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">grouping</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"n\">is</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">permutations</span> <span class=\"n\">is</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bind</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"n\">t</span> <span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"n\">ts</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- We know that `ts` is the fixed suffix, and also that `t::ts` is *not* fixed,</span>\n<span class=\"c1\">-- or else we would be in the next group. Given a permutation of `is++t::ts` that fixes `ts`</span>\n<span class=\"c1\">-- and does not fix `t::ts`, we know that `t` and `is` are mixed in some way, which we</span>\n<span class=\"c1\">-- express as a permutation of `is` with `t` inserted anywhere except the last position.</span>\n<span class=\"c1\">-- We then append `ts` at the end as required, and that's what `grouping` does.</span>\n\n<span class=\"c1\">-- Appending all these lists for different suffixes produces all permutations except the</span>\n<span class=\"c1\">-- identity, because we assumed that `t::ts` was not fixed so the identity permutation is</span>\n<span class=\"c1\">-- never in any of the groups. So `permutations` has to do one final fixup to put it in.</span>\n</code></pre></div>",
        "id": 244859842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625405699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113488-general/topic/perm.20of.20permutations/near/244859437\">said</a>:</p>\n<blockquote>\n<p><code>slim_check</code> hangs on this because checking that two lists are <code>perm</code> works by enumerating over all appendings:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.slim_check</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.perm</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.permutations_aux</span> <span class=\"n\">l'</span> <span class=\"bp\">~</span> <span class=\"n\">l.permutations_aux</span> <span class=\"o\">(</span><span class=\"n\">l'.rotate</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">slim_check</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Ooh, that's probably kernel computation coming to bite us</p>",
        "id": 244860206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625406261
    },
    {
        "content": "<p><code>slim_check</code> doesn't use <code>#eval</code></p>",
        "id": 244860210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625406273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/perm.20of.20permutations/near/244859296\">said</a>:</p>\n<blockquote>\n<p>I take it that means it is false</p>\n</blockquote>\n<p>Having written all that, I think that it is true. Anything that goes into the <code>is</code> argument is either an input of <code>permutations is</code> for the current group or is passed to the next iteration as <code>t::is</code>, so it will only ever be scrambled. Therefore permuting the <code>is</code> should result in a permutation of the output, and moreover it will be a permutation individually in the groups, that is, you can prove each group is separately a permutation</p>",
        "id": 244860422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625406613
    },
    {
        "content": "<p>Thanks for that thorough explanation <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, it was enough for me to spot the pattern!</p>\n<p>I guess this statement is true then?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">permutations_concat</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">permutations</span> <span class=\"bp\">=</span>\n    <span class=\"n\">l.permutations.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">])</span> <span class=\"bp\">++</span> <span class=\"n\">l.permutations.bind</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 244877618,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625432868
    },
    {
        "content": "<p>Edit: no, #eval tells me its false</p>",
        "id": 244877698,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625432958
    },
    {
        "content": "<p>In which case, I'm still confused by how the order of the elements in <code>grouping 3 [4] [2, 1]</code> is determined.</p>",
        "id": 244877845,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625433152
    },
    {
        "content": "<p><code>grouping 3 [4] [2, 1]</code> is <code>[[3, 2, 1, 4], [2, 3, 1, 4], [3, 1, 2, 4], [1, 3, 2, 4]]</code>. It is defined as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">grouping</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"n\">is</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">permutations</span> <span class=\"n\">is</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bind</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"n\">t</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"n\">ts</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>So we're putting <code>[4]</code> on the end of each list, without that it's <code>[[3, 2, 1], [2, 3, 1], [3, 1, 2], [1, 3, 2]]</code>. These are obtained by taking <code>permutations [2, 1] = [[2, 1], [1, 2]]</code>, and then inserting <code>3</code>  at the first and second positions of each. Inserting <code>3</code> in <code>[2, 1]</code> yields <code>[3, 2, 1], [2, 3, 1]</code>, and inserting <code>3</code> in <code>[1, 2]</code> yields  <code>[3, 1, 2], [1, 3, 2]</code>.</p>\n<p>Now the particular ordering of <code>permutations [2, 1] = [[2, 1], [1, 2]]</code> depends on a recursive call, so we're back to stage one here. This is why <code>permutations_aux</code> has such a convoluted recursor. But your inductive hypothesis should supply whatever you need to know about this function.</p>",
        "id": 244882631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625441614
    },
    {
        "content": "<p>Ah, it's the fact that the second argument to <code>grouping</code> is reversed that threw me off</p>",
        "id": 244915158,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625478483
    },
    {
        "content": "<p>The true version of my statement appears to be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">permutations_concat_statement</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">permutations</span> <span class=\"bp\">=</span>\n    <span class=\"n\">l.permutations.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">])</span> <span class=\"bp\">++</span> <span class=\"n\">l.reverse.permutations.bind</span> <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">permutations_concat_statement</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">permutations_concat_statement</span> <span class=\"o\">[]</span> <span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 244915199,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625478496
    },
    {
        "content": "<p>I assume the <code>.reverse</code> in there for some efficiency reason regarding assembling lists</p>",
        "id": 244915245,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625478556
    },
    {
        "content": "<p>This looks like it will probably help with <code>permutations_aux2</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The `ts`, `r`, and `f` arguments of `permutations_aux2` are just post-processing. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">permutations_aux2_snd_f</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"n\">r</span> <span class=\"n\">ys</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">=</span>\n      <span class=\"o\">(</span><span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"o\">[]</span> <span class=\"o\">[]</span> <span class=\"n\">ys</span> <span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"bp\">++</span> <span class=\"n\">ts</span><span class=\"o\">))</span> <span class=\"bp\">++</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"k\">calc</span> <span class=\"o\">(</span><span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"n\">r</span> <span class=\"n\">ys</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span>\n     <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"o\">[]</span> <span class=\"n\">ys</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">++</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kd\">begin</span>\n       <span class=\"n\">induction</span> <span class=\"n\">ys</span> <span class=\"k\">with</span> <span class=\"n\">y</span> <span class=\"n\">ys</span> <span class=\"n\">generalizing</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n       <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n       <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ys_ih</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">))]</span> <span class=\"o\">}</span>\n     <span class=\"kd\">end</span>\n <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"o\">[]</span> <span class=\"n\">ys</span> <span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd.map</span> <span class=\"n\">f</span> <span class=\"bp\">++</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kd\">begin</span>\n       <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n       <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">map_permutations_aux2'</span> <span class=\"n\">id</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n     <span class=\"kd\">end</span>\n <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"o\">[]</span> <span class=\"o\">[]</span> <span class=\"n\">ys</span> <span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"bp\">++</span> <span class=\"n\">ts</span><span class=\"o\">))</span> <span class=\"bp\">++</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kd\">begin</span>\n       <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">map_map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">++</span> <span class=\"n\">ts</span><span class=\"o\">),</span>\n       <span class=\"n\">congr'</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n       <span class=\"n\">induction</span> <span class=\"n\">ys</span><span class=\"o\">,</span>\n       <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n       <span class=\"n\">simp</span><span class=\"o\">,</span>\n       <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n      <span class=\"c1\">--  convert (map_permutations_aux2' _ _ _ _ _ _ _ _ _).symm,</span>\n     <span class=\"kd\">end</span>\n</code></pre></div>\n<p>Unfortunately I'm not sure how to show the <code>sorry</code>.</p>",
        "id": 244921780,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625482880
    },
    {
        "content": "<p>does</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>       <span class=\"n\">induction</span> <span class=\"n\">ts</span><span class=\"o\">,</span>\n       <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">append_nil</span><span class=\"o\">],</span>\n       <span class=\"n\">rw</span> <span class=\"n\">map_permutations_aux2'</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n       <span class=\"n\">simp</span><span class=\"o\">,</span>\n       <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">map_id</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>make any useful progress? I don't really understand <code>permutations_aux2</code> so I went for \"goal-driven development\"</p>",
        "id": 244923400,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1625483959
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ts</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"o\">[]</span> <span class=\"n\">ys</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"o\">[]</span> <span class=\"o\">[]</span> <span class=\"n\">ys</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"bp\">++</span> <span class=\"n\">ts</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">ys</span> <span class=\"n\">generalizing</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">id.def</span><span class=\"o\">,</span> <span class=\"n\">map</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">permutations_aux2_snd_cons</span><span class=\"o\">,</span> <span class=\"n\">append_nil</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">hg</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">ys_ih</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">cons_append</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Solves your sorry Eric! By the way, your first begin/end in the calc is already in mathlib: <code>permutations_aux2_append</code></p>",
        "id": 244927630,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625486686
    },
    {
        "content": "<p>There are already lemmas which eliminate the <code>f</code> and <code>r</code> parameters of <code>permutations_aux2</code>, so you don't need them in the lemma statement. It's a lot easier to tackle these arguments one at a time</p>",
        "id": 244931090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625488825
    },
    {
        "content": "<p>Actually, I don't think it's worth eliminating the <code>ts</code> argument. In the context of <code>grouping</code>, the <code>foo</code> function makes a bit more sense than <code>bar</code>: we have a list <code>is ++ t :: ts</code> and are permuting the left half of it and moving <code>t</code> out of place</p>",
        "id": 244931322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625488967
    },
    {
        "content": "<p>Perhaps this is the lemma that's missing then?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The `ts` argument to `permutations_aux2` can be folded into the `f` argument. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">permutations_aux2_comp_append</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ts</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"o\">[]</span> <span class=\"n\">r</span> <span class=\"n\">ys</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"n\">ts</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"n\">ts</span> <span class=\"n\">r</span> <span class=\"n\">ys</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">ys</span> <span class=\"n\">generalizing</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">id.def</span><span class=\"o\">,</span> <span class=\"n\">map</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span> <span class=\"n\">permutations_aux2_snd_cons</span><span class=\"o\">,</span> <span class=\"n\">append_nil</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"n\">ys_ih</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 244932055,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625489467
    },
    {
        "content": "<p>Stated backwards to match <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.permutations_aux2_append\">docs#list.permutations_aux2_append</a></p>",
        "id": 244932209,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625489546
    },
    {
        "content": "<p>Looking again, I actually don't see a lemma that says that <code>f</code> can be eliminated, but most of the lemmas are about <code>f = id</code> so apparently they (that is, past me) managed to get around it</p>",
        "id": 244933101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1625490110
    },
    {
        "content": "<p>I'll add the lemma that eliminates <code>f</code> too, even if it doesn't get used - it's good for explaining what the function does</p>",
        "id": 244933253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625490194
    },
    {
        "content": "<p>Isn't <code>map_permutations_aux2'</code> the one that eliminates <code>f</code>?</p>",
        "id": 244933586,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1625490393
    },
    {
        "content": "<p>Yes, but it's stated very generally which makes it hard to apply</p>",
        "id": 244933604,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625490412
    },
    {
        "content": "<p>The yellow bars are stuck in \"refresh every time I hit a key\" mode so this is taking forever</p>",
        "id": 244935549,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625491566
    },
    {
        "content": "<p>Do you have any other open files?</p>",
        "id": 244935684,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625491644
    },
    {
        "content": "<p>They're all \"plaintext\" files</p>",
        "id": 244935702,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625491654
    },
    {
        "content": "<p>Although only because I told Vscode to not process them as lean any more</p>",
        "id": 244935724,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625491672
    },
    {
        "content": "<p>They're also all unsaved anonymous buffers</p>",
        "id": 244935735,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625491679
    },
    {
        "content": "<p>Aha</p>",
        "id": 244935788,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625491688
    },
    {
        "content": "<p>For me, it usually worked to restart VScode with only 1 file open.</p>",
        "id": 244935819,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1625491706
    },
    {
        "content": "<p>I restarted vscode, reopening to 1 lean file + 5 plaintext buffers and it still behaves poorly.</p>",
        "id": 244935893,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625491743
    },
    {
        "content": "<p>Maybe CI can build for me: <a href=\"https://github.com/leanprover-community/mathlib/issues/8198\">#8198</a></p>",
        "id": 244935946,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1625491771
    },
    {
        "content": "<p>Done in <a href=\"https://github.com/leanprover-community/mathlib/issues/8587\">#8587</a> <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 248824767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628502595
    },
    {
        "content": "<p>That PR also introduces <code>list.permutations'</code> which has much more straightforward equations:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">permutations'_aux</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>      <span class=\"o\">:=</span> <span class=\"o\">[[</span><span class=\"n\">t</span><span class=\"o\">]]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">::</span> <span class=\"n\">y</span> <span class=\"o\">::</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">permutations'_aux</span> <span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">permutations'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">[[]]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">::</span><span class=\"n\">ts</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">permutations'</span> <span class=\"n\">ts</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bind</span> <span class=\"bp\">$</span> <span class=\"n\">permutations'_aux</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 248824915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628502691
    },
    {
        "content": "<p>Oh wow! I was genuinely banging my hand against this problem.</p>",
        "id": 248826611,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628503995
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>, it's Christmas before December!</p>",
        "id": 248826714,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628504094
    },
    {
        "content": "<p>I was wondering, what's the difference in practice between a new inductive definition and a new recursor? Could you have proven <code>perm.permutations</code> with just the new recursor?</p>",
        "id": 248826830,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1628504194
    },
    {
        "content": "<p>no, because <code>list.permutations'</code> is not equal to <code>list.permutations</code></p>",
        "id": 248826896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628504277
    },
    {
        "content": "<p>it is a complicated permutation thereof</p>",
        "id": 248826950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628504294
    },
    {
        "content": "<p>If you replaced <code>=</code> with <code>~</code> everywhere, then possibly, however all of the theorems expressing list.permutation in terms of permutations of pieces of itself only come after all the main lemmas are proven, so it's no good for proving the theorem itself</p>",
        "id": 248827025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628504401
    },
    {
        "content": "<p>I think the key lemma that is actually true about <code>list.permutations</code> and doesn't need <code>~</code> is this one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">permutations_append</span> <span class=\"o\">(</span><span class=\"n\">is</span> <span class=\"n\">ts</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">permutations</span> <span class=\"o\">(</span><span class=\"n\">is</span> <span class=\"bp\">++</span> <span class=\"n\">ts</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">permutations</span> <span class=\"n\">is</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">++</span> <span class=\"n\">ts</span><span class=\"o\">)</span> <span class=\"bp\">++</span> <span class=\"n\">permutations_aux</span> <span class=\"n\">ts</span> <span class=\"n\">is.reverse</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 248827124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628504458
    },
    {
        "content": "<p>In terms of the description up thread, <code>permutations_aux</code> is defined as an append of a bunch of <code>grouping</code>s, satisfying the recursion <code>permutations_aux (t :: ts) is = grouping ts t is ++ permutations_aux ts (t :: is)</code>, so this suggests that you can also collect the groupings from the left, to define <code>permutations_left (t :: is) ts = permutations_left is (t :: ts) ++ grouping ts t is</code> such that <code>permutations_left ts is ++ permutations_aux ts is = permutations (ts ++ is.reverse)</code>. Then observe that every element of <code>permutations_left</code> is supposed to fix <code>ts</code>, so it can be factored as <code>permutations_left is ts = (???).map (++ ts)</code>, and by great good luck (or simple consideration of the defining equation) <code>???</code> turns out to be <code>permutations is</code> itself, so you get this lovely equation</p>",
        "id": 248827600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628504828
    },
    {
        "content": "<p>If you plug in <code>ts = [t]</code>, it simplifies to this slightly awkward theorem (cut from the final version):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">permutations_concat</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">permutations</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">permutations</span> <span class=\"n\">ts</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">])</span> <span class=\"bp\">++</span>\n  <span class=\"n\">ts.reverse.permutations.bind</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">permutations_aux2</span> <span class=\"n\">t</span> <span class=\"o\">[]</span> <span class=\"o\">[]</span> <span class=\"n\">ys</span> <span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>The <code>ts.reverse.permutations</code> that occurs here is why <code>list.permutations</code> has such terrible equations, because it's reversing the permutations for some of it and not for other parts, so it's hard to see what this does until you already have <code>perm.permutations</code></p>",
        "id": 248827961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628505119
    },
    {
        "content": "<p>but if you assume that <code>ts.reverse.permutations</code> is a permutation of <code>ts.permutations</code> then this simplifies to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">permutations_perm_lem1</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">permutations</span> <span class=\"n\">ts</span> <span class=\"bp\">~</span> <span class=\"n\">ts.reverse.permutations</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">permutations</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">])</span> <span class=\"bp\">~</span> <span class=\"n\">ts.permutations.bind</span> <span class=\"o\">(</span><span class=\"n\">permutations'_aux</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>because <code>permutations'_aux t ys = (permutations_aux2 t [] [] ys id).2 ++ [ys ++ [t]]</code>, and at this point we are basically done because this is the defining equation for <code>permutations'</code> (and we can prove <code>perm.permutations'</code> directly without too much trouble)</p>",
        "id": 248828280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628505328
    },
    {
        "content": "<p>This is excellent, thanks Mario!</p>",
        "id": 248828558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628505548
    },
    {
        "content": "<p>Wonderful, thanks Mario! In particular I like the double induction on the length of ts and then the reverse induction.</p>",
        "id": 248832890,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628508694
    }
]
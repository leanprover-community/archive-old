[
    {
        "content": "<p>I need a tactic that works like <code>generalize</code>, but for multiple terms at once. Does this already exist?</p>\n<p>Background: Generalising over multiple terms at once is not the same thing as generalising one after the other. Consider the following (slightly contrived) example:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">Vec</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Vec</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">eq</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"n\">nil</span> <span class=\"n\">nil</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">→</span>\n  <span class=\"n\">eq</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"bp\">→</span>\n  <span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">Vec</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span> <span class=\"n\">Vec</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Vec</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Vec</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n  <span class=\"bp\">→</span> <span class=\"n\">Vec</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- generalize eq : n + 1 = i₁,         -- The `n + 1`         in h is not generalised.</span>\n  <span class=\"c1\">-- generalize eq : Vec.cons x xs = i₁, -- The `Vec.cons x xs` in h is not generalised.</span>\n  <span class=\"n\">refine</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i₁</span> <span class=\"n\">i₂</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i₃</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"n\">i₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i₄</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span> <span class=\"n\">α</span> <span class=\"n\">i₂</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">i₁_eq</span> <span class=\"o\">:</span> <span class=\"n\">i₁</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i₂_eq</span> <span class=\"o\">:</span> <span class=\"n\">i₂</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i₃_eq</span> <span class=\"o\">:</span> <span class=\"n\">i₃</span> <span class=\"bp\">==</span> <span class=\"n\">Vec</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">i₄_eq</span> <span class=\"o\">:</span> <span class=\"n\">i₄</span> <span class=\"bp\">==</span> <span class=\"n\">Vec</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h&#39;</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"n\">i₁</span> <span class=\"n\">i₂</span> <span class=\"n\">i₃</span> <span class=\"n\">i₄</span><span class=\"o\">),</span>\n      <span class=\"o\">(</span><span class=\"bp\">_</span> <span class=\"o\">:</span> <span class=\"n\">Vec</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Vec</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Vec</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"n\">rfl</span> <span class=\"n\">rfl</span> <span class=\"n\">heq</span><span class=\"bp\">.</span><span class=\"n\">rfl</span> <span class=\"n\">heq</span><span class=\"bp\">.</span><span class=\"n\">rfl</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- This is the state I want after generalising `n + 1`, `m + 1`, `Vec.cons x xs` and `Vec.cons y ys`.</span>\n   <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>The individual generalisations can't be performed because the resulting term would not be type-correct -- but when we generalise everything at once, it works out.</p>",
        "id": 199514716,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1591113840
    },
    {
        "content": "<p>have you tried <code>generalize_hyp</code>?</p>",
        "id": 199516508,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1591114581
    },
    {
        "content": "<p>Ah yes, sorry, <code>generalize</code> only works on the target. I've fixed the example, but the problem remains.</p>",
        "id": 199518238,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1591115343
    },
    {
        "content": "<p>There's also <code>h_generalize</code> for issues arising with heterogeneous types / equality but you might want to take a step back and make the types in your theorem less dependent. For instance, you might want to define a function from vector to list, reason about list equality and reflect that equality back into a statement about vectors</p>",
        "id": 199519680,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1591116010
    },
    {
        "content": "<p>I've looked into <code>h_generalize</code>, but it doesn't seem applicable to this particular problem.</p>\n<p>The generalisation step is supposed to be part of a larger tactic and I'd like to support use cases like this, even if it may be wiser to reduce the amount of dependency. (Also, this issue originally came up in a more realistic example, so it's not entirely academic.) Seems like I'll have to just write the tactic.</p>",
        "id": 199522486,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1591117325
    },
    {
        "content": "<p>Umm... isn't the proof here just <code>intro h, cases h, assumption</code>?</p>",
        "id": 199523501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591117817
    },
    {
        "content": "<p>Yes, that's the 'contrived' part of the example. ;)</p>",
        "id": 199523553,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1591117841
    },
    {
        "content": "<p>When I have more nontrivial variants on <code>generalize</code> I just write out the <code>suffices</code> term manually</p>",
        "id": 199523594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591117866
    },
    {
        "content": "<p>usually this is before an induction and I find I want to make other changes to the state as well, such that straight double generalize wouldn't cut it</p>",
        "id": 199523680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591117921
    },
    {
        "content": "<p>Plus, the description of the problem here is more or less guaranteed to create <code>heq</code> terms</p>",
        "id": 199523762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591117951
    },
    {
        "content": "<p>If you want just <code>generalize : a = x</code> and not <code>generalize e : a = x</code> then it is easier</p>",
        "id": 199523851,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591118011
    },
    {
        "content": "<p>which is probably the right approach in these situations anyway</p>",
        "id": 199523914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591118037
    },
    {
        "content": "<p>Do you have a more realistic example? You can also use <code>match</code> to perform multiple generalizes like this but it probably also requires the target type</p>",
        "id": 199524279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591118195
    },
    {
        "content": "<p>No, I need the equations. This is indeed for a smarter induction tactic which properly generalises over compound index arguments (basically McBride's \"Elimination with a Motive\" tactic). The heqs often aren't an issue because they will be eliminated, or at least turned into homogeneous equations, after the fact. The example is realistic if you pretend that <code>cases</code> doesn't already exist: <code>induction</code> should be a generalisation of <code>cases</code>.</p>",
        "id": 199524397,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1591118273
    },
    {
        "content": "<p>well you can always get the equations with a multiple generalize, you know</p>",
        "id": 199524584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591118378
    },
    {
        "content": "<p>it's just one more dependent arg</p>",
        "id": 199524627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591118394
    },
    {
        "content": "<blockquote>\n<p>The heqs often aren't an issue because they will be eliminated, or at least turned into homogeneous equations, after the fact</p>\n</blockquote>\n<p>What's confusing me about this example is that I would be fighting to turn the goal after the tactic into the one before the tactic</p>",
        "id": 199524746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591118442
    },
    {
        "content": "<blockquote>\n<p><code>induction</code> should be a generalisation of <code>cases</code></p>\n</blockquote>\n<p>The generalizes done in <code>cases</code> are generally bad for <code>induction</code>, because they limit the inductive hypothesis too much and usually make it useless</p>",
        "id": 199524982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591118560
    },
    {
        "content": "<p>Do you have an example where this better induction tactic would be useful and <code>cases</code> / <code>induction</code> fail?</p>",
        "id": 199526504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591119272
    },
    {
        "content": "<p>My <code>induction</code> is essentially a reimplementation of Coq's <code>dependent induction</code> and should be broadly equivalent to Agda's pattern matching, Coq's <code>Equations</code> plugin and Lean's equation compiler, so it's not exactly a radical new idea. Here's an example from Jasmin's course (which motivates the whole project):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">state</span> <span class=\"o\">:=</span>\n<span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n\n<span class=\"n\">def</span> <span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">update</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">state</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">state</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span><span class=\"n\">name&#39;</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">name&#39;</span> <span class=\"bp\">=</span> <span class=\"n\">name</span> <span class=\"k\">then</span> <span class=\"n\">val</span> <span class=\"k\">else</span> <span class=\"n\">s</span> <span class=\"n\">name&#39;</span>\n\n<span class=\"kn\">notation</span> <span class=\"n\">s</span> <span class=\"bp\">`</span><span class=\"o\">{</span><span class=\"bp\">`</span> <span class=\"n\">name</span> <span class=\"bp\">`</span> <span class=\"err\">↦</span> <span class=\"bp\">`</span> <span class=\"n\">val</span> <span class=\"bp\">`</span><span class=\"o\">}</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">state</span><span class=\"bp\">.</span><span class=\"n\">update</span> <span class=\"n\">name</span> <span class=\"n\">val</span> <span class=\"n\">s</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">stmt</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">skip</span>   <span class=\"o\">:</span> <span class=\"n\">stmt</span>\n<span class=\"bp\">|</span> <span class=\"n\">assign</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">state</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">stmt</span>\n<span class=\"bp\">|</span> <span class=\"n\">seq</span>    <span class=\"o\">:</span> <span class=\"n\">stmt</span> <span class=\"bp\">→</span> <span class=\"n\">stmt</span> <span class=\"bp\">→</span> <span class=\"n\">stmt</span>\n<span class=\"bp\">|</span> <span class=\"n\">ite</span>    <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">state</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">stmt</span> <span class=\"bp\">→</span> <span class=\"n\">stmt</span> <span class=\"bp\">→</span> <span class=\"n\">stmt</span>\n<span class=\"bp\">|</span> <span class=\"n\">while</span>  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">state</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">stmt</span> <span class=\"bp\">→</span> <span class=\"n\">stmt</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">big_step</span> <span class=\"o\">:</span> <span class=\"n\">stmt</span> <span class=\"bp\">×</span> <span class=\"n\">state</span> <span class=\"bp\">→</span> <span class=\"n\">state</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">skip</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">skip</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"n\">assign</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">assign</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"err\">↦</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">})</span>\n<span class=\"bp\">|</span> <span class=\"n\">seq</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hT</span> <span class=\"o\">:</span> <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">seq</span> <span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">ite_true</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">state</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hcond</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hbody</span> <span class=\"o\">:</span> <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"n\">b</span> <span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">t</span>\n<span class=\"bp\">|</span> <span class=\"n\">ite_false</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">state</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hcond</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hbody</span> <span class=\"o\">:</span> <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"n\">b</span> <span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">t</span>\n<span class=\"bp\">|</span> <span class=\"n\">while_true</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">state</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hcond</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hbody</span> <span class=\"o\">:</span> <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hrest</span> <span class=\"o\">:</span> <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">while</span> <span class=\"n\">b</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">while</span> <span class=\"n\">b</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">while_false</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">state</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hcond</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">big_step</span> <span class=\"o\">(</span><span class=\"n\">while</span> <span class=\"n\">b</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">s</span>\n\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"err\">⟹</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">110</span> <span class=\"o\">:=</span> <span class=\"n\">big_step</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">not_big_step_while_true</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">while</span> <span class=\"o\">(</span><span class=\"bp\">λ_</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"err\">⟹</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n  <span class=\"n\">induction&#39;</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n  <span class=\"n\">case</span> <span class=\"n\">while_true</span> <span class=\"o\">{</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ih_hw_1</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">while_false</span> <span class=\"o\">{</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hcond</span><span class=\"o\">,</span>\n    <span class=\"n\">trivial</span>\n  <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p><code>cases</code> wouldn't suffice here; the proof requires induction. Regular <code>induction</code> leaves us with an unprovable <code>while_false</code> case because the naive generalisation it performs throws information away. So you have to know how to generalise the goal yourself; my <code>induction'</code> does this for you. It also recognises that most of the cases are impossible and solves them automatically.</p>\n<p>Now, this example doesn't have the dependencies between index argument that are the topic of this thread. But having hopefully established the utility of <code>induction'</code>, the only question is whether it should randomly fail on perfectly good hypotheses because I was too lazy to implement a more general procedure for simultaneous generalisation. That would seem unfortunate to me.</p>",
        "id": 199570804,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1591146264
    },
    {
        "content": "<p>Right, this is the sort of thing I don't think you can get right in general</p>",
        "id": 199570893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591146386
    },
    {
        "content": "<p>picking the right induction hypothesis is a very difficult problem. You may have a heuristic that works for this problem but then it fails for a different use case. In this case you need to know that the left arg is a <code>while true</code> but if <code>s</code> was a more specific thing like <code>\\lam _, 0</code> then you might accidentally hold that fixed as well and then it wouldn't be provable</p>",
        "id": 199571003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591146568
    },
    {
        "content": "<p>I believe that <code>induction</code> has the correct default behavior, and it is best to have the user manually use generalize to indicate what they want to hold fixed in the induction hypothesis</p>",
        "id": 199571100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591146658
    },
    {
        "content": "<p>I'm not claiming that this tactic can intuit the correct level of generality for every lemma. But in my experience, it is usually right if you state the lemma at the right level of generality. And I should stress again that I'm doing more or less exactly what the equation compiler is doing:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">not_big_step_while_true&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">while</span> <span class=\"o\">(</span><span class=\"bp\">λ_</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"err\">⟹</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">false</span>\n<span class=\"bp\">|</span> <span class=\"n\">S</span> <span class=\"n\">s</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">while_true</span> <span class=\"n\">b</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">t</span> <span class=\"bp\">_</span> <span class=\"n\">hcond</span> <span class=\"n\">hbody</span> <span class=\"n\">hrest</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">not_big_step_while_true&#39;</span> <span class=\"n\">hrest</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">while_false</span> <span class=\"n\">hcond</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">hcond</span> <span class=\"n\">trivial</span>\n</code></pre></div>\n\n\n<p>(The termination checker complains for whatever reason, hence the <code>meta</code>.) If every modern dependently typed language employs this strategy, it's probably a decent strategy.</p>",
        "id": 199571937,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1591147845
    },
    {
        "content": "<p>The termination checker complains because the equation compiler actually failed in this example!</p>",
        "id": 199572778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591149080
    },
    {
        "content": "<p>It fell back on well founded recursion which has pretty bad error messages</p>",
        "id": 199572783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591149112
    },
    {
        "content": "<p>If you are replicating the equation compiler in lean, that's a big project (that I encourage). But I would suggest a principled approach to it rather than chaining tactics because this is more likely to create brittleness and edge cases (some of which exist already in <code>induction</code>, <code>cases</code>, and the equation compiler)</p>",
        "id": 199572980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591149470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Simultaneous.20generalisation/near/199572778\">said</a>:</p>\n<blockquote>\n<p>The termination checker complains because the equation compiler actually failed in this example!</p>\n</blockquote>\n<p>I see. That's a problem with the equation compiler though; Agda would have no issue with this definition.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Simultaneous.20generalisation/near/199572980\">said</a>:</p>\n<blockquote>\n<p>If you are replicating the equation compiler in lean, that's a big project (that I encourage). But I would suggest a principled approach to it rather than chaining tactics because this is more likely to create brittleness and edge cases (some of which exist already in <code>induction</code>, <code>cases</code>, and the equation compiler)</p>\n</blockquote>\n<p>That's fair. My goal is much more modest: an induction tactic that can handle Jasmin's course contents with minimal ceremony.</p>",
        "id": 199573269,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1591149933
    },
    {
        "content": "<p>FWIW the way I write proofs of theorems like your example is:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">not_big_step_while_true</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">while</span> <span class=\"o\">(</span><span class=\"bp\">λ_</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"err\">⟹</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">while</span> <span class=\"o\">(</span><span class=\"bp\">λ_</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">hw</span> <span class=\"n\">generalizing</span> <span class=\"n\">s</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hw_ih_hrest</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">hw_hcond</span><span class=\"o\">,</span>\n    <span class=\"n\">trivial</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 199573430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591150161
    },
    {
        "content": "<p>Unfortunately this throws away the case tags so you can't use <code>case</code>, and <code>propagate_tags</code> doesn't work because of the unique rename problem</p>",
        "id": 199573515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591150293
    },
    {
        "content": "<blockquote>\n<p>I see. That's a problem with the equation compiler though; Agda would have no issue with this definition.</p>\n</blockquote>\n<p>Do you know how Agda's equation compiler works? It is the most complex equation compiler I am aware of, and because the things it does are axiomatic it has a lot of leeway to just do things and not worry about the reason behind them</p>",
        "id": 199573588,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591150417
    },
    {
        "content": "<p>But from my point of view there is a very real issue that explains why <code>induction</code> and <code>cases</code> use different inductive hypotheses</p>",
        "id": 199573654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591150511
    },
    {
        "content": "<p>One thing that's not clear to me about <code>induction'</code> is how you decide what to generalize</p>",
        "id": 199573671,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591150561
    },
    {
        "content": "<p>In order for that theorem to be provable you need to generalize at least <code>s</code>, as well as some <code>S'</code> that is equal to <code>(while (λ_, true) S, s)</code></p>",
        "id": 199573716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591150606
    },
    {
        "content": "<p>If you are thinking to just generalize everything, that will limit its usefulness when this is an induction buried inside a larger proof. Or are you expecting that <code>induction'</code> should always be the first tactic in the proof, and the goal state is already curated for consumption?</p>",
        "id": 199573783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591150714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Simultaneous.20generalisation/near/199573430\">said</a>:</p>\n<blockquote>\n<p>FWIW the way I write proofs of theorems like your example is: [...]</p>\n</blockquote>\n<p>Yeah, that's exactly what the tactic does as well. Generalise indices, induction, eliminate the equations for the generalised indices, simplify the induction hypothesis.</p>\n<p><code>with_cases</code> preserves the case tags:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">not_big_step_while_true</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">while</span> <span class=\"o\">(</span><span class=\"bp\">λ_</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"err\">⟹</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">while</span> <span class=\"o\">(</span><span class=\"bp\">λ_</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hw</span><span class=\"o\">,</span>\n  <span class=\"n\">with_cases</span> <span class=\"o\">{</span> <span class=\"n\">induction</span> <span class=\"n\">hw</span> <span class=\"n\">generalizing</span> <span class=\"n\">s</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">e</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">while_true</span> <span class=\"o\">{</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hw_ih_hrest</span> <span class=\"n\">rfl</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">while_false</span> <span class=\"o\">{</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hw_hcond</span><span class=\"o\">,</span>\n    <span class=\"n\">trivial</span>\n  <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Simultaneous.20generalisation/near/199573588\">said</a>:</p>\n<blockquote>\n<p>Do you know how Agda's equation compiler works? It is the most complex equation compiler I am aware of, and because the things it does are axiomatic it has a lot of leeway to just do things and not worry about the reason behind them</p>\n</blockquote>\n<p>Not in any detail. I know that it translates the patterns to case trees, but not to eliminators. Termination checking is a separate pass based on a 'size-change' criterion, but I don't actually know what that is. If I wanted to build an equation compiler, I'd start with Jesper Cockx's <a href=\"https://jesper.sikanda.be/files/proof-relevant-unification.pdf\">paper</a> on proof-relevant unification. Matthieu Sozeau probably also has a paper on the Equations plugin.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Simultaneous.20generalisation/near/199573671\">said</a>:</p>\n<blockquote>\n<p>One thing that's not clear to me about <code>induction'</code> is how you decide what to generalize</p>\n</blockquote>\n<p>It generalises every compound index argument of the hypothesis we eliminate ('eliminee'), here <code>(while (λ_, true) S, s)</code>. It then reverts every hypothesis that doesn't occur in the eliminee to get the most general induction hypothesis. (This can be overridden with a 'fixing' clause akin to <code>induction</code>'s 'generalizing'.)</p>\n<p>There is currently no way to prevent compound index arguments from being generalised, though I could add a flag to that effect. I would indeed assume that most uses of induction are near the top of the proof. This is certainly the case for the boring programming languages proofs where this tactic will be most useful. For induction within a longer proof, I would tend to use a lemma or <code>assert</code>.</p>",
        "id": 199574353,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1591151612
    },
    {
        "content": "<p>another common pattern in boring PL proofs is <code>induction h1; cases h2; cases equality</code></p>",
        "id": 199574540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591151885
    },
    {
        "content": "<p>for example in proving determinism with a small step semantics</p>",
        "id": 199574547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591151903
    },
    {
        "content": "<p>or big step for that matter</p>",
        "id": 199574557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1591151927
    },
    {
        "content": "<p>PR: <a href=\"https://github.com/leanprover-community/mathlib/issues/2982\">#2982</a></p>",
        "id": 200052957,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1591582442
    }
]
[
    {
        "content": "<p>I have the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.ultrafilter</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.partial</span>\n\n<span class=\"kd\">variable</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">convergence_space</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">conv</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">convergence_space</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">convergence_space</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_le</span> <span class=\"o\">(</span><span class=\"n\">convergence_space</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"k\">forall</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">},</span> <span class=\"bp\">@</span><span class=\"n\">conv</span> <span class=\"n\">a</span> <span class=\"n\">q</span> <span class=\"n\">l</span> <span class=\"n\">x</span> <span class=\"bp\">-&gt;</span> <span class=\"bp\">@</span><span class=\"n\">conv</span> <span class=\"n\">a</span> <span class=\"n\">p</span> <span class=\"n\">l</span> <span class=\"n\">x</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">conv_le_antisymm</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">convergence_space</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">q</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">p</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">l</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">iff.intro</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">l</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h'</span> <span class=\"n\">l</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Unfortunately,  lean complains with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">no</span> <span class=\"n\">applicable</span> <span class=\"n\">extensionality</span> <span class=\"n\">rule</span> <span class=\"n\">found</span> <span class=\"n\">for</span> <span class=\"n\">convergence_space</span>\n</code></pre></div>\n<p>I think I need to unfold the definitions of <code>h</code> and <code>h'</code>, but I'm not sure how to do so.</p>",
        "id": 264644083,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1639343839
    },
    {
        "content": "<p>If you tag the structure with <code>@[ext]</code>, it should auto-generate the ext lemmas.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span> <span class=\"kd\">structure</span> <span class=\"n\">convergence_space</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">conv</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">convergence_space.ext</span>\n<span class=\"k\">#check</span> <span class=\"n\">convergence_space.ext_iff</span>\n</code></pre></div>",
        "id": 264644659,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1639344656
    },
    {
        "content": "<p>Ah, nice. Didn't know about that attribute. I added it, but now I get a type mismatch error in <code>conv_le_antisymm</code>.</p>",
        "id": 264644912,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1639345005
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"416322\">@Bernd Losert</span> Your syntax is a bit off with <code>iff.intro</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">conv_le_antisymm</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">convergence_space</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">q</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">p</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">l</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">iff.intro</span> <span class=\"n\">h'</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 264646230,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1639346818
    },
    {
        "content": "<p>Ah, that works. I was confused because in another thread I asked about how to use <code>ext</code> and there it was like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">q</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">hpq</span> <span class=\"n\">hqp</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hpq</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hqp</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">⟩,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 264646590,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1639347206
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"416322\">@Bernd Losert</span> By the way, instead of proving some antisymmetry lemma directly, you probably want to put a partial order structure on <code>convergence_space a</code>, and then it will be accessible as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/le_antisymm\">docs#le_antisymm</a>, while also hooking your result in to all the other lemmas about partial orders.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">convergence_space</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">iff.intro</span> <span class=\"n\">h'</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"bp\">..</span> <span class=\"n\">convergence_space.has_le</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 264646876,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1639347593
    },
    {
        "content": "<p>Actually, that's what I'm doing. I just wrote it out as a lemma to demonstrate my issue.</p>",
        "id": 264646962,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1639347714
    },
    {
        "content": "<p>When I use your suggested instance, I get this error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"n\">convergence_space.has_le</span>\n<span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">has_le</span> <span class=\"o\">(</span><span class=\"n\">convergence_space</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 264647027,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1639347779
    },
    {
        "content": "<p>Ah, it's because of <code>a</code> in <code>has_le a</code>.</p>",
        "id": 264647106,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1639347861
    },
    {
        "content": "<p>Bernd, <code>iff</code> is an inductive type that produces a Prop. It has one single constructor, <code>iff.intro</code>. So either you say <code>iff.intro h' h</code>, or you say <code>⟨h', h⟩</code> because those chevrons are constructor notation (when used in this location). Whether or not you include <code>l</code> and <code>x</code> depends on the type of argument you made them be. In your definition on le you made them implicit, which is why you only need <code>h'</code> and <code>h</code>.</p>",
        "id": 264647116,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639347887
    },
    {
        "content": "<p>Makes sense.</p>",
        "id": 264647233,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1639347979
    }
]
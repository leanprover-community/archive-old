[
    {
        "content": "<p>Here is the lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ultrafilter_comap_set</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">𝒱</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒱</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∃</span> <span class=\"bp\">𝒰</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">𝒰.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"bp\">𝒱</span> <span class=\"bp\">∧</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒰</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"c1\">-- 𝒰 will be the ultrafilter generated by the filter base { (f ⁻¹' V ∩ A) | V ∈ 𝒱 }</span>\n  <span class=\"k\">let</span> <span class=\"n\">B₀</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">ℬ</span> <span class=\"o\">:</span> <span class=\"n\">filter_basis</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">sets</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒱</span> <span class=\"o\">},</span>\n    <span class=\"n\">nonempty</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">B₀</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">inter_sets</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n      <span class=\"k\">assume</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n      <span class=\"k\">assume</span> <span class=\"n\">B'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n      <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒱</span><span class=\"o\">,</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">h₁'</span> <span class=\"o\">:</span> <span class=\"n\">V'</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒱</span><span class=\"o\">,</span> <span class=\"n\">h₂'</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V'</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B'</span><span class=\"o\">⟩,</span>\n      <span class=\"k\">let</span> <span class=\"n\">B''</span> <span class=\"o\">:=</span> <span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">B'</span><span class=\"o\">,</span>\n      <span class=\"n\">use</span> <span class=\"n\">B''</span><span class=\"o\">,</span>\n      <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">∩</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B''</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"k\">calc</span>\n        <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">∩</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">set.preimage_inter</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V'</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">tauto</span><span class=\"o\">}</span>\n        <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"bp\">∩</span> <span class=\"n\">B'</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">h₂'</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">V</span> <span class=\"bp\">∩</span> <span class=\"n\">V'</span><span class=\"o\">,</span> <span class=\"bp\">𝒱.</span><span class=\"n\">inter_sets</span> <span class=\"n\">h₁</span> <span class=\"n\">h₁'</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">set.subset.rfl</span><span class=\"o\">],</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"k\">let</span> <span class=\"n\">ℱ</span> <span class=\"o\">:=</span> <span class=\"n\">ℬ.filter</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">ℱ</span> <span class=\"o\">:=</span> <span class=\"n\">ℬ.mem_filter_iff.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">B₀</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">set.inter_subset_right</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"n\">A</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">ℱ.ne_bot</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"n\">ℬ.has_basis.ne_bot_iff</span><span class=\"o\">,</span>\n    <span class=\"k\">assume</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒱</span><span class=\"o\">,</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"n\">set.inter_comm</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">set.image_inter_nonempty_iff</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒱</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">𝒱.</span><span class=\"n\">inter_sets</span> <span class=\"n\">h</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ultrafilter.nonempty_of_mem</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"bp\">𝒰</span> <span class=\"o\">:=</span> <span class=\"n\">ultrafilter.of</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"bp\">𝒰</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n\n  <span class=\"k\">show</span> <span class=\"bp\">𝒰.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"bp\">𝒱</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒱</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"n\">ℱ</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n      <span class=\"k\">assume</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">,</span>\n      <span class=\"k\">assume</span> <span class=\"n\">hV</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒱</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">filter_basis.mem_filter_iff</span> <span class=\"n\">ℬ</span><span class=\"o\">,</span>\n      <span class=\"k\">let</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n      <span class=\"n\">use</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n      <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"k\">show</span> <span class=\"n\">B</span> <span class=\"bp\">∈</span> <span class=\"n\">ℬ</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hV</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n      <span class=\"k\">show</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">set.inter_subset_left</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">𝒰</span> <span class=\"bp\">≤</span> <span class=\"bp\">𝒱</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"k\">calc</span>\n      <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">𝒰</span> <span class=\"bp\">≤</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">ℱ</span> <span class=\"o\">:</span> <span class=\"n\">filter.map_mono</span> <span class=\"o\">(</span><span class=\"n\">ultrafilter.of_le</span> <span class=\"n\">ℱ</span><span class=\"o\">)</span>\n      <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"bp\">𝒱</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">filter.tendsto_def.mpr</span> <span class=\"n\">this</span><span class=\"o\">),</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">𝒰</span> <span class=\"bp\">=</span> <span class=\"bp\">𝒱</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">(</span><span class=\"bp\">𝒱.</span><span class=\"n\">unique</span> <span class=\"n\">this</span><span class=\"o\">),</span>\n    <span class=\"n\">exact_mod_cast</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n\n  <span class=\"k\">show</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒰</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">filter.le_def.mp</span> <span class=\"o\">(</span><span class=\"n\">ultrafilter.of_le</span> <span class=\"n\">ℱ</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">assumption</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">ℱ</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I couldn't find anything like this in mathlib. I thought proving it would be simple, but it turned out not to be the case. I was thinking about contributing this since it is a non-trivial result. Any thoughts? Should I just open a PR?</p>",
        "id": 267841933,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642065452
    },
    {
        "content": "<p>Can you promote that from an existential to a construction?</p>",
        "id": 267842494,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1642065729
    },
    {
        "content": "<p>That is, something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ultrafilter_comap_set</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">𝒱</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒱</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">ultrafilter</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">map_ultrafilter_comap_set</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">𝒱</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒱</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">ultrafilter_comap_set</span> <span class=\"n\">f</span> <span class=\"n\">A</span><span class=\"bp\">𝒱</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"bp\">𝒱</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_ultrafilter_comap_set</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">𝒱</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒱</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">ultrafilter_comap_set</span> <span class=\"n\">f</span> <span class=\"n\">A</span><span class=\"bp\">𝒱</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 267842876,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1642065944
    },
    {
        "content": "<p>Yes I can.</p>",
        "id": 267844805,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642066966
    },
    {
        "content": "<p>I know I will also need to change the variable names to fit the style of order.filter.ultrafilter. Also, I'm not sure about the name of this thing.</p>",
        "id": 267844862,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642067016
    },
    {
        "content": "<p>I think this proof is needlessly complicated, I'll try to find time to write a shorter proof.</p>",
        "id": 267847177,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1642068359
    },
    {
        "content": "<p>Yeah, my tactic skills (or lack thereof) shows.</p>",
        "id": 267847715,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642068671
    },
    {
        "content": "<p>This is not a question of tactic skills. You need to get used to how much structure we use on filters, especially push-forward, pull-back, inf and sup. And of course you need to know the library.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.bases</span> <span class=\"n\">order.filter.ultrafilter</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span> <span class=\"n\">set</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ultrafilter.eq_of_le</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">ultrafilter.coe_injective</span> <span class=\"o\">(</span><span class=\"n\">b.unique</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">ultrafilter</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ultrafilter_comap_set</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"bp\">𝒰</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">𝒰.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒰</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">V</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span> <span class=\"n\">comap_inf_principal_ne_bot_of_image_mem</span> <span class=\"n\">V.ne_bot</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">V</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">of_le</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">mem_inf_of_right</span> <span class=\"bp\">$</span> <span class=\"n\">mem_principal_self</span> <span class=\"n\">A</span><span class=\"o\">)⟩,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">eq_of_le</span><span class=\"o\">,</span>\n  <span class=\"k\">calc</span> <span class=\"n\">filter.map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">V</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">A</span><span class=\"o\">))</span>\n      <span class=\"bp\">≤</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">V</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">map_mono</span> <span class=\"o\">(</span><span class=\"n\">of_le</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">$</span> <span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">⊓</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">𝓟</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">map_inf_le</span>\n  <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">$</span> <span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">⊓</span> <span class=\"o\">(</span><span class=\"bp\">𝓟</span> <span class=\"bp\">$</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">map_principal</span>\n  <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span> <span class=\"bp\">⊓</span> <span class=\"o\">(</span><span class=\"bp\">𝓟</span> <span class=\"bp\">$</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inf_le_inf_right</span> <span class=\"n\">_</span> <span class=\"n\">map_comap_le</span>\n  <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">inf_of_le_left</span> <span class=\"o\">(</span><span class=\"n\">le_principal_iff.mpr</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 267863332,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1642077918
    },
    {
        "content": "<p>As you can see, the core of the proof is a <em>computation</em> using all the structure I mentioned. As far as I know, this doesn't exist anywhere else (it certainly doesn't exist in Bourbaki).</p>",
        "id": 267863475,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1642078012
    },
    {
        "content": "<p>I did try to make it work with <code>comap f V ⊓ 𝓟 A</code>, but I ran into problems when I wanted to show the equality <code>𝒰.map f = V</code>, so I tried a different approach.<br>\nI have not used the <code>refine</code> tactic yet, so I'm not sure what magic it does.</p>",
        "id": 267898144,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642093202
    },
    {
        "content": "<blockquote>\n<p>And of course you need to know the library.</p>\n</blockquote>\n<p>Yeah, this is a major issue I have.</p>",
        "id": 267898722,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642093402
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"416322\">@Bernd Losert</span> <code>refine</code> is like <code>exact</code> but any holes you leave (the underscores) become new goals if Lean doesn't otherwise figure them out for you.</p>",
        "id": 267899260,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1642093619
    },
    {
        "content": "<p>For example, say <code>f</code> has two arguments, then <code>apply f</code> and <code>refine f _ _</code> have a similar effect.</p>",
        "id": 267899459,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1642093699
    },
    {
        "content": "<p>Ah, that's interesting.</p>",
        "id": 267899504,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642093718
    },
    {
        "content": "<p>It's also useful for using custom induction lemmas since it gives you more control (and also the <code>induction</code> tactic seems to have some longstanding bugs...). Setting up strong induction, for example: <code>refine nat.strong_induction_on n (λ n' ih, _)</code></p>",
        "id": 267900193,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1642093977
    },
    {
        "content": "<p><code>refine</code> isn't doing anything fancy here. You could write the exact same proof as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ultrafilter_comap_set</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"bp\">𝒰</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">𝒰.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝒰</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">V</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span> <span class=\"n\">comap_inf_principal_ne_bot_of_image_mem</span> <span class=\"n\">V.ne_bot</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">V</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">eq_of_le</span><span class=\"o\">,</span>\n    <span class=\"k\">calc</span> <span class=\"n\">filter.map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">V</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"bp\">≤</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">V</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">map_mono</span> <span class=\"o\">(</span><span class=\"n\">of_le</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">$</span> <span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">⊓</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">𝓟</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">map_inf_le</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">$</span> <span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">⊓</span> <span class=\"o\">(</span><span class=\"bp\">𝓟</span> <span class=\"bp\">$</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">map_principal</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span> <span class=\"bp\">⊓</span> <span class=\"o\">(</span><span class=\"bp\">𝓟</span> <span class=\"bp\">$</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inf_le_inf_right</span> <span class=\"n\">_</span> <span class=\"n\">map_comap_le</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">inf_of_le_left</span> <span class=\"o\">(</span><span class=\"n\">le_principal_iff.mpr</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">of_le</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">mem_inf_of_right</span> <span class=\"bp\">$</span> <span class=\"n\">mem_principal_self</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 267908078,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1642097328
    },
    {
        "content": "<p>If anything is fancy here then it's the anonymous constructor notation (the angle brackets) and its convenient \"associativity\".</p>",
        "id": 267908181,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1642097386
    },
    {
        "content": "<p><code>refine</code> is a really fundamental tactic. In a very real sense, every tactic is a special case of <code>refine</code>.</p>",
        "id": 267908365,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1642097475
    },
    {
        "content": "<p>I don't remember seeing <code>refine</code> in \"Theorem proving with Lean\". Most of my tactic knowledge comes from there.</p>",
        "id": 267908759,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642097669
    },
    {
        "content": "<p>Isn't <code>refine</code> the only tactic that exists in agda? (This is only partially a joke)</p>",
        "id": 267908777,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642097674
    },
    {
        "content": "<p>The only tactic I know of in Agda is <code>rewrite</code>.</p>",
        "id": 267908844,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642097710
    },
    {
        "content": "<p>I'm not aware of how updated this list is, but <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html\">https://leanprover-community.github.io/mathlib_docs/tactics.html</a> contains a more complete set of possibilities available in mathlib</p>\n<p>(tip: it's a bit overwhelming, so don't worry too much)</p>",
        "id": 267908994,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1642097780
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"416322\">@Bernd Losert</span> <code>refine</code> is the analogue of agda's <code>C-c C-r</code> (in emacs)</p>",
        "id": 267909135,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642097863
    },
    {
        "content": "<p>Ah, I don't use emacs with Agda, so no clue.</p>",
        "id": 267909311,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642097942
    },
    {
        "content": "<p>Is it possible to write agda without emacs?</p>",
        "id": 267909388,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642097986
    },
    {
        "content": "<p>Of course. I'm also writing Lean without emacs or vscode.</p>",
        "id": 267909501,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642098017
    },
    {
        "content": "<p>I use vim.</p>",
        "id": 267909549,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642098039
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"VimL\"><pre><span></span><code><span class=\"c\">\" C-c C-r -&gt; \\r</span>\n<span class=\"nb\">nnoremap</span> <span class=\"p\">&lt;</span>buffer<span class=\"p\">&gt;</span> <span class=\"p\">&lt;</span>LocalLeader<span class=\"p\">&gt;</span><span class=\"k\">r</span> :<span class=\"k\">call</span> AgdaRefine<span class=\"p\">(</span><span class=\"s2\">\"False\"</span><span class=\"p\">)&lt;</span>CR<span class=\"p\">&gt;</span>\n<span class=\"nb\">nnoremap</span> <span class=\"p\">&lt;</span>buffer<span class=\"p\">&gt;</span> <span class=\"p\">&lt;</span>LocalLeader<span class=\"p\">&gt;</span>R :<span class=\"k\">call</span> AgdaRefine<span class=\"p\">(</span><span class=\"s2\">\"True\"</span><span class=\"p\">)&lt;</span>CR<span class=\"p\">&gt;</span>\n</code></pre></div>",
        "id": 267909631,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642098086
    },
    {
        "content": "<p>:)<br>\nMy vim setup is very plain. I just run <code>agda</code> on the files, so no hole-driven development for me.</p>",
        "id": 267909859,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642098196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416322\">Bernd Losert</span> <a href=\"#narrow/stream/113488-general/topic/contribute.20lemma.20to.20mathlib/near/267909549\">said</a>:</p>\n<blockquote>\n<p>I use vim.</p>\n</blockquote>\n<p>Are you using lean.nvim or doing something similarly barebones for lean</p>",
        "id": 267910086,
        "sender_full_name": "Julian Berman",
        "timestamp": 1642098323
    },
    {
        "content": "<p>Barebones. I basically run <code>!lean %</code> to type check the file I'm working on.</p>",
        "id": 267933314,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642109209
    },
    {
        "content": "<p>Brave.</p>",
        "id": 267933733,
        "sender_full_name": "Julian Berman",
        "timestamp": 1642109447
    },
    {
        "content": "<p>By doing so, you've really decreased the \"interactive\" in interactive theorem prober</p>",
        "id": 267933913,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1642109548
    },
    {
        "content": "<p>Because you've lost the ability to see the goal automatically at different places in your tactic proofs</p>",
        "id": 267933944,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1642109574
    },
    {
        "content": "<p>So you're basically limited to constructing proofs that are basically the equivalent of term mods proofs with holes.</p>",
        "id": 267934029,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1642109621
    },
    {
        "content": "<p>Which is now explains why your proof at the beginning of the thread is the way it is</p>",
        "id": 267934110,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1642109650
    },
    {
        "content": "<p>Yes. I tried using vscode (again). The feedback in goals is super fast. Unfortunately, vscode has the bad habit of dying on me and sending all my cpus to 100%.</p>",
        "id": 267934353,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642109822
    },
    {
        "content": "<p>It's also a giant time sink to be honest.</p>",
        "id": 267934382,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642109839
    },
    {
        "content": "<p>I used to use emacs before too. But after I while I also realized it was a giant time sink.</p>",
        "id": 267934535,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642109920
    },
    {
        "content": "<p>Have you tried doom emacs? It works pretty much right out of the box.</p>",
        "id": 267934567,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642109942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416322\">Bernd Losert</span> <a href=\"#narrow/stream/113488-general/topic/contribute.20lemma.20to.20mathlib/near/267933314\">said</a>:</p>\n<blockquote>\n<p>Barebones. I basically run <code>!lean %</code> to type check the file I'm working on.</p>\n</blockquote>\n<p>This is definitely not recommended.</p>",
        "id": 267934606,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642109963
    },
    {
        "content": "<p>Never tried doom emacs. Maybe I'll give it a try again at some point. I'm doing fine with vim at the moment.</p>",
        "id": 267935018,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642110198
    },
    {
        "content": "<p>Any reason you're <em>not</em> using lean.nvim I suppose I should ask (even just for feedback)?</p>",
        "id": 267938348,
        "sender_full_name": "Julian Berman",
        "timestamp": 1642111975
    },
    {
        "content": "<p>Is it because you're using vanilla vim?</p>",
        "id": 267938362,
        "sender_full_name": "Julian Berman",
        "timestamp": 1642111984
    },
    {
        "content": "<p>Correct.</p>",
        "id": 267939219,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642112267
    },
    {
        "content": "<p>Seems like switching to neovim should be easier than switching to emacs :) -- but even if you stick with your current thing, even just using <code>coc</code> is going to be lots more fun than <code>!lean %</code>, but it's your party.</p>",
        "id": 267939811,
        "sender_full_name": "Julian Berman",
        "timestamp": 1642112559
    },
    {
        "content": "<p>What's coc?</p>",
        "id": 267939921,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642112626
    },
    {
        "content": "<p>An LSP client (one that works for vanilla vim).</p>",
        "id": 267940014,
        "sender_full_name": "Julian Berman",
        "timestamp": 1642112654
    },
    {
        "content": "<p>Ah, OK. There was a time when I used neovim with LSP and all sorts of customizations. But at some point I realized that the benefit I got from it was marginal and started reverting to a more simpler setup. I work as developer, so I've gone through a couple of IDEs. And I've always abandoned them for vim in the end.</p>",
        "id": 267940410,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642112881
    },
    {
        "content": "<p>Sure, I understand, I hate IDEs and don't use anything but (neo)vim :), but I've never done so quite as barebones as you're doing now, I think it'd get quite annoying to me not seeing the goal state.Do what makes you happy (says the guy who ignored people who said lean doesn't support vim and did it anyway :P) but you may try something else for a bit just to see what you're missing from Lean, and then if you're really happy the way you were you go back. And in a biased way I'd try lean.nvim as the closest to what you're doing now :P.</p>",
        "id": 267940722,
        "sender_full_name": "Julian Berman",
        "timestamp": 1642113041
    },
    {
        "content": "<p>Or watch the demo at least maybe -- <a href=\"https://github.com/Julian/lean.nvim/\">https://github.com/Julian/lean.nvim/</a> it's out of date, things look nicer now, but it's close to what my setup looks like.</p>",
        "id": 267940769,
        "sender_full_name": "Julian Berman",
        "timestamp": 1642113071
    },
    {
        "content": "<p>Looks pretty good. Thanks for suggesting it. The only thing that would annoy me is the pop-ups. I've grown to dislike pop-ups.</p>",
        "id": 267945032,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642115412
    },
    {
        "content": "<p>None of that is required (and in my own setup, no popups at this point happen automatically, they're all key driven).</p>",
        "id": 267945357,
        "sender_full_name": "Julian Berman",
        "timestamp": 1642115607
    },
    {
        "content": "<p>The discussion has turned into a talk about text editors (someone might split this thread). So I am going to say something: learning vim/neovim is an old dream of mine and I'd love to learn how to use it with Lean <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 267962245,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1642129379
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> : I have broken-up the proof by <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">ultrafilter</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eq_of_le</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"n\">coe_injective</span> <span class=\"o\">(</span><span class=\"n\">g.unique</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">comap_inf_principal_ne_bot_of_image_mem</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">filter.comap</span> <span class=\"n\">m</span> <span class=\"n\">g</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"n\">filter.comap_inf_principal_ne_bot_of_image_mem</span> <span class=\"n\">g.ne_bot</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">of_comap_inf_principal</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">filter.comap</span> <span class=\"n\">m</span> <span class=\"n\">g</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span> <span class=\"n\">comap_inf_principal_ne_bot_of_image_mem</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">filter.comap</span> <span class=\"n\">m</span> <span class=\"n\">g</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of_comap_inf_principal_ultrafilter_mem</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">of_comap_inf_principal</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">filter.comap</span> <span class=\"n\">m</span> <span class=\"n\">g</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span> <span class=\"n\">comap_inf_principal_ne_bot_of_image_mem</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">filter.comap</span> <span class=\"n\">m</span> <span class=\"n\">g</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">mem_inf_of_right</span> <span class=\"o\">(</span><span class=\"n\">mem_principal_self</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">filter.le_def.mp</span> <span class=\"o\">(</span><span class=\"n\">of_le</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"n\">this</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of_comap_inf_principal_ultrafilter_eq_of_map</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">of_comap_inf_principal</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">filter.comap</span> <span class=\"n\">m</span> <span class=\"n\">g</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span> <span class=\"n\">comap_inf_principal_ne_bot_of_image_mem</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">eq_of_le</span><span class=\"o\">,</span>\n  <span class=\"k\">calc</span> <span class=\"n\">filter.map</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">filter.comap</span> <span class=\"n\">m</span> <span class=\"n\">g</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">≤</span> <span class=\"n\">filter.map</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">filter.comap</span> <span class=\"n\">m</span> <span class=\"n\">g</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">filter.map_mono</span> <span class=\"o\">(</span><span class=\"n\">of_le</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">filter.map</span> <span class=\"n\">m</span> <span class=\"bp\">$</span> <span class=\"n\">filter.comap</span> <span class=\"n\">m</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">⊓</span> <span class=\"n\">filter.map</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"bp\">𝓟</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">filter.map_inf_le</span>\n  <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">filter.map</span> <span class=\"n\">m</span> <span class=\"bp\">$</span> <span class=\"n\">filter.comap</span> <span class=\"n\">m</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">⊓</span> <span class=\"o\">(</span><span class=\"bp\">𝓟</span> <span class=\"bp\">$</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">filter.map_principal</span>\n  <span class=\"bp\">...</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span> <span class=\"bp\">⊓</span> <span class=\"o\">(</span><span class=\"bp\">𝓟</span> <span class=\"bp\">$</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inf_le_inf_right</span> <span class=\"n\">_</span> <span class=\"n\">filter.map_comap_le</span>\n  <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">inf_of_le_left</span> <span class=\"o\">(</span><span class=\"n\">le_principal_iff.mpr</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">ultrafilter</span>\n</code></pre></div>\n<p>One thing that bugs me is that I have to keep repeating the <code>haveI</code>part. Is there a way to prevent this?</p>\n<p>If anyone has any other feedback about this code, please let me know.</p>",
        "id": 267996755,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642156846
    },
    {
        "content": "<p>Most of those <code>def</code>s should be lemmas, only the actual construction (<code>of_comap_inf_principal</code>) should be a <code>def</code>. I'm not familiar with this part of mathlib so can't really advise much beyond that.</p>",
        "id": 267998804,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1642158043
    },
    {
        "content": "<p>Ah, good point.</p>",
        "id": 267999158,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642158290
    },
    {
        "content": "<p>Any thoughts on the <code>haveI</code> issue?</p>",
        "id": 267999824,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642158688
    },
    {
        "content": "<p>There might be a trick - this works, but is uglier than what you have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">of_comap_inf_principal_ultrafilter_mem</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">of_comap_inf_principal</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">filter.comap</span> <span class=\"n\">m</span> <span class=\"n\">g</span> <span class=\"bp\">⊓</span> <span class=\"bp\">𝓟</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">mem_inf_of_right</span> <span class=\"o\">(</span><span class=\"n\">mem_principal_self</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">filter.le_def.mp</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">of_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"n\">s</span> <span class=\"n\">this</span><span class=\"o\">,</span>  <span class=\"c1\">-- find the instance by unification rather than typeclass search</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>There might be a nicer way to spell that.</p>",
        "id": 268000030,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1642158825
    },
    {
        "content": "<p>I made a PR: <a href=\"https://github.com/leanprover-community/mathlib/pull/11445\">https://github.com/leanprover-community/mathlib/pull/11445</a>.</p>",
        "id": 268004172,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1642161455
    }
]
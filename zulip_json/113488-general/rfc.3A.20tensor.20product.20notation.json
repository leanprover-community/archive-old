[
    {
        "content": "<p>Tl;dr: I think the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\otimes</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>⊗</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x \\otimes y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> will be used an order of magnitude more often than the one in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>⊗</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>. Hence I would like to swap the subscript <code>ₜ</code> from the former to the latter.</p>\n<hr>\n<p>Longer story:<br>\nI'm planning a refactor of tensor products. Roughly speaking, I want to use a characteristic predicate instead of the explicit construction. This will allow us to treat <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">R \\otimes_R M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>, or to treat <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[X]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><msub><mo>⊗</mo><mi>R</mi></msub><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">R[X] \\otimes_R A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, etc...</p>\n<p>As part of this, I'm proposing a <code>has_tmul</code> class, that will enable tensor product notation.</p>\n<p>With this post, I want to ask whether people are happy with the following notation change.</p>\n<p>Current situation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- tensor product of elements (terms)</span>\n<span class=\"n\">x</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">y</span>\n<span class=\"n\">x</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">y</span>\n\n<span class=\"c1\">-- tensor product of modules (types)</span>\n<span class=\"n\">M</span> <span class=\"bp\">⊗</span> <span class=\"n\">N</span>\n<span class=\"n\">M</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span>\n</code></pre></div>\n<p>My proposal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- tensor product of elements (terms)</span>\n<span class=\"n\">x</span> <span class=\"bp\">⊗</span> <span class=\"n\">y</span>\n<span class=\"n\">x</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">y</span>\n\n<span class=\"c1\">-- tensor product of modules (types)</span>\n<span class=\"n\">M</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">N</span>\n<span class=\"n\">M</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span>\n</code></pre></div>\n<p>I think that currently the subscript <code>ₜ</code> stands for <code>terms</code>, but it could just as well stand for <code>types</code> (or <code>tmul</code> or <code>tensor</code>). So as a mnemonic, it doesn't matter too much where it sits.</p>\n<p>The reason I would like to change this, is that if we switch to the characteristic predicate, we will be talking a lot about tensor products of terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>⊗</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x \\otimes y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span>, but not so much about the explicit construction <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>⊗</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> of tensor products of modules. Instead, we will usually introduce an auxiliary module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> that satisfies the characteristic predicate, and hence is canonically isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>⊗</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>.</p>",
        "id": 252830370,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631299039
    },
    {
        "content": "<p>Is it definitely not possible to overload the notation like we do in regular maths? (one works on types, one on terms...)</p>",
        "id": 252832053,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631299767
    },
    {
        "content": "<p>those aren't exactly disjoint classes</p>",
        "id": 252832182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631299816
    },
    {
        "content": "<p>strictly speaking you could have a module whose elements are types</p>",
        "id": 252832228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631299841
    },
    {
        "content": "<p>only in your crazed computer science theoretical model of how things might be</p>",
        "id": 252832290,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631299870
    },
    {
        "content": "<p>but I take your point</p>",
        "id": 252832315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631299885
    },
    {
        "content": "<p>The best you can say is that there are two functions and if you pick the wrong one a typeclass search will fail</p>",
        "id": 252832443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631299930
    },
    {
        "content": "<p>I don't know whether / to what extent typeclass search can be used for overload resolution</p>",
        "id": 252832488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631299950
    },
    {
        "content": "<p>The way we dealt with <code>|</code> vs <code>\\|</code> was to use two extremely similar unicode characters with different shortcuts. Can we pull this off here?</p>",
        "id": 252832495,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631299953
    },
    {
        "content": "<p>sure, just smuggle a zero width space in somewhere</p>",
        "id": 252832574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631299985
    },
    {
        "content": "<p>Basically the less it looks like normal maths, the less good it is, so in some sense this change is fine by me because it didn't look quite like normal maths before and it won't quite look like it afterwards, but if we could come up with a better idea where it looked like normal maths and people who are confused can get unconfused by hovering then this would be a solution which would be nicer as far as I'm concerned.</p>",
        "id": 252832743,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631300059
    },
    {
        "content": "<p>Is the zero width space suggestion a serious one? Can we make it so that <code>\\otimes</code> gives the type one and <code>\\otimest</code> gives the term one, for example?</p>",
        "id": 252832868,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631300113
    },
    {
        "content": "<p>wooah <a href=\"https://www.fileformat.info/info/unicode/char/26d2/index.htm\">https://www.fileformat.info/info/unicode/char/26d2/index.htm</a></p>",
        "id": 252832923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631300137
    },
    {
        "content": "<p>I know it will be considered seriously by crazed mathematicians, I haven't decided how to feel about it yet</p>",
        "id": 252832936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631300144
    },
    {
        "content": "<p>\"road closed\"</p>",
        "id": 252832972,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631300156
    },
    {
        "content": "<p>lolol</p>",
        "id": 252833037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631300167
    },
    {
        "content": "<p>I'm pretty sure lean-liquid uses zero width spaces somewhere</p>",
        "id": 252833088,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631300187
    },
    {
        "content": "<p>The zero-width space option (the unicode confusable option is similar) has the drawback that it is hostile to authors since they can't see the effect of a typo</p>",
        "id": 252833156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631300216
    },
    {
        "content": "<p>wait there really are two unicode chars? <a href=\"https://www.fileformat.info/info/unicode/char/2a02/index.htm\">https://www.fileformat.info/info/unicode/char/2a02/index.htm</a> and <a href=\"https://www.fileformat.info/info/unicode/char/2297/index.htm\">https://www.fileformat.info/info/unicode/char/2297/index.htm</a> ?</p>",
        "id": 252833260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631300261
    },
    {
        "content": "<p>there's even <a href=\"https://www.fileformat.info/info/unicode/char/2b59/index.htm\">https://www.fileformat.info/info/unicode/char/2b59/index.htm</a></p>",
        "id": 252833414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631300315
    },
    {
        "content": "<p>The unicode confusable option is strictly better than the zero width space option, right? Because I can't make <code>\\otimest</code> produce <code>\\otimes</code> + zero_width_space presumably?</p>",
        "id": 252833637,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631300406
    },
    {
        "content": "<p>you can</p>",
        "id": 252833742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631300436
    },
    {
        "content": "<p>For me this is no less hostile than the issues we have with <code>|</code> vs <code>\\|</code> (which I see when doing number theory with undergrads asking me why 2 divides 4 doesn't typecheck)</p>",
        "id": 252833890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631300511
    },
    {
        "content": "<p>I am very conflicted about the idea of using symbols that are documented to cause confusion for related but different purposes</p>",
        "id": 252834016,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631300564
    },
    {
        "content": "<p>You are right that <code>|</code> vs <code>\\|</code> is the same sort of thing</p>",
        "id": 252834062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631300588
    },
    {
        "content": "<p>I'll add another proposal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- tensor product of elements (terms)</span>\n<span class=\"n\">x</span> <span class=\"bp\">⊗</span> <span class=\"n\">y</span>\n<span class=\"n\">x</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">y</span>\n\n<span class=\"c1\">-- tensor product of modules (types)</span>\n<span class=\"n\">M</span> <span class=\"bp\">⊠</span> <span class=\"n\">N</span>\n<span class=\"n\">M</span> <span class=\"bp\">⊠</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span>\n</code></pre></div>\n<p>(I know <code>⊠</code> can have some other meaning, though, as the tensor product over the tensor product of rings.)</p>",
        "id": 252834110,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631300622
    },
    {
        "content": "<p>Isn't this worse than using a different \\otimes? Because now this is actually wrong, that symbol is some sort of external tensor product thing which I've never properly understood.</p>",
        "id": 252834242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631300680
    },
    {
        "content": "<p>I've seen it used to mean normal tensor product (occasionally), so I'm not sure there's a standard meaning.</p>",
        "id": 252834314,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631300724
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/external%20tensor%20product\">https://ncatlab.org/nlab/show/external%20tensor%20product</a></p>",
        "id": 252834373,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631300758
    },
    {
        "content": "<p>is there a circled comma? That would be great</p>",
        "id": 252834420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631300765
    },
    {
        "content": "<p><code>❟</code> anyone?</p>",
        "id": 252834601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631300842
    },
    {
        "content": "<p>maybe we should add it to the proposal for the unicode guys together with those missing subscript letters</p>",
        "id": 252834641,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631300858
    },
    {
        "content": "<p>I think a comma-like operator makes a lot more sense for the tensor product of elements than an <code>\\otimes</code> given the notational conventions elsewhere in lean</p>",
        "id": 252834821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631300943
    },
    {
        "content": "<p>I wish there were a TRIANGLED TIMES to complement SQUARED TIMES, since it'd be a mnemonic that it's a tensor product with a diagonal action.</p>",
        "id": 252835045,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631301046
    },
    {
        "content": "<p>Could we use <code>\\Ox</code> for types and <code>\\ox</code> for terms? These are two of the characters I mentioned earlier. We have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> This enables the notation `⨂[R] i : ι, s i` for the pi tensor product, given `s : ι → Type*`. -/</span>\n<span class=\"n\">localized</span> <span class=\"s2\">\"notation `⨂[`:100 R `] ` binders `, ` r:(scoped:67 f, pi_tensor_product R f) := r\"</span>\n  <span class=\"k\">in</span> <span class=\"n\">tensor_product</span>\n</code></pre></div>\n<p>and does that stop us also using it for <code>M ⨂[R] N</code>? Alternatively <code>⭙</code> is unused in mathlib and looks exactly the same as <code>\\ox</code> in my font unless you zoom in super-close</p>",
        "id": 252835410,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631301215
    },
    {
        "content": "<p>I like <a href=\"https://www.fileformat.info/info/unicode/char/26d2/index.htm\">⛒</a> because it looks quite enough like the tensor product, but is also a bit different if you look close enough.</p>",
        "id": 252835602,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1631301313
    },
    {
        "content": "<p>I agree that <code>(a,b)</code> has type <code>A \\times B</code> but unfortunately mathematicians are just going to get confused by specialised notation which is unrecognisable to them. I think the Johan's original \"switch the _t\" idea is better than a comma thing, even though I do understand the logic -- I think we should aim for readability for mathematicians above all else</p>",
        "id": 252835605,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631301315
    },
    {
        "content": "<p>Is it OK to use road closed symbols for uses other than their intended purpose?</p>",
        "id": 252835764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631301382
    },
    {
        "content": "<p>I don't think we intend to close any roads in mathlib</p>",
        "id": 252835788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631301397
    },
    {
        "content": "<p>so it's probably fine</p>",
        "id": 252835792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631301401
    },
    {
        "content": "<p>I'm pretty sure we are abusing tons of unicode symbols already</p>",
        "id": 252835860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631301443
    },
    {
        "content": "<p>Ok, one more proposal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- tensor product of elements (terms)</span>\n<span class=\"n\">x</span> <span class=\"bp\">⊠</span> <span class=\"n\">y</span>\n<span class=\"n\">x</span> <span class=\"bp\">⊠</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">y</span>\n\n<span class=\"c1\">-- tensor product of modules (types)</span>\n<span class=\"n\">M</span> <span class=\"bp\">⊗</span> <span class=\"n\">N</span>\n<span class=\"n\">M</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span>\n</code></pre></div>\n<p>The justification is that (I think) there's a sense in which the external tensor product of terms is the usual tensor product of terms.  If <code>M</code> is a module, you can think of it as a 0-category whose objects are the terms of <code>M</code>, and the exterior tensor product of a term of <code>M</code> and a term of <code>N</code> is a term of the tensor product of these two 0-categories.</p>",
        "id": 252835865,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631301446
    },
    {
        "content": "<p>If Johan is correct then this would mean that the weird-to-mathematicians symbol would be the prevalent one, which is not ideal.</p>",
        "id": 252835979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631301487
    },
    {
        "content": "<p>I think using similar-looking (or invisible) unicode characters as a design is a sketchy hack -- it's important to be able to look at some Lean code and know what it means.  Otherwise, how can we know that we've proved the theorems we intended to prove without going through with an editor checking each characters' Unicode codepoints?</p>\n<p><code>|</code> vs <code>∣</code> and <code>∑</code> vs <code>Σ</code> are bad enough, and I'm not looking forward to having more of it...</p>",
        "id": 252837657,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631302096
    },
    {
        "content": "<p>(My biases: \"a little notation is nice for algebraic reasoning, but I'm a fan of Lisp and Scheme.\")</p>",
        "id": 252837965,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631302241
    },
    {
        "content": "<p>On the one hand we have the very remote but I guess pretty serious possibility that someone tensors two types together using term-tensor by accident and there happened to be a module structure on <code>Type u</code> so it compiled and gave a super-super-hard to find bug or even worse a misleading result, and on the other hand we have the issue of making our theorem statements readable to mathematicians with no training.</p>",
        "id": 252839517,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631302970
    },
    {
        "content": "<p>It might be worth considering how any changes might interact with the monoidal product notation for monoidal categories: <a href=\"https://github.com/leanprover-community/mathlib/blob/6d2cbf9df602a9bd62cf82e7d8ed76b34f4b1e6e/src/category_theory/monoidal/category.lean#L127\">https://github.com/leanprover-community/mathlib/blob/6d2cbf9df602a9bd62cf82e7d8ed76b34f4b1e6e/src/category_theory/monoidal/category.lean#L127</a></p>",
        "id": 252839702,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631303051
    },
    {
        "content": "<p>Yeah I'm not sure I would agree with the original claim. I think I'd say that in some contexts you exclusively use the tensor product of modules and in other contexts you mostly use the tensor product of elements.</p>",
        "id": 252850379,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631307867
    },
    {
        "content": "<p>Unicode Character 'N-ARY CIRCLED TIMES OPERATOR' (U+2A02) should probably be used for the n-ary tensor product</p>",
        "id": 252850431,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631307894
    },
    {
        "content": "<p>Nowadays it's become fashionable to write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\otimes</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span> for the smash product of spectra, where there aren't really elements at all.</p>",
        "id": 252850606,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631307979
    },
    {
        "content": "<p>By the way, don't forget about ꕕ U+A555 VAI SYLLABLE KPAN or ⛒ U+26D2 CIRCLED CROSSING LANES.</p>",
        "id": 252850893,
        "sender_full_name": "Reid Barton",
        "timestamp": 1631308130
    },
    {
        "content": "<p>Yes, note we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi_tensor_product\">docs#pi_tensor_product</a> which uses the n-ary symbol</p>",
        "id": 252866800,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631318525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113488-general/topic/rfc.3A.20tensor.20product.20notation/near/252850379\">said</a>:</p>\n<blockquote>\n<p>Yeah I'm not sure I would agree with the original claim. I think I'd say that in some contexts you exclusively use the tensor product of modules and in other contexts you mostly use the tensor product of elements.</p>\n</blockquote>\n<p>My goal with the refactor is that in an unbundled situation, you should almost never mention the explicit construction. But if you are working in some bundled setup where you have a monoidal category, sure, then you'll take tensor products of objects.</p>\n<p>Do you think that makes sense? Or do you think that also in the unbundled situation, the construction should be used a good number of times, instead of some module satisfying the characteristic \"predicate\".</p>",
        "id": 252880257,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631333507
    },
    {
        "content": "<p>If you prove things for <code>is_tensor_product</code> then you'll of course be able to deduce them for the concrete tensor product, and if schemes/localisation are anything to go by, there will be plenty of instances where mathematicians use a noncanonical tensor product (possibly without noticing) so I totally agree that you'll need it. Like you I feel like the terms will be more prevalent than the types, although actually of course the terms will be taking values now in the <code>is_tensor_product</code> type now I guess, which might cause some confusion...</p>",
        "id": 252894649,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631350362
    },
    {
        "content": "<p>I would be pretty unhappy about any zero-width spaces in mathlib.</p>",
        "id": 252939979,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1631399430
    },
    {
        "content": "<p>I would love to just use the same symbol in both situations, if Lean can cope. (In the monoidal category development, there seems to have been no problem using the same symbol for tensor products of objects and of morphisms.)</p>",
        "id": 252940006,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1631399481
    },
    {
        "content": "<p>Much as I appreciate the existence of symbols from Vai, Canadian Syllabics, etc, I wouldn't like using near-indistinguishable symbols. Primes or subscripts are not terrible.</p>",
        "id": 252940090,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1631399583
    },
    {
        "content": "<p>One way to make the same symbol work would be a notation typeclass</p>",
        "id": 252940182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631399679
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.tensor_product</span>\n\n<span class=\"kd\">class</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">has_tensor</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tensor</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_tensor</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span> <span class=\"n\">has_tensor.val</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">⊗</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"o\">:=</span> <span class=\"n\">tensor</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_tensor</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">tensor_product</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_tensor</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">⊗</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">tensor_product.tmul</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">M</span> <span class=\"bp\">⊗</span> <span class=\"n\">N</span> <span class=\"c1\">-- M ⊗ N : Type v</span>\n<span class=\"k\">#check</span> <span class=\"n\">x</span> <span class=\"bp\">⊗</span> <span class=\"n\">y</span> <span class=\"c1\">-- x ⊗ y : M ⊗ N</span>\n</code></pre></div>",
        "id": 252941225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631400967
    },
    {
        "content": "<p>Ooh</p>",
        "id": 252941625,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631401412
    },
    {
        "content": "<p>Would we also then be able to use <code>x ⊗ y</code> as a term of type <code>T</code> if <code>is_tensor_product R M N T</code>?</p>",
        "id": 252941717,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631401505
    },
    {
        "content": "<p>The limitation of this approach is in the decision for <code>γ</code> to be an out_param or not. Either way there are going to be some pains because you can't use unification to infer <code>R</code>, like you would if you are literally using <code>tensor_product</code> or <code>tensor_product.tmul</code>. If the output type is some generic <code>T</code>, then it seems even harder to have it be an out_param, although it might work if there is something preventing the construction from coming up first</p>",
        "id": 252942133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631402018
    },
    {
        "content": "<p>Lean 4 would allow more flexibility to decouple the notation from the elaboration method and use domain specific tricks to distinguish the cases</p>",
        "id": 252942216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631402111
    },
    {
        "content": "<p>I guess <code>x ⊗[R] y</code> and <code>M ⊗[R] N</code> would be acceptable to mathematicians</p>",
        "id": 252942487,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631402431
    },
    {
        "content": "<p>Right now the <code>[R]</code> is optional</p>",
        "id": 252942499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631402462
    },
    {
        "content": "<p>actually in the version I just posted there is no support for the <code>R</code></p>",
        "id": 252942510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631402479
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_tensor_product</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">tensor_product</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"bp\">≃</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"c1\">-- or something</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_tensor_product</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_tensor</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">T</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">bla</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_tensor_product</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_tensor</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">is_tensor_product.e.1</span> <span class=\"o\">(</span><span class=\"n\">tensor_product.tmul</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">w</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_tensor_product</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"k\">#check</span> <span class=\"n\">M</span> <span class=\"bp\">⊗</span> <span class=\"n\">N</span> <span class=\"c1\">-- M ⊗ N : Type w</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⊗</span> <span class=\"n\">N</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">x</span> <span class=\"bp\">⊗</span> <span class=\"n\">y</span> <span class=\"c1\">-- x ⊗ y : T</span>\n</code></pre></div>",
        "id": 252942587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631402572
    },
    {
        "content": "<p>TBF I don't think this is a good idea</p>",
        "id": 252942603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631402597
    },
    {
        "content": "<p>Interesting idea!</p>",
        "id": 252946425,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631407330
    },
    {
        "content": "<p>We certainly need support for <code>[R]</code>. Because we want to be able to consider <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><msub><mo>⊗</mo><mi mathvariant=\"double-struck\">Z</mi></msub><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R \\otimes_\\Z \\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83889em;vertical-align:-0.15em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33222299999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathbb mtight\">Z</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><msub><mo>⊗</mo><mi mathvariant=\"double-struck\">R</mi></msub><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R \\otimes_\\R \\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83889em;vertical-align:-0.15em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33222299999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathbb mtight\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>. (Similarly for the termy versions.)</p>",
        "id": 252946467,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631407416
    },
    {
        "content": "<p>This seems similar to how we have <code>A × B</code> vs <code>(a, b)</code>. I've seen comments in the past saying that Haskell uses the same notation for both but it is confusing.</p>",
        "id": 252964749,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631429358
    },
    {
        "content": "<p>How about <code>(a, b)ₗ[R]</code> since <code>tensor_product</code> is like a linear version of <code>prod</code>?</p>",
        "id": 252965054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631429710
    },
    {
        "content": "<p>I think <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>⊗</mo><mi>t</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\otimes_t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2805559999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is better, because it has so much more resemblance with current usage in informal maths.</p>",
        "id": 252965288,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631429982
    },
    {
        "content": "<p>Here's a circled comma, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>:  <code>⃝,</code></p>",
        "id": 252965498,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631430184
    },
    {
        "content": "<p>We can't do commas. This is not acceptable. Mathematicians will find the code unreadable, their first question will be why we're not using the standard symbol, and any answer of the form \"we can't\" will be met with a response of \"ok I'll come back when you've figured it out\"</p>",
        "id": 252965912,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631430569
    },
    {
        "content": "<p>One reason lean caught on in the maths community is its liberal use of the correct unicode symbols for many things</p>",
        "id": 252965976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631430615
    },
    {
        "content": "<p>My impression is that the CS  people really can't see what the fuss is about here but to mathematicians it seems to make a huge difference</p>",
        "id": 252966002,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631430663
    },
    {
        "content": "<p>Would mathematicians prefer a non-comma symbol for <code>(a, b) : A × B</code> too?</p>",
        "id": 252966283,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631431029
    },
    {
        "content": "<p>No, we use commas for that</p>",
        "id": 252966288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631431044
    },
    {
        "content": "<p>What you write there is perfect</p>",
        "id": 252966305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631431071
    },
    {
        "content": "<p>Ah, I'm misremembering, it's <code>A × B</code> that I've seen often written <code>A ⊕ B</code> in maths, not <code>(a, b)</code>. (See the Wikipedia page on direct sums for instance)</p>",
        "id": 252966379,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631431138
    },
    {
        "content": "<p>Sure, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\times B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊕</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\oplus B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> are used a lot, and quite often they are interchangeable.</p>",
        "id": 252966623,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1631431406
    },
    {
        "content": "<p>Which is a shame because <code>A ⊕ B</code> is very different in Lean</p>",
        "id": 252966824,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631431636
    },
    {
        "content": "<p>Yes, and I'm sure you can guess which one I'd like to nuke</p>",
        "id": 252966907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631431716
    },
    {
        "content": "<p>We have <code>A ⨿ B</code> for that</p>",
        "id": 252966921,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631431742
    },
    {
        "content": "<p>I hope you mean <code>A ⊔ B</code></p>",
        "id": 252967285,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631432164
    },
    {
        "content": "<p>Sure, they look the same to me</p>",
        "id": 252967315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631432223
    },
    {
        "content": "<p>With my mathematician's glasses on</p>",
        "id": 252967337,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631432250
    },
    {
        "content": "<p>I guess mathlib lost its \"intended semantics of unicode characters\" glasses long ago...</p>",
        "id": 252967415,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631432333
    },
    {
        "content": "<p>In human maths papers in this particular case I'm pretty sure that nobody would be particularly fussed about which disjoint union character to use, it's actually surprisingly rare as a construction (at least in number theory)</p>",
        "id": 252975724,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1631441718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/rfc.3A.20tensor.20product.20notation/near/252964749\">said</a>:</p>\n<blockquote>\n<p>This seems similar to how we have <code>A × B</code> vs <code>(a, b)</code>. I've seen comments in the past saying that Haskell uses the same notation for both but it is confusing.</p>\n</blockquote>\n<p>(Haskell does the same with <code>[A]</code> for a list of things of type <code>A</code>.)</p>\n<p>I guess it's not so hard to get Lean to have this same notation for cartesian products:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">pair_to_cart</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">×</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p.1</span> <span class=\"bp\">×</span> <span class=\"n\">p.2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">swap</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">p.2</span><span class=\"o\">,</span> <span class=\"n\">p.1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Could this be a way to support <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\otimes</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span> for terms and types?  Have a coercion from the term tensor product of types to the tensor product?</p>",
        "id": 252995748,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631462622
    },
    {
        "content": "<p>Note that haskell has the luxury of being able to do that because terms and types are different syntactic classes. This doesn't work in dependent type theories because they are completely different operators that both validly apply to types</p>",
        "id": 252997694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631464739
    },
    {
        "content": "<p>That just means Haskell has the luxury of having <code>(ℕ, ℕ)</code> immediately be a type, rather than needing an additional rule for when such a term is used as a type. I think it's similar to how in Automath pi types are represented by lambda expressions, though that rule is built-in rather than needing a Lean-style coercion.</p>\n<p>(It's unclear how you'd make <code>[A]</code> be the type of lists, but I just brought it up to illustrate that they like this sort of notation in Haskell.)</p>",
        "id": 252998154,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631465292
    },
    {
        "content": "<p>Well in DTT the product type constructor is not necessarily injective, so making them the same is at least an additional axiomatic commitment</p>",
        "id": 252998298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631465474
    },
    {
        "content": "<p>and as you say this doesn't work at all for lists</p>",
        "id": 252998305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631465488
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">list_to_type</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">37</span>\n<span class=\"bp\">|</span> <span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">::</span><span class=\"n\">B</span><span class=\"o\">::</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">37</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">list_to_type</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"n\">ℕ</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 252998487,
        "sender_full_name": "David Wärn",
        "timestamp": 1631465662
    },
    {
        "content": "<p>Clearly the other lists should be tuple types ;)</p>",
        "id": 252998538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631465747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/rfc.3A.20tensor.20product.20notation/near/252998305\">said</a>:</p>\n<blockquote>\n<p>and as you say this doesn't work at all for lists</p>\n</blockquote>\n<p>I regret bringing up lists, since it has nothing to do with what I was suggesting. (Though thanks for finding a solution to this puzzle, <span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span>.)</p>\n<p>I find it puzzling that you're saying it doesn't work when I gave some working code.  Why does it matter if the product type constructor is injective?  There are obviously some problems with needing coercions, but it seems to be significantly better than relying on CIRCLED CROSSING LANES or VAI SYLLABLE KPAN.</p>",
        "id": 252998597,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1631465784
    },
    {
        "content": "<p>If there is a coercion, then I can see some more possibilities; I was talking about the case where there is no coercion and the two constructors are identified</p>",
        "id": 252998648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631465864
    }
]
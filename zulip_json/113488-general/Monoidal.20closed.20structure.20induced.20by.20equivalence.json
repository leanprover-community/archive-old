[
    {
        "content": "<p>Hi,<br>\nI'm trying to provide basic simp lemmas for the monoidal closed structure induced by a monoidal equivalence and would appreciate some help with the use of <code>haveI</code> in lemma statements. Here is my attempt so far; the first lemma works fine but in the second one I can't figure out how to tell Lean that the morphisms on both sides of the equal sign have the same source and the same target.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.closed.monoidal</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u₁</span> <span class=\"n\">v₁</span> <span class=\"n\">u₂</span> <span class=\"n\">v₂</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory.monoidal_closed</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoidal_category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoidal_category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_equiv_ihom_obj</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_functor</span> <span class=\"n\">C</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_equivalence</span> <span class=\"n\">F.to_functor</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_closed</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">of_equiv</span> <span class=\"n\">F</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">ihom</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"n\">F.inv.obj</span> <span class=\"o\">((</span><span class=\"n\">ihom</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_functor</span> <span class=\"n\">C</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_equivalence</span> <span class=\"n\">F.to_functor</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_closed</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">of_equiv</span> <span class=\"n\">F</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">ihom</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"n\">F.inv.map</span> <span class=\"o\">((</span><span class=\"n\">ihom</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 303468051,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1665503538
    },
    {
        "content": "<p>just change the <code>haveI</code> to a <code>letI</code>.</p>",
        "id": 303469244,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665503942
    },
    {
        "content": "<p>These instances involve data (some adjoints)</p>",
        "id": 303469276,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665503949
    },
    {
        "content": "<p>the first <code>haveI</code> should also be a <code>letI</code> btw</p>",
        "id": 303469373,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665503977
    },
    {
        "content": "<p>Thanks for the answer, that works. Now I'm having trouble applying these lemmas. In the following code, how can I get Lean to simplify using <code>of_equiv_ihom_obj</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.closed.functor_category</span>\n<span class=\"kn\">import</span> <span class=\"n\">representation_theory.Action</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory.monoidal_closed</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoidal_category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoidal_category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">of_equiv_ihom_obj</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_functor</span> <span class=\"n\">C</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_equivalence</span> <span class=\"n\">F.to_functor</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_closed</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">of_equiv</span> <span class=\"n\">F</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">ihom</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"n\">F.inv.obj</span> <span class=\"o\">((</span><span class=\"n\">ihom</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">Action</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"n\">large_category</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoidal_category</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Group.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">monoidal_closed</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_closed</span> <span class=\"o\">(</span><span class=\"n\">single_obj</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Mon.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"bp\">⥤</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"n\">monoidal_closed</span> <span class=\"o\">(</span><span class=\"n\">single_obj</span> <span class=\"n\">H</span> <span class=\"bp\">⥤</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">monoidal_closed</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_closed</span> <span class=\"o\">(</span><span class=\"n\">Action</span> <span class=\"n\">V</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">monoidal_closed.of_equiv</span> <span class=\"o\">(</span><span class=\"n\">functor_category_monoidal_equivalence</span> <span class=\"n\">V</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ihom_obj_ρ</span> <span class=\"o\">[</span><span class=\"n\">monoidal_closed</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Action</span> <span class=\"n\">V</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">ihom</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ρ</span> <span class=\"n\">g</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">monoidal_closed.pre</span> <span class=\"o\">(</span><span class=\"n\">X.ρ</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">Y.V</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">ihom</span> <span class=\"n\">X.V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">Y.ρ</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">of_equiv_ihom_obj</span> <span class=\"o\">(</span><span class=\"n\">functor_category_monoidal_equivalence</span> <span class=\"n\">V</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">],</span> <span class=\"c1\">--fails</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 303488349,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1665510292
    },
    {
        "content": "<p>i think it would be better to obtain isomorphisms between internal homs when you have a monoidal equivalence between monoidal closed categories, and work with those isomorhpisms instead.</p>",
        "id": 303491070,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665511213
    },
    {
        "content": "<p>I think <code>haveI</code> is fine here</p>",
        "id": 303491721,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665511457
    },
    {
        "content": "<p><code>have</code> vs <code>let</code> only makes a difference within a tactic block, not between different tactic blocks</p>",
        "id": 303491802,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665511495
    },
    {
        "content": "<p>Well there is obviously some difference in this case, beucase <code>haveI</code> doesn't work, but <code>letI</code> does.</p>",
        "id": 303492163,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665511615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/Monoidal.20closed.20structure.20induced.20by.20equivalence/near/303491070\">said</a>:</p>\n<blockquote>\n<p>i think it would be better to obtain isomorphisms between internal homs when you have a monoidal equivalence between monoidal closed categories, and work with those isomorhpisms instead.</p>\n</blockquote>\n<p>So </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ihom_obj_V</span> <span class=\"o\">[</span><span class=\"n\">monoidal_closed</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Action</span> <span class=\"n\">V</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">ihom</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">ihom</span> <span class=\"n\">X.V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Y.V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>should be an isomorphism and <code>ihom_obj_ρ</code> should be stated in terms of conjugation by this isomorphism? I guess that makes sense, though it quickly makes very messy statements.</p>",
        "id": 303496688,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1665513233
    }
]
[
    {
        "content": "<p>I have another question about variables and synthesis</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">computability.encoding</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.polynomial.eval</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">computability.fin_encoding</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"c1\">-- variable [encA : computability.fin_encoding A] -- works</span>\n<span class=\"c1\">-- variable [_instfoobar : computability.fin_encoding A] --doesn't work</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dtime</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">polytime</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">ℕ</span> <span class=\"o\">),</span> <span class=\"n\">dtime</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p.eval</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This code throws <code>failed to synthesize type class instance</code> for the dtime call. However, if I replace the line <code>variable [computability.fin_encoding A]</code> with <code>variable [encA : computability.fin_encoding A]</code> everything is fine. This is pretty confusing, since the reference manual says of implicit arguments </p>\n<blockquote>\n<p>The name of the variable can be omitted from a class resolution argument, in which case an internal name is generated.</p>\n</blockquote>\n<p>From this quote I would expect the behavior of these two versions to be the same. </p>\n<p>Further exploration shows that an error is thrown even when the name of the <code>fin_encoding</code> instance is inserted manually, as long as the name starts with the characters <code>_inst</code>. What is going on?</p>",
        "id": 229974333,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1615523290
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/computability.fin_encoding\">docs#computability.fin_encoding</a></p>",
        "id": 229982882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615530226
    },
    {
        "content": "<p>Looks to me like it's a structure but not a class so you shouldn't be using square brackets at all</p>",
        "id": 229982974,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615530265
    },
    {
        "content": "<p>Then why doesn't the compiler complain at all when I name the value?</p>",
        "id": 230080128,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1615575419
    },
    {
        "content": "<p>Named and unnamed typeclass variables behave differently, in that unnamed typeclass variables are included if all their dependents (here <code>A</code>) are required for the theorem statement, while named typeclass variables are included only if the variable itself (<code>encA</code>) is used in the theorem statement. You might have stumbled on a non-hygiene situation though with your tricky name <code>_instfoobar</code>, which probably tricks lean into thinking that it's an unnamed instance since unnamed instances have autogenerated names starting with <code>_inst</code></p>",
        "id": 230082245,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615576278
    },
    {
        "content": "<p>Ok thanks. Just one more question: Is there some technical or philosophical reason why <code>computability.fin_encoding</code> is not a class here? To me, this feels analogous to me to other classes in Lean, like <code>algebra.field</code>. In both cases there are objects and propositions associated with each instance. Also, it feels like it should be possible to use the \"chaining\" feature  of  type classes to chain instances of <code>computability.fin_encoding</code>,  for example, to implement an encoding for pairs of encodable types.</p>",
        "id": 230090823,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1615580157
    },
    {
        "content": "<p>If it were a typeclass, it would be saying \"there is a canonical encoding of nat\", just as <code>field</code> says \"there is a canonical field structure on the reals\"</p>",
        "id": 230093936,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615581466
    }
]
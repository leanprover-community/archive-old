[
    {
        "content": "<p>If I have <code>h : i = j ∨ k = l</code>, I might do <code>rcases h with rfl | rfl</code>.  If I have <code>h : i = j ∨ k = l  ∨ p = q</code>, I might do <code>rcases h with rfl | rfl | rfl</code>.  Now suppose I want to handle a large number of goals in parallel, each of which has an <code>h</code> as before, but with varying numbers of equations or'd together.  What is a tidy way to apply <code>rcases</code> with the right number of <code>rfl</code>'s in each goal?</p>",
        "id": 168134039,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1560518341
    },
    {
        "content": "<p>Indeed it would be nice to have a more automatic <code>rcases</code></p>",
        "id": 168134972,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560519111
    },
    {
        "content": "<p>Maybe use the <code>repeat</code> combinator?</p>",
        "id": 168135925,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1560519853
    },
    {
        "content": "<p>I tried <code>repeat { rcases h with rfl | _ }</code> but that did not work.  Perhaps some other variant would work, but I could not find one.</p>",
        "id": 168136437,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1560520259
    },
    {
        "content": "<p>You might have to explicitly call the second argument <code>h</code>, instead of <code>_</code>.</p>",
        "id": 168136463,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560520290
    },
    {
        "content": "<p>Otherwise <code>rcases</code> might generate the wrong name.</p>",
        "id": 168136472,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560520304
    },
    {
        "content": "<p>I am a bit confused, by the way, about the <code>with rfl</code> part. I thought you'd need to write something like<br>\n<code>repeat {cases h}; rfl</code></p>",
        "id": 168137556,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1560521090
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  Yes, that was the problem, thanks</p>",
        "id": 168137617,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1560521131
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198376\">@Kevin Kappelmann</span>  If <code>h : i = j</code> then <code>rcases h with rfl</code> will \"specialise to the case where <code>h</code> is <code>rfl : i = i</code>\" and so will remove change <code>j</code> to <code>i</code> in all hypotheses and in the goal.  Similarly, if <code>h : i = j ∨ i = k</code> then  <code>rcases h with rfl | rfl</code> will give two new goals, one will all <code>j</code>'s changed to <code>i</code>, and one with all <code>k</code>'s changed to <code>i</code>.</p>",
        "id": 168137958,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1560521349
    },
    {
        "content": "<p>Ohhh, alright - thanks for explaining! :)</p>",
        "id": 168139042,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1560522152
    },
    {
        "content": "<p>Hello! This is a question about tactics also - is <code>ring</code> the only tactic for resolving equalities in an algebraic structure? Would something similar for other structures be considered useful or is <code>simp</code> good enough?</p>",
        "id": 168139335,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1560522391
    },
    {
        "content": "<p>There is also <code>abel</code>, and any other one would be very useful</p>",
        "id": 168139879,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560522730
    },
    {
        "content": "<p>Is there any tactic yet that could do</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"err\">∩</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∩</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">finish</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>This proof is quick to come up with, but slow. I could also come up with the right sequence of rewrites, which would be much faster, but my time is too precious for this :)</p>",
        "id": 168142662,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1560524605
    },
    {
        "content": "<p>Does <code>casesm</code>help at all? <a href=\"https://github.com/leanprover-community/lean/blob/master/library/init/meta/interactive.lean#L773\" target=\"_blank\" title=\"https://github.com/leanprover-community/lean/blob/master/library/init/meta/interactive.lean#L773\">https://github.com/leanprover-community/lean/blob/master/library/init/meta/interactive.lean#L773</a></p>",
        "id": 168151569,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1560530714
    },
    {
        "content": "<p>Regarding ring, is it more or less accurate that <code>ring</code> runs faster than <code>ring2</code>, but <code>ring2</code> generates much smaller proof terms thanks to reflection and is therefore better for large expressions?</p>",
        "id": 168154217,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1560532665
    },
    {
        "content": "<p>Generally speaking, the \"smaller proof term\" heuristic for complexity breaks down in the presence of \"heavy rfls\"</p>",
        "id": 168271152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560725806
    },
    {
        "content": "<p>What do you mean by <em>heavy rfls</em>? Is it that the normalizing procedure over the reflected expression has to take many steps and so does the kernel to decide judgmental eq., or something else?</p>",
        "id": 168356828,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1560814090
    },
    {
        "content": "<p>Definitional equality is a large and complicated judgment. Normally we don't stress it too much, we just unfold a definition here or a beta reduction there. By \"heavy rfl\" I mean something with many steps of definitional reduction, comparable to the size of the entire rest of the proof term or even much much larger</p>",
        "id": 168356939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814247
    },
    {
        "content": "<p>Okay, I think that's what I meant. So when you have that, you end up with a very small proof term which also happens to require a really large computation to typecheck, right?</p>",
        "id": 168357022,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1560814328
    },
    {
        "content": "<p>right</p>",
        "id": 168357029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814335
    },
    {
        "content": "<p>and doing that computation in the kernel is not necessarily the best idea</p>",
        "id": 168357039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814358
    },
    {
        "content": "<p>Okay, I think when saying \".. better for large expressions\" I should've really said \"better in terms of proof size\", but not necessarily better in terms of <code>time lean --make</code>.</p>",
        "id": 168357062,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1560814402
    },
    {
        "content": "<p>Most of the time, the length of the typing derivation is proportional to the size of the proof term, but heavy rfls break that comparison</p>",
        "id": 168357078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814428
    },
    {
        "content": "<p>In such cases it really is more accurate to measure the length of the typing derivation</p>",
        "id": 168357128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814448
    },
    {
        "content": "<p>To me, \"proof size\" means size of typing derivation, because that correlates to wall time</p>",
        "id": 168357172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814526
    },
    {
        "content": "<p>it is far too easy to write \"short proofs\" of every statement imaginable by doing a proof search in the kernel</p>",
        "id": 168357229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814578
    },
    {
        "content": "<p>By typing derivation you mean the time it takes for the kernel to typecheck the term, but not elaboration/inference etc time?</p>",
        "id": 168357240,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1560814600
    },
    {
        "content": "<p>yes</p>",
        "id": 168357242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814606
    },
    {
        "content": "<p>the other stuff is engineering challenges, and also it's a one time cost, at least in principle. The kernel typechecking is mandatory for correctness</p>",
        "id": 168357275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814671
    },
    {
        "content": "<p>Right, but if a reflection tactic generates <em>heavy rfls</em> which take less time to check than an equivalent sequence of <code>eq.subst</code> or some such would, then it would still be preferrable?</p>",
        "id": 168357420,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1560814839
    },
    {
        "content": "<p>yes</p>",
        "id": 168357425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814854
    },
    {
        "content": "<p>That's why I wrote <code>ring</code> and <code>ring2</code></p>",
        "id": 168357439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814871
    },
    {
        "content": "<p>because it wasn't obvious which method is faster in practice</p>",
        "id": 168357444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814883
    },
    {
        "content": "<p>but the kernel is not very optimized, in order to keep code size down, and it has to unfold many things because it doesn't exactly know where to go</p>",
        "id": 168357503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814941
    },
    {
        "content": "<p>with a proof term you can expose the kernel to only those things it needs to know</p>",
        "id": 168357509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560814967
    },
    {
        "content": "<p>basically, you have a lot more control with a proof term than with a rfl proof</p>",
        "id": 168357579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560815053
    },
    {
        "content": "<p>With a rfl proof, could you not write your decision procedure in a way that makes it easy to reduce for the kernel?</p>",
        "id": 168357829,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1560815403
    },
    {
        "content": "<p>yes you can, and it's pretty important that you do</p>",
        "id": 168358028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560815706
    },
    {
        "content": "<p>but there is still the matter of the O(1) constant</p>",
        "id": 168358033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560815715
    },
    {
        "content": "<p>and the only way to really find that out is to profile it</p>",
        "id": 168358093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560815775
    },
    {
        "content": "<p>I think even just using the equation compiler to define, say, functions on lists is bad for the kernel</p>",
        "id": 168358127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560815839
    },
    {
        "content": "<p>not that bad, but measurable</p>",
        "id": 168358139,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560815860
    },
    {
        "content": "<p>I see</p>",
        "id": 168359137,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1560817095
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Is there any documentation/paper explaining what the purpose of <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/tactic/abel.lean#L13\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/tactic/abel.lean#L13\">the cache in abel</a> is?</p>",
        "id": 168512360,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1560955023
    },
    {
        "content": "<p>It's a bunch of info I want to inject into the proof term at various points without recomputing all the time. So I need the base type, the level of that type for constants, the zero constant because that comes up a lot, and the instance of either <code>add_comm_monoid</code> or <code>add_comm_group</code> (whichever it was able to find). This data can be calculated just from the type, which we find as soon as we start entering the term, and that means we can avoid almost all uses of <code>mk_app</code>, which tends to be unpredictably slow sometimes (see also the recent bug in <a href=\"#narrow/stream/116395-maths/topic/witt.20vectors\" title=\"#narrow/stream/116395-maths/topic/witt.20vectors\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/witt.20vectors</a> ).</p>",
        "id": 168554009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560986535
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 168555193,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1560988103
    },
    {
        "content": "<p>Is there a better notation for doing something on failure of a tactic match than</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">(</span><span class=\"n\">do</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">some_expr</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"n\">next_t</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">on_fail_t</span>\n</pre></div>\n\n\n<p>? It gets ugly quickly with multiple nested matches and failure handlers. Ideally something local like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">do</span> <span class=\"o\">(</span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">some_expr</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">except</span> <span class=\"n\">on_fail_t</span><span class=\"o\">,</span> <span class=\"n\">next_t</span><span class=\"o\">,</span>\n</pre></div>",
        "id": 168608384,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1561046141
    },
    {
        "content": "<p>Found it, it's just</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">do</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">some_expr</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">t</span>\n  <span class=\"bp\">|</span> <span class=\"n\">on_fail_t</span><span class=\"o\">,</span>\n</pre></div>",
        "id": 168616436,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1561052106
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is there any particular reason for using a custom <code>tree</code> instead of <code>rbnode</code> in <code>ring2</code>? (The <code>pos_num</code> indexing stuff could be added if <code>rbnode</code> doesn't have it already.)</p>",
        "id": 170999997,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1563292534
    },
    {
        "content": "<p>The red-black tree implementation in core is broken,, so I try to use it as little as possible. Also it's important that the kernel compute with it well, so extraneous rebalancing code would be not good. All the rbnode handling happens in the VM, the kernel only sees <code>tree</code>.</p>",
        "id": 171010679,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563299933
    },
    {
        "content": "<p>Oh I see, in what way is it broken? I think w.r.t. rebalancing it would be fine, because the rebalancing only happens on tree modifications, but neither normalization in <code>of_csexpr</code>, nor <code>eval</code>/<code>cseval</code> modify the tree.</p>",
        "id": 171011090,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1563300149
    },
    {
        "content": "<p>It's still a more complicated recursive function since there are more cases</p>",
        "id": 171011179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563300224
    },
    {
        "content": "<p>You can't erase from an <code>rbtree</code></p>",
        "id": 171011281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563300265
    },
    {
        "content": "<p>because the red black invariant is wrong</p>",
        "id": 171011326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563300298
    },
    {
        "content": "<p>?! Do you mean it doesn't maintain the invariant, or it maintains the wrong invariant, or ..?</p>",
        "id": 171015269,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1563302700
    },
    {
        "content": "<p>It maintains the wrong invariant. The actual red black invariant is not defined; instead it does the lazy thing and says \"whatever you can get to by applying insert to empty\" which is obviously sufficient to get insert and empty but basically nothing else</p>",
        "id": 171020547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563306259
    },
    {
        "content": "<p>So it is not defined, but are you also saying that \"being a red-black tree\" is actually dynamically broken, e.g. a <code>red_node</code> appears directly as the child of a <code>red_node</code> or some such? Or just that it doesn't maintain a proof of the right \"being red-black\" proposition (since <code>well_formed</code> is defined as \"either a leaf or the result of <code>insert</code> on a well-formed tree\" rather than \"meets all the rbtree requirements\")?</p>",
        "id": 171023629,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1563308469
    },
    {
        "content": "<p>The red-black property is maintained, but this is not proven</p>",
        "id": 171026496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563310470
    },
    {
        "content": "<p>The current definition of <code>well_formed</code> is not equivalent to the red black property, but implies it</p>",
        "id": 171026562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563310522
    },
    {
        "content": "<p>But because of the over-strict well formedness predicate, you can't define anything on these red black trees other than insert and empty</p>",
        "id": 171026658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563310572
    },
    {
        "content": "<p>I don't really remember what is an rb-tree but I remember this came up last summer. See <a href=\"#narrow/stream/113488-general/topic/Ed's.20question.20barrage\" title=\"#narrow/stream/113488-general/topic/Ed's.20question.20barrage\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Ed's.20question.20barrage</a> and <a href=\"#narrow/stream/113488-general/topic/using_well_founded\" title=\"#narrow/stream/113488-general/topic/using_well_founded\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/using_well_founded</a></p>",
        "id": 171061393,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1563354958
    },
    {
        "content": "<p>I see what you mean now Mario, thanks a bunch for explaining! In that case it does make sense to use a custom <code>tree</code>. <br>\nThanks Patrick for the links - it does look like those discussions were partly about the same problem - I should have searched harder, sorry!</p>",
        "id": 171164645,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1563453027
    },
    {
        "content": "<p>While a term and its reduced form are equivalent in the type theory, they are not so syntactically. This matters if I want to compare <code>expr</code>s syntactically in a tactic. My question: is there a builtin/way to reduce an <code>expr</code> to normal form?</p>",
        "id": 171858775,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1564258944
    },
    {
        "content": "<p><code>whnf</code></p>",
        "id": 171859446,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564260314
    },
    {
        "content": "<p>Nice, there are also a bunch of others like <code>head_beta</code> next to it. Thanks!</p>",
        "id": 171861315,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1564263948
    },
    {
        "content": "<p>Suppose that I have a goal state, how do I get a list of all hypotheses that are mentioned in the target?</p>",
        "id": 207492522,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597904946
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> : I want a tactic that reverts all those hyps (and whatever depends on them), and then runs <code>exact dec_trivial</code>.</p>",
        "id": 207492541,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597904973
    },
    {
        "content": "<p>I found this in <code>tactic.clear</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">hyps</span><span class=\"bp\">.</span><span class=\"n\">mmap&#39;</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">do</span>\n  <span class=\"n\">dep</span> <span class=\"err\">←</span> <span class=\"n\">kdepends_on</span> <span class=\"n\">tgt</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">when</span> <span class=\"n\">dep</span> <span class=\"err\">$</span> <span class=\"n\">fail</span> <span class=\"err\">$</span>\n    <span class=\"n\">format</span><span class=\"bp\">!</span><span class=\"s2\">&quot;Cannot clear hypothesis {h} since the target depends on it.&quot;</span><span class=\"o\">),</span>\n<span class=\"n\">n</span> <span class=\"err\">←</span> <span class=\"n\">revert_lst</span> <span class=\"n\">hyps</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 207492648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597905101
    },
    {
        "content": "<p>Ok, let me see if I can make this work.</p>",
        "id": 207492718,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597905143
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">interactive</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"err\">«</span><span class=\"n\">dec_trivial</span><span class=\"err\">»</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">tgt</span> <span class=\"err\">←</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n   <span class=\"n\">ctx</span> <span class=\"err\">←</span> <span class=\"n\">local_context</span><span class=\"o\">,</span>\n   <span class=\"n\">l</span> <span class=\"err\">←</span> <span class=\"n\">ctx</span><span class=\"bp\">.</span><span class=\"n\">mfilter</span> <span class=\"o\">(</span><span class=\"n\">kdepends_on</span> <span class=\"n\">tgt</span><span class=\"o\">),</span>\n   <span class=\"n\">n</span> <span class=\"err\">←</span> <span class=\"n\">revert_lst</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n   <span class=\"n\">exact_dec_trivial</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">interactive</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 207493868,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597906500
    },
    {
        "content": "<p>Bingo</p>",
        "id": 207493874,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597906503
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/3875\">#3875</a></p>",
        "id": 207494583,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597907247
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> This should make your <code>fin 3</code> problems go away.</p>",
        "id": 207494600,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597907277
    },
    {
        "content": "<p>It means that you can now write things like</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"k\">obtain</span> <span class=\"bp\">⟨</span><span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"bp\">⟩</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">i₁</span><span class=\"o\">,</span> <span class=\"n\">i₂</span><span class=\"o\">,</span> <span class=\"n\">i₃</span><span class=\"o\">}</span> <span class=\"bp\">∧</span>\n    <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"err\">\\</span> <span class=\"o\">{</span><span class=\"n\">i₂</span><span class=\"o\">,</span> <span class=\"n\">i₃</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">i₁</span><span class=\"o\">}</span> <span class=\"bp\">∧</span>\n    <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">i₁</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">i₂</span><span class=\"o\">,</span> <span class=\"n\">i₃</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n</code></pre></div>",
        "id": 207494679,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597907360
    },
    {
        "content": "<p>Ooh, it's not good enough yet</p>",
        "id": 207494699,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597907400
    },
    {
        "content": "<p>It doesn't see through <code>let</code> statements</p>",
        "id": 207494742,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597907408
    },
    {
        "content": "<p>This doesn't work yet</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"k\">by</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 207494920,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597907620
    },
    {
        "content": "<p>It reverts <code>k</code>, but the dependency checking isn't recursive <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 207495235,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597907950
    },
    {
        "content": "<p>I guess I can fix that.</p>",
        "id": 207495238,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597907954
    },
    {
        "content": "<p>Is this ok?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">revert_target_deps</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">tgt</span> <span class=\"err\">←</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n   <span class=\"n\">ctx</span> <span class=\"err\">←</span> <span class=\"n\">local_context</span><span class=\"o\">,</span>\n   <span class=\"n\">l</span> <span class=\"err\">←</span> <span class=\"n\">ctx</span><span class=\"bp\">.</span><span class=\"n\">mfilter</span> <span class=\"o\">(</span><span class=\"n\">kdepends_on</span> <span class=\"n\">tgt</span><span class=\"o\">),</span>\n   <span class=\"n\">n</span> <span class=\"err\">←</span> <span class=\"n\">revert_lst</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n   <span class=\"k\">if</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"k\">then</span> <span class=\"n\">skip</span> <span class=\"k\">else</span> <span class=\"n\">revert_target_deps</span>\n</code></pre></div>",
        "id": 207495607,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597908339
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> I've now gotten proofs like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">- The orthocenter lies in the altitudes. -/</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">orthocenter_mem_altitude</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">triangle</span> <span class=\"n\">ℝ</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">i₁</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">orthocenter</span> <span class=\"err\">∈</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">altitude</span> <span class=\"n\">i₁</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">s₂₃</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">i₁</span><span class=\"o\">,</span>\n  <span class=\"k\">obtain</span> <span class=\"bp\">⟨</span><span class=\"n\">i₂</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span>\n    <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card_pos</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">s₂₃</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n  <span class=\"k\">let</span> <span class=\"n\">s₃</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">s₂₃</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">i₂</span><span class=\"o\">,</span>\n  <span class=\"k\">obtain</span> <span class=\"bp\">⟨</span><span class=\"n\">i₃</span><span class=\"o\">,</span> <span class=\"n\">h₃</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span>\n    <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card_pos</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">s₃</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">dec_trivial</span><span class=\"o\">),</span>\n  <span class=\"k\">obtain</span> <span class=\"bp\">⟨</span><span class=\"n\">h₁₂</span><span class=\"o\">,</span> <span class=\"n\">h₂₃</span><span class=\"o\">,</span> <span class=\"n\">h₁₃</span><span class=\"bp\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">i₁</span> <span class=\"bp\">≠</span> <span class=\"n\">i₂</span> <span class=\"bp\">∧</span> <span class=\"n\">i₂</span> <span class=\"bp\">≠</span> <span class=\"n\">i₃</span> <span class=\"bp\">∧</span> <span class=\"n\">i₁</span> <span class=\"bp\">≠</span> <span class=\"n\">i₃</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">orthocenter_eq_monge_point</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">altitude_eq_monge_plane</span> <span class=\"n\">h₁₂</span> <span class=\"n\">h₁₃</span> <span class=\"n\">h₂₃</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">monge_point_mem_monge_plane</span> <span class=\"n\">h₂₃</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 207495875,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597908617
    },
    {
        "content": "<p>Golfed:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">- The orthocenter lies in the altitudes. -/</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">orthocenter_mem_altitude</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">triangle</span> <span class=\"n\">ℝ</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">i₁</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">orthocenter</span> <span class=\"err\">∈</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">altitude</span> <span class=\"n\">i₁</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">obtain</span> <span class=\"bp\">⟨</span><span class=\"n\">i₂</span><span class=\"o\">,</span> <span class=\"n\">i₃</span><span class=\"o\">,</span> <span class=\"n\">h₁₂</span><span class=\"o\">,</span> <span class=\"n\">h₂₃</span><span class=\"o\">,</span> <span class=\"n\">h₁₃</span><span class=\"bp\">⟩</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">i₂</span> <span class=\"n\">i₃</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span><span class=\"o\">),</span> <span class=\"n\">i₁</span> <span class=\"bp\">≠</span> <span class=\"n\">i₂</span> <span class=\"bp\">∧</span> <span class=\"n\">i₂</span> <span class=\"bp\">≠</span> <span class=\"n\">i₃</span> <span class=\"bp\">∧</span> <span class=\"n\">i₁</span> <span class=\"bp\">≠</span> <span class=\"n\">i₃</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">orthocenter_eq_monge_point</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">altitude_eq_monge_plane</span> <span class=\"n\">h₁₂</span> <span class=\"n\">h₁₃</span> <span class=\"n\">h₂₃</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">monge_point_mem_monge_plane</span> <span class=\"n\">h₂₃</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 207496133,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597908848
    },
    {
        "content": "<p>Often, in doing cases for <code>fin 2</code> lets say, I've done:</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">i</span> <span class=\"k\">with</span> <span class=\"bp\">_|_|</span><span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span> <span class=\"c\">/-</span><span class=\"cm\">- proof for case 0 --/</span>\n    <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span> <span class=\"c\">/-</span><span class=\"cm\">- proof for case 1 --/</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">lt_of_succ_lt_succ</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">lt_of_succ_lt_succ</span> <span class=\"n\">i_is_lt</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">not_lt_of_le</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">zero_le</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"bp\">/</span> <span class=\"k\">proof</span> <span class=\"n\">for</span> <span class=\"n\">case</span> <span class=\"mi\">2</span><span class=\"bp\">+</span> <span class=\"c1\">--/</span>\n</code></pre></div>",
        "id": 207526292,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1597932722
    },
    {
        "content": "<p>Would this tactic help with that?</p>",
        "id": 207526338,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1597932731
    },
    {
        "content": "<p>You could rewrite it a bit, and then it would help.</p>",
        "id": 207526415,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597932794
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">obtain</span> <span class=\"err\">\\</span><span class=\"bp\">&lt;</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"err\">\\</span><span class=\"bp\">&gt;</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"err\">\\</span><span class=\"n\">or</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 207526447,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597932822
    },
    {
        "content": "<p>But there is also <code>fin_cases</code> for such problems</p>",
        "id": 207526462,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597932833
    },
    {
        "content": "<p>Ah, right! I always forget about <code>fin_cases</code> because it doesn't work for arbitrary <code>fin (n + 2)</code>.</p>",
        "id": 207526566,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1597932883
    },
    {
        "content": "<p>This tactic also solves a slew of other problems that have nothing to do with <code>fin n</code>.</p>",
        "id": 207526573,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597932886
    },
    {
        "content": "<p>Neither does this one.</p>",
        "id": 207526599,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597932900
    }
]
[
    {
        "content": "<p>Oliver, the question is whether you can write a def that takes a lie algebra structure and outputs a <code>non_unital_non_assoc_semiring</code></p>",
        "id": 256260939,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633445935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list/near/256260939\">said</a>:</p>\n<blockquote>\n<p>Oliver, the question is whether you can write a def that takes a lie algebra structure and outputs a <code>non_unital_non_assoc_semiring</code></p>\n</blockquote>\n<p>Should we have <code>bracketive</code>/<code>unbracketive</code> to match <code>multiplicative</code>/<code>additive</code>? One translates between <code>+</code> and <code>*</code>, the other between lie brackets and <code>*</code>.</p>",
        "id": 256261505,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633446111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list.20.28algebras.29/near/256260939\">said</a>:</p>\n<blockquote>\n<p>Oliver, the question is whether you can write a def that takes a lie algebra structure and outputs a <code>non_unital_non_assoc_semiring</code></p>\n</blockquote>\n<p>I see, well we can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.lie.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">lie_ring</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lie_ring.to_non_unital_non_assoc_semiring</span> <span class=\"o\">:</span> <span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul</span>           <span class=\"o\">:=</span> <span class=\"n\">has_bracket.bracket</span><span class=\"o\">,</span>\n  <span class=\"n\">left_distrib</span>  <span class=\"o\">:=</span> <span class=\"n\">lie_add</span><span class=\"o\">,</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">add_lie</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_mul</span>      <span class=\"o\">:=</span> <span class=\"n\">zero_lie</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_zero</span>      <span class=\"o\">:=</span> <span class=\"n\">lie_zero</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">L</span><span class=\"o\">),</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 256262488,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633446459
    },
    {
        "content": "<p>And if we had also assumed <code>lie_algebra R L</code> (for a <code>comm_ring R</code>) we could define the relevant <code>is_scalar_tower</code> and <code>smul_comm_class</code> classes.</p>",
        "id": 256262745,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633446543
    },
    {
        "content": "<p>Where does the <code>has_scalar R L</code> instance come from?</p>",
        "id": 256262833,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633446572
    },
    {
        "content": "<p>From <code>lie_algebra.to_module</code></p>",
        "id": 256262991,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633446612
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/lie_algebra.to_module\">docs#lie_algebra.to_module</a></p>",
        "id": 256263285,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633446708
    },
    {
        "content": "<p>Oh I was getting confused by <code>lie_ring_module</code> which has a different sort of action, never mind</p>",
        "id": 256263561,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633446789
    },
    {
        "content": "<p>Oh, but actually you have a point, we need a <code>has_scalar L L</code>.</p>",
        "id": 256263681,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633446825
    },
    {
        "content": "<p>Which I guess would come from <code>lie_ring.to_non_unital_non_assoc_semiring</code> via <code>has_mul.to_has_scalar</code> if we set things up right.</p>",
        "id": 256263786,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633446845
    },
    {
        "content": "<p>Oh wow, someone took the trouble to sort the conversations in different topics</p>",
        "id": 256266194,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633447570
    },
    {
        "content": "<p>What is the conclusion then? Do you have a fully working instance?</p>",
        "id": 256266239,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633447588
    },
    {
        "content": "<p>No but I could create one. It would be a type synonym and 3/4 associated instances on it. I can create and PR it if you would like but it is not very likely to be used.</p>",
        "id": 256266398,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447643
    },
    {
        "content": "<p>I'd be more inclined to do it if we \"fixed\" our <code>algbera</code> class.</p>",
        "id": 256266471,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447673
    },
    {
        "content": "<p>Of course, very easy and won't do any harm.</p>",
        "id": 256266476,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447674
    },
    {
        "content": "<p>I don't think it necessarily needs to be PRed, but clarifying this would be nice</p>",
        "id": 256266588,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633447700
    },
    {
        "content": "<p>What do you mean by fixing here?</p>",
        "id": 256266613,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633447711
    },
    {
        "content": "<p>Changing its definition so that it does not require the underlying \"ring\" to be unital and associative.</p>",
        "id": 256266755,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447770
    },
    {
        "content": "<p>There was an old branch where Scott and I made a brief attempt to do this and more recently there is this: <a href=\"https://github.com/leanprover-community/mathlib/commit/dcbed292a23994dfddf70d8262a4defb3103e968#diff-7fa8b94b14c549770d3cddb5a015c4c6029e40e3cd5161d574d9b9f5e7cdff1bR54\">https://github.com/leanprover-community/mathlib/commit/dcbed292a23994dfddf70d8262a4defb3103e968#diff-7fa8b94b14c549770d3cddb5a015c4c6029e40e3cd5161d574d9b9f5e7cdff1bR54</a></p>",
        "id": 256266802,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447787
    },
    {
        "content": "<p>Ok, that's a big refactor.</p>",
        "id": 256266814,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633447792
    },
    {
        "content": "<p>Yep</p>",
        "id": 256266842,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list.20.28algebras.29/near/256266588\">said</a>:</p>\n<blockquote>\n<p>I don't think it necessarily needs to be PRed, but clarifying this would be nice</p>\n</blockquote>\n<p>I'll paste a complete version here later today.</p>",
        "id": 256266971,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633447835
    },
    {
        "content": "<p>The following is not pretty but I think should illustrate how to do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.lie.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lie_ring.to_has_mul</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">L</span>\n<span class=\"kd\">def</span> <span class=\"n\">forward</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"n\">lie_ring.to_has_mul</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span>\n<span class=\"kd\">def</span> <span class=\"n\">back</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">lie_ring.to_has_mul</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">lie_ring</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">lie_algebra</span> <span class=\"n\">R</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"o\">(</span><span class=\"n\">lie_ring.to_has_mul</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul</span>           <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">forward</span> <span class=\"bp\">⁅</span><span class=\"n\">back</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">back</span> <span class=\"n\">y</span><span class=\"bp\">⁆</span><span class=\"o\">,</span>\n  <span class=\"n\">left_distrib</span>  <span class=\"o\">:=</span> <span class=\"n\">lie_add</span><span class=\"o\">,</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">add_lie</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_mul</span>      <span class=\"o\">:=</span> <span class=\"n\">zero_lie</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_zero</span>      <span class=\"o\">:=</span> <span class=\"n\">lie_zero</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">L</span><span class=\"o\">),</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">lie_ring.to_has_mul</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">lie_algebra.to_module</span> <span class=\"n\">R</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">lie_ring.to_has_mul</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lie_ring.to_has_mul</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">smul_lie</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lie_smul'</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">•</span> <span class=\"bp\">⁅</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"bp\">⁅</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"bp\">⁆</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">lie_smul</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">lie_ring.to_has_mul</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lie_ring.to_has_mul</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul_comm</span> <span class=\"o\">:=</span> <span class=\"n\">lie_smul'</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 256273357,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633450067
    },
    {
        "content": "<p>Tidied up <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span> slightly. LMK if you want anything else.</p>",
        "id": 256280807,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1633452993
    },
    {
        "content": "<p><code>with_mul</code> is probably a better name than <code>to_has_mul</code>.</p>",
        "id": 256283221,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633453919
    },
    {
        "content": "<p>It still feels weird that we don't have a plain <code>non_unital_non_associative_algebra R A</code>. People coming to mathlib and asking where are algebras will have a very hard time understanding the answer</p>",
        "id": 256289451,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633456413
    },
    {
        "content": "<p>If we do that we face the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/domain\">docs#domain</a> problem, where either:</p>\n<ul>\n<li>Lots of lemmas get stated about <code>domain</code> that don't actually require all of <code>ring</code>, <code>nontrivial</code>, and <code>no_zero_divisors</code></li>\n<li>No lemmas actually use <code>domain</code>, which means it's not really pedagogically useful</li>\n</ul>\n<p>And to make matters worse, typeclass inference can't promote <code>ring R</code> <code>nontrivial R</code> <code>no_zero_divisors R</code> into <code>integral_domain</code> even though they mean the same thing</p>",
        "id": 256289977,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633456597
    },
    {
        "content": "<p>I think that last problem goes away in lean4</p>",
        "id": 256292819,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633457547
    },
    {
        "content": "<p>I guess we could just define it like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/vector_space\">docs#vector_space</a> but not use it?</p>",
        "id": 256292843,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633457558
    },
    {
        "content": "<p>(i thought we did that for <code>vector_space</code> too but I guess not)</p>",
        "id": 256292952,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1633457600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list.20.28algebras.29/near/256289451\">said</a>:</p>\n<blockquote>\n<p>It still feels weird that we don't have a plain <code>non_unital_non_associative_algebra R A</code>. People coming to mathlib and asking where are algebras will have a very hard time understanding the answer</p>\n</blockquote>\n<p>Understanding the answer will be just as hard as understanding why we have <code>group</code> and <code>add_group</code>. And just as hard as why we can't use <code>∘</code> to denote multiplication in endomorphism rings.</p>",
        "id": 256302075,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633461158
    },
    {
        "content": "<p>I disagree, this is not the same order of magnitude.</p>",
        "id": 256302370,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633461267
    },
    {
        "content": "<p>Hmm, ok, I agree that such algebras could exist. Do you agree that Lie algebras wouldn't be instances?</p>",
        "id": 256303055,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633461530
    },
    {
        "content": "<p>I've never used such algebras, apart from Lie algebras.</p>",
        "id": 256303164,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633461576
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Does the \"<code>module R A</code> + <code>is_scalar_tower R A A</code> + <code>smul_comm_class R A A</code>\" definition work in this case?</p>",
        "id": 256303554,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633461728
    },
    {
        "content": "<p>If yes, then we can go with <a href=\"https://github.com/leanprover-community/mathlib/tree/redefine-algebra\">branch#redefine-algebra</a> and use very weak typeclass assumptions in the definition.</p>",
        "id": 256303621,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633461760
    },
    {
        "content": "<p>Johan, did you intend to write \"Lie algebras would be instances\"?</p>",
        "id": 256304125,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633461989
    },
    {
        "content": "<p>I'm talking about <a href=\"https://en.wikipedia.org/wiki/Non-associative_algebra\">https://en.wikipedia.org/wiki/Non-associative_algebra</a> which does include Lie algebras and mathlib algebras as special cases</p>",
        "id": 256304207,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633462020
    },
    {
        "content": "<p>(although wikipedia insists the base ring is a field for some mysterious reason)</p>",
        "id": 256304253,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633462037
    },
    {
        "content": "<p>No. I meant \"would not\".</p>\n<p>I think it is more useful that every associative algebra gives a Lie algebra, via the commutator bracket, then the fact that the Lie algebra can be viewed as a non-assoc multiplication.<br>\nHaving both as instances would give two non-propeq multiplications on every assoc algebra.</p>",
        "id": 256304387,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633462086
    },
    {
        "content": "<p>But we can have a type tag that turns a Lie algebra into a (non-assoc) algebra.</p>",
        "id": 256304601,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633462182
    },
    {
        "content": "<p>Then we restate all facts in terms of Lie brackets.</p>",
        "id": 256304627,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633462194
    },
    {
        "content": "<p>Yury, yes I think this collection of type classes work</p>",
        "id": 256304879,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633462278
    },
    {
        "content": "<p>And it is equivalent to the standard definition in case of <code>semiring A</code>.</p>",
        "id": 256304950,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633462311
    },
    {
        "content": "<p>Johan, we don't have to have instances of this, I only suggest that people who want to formalize stuff about algebras can find a way to express this without searching Zulip for this thread.</p>",
        "id": 256305042,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633462337
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> This <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> is another reason to remove <code>algebra_map</code> from the definition of <code>algebra</code>.</p>",
        "id": 256305141,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633462391
    },
    {
        "content": "<p>I certainly don't want our currently supported algebras to become harder to use because of this definition.</p>",
        "id": 256305208,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633462422
    },
    {
        "content": "<p>I think we can simply put the definition somewhere and not use it.</p>",
        "id": 256305278,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1633462443
    },
    {
        "content": "<p>Ok, then I fully agree with you.</p>",
        "id": 256306023,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1633462752
    },
    {
        "content": "<p>Earlier, I suggested the same retractor as a way to get rid of some TC diamonds.</p>",
        "id": 256306815,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633463076
    },
    {
        "content": "<p>We only lose some definitional equalities for <code>algebra_map</code>, nothing more.</p>",
        "id": 256306934,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633463128
    },
    {
        "content": "<p>And we can reuse instances about scalar towers in definitions of algebras.</p>",
        "id": 256307038,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1633463167
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list.20.28algebras.29/near/256305042\">said</a>:</p>\n<blockquote>\n<p>Johan, we don't have to have instances of this, I only suggest that people who want to formalize stuff about algebras can find a way to express this without searching Zulip for this thread.</p>\n</blockquote>\n<p>I think a better solution to this is to curate a note explaining how maths-speak translates to mathlib-speak. Typically, an explanation of how to declare a vector space or an algebra.</p>",
        "id": 256311534,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1633464796
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/10221\">#10221</a> improves the docstring of <code>algebra</code> a little, which somewhat helps here.</p>",
        "id": 260670195,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636384496
    },
    {
        "content": "<p>for vector spaces I think we came up with a really nice idea involving either notation or reducible defs, I can't remember, it was something Anne and I talked about months ago and then I never did anything about.</p>",
        "id": 260676207,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1636386954
    },
    {
        "content": "<p>Would it be possible to make a command to do the canonical <code>variables</code> incantation for you for various objects?</p>\n<p>For example, maybe</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">declare</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span>\n<span class=\"n\">declare</span> <span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span>\n</code></pre></div>\n<p>would do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I am imagining that this wouldn't be worked out automatically, but rather it would be hard-coded. Maybe another command <code>def_declare</code> could create entries in its database, allowing these definitions to be put near relevant classes.  Perhaps as a bonus it could add <code>{A : Type*}</code> and so on if these variables aren't already present.</p>\n<p>An unsophisticated implementation could be that <code>declare</code> is a parameterized <code>open_locale</code>, doing textual substitution of the arguments.</p>\n<p>If this is possible, would it be a good idea?  I like how it's not particularly magical (and you can verify its effects with <code>#where</code> and such) and how it doesn't abuse the language (anything nonstandard is localized to the <code>declare</code> line).</p>",
        "id": 260869839,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636495985
    },
    {
        "content": "<p>This is definitely doable (with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lean.parser.emit_code_here\">docs#lean.parser.emit_code_here</a>) and would make a nice little project! Working out which classes are needed from e.g. <code>algebra R A</code> should be doable too, at least if all the types involved appear in the target type class.</p>",
        "id": 260870689,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1636496409
    },
    {
        "content": "<p>I have a patch for Lean lying around somewhere that allows you to write <code>[ring R] [[algebra R A]] [[module R M]]</code>, and adds all the missing typeclass dependencies, e.g. <code>[ring R] [semiring A] [algebra R A] [add_comm_monoid M] [module R M]</code>. However, adding more locals broke the elaborator terribly and I couldn't figure out a good way to proceed.</p>",
        "id": 260870698,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1636496412
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lean/commit/d17c9e0c67573a35b8319da15b816409e92c160e\">https://github.com/leanprover-community/lean/commit/d17c9e0c67573a35b8319da15b816409e92c160e</a></p>",
        "id": 260871369,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1636496765
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> Having <code>[[...]]</code> notation for auto-inserting all missing dependencies in binders would be great, too, if that could work, though it doesn't solve <code>vector_space</code>, I think.  There could be an attribute for classes (<code>abbreviation_class</code>?) that directs this feature to try to eliminate the class completely. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[abbreviation_class]</span>\n<span class=\"kd\">def</span> <span class=\"n\">vector_space</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>could define how <code>`[[vector_space K V]]</code> is replaced, though this might be confusing if you forget the double square brackets.</p>",
        "id": 260871644,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636496940
    },
    {
        "content": "<p>Also as you can see, where in mathlib we would know to use <code>[add_comm_group M]</code> when <code>R</code> is a ring, the fancy brackets only insert <code>add_comm_monoid</code>.</p>",
        "id": 260871783,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1636497004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list.20.28algebras.29/near/260871644\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> Having <code>[[...]]</code> notation for auto-inserting all missing dependencies in binders would be great, too, if that could work, though it doesn't solve <code>vector_space</code>, I think.  There could be an attribute for classes (<code>abbreviation_class</code>?) that directs this feature to try to eliminate the class completely. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[abbreviation_class]</span>\n<span class=\"kd\">def</span> <span class=\"n\">vector_space</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>could define how <code>`[[vector_space K V]]</code> is replaced, though this might be confusing if you forget the double square brackets.</p>\n</blockquote>\n<p>Good idea to control the dependencies through an attribute. Maybe we could also setup something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n\n<span class=\"kd\">@[dependency (field K) (add_comm_group V)]</span>\n<span class=\"kd\">abbreviation</span> <span class=\"n\">vector_space</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">module</span> <span class=\"n\">K</span> <span class=\"n\">V</span>\n<span class=\"c1\">-- Don't specialize the typeclass arguments themselves!</span>\n</code></pre></div>",
        "id": 260872328,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1636497320
    },
    {
        "content": "<p>this would be super cool!</p>",
        "id": 260872508,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1636497405
    },
    {
        "content": "<p>I assume this is then meant for teaching and not mathlib?</p>",
        "id": 260872569,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636497443
    },
    {
        "content": "<p>I feel like it could be huge for mathlib if you could type more maths-friendly things far more often instead of the typeclass hell you see in things like the statement of FTC</p>",
        "id": 260872667,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1636497485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list.20.28algebras.29/near/260870698\">said</a>:</p>\n<blockquote>\n<p>I have a patch for Lean lying around somewhere that allows you to write <code>[ring R] [[algebra R A]] [[module R M]]</code>, and adds all the missing typeclass dependencies, e.g. <code>[ring R] [semiring A] [algebra R A] [add_comm_monoid M] [module R M]</code>. However, adding more locals broke the elaborator terribly and I couldn't figure out a good way to proceed.</p>\n</blockquote>\n<p>Looking at it again, the precise diagnosis involves <a href=\"https://github.com/leanprover-community/lean/blob/implicit-dep-binder/src/frontends/lean/definition_cmds.cpp#L796\">lines 796-801 of <code>definition_cmds.cpp</code></a>:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"n\">recover_from_errors</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">m_error_recovery</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">elaborator</span><span class=\"w\"> </span><span class=\"nf\">elab</span><span class=\"p\">(</span><span class=\"n\">env</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">get_options</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">resolve_decl_name</span><span class=\"p\">(</span><span class=\"n\">env</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fn</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">metavar_context</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">local_context</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">recover_from_errors</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">buffer</span><span class=\"o\">&lt;</span><span class=\"n\">expr</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">new_params</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">elaborate_params</span><span class=\"p\">(</span><span class=\"n\">elab</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">params</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">new_params</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">elab</span><span class=\"p\">.</span><span class=\"n\">freeze_local_instances</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">replace_params</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">new_params</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fn</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In <code>elaborate_params</code> I added the code to add dependencies for instance arguments, however <code>replace_params</code> can't tell at which points new params were inserted, so it (correctly) trips an error. So a solution would probably start with passing a list of added/deleted indices to <code>replace_params</code>.</p>",
        "id": 260873351,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1636497850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list.20.28algebras.29/near/260872667\">said</a>:</p>\n<blockquote>\n<p>I feel like it could be huge for mathlib if you could type more maths-friendly things far more often instead of the typeclass hell you see in things like the statement of FTC</p>\n</blockquote>\n<p>Yeah but also the modularity is crucial. During the convexity refacotr, I literally turned a single concrete type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> into around 15 shades of spaces.</p>",
        "id": 260873723,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1636498080
    },
    {
        "content": "<p>In support of modularity, it can protect code from changes to the algebra hierarchy, since things about a <code>vector_space</code> don't care too much about exactly which intermediate algebraic objects you also need to include.  (And there are in fact theorems about vector spaces, I believe. <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>",
        "id": 260874193,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1636498369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/113488-general/topic/Undergraduate.20math.20list.20.28algebras.29/near/260873351\">said</a>:</p>\n<blockquote>\n<p>So a solution would probably start with passing a list of added/deleted indices to <code>replace_params</code>.</p>\n</blockquote>\n<p>This seems to work, almost! Now the only issue is that we detect the list of missing instances by checking which errors result from elaborating the implicit+deps binder, but the errors seem to bubble up to the surface too(?)</p>",
        "id": 260878777,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1636501136
    },
    {
        "content": "<p>Now we ignore the \"missing instance\" errors. What do you all think, is this addition PR-worthy? <a href=\"https://github.com/leanprover-community/lean/compare/implicit-dep-binder\">https://github.com/leanprover-community/lean/compare/implicit-dep-binder</a></p>",
        "id": 260883160,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1636503773
    },
    {
        "content": "<p>What do the lean4 people think of this in lean4? Not sure who to @</p>",
        "id": 260883609,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1636504041
    }
]
[
    {
        "content": "<p>Trying to fix the <code>normed_space</code> issue, I ran into a weird behavior of typeclass resolution. The definition is now</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">normed_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"kn\">extends</span> <span class=\"n\">vector_space</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">norm_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"err\">•</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">has_norm</span><span class=\"bp\">.</span><span class=\"n\">norm</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">norm</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Then, to define a normed space structure on the space of continuous linear maps between two normed spaces, I write</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">to_normed_group</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">normed_group</span><span class=\"bp\">.</span><span class=\"n\">of_core</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨</span><span class=\"n\">op_norm_zero_iff</span><span class=\"o\">,</span> <span class=\"n\">op_norm_triangle</span><span class=\"o\">,</span> <span class=\"n\">op_norm_neg</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">to_normed_space</span> <span class=\"o\">:</span> <span class=\"n\">normed_space</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">op_norm_smul</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>The surprising behavior is that Lean can not infer the normed group structure on <code>E →L[k] (F × G)</code>.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">to_normed_group_prod</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">continuous_linear_map</span><span class=\"bp\">.</span><span class=\"n\">to_normed_group</span>\n</pre></div>\n\n\n<p>works, but using <code>by apply_instance</code> instead of <code>continuous_linear_map.to_normed_group</code> fails. I can register this instance by hand as I just did, and then everything works fine, but I am afraid this shows there is something wrong with my definitions.</p>",
        "id": 167264211,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1559632133
    },
    {
        "content": "<p>If I try with <code>apply_instance</code>, the context is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"mi\">1</span> <span class=\"n\">goal</span>\n<span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">,</span>\n<span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">,</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">nondiscrete_normed_field</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">normed_space</span> <span class=\"n\">k</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_4</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_5</span> <span class=\"o\">:</span> <span class=\"n\">normed_space</span> <span class=\"n\">k</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_6</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_7</span> <span class=\"o\">:</span> <span class=\"n\">normed_space</span> <span class=\"n\">k</span> <span class=\"n\">G</span>\n<span class=\"err\">⊢</span> <span class=\"n\">normed_group</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">F</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>and in the instance search trace I find the line</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_36</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">normed_space</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nondiscrete_normed_field</span><span class=\"bp\">.</span><span class=\"n\">to_normed_field</span> <span class=\"n\">k</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"n\">inst_6</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"n\">inst_7</span>\n<span class=\"n\">failed</span> <span class=\"n\">is_def_eq</span>\n</pre></div>\n\n\n<p>I don't understand what is going on...</p>",
        "id": 167266754,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1559634466
    },
    {
        "content": "<p>Crap, universe issues: if I put all of them in <code>Type</code>, everything works...</p>",
        "id": 167267018,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1559634632
    },
    {
        "content": "<p>Try changing <code>Type*</code> to <code>Type u</code> in some places, if you want to remain polymorphic. That sometimes changes things.</p>",
        "id": 167267097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559634714
    },
    {
        "content": "<p>I have no proper understanding of why this helps, but apparently it changes elaboration. This might be an unrelated issue though of course.</p>",
        "id": 167267161,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559634743
    },
    {
        "content": "<p>I just tried this, but the problem remains.</p>",
        "id": 167267169,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1559634753
    },
    {
        "content": "<p>Well spotted though; universe problems are hard to debug.</p>",
        "id": 167267182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559634770
    },
    {
        "content": "<p>I have in the past suggested that mathematicians would be better off working in only one universe -- after all, that's how mathematics of this nature actually works in practice. Since when did any mathematician ever want to consider two normed fields in two different universes? Universes are for people wrestling with categories in a serious way, not for people doing \"normal\" mathematics like this.</p>",
        "id": 167267322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559634876
    },
    {
        "content": "<p>I don't necessarily mean <code>Type</code>, but I'm suggesting <code>Type u</code> for everything.</p>",
        "id": 167267337,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559634896
    },
    {
        "content": "<p>The CS guys like this \"maximally universe polymorphic\" approach but I have never seen a benefit when doing this kind of mathematics. Are these issues present in Isabelle/HOL?</p>",
        "id": 167267389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559634942
    },
    {
        "content": "<p>If Lean struggles with them, and we don't actually need them, then this is an argument for just using one universe.</p>",
        "id": 167267486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559635009
    },
    {
        "content": "<p>What is done in Coq? Does anyone know?</p>",
        "id": 167267530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559635054
    },
    {
        "content": "<p>I agree with this (almost: I would be ready to have the field <code>k</code> in some universe -- think of the real numbers, they are in <code>Type</code> -- and the vector spaces in another one -- but in my example it doesn't work, they really all need to be in the same universe). I haven't seen any benefit of universe polymorphism either, and these issues don't exist in Isabelle. We really need the CS guys either to make it better, or to grant us the right to use only one universe :)</p>",
        "id": 167267840,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1559635271
    },
    {
        "content": "<p>Linear equivalences between vector spaces are currently not universe polymorphic... so it's not like you can't have non-universe polymorphic stuff in mathlib. It works like a virus though</p>",
        "id": 167268035,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559635415
    },
    {
        "content": "<p>I fear that the <code>ℚ_[ℓ]</code>-vector space that rolls out of étale cohomology will not live in <code>Type</code>.</p>",
        "id": 167268157,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559635480
    },
    {
        "content": "<p>I would still like to be able to apply general theorems to it.</p>",
        "id": 167268180,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559635496
    },
    {
        "content": "<p>Currently mathlib makes it hard for me to express that it is isomorphic to its double dual... (assuming that this cohomology group is fin.dim., which is often the case).</p>",
        "id": 167268241,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559635534
    },
    {
        "content": "<p>Just for the record, with <code>pp.all</code> I have in the context</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">_</span><span class=\"n\">inst_7</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">uG</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nondiscrete_normed_field</span><span class=\"bp\">.</span><span class=\"n\">to_normed_field</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"n\">inst_6</span>\n</pre></div>\n\n\n<p>and the line that fails in instance search, if I read the trace correctly, is</p>\n<div class=\"codehilite\"><pre><span></span>[class_instances] (1) ?x_36 : @normed_space.{u uG} k G (@nondiscrete_normed_field.to_normed_field.{u} k _inst_1) _inst_6 := _inst_7\nfailed is_def_eq\n</pre></div>\n\n\n<p>This is really a mystery to me...</p>",
        "id": 167268309,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1559635576
    },
    {
        "content": "<p>That's really crazy...</p>",
        "id": 167268338,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559635623
    },
    {
        "content": "<p>Is this the same reluctance to unify universe metavariables that makes you have to specify the category_theory morphism universe sometimes?</p>",
        "id": 167268361,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1559635652
    },
    {
        "content": "<p>So the category theory one I understand</p>",
        "id": 167268425,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559635685
    },
    {
        "content": "<p>The issue there is that, just like how in group theory we only talk about <code>G : Type u</code> and rely on the type class system to find <code>[group G]</code>, in category theory we talk about <code>C : Type u</code> and rely on the type class system to find <code>[category C]</code>. But there is a difference, because <code>category</code> has a second universe parameter <code>v</code> which is not determined by <code>C</code>. If you're unlucky it might also not be determined by whatever context is requiring the <code>category</code> instance and then Lean will refuse to \"guess\" <code>v</code> for you.</p>",
        "id": 167268584,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559635836
    },
    {
        "content": "<p>In that case you might need to add a <code>.{v}</code> somewhere.</p>",
        "id": 167268618,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559635874
    },
    {
        "content": "<p>When I saw Sebastien's tactic state my first thought was that there is some problem about universe variables, but I don't understand what the problem was. It looks as though there is just a bug.</p>",
        "id": 167268744,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559636018
    },
    {
        "content": "<blockquote>\n<p>I agree with this (almost: I would be ready to have the field <code>k</code> in some universe -- think of the real numbers, they are in <code>Type</code> -- and the vector spaces in another one -- but in my example it doesn't work, they really all need to be in the same universe). I haven't seen any benefit of universe polymorphism either, and these issues don't exist in Isabelle. We really need the CS guys either to make it better, or to grant us the right to use only one universe :)</p>\n</blockquote>\n<p>I like the \"<code>Type u</code> for everything\" approach for all the parts of math that don't routinely use universes even in informal presentations.<br>\nFor cases where you want to work over some particular base field in <code>Type</code> there's always <code>ulift</code>. If <code>ulift real</code> isn't already a field then we can have someone go and make <code>algebra/ulift_instances</code>.</p>",
        "id": 167269587,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559636791
    },
    {
        "content": "<p>What actually is the point of <code>Type u</code> not being in <code>Type u+2</code></p>",
        "id": 167269733,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1559636946
    },
    {
        "content": "<blockquote>\n<p>I fear that the <code>ℚ_[ℓ]</code>-vector space that rolls out of étale cohomology will not live in <code>Type</code>.</p>\n</blockquote>\n<p>Removing my computer science hat completely, you sound like you just said \"I fear that the etale cohomology groups are not sets\", to which I reply \"Johan that is complete nonsense, of course they're sets! What are you talking about?\"</p>",
        "id": 167270038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559637244
    },
    {
        "content": "<p>I think Johan means that the étale site of X is not small, but only essentially small. It's not clear what the best way to formalize this is--but informally we just pretend there's no difference at all.</p>",
        "id": 167270353,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559637492
    },
    {
        "content": "<p>I don't like have <code>ulift ℤ</code> and <code>ulift ℝ</code> all over the place... it's quite ugly. Otoh, battling universe issues is also ugly. I hope that we can jump between the two horns of this bull.</p>",
        "id": 167270471,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559637590
    },
    {
        "content": "<blockquote>\n<p>The issue there is that, just like how in group theory we only talk about <code>G : Type u</code> and rely on the type class system to find <code>[group G]</code>, in category theory we talk about <code>C : Type u</code> and rely on the type class system to find <code>[category C]</code>. But there is a difference, because <code>category</code> has a second universe parameter <code>v</code> which is not determined by <code>C</code>. If you're unlucky it might also not be determined by whatever context is requiring the <code>category</code> instance and then Lean will refuse to \"guess\" <code>v</code> for you.</p>\n</blockquote>\n<p>My way of thinking about this completely solves this issue. Every category that I run into as a \"normal mathematician\" who is not explicitly trying to prove theorems about categories but is instead just using them as a tool to do \"normal mathematics\", is either a category where the class of all objects is a set (e.g. a diagram category), or a category where the class of all objects is not a set, but Hom(X,Y) is a set for all objects X and Y (e.g. the categories of sets, groups, rings, vector spaces over a field, schemes, topological spaces, insert arbitrary sane mathematical object here i.e. not \"category\"). So in all of \"normal mathematics\" there are only two things: small categories and big categories. In both cases v is determined by u. Mathematicians use these two kinds of categories in different ways too; diagram categories are for taking limits, all the other categories are for giving us a unified language for managing data and theorems, giving us a general language such as \"adjoint functor\" to save pen when we're trying to say what we want to say. </p>\n<p>So the extension of my \"just use one universe\" argument to the category theory situation is \"if you want to make the category of perfectoid spaces, make it a \"category of the second kind\" with just one universe parameter u, and have X : Type u and Hom(X,Y) : Type u. One universe, doing the thing which the ZFC universe was invented to solve\". Problem solved. Not as universe polymorphic as some people like -- <em>but it works in Lean and it is enough for mathematicians</em>. </p>\n<p>Sure if you want to develop some theories about higher categories or whatever then feel free to wrestle with universes; I am not saying that all of the maths everyone does should stick to one universe. But I want to argue that for \"normal\" mathematics, being universe polymorphic is <em>actively bad</em>. It is bad because things don't work. It is bad because normal mathematicians say \"why are you assuming the existence of universes?\". I have no good answer to this question. I want to start a campaign for one universe.</p>",
        "id": 167270713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559637743
    },
    {
        "content": "<blockquote>\n<p>I think Johan means that the étale site of X is not small, but only essentially small. It's not clear what the best way to formalize this is--but informally we just pretend there's no difference at all.</p>\n</blockquote>\n<p>I must understand all the mathematics here. How do we define the constant sheaf Z/nZ on the etale site? Insert definition here. It's a sheaf. H^0 is then in Type, right?</p>",
        "id": 167270902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559637901
    },
    {
        "content": "<p>There are various ways of defining the higher H^i. Can't I just take some cohomologically trivial cover and then do some Cech-like thing? Is there really an issue here?</p>",
        "id": 167271017,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559637968
    },
    {
        "content": "<p>I don't really buy this.  It's a basic part of the formalism that any ring <code>R</code> is isomorphic to the ring of global sections of the structure sheaf on the Zariski site for <code>R</code>.  But under the natural framework of definitions, the latter ring will be in a higher universe.  You can probably avoid that, by some argument showing that it is sufficient to consider <code>R</code>-algebras of finite presentation, which can be specified by finite lists of elements of <code>R</code>.  But that will take some work.  However, there is some real mathematical content here: we have no right to expect that the obvious definition of etale cohomology does not lead to Russell-type paradoxes, and the reasons behind that are essentially the same as the universe considerations that we are discussing.</p>",
        "id": 167271433,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1559638297
    },
    {
        "content": "<p>Neil said basically what I was going to but just to spell out this \"natural framework\":<br>\nEtale cohomology is an instance of sheaf cohomology, which we can define for any site. If F is a sheaf on a site (C, J) then H^0(F) is the limit of F over C^{op}. In general if we allow C to be a large category then H^0(F) might really be too big to be a set even if all the values of F are sets.<br>\nNow in etale cohomology two things happen which each independently prevent this from occurring.</p>\n<ul>\n<li>The etale site of X has a terminal object (X itself) which means that H^0(F) is (isomorphic to) F(X). But we should regard this as a theorem, not a definition. Moreover we still have to do something about the higher H^i(F).</li>\n<li>The etale site of X is essentially small (by the kind of cardinality arguments Neil mentioned) and therefore we can compute all the H^i(F) by replacing the etale site by an equivalent small category. Again there are theorems involved here (these cardinality arguments, and the fact that cohomology is unchanged under an equivalence of sites) but perhaps it's most ergonomic to define etale cohomology as the sheaf cohomology over a genuinely small category equivalent to the etale site of X.</li>\n</ul>",
        "id": 167273439,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559639763
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> As mathematicians, we have <code>Type u ⊆ Type (u+1)</code>. Hence you're definition can spit out something in <code>Type (u+1)</code> but you can later prove that it actually lives in a smaller universe. We can't do that in Lean <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 167273625,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559639896
    },
    {
        "content": "<p>Conrad has thought hard about these issues and might have opinions on \"the best way to do it\". I'll see what he thinks. It will probably just be the \"replace by an equivalent small category\" argument.</p>",
        "id": 167273825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559640094
    },
    {
        "content": "<p>I do think it's essential to prove that cohomology groups are in the right universe. Wait -- this is orthogonal to the underlying issue, isn't it? If I'm prepared once and for all to do some work (which should be done!) to prove that my cohomology groups are sets (which is one way of thinking about it with a ZFC perspective) then this is all just fine still; I still don't ever need more than one universe. I'm aware there's an issue, but I don't think universe polymorphism is the way to solve it; I think what Reid is saying is the way to solve it. This is hence not an argument for multiple universes.</p>",
        "id": 167273968,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559640208
    },
    {
        "content": "<p>It's not yet clear to me how we can define <code>H^i_et</code> to be in <code>Type</code> and also make it interact nicely with the sheaf cohomology machinery. The answer is probably to have comparison isomorphisms all over the place. And once we get sufficiently annoyed by them, we try to write a tactic that hides them for us.</p>",
        "id": 167274185,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559640379
    },
    {
        "content": "<blockquote>\n<p>I do think it's essential to prove that cohomology groups are in the right universe.</p>\n</blockquote>\n<p>In Lean you cannot <em>prove</em> this. You have to make a definition, and that is the place where you have to get it right. If you mess up... bad luck.</p>",
        "id": 167274229,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559640443
    },
    {
        "content": "<p>But maybe we will have <code>norm_ulift</code> (-;</p>",
        "id": 167274329,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559640540
    },
    {
        "content": "<p>I totally agree that having a field <code>k</code> and two <code>k</code>-algebras <code>R</code> and <code>S</code> and an <code>S</code>-module <code>M</code> all living in different universes is not sustainable and mathlib is probably close to exhausting the material for which it makes sense. If universes are causing any difficulty then just put everything in a single <code>Type u</code>. Kevin I'm not sure whether your \"one universe\" is <code>Type u</code> for a \"fixed\" <code>u</code> or genuinely <code>Type</code>--if the latter then I'm more skeptical.<br>\nThe reason we have two parameters in category theory is just to avoid duplication between small and large categories. We have definitions with up to four category parameters, I think, so there would be a lot of combinations.</p>",
        "id": 167274836,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559640974
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> But your problem didn't go away if you put everything in <code>Type u</code>, right? Only putting everything in <code>Type</code> worked, iirc...</p>",
        "id": 167275023,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1559641109
    },
    {
        "content": "<p>It works fine if everything is in <code>Type u</code>. If the field is in <code>Type u</code> and the normed spaces are in <code>Type v</code>, it doesn't.</p>",
        "id": 167275473,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1559641413
    },
    {
        "content": "<p>Coming back to the original question, is there a MWE?</p>",
        "id": 167283353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559648478
    },
    {
        "content": "<p>From Brian:</p>\n<blockquote>\n<p>You don’t mean “equivalent to the etale site” (that can and should have arbitrarily huge disjoint unions in it), but rather the sheaf theory on such a more limited site is naturally equivalent (via restriction) to the sheaf theory on the actual small etale site. </p>\n<p>This latter sheaf theory has no set-theoretic issues (in terms of Hom-sets being sets, etc.) because the sheaf theory only needs a “base” for the topology to determine objects up to unique isomorphisms and maps between objects.  So if for a scheme X you consider just affine schemes E equipped with an etale map f members U of a chosen base of Zariski open affines in X (to make it more “concrete”) then there’s a set of such triples (E, U, f) for which any triple is isomorphic to one of those, and if you throw in all finitely iterated fiber products among these then those objects and maps among them form a site and its sheaf theory is naturally equivalent to the one on X, so in that way you’ll get all the data you need to do the sheaf theory without set-theoretic issues.  The sheaf theory on the small etale site (etale X-schemes and etale covers thereof) is all that is needed for any of the foundational theorems and applications thereof (e.g., Weil II, etc.) that I have ever seen.</p>\n<p>In EGA there is the important theorem that if Spec(B) —&gt; Spec(A) is etale, then Zariski-locally B looks “standard-etale” (i.e., (A[X]/(f))[1/f’]_h  for some monic f and some h in A[X]), but in the Stacks Project this is improved to avoid needing to Zariski-localize upstairs.  Same with smooth maps between affines.  Maybe that would be useful to you? </p>\n<p>Brian</p>\n</blockquote>",
        "id": 167309447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559664302
    },
    {
        "content": "<p>No MWE, it depends on two many modifications to mathlib. Once <a href=\"https://github.com/leanprover-community/mathlib/issues/1085\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/1085\">#1085</a> is merged, I will PR a branch with the workaround and showing the issue.</p>",
        "id": 167317206,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1559669498
    },
    {
        "content": "<p>I'm working on it, but probably won't have time to finish before dinner, and then I need to bring one of my daughter to a spectacle...</p>",
        "id": 167317375,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559669584
    },
    {
        "content": "<p>While we are on the topic of universes, I'll point to a problem that I recently came across. When I was in Edinburgh, Marijn Heule wrote me and me that Donald Knuth had written him with a question about the Mycielskian (<a href=\"https://en.wikipedia.org/wiki/Mycielskian\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Mycielskian\">https://en.wikipedia.org/wiki/Mycielskian</a>). Knuth remarked that he thought the construction would be hard to carry out in an interactive theorem prover like Coq. So, I tried it. Knuth was wrong; the construction is routine and the formalization did not take long at all. It is here: <a href=\"https://gist.github.com/avigad/6c1b7a2b771ac561425f50ffd69a4815\" target=\"_blank\" title=\"https://gist.github.com/avigad/6c1b7a2b771ac561425f50ffd69a4815\">https://gist.github.com/avigad/6c1b7a2b771ac561425f50ffd69a4815</a>.</p>\n<p>There were a few issues I wanted to raise here. First, I made the constructions computable, since it would be a shame if we could not compute with finite graphs. But I ultimately decided it is a mistake to use <code>fintype</code>s, and if I ever get back to this, I'll rewrite the constructions to avoid them. The problem is that if <code>α</code> is a <code>fintype</code>, then <code>card α = card α</code> is not necessarily provable by reflexivity, since there is an implicit dependence on the list of elements that is inferred. This actually comes up; rewrites can fail since different ways of getting a term lead to different instances. I think the right way to go is to use <code>finset</code>s instead.</p>\n<p>Second, a silly calculation in <code>nat</code> was much harder than it should have been: <a href=\"https://gist.github.com/avigad/6c1b7a2b771ac561425f50ffd69a4815#file-mycielskian-lean-L162-L168\" target=\"_blank\" title=\"https://gist.github.com/avigad/6c1b7a2b771ac561425f50ffd69a4815#file-mycielskian-lean-L162-L168\">https://gist.github.com/avigad/6c1b7a2b771ac561425f50ffd69a4815#file-mycielskian-lean-L162-L168</a>.  (<span class=\"user-mention\" data-user-id=\"116585\">@Seul Baek</span> I can show you some examples where the <code>omega</code> tactic gets confused.) I have been meaning to experiment some more before passing it off to all of you, but I will be interested in hearing if any of you can make the calculation more automatic.</p>\n<p>Finally (and this is the place where universes come in), I said that a graph is k-colorable if there exists a type α of cardinality k and a coloring of the graph with elements from alpha. But I could not get the key proof to work without naming universes explicitly: <a href=\"https://gist.github.com/avigad/6c1b7a2b771ac561425f50ffd69a4815#file-mycielskian-lean-L125-L126\" target=\"_blank\" title=\"https://gist.github.com/avigad/6c1b7a2b771ac561425f50ffd69a4815#file-mycielskian-lean-L125-L126\">https://gist.github.com/avigad/6c1b7a2b771ac561425f50ffd69a4815#file-mycielskian-lean-L125-L126</a>. I messed around with proof terms and tactics for a while before resorting to that. I have been meaning to come back to it and experiment some more, but I am teaching a summer school workshop that has been absorbing all my energy. (I have ~25 really great undergraduates from all over, coming from math, computer science, and philosophy.) Anyhow, if anyone can tell me what I am doing wrong and why I need the universe annotations, I'd be interested in hearing it.</p>",
        "id": 167340123,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1559686541
    },
    {
        "content": "<p>I strongly agree that the <code>fintype</code> thing is a major problem, but I wasn't sure of the best approach. It's a barrier to finite groups that never got resolved. I'm not sure how using finsets solves the issue, <code>card α</code>, would become <code>finset.univ.card</code>, but we still use a <code>fintype</code> instance. I thought it might be okay to just make <code>fintype</code> a proposition for most proof purposes, and keep the computable version just in case anyone wanted to compute with it. Either that or make Lean handle subsingletons better with rewrite / simp etc.</p>",
        "id": 167340478,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1559686984
    },
    {
        "content": "<p>Chris pointed out the <code>fintype</code> issue to me nearly a year ago now. </p>\n<p>Jeremy's silly <code>nat</code> calculation is this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">silly</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"err\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"err\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span>\n<span class=\"mi\">2</span> <span class=\"err\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"err\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">ring</span><span class=\"o\">,</span>\n <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">sub_add_eq_add_sub</span><span class=\"o\">],</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ_sub_succ</span> <span class=\"o\">},</span>\n  <span class=\"n\">change</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">mul_le_mul</span><span class=\"bp\">;</span> <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">simp</span><span class=\"o\">},</span>\n  <span class=\"n\">change</span> <span class=\"mi\">2</span><span class=\"err\">^</span><span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pow_le_pow_of_le_right</span><span class=\"bp\">;</span> <span class=\"n\">norm_num</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>It's the sort of thing that would turn Patrick's stomach! </p>\n<p>Universes are somehow beyond my ken.</p>",
        "id": 167341174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559687722
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> The universe issue is because <code>colorable</code> has an internal universe variable:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">colorable</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">coloring</span> <span class=\"n\">G</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">α</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">k</span>\n</pre></div>\n\n\n<p>means</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">colorable</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">coloring</span> <span class=\"n\">G</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">α</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">k</span>\n</pre></div>\n\n\n<p>where you almost certainly did not intend to have <code>colorable</code> take a second (input!) universe variable. It is not possible to existentially quantify over universe variables, so <code>colorable.{u v} G k</code> says that there is a coloring using some type in <code>Type v</code>. I would suggest either using <code>Type u</code> instead of <code>Type v</code> here, or even simpler, skipping general types entirely and using <code>fin k</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">colorable</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">coloring</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>Then the equivalence to the first definition (for an arbitrary fintype in any universe) is a theorem.</p>",
        "id": 167341572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559688125
    },
    {
        "content": "<p>Thanks to all three of you for the quick responses! </p>\n<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> You are right. It is convenient to use inductive types for graph-theoretic constructions, but then I don't see how to get a <code>finset</code> without avoiding the <code>fintype</code> problem. Probably the best solution, as you say, is to have a <code>finite_type</code> class in <code>Prop</code> that mirrors the <code>fintype</code> one (until <code>rw</code> and so on are able to handle subsingletons). The duplication would be unfortunate though. (Or does anyone really need the one in <code>Type</code>?)</p>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Thanks for the explanation. Forcing the colors to be in the same type as the graph might work. (But maybe one day someone will want to 2-color a huge graph with <code>bool</code>?) Using a general type rather than <code>fin k</code> was useful in the proofs, because in the key argument Wikipedia runs as follows: \"Suppose you have a coloring of the original graph with {1,...,k}. Without loss of generality, we can assume the hub is colored k.\" Can you see a clever way to get the WLOG using <code>fin k</code>?</p>",
        "id": 167342630,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1559689267
    },
    {
        "content": "<p>I'm not saying you can't have <code>coloring G A</code> for some other type <code>A</code>, I'm saying to prove a lemma that this implies <code>coloring G (fin (card A))</code> and hence <code>colorable G (card A)</code></p>",
        "id": 167342761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559689404
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">what_is_this_called</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 167342769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559689415
    },
    {
        "content": "<p>My library-search-fu is failing me.</p>",
        "id": 167342825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559689458
    },
    {
        "content": "<p>it's an iff, sub will be on the left, and on the left of the eq</p>",
        "id": 167342839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559689490
    },
    {
        "content": "<p>so <code>nat.sub_eq_iff_add_eq</code> or similar</p>",
        "id": 167342855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559689503
    },
    {
        "content": "<p>Ah, got it. Yes, that seems the way to go.</p>",
        "id": 167342869,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1559689515
    },
    {
        "content": "<p>it's <code>nat.sub_eq_iff_eq_add</code></p>",
        "id": 167342878,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559689549
    },
    {
        "content": "<p>It's not an iff because maybe a=0 and c&gt;&gt;b</p>",
        "id": 167343211,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559689938
    },
    {
        "content": "<p>oh, you aren't assuming the subtraction works?</p>",
        "id": 167343223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559689970
    },
    {
        "content": "<p>It's somehow not quite the right thing anyway. You do have to prove <code>1 ≤ 2 ^ n * 2 * 1 + 2 ^ n * 2 * d - 1</code> at some point -- yeah exactly, that the subtraction works.</p>",
        "id": 167343243,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559690002
    },
    {
        "content": "<p>I don't think we have it; if there is an equality in the hypotheses we usually just substitute it in, so it's just saying <code>a + b - b = a</code> which is one of the variants of <code>nat.add_sub_cancel</code></p>",
        "id": 167343315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559690060
    },
    {
        "content": "<p>(also I think this is the wrong thread)</p>",
        "id": 167343352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559690128
    },
    {
        "content": "<p>this thread is already a mess ;-)</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">silly</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"err\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"err\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span>\n<span class=\"mi\">2</span> <span class=\"err\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"err\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">sub_eq_iff_eq_add</span><span class=\"o\">,</span>\n    <span class=\"n\">ring</span><span class=\"o\">,</span>\n<span class=\"c1\">--    ⊢ 1 ≤ 2 ^ n * 2 * 1 + 2 ^ n * 2 * d - 1</span>\n<span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I don't see how one can get away from that silly inequality goal.</p>",
        "id": 167343421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559690181
    },
    {
        "content": "<p>oh I see this is Jeremy's nat equality issue</p>",
        "id": 167343437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559690221
    },
    {
        "content": "<p>Right.</p>",
        "id": 167343446,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559690227
    },
    {
        "content": "<p>But he's doing exactly what I'm going to have to do now, n&gt;=0 and d&gt;=0 so done.</p>",
        "id": 167343455,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559690251
    },
    {
        "content": "<p>Maybe some sort of mono tactic saves you the pain?</p>",
        "id": 167343466,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559690280
    },
    {
        "content": "<p>apply <code>a + b &lt;= c -&gt; a &lt;= c - b</code> and then linarith</p>",
        "id": 167343516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559690291
    },
    {
        "content": "<p><code>linarith</code> was the first thing I tried. It doesn't work.</p>",
        "id": 167343601,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559690392
    },
    {
        "content": "<p>The lemma is basically equivalent to <code>⊢ 1 ≤ 2 ^ n * 2 * 1 + 2 ^ n * 2 * d - 1</code>; if you can get the cancellation to work then <code>ring</code> does the job. But to prove this you need <code>2^n&gt;=1</code> and now it's all going a bit meh.</p>",
        "id": 167343677,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559690453
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">silly</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"err\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"err\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span>\n<span class=\"mi\">2</span> <span class=\"err\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"err\">^</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">sub_eq_iff_eq_add</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">ring</span><span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">le_sub_left_of_add_le</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pow_pos</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span><span class=\"o\">:</span><span class=\"mi\">2</span><span class=\"bp\">&gt;</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 167344001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559690872
    },
    {
        "content": "<p>Aah you just beat me on length -- I didn't know about <code>nat.pow_pos</code> so used <code>nat.pow_le_pow_of_le_right</code>. I found <code>nat.le_sub_right_of_add_le</code> using <code>library_search</code> :D</p>",
        "id": 167344329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559691292
    },
    {
        "content": "<p>Better solution: don't use subtraction</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">card_iterated_mycielskian</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">graph</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">vertex</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">card</span> <span class=\"o\">(</span><span class=\"n\">iterated_mycielskian</span> <span class=\"n\">G</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">vertex</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"err\">^</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">card</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">vertex</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">iterated_mycielskian</span><span class=\"o\">],</span> <span class=\"o\">{</span><span class=\"n\">simp</span><span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">card_mycielskian</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pow_succ</span><span class=\"o\">,</span> <span class=\"n\">mul_right_comm</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">ih</span><span class=\"o\">],</span> <span class=\"n\">ring</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 167344347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559691318
    },
    {
        "content": "<p>That horrific function shouldn't even be called subtraction.</p>",
        "id": 167344357,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559691346
    },
    {
        "content": "<p>monus then</p>",
        "id": 167344361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559691358
    },
    {
        "content": "<p>I think Patrick would prefer moanus</p>",
        "id": 167344415,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559691380
    },
    {
        "content": "<p>I like Mario's last solution. I should have thought of it. I wonder: how can we record this general strategy so that others don't make the same mistake I did? We need a theorem linter that warns users away from subtraction on nat and suggests alternatives. (Similarly, one should replace division on int and nat by multiplication, despite Descartes' rule XX: <a href=\"https://en.wikisource.org/wiki/Rules_for_the_Direction_of_the_Mind\" target=\"_blank\" title=\"https://en.wikisource.org/wiki/Rules_for_the_Direction_of_the_Mind\">https://en.wikisource.org/wiki/Rules_for_the_Direction_of_the_Mind</a>.)</p>",
        "id": 167344697,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1559691779
    },
    {
        "content": "<p>Perhaps we should collect some tips and tricks. It's not quite the same as the style guide, and I don't think any of the other doc pages covers this area, but I think we have a decent collection of things to avoid and beginner mistakes</p>",
        "id": 167344965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1559692136
    },
    {
        "content": "<p>\"Work always in maximal generality\" would be a good rule too.</p>",
        "id": 167346981,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1559694593
    },
    {
        "content": "<p>About the original question: are the lines the same with <code>set_option pp.instantiate_mvars false</code> (in addition to <code>pp.all true</code> )? I have no particular reason why they wouldn't be, but there was another case where this option showed a difference when <code>pp.all</code> didn't.</p>",
        "id": 167364857,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1559720292
    },
    {
        "content": "<p>With <code>set_option pp.instantiate_mvars false</code>, I still get in the trace</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_36</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">uG</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nondiscrete_normed_field</span><span class=\"bp\">.</span><span class=\"n\">to_normed_field</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"n\">inst_6</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"n\">inst_7</span>\n<span class=\"n\">failed</span> <span class=\"n\">is_def_eq</span>\n</pre></div>\n\n\n<p>while I have in the context</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">_</span><span class=\"n\">inst_7</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">uG</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nondiscrete_normed_field</span><span class=\"bp\">.</span><span class=\"n\">to_normed_field</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"n\">inst_6</span>\n</pre></div>",
        "id": 167365128,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1559720624
    },
    {
        "content": "<p>If someone wants to play with this weird instance search behavior, the branch is now available at <a href=\"https://github.com/leanprover-community/mathlib/issues/1112\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/1112\">#1112</a></p>",
        "id": 167370809,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1559726102
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230999\">@Daniel Selsam</span> You were looking for weird instance behavior. The one at the beginning of this thread is still puzzling for me. To sum it up: in <code>analysis/normed_space/operator_norm.lean</code>, there are the lines</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\">- Continuous linear maps themselves form a normed space with respect to</span>\n<span class=\"cm\">    the operator norm. -/</span>\n<span class=\"kn\">instance</span> <span class=\"n\">to_normed_group</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">normed_group</span><span class=\"bp\">.</span><span class=\"n\">of_core</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨</span><span class=\"n\">op_norm_zero_iff</span><span class=\"o\">,</span> <span class=\"n\">op_norm_triangle</span><span class=\"o\">,</span> <span class=\"n\">op_norm_neg</span><span class=\"bp\">⟩</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The next instance should be found automatically, but it is not.</span>\n<span class=\"cm\">TODO: fix me -/</span>\n<span class=\"kn\">instance</span> <span class=\"n\">to_normed_group_prod</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">continuous_linear_map</span><span class=\"bp\">.</span><span class=\"n\">to_normed_group</span>\n</pre></div>\n\n\n<p>I don't know why the second instance is not found by <code>apply_instance</code>. The instance trace search contains the line</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"err\">?</span><span class=\"n\">x_36</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">uG</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nondiscrete_normed_field</span><span class=\"bp\">.</span><span class=\"n\">to_normed_field</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"n\">inst_6</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"n\">inst_7</span>\n<span class=\"n\">failed</span> <span class=\"n\">is_def_eq</span>\n</pre></div>\n\n\n<p>while the context contains</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">_</span><span class=\"n\">inst_7</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">uG</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nondiscrete_normed_field</span><span class=\"bp\">.</span><span class=\"n\">to_normed_field</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">k</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"n\">inst_6</span>\n</pre></div>\n\n\n<p>If everything is put in <code>Type</code> (or even in the same universe), then the issue disappears.</p>",
        "id": 177703430,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1570619903
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Thanks. I'll look into it, though it seems to be just an issue with the unifier, not the typeclass resolution procedure itself. Note that you can trace the failed <code>is_def_eq</code> with <code>set_option trace.type_context.is_def_eq</code> and <code>set_option trace.type_context.is_def_eq_detail</code>.</p>",
        "id": 177712254,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1570627024
    },
    {
        "content": "<p>This is way too big for my eyes. I was wondering if this is was a problem with the unifier, or with typeclass resolution feeding something weird to the unifier.</p>",
        "id": 177713460,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1570627898
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Reading the unifier log is an art. Could you put it in a gist/...?</p>",
        "id": 177714468,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1570628553
    },
    {
        "content": "<p>Done at <a href=\"https://gist.github.com/sgouezel/8357413e4c91f1092993c7a2c04ee112\" target=\"_blank\" title=\"https://gist.github.com/sgouezel/8357413e4c91f1092993c7a2c04ee112\">https://gist.github.com/sgouezel/8357413e4c91f1092993c7a2c04ee112</a>. 2821 lines, so not sure this helps...</p>",
        "id": 177715662,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1570629340
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Thanks. Can you please enable <code>pp.all</code>? We need to see the universes.</p>",
        "id": 177718668,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1570631173
    },
    {
        "content": "<p>Sure. It is at <a href=\"https://gist.github.com/sgouezel/be6d961c87d2c6bb017a8fba2417d229\" target=\"_blank\" title=\"https://gist.github.com/sgouezel/be6d961c87d2c6bb017a8fba2417d229\">https://gist.github.com/sgouezel/be6d961c87d2c6bb017a8fba2417d229</a>, with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">type_context</span><span class=\"bp\">.</span><span class=\"n\">is_def_eq</span> <span class=\"n\">true</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">type_context</span><span class=\"bp\">.</span><span class=\"n\">is_def_eq_detail</span> <span class=\"n\">true</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"n\">true</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">class_instances</span> <span class=\"n\">true</span>\n</pre></div>",
        "id": 177719099,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1570631456
    },
    {
        "content": "<p>4169 lines now...</p>",
        "id": 177719178,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1570631506
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Thanks. The message is so long that it got truncated though. One last request: can you please do the same thing but with <code>pp.universes</code> instead of <code>pp.all</code>?</p>",
        "id": 177719603,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1570631785
    },
    {
        "content": "<p>(My system is configured for Lean4 so it is not convenient for me to generate these myself right now)</p>",
        "id": 177719669,
        "sender_full_name": "Daniel Selsam",
        "timestamp": 1570631826
    },
    {
        "content": "<p>Ah, I didn't spot it got truncated. New version at <a href=\"https://gist.github.com/sgouezel/11afeb220ab65f45f4565c1f05c25546\" target=\"_blank\" title=\"https://gist.github.com/sgouezel/11afeb220ab65f45f4565c1f05c25546\">https://gist.github.com/sgouezel/11afeb220ab65f45f4565c1f05c25546</a> with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">type_context</span><span class=\"bp\">.</span><span class=\"n\">is_def_eq</span> <span class=\"n\">true</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">type_context</span><span class=\"bp\">.</span><span class=\"n\">is_def_eq_detail</span> <span class=\"n\">true</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">universes</span> <span class=\"n\">true</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">class_instances</span> <span class=\"n\">true</span>\n</pre></div>\n\n\n<p>And I am happy to give you any output you need (you're trying to help, after all!)</p>",
        "id": 177720247,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1570632139
    },
    {
        "content": "<p>3144 lines</p>",
        "id": 177720296,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1570632172
    },
    {
        "content": "<p>Another version where it fails on</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">to_normed_group_prod</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">×</span> <span class=\"n\">E</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>\n\n\n<p>is available at <a href=\"https://gist.github.com/sgouezel/1bde1320a31474311bb4f1331ee58960\" target=\"_blank\" title=\"https://gist.github.com/sgouezel/1bde1320a31474311bb4f1331ee58960\">https://gist.github.com/sgouezel/1bde1320a31474311bb4f1331ee58960</a>. There are just 2 universes instead of 4, so this is maybe easier to read.</p>",
        "id": 177720610,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1570632339
    }
]
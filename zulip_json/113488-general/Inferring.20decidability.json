[
    {
        "content": "<p>The following mwe comes from some experiments we were running on the speed of the Miller-Rabin test. Lean has no trouble figuring out that equality on zmod is decidable when evaluating <code>fast_strong_probable_prime</code>, but it somehow won't infer this when evaluating <code>fermat_strong_probable_prime</code>.  Why is this? In fact, why is it even necessary to write <code>or.decidable</code> to prove <code>fast_strong_probable_prime</code> is decidable? Shouldn't the typeclass inference system know this already without having to be told?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.zmod.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">binpow</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.binary_rec</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"k\">let</span> <span class=\"n\">ih2</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span> <span class=\"bp\">*</span> <span class=\"n\">ih</span> <span class=\"k\">in</span> <span class=\"n\">cond</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">ih2</span><span class=\"o\">)</span> <span class=\"n\">ih2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fast_two_multiplicity</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.binary_rec</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">cond</span> <span class=\"n\">b</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">ih</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fast_odd_part</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"n\">fast_two_multiplicity</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fast_strong_probable_prime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">binpow</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">fast_odd_part</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;</span> <span class=\"n\">fast_two_multiplicity</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">binpow</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">fast_odd_part</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fermat_strong_probable_prime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">binpow</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">fast_strong_probable_prime</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">or.decidable</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">fast_strong_probable_prime</span> <span class=\"mi\">1241213</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- instance {n : ℕ} {a : zmod n} : decidable (fermat_strong_probable_prime n a) := sorry</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">fermat_strong_probable_prime</span> <span class=\"mi\">1241213</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 279196225,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1650159633
    },
    {
        "content": "<p>Definitions are by default semireducible, and semireducible definitions aren't unfolded during typeclass inference. If you unfold it yourself, then it's able to infer it automatically:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">fast_strong_probable_prime</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">fast_strong_probable_prime</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>When you do <code>or.decidable</code>, what's happening is that the elaborator unfolds the definition for you since during unification semireducible definitions are unfolded as needed.</p>",
        "id": 279197638,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650162198
    },
    {
        "content": "<p>If you make the definition reducible, then typeclass inference will unfold the definition if needed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[reducible]</span>\n<span class=\"kd\">def</span> <span class=\"n\">fast_strong_probable_prime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">binpow</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">fast_odd_part</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;</span> <span class=\"n\">fast_two_multiplicity</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">binpow</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">fast_odd_part</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">fast_strong_probable_prime</span> <span class=\"mi\">1241213</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 279197696,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650162248
    },
    {
        "content": "<p>Both of these methods adapt for the last <code>#eval</code>. Here's creating a decidable instance by unfolding:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">fermat_strong_probable_prime</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">fermat_strong_probable_prime</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span> <span class=\"o\">}</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">fermat_strong_probable_prime</span> <span class=\"mi\">1241213</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 279197713,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650162333
    },
    {
        "content": "<p>You can also avoid this by making your functions be <code>bool</code>-valued:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fast_strong_probable_prime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"n\">binpow</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">fast_odd_part</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;</span> <span class=\"n\">fast_two_multiplicity</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">binpow</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">fast_odd_part</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fermat_strong_probable_prime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"o\">:=</span>\n<span class=\"n\">binpow</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">fast_strong_probable_prime</span> <span class=\"mi\">1241213</span> <span class=\"mi\">3</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">fermat_strong_probable_prime</span> <span class=\"mi\">1241213</span> <span class=\"mi\">3</span>\n</code></pre></div>\n<p>There's a coercion from <code>bool</code> to <code>Prop</code> so you can still use these inside propositions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">to_bool</span> <span class=\"o\">(</span><span class=\"n\">fast_strong_probable_prime</span> <span class=\"mi\">1241213</span> <span class=\"mi\">3</span> <span class=\"bp\">∨</span> <span class=\"n\">fermat_strong_probable_prime</span> <span class=\"mi\">1241213</span> <span class=\"mi\">3</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 279197863,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1650162564
    }
]
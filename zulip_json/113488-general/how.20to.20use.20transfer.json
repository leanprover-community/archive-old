[
    {
        "content": "<p>Okay, here is a mockup use of <code>transfer</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">xnat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">xnat</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">xnat</span> <span class=\"bp\">→</span> <span class=\"n\">xnat</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"n\">xnat</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"n\">xnat</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"mi\">0</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">to_xnat</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">xnat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">to_xnat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"n\">def</span> <span class=\"n\">of_xnat</span> <span class=\"o\">:</span> <span class=\"n\">xnat</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">of_xnat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">to_of_xnat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">to_xnat</span> <span class=\"o\">(</span><span class=\"n\">of_xnat</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">to_of_xnat</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">of_to_xnat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">of_xnat</span> <span class=\"o\">(</span><span class=\"n\">to_xnat</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">of_to_xnat</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">xnat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">to_xnat</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_zero</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_succ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">rel</span><span class=\"o\">)</span> <span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">m</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩;</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_one</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">xnat</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">induction</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">n_ih</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">to_xnat_add</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">to_xnat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">to_xnat</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">to_xnat</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">to_xnat_add</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_add</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">rel</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">m</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩</span> <span class=\"n\">n</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩;</span> <span class=\"n\">apply</span> <span class=\"n\">to_xnat_add</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_eq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">=</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">=</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">m</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩</span> <span class=\"n\">n</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩;</span> <span class=\"n\">exact</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">of_to_xnat</span><span class=\"o\">]</span> <span class=\"kn\">using</span> <span class=\"n\">congr_arg</span> <span class=\"n\">of_xnat</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">congr_arg</span> <span class=\"bp\">_⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">bi_total</span> <span class=\"n\">rel</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">to_of_xnat</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩⟩</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">xnat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">transfer</span><span class=\"bp\">.</span><span class=\"n\">transfer</span> <span class=\"o\">[</span><span class=\"bp\">``</span><span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">rel_forall_of_total</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">rel_eq</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">rel_add</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 135299504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538803273
    },
    {
        "content": "<p>Coincidentally I was playing with some proofs recently where I wished I had automatic transport. I'm playing with (regular) languages, and I've manually proven language equivalences like <code>L₁ ≃ L₃ → L₂ ≃ L₄ → L₁ ∪ L₂ ≃ L₃ ∪ L₄</code> which feel a lot like the <code>A ≃ B → P A ≃ P B</code> univalent transport</p>",
        "id": 135299649,
        "sender_full_name": "Scott Olson",
        "timestamp": 1538803600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Thanks a lot for this mock-up! Do you mind if I post my thoughts about it?</p>",
        "id": 135299658,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538803669
    },
    {
        "content": "<p>of course, that's the idea</p>",
        "id": 135299697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538803690
    },
    {
        "content": "<p>I wonder if <code>transfer</code> would apply here? It might run intro trouble because these is an equivalence of functions, and <code>funext</code>-as-a-theorem would still be something cubical types have and Lean doesn't, but I haven't thought this through</p>",
        "id": 135299698,
        "sender_full_name": "Scott Olson",
        "timestamp": 1538803694
    },
    {
        "content": "<p>Should we take it to a different thread?</p>",
        "id": 135299700,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538803712
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> wrote a mockup use of <code>transfer</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">xnat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">xnat</span>\n<span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">xnat</span> <span class=\"bp\">→</span> <span class=\"n\">xnat</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"n\">xnat</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"n\">xnat</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"mi\">0</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">to_xnat</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">xnat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">to_xnat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"n\">def</span> <span class=\"n\">of_xnat</span> <span class=\"o\">:</span> <span class=\"n\">xnat</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">of_xnat</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">to_of_xnat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">to_xnat</span> <span class=\"o\">(</span><span class=\"n\">of_xnat</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">to_of_xnat</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">of_to_xnat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">of_xnat</span> <span class=\"o\">(</span><span class=\"n\">to_xnat</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">of_to_xnat</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">xnat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">to_xnat</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_zero</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_succ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">rel</span><span class=\"o\">)</span> <span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">m</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩;</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_one</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">xnat</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">induction</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">n_ih</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">to_xnat_add</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">to_xnat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">to_xnat</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">to_xnat</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">to_xnat_add</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_add</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">rel</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">m</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩</span> <span class=\"n\">n</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩;</span> <span class=\"n\">apply</span> <span class=\"n\">to_xnat_add</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_eq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">=</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">=</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">m</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩</span> <span class=\"n\">n</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩;</span> <span class=\"n\">exact</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">of_to_xnat</span><span class=\"o\">]</span> <span class=\"kn\">using</span> <span class=\"n\">congr_arg</span> <span class=\"n\">of_xnat</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">congr_arg</span> <span class=\"bp\">_⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">bi_total</span> <span class=\"n\">rel</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">to_of_xnat</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩⟩</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">xnat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">transfer</span><span class=\"bp\">.</span><span class=\"n\">transfer</span> <span class=\"o\">[</span><span class=\"bp\">``</span><span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">rel_forall_of_total</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">rel_eq</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">rel_add</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 135299706,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538803775
    },
    {
        "content": "<p>First of all: I think for general applicability I think we need a quick way to construct <code>rel</code> from an `equiv.</p>",
        "id": 135299754,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538803817
    },
    {
        "content": "<p>And then I have several conflicting thoughts...</p>",
        "id": 135299803,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538803968
    },
    {
        "content": "<p>One is, given <code>nat</code> and the definition of <code>xnat</code> I would like to just immediately transfer <code>comm_semiring</code> to <code>xnat</code>.</p>",
        "id": 135299809,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804004
    },
    {
        "content": "<p>All the structure and proofs should be transferable using automation.</p>",
        "id": 135299810,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804021
    },
    {
        "content": "<p>On the other hand, one might find oneself in the situation where both sides are already equipped with some structure. In this case both already have a <code>0</code> and a <code>+</code>.</p>",
        "id": 135299853,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804061
    },
    {
        "content": "<p>It is easy to define <code>equiv.rel : A ~= B -&gt; A -&gt; B -&gt; Prop</code></p>",
        "id": 135299854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804068
    },
    {
        "content": "<p>Right, I'm collecting things that you find easy to define (-;</p>",
        "id": 135299861,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804101
    },
    {
        "content": "<p>immediately transferring structures is both more difficult and not necessarily what we want</p>",
        "id": 135299868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804134
    },
    {
        "content": "<p>So, suppose that both have a <code>0</code> and <code>+</code> like in your example.</p>",
        "id": 135299870,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804152
    },
    {
        "content": "<p>I would prefer an expedited method for showing that pre-existing structures are compatible with an equiv</p>",
        "id": 135299910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804168
    },
    {
        "content": "<p>..oh wait, that's group_iso etc</p>",
        "id": 135299911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804177
    },
    {
        "content": "<p>Exactly</p>",
        "id": 135299912,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804182
    },
    {
        "content": "<p>so problem solved?</p>",
        "id": 135299913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804190
    },
    {
        "content": "<p>So we show that <code>to_xnat</code> is an <code>add_monoid</code> iso. And then?</p>",
        "id": 135299917,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804210
    },
    {
        "content": "<p>Then there should be an easy way to extract those <code>rel</code>-lemmas</p>",
        "id": 135299921,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804224
    },
    {
        "content": "<p>oh yes, that's a one liner</p>",
        "id": 135299926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804233
    },
    {
        "content": "<p>rel for add is literally map_add with some dressing</p>",
        "id": 135299927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804247
    },
    {
        "content": "<p>After that, proving that <code>xnat</code> is a <code>comm_monoid</code> should be <code>by transfer</code>.</p>",
        "id": 135299928,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804259
    },
    {
        "content": "<p>Or something like that.</p>",
        "id": 135299930,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804273
    },
    {
        "content": "<p>we could put that in the theorems for group_iso</p>",
        "id": 135299931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804281
    },
    {
        "content": "<p>But I am wary about <em>constructing</em> structure using <code>transfer</code></p>",
        "id": 135299972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804296
    },
    {
        "content": "<p>you might use <code>transfer</code> to prove that the addition is commutative, like I showed, but the definitions themselves should stand on their own</p>",
        "id": 135299975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804334
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">rel_zero</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_succ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">rel</span><span class=\"o\">)</span> <span class=\"n\">xnat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">m</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩;</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_one</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_add</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">rel</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">m</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩</span> <span class=\"n\">n</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩;</span> <span class=\"n\">apply</span> <span class=\"n\">to_xnat_add</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">rel_eq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">iff</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">=</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">=</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">m</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩</span> <span class=\"n\">n</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟩;</span> <span class=\"n\">exact</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">of_to_xnat</span><span class=\"o\">]</span> <span class=\"kn\">using</span> <span class=\"n\">congr_arg</span> <span class=\"n\">of_xnat</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">congr_arg</span> <span class=\"bp\">_⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">bi_total</span> <span class=\"n\">rel</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">to_of_xnat</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩⟩</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">xnat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">transfer</span><span class=\"bp\">.</span><span class=\"n\">transfer</span> <span class=\"o\">[</span><span class=\"bp\">``</span><span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">rel_forall_of_total</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">rel_eq</span><span class=\"o\">,</span> <span class=\"bp\">``</span><span class=\"n\">rel_add</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>I would wish that this could all be compressed into 2 or 3 lines.</p>",
        "id": 135299981,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804371
    },
    {
        "content": "<p>I don't think it needs to, it can be done in generality</p>",
        "id": 135299983,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804401
    },
    {
        "content": "<p>the stuff about applying <code>transfer.transfer</code> is not nice though, it should be easier than that</p>",
        "id": 135300030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804428
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Why are you cautious about <code>transfer</code>ing structure?</p>",
        "id": 135300039,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804475
    },
    {
        "content": "<p>because it leads to bad definitional reduction</p>",
        "id": 135300041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804493
    },
    {
        "content": "<p>there are very few cases when it is the right thing to do</p>",
        "id": 135300044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804511
    },
    {
        "content": "<p>Hmmm, maybe I'm sad about that. I would have to see how it turns out in practice...</p>",
        "id": 135300094,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804626
    },
    {
        "content": "<p>I would wish that if someone inadvertently defined <code>xnat</code>, then we could just say: \"Aaah, that's <code>equiv</code> to <code>nat</code>. Bam!!! from now one it is a <code>comm_semiring</code> and you can use all theorems about <code>nat</code> for your <code>xnat</code>.\"</p>",
        "id": 135300134,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804694
    },
    {
        "content": "<p>Hmm, I want to use more.</p>",
        "id": 135300144,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804734
    },
    {
        "content": "<p>I want to use that it is not just some random <code>equiv</code>. I want to use that they are structurally equivalent. Is that a thing?</p>",
        "id": 135300182,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804765
    },
    {
        "content": "<p>They are the <em>same</em> inductive type.</p>",
        "id": 135300186,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804788
    },
    {
        "content": "<p>But I'm getting distracted, I think.</p>",
        "id": 135300187,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804803
    },
    {
        "content": "<p>So you're interested in duplicated definitions, not e.g. <code>nat</code> vs. <code>binnat</code>?</p>",
        "id": 135300193,
        "sender_full_name": "Scott Olson",
        "timestamp": 1538804845
    },
    {
        "content": "<p>Well, not really. Like I said, I was getting distracted.</p>",
        "id": 135300234,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804922
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Ok, I think I know what I want. I want you to remove every mention of <code>rel</code> in your example.</p>",
        "id": 135300239,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804947
    },
    {
        "content": "<p>That's the key part that makes transfer work</p>",
        "id": 135300240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804974
    },
    {
        "content": "<p>In the proof that addition is commutative, I want to invoke <code>big_transfer</code></p>",
        "id": 135300241,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804981
    },
    {
        "content": "<p>you could remove everything else</p>",
        "id": 135300242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538804982
    },
    {
        "content": "<p>And it will ask me for a <code>rel</code></p>",
        "id": 135300243,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538804996
    },
    {
        "content": "<p>And I will answer: use this <code>equiv</code></p>",
        "id": 135300279,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805003
    },
    {
        "content": "<p>but it is a logical relations proof, not a rewrite proof</p>",
        "id": 135300283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805006
    },
    {
        "content": "<p>That's fine, I think</p>",
        "id": 135300287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805023
    },
    {
        "content": "<p>And then it says: Good. But then you need to prove these goals: <code>rel_zero</code>, <code>rel_add</code>.</p>",
        "id": 135300288,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805033
    },
    {
        "content": "<p>the user layer can handle that</p>",
        "id": 135300289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805036
    },
    {
        "content": "<p>And it generates those two goals. And I prove them with <code>tidy</code>.</p>",
        "id": 135300290,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805051
    },
    {
        "content": "<p>But the user layer here <em>really</em> needs work</p>",
        "id": 135300291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805060
    },
    {
        "content": "<p>there is nothing, it's not even an interactive tactic</p>",
        "id": 135300297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805071
    },
    {
        "content": "<p>And there you have a 4 line tactic proof of commutativity. And all the other stuff above is gone.</p>",
        "id": 135300298,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805074
    },
    {
        "content": "<p>Aaah...!</p>",
        "id": 135300301,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805083
    },
    {
        "content": "<p>When I asked whether there was a tactic for <code>transfer</code>, you said \"Yes\". And I immediately assumed it was interactive.</p>",
        "id": 135300303,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805112
    },
    {
        "content": "<p>Lol</p>",
        "id": 135300304,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805113
    },
    {
        "content": "<p>For me tactic implies interactive. Silly me.</p>",
        "id": 135300343,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805128
    },
    {
        "content": "<p>In the int.basic example, there is a local redefinition of <code>transfer</code> to get the big list of relevant rel theorems for this particular relation</p>",
        "id": 135300344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805130
    },
    {
        "content": "<p>because it is often the case that you will want to use the same relation, or pair of structures, in multiple nearby proofs</p>",
        "id": 135300345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805158
    },
    {
        "content": "<p>in <code>int.basic</code> it is of course used for each of the axioms of the ring structure</p>",
        "id": 135300350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805193
    },
    {
        "content": "<p>But, can a tactic automatically infer what it needs to know about a relation, given a certain goal?</p>",
        "id": 135300351,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805196
    },
    {
        "content": "<p>no, it doesn't even know the target</p>",
        "id": 135300352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805217
    },
    {
        "content": "<p>For example in my mockup I have a goal on <code>xnat</code> and I said <code>transfer</code> with no info</p>",
        "id": 135300391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805251
    },
    {
        "content": "<p>how would it know that I am transferring to <code>nat</code> instead of something else? and why that relation instead of something else?</p>",
        "id": 135300393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805280
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">begin</span>\n  <span class=\"n\">interactive</span><span class=\"bp\">.</span><span class=\"n\">transfer</span> <span class=\"n\">my_equiv</span><span class=\"bp\">.</span><span class=\"n\">to_rel</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- prove rel_zero },</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- prove rel_add }</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 135300401,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805309
    },
    {
        "content": "<p>Would that be possible?</p>",
        "id": 135300403,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805315
    },
    {
        "content": "<p>I think we will need to rewrite transfer anyway, I very much doubt the one in core works well enough for our purposes</p>",
        "id": 135300408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805352
    },
    {
        "content": "<p>(at least we should copy it to mathlib and give it a nice front end)</p>",
        "id": 135300449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805374
    },
    {
        "content": "<p>That would be possible, but like I said you want more reuse than that</p>",
        "id": 135300452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805395
    },
    {
        "content": "<p>Cool</p>",
        "id": 135300454,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805400
    },
    {
        "content": "<p>that might prove your theorem now, but in the very next theorem you will probably want this relation again and you would have to prove <code>rel_zero</code> again</p>",
        "id": 135300470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805451
    },
    {
        "content": "<p>Yes, the VScode \"Turn this goal into lemma\" keyboard-shortcut will take care of the reuse.</p>",
        "id": 135300471,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805454
    },
    {
        "content": "<p>I don't think we have to worry about proof obligations much here</p>",
        "id": 135300515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805502
    },
    {
        "content": "<p>It will take everything between a pair of <code>{ .. }</code> and turn it into a proof of the subgoal. It will suggest a name for the lemma. And it will apply that lemma where previously the <code>{ .. }</code> were written.</p>",
        "id": 135300516,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805503
    },
    {
        "content": "<p>But I'm getting distracted again <span class=\"emoji emoji-1f606\" title=\"lol\">:lol:</span></p>",
        "id": 135300517,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805521
    },
    {
        "content": "<p>it will usually already have all the info it needs to prove these obligations</p>",
        "id": 135300518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805526
    },
    {
        "content": "<p>Right.</p>",
        "id": 135300526,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805550
    },
    {
        "content": "<p>e.g. if you are proving rel_zero and rel_add that means you have a group iso and so you probably assumed it was a group iso, and so these theorems will already be proven</p>",
        "id": 135300529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805564
    },
    {
        "content": "<p>The main point behind the <code>rel</code> stuff is to build up relations on bigger things, i.e. kernels and short exact sequences</p>",
        "id": 135300570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805625
    },
    {
        "content": "<p>But then <code>interactive.transfer</code> needs to remember that the <code>rel</code> came from an <code>equiv</code>. Then it could use type class search to find those results.</p>",
        "id": 135300572,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805628
    },
    {
        "content": "<blockquote>\n<p>The main point behind the <code>rel</code> stuff is to build up relations on bigger things, i.e. kernels and short exact sequences</p>\n</blockquote>\n<p>This could all be <code>equiv.to_rel</code>, right?</p>",
        "id": 135300573,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805656
    },
    {
        "content": "<p>there is nothing to remember, the relation is explicitly <code>equiv.rel e</code></p>",
        "id": 135300581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805674
    },
    {
        "content": "<p>not sure what you mean by that last bit</p>",
        "id": 135300585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805702
    },
    {
        "content": "<p>But then transfer will have a hard time finding theorems about <code>e</code>, not?</p>",
        "id": 135300586,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805702
    },
    {
        "content": "<p>I meant that to me <code>equiv</code> seems a lot more natural than <code>rel</code>. And usually we will have an <code>equiv</code> floating around. Even for kernels and s.e.s's</p>",
        "id": 135300627,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805745
    },
    {
        "content": "<p>We will have to think about how to discover/supply rel theorems to transfer. Currently it just accepts a big ugly list of names</p>",
        "id": 135300628,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805768
    },
    {
        "content": "<p>Or some <code>Isom</code> in a category. So we will need <code>Isom.rel</code></p>",
        "id": 135300630,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805769
    },
    {
        "content": "<p>Note that rel is a <em>lot</em> more general</p>",
        "id": 135300635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805794
    },
    {
        "content": "<p>The relation need not be an equiv</p>",
        "id": 135300637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805803
    },
    {
        "content": "<p>Yes, I know. I'm not sure if I care</p>",
        "id": 135300638,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805810
    },
    {
        "content": "<p>Almost all of these theorems hold with much weaker assumptions</p>",
        "id": 135300639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805821
    },
    {
        "content": "<p>I suggest that the interactive transfer generates a list of goals.<br>\nThen we can prove <code>by transfer my_rel; tidy</code>.</p>",
        "id": 135300679,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538805856
    },
    {
        "content": "<p>I think it will discharge all its goals</p>",
        "id": 135300684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805901
    },
    {
        "content": "<p>except the main goal</p>",
        "id": 135300691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805911
    },
    {
        "content": "<p>I wonder whether it should deliver its iff statement instead of changing the goal... that way it can apply on hyps too</p>",
        "id": 135300695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538805961
    },
    {
        "content": "<p>I was reading <a href=\"https://www21.in.tum.de/~kuncar/documents/huffman-kuncar-cpp2013.pdf\" target=\"_blank\" title=\"https://www21.in.tum.de/~kuncar/documents/huffman-kuncar-cpp2013.pdf\">https://www21.in.tum.de/~kuncar/documents/huffman-kuncar-cpp2013.pdf</a> again and I saw that Isabelle's transfer can do <code>The transfer proof method can replace a universal with an equivalent bounded quantifier:\ne.g., (∀n::nat. n &lt; n + 1) is transferred to (∀x::int ∈ {0..}. x &lt; x + 1).</code></p>",
        "id": 135301646,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1538808298
    },
    {
        "content": "<p>This sounds suspiciously like the number casting tactic mentioned in this chat earlier</p>",
        "id": 135301653,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1538808322
    },
    {
        "content": "<p>Of course our <code>transfer</code> is based on isabelle's <code>transfer</code></p>",
        "id": 135301695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538808371
    },
    {
        "content": "<p>The number casting tactic uses rewrites instead of logical relations</p>",
        "id": 135301696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538808398
    },
    {
        "content": "<p>Maybe it would be better to use transfer for this ...?</p>",
        "id": 135301698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538808416
    },
    {
        "content": "<p>I think <code>transfer</code> in Lean will want this anyway at some point, so the same machinery may as well do double duty...? I'm unsure of what the implications are</p>",
        "id": 135301754,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1538808577
    },
    {
        "content": "<p>I do like that relations are stronger than rewrites</p>",
        "id": 135301795,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1538808605
    },
    {
        "content": "<p>I'm reading some of the follow-on papers and there are some tactics that automatically generate refinement theorems for converting algorithms over finsets to concrete algorithms over data structures like rb-trees etc</p>",
        "id": 135301800,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1538808637
    },
    {
        "content": "<p>using transfer or derivatives of</p>",
        "id": 135301801,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1538808645
    },
    {
        "content": "<p>it appears someone in Coq wanted to port <code>transfer</code> too: <a href=\"https://arxiv.org/pdf/1505.05028.pdf\" target=\"_blank\" title=\"https://arxiv.org/pdf/1505.05028.pdf\">https://arxiv.org/pdf/1505.05028.pdf</a></p>",
        "id": 135301860,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1538808792
    },
    {
        "content": "<p>example 2 in the coq paper is exactly xnat and nat...</p>",
        "id": 135301861,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1538808821
    },
    {
        "content": "<p>The number casting tactic would be transferring data as well, right? Not only proofs...</p>",
        "id": 135301901,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538808885
    },
    {
        "content": "<blockquote>\n<p>They are the <em>same</em> inductive type.</p>\n</blockquote>\n<p>I remember when I used to go on about this sort of thing. For computer scientists there is a very precise notion of <em>the same</em> and it's asking a lot more than what we have -- it means they are literally the same object -- structurally equal. Two inductive types with canonically isomorphic definitions are just canonically isomorphic, which is a much weaker notion. For each notion of \"the same\" (these groups are \"the same\", these topological spaces are \"the same\") we have to formalise our notion of sameness (e.g. with an equiv or a beefed-up equiv structure with extra proof such as \"...and the maps are also group homomorphisms\") and then understand exactly which constructions descend to equivalence classes. \"The same\" is a fluid concept in mathematics, it is really a bunch of equivalence relations. I discovered in the schemes project that it was very costly to think of the open set <code>U</code> and the open set <code>id'' U</code> (the image of U under the identity map) as \"the same\", because they really were not <em>the same</em>. They were \"equal because of a theorem\" and this is a much weaker statement. Stuff like <code>congr_arg</code> and <code>congr_fun</code> work because <code>eq</code> (which is a random inductive type remember, not at all related to whether things are <em>the same</em>) has a good recursor.</p>",
        "id": 135306619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538819773
    },
    {
        "content": "<p>There was a thread a while ago now, possibly on gitter, where I got extremely frustrated about how <code>U</code> and <code>id'' U</code> could even <em>possibly</em> not be <em>the same</em> and it took a lot of talking from Mario and Kenny to peel me off the ceiling. Once I realised that the correct map from <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"script\">F</mi></mrow><mo>(</mo><mi>U</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}(U)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"script\">F</mi></mrow><mo>(</mo><mi>i</mi><mi>d</mi><mo>(</mo><mi>U</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}(id(U))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span><span class=\"mopen\">(</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> was not <code>id</code> but <code>res</code> all my problems went away.</p>",
        "id": 135306664,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538819892
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mi>d</mi><mo>(</mo><mi>U</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">id(U)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span> are canonically isomorphic in the computer-scientist's version of the category of open sets on a topological space, but the moment you start treating them as <em>the same</em> you get a whole bunch of errors about motives not being type correct which Reid did show me how to fight against if necessary. However these techniques turned out not to be needed once I understood that the canonical isomorphisms were not <code>id</code> but <code>res</code>.</p>",
        "id": 135306746,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538820043
    },
    {
        "content": "<p>In the mathematician's model of this category, these sets are <em>the same</em>.</p>",
        "id": 135306755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538820062
    }
]